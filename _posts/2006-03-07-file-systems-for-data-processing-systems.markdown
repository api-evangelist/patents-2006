---

title: File systems for data processing systems
abstract: A method for dynamically optimizing file systems based on user access patterns or other parameters. According to an embodiment of the present invention, a list of files forming a cluster is first created based on various preset criteria by an application, the list is transmitted to a file system program, and then the file system optimizes allocation of files in a storage medium based on the list. Embodiments of the present invention can be used to rearrange files stored in a storage medium so that files which tend to be used together are stored closer to each other. This can substantially reduce a typical application launch time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07930508&OS=07930508&RS=07930508
owner: Apple Inc.
number: 07930508
owner_city: Cupertino
owner_country: US
publication_date: 20060307
---
The present invention generally relates to data processing systems. More particularly the present invention pertains to a file system of a computer operating system.

A typical data processing system comprises a central processing unit memory and various peripheral devices such as mass storage units. A user s data is usually stored in long term non volatile mass storage devices such as hard disks using magnetic or optical media. One of the main purposes of many data processing systems such as personal computers is to create manipulate store and retrieve data. An operating system or a file system in particular provides the machinery to support these tasks. File systems of modern computers such as HFS or HFS of Apple Macintosh operating system are integral parts of all operating systems and provide a way to organize store retrieve describe and manage information on a permanent or semi permanent storage medium.

The unit of storage in modern block devices such as a hard disk is a so called block. For example storage areas of modern hard disks are typically divided into tracks and sectors which form blocks or physical blocks. A physical block is an area in the storage medium that can be read and saved as a unit and it provides the smallest unit that can be manipulated by the storage device. The typical block size of many modern hard disks is 512 bytes.

Many file systems also manage data on block storage media using blocks or logical blocks. A logical block is often mapped to one or more physical blocks on a hard disk and it is the same size as or integer multiples of the disk block size. Data of a file is generally stored in one or more logical blocks. File systems also store data about a file or its metadata in one or more logical blocks. For example many file system implementations use special or regular blocks on a storage media to store files metadata. In most modern file systems a data structure generally called an inode is used to store a file s metadata. For instance a file s creation time last access time and permission settings and the like are typically stored in the inode associated with the file. An inode often occupies one logical block but it can occupy two or more blocks if the inode grows beyond one logical block size.

It is a well recognized fact in the art that accessing devices like hard disks is orders of magnitude slower than other operations in typical data processing systems. For example central processing units typically found in personal computers have a clock frequency of 1 GHz or higher translating into more than one instruction being performed per each few nanoseconds whereas typical seek times of data stored in hard disks is of the order of 10 milliseconds. The bandwidth of the internal bus for example associated with the system memory is of the order of hundreds of megabytes to gigabytes per second or often much higher whereas the typical value of the bandwidth of IDE or SCSI hard drives is around 20 50 megabytes per second. The primary reason for this discrepancy in speed is that hard disks have mechanical parts. That is to access data the disk needs to be spun and the heads need to be moved to access the target blocks. The seek time to move the disk heads from one part of a disk to another is considerable. Any operation that requires mechanical movement is usually much slower than those that require only electrical switching.

For this reason accessing data that requires less amount of mechanical motion in a hard disk provides much faster access and much higher bandwidth. For example reading or writing contiguous blocks from a disk is much faster than having to seek to access different blocks spread over different areas of the disk. Likewise accessing blocks from the same cylinder group is substantially faster than otherwise because reading successive blocks in a cylinder group only involves switching heads. Switching disk heads is an electrical operation and thus significantly faster than a mechanical operation such as moving the heads.

Modern hard disks hide much of their physical geometries and their internal operations and much of the low level optimization is done at the drive controller level. File systems rely on the drive controllers for many tasks. In many file systems the block storage device is abstracted into an array of logical blocks. File systems then manage the block array and the device controllers do the actual working including mapping of the logical blocks into the corresponding physical blocks. In this disclosure we will often use this level of abstraction for the sake of clarity. However as will be apparent to people of ordinary skill in the art the present invention can be understood and practiced at many different levels.

As an illustration a schematic drawing of a logical structure of a storage medium such as a hard disk or a compact disc CD is shown in . The medium is divided into multiple blocks which are not explicitly shown in the figure. Each block in this example can be viewed either as a logical allocation block or as a set of contiguous such blocks possibly representing a file or a directory content or metadata. Certain regions of the medium in the figure are marked with hashed rectangles . These rectangular regions represent blocks storing files or directories or their metadata i.e. inodes. The figure shows five such regions labeled from A to E.

In order to illustrate the file access times and their dependence on the file arrangement on the storage medium two exemplary file access scenarios are shown in . In this example it is assumed for the purposes of illustration that the file access or seek time is simply proportional to the sum of the distance between the locations in the block array of any consecutively accessed files. In the scenario of files are accessed sequentially based on the arrangement of the files on the medium. Their total access or seek time equals to 10.0 in an arbitrary unit.

In the prior art files and directories are stored without regard to this consideration. As an example show typical mappings between a file or directory hierarchy and the corresponding file arrangement in a storage medium or in a logical block array. The top portion of illustrates an exemplary directory structure in a hierarchical file system such as HFS of the Apple Macintosh operating system. The tree in the figure has nine nodes labeled A through I. Four of them A B C and F represent directories whereas the rest leaf nodes represent files. The drawing at the bottom of the figure illustrates a logical representation of the block array in a file system for the nodes in tree . The files and directories shown in the file tree are arranged in a particular order in this block array. For simplicity we assume that they are inode blocks of the corresponding files and directories and that each inode occupies one block . The array also shows a region of empty blocks . The particular ordering shown in the figure is based on depth first arrangement and it is not in any way optimized in the sense illustrated with regards to . Note that the particular arrangement shown in might be viewed as an example after installation of a new operating system on a new computer or the installation of new software e.g. a new Web browser on an existing already used computers.

Once the system is used however the file arrangement changes on the storage medium. For example some existing files and directories may be deleted and some new files and directories may be added. Furthermore certain files and directories may be moved to different locations. shows an exemplary directory structure based on that of after some time of use. As is apparent from this pair of figures certain files have been deleted and some new files have been added during this intervening time period. More specifically directories D and F and files H and I from the tree of have been deleted and new directories J and K and new files L and M have been added. The new tree structure reflects these changes. The bottom drawing in illustrates a logical representation of this new block array which reflects the way the data is stored on a physical medium. The updated list of files and directories from the file hierarchy is shown in this block array representation with the same labels. Note that in this case the occupied blocks are fragmented and spread over the empty block regions . Therefore at least for the reasons given with respect to a typical access or seek time in will usually be much larger than that of the block array shown in for a typical file access pattern. This often translates into slower application launch and longer response time in terms of user interaction. Degradation of performance after some time of use is typical in the implementations of the prior art. It should be noted that file data or file metadata may not be physically removed when the corresponding file is deleted from the file hierarchy. In some implementations of file systems deleted files and directories may remain on the storage medium and may be made simply inaccessible.

There has been much effort to reduce file access times from block storage media. There are for example prior art applications that defragment file allocations in the storage medium which are widely available in some of the popular platforms such as the NTFS file system of Microsoft Windows operating system. However they are limited to defragmenting file contents stored in multiple regions That is defragmentation in the prior art attempts to gather the blocks storing the content of a single file to a contiguous single region.

In some cases file contents are cached or pre loaded into memory to speed up the application launch. However this type of implementation does not directly address the issue of block arrangement in storage media and its effect on the application or file access times.

The present invention provides a system for optimizing a file system performance. A file system manages mass storage devices and in particular it stores organizes describes and retrieves data or information stored in storage media of the mass storage devices such as hard disk drives. Much of disk access time is spent in seeking blocks storing the data or the metadata of files or directories in file systems. The present invention relates to a method and an apparatus for optimizing file systems by rearranging file data or metadata in block storage media.

In an embodiment of the present invention an application or utility program and the file system of an operating system collaborate with each other to optimize the file allocations in storage media for example in order to reduce the average file access times. First the application analyzes file access patterns based on various criteria and it creates a request to the file system. Then the file system optimizes allocation of files and directories in the storage media based on the request.

According to one aspect of an embodiment of the present invention an application program creates a list of files based on the user access patterns of files and directories and or based on other parameters. Each file list may be generated based on the proximity of the files to each other in terms of various attributes associated with files and directories such as last file access times and it provides information regarding a group of files that form a cluster. The term cluster is used in this context to indicate a group of loosely related files which are likely to be accessed or used together in a given time window. In some embodiments a user or utility software may define clusters of files based on some additional information. Once one or more such file lists are constructed they are transmitted to the file system program. In one embodiment these cluster lists are transmitted one at a time. In another embodiment these lists are first collected by going through the whole file hierarchy and a set of lists is transmitted at the end of each traversal.

According to embodiments of the present invention the file system optimizes allocation of files in a storage medium based on the transmitted list or set of lists. In some embodiments this is done by allocating files from the same cluster in the nearby physical region in a storage medium.

At least one embodiment of the present invention utilizes virtual inode tables. A virtual inode table maintains a mapping between inodes and the blocks storing the corresponding inodes in an indirect way. This allows the file system to rearrange physical inode blocks without affecting application programs which rely on the constancy of the inode block mapping.

Embodiments of the present invention can be used to rearrange files stored in a storage medium so that files which tend to be used together are physically stored closer to each other. This can substantially reduce the average time for accessing related group of files for example during the initial launch of an application.

The present invention will now be described more fully hereinafter with reference to the accompanying drawings in which various exemplary embodiments of the invention are shown. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be evident however to one skilled in the art that the present invention may be practiced without these specific details. Like numbers refer to like elements throughout.

At least certain embodiments of the present invention provide a system for dynamically optimizing a file system performance. A file system manages mass storage devices and in particular it stores organizes describes and retrieves data or information stored in storage media of the mass storage devices such as hard disk drives on behalf of other applications or system processes. It has been recognized that much of disk access time is spent in seeking blocks storing the data or the metadata of files or directories in file systems. Embodiments of the present invention relate to a method and an apparatus for optimizing file systems by rearranging file data or metadata in block storage media in order to reduce the seek times of files and directories. In the following discussion the word file will be often used to denote both files and directories unless otherwise indicated. In some current file systems directories are files. In some other file system implementations directories might have different internal representations than those of files.

As can be easily recognized from the figure certain files are typically accessed together. For example files F and F and files F and F are accessed within a short time window as indicated in the figure. This may be due to the fact that these files are associated with the same applications. In this oversimplified example the files F and F and the files F and F happen to be closely related in the file hierarchy as shown in . However this may not be the case in general. The last access times for these seven files are tabulated in . Note that these last access times summarized in the table correspond to the numbers shown in parentheses in and to the filled circles in the diagram of .

In embodiments of the present invention the file system is optimized by rearranging file data or metadata or both in block storage media such that it reduces the seek times of files and directories in a typical case of file access. According to an embodiment of the present invention an application or utility program and the file system of an operating system collaborate with each other to optimize the file allocations in storage media. First the application analyzes file access patterns based on various criteria and it creates a request to the file system. Then the file system optimizes the storage media based on the request. A block array representation of an exemplary file arrangement according to an embodiment of the present invention is shown in . The blocks representing the files through are marked with hashed rectangles in the figure. In this example files have been arranged such that the total seek time is minimal or near minimal for a particular access pattern namely F F F F F F and then F. The assumption is that the files will be typically accessed in a way closely resembling the previous access patterns for example as shown in .

File attributes other than last access times can also be used for this purpose. For example shows a typical pattern for accessing files and directories in a two dimensional attribute diagram. The last file access time is drawn horizontally with time increasing from left to right. The vertical axis on the other hand represents a depth or level of each file or directory in a hierarchical directory structure. The diagram shows three levels and corresponding to different levels of a tree shown in . The small rectangular boxes indicate file access at specified times. Files can be clustered based on these two or any other additional attributes.

In general any attribute associated with files and directories can be used for clustering purposes. According to an embodiment of the present invention relevant attributes are first selected based on various criteria. Then each file and directory is plotted either explicitly or implicitly on this attribute space. shows a schematic drawing of distribution of files in a two dimensional attribute space comprising Attr. 1 and Attr. 2 . These attributes are assumed to have real values in this example. Some attributes however may take only discrete values. Each circular dot in the figure represents a file or directory in the file system. As illustrated in the figure the distribution of the files is typically non uniform and files are more or less clustered into groups. In particular the exemplary distribution of includes two rather clearly defined clusters and which are marked with broken lines. Embodiments of the present invention use this distribution and clusters for optimizing files systems. The grouping or clustering or files can be done using various clustering algorithms known in the related art. For example K means or Hierarchical clustering algorithms may be used.

According to at least one embodiment of the present invention the clustering request is processed by the file system. In some embodiments files belonging to the same cluster in a request are rearranged in a block array so that they are stored together in a nearby physical region of the storage device. In some other embodiments the file system may implement more complicated algorithms. For example the file system may maintain additional attributes or classes of files and directories and files are reallocated within predetermined constraints. One such example is shown in . The exemplary block array shown in the figure is divided into multiple regions. In particular it shows four distinct regions . Each region is used to store a particular group of files which meet certain preset criteria. For instance the block array in this example shows four such regions corresponding to applications shared libraries and system files. Note that the application group is distributed over multiple regions and in this illustration.

With respect to the block diagram shows a high level relationship among various software programs or components running on typical data processing systems such as Apple Macintosh personal computers. The diagram shows two distinct components an operating system and other application programs . An operating system may comprise more than one file systems as indicated by multiple FS blocks in the figure. In some operating systems additional abstraction layer may be used to manage diverse file systems which is commonly called a virtual file system in the related art. In many computer systems the software programs are categorized into two groups Kernel level and application level. Operating systems tend to comprise both types of programs whereas non operating system programs typically run only at the application level. Much of the functionalities of many file systems are implemented at the kernel level as shown in the diagram because they require special privileges to access protected resources in the system. The framework included at the application level in component includes various common libraries and shared files that can be utilized by applications. Common GUI controls for example are a part of the framework in this illustration. Note that this example is for illustrative purposes only and should not be taken literally. For example some framework functionalities might be implemented at the kernel level.

In an embodiment of the present invention one software component typically an application or utility program either from or from of and another software component typically a file system of an operating system from collaborate with each other to optimize the file allocations in storage media for example in order to reduce the average file access times. According to one aspect of an embodiment of the present invention the first software component creates a list of files based on the user access patterns of files and directories and or based on other parameters. Each file list is generated for example based on clustering in the space of selected attributes as in . In some embodiments the clustering is done in an ad hoc way for instance based on user input or on other predetermined settings. Once one or more such file lists are constructed they are transmitted to the second software component. In one embodiment these cluster lists are transmitted one at a time. In another embodiment one or more such lists are transmitted together at appropriate times. According to an embodiment of the present invention the second software component that manages either directly or indirectly a block storage medium such as the file system optimizes allocation of files in the storage medium based on the transmitted list or set of lists. In some embodiments this is done by rearranging or clustering files from the same list or cluster in a nearby region in the storage medium for example as illustrated in . It should be noted that the term clustering is used in both contexts in this disclosure as is common in the related art. That is clustering sometimes refers to grouping of files in a logical sense based on certain attributes associated with the files and it in other times refers to reallocating blocks so that related files and directories are stored in nearby physical regions in a block storage medium. The appropriate meaning however should be clear to skilled artisans in the related art based on the context.

Turning now to an exemplary embodiment of the present invention is illustrated as a flow chart. As shown in the chart the embodiment involves the aforementioned two software components indicated simply as first and second components in the figure and it comprises the following two main operational elements 1 Generating a list of files to be clustered by the first software component as shown in block based on some preset clustering algorithm and 2 relocating or clustering files and directories in a block storage medium by the second software component as indicated in block based on the request by the first software component. In some embodiments the request is considered a suggestion or hint and the second software component may or may not fully oblige to the request by the first component. As alluded earlier the first software component is an application or utility program implemented either as a stand alone program or as a part of the operating system in some embodiments. The role of the second software component is typically assumed by a file system software of the operating system. However some or all of the functionalities discussed in the context of the second software component may be implemented by other types of softwares. For example a device driver for a block device can be used for this purpose. Or its entire implementation may be made to run in the block device itself in some embodiments for example as a firmware. It should be noted that the present invention might be embodied as a single software component. Or it can be embodied with more than two components. Reference to the two software components throughout the discussion of various embodiments in the following description should not be construed as limitations of embodiments of the present invention.

Once the file system receives the request it typically queues or otherwise stores the request for later processing as in the example of . In some embodiments the request might be processed as soon as it is received which is assumed to be the case in this particular embodiment. According to at least one embodiment of the present invention this processing operation comprises rearranging files and directories in a block storage medium as indicated in blocks and . This will be further discussed later with regards to .

With reference to exemplary processes of creating clustering requests by the first software component are illustrated in some detail. According to the embodiment shown in the first software component e.g. an application or utility program goes through all or some subset of the files and directories in a file hierarchy in a particular order e.g. using a depth first search in the directory tree and finds the files and directories that meet a certain preset criterion as indicated by blocks and . When a file or directory that meets the criterion is found it is included in a list at which has been created or reset at block . Once the number of files and directories in the list reaches a certain preset size or all files and directories in the file system have been traversed as indicated by the Yes branch in block a clustering request is constructed based on the current list and it is then sent to the file system at .

The first component comprises two operations in this illustration Receiving the request from other software components and storing the received requests using a data structure such as a queue. The stored requests are processed later as illustrated in the second block either at a specified time or in response to other events or based on any preset conditions. The second component includes a loop blocks and which comprises an operation for processing of one or more clustering requests or one or more file lists contained in any request. If the processing of the currently received requests are done as indicated by the Yes branch at the decision block this portion of the process terminates and it waits for any additional clustering requests as shown in block .

Referring now to a flow chart is shown illustrating various elements of application side clustering in an embodiment of the present invention. The files and directories are traversed in some predetermined order in this example such as depth first or breadth first traversals in the directory hierarchy. Or the files and directories can be arranged based on various attributes for example as shown in and traversed in a certain predetermined order in this space. The exemplary method of begins by reading the last file access times starting from a leaf node at a certain depth of the directory hierarchy as indicated by block . Next files and directories are collected for example based on certain proximity relationships among them into a file list as shown in block . This operation may also comprise for example on line versions of more formal clustering similar to that illustrated with respect to in some embodiments. The list is then sent to the file system at and the process continues as indicated in block

At least one embodiment of the present invention utilizes aforementioned virtual inode tables. A virtual inode table maintains a mapping between inodes and the blocks storing the corresponding inodes in an indirect way. This allows the file system to rearrange physical inode blocks without affecting other programs which rely on the constancy of the inode block mapping.

With respect now to shows a structure of a typical directory entry dentry in a prior art whereas shows a new dentry structure used in some embodiments of the present invention. The first column from each table shows files and directories contained in the directory that the table is associated with. The second column of the dentry of shows the block address of inode table for the corresponding file or directory where file or directory metadata is stored. On the other hand as illustrated in the new data structure includes a level of indirection as can be seen by three column format. The inode pointer or virtual inode shown on the second column in this example points to the real inode shown on the third column. shows another way of representing this indirection using two tables and . In this example the two tables are coupled by sharing virtual inodes which is in the second column of the first table and the first column of the second table .

As will be appreciated by one of skill in the art the present invention may be embodied as a method data processing system or program product. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment combining software and hardware aspects. Furthermore the present invention may take the form of a computer program product on a computer readable storage medium having computer readable program codes embodied in the medium. Any suitable storage medium may be utilized including hard disks CD ROMs DVD ROMs optical storage devices or magnetic storage devices. Thus the scope of the invention should be determined by the appended claims and their legal equivalents and not by the examples given.

As shown in the computer system which is a form of a data processing system includes a bus which is coupled to a microprocessor s and a memory such as a ROM read only memory and a volatile RAM and a non volatile storage device s A. The CPU may be a G3 or G4 microprocessors from Motorola Inc. or one or more G5 microprocessors from IBM. The system bus interconnects these various components together and also interconnects these components and A to a display controller and display devices and to peripheral devices such as input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art. Typically the I O devices are coupled to the system through I O controllers . The volatile RAM random access memory is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory. The mass storage A is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD ROM or other types of memory system which maintain data e.g. large amounts of data even after power is removed from the system. Typically the mass storage A will also be a random access memory although this is not required. A block type mass storage device comprises one or more block storage media. While shows that the mass storage A is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art. In one embodiment the I O controller s includes a USB universal serial bus adapter for controlling USB peripherals and an IEEE 1394 i.e. firewire controller for IEEE 1394 compliant peripherals. Mass storage devices B may also be coupled to the system through I O controllers . The display controllers may include additional processors such as GPUs graphical processing units and they may control one or more display devices .

It will be apparent from this description that aspects of the present invention may be embodied at least in part in software. That is the techniques may be carried out in a computer system or other data processing system in response to its processor such as a microprocessor executing sequences of instructions contained in a memory such as ROM or RAM mass storage A and B or a remote storage device. In various embodiments hardwired circuitry may be used in combination with software instructions to implement the present invention. Thus the techniques are not limited to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by the data processing system. In addition throughout this description various functions and operations are described as being performed by or caused by software codes to simplify the description. However those skilled in the art will recognize what is meant by such expressions is that the functions result from execution of the code by a processor such as the CPU unit .

