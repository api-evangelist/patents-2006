---

title: Multi-level read caching for multiplexed transactional logging
abstract: A transactional logging service is provided to user-mode and kernel-mode log clients by utilizing a marshalling area to buffer a set of log records that a log client assembles into a log stream. Disk I/O (input/output) functionality is then separately brokered using a kernel-mode address space for a single dedicated physical log, or virtual logs multiplexed to a single log, which is written to stable storage that contains log records from across all of the log streams. Physical log writes are handled by a shared log flush queue and physical log reads are provided by a file system cache that underlies the service. A multi-level cache hierarchy is utilized when a log client needs to access a log record. A series of caches are queried in order of increasing latency until the targeted log record is located. The target log record is only read from disk in the event that it missed at each cache in the hierarchy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08074027&OS=08074027&RS=08074027
owner: Microsoft Corporation
number: 08074027
owner_city: Redmond
owner_country: US
publication_date: 20061204
---
Transactional logging involves maintaining a transactional log that durably records a time serial history of transactions in a system. The transactional log provides information for restoring a system to a particular state in time prior to a system failure. A transactional logging system must be able to reliably and accurately restore logging functionalities after such a system failure. Most conventional transactional logging systems implement a read cache in the user address space to help reduce the latency of the round trip to disk to read log records. Typically read caches exploit the inherent sequential nature of logs and pre fetch large amounts of data into their read caches. In many traditional systems multiple log clients i.e. recipients of a logging service exist and each log client consumes virtual memory and working set quota which equal the size of its read cache. In addition because the read cache is stored in the application s address space it has to be replicated for every open instance of a log file or stored in user mode shared memory.

While many current transactional logging systems are typically very robust and achieve a satisfactory performance level the read caches utilized for multiple log clients can consume a significant amount of resources. Overall performance of the computing environment in which a multi client transactional system is operating can be substantially impaired as a result of paying for the overhead and memory costs associated with the read caches.

This Background is provided to introduce a brief context for the Summary and Detailed Description that follows. This Background is not intended to be an aid in determining the scope of the claimed subject matter nor be viewed as limiting the claimed subject matter to only those implementations that may solve any or all of the disadvantages or problems presented above.

A transactional logging service is provided to user mode and kernel mode log clients by utilizing a marshalling area to buffer a set of log records that a log client assembles into a log stream. Disk I O input output functionality is then separately brokered using a shared kernel mode address space for a single dedicated physical log or virtual logs multiplexed to a single log which is written to stable storage that contains log records from across all of the log streams. Physical log writes are handled by a shared log flush queue and physical log reads are provided by a file system cache that underlies the service.

A multi level cache hierarchy is utilized when a log client needs to access a log record. A series of caches are queried in order of increasing latency until the targeted log record is located. These caches include respectively 1 the current read buffer in the marshalling area 2 the current write buffer if any in the marshalling area to which log records are being written 3 the shared log flush queue and 4 the file system cache. The target log record is only read from disk in the event that it is missed i.e. is not located at each cache in the hierarchy.

In various illustrative examples a kernel mode driver called a Common Log File System CLFS driver manages the log flush queue to thereby implement a single physical log file. A set of log records is multiplexed from log streams from the marshalling buffers from one or more log clients into the shared log flush queue and then flushed to the single physical log file on stable storage. The CLFS driver interacts with user mode and kernel mode application programming interfaces APIs that respectively provide log file objects and log handles for the clients to marshal log records into virtual logs that form the log streams. In addition the CLFS driver maps non contiguous log sequence numbers LSNs used to uniquely identify log records from the physical log to a contiguous address space in the file system cache. The mapping is performed by determining an offset in bytes between a reference point in the physical log called a cache base LSN and a log record of interest.

The present multi level read caching for transactional logging provides read and write log caching that appears to the log clients as a conventional transactional logging system with all of the same functionality. However available memory e.g. virtual memory is more efficiently and economically utilized because only logs being actively read or queued in the shared log flush queue consume memory which substantially reduces the size of the overall log cache footprint. Delegation of physical log reads to the underlying file system cache advantageously enables further memory optimization at the system level to improve overall computer system performance while still maintaining the benefits of log caching. In addition after a system recovery the cache hierarchy is repopulated in bottoms up order so that the transactions in the logs cached in the file system cache are handled first which improves system recovery performance.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. The benefits and advantages noted in this Summary are not intended to limit the claimed subject matter to only those implementations that contain those benefits or advantages. In addition this Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Transactional systems include database management systems messaging systems such as store and forward systems transaction managers transaction files systems and online transactional processing systems. A single logical operation on data in such systems is called a transaction. Key transactional processing properties are commonly identified by the acronym ACID which stands for Atomicity Consistency Isolation and Durability. Conforming with ACID properties generally ensures that transactions are processed reliably and durably.

One method for implementing the ACID properties involves the use of a transactional log. A transactional log may comply with the popular ARIES Algorithms for Recovery and Isolation Exploiting Semantics in which case it is called an ARIES log. Typically ARIES implements write ahead logging WAL where any change to an object is first recorded in the log and the log is written to stable storage e.g. a disk before the changes to the object are implemented. Thus changes to the object and transactions in general are capable of being rolled back or undone. Thus ARIES logs are commonly utilized in system recovery and restoration situations so that transactional systems may be brought back to the state in which they were operating before a system failure.

Turning now to the drawings in which like reference numerals indicate like elements is a simplified block diagram of an illustrative computer system such as a personal computer PC or server with which the present multi level read caching for transactional logging may be implemented. Computer system includes a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer system such as during start up is stored in ROM . The computer system may further include a hard disk drive for reading from and writing to an internally disposed hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD compact disc DVD digital versatile disc or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the computer system . Although this illustrative example shows a hard disk a removable magnetic disk and a removable optical disk other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks data cartridges random access memories RAMs read only memories ROMs and the like may also be used in some applications of the present dynamic database memory management. In addition as used herein the term computer readable medium includes one or more instances of a media type e.g. one or more magnetic disks one or more CDs etc. .

A number of program modules may be stored on the hard disk magnetic disk optical disc ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer system through input devices such as a keyboard and pointing device such as a mouse. Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers. The illustrative example shown in also includes a host adapter a Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The computer system is operable in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be selected as another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer system although only a single representative remote memory storage device is shown in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are often deployed for example in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the local area network through a network interface or adapter . When used in a WAN networking environment the computer system typically includes a broadband modem network gateway or other means for establishing communications over the wide area network such as the Internet. The broadband modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules related to the computer system or portions thereof may be stored in the remote memory storage device . It is noted that the network connections shown in are illustrative and other means of establishing a communications link between the computers may be used depending on the specific requirements of an application of database memory management.

A server communicates with a plurality of client computers . . . over a network e.g. local area network as shown in . Note however that remote logging by the client computers is an optionally utilized functionality as the present multi level read caching for transactional logging is applicable to either local or remote logging or combinations thereof. In this illustrative example the server and clients are each implemented using a computer system that is arranged with similar features and functionalities as computer system shown in and described in the accompanying text. More specifically server is arranged to host an operating system that includes a kernel mode driver which in this illustrative example is called a common log file system CLFS driver .

CLFS driver is a component that in combination with kernel mode and user mode APIs application programming interfaces as described below provides logging services to a number of log clients in the network environment . In this illustrative example the provided logging services are ARIES compliant. However the CLFS driver and associated APIs are not limited to supporting ARIES and may be used in a variety of logging scenarios.

Log clients and N are indicated by reference numerals in . Log clients may include applications drivers threads or other units of software that use a transactional log.

Each log client is shown in as having an associated virtual log . The logs are virtual in the sense that each log client is provided with a log that appears and functions as a client s own dedicated log even though only a single common physical log is managed by CLFS driver . In this illustrative example the physical log contains multiplexed log records from the plurality of log clients . In most applications such multiplexing provides an effective method for providing robust logging services on a memory efficient basis and is thus generally preferred. In particular the present paradigm overcomes many of the shortcomings of multiplexed transactional logging which have proven to be very difficult to address. Here a single methodology may be consistently applied to either or both multiplexed and dedicated logs to advantageously provide high performing and flexible log caching to simultaneous user mode and kernel mode log clients. Although this illustrative example uses a multiplexed physical log file the choice of usage of dedicated or multiplexed logs will typically be made according to the requirements of a specific application of transactional logging.

As shown in virtual logs and indicated by reference numerals are coupled to the CLFS driver at the kernel mode level through network connection . In addition the Nth client is commonly disposed in server and is coupled to the CLFS driver in kernel mode. The 4th client is also commonly disposed in server and is coupled to the CLFS driver in user mode. Accordingly log clients are considered kernel mode log clients and log client is considered a user mode client.

CLFS architecture functions to marshal log records generated by the log clients into virtual logs and then reliably read them back. Log records in the virtual logs are sequenced into log streams and written to stable storage in the form of log I O blocks which are buffers for the log records . The log clients are thus enabled with the ability to accurately repeat history after recovery from a system failure or system restart. In addition CLFS architecture enables user mode and kernel mode clients to create open log files expand and shrink them delete them and marshal log records to and from client defined buffers in a marshalling area. The marshalling area is an abstraction provided by APIs and to respective kernel mode log clients and user mode log clients.

Architecture is divided into user mode and kernel mode . Kernel mode is the processor access mode in which operating system components and drivers run. Kernel mode processes can directly access system data and hardware and are not restricted like user mode processes. Performance sensitive drivers and services run in kernel mode to interact with hardware more efficiently. All kernel mode components are fully protected from applications running in user mode.

User mode is the processor access mode in which applications and subsystems run on the computer system e.g. computer system in in user mode. Processes that run in user mode do so within their own virtual address spaces. They are restricted from gaining direct access to many parts of the system including system hardware memory not allocated for user mode and other portions of the system that might compromise system integrity.

CLFS architecture is arranged to cleanly separate the marshalling function from the physical I O to disk. This is accomplished by maintaining a separate marshalling area for each log client with its own address space. Marshaled log I O blocks for each of the client s log files are queued for stable storage through a single shared and centrally managed log flush queue not shown . APIs and control the respective marshalling of log records into log I O blocks and the migration of log I O blocks to and from the log flush queue for kernel mode and user mode log clients.

In user mode the user mode API passes references to log I O blocks shown as a single representative log I O block in to the log flush queue managed by CLFS driver using I O request packets IRPs on a log file handle to an I O manager . CLFS driver provides handlers for each type of I O request and schedules the log I O block on the log flush queue for writing to the physical log in the proper order across all the virtual logs . Kernel mode operations are arranged in this illustrative example to bypass the I O manager and manipulate log file objects directly through the kernel mode API using an API call . Accordingly log I O blocks shown as a single representative log I O block in from kernel mode log clients are scheduled on the log flush queue.

An abstract object called a container is used to present an underlying file system such as the NTFS file system in the Windows operating system to the CLFS architecture and log clients to thereby normalize all I O operations. Containers are utilized to form the logical sequential physical log. The file system may utilize one or more file system volumes that are physically implemented on one or more hard disk drives in . Containers are used to embody the physical log utilized in the present multi level read caching arrangement for transactional logging as a logical single contiguous physical log . Use of the container abstraction advantageously enables any local or remote file system conforming with the Windows NT operating system I O model to interoperate as the underlying file system supporting the CLFS architecture . Such interoperability reduces the need to embed volume management functionality in the CLFS driver and streamlines the APIs and .

CLFS driver writes log I O blocks shown as a single representative log I O block into containers using IRPs . The physical log generally will comprise multiple discrete containers and the CLFS driver strings multiple containers together logically to form a single logical sequential disk extent to give the log clients a logical view of single contiguous physical log stream.

For a given physical log all containers have the same size. A single container provides a unit of growth or shrinkage of a physical log according to the log streams feeding it. Initially at least two containers must be allocated to each log but a log client can dynamically grow or shrink a physical log by respectively adding containers to or deleting them from the physical log. Resizing the physical log involves minimal synchronization and performance overhead.

All log records including the target record are identified by a log sequence number LSN as indicated by reference numeral in . Thus when a log client writes a log record to a log stream it gets back an LSN that identifies the log record for future use. The LSN is comprised of a set of three numbers which locates a record in a physical log 1 a container identifier that identifies the container holding the log record 2 a block offset that gives the byte offset within the container of the beginning of the log I O block that holds the log record and 3 a record sequence number that identifies the record within the log I O block. Due to the sequential nature of logs LSNs are strictly arranged in a monotonically increasing but non contiguous sequence of 64 bit integers. That is the LSN assigned to a log record in a given log stream is always greater than the LSNs assigned to log records previously written to that same log stream.

Since the marshalling area contains virtual logs the current read buffer and current write buffer use virtual LSNs to identify log records cached therein. And as the log flush queue uses a projection of the buffers contained in the marshalling area the top three cache levels in the cache hierarchy do not require any form of LSN address translation for the log clients to correctly locate a requested target log record.

By contrast a conversion algorithm is used in order to correctly identify a target log record using an LSN that is cached in the system file cache . In addition another conversion algorithm as described in U.S. Pat. No. 7 007 197 entitled Virtual Logging System and Method may be utilized to correctly identify the associated block location on disk. The former conversion is necessary because the non contiguous nature of LSNs can create a cache hole in the contiguous file system cache address space as discussed below in the text accompanying . shows an illustrative file system cache address space that includes contiguous addresses across pages of virtual memory. The contiguous addresses are included in the set of 0 n .

As shown in a group of containers where one container was described above in the text accompanying is illustratively provided having container addresses in the set 0 m . Containers represent arbitrary file system files that are strung together by metadata data structures to represent a single logical sequential log medium. In the icontainer in group of containers contains several fixed length log block headers and several variable length log block data structures as does the next container i 1 .

As a result as shown in a cache hole would result from using the non contiguous LSN addresses for the log I O blocks and from physical log in a file system cache that uses a contiguous address space. Such cache hole could cause invalid reads from the file system cache .

A present solution to the problem of a cache hole is shown in which depicts an illustrative arrangement for bidirectional mapping between an LSN address space and a file system cache address space. Here a cache base LSN provides a reference point which is defined as being less than or equal to an LSN that defines the beginning of a physical log. This latter LSN is the lesser of a base LSN or archive tail LSN depending on the type of log being used. A base LSN is the LSN of the oldest record in a log stream that is still active i.e. potentially needed by the log stream s log client . The log clients are responsible for updating the base LSN. An archive tail LSN is the LSN of the oldest record in a log stream for which archiving has not taken place. Not every log has an archive tail. A log that does not have an archive tail is called ephemeral and a log that has an archive tail is called non ephemeral. When a log client specifies that a log has an archive tail the client is responsible for updating the archive tail. In the illustrative example shown in a base LSN is used for an ephemeral type log.

As shown in a cache address Addr is determined by using an offset measured in bytes between the cache base LSN and a log record of interest in physical log having a physical log address LSN . Similarly a cache address Addr is the offset between the cache base LSN and another log record of interest having a physical log address of LSN . It is particularly noted that the mapping between the LSN address space and file system cache address space is bidirectional. That is an LSN address for a log record is mapped to the file system cache during log writes to avoid the problem with cache holes. And the file system cache address is mapped to an LSN address that is recognized by a log client if it needs to read the log record from the system file cache .

As the base LSN moves forward as a result of log client operation a gap of unusable addresses is created between the cache base LSN and base LSN. Periodically e.g. on a lazy basis the cache base LSN is advanced to close the gap when for example the offset and the resulting number of unusable addresses exceeds a predetermined threshold. In addition since the file system cache addresses are based on the cache base LSN it needs to be purged and repopulated whenever the cache base LSN is advanced. Accordingly the cache base may be advanced to minimize the impact of the purging and repopulation on system resources for example by timing the advance during periods of relative system inactivity i.e. when the file system is sufficiently acquiesced or to tune the threshold for unusable addresses. Generally the cache base LSN will be configured for advancement as necessary to strike a particular balance between performance management and memory management as dictated by specific circumstances.

Another issue that arises when using both a file system cache and physical log is the potential for mismatch between physical log boundaries and file system cache boundaries as shown in . As shown in and noted in the text accompanying the physical log writes variable length log I O blocks to sector boundaries on a disk . By comparison the file system cache performs all reads and writes on page boundaries. As shown in the key a page equals four sectors in systems using 32 bit processing and eight sectors in systems using 64 bit processing.

A present solution to the boundary mismatch is shown in the flowchart of which provides an illustrative method for detecting a page misalignment on the last write to disk and accordingly purging the last dirtied i.e. modified page from the file system cache. Method is described with reference to . Note that while illustrative method employs a case where a one sector block is utilized the method may be applied to a partial page write of any size.

Step in method includes writing a first log I O block that is one sector in size into the physical log on disk . Step includes reading the first log I O block which is one sector in size into the file system cache .

Referring now to the left hand branch of flowchart steps and illustrate how a new log I O block would be written and incorrectly read if the boundary mismatch issue were not appropriately addressed. Step includes writing a new log I O block that is one sector in size into the physical log on disk . Step includes attempting to read the new log I O block that is one sector in size from the file system cache . In this case the file system cache will return invalid data because it believes that it has already read the correct page.

Referring now to the right hand branch of flowchart steps A A illustrate how a new log I O block is written and correctly read by addressing the boundary mismatch issue in accordance with the principles of the present multi level caching arrangement. Step A includes writing the new log I O block one sector in size to the physical log on disk . Step A includes purging the last dirtied i.e. modified page in the system file cache . Step A includes reading a whole page into the file system cache on the next log I O block read. Step A includes reading the new log I O block that is one sector in size from the file system cache . In this case now the file system cache will return valid data for the new log I O block .

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

