---

title: Method for building data encapsulation layers for highly variable schema
abstract: The relationships between physical data store schema, object model, and end-user property may be encoded in the source of the object model using attributes. Reflection may be used to build the table of those relationships so that changes to the relationships between those three layers can be easily and quickly made without impacting higher levels in the software stack.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07831629&OS=07831629&RS=07831629
owner: Microsoft Corporation
number: 07831629
owner_city: Redmond
owner_country: US
publication_date: 20060106
---
Predefined schema data storage systems such as relational databases such as SQLServer from Microsoft and Oracle from Oracle for example may be based on a relational data model in which the schema of the data model is defined in advance of use i.e. at data definition time which is separate from and earlier than data manipulation time . Applications written to use these systems must be aware of the schema and changes to that schema are very disruptive because the model is predicated on data definition being advance of data manipulation. 

There are however many applications such as messaging systems like Exchange from Microsoft Corp that are not able to describe their full schema in advance of use because the schema e.g. the MAPI data model in the case of Exchange may be modified at any point in time by any user. For example it may be known that all Messages have a property called PR SUBJECT 0x0037001E but it might not be known that certain messages will be annotated with a new property called PR FOOBAR 0x8011001F .

Applications have typically taken two different approaches to store such highly flexible schema data in less flexible database systems. In a first such approach the data is stored in XML or blobs in the database i.e. the schema of the data is moved to a higher layer in the software stack. The database management system DBMS sees a very simple schema largely containing a single dynamic schema object. This allows the schema to be stored and manipulated in a consistent manner but robs the data store of the ability to use knowledge of the schema to optimize operations of the data store. In the absence of advanced database features such as XML data processing this approach is practically unusable for commercial applications because of the performance penalty imposed by eliminating the data store s ability to optimize its operations.

In a second such approach some of the data i.e. the portion that is known at data definition time is stored in the data store as normal not dynamic schema objects and the remainder is stored in either a blob XML or normalized into a property value pair table. This allows the data store to know about as much of the schema as possible and consequently to use that knowledge in operations. But it requires the application to be written knowing which parts of the schema as normal database objects and which are stored as blob XML or property value pairs.

The net result of these approaches is that the application writer must choose between exposing their part structured and part variable data store schema through their object model or having a fully variable data schema and loose data store level optimization and processing. Consider MAPI as an example. There is no natural and intuitive way for the writer to know that PR SUBJECT 0x0037001E maps to Message.Subject in the object model and column dbo.MessageView.Subject in the data store schema while PR FOOBAR 0x8011001F is not represented in either the object model or data store schema because it is a new data property added dynamically.

It would be desirable therefore if a mechanism existed via which applications could be written such that the data store can have a part structured and part variable data schema. It would be particularly desirable if such a schema were not exposed through the object model.

Methods for building data encapsulation layers for a highly variable schema are disclosed and claimed. As described in detail below such methods allow for applications to be written in such a way that a data store can have a part structured and part variable data schema. Such a schema need not be exposed through the object model. Application writers can choose an optimal data store schema design part of which is structured and part of which is variable without sacrificing integrity of the exposed object model.

An isolation layer that defines a relationship between object model data fields and data store data fields may be encoded in the source of the data store interface layer using attributes. Reflection may be used at application start time for example to build a table of mappings that drive interactions with that data. The use of reflection to build the mapping table eliminates the need for hard coding such relationships. Consequently the application code need not change merely because the data store structure changes. An example three step process for building and using such an isolation layer is described in detail.

It should be understood that many types of mapping relationships may be supported. The foregoing is an example of a 1 to 1 to 1 mapping from end user to object model to data store. The following is an example of a 1 to 1 to many mapping from end user to object model to data store 

At a mapping table may be built. The mapping table may be derived from the variable relationship encoded into the data store interface layer of the application and may map a specific relationship between the object model data fields and the data store data fields that exists at start up time. Thus the application code need not change merely because the data store structure changes.

Such a mapping table may be built using a technique that is commonly referred to as reflection such as Microsoft .NET Framework Reflection for example. That is the executable code associated with an application may look at the source code associated with the application e.g. the source code from which the executable code was compiled and identify certain relationships from the source code.

At the mapping table may be used at run time. That is when there is a request for a property the table may be used to determine how to get the data and to invoke the correct mechanism for obtaining the value of the requested property. provides an example of how to use a mapping table at run time. As shown the program loops through the request array and fills the property values.

It should be apparent that a user can invoke MapiGetProps to retrieve the desired data from the data store. Thus the user may be totally shielded from the physical realization of those properties in the object model or data store. In fact the MapiGetProps function itself may also be shielded. It knows there are two types of properties those that are handled in the object model and represented in the data store schema and those that are represented as property value pairs or XML or blob . It need not be aware of which properties fall into which set or why. This logical isolation allows the underlying object model or data store physical realization to change without affecting the end user application.

Although not required the invention can be implemented via an application programming interface API for use by a developer or tester and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers e.g. client workstations servers or other devices . Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. An embodiment of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an example system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology compact disc read only memory CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as ROM and RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data . RAM may contain other data and or program modules.

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the example operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

One of ordinary skill in the art can appreciate that a computer or other client devices can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. An embodiment of the present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

