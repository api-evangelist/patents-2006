---

title: Guided performance optimization for graphics pipeline state management
abstract: Techniques are provided for efficiently arranging shader constants into constant buffers to more efficiently set shader constants to a GPU. Techniques are provided for tracking runtime usage patterns of shader constants, and then generating usage pattern data regarding usage patterns of shader constants. This usage pattern data can then be fed into an optimization algorithm to efficiently lay out the data for maximal performance given certain heuristics. Factors considered include, for example, frequency of client update of the values, usage by certain shaders, and size and number of the resulting buffers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07692660&OS=07692660&RS=07692660
owner: Microsoft Corporation
number: 07692660
owner_city: Redmond
owner_country: US
publication_date: 20060628
---
Rendering and displaying three dimensional 3 D graphics on screen typically involves many calculations and computations. In a simple graphics system such computations occur according to some level of cooperative or shared processing by the central processing unit CPU and the graphics processing unit GPU . In an exemplary scenario after instructions are processed and some initial computations occur in the CPU a set of coordinate points or vertices that define the object to be rendered are stored in video memory for further processing by the GPU in the graphics pipeline. When graphics programmers develop graphics applications via a set of available graphics APIs the programmer generally indicates a set of vertices to be operated upon by a set of algorithmic elements.

The data is sent into the graphics pipeline and each vertex is streamed through a configurable set of GPU subunits. One or more programmable shader units sometimes referred to as shaders or shader programs can operate on the data and perform specialized operations on graphics data. Shaders can include for example vertex shader s geometry shader s and pixel shader s .

Rather than creating a plurality of different shader programs for each specific scenario a single shader program can receive different combinations of shader constants and depending on the combination of particular shader constants that are selected the output of the shader will vary. These shader constants can specify for example how pixels are combined how data is read in and out and in the case of a texture how values are extracted from that texture. Shader constants can be used to specify for example things like light positions view transformations which certain objects undergo material parameters such as color and reflectivity. For instance a particular shader program can be fed different constants which can define for example what type of surface is present and how in view of those constants the light would reflect off a particular surface. For example light would reflect differently off a plain wood surface than it would off a laminated wood surface. The shader constants are used to specify how this reflection would occur. If the shader program is computing a lighting equation the CPU can provide shader constants which define light positions or light colors. These constant values are unchanged throughout the shader invocation.

The process of shading is a computation intensive and complex process. When these specific shaders operate in a graphics pipeline there are regular bottlenecks due to the operations that occur in each stage. One inefficiency in graphics programming results from time spent setting state and issuing commands to the GPU. State refers to a large amount of data numbers or values that describes how the hardware pipeline is to be configured and how it will behave. One component of this state is a set of shader constants that need to be bound to the GPU before executing a shader program. It is desirable to reduce time spent setting state e.g. shader constants to the GPU.

Some shaders utilize constant buffers as opposed to constant registers which hold groups or aggregations of shader constants. Constant buffers can allow shader constants to be set to the GPU more rapidly since the aggregations of shader constants are grouped together.

Techniques are provided for efficiently arranging shader constants into constant buffers to more efficiently set shader constants to a GPU. Techniques are provided for tracking runtime usage patterns of shader constants and then generating usage pattern data regarding usage patterns of shader constants. This usage pattern data can then be fed into an optimization algorithm to efficiently lay out the data for maximal performance given certain heuristics. Factors considered include for example frequency of client update of the values usage by certain shaders and size and number of the resulting buffers.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The following detailed description is merely exemplary in nature and is not intended to limit the invention or the application and uses of the invention. As used herein the word exemplary means serving as an example instance or illustration. Any implementation described herein as exemplary is not necessarily to be construed as preferred or advantageous over other implementations. All of the implementations described below are exemplary implementations provided to enable persons skilled in the art to make or use the invention and are not intended to limit the scope of the invention which is defined by the claims. Furthermore there is no intention to be bound by any expressed or implied theory presented in the preceding background brief summary or the following detailed description.

As used herein the term shader can be used to generically to refer to either the hardware subunit of the GPU that performs the execution or to refer to the set of instructions or tokens downloaded to the GPU that are subsequently loaded into memory and used by the shader hardware to perform the shading. The term shader can also refer to both working together. Where the term subunit is also used in connection with the term shader the term shader should be construed to refer to the subunit of the GPU that performs the processing associated with the shading. The term shader program can generally refer to computer programs or processes that reside and run in the graphics pipeline which can be used to help determine define the final on screen surface properties of an image or object in a 3D on screen environment. Shaders can perform billions or more of computations a second in order to perform their specific tasks.

As used herein the term shader constant can refer to different parameters or variables that are fed into a shader program that allow the shader program to produce different results based on the particular shader constants that are used. Shader constants do not have to be a part of the shader program itself. Shader programs can receive a range of different values for each shader constant over the course of an applications execution.

Techniques are provided for tracking runtime usage patterns of shader constants and then generating usage pattern data regarding usage patterns of shader constants. This usage pattern data can then be fed into an optimization algorithm to efficiently lay out the data for maximal performance given certain heuristics. Factors considered include for example frequency of client update of the values usage by certain shaders and size and number of the resulting buffers.

One of ordinary skill in the art can appreciate that the invention can be implemented in connection with any computer or other client or server device which can be deployed as part of a computer network or in a distributed computing environment. In this regard the present invention pertains to any computer system or environment having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes which may be used in connection with processes for a non limiting implementation of a graphics pipeline in accordance with the present invention. The present invention may apply to an environment with server computers and client computers deployed in a network environment or distributed computing environment having remote or local storage. The present invention may also be applied to standalone computing devices having programming language functionality interpretation and execution capabilities for generating receiving and transmitting information in connection with remote or local services. In a gaming environment a graphics pipeline is particularly relevant to those computing devices operating in a network or distributed computing environment and thus graphic pipeline techniques in accordance with the present invention can be applied with great efficacy in those environments.

Distributed computing provides sharing of computer resources and services by exchange between computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for files. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may implicate the graphics pipeline processes of the invention.

It can also be appreciated that an object such as may be hosted on another computing device etc. or etc. Thus although the physical environment depicted may show the connected devices as computers such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs televisions MP3 players etc. software objects such as interfaces COM objects and the like.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems may be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many of the networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks. Any of the infrastructures may be used for exemplary communications made incident to a graphics pipeline according to the present invention.

In home networking environments there are at least four disparate network transport media that may each support a unique protocol such as Power line data both wireless and wired voice e.g. telephone and entertainment media. Most home control devices such as light switches and appliances may use power lines for connectivity. Data Services may enter the home as broadband e.g. either DSL or Cable modem and are accessible within the home using either wireless e.g. HomeRF or 802.11B or wired e.g. Home PNA Cat 5 Ethernet even power line connectivity. Voice traffic may enter the home either as wired e.g. Cat 3 or wireless e.g. cell phones and may be distributed within the home using Cat 3 wiring. Entertainment media or other graphical data may enter the home either through satellite or cable and is typically distributed in the home using coaxial cable. IEEE 1394 and DVI are also digital interconnects for clusters of media devices. All of these network environments and others that may emerge as protocol standards may be interconnected to form a network such as an intranet that may be connected to the outside world by way of the Internet. In short a variety of disparate sources exist for the storage and transmission of data and consequently moving forward computing devices will require ways of sharing data such as data accessed or utilized incident to program objects which make use of the graphics pipeline in accordance with the present invention.

The Internet commonly refers to the collection of networks and gateways that utilize the TCP IP suite of protocols which are well known in the art of computer networking. TCP IP is an acronym for Transmission Control Protocol Internet Protocol. The Internet can be described as a system of geographically distributed remote computer networks interconnected by computers executing networking protocols that allow users to interact and share information over the network s . Because of such wide spread information sharing remote networks such as the Internet have thus far generally evolved into an open system for which developers can design software applications for performing specialized operations or services essentially without restriction.

Thus the network infrastructure enables a host of network topologies such as client server peer to peer or hybrid architectures. The client is a member of a class or group that uses the services of another class or group to which it is not related. Thus in computing a client is a process i.e. roughly a set of instructions or tasks that requests a service provided by another program. The client process utilizes the requested service without having to know any working details about the other program or the service itself. In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the example of computers etc. can be thought of as clients and computers etc. can be thought of as the server where server etc. maintains the data that is then replicated in the client computers etc. although any computer can be considered a client a server or both depending on the circumstances. Any of these computing devices may be processing data or requesting services or tasks that may implicate the graphics programming techniques specific to an implementation of the graphics pipeline in the invention.

A server is typically a remote computer system accessible over a remote or local network such as the Internet. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server. Any software objects utilized pursuant to the graphics programming techniques of the graphics pipeline may be distributed across multiple computing devices or objects.

Client s and server s communicate with one another utilizing the functionality provided by protocol layer s . For example HyperText Transfer Protocol HTTP is a common protocol that is used in conjunction with the World Wide Web WWW or the Web. Typically a computer network address such as an Internet Protocol IP address or other reference such as a Universal Resource Locator URL can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium e.g. client s and server s may be coupled to one another via TCP IP connection s for high capacity communication.

Thus illustrates an exemplary networked or distributed environment with a server in communication with client computers via a network bus in which the present invention may be employed. In more detail a number of servers etc. are interconnected via a communications network bus which may be a LAN WAN intranet the Internet etc. with a number of client or remote computing devices etc. such as a portable computer handheld computer thin client networked appliance or other device such as a VCR TV oven light heater and the like in accordance with the present invention. It is thus contemplated that the present invention may apply to any computing device in connection with which it is desirable to implement a graphics interface employing a graphics pipeline of the invention.

In a network environment in which the communications network bus is the Internet for example the servers etc. can be Web servers with which the clients etc. communicate via any of a number of known protocols such as HTTP. Servers etc. may also serve as clients etc. as may be characteristic of a distributed computing environment. Communications may be wired or wireless where appropriate. Client devices etc. may or may not communicate via communications network bus and may have independent communications associated therewith. For example in the case of a TV or VCR there may or may not be a networked aspect to the control thereof. Each client computer etc. and server computer etc. may be equipped with various application program modules or objects and with connections or access to various types of storage elements or objects across which files or data streams may be stored or to which portion s of files or data streams may be downloaded transmitted or migrated. Any one or more of computers etc. may be responsible for the maintenance and updating of a database or other storage element such as a database or memory for storing data processed according to the invention. Thus the present invention can be utilized in a computer network environment having client computers etc. that can access and interact with a computer network bus and server computers etc. that may interact with client computers etc. and other like devices and databases .

Although not required the invention can be implemented via an operating system for use by a developer of services for a device or object and or included within application software that operates in connection with the graphics programming techniques for a graphics pipeline in the invention. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations and protocols. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs appliances lights environmental control elements minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network bus or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A graphics interface such as Northbridge may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU or host processing unit and assumes responsibility for accelerated graphics port AGP communications. One or more graphics processing units GPUs may communicate with graphics interface . In this regard GPUs generally include on chip memory storage such as register storage and GPUs communicate with a video memory wherein the application variables of the invention may have impact. GPUs however are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer and may include a variety of procedural shaders such as pixel and vertex shaders. A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked or distributed environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web enabled interface for applications and computing devices making computing activities increasingly Web browser or network oriented.

For example MICROSOFT s managed code platform i.e. .NET includes servers building block services such as Web based data storage and downloadable device software. Generally speaking the .NET platform provides 1 the ability to make the entire range of computing devices work together and to have user information automatically updated and synchronized on all of them 2 increased interactive capability for Web pages enabled by greater use of XML rather than HTML 3 online services that feature customized access and delivery of products and services to the user from a central starting point for the management of various applications such as e mail for example or software such as Office .NET 4 centralized data storage which increases efficiency and ease of access to information as well as synchronization of information among users and devices 5 the ability to integrate various communications media such as e mail faxes and telephones 6 for developers the ability to create reusable modules thereby increasing productivity and reducing the number of programming errors and 7 many other cross platform and language integration features as well.

While some exemplary embodiments herein are described in connection with software residing on a computing device one or more portions of the invention may also be implemented via an operating system application programming interface API or a middle man object a control object hardware firmware intermediate language instructions or objects etc. such that the methods may be included in supported in or accessed via all of the languages and services enabled by managed code such as .NET code and in other distributed computing frameworks as well.

The CPU can generally be any processor such as a single chip multi core processor running multiple cores e.g. processors such as a simultaneous multithreading SMT processor which can process or execute several e.g. one or more threads at the same time. As used herein the term thread refers to an individual sequence of instructions. As such simultaneous multithreading refers to the ability for a single processor to handle several threads at the same time. Each core in the CPU may have a Single Instruction Multiple Data SIMD unit as an extension to the processor instruction set. The extension may contain special instructions that help to speed up integer and floating point intensive applications when specially coded to take advantage of these instruction sets. Calculations involved in rendering 3D graphics can be mathematically intensive and rather taxing on the CPU . To alleviate the burden on the CPU the GPU is provided to help the computer run more efficiently.

Before graphics are output to a raster display device e.g. a computer monitor the information used to generate those graphics goes through the GPU and its graphics pipeline . The GPU implements the graphics pipeline in hardware to perform billions of geometry calculations per second.

The GPU is very efficient at manipulating and displaying graphics and its highly parallel structure makes it more effective than typical CPUs for a range of complex algorithms. The GPU implements a number of graphics primitive operations in a way that makes running them much faster than drawing directly to the screen with the host CPU . Lifting this burden from the CPU means that the computer s CPU doesn t have to work as hard to process graphics data e.g. frees up cycles that can be used for other jobs . By offloading most of the graphics functions to the GPU the CPU can perform even more calculations in order to achieve an immersive real time graphics environment. The GPU is responsible for accelerating the display of graphical elements e.g. polygons with texture and shading applied to them on the raster display device e.g. a computer monitor . The GPU processes raw geometry data to ultimately represent that information as pixels on the monitor . The graphics pipeline receives a representation of a 3D scene efficiently processes that representation by running the representation through a number of processing stages and renders 3D scenes as 2D raster images at the monitor .

The GPU can be implemented as one or more stand alone microprocessors which are configured to process real time 2D and 3D graphics. The GPU can sit on a separate graphics card from the motherboard for processing for 2D and or 3D computer graphics and then rendering 2D or 3D images. The GPU can access high performance VRAM directly on the graphics card. Alternatively the GPU may be implemented by integrating it into one of the chips on a PC motherboard so that the GPU can use the main memory as a frame buffer and the CPU to aid in frame rendering. The GPU can be used for example as a dedicated graphics video rendering device for a personal computer or game console.

In 3D graphics rendering the graphics pipeline refers to the various stages of processing e.g. the sequence of steps that the GPU carries out to transform three dimensional image data e.g. the vertices textures and other data from an application into an actual image that is displayed on a two dimensional screen. The properties provided per vertex can include for example x y z coordinates RGB values translucency texture reflectivity and other characteristics.

The different stages in the graphics pipeline are responsible for processing information that is initially provided as properties at the end points vertices or control points of the geometric primitives to generate the image that is eventually rendered. As used herein the term primitive can refer to a collection of vertices that form a single 3D entity. The simplest primitive is a collection of points in a 3D coordinate system which is called a point list. The typical primitives in 3D graphics are lines and triangles. Other types of primitives can include for example a line line list line strips a triangle triangle lists triangle strips and triangle fans. Often 3D primitives are polygons. A polygon is a closed 3D figure delineated by at least three vertices. The simplest polygon is a triangle. Triangles can be used to compose most polygons because all three vertices in a triangle are guaranteed to be coplanar. Triangles can be used to form large complex polygons and meshes.

Within the graphics pipeline all stages are working in parallel. 60 By reconfiguring the graphics pipeline different visual effects can be achieved. For example the graphics pipeline might receive the geometry to be displayed e.g. list of triangles and then perform the necessary geometric transformations on it e.g. rotations translations etc. calculate the color for the geometry to be displayed and then render the geometry to be displayed.

In general the graphics pipeline may comprise the following logical stages input assembler IA vertex shaders and a geometry shader having an associated stream output the rasterizer a pixel shader and the output merger OM . The graphics pipeline can be configured to optimize the use of resources balance the workload in the graphics pipeline allow access to calculated information with IEEE compliant integer or floating point values and provide additional programmability.

The exemplary non limiting embodiment of the graphics pipeline employs dynamically configurable common shader core s comprising a number of units or processing cores that can be configured in various configurations. The common shader core allows simplified optimization as identical hardware units for the different shaders provide load balancing by reconfiguring or disabling a shader as part of the pipeline when it is not needed thus freeing up resources for stages that remain active.

These processing cores can be read into memory and write out from memory in various patterns depending upon the particular application being executed. Depending on its configuration each of the units can be used to perform a vertex shader stage a geometry shader stage and or a pixel shader stage. This allows the common shader cores to be scheduled to different stages or functional blocks of the graphics pipeline on demand to allocate pixel shaders geometry shaders and vertex shaders in a manner that is best suited for the tasks being requested of the pipeline . Any stage may be dynamically enabled or disabled and configured or reconfigured thereby freeing and respecializing resources for stages that are active. As such the underlying resources of the graphics chip can be optimized for the tasks being asked of the graphics chip.

The particular configuration of the graphics pipeline shown in includes a plurality of shared programmable cores or common core elements such as vertex shaders and a geometry shader having an associated stream output and a pixel shader . These different functional stages operate in parallel serving as separate special purpose processors. Depending upon that particular implementation there can be additional or fewer pipeline stages that are shown in . Moreover during the processing of certain vertex and primitive data only some of the pipeline stages shown may actually process that data before an output is displayed on a computer monitor.

The graphics pipeline receives incoming primitive data from and vertex data from an application and passes it through the various pipeline stages before an output is displayed on a computer monitor or screen. The input assembler IA introduces vertex data such as triangles lines or points into the graphics pipeline by pulling source geometry data out of vertex memory buffers and index memory buffers.

 Non indexed or indexed rendering can be used to produce addresses from which to fetch vertex data in memory and subsequently assemble the results into vertices and primitives.

 Non indexed rendering refers to the sequential traversal of vertex buffer s containing vertex data originating at a start offset at each buffer binding. Vertex memory buffers not shown in can receive untransformed model vertices from an application and store them as vertex data. The buffers are each bound to an individual input slot. The layout of data across all the buffers is specified by an input declaration in which each entry defines an element with an input slot a structure offset a data type and a target register for the first active shader in the pipeline . The vertex memory buffers can contain any vertex type. Vertex data can come from multiple buffers accessed in an Array of Structures fashion from each buffer. A given sequence of vertices is constructed out of data fetched from buffers. Various primitive topologies are available to make the sequence of vertex data represent a sequence of primitives. Example topologies are for example point list line list triangle list triangle strip.

 Indexed rendering refers to the sequential traversal of a single buffer containing scalar integer indices originating at a start offset into the buffer. The data to be processed by the graphics pipeline may also be assigned an index. Index memory buffers not shown in receive raw indexed geometric primitive data from an application including points lines triangles and polygons. These geometric primitives can be referenced in the vertex data with index memory buffers. Each index indicates where to fetch data out of buffer s containing vertex data. The index memory buffers contain index data or indices which are integer offsets into vertex memory buffers and are used to render primitives using techniques which draw indexed primitives from a current set of data input streams. Because an index buffer contains indices an index buffer can not be used without a corresponding vertex buffer. Indexing can be useful in a number of situations. For instance an index value can be used for example as part of a video memory addressing scheme while processing data e.g. the index may signify where and when to retrieve and or write to portions of video memory for processing . The programs downloaded to the shader can thus programmatically use the index values associated with the graphics data while retrieving or writing to video memory and also while processing graphics data.

The input assembler IA sends data to the first common core . In this embodiment the first common core is configured as a vertex shader stage. The vertex shader stage operates on or processes streams of vertices from video memory of the graphics pipeline that are specified for algorithmic transformation via a program from the host. Among other things a vertex shader can receive a variety of inputs such as uniform variables and vertex attributes. Uniform variables are constant values for each shader invocation. By contrast vertex attributes are per vertex data a special case of variant variables such as vertex position.

Vertex shaders generally operate on a single input vertex and produce a single output vertex where a vertex refers a point of intersection in 3D space usually defined by its location using x y and z coordinates. The vertex shader stage can allow each geometric vertex to be processed by a short program before it is projected onto the screen. For instance the vertex shader stage can manipulate an object s position in 3 D space by defining techniques to compute vector space transformations and other linearizable computations. For example the vertex shader stage can apply computations of positions colors and texturing coordinates to individual vertices and can perform operations such as transformations skinning and lighting. Some examples of vertex shader s functionalities include arbitrary mesh deformation and vertex displacements in general computing linearizable attributes for later pixel shaders such as texture coordinate transformations.

The data is then sent to a tessellator which performs tessellation on the data. Tesselation generally refers to a process which involves covering of a bounded geometric region without gaps or overlaps by congruent plane figures of one type or a few types. Following the tessellator there is another common core in the pipeline which can be used to perform post tessellation vertex shading on the data. The tessellator steps in this embodiment are optional.

The second common core is followed by a third common core that is configured as a geometry shader . The geometry shader allows for programming primitives as well as the generation of new geometry. The geometry shader can operate on different types of primitive input including vertices points lines sets of two vertices and triangles sets of three lines and generate new geometry inside the pipeline based on the primitives being input. The geometry shader s inputs are the vertices for a full primitive two vertices for lines three vertices for triangles or single vertex for point plus the vertex data for the edge adjacent primitives an additional two vertices for a line an additional three for a triangle . For example the geometry shader can receive one primitive and output either zero one or multiple primitives. The geometry shader can output multiple vertices forming a single selected topology. Some examples of the output include topologies like a triangle strip a line strip or a point list. The number of primitives emitted can vary within any invocation of the geometry shader .

The geometry shader may take in one primitive and output multiple primitives optionally processing adjacent primitives such as adjacent vertices. In other words the geometry shader enables operations on the entire primitive not just by itself but also in the context of some additional nearby vertices. One line segment in a polyline for example may be processed with the ability to read the vertices before and after that segment. One application of this capability e.g. to process adjacent vertices of a primitive is that the geometry shader is capable of taking information about neighboring points in 3 D geometric space into account in current calculations.

Algorithms that can be implemented in the geometry shader can include point sprite or wide line tessellation fur fin generation shadow volume generation single pass rendering to multiple texture cube faces and set up barycentric coordinates as primitive data so that the pixel shader can perform custom attribute interpolation .

To perform point sprite tessellation the shader would take a single vertex and generate four vertices or two output triangles representing four corners of a quadrilateral while performing wide line tessellation the shader receives two line vertices and generates four vertices for a quadrilateral representing a widened line. Additionally the geometry shader may utilize adjacent line vertices to perform mitering on the line end points.

The geometry shader can also be used to generate fur or fins this is not limited to fur or fin generation but encompasses any additional vertices added in a third direction of a single topology. Examples include hair scales grass etc. where primitives describing a geometry are fed to the geometry shader and the geometry shader grows the geometry arbitrarily to supplement the shape. Thus with hair for instance based on triangles input to a geometry shader the geometry shader can add a few vertices that represent hair at each vertex. Advantageously because a stream of triangles to the geometry shader includes information about the neighbors of a vertex the proximity and properties color depth etc. of the geometry of the vertex s neighbors can be taken into account during processing. Another exemplary non limiting use of the geometry shader includes shadow volume generation where the adjacency information is used to decide whether to extrude. Furthermore an application may want to generate some geometry like a fin or fur and extrude shadow volumes out of that. In such cases multi pass functionality of the geometry shader would be employed using the ability output a data stream and circulate it back through the use of the stream output.

In this exemplary non limiting embodiment the output from a geometry shader goes to either the rasterizer for rendering and or to a buffer via stream output SO . Turning the stream output SO on does not stop the rasterization functions of the graphics graphics pipeline it merely amplifies the power of the graphics pipeline by providing more programmatic power to the developer.

The stream output SO serves like a tap in the graphics pipeline which can be turned on and off even as data continues to flow down to the rasterizer . The stream output SO may be tapped into anywhere inside the graphics pipeline prior to the data reaching the frame buffer for rasterization.

When the stream output SO is off the stream output SO has no effect on the pipeline. In other words the stream output SO is optional an application may merely allow the pipeline to send the data through without reading the data to a stream output buffer. Furthermore the stream output buffer is one example of the type of memory that can be used to store the streamed data. There may be times when different types of memory may be used for such functionality like cache memory in a microprocessor.

When turned on the stream output SO allows programmers to tap into the pipeline while the data is inside the pipeline and provide that data to another location.

For instance the stream output SO can stream primitives to one or more output buffers for re use elsewhere in the pipeline enabling the application of recursive programmatic algorithms inside the pipeline. Data sent out via stream output SO can be concatenated to buffer s . The data in the buffer s can then be recirculated to graphics pipeline inputs on subsequent passes. For example the data received at the stream output SO can be written to a buffer or memory for retrieval by the host or other operation.

Alternatively the data received at the stream output SO can be recirculated e.g. fed back or fed forward to another entity within the pipeline such as the input assembler IA vertex shaders and geometry shader or the pixel shader to perform recursive or looping functionality. The stream output SO can allow data to be recirculated to other parts of the graphics pipeline programmatically e.g. the programmer can download a program to the GPU which performs recursive operations on the data recircling data through the same algorithms recursively or otherwise loop through the data a pre fixed number of times . For instance the stream output SO can be used to recirculate the data to the shader itself thereby allowing multi pass operations to be performed on the given data. This can enable programmatic recursive and looping algorithms on graphics data. Another way to recirculate data is to send it through the pipeline again inputting the data to the input assembler IA again.

Furthermore if necessary the information can be streamed out while the same data goes to the rasterizer thus not slowing down the rendering of data or enabling the display of the image as it undergoes a transformation based on recursive algorithmic elements operating on the data.

The next component of the graphics pipeline is a rasterizer . The rasterizer is not necessarily a stage in the graphics pipeline but rather an interface between various pipeline stages. The rasterizer assumes input positions are provided in clip space and performs a significant set of fixed function operations which may include clipping perspective divides viewport or scissor selection primitive setup and determining how to invoke pixel shader . Many of these functions can be adjusted by software developers.

Following the rasterizer is a fourth common core and it functions as a pixel shader where it takes one pixel and outputs the pixel at a position. A pixel shader can allow each pixel to be processed by a short program that can include for example image textures or texture data as inputs. A pixel shader can allow developers manipulate colors textures or even shapes by altering the lighting color and surface at a pixel level. Pixel shaders can be used to alter the lighting color and surface of each pixel. This in turn affects the overall color texture and shape of 3 D objects built from these pixels.

Input data available to the pixel shader includes vertex attributes that can be chosen on a per element basis to be interpolated with or without perspective correction or be treated as constant per primitive. Outputs generated by the pixel shader can be one or more 4 vectors of output data for the current pixel location or no color if pixel is discarded . A partial list of effects that pixel shaders make possible includes per pixel reflections per pixel lighting using Phong style shading or DOT3 effects and procedural textures.

At the output merger OM the final step in the logical graphics pipeline other pixel processing functions can be performed to render the final pixels. These functions can include for example binding of output resources render targets modifying pixel color values with a scissor test visibility determination through depth bias and or stencil buffer techniques or applying functions such as alpha blending or fog shadowing bump mapping environment mapping antialiasing writing or blending of output s to render target s which may be one of many resource types and multiple element textures. After performing these functions on the data the data is ultimately processed further and eventually displayed on a monitor .

The common shader core receives the input data from either the input assembler IA unit a previous stage which may be from anywhere in the graphics pipeline or in some cases from a specialized input source.

The input data can then be temporarily stored in input register s . The input register s may be for example a dynamically indexable array. In the case of a geometry shader the input register s may be a two dimensional 2D array which arranges the inputs for example as vertex element pairs.

The input data is then sent to the shader code . The shader code provides flow control mechanisms an arithmetic logic unit ALU that handles vector floating point and integer arithmetic memory fetch or sample operations and a shader function or program that specifies the particular transformations to be performed on the input data. The shader code can also receive a number of other inputs such as information from the samplers the textures and the constant buffers . The shader code also has two way communication with the temporary registers and the subroutine return address stack .

Samplers textures and constant buffers are resources that are set in a pass block based on the dependency information extracted from the shaders.

The shader code receives samples from the samplers that define how to sample textures. However memory can also be read without filtering and the sampler is not necessary in every embodiment. Because sampler objects are statically created it enables the hardware to maintain references of multiple samplers in the flight of the pipeline without having to track changes or flush the pipeline because the sampler objects maintain their definitions and are not modified .

The shader code receives texture information from the textures . The textures work with the shader code to provide texture sampling.

The CPU generates shader constants that can be used to reconfigure a particular shader program. The shader code receives shader constants from the constant buffers . Constant buffers are provided to aggregate or group certain variables or shader constants in memory on the GPU. In other words instead of using an array of constant registers c . . . cN to store constant input values constant buffers can be used to group numeric shader constant values together. The constant buffers are optimized for lower latency access and more frequent updates than textures . The constant buffers can allow a developer to set a particular group of constants all at the same time. The constants can be arranged in any particular order that the developer desires. Grouping shader constants together in a constant buffer can result in certain performance benefits. For example if two shader constants are typically modified and used together at the same time e.g. have the same state in each scenario then those shader constants can be put into a particular constant buffer.

In one implementation for each stage in the graphics pipeline there are 15 slots for constant buffers that can be active. In shader code a cb register is a placeholder for a constant buffer at slot . A constant buffer is accessed in a shader using cb index as an operand to shader instructions where index can be either a non indexable r or statically indexed x containing a 32 bit unsigned integer an immediate 32 bit unsigned integer constant or a combination of the two added together e.g. mov r0 cb3 x3 0 .x 6 represents moving Element 7 from the ConstantBuffer assigned to slot 3 into r0 assuming x3 0 .x contains 1 . Applications are able to write shader code that reads constants in whatever pattern and quantity desired while still allowing different hardware to easily achieve the best performance possible.

The temporary registers serve as temporary storage. In an exemplary non limiting embodiment the temporary registers can hold any non indexable or indexable arrays of any size and quantity that are needed up to the limit of the temporary storage.

The subroutine return address stack in this particular non limiting exemplary embodiment is a fixed height. Furthermore the stack is hidden from direct shader access and transparently stores return addresses only. It also permits the definition of recursive algorithms.

After the code has passed through the shader code the data goes to output registers . The output registers in this exemplary non limiting embodiment are made of a dynamically indexable array of four vector outputs. Furthermore some stages may have additional specialized outputs.

Depending on which stage the common shader core is being implemented at in the graphics pipeline the output data can then be output to the next shader stage if present as a stream output SO to memory or other location or to an output merger OM or rendering stage.

The data structures listed can be changed from a 1 D array to a 2D array or a list. All data structures may change depending on the size and storing capabilities of the GPU. Within the GPU changes to the storage limits and fixed heights may occur due to dynamic allocation and application of compression algorithms to information to conserve space. The samplers and constant buffers may behave like the textures however as resources change the definitions of these components may be modified. If textures are redefined both samplers and constant buffers can change and are not limited to just the texture functions. Furthermore all the data structures can implement new optimization algorithms for speed and utility purposes. The various embodiments described herein are mere examples of graphics pipeline using common cores which can be dynamically configured to provide functionality of a vertex shader a pixel shader and a geometry shader.

a non consumed state which indicates that the particular shader program does not consume the particular shader constant e.g. the shader program does not use that particular constant at all 

a consumed stale state which indicates that the particular shader program is consuming a stale value of the particular shader constant previously consumed by another shader e.g. the particular shader program uses a stale value of the particular shader constant consumed previously by another shader shader constant has already been modified by the application for consumption by a previous shader invocation and

a consumed fresh state which indicates that the particular shader program is the first shader program to freshly consume the newly set value of the particular shader constant. Using these designations a particular shader constant must be in the consumed fresh state e.g. freshly consumed by a particular shader before it can be in the consumed stale state e.g. stale consumed by another particular shader .

Thus with respect to the exemplary shader constant configurations shown in each of the shader constants can be designated as having a status or state relative to its use or non use in a preceding constant buffer.

For instance the constant buffer in shader A presently holds two constants C C and both are designated as being in a consumed fresh state since shader A is the first shader in the sequence of shaders A . . . N to freshly consume the newly set value of the particular shader constants C C . The other three constants C C are designated as being in a non consumed state since the particular shader does not consume those particular shader constants C C .

The constant buffer in shader B presently holds four constants C C C C . Of those two constants C C are both designated as being in a consumed fresh state since shader B is the first shader in the sequence of shaders A . . . N to freshly consume the newly set value of the particular shader constants C C . Constants C C are both designated as being in a consumed stale state since shader B is consuming a stale value of those particular shader constants e.g. C C were previously consumed by shader A . In other words shader B does not really modify shader constants C and C since shader constants C and C are in the same state as they were previously and are therefore designated as consumed stale. The other constant C is designated as being in a non consumed state since shader B does not consume that particular shader constant C .

The constant buffer in shader C presently holds three constants C C C . All three constants C C C are designated as being in a consumed fresh state since shader C is the first shader in the sequence of shaders A . . . N to freshly consume the newly set value of the particular shader constants C C C . The client must have set new values for C C between the execution of S and S. Thus the new values are consumed freshly by S even though S S have consumed older values of C C before. The other constants C C are designated as being in a non consumed state since shader C does not consume those particular shader constants C C .

The constant buffer in shader N presently holds three constants C C C . These constants C C C are designated as being in a consumed stale state since shader N is consuming a stale value of those particular shader constants e.g. C C C were previously consumed by shader C . The other constants C C are designated as being in a non consumed state since shader N does not consume those particular shader constants C C .

Thus in some cases many of the shaders will share the same information. For example if there is a light that is lighting all the objects in a particular scene the position of the light will be the same in every shader program in that particular scene and the position of the light will be read by every shader that does a lighting computation. When multiple shaders are using the same shader constants it is inefficient to repeatedly send the same shader constants down the pipeline multiple times to the different shaders since bandwidth between the CPU and the GPU is relatively limited.

Techniques are provided for determining based on actual behavior of a particular application at run time an optimal size of shader constant buffers and the optimal shader constants in those particular shader constant buffers. Given a set of shaders and shader constants the application is run through each of the particular shaders and the shader constants used by each constant buffer can be observed. An optimization algorithm continuously evaluates the current state of shader constants used in each of the constant buffers analyzes the shader constants used in each constant buffer and determines an optimal organization e.g. selection and arrangement of shader constants in each constant buffer.

This algorithm allows observation of which constants are being set and which values are being updated based on the actual behavior of the application. By running a particular application it can be determined which constants seem to change and which do not by observing the different combinations of the shader constants used in each constant buffer as the application executes. By observing the run time environment it can be determined which constants need to be changed. As a particular application runs usage of the different constants in each of constant buffers can be recorded. Once the application runs for a certain amount of time certain metrics can be determined. Usage patterns are analyzed and the different metrics can be used to come up with an optimal distribution of these constant buffers. The constants used in each constant buffer of each of the different shaders can be optimized based on these metrics.

The process begins at step by running the particular application. At step the number N of shader programs not necessarily unique can be applied in chronological order as the particular application executes. For example in one implementation as an application executes the client program applies a number N of shaders and the shaders pull subsets of constants from a pool N of constants. The number N of shaders are not necessarily unique and can be applied for example in chronological order. Optionally the developer may have also placed these shader constants into constant buffers with a particular arrangement which can be used as an initial guess as to the optimal placement of constants into respective buffers or affinity. This lets a developer hint to the system which constants should be placed in which buffers all things being roughly equal. Since the optimization procedure uses a heuristic based on minimizing the number of bytes copied and the number of constant buffers locks another heuristic can be added that adds a cost for moving a constant out of the original buffer the developer placed it in. This essentially creates an affinity for a constant to stay in its current buffer unless there is a huge cost to doing so.

For example in the initialization phase all the constants could be put into one buffer the application can then be run and the constant buffers will update each time state changes. State refers to an array of shader constants numbers or values that is being interpreted by the shader program. Interspersed between shader apply calls are a number of Variable SetValue calls which set data into a shader constant. In other words between the shader apply calls equivalently between columns of the table in it is inferred that the developer is changing the values of various constants by using material management APIs FX . This is why in the values for C C are consumed fresh in Shader C even though they were already consumed stale by the previous Shader B . The application produces values and the shaders consume the values. The values are not always 1 to 1 sometimes a program might set a value multiple times before applying which generates a performance warning and sometimes a value might be set once and used intact across multiple shaders. In the latter case frequency of updates can be inferred e.g. which shaders use which constants in common with other shaders .

At step each time state changes each constant buffer is updated with the shader constants that need to be modified to execute a particular shader program.

As the particular application continues to run e.g. during run time at step changes in the shader constants in each constant buffer are observed. illustrates an exemplary non limiting flow diagram for observing changes in the shader constants in each constant buffer as the particular application runs during run time. At step a determination is made as to which shader constants are being set which shader constants are being updated and the order in which the shader constants are being set updated as the particular application runs during run time. At step each particular shader constant in each particular constant buffer associated with a particular shader program can be designated as being in one of a non consumed state a consumed stale state and a consumed fresh state.

Referring again to at step usage patterns of shader constants in each constant buffer are recorded as the particular application continues to run. In one implementation a table T can be generated comprising a number of entries N N based on the Nshader programs and the pool N shader constants. Each entry T s c in the table T corresponds to the state of a particular shader constant c in a particular constant buffer associated with a particular shader program s .

At step changes in usage patterns of shader constants in each constant buffer can be determined during run time to generate usage pattern data. In one implementation the shader constant metrics can be analyzed to determine the changes in usage patterns of shader constants in each constant buffer during run time to generate usage pattern data. illustrates an exemplary non limiting flow diagram for determining changes in usage patterns of shader constants in each constant buffer during run time to generate usage pattern data. At step once the table T has been generated shader constant metrics can be generated. Given any arrangement of the shader constants into mutually exclusive constant buffers whether it be the initial guess provided by the original arrangement or whether it be some given configuration suggested by the optimizer a number of shader constant metrics can be computed. The shader constant metrics may comprise for example 

a number of constant buffer updates needed to execute a given shader program NumCBLocks i i.e. for a given shader how many CBs need to be updated in order to apply the shader given all of the previous history 

a number of bytes that need to be copied in order to execute a given shader program BytesCopied i i.e. for a given shader what is the sum of the sizes of the CBs that a the shader is dependent on and b need updating and

a number of wasted bytes copied from each shader program WastedBytesCopied i i.e. of the total number of bytes copied for a shader BytesCopied i how many of them were stale values being copied as an unfortunate side effect of being grouped into the same buffer as freshly consumed values .

A constant buffer CB will be locked and updated if and only if a shader is freshly consuming state 3 at least one of the CB s constants. If the shader is consuming stale values or consuming none at all then the constant buffer has necessarily already been locked by a previous shader. At step the observed changes can be quantified using these shader constant metrics. At step the shader constant metrics can be analyzed to determine the changes in usage patterns of shader constants in each constant buffer during run time to generate usage pattern data.

For instance referring to the example in assuming constant C through C are in a constant buffer shader A only consumes C and C and the other three constants C C are wasted. In shader B constants C and C are designated as consumed stale. The consumed stale designation can be used to count the order in which shaders are executed. The values C and C from shader one can be reused or while C and C need to be updated. There is no need to lock the third constant buffer since C and C are already stale and the C will not be used. As such for shader A and shader B the optimal configuration might be that the first constant buffer includes C and C and the second constant buffer will contain C and C.

Referring again to at step changes in usage pattern data and or shader constant metrics can be used to generate an optimal shader constant configuration for each constant buffer.

Heuristics to feed into an optimization algorithm can be defined to help decide how to arrange the shader constants. For example based on the observed changes in the shader constants in each constant buffer an optimal arrangement of shader constants in each constant buffer can be determined to optimize performance of each shader program in the context of the particular application. In one implementation the shader constant metrics can be used to optimize performance of each shader program by determining an optimal size of each of the particular constant buffer and selecting the optimal shader constants to be included in the particular constant buffer. For instance the sum NumCBLocks i and sum WastedBytesCopied i can be minimized with some configurable ratio to tradeoff between the two. A priority queue based optimization algorithm can be used that assigns costs to a number of different possible operations split merge etc. . The algorithm can then execute these operations to modify the layout of the buffers using the specified heuristics.

After a number of iterations the optimal value for the shader constants can be arrived at. Thus once the optimal shader constants and optimal layout of the constant buffers have been determined the optimal shader constants and optimal layout of the constant buffers can be entered into the files the developer ultimately writes and input into the particular application and the particular application can be executed.

The table in lists tri state values for every combination of shader and constant table 2 dimensional array . The data in this table can be fed into the optimization algorithm in any of a number of different ways.

For example at the start of the optimization algorithm the initial state could be either each constant in a constant buffer by itself exception if there are constants C C such that the tri state value for C and C are always identical for a given shader e.g. a column of table in then the constants C and C can be combined into the same buffer to start with all constants could be arranged in one big constant buffer or constants can be arranged in buffers identically to the way the developer originally configured them e.g. per an initial guesses and affinity .

For any given state a cost for this state can be defined which is a linear combination of a number of constant buffer locks required to execute shaders S1 . . . SN multiplied by a constant value number of cycles required per lock to be determined empirically on various hardware configurations a number of wasted bytes copied due to lock discard operations on a given constant buffer e.g. when a constant is consumed fresh along with stale or unused values in the same constant buffer some bytes of data are needlessly copied and optionally if constants are arranged in buffers per an initial guess of the developer a constant cost for each constant that has been moved to a constant buffer e.g. due to either a split or merge operation other than the one specified initially by the developer.

From any given state split and merge operations are defined. The split operation for a given constant buffer splits the given constant buffer into two buffers A and B with some constants moving into buffer A and some moving into buffer B. The merge operation for two given constant buffers A and B combines constant buffer A and constant buffer B into one large buffer.

At each step of the algorithm the current heuristic is calculated followed by a delta value for each possible split or merge operation. To greatly reduce the number of possibilities at each step certain split and merge operations can be preferred over others based on the actual consumption of constant values by shaders e.g. based on frequency of update frequency of use etc. . A given operation is taken if it results in the largest decrease in total cost. 

There are multiple ways of implementing the present invention e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to use the systems and methods of the enhanced graphics pipeline invention. The invention contemplates the use of the invention from the standpoint of an API or other software object as well as from a software or hardware object that receives any of the aforementioned techniques including techniques of the common core the geometry shader or the stream output in accordance with the invention. Thus various implementations of the invention described herein may have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

As mentioned above while exemplary embodiments of the present invention have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any computing device or system in which it is desirable to employ a GPU with an enhanced graphics pipeline. For instance the algorithm s and hardware implementations of the invention may be applied to the operating system of a computing device provided as a separate object on the device as part of another object as a reusable control as a downloadable object from a server as a middle man between a device or object and the network as a distributed object as hardware in memory a combination of any of the foregoing etc. While exemplary programming languages names and examples are chosen herein as representative of various choices these languages names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code and nomenclature that achieves the same similar or equivalent functionality achieved by the various embodiments of the invention.

As mentioned the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the enhanced graphics pipeline techniques of the present invention e.g. through the use of a data processing API reusable controls or the like are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

The methods and apparatus of the present invention may also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer etc. the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of the present invention. Additionally any storage techniques used in connection with the present invention may invariably be a combination of hardware and software.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. For example while exemplary network environments of the invention are described in the context of a networked environment such as a peer to peer networked environment one skilled in the art will recognize that the present invention is not limited thereto and that the methods as described in the present application may apply to any computing device or environment such as a gaming console handheld computer portable computer etc. whether wired or wireless and may be applied to any number of such computing devices connected via a communications network and interacting across the network. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate.

While exemplary embodiments refer to utilizing the present invention in the context of a graphics pipeline the invention is not so limited but rather may be implemented to provide a second processing unit. For instance if the programmer wants to render a display to the screen and process the computational mathematics while performing another function using the CPU the processing units may need to be utilized to their fullest whether or not the graphical display is included in the final output. Still further the present invention may be implemented in or across a plurality of processing chips or devices and storage may similarly be effected across a plurality of devices. Therefore the present invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

