---

title: Pseudorandom number generation with expander graphs
abstract: Pseudorandom numbers may be generated from input seeds using expander graphs. Expander graphs are a collection of vertices that are interconnected via edges. Generally, a walk around an expander graph is determined responsive to an input seed, and a pseudorandom number is produced based on vertex names. Specifically, a next edge, which is one of multiple edges emanating from a current vertex, is selected responsive to an extracted seed chunk. The next edge is traversed to reach a next vertex. The name of the next vertex is ascertained and used as a portion of the pseudorandom number being produced by the walk around the expander graph.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07907726&OS=07907726&RS=07907726
owner: Microsoft Corporation
number: 07907726
owner_city: Redmond
owner_country: US
publication_date: 20060119
---
Random numbers are useful in many different computing spheres. For example most security protocols which are employed in many business and commercial contexts rely on random numbers. Unfortunately acquiring truly random numbers using the mathematical logic and consequential predictability embodied in the circuitry of today s computing devices is a difficult prospect. Hence pseudorandom numbers which computing devices are capable of producing are typically used in the real world.

Pseudorandom numbers tend to appear random at least to a resource constrained analysis. Pseudorandom number generation typically involves using an input seed of a first bit length to produce a pseudorandom number of a second bit length. The input seed is generally considered truly random. The second bit length of the pseudorandom number output is longer than the first bit length of the seed input due to some mathematical algorithm that is applied to the input seed. The effect is the production of a pseudorandom number sequence that may be employed with a security protocol or in some other context.

Pseudorandom numbers may be generated from input seeds using expander graphs. Expander graphs are a collection of vertices that are interconnected via edges. Generally a walk around an expander graph is determined responsive to an input seed and a pseudorandom number is produced based on vertex names. Specifically a next edge which is one of multiple edges emanating from a current vertex is selected responsive to an extracted seed chunk. The next edge is traversed to reach a next vertex. The name of the next vertex is ascertained and used as a portion of the pseudorandom number being produced by the walk around the expander graph.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure API arrangement etc. implementations are described herein.

As described herein pseudorandom numbers may be generated using an expander graph. By way of example only an input seed is used to determine a walk around an expander graph. The walk around the expander graph produces values that may be utilized as a pseudorandom number. Two sections are presented below one section pertains to a relatively qualitative description and the other section pertains to a relatively quantitative description. The sections are entitled Example Qualitative Implementations for Pseudorandom Number Generation with Expander Graphs and Example Quantitative Implementations for Pseudorandom Number Generation with Expander Graphs .

Expander graph is a collection of vertices or nodes and a collection of edges. The edges interconnect the vertices. A walk is taken around expander graph by traversing edges between vertices. Seed is used by pseudorandom number generator to determine the path of the walk around expander graph . Identifiers of constituent parts of expander graph are used to form portions of pseudorandom number .

An example of an expander graph is described herein below with particular reference to . An example of a walk around an expander graph as determined by a seed to generate a pseudorandom number is described herein below with particular reference to .

Generally any type of expander graph may be employed by pseudorandom number generator . Expander graphs are usually characterized as having a property that enables them to grow quickly from a given vertex to its neighbors and onward to other vertices. An example of a family of graphs that are considered to have good expansion properties are the so called Ramanujan graphs. Although not required pseudorandom number generation with an expander graph is facilitated by using an expander graph with good expansion properties along with a small degree k where the degree indicates the number of edges emanating from the vertices. These types of expander graphs can usually be described with a compact set of instructions.

Although not required expander graphs that are so called k regular graphs are particularly amenable for use in generating pseudorandom numbers. These k regular graphs are graphs that have the same number of edges emanating from each vertex. Moreover two types of k regular graphs are particularly amenable for use in generating pseudorandom numbers. These two examples of k regular graph types are i supersingular elliptic curves expander graphs and ii Lubotzky Philips Sarnak LPS expander graphs. These two specific k regular expander graph types which are also examples of Ramanujan graphs are described mathematically herein below in the quantitative section.

As illustrated expander graph is a k regular graph with k 3. In other words each vertex has three edges extending there from and therefore terminating thereat depending on perspective and the direction of the walk. Hence each vertex is directly connected to three other neighbor vertices . Although a k 3 regular graph is used as an example herein k may take any integer value especially of three or larger .

Generally walk is shown starting at vertex and extending beyond vertex . Specifically example walk traverses edges and includes vertices to . Walk starts at vertex and traverses edge to reach vertex . From vertex walk traverses edge to reach vertex . From vertex walk traverses edge to reach vertex . From vertex walk traverses edge to reach vertex . From vertex walk traverses edge to reach a vertex not explicitly shown in .

In a described implementation walk can continue traversing edges to include other vertices in walk as long as seed of may be used to provide direction for the path. The seed is used to select a next edge to be traversed to reach a next vertex . With three edges emanating from each vertex there are three options for a next step or leg of a walk . Hence with a k 3 regular graph two bits from seed are used for each next edge or step determination. Creating a walk on an expander graph is described further below with particular reference to .

To facilitate clarity much of expander graph is omitted from . The illustrated part of expander graph includes six vertices that are represented as circles. Edges that interconnect the six illustrated vertices are represented by solid lines. Edges that emanate from the six illustrated vertices but terminate on un illustrated edges are represented by large dashed lines. Each vertex is associated with a vertex name. The six vertices have six vertex names name name name name name and name . An example walk is represented by short dashed lines.

Seed input is segmented into seed chunks . Generally seed input is segmented into n chunks with n being an integer. Specifically seed input includes seed chunk seed chunk seed chunk seed chunk seed chunk . . . seed chunk . Graphically each seed chunk is represented by a balloon indicator having a numeral . . . n.

In a described implementation the size e.g. the number of bits of each seed chunk is based on the degree of the expander graph being utilized to generate pseudorandom number . For example the number of bits h per seed chunk may be set to at least equal the number of bits h needed to individually identify one of the k edges emanating from each vertex 2 k . With a k 3 expander graph each seed chunk is therefore two bits long 2 3 . In other words an association is established between the available edges that emanate from a current vertex and the possible values for a seed chunk . The actual value of an extracted seed chunk is used to determine the next edge from among the available edges using the association.

Pseudorandom number is divided into multiple pseudorandom number portions . As illustrated pseudorandom number includes at least five pseudorandom number portions that are vertex names. These at least five pseudorandom number portions are name name name name name name . . . . Pseudorandom number thus comprises a concatenation of multiple vertex names. The size of pseudorandom number portion is based on the length of each vertex name. The length of each vertex name is at least partially dependent on the type of expander graph being utilized in the pseudorandom number generation. The overall size of pseudorandom number is also based on the number of vertices traversed in a given walk around expander graph .

In a described implementation seed input is typically considered effectively truly random. An example source for seed input is a processor or system clock value. Seed input is stretched to produce a much longer pseudorandom number . This stretching is accomplished because a length of each vertex name or pseudorandom number portion is greater than a length of each seed chunk . This is indicated graphically within brackets .

In operation pseudorandom number generation scheme involves a walk around expander graph in which each step is determined responsive to a seed chunk . An initial vertex can be determined by a fixed starting point by selecting from a limited subset of vertices by selecting from all vertices within expander graph and so forth. If the initial vertex is selected an initial portion of seed input may be extracted and used to select it.

In example walk along expander graph the initial vertex is the vertex with name . Hence name is added to pseudorandom number as pseudorandom number portion . Especially if the initial vertex is fixed name may be omitted from pseudorandom number .

Because expander graph has a degree of k 3 there are three edges emanating from the name vertex. A next edge to traverse to reach the next vertex is selected responsive to seed input . As illustrated seed chunk is extracted from seed . These bits are used to select one of the three edges emanating from the name vertex as indicated by the balloon indicator having the numeral .

This step extends the path of walk to the name vertex. Hence name is added to pseudorandom number as pseudorandom number portion . To select the next edge for the next step of walk seed chunk is extracted from seed . As shown seed chunk selects a next edge that leads to the name vertex. Hence name is added to pseudorandom number as pseudorandom number portion .

This process continues for pseudorandom number generation scheme . Seed chunk is extracted and the next edge is selected responsive thereto. This step leads to the name vertex and name is therefore added as pseudorandom number portion . By using seed chunk to select the next edge walk is extended to the name vertex. Hence name is added to pseudorandom number as pseudorandom number portion . The edge leading to the name vertex is selected responsive to seed chunk and name is concatenated onto pseudorandom number as pseudorandom number portion . The process can continue while additional bits are desired for pseudorandom number as long as bits of seed input remain to be extracted as seed chunks .

Example vertex names are described herein below in the quantitative section. As noted above the length of each vertex name is at least partially dependent on the type of expander graph being utilized in the pseudorandom number generation. The quantitative section also provides mathematical examples of the stretching ratio of the length of the seed input to the length of the pseudorandom number with a pseudorandom number generation scheme using an expander graph. The seed bits may also be separately exponentially stretched using a linear congruential scheme which is described herein below in the quantitative section.

Other figures that are described herein above are referenced to further explain an example of the method. For example a pseudorandom number generator may implement the method using an expander graph of FIGS. and . Additionally the method may be implemented as part of a pseudorandom number generation scheme of . To provide a specific example for the method of flowchart it is given that a current state of a walk is located at the name vertex of expander graph of .

At block a seed chunk is extracted. For example seed chunk may be extracted from seed . At block a next edge is selected responsive to the extracted seed chunk. For example an edge that leads to the name vertex may be selected responsive to seed chunk .

At block the next edge is traversed to determine a next vertex. For example the next edge that is selected responsive to seed chunk may be traversed to determine that the next vertex is the name vertex. At block the name of the next vertex is ascertained. For example name of the name vertex may be ascertained. In the quantitative examples provided below in the quantitative section the name of each vertex is dependent upon the type of expander graph being used to generate a pseudorandom number .

At block a pseudorandom number portion is produced based on the ascertained name of the next vertex. For example pseudorandom number portion may be produced based on the ascertained name of the name vertex. This pseudorandom number portion is concatenated onto the previously produced pseudorandom number portions .

At block the pseudorandom number is used. Generally the pseudorandom number may be used for a variety of purposes in any of many different contexts. More specifically the pseudorandom number may be used for security purposes for quick sorting for computing prime numbers for approximate averaging for some combination thereof and so forth. With respect to security purposes pseudorandom numbers may be used in cryptographic protocols that are facilitated with random numbers. Public key cryptography is an example relevant context for security in which authenticated key exchanges are performed using pseudorandom numbers. Pseudorandom numbers may also be used with digital signature algorithms.

At block the pseudorandom number is expanded by continuing with flow diagram at block . The expansion of pseudorandom number may occur as long as desired while seed chunks of seed are still available.

Generally device may represent a server device a storage device a workstation or other general computer device a set top box or other television device a personal digital assistant PDA mobile telephone or other mobile appliance some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media includes processor executable instructions . Although not specifically illustrated device may also include other components.

In a described implementation of device I O interfaces may include i a network interface for communicating across network s ii a display device interface for displaying information on a display screen iii one or more man machine device interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen television or printer and so forth. Examples of iii man machine device interfaces include those that communicate by wire or wirelessly to man machine interface devices e.g. a keyboard or keypad a mouse or other graphical pointing device a remote control etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device .

Thus realizations for pseudorandom number generation using an expander graph may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects interfaces components metadata and definitions thereof data structures application programming interfaces APIs etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

Processor s may be implemented using any applicable processing capable technology. Media may be any available media that is included as part of and or accessible by device . It includes volatile and non volatile media removable and non removable media and storage and transmission media e.g. wireless or wired communication channels . For example media may include an array of disks for longer term mass storage of processor executable instructions random access memory RAM for shorter term storage of instructions that are currently being executed flash memory for medium to longer term storage optical disks for portable storage and or link s on network for transmitting communications and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein including those that are illustrated in scheme and flow diagram of respectively . By way of example only processor executable instructions may include all or part of a pseudorandom number generator .

In certain implementations as described herein pseudorandom number generation involves taking random walks on expander graphs. Expander graphs with good expansion properties are particularly adaptable to generating pseudorandom numbers. One family of expander graphs with good expansion properties are Ramanujan graphs. As noted herein above pseudorandom number generation is also facilitated using regular graphs especially regular graphs having a relatively low degree i.e. a relatively small number of interconnecting edges per vertex . Two example graphs that are both regular and Ramanujan graphs are i expander graphs formed from supersingular elliptic curves and ii Lubotzky Philips Sarnak LPS expander graphs. These two example expander graphs are addressed mathematically below in individual subsections.

This and the succeeding paragraph present a concise relatively non rigorous explanation of how and why walks on expander graphs behave in a pseudorandom fashion and generally entail pseudorandom properties. On any k regular connected graph a random walk converges to a uniform distribution on the vertices that means that the likelihood of reaching any vertex given a sufficiently long random walk is the same equal to one over the number of vertices. The key property of good expander graphs and among them the Ramanujan graphs are optimal in that regard is the speed of convergence to that uniform distribution.

Given a probability distribution on the vertices of a k regular connected graph namely given for each vertex the likelihood of the process beginning at this vertex the rate of convergence to the uniform probability distribution is controlled by the size of the gap between the eigenvalue 1 and the other eigenvalues of the normalized adjacency matrix of the graph. For an expander graph this gap is large enough so that this convergence to the uniform distribution occurs in a logarithm of the number of vertices many steps. The property of the gap between the leading eigenvalue and the others being large is the defining property of Ramanujan graphs of which the two example graphs describe herein are instances. Thus heuristically in the example graphs a relatively short with respect to the number of vertices and degree k random walk on the graph as is carried out in the processes described herein shall converge rapidly relative to the same parameters to a uniform distribution and so the likelihood of reaching any vertex is close to being the same.

An example family of supersingular elliptic curve expander graphs is defined as follows. It is given that p is a prime number and that l p is another prime number. The graph G p l has as its vertex set V the set of supersingular j invariants over the finite field F. There is an edge between the vertex jand jif there is an isogeny of degree l between the supersingular elliptic curves whose j invariants are jand j. The graph G p l is therefore established to be an example of an l 1 regular Ramanujan graph. The following paragraphs of this subsection describe the construction of a pseudorandom number generator that uses supersingular elliptic curve expander graphs. This also entails describing how to navigate the graph G p l .

The graph is constructed as follows. It is given that j . . . iare the vertices of the graph G p l . Because the number of vertices k of the graph is equal to the class number of the definite quaternion algebra ramified only at p and at infinity only log k bits are needed to specify a vertex. However the j invariants are given a priori as elements of Fwritten as a pair a b of elements of F. The j invariant may be considered as a pair of natural numbers a b mod p. Applying e.g. a 2 universal hash function to the concatenation of a and b produces a bit string of length ceil log 2 k 1.

More specifically although there are k vertices the names for the vertices occupy 2 log p bits instead of log k bits. Because the number of vertices is known a priori an appropriate hash function can be applied to reduce the number of bits consumed by the names of the vertices. The result of applying such a universal hash function is called u and the vertices of the graph are relabeled u j . . . u j .

Generally the graph is navigated for a walk to generate a pseudorandom number as follows. It is given that is the seed of the pseudorandom number generator and that s is the number of steps that can be taken for the walk. While log k bits of the seed are used to determine the starting vertex h bits of the seed are consumed at each step. If the starting vertex is fixed then it can be assumed that is of length h s. The value of is considered to be an element of 0 1 i.e. a string of 0 s and 1 s of length h s log k where h ceil log l 1 1 . It is also given that is the first log k bits of .

The output of the pseudorandom number generator with an input of the seed is defined as follows In stage 0 the starting vertex is v j and the output is . At stage i for 0

The pseudorandom number generator stretches the h s log k bits of the seed to s log 2 k 1 bits. The size of the graph G p l is known to be about p 12 and so log k is O log p . Thus s log l O log p bits are being stretched to about s log p bits. When l is very small in comparison to p this is a considerable factor of stretching. Hence a seed input can be stretched relatively farther when the supersingular elliptic curve expander graph is established to have p l.

A specific mathematical approach to taking a walk around a supersingular elliptic curve expander graph is as follows. For the expander graph whose nodes are supersingular elliptic curves modulo a prime p and its edges are isogenies of degree t between elliptic curves the steps of a walk around the graph can be taken as follows 

Beginning at a node corresponding to the elliptic curve E first find generators P and Q of the l torsion of E l . To this end 

The j invariants in Fof the l 1 elliptic curves that are isogenous to E are j . . . j. They can be found as follows 

If the graph of supersingular elliptic curves with 2 isogenies is used for example a random walk can be taken in the following explicit way at each step after finding the three non trivial 2 torsion points of E they are ordered in terms of their x coordinates in a pre specified manner. The input bits are then used to determine which point to select to quotient the elliptic curve by in order to get to the next vertex or node in the walk.

Another Ramanujan graph that may be used by a pseudorandom number generator is the Lubotzky Philips Sarnak LPS expander graph This example expander graph is described in this subsection The construction of an LPS expander graph is accomplished as follows. It is given that l and p are two distinct primes with l a relatively small prime and p a relatively large prime. It is also established that p and l are 1 mod 4 and that the l is a quadratic residue mod p i.e. that l 1 mod p . The LPS graph with parameters l and p is denoted by X.

The vertices that make up the graph Xare defined as follows. The vertices of Xare the matrices in a projective special linear PSL group. More specifically the vertices of Xare the matrices in PSL 2 F which are invertible 2 2 matrices with entries in Fthat have a determinant of 1 together with the equivalence relation A A for any matrix A. Given a 2 2 matrix A with determinant the name for the vertex is the 4 tuple of entries of A or A depending on which is lexicographically smaller in the usual ordering of the set 0 . . . p 1.

The edges that make up the graph Xare defined as follows. Each matrix A is connected to the matrices gA where the g s are the following explicitly defined matrices It is given that I is an integer satisfying I 1 mod p. There are exactly 8 l 1 solutions g g g g g to the equation g g g g l. Among these 8 l 1 solutions there are exactly l 1 with i gboth 0 and odd and ii geven for j 1 2 3 . . . .

Regardless of the type of expander graph used by a pseudorandom number generator the input seed can be stretched exponentially using the following technique. Although the pseudorandom number output is consequently longer with this technique and exponentially so the walk around a given expander graph becomes merely pseudorandom.

To exponentially stretch an input seed a linear congruential scheme is employed. In an example of this implementation a finite field Fhaving a size approximately l is used a and b are elements of F. The starting vertex vis also fixed. It is given that xin Fis the seed. From vthe edge labeled xis used to determine v. At stage i xis set by x a x b. Also xis used to determine vwith vbeing the output. The seed size becomes log l and the output size becomes log p l. Thus the stretching factor is log p l log l .

The exponential stretching using a linear congruential scheme may be employed in one of at least two different ways. First the linear congruential scheme may be applied to lengthen the overall seed with the lengthened seed then being used to take a pseudorandom walk around a given expander graph . Second the linear congruential scheme may be applied to lengthen individual seed chunks with each lengthened seed chunk being used to determine a greater number of steps of the overall walk around a given expander graph as compared to an un lengthened seed chunk.

The devices actions aspects features functions procedures modules data structures schemes architectures components etc. of are illustrated in diagrams that are divided into multiple blocks. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses APIs arrangements etc. for pseudorandom number generation using an expander graph.

Although systems media devices methods procedures apparatuses techniques schemes approaches arrangements and other implementations have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

