---

title: System and method for replacing code
abstract: Computer-implemented methods, computer program products and data processing systems for transmitting a target code module to a server that is executing a computer program capable of using the target code module, and for obtaining the target code module at the server. The target code module is encapsulated in a base language code module, and the base language code module is transmitted to the server. The server receives the base language code module having the target code module encapsulated therein, and extracts the target code module from the base language code module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08645938&OS=08645938&RS=08645938
owner: International Business Machines Corporation
number: 08645938
owner_city: Armonk
owner_country: US
publication_date: 20061117
---
The present invention relates to debugging of computer program code and more particularly to debugging using hot code replace herein HCR .

Computer software comprises a set of instructions to be executed by a data processing system. Generally it is the computer software which makes a data processing system useful by providing the instructions for the data processing system to carry out productive tasks. Computer software provides instructions that enable a data processing system to function as for example a word processing device spreadsheet device or an Internet browsing device.

There are a wide variety of different data processing systems capable of using computer software. Accordingly as used herein the term data processing system is intended to have a broad meaning and may include personal computers laptop computers palmtop computers handheld computers network computers servers mainframes workstations cellular telephones and similar wireless devices personal digital assistants and other electronic devices on which computer software may be installed. The terms computer computer software computer program computer programming software software program and related terms are intended to have a similarly broad meaning.

Generally modern computer software is originally written in a computer programming language using syntactic constructs that are comprehensible by a programmer to represent the instructions embodied in the software. For example in the C programming language the syntactic term printf is used to represent an instruction to the data processing system to print the contents of a particular data field. These types of computer programming languages are useful because their syntactic constructs make it easier for programmers to create computer software since they do not need to compose instructions in a language that would be directly understood by the data processing system. Writing instructions in such a language would be far more difficult because such languages bear little or no resemblance to any human language. A computer program or a portion thereof written with such a human comprehensible programming language is generally referred to as source code . Software developers can create source code either by directly authoring the source code for example by entering the instructions into a text editor or more recently by using specialized software programs that provide a specially designed user interface and that partially or substantially automate the generation of source code.

Instructions written in human comprehensible source code however generally cannot be directly understood and implemented by a data processing system. Therefore before a computer program written in human comprehensible computer programming language i.e. source code may be used by a data processing system it must first be compiled into language that will be understood by the target data processing system. Compiling is a process usually carried out by a computer program called a compiler in which the syntactic constructs of the human comprehensible computer programming language are in essence translated into instructions in a language that will be understood by the target data processing system possibly through an intermediate software layer . The result of the compiling or compilation process is known as executable code meaning computer program code that can be executed by the data processing system either directly or by an intermediate software layer. Executable code is generally platform specific meaning that it can only be executed by a specific type of computer system. Accordingly source code must generally be compiled in a specific way to be executed by a given type of computer.

For certain computer programming languages such as Java the source code is first compiled into an intermediate form that can be implemented by an intermediate software layer such as a Java virtual machine hereinafter JVM . In Java this intermediate form is known as bytecode . Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both. Typically but not necessarily the intermediate software layer will carry out additional compilation each time the computer program is run usually to translate the intermediate form of the source code into executable code that can be directly executed by the data processing system. While the JVM itself is platform specific it enables any computer having a compatible JVM to execute a Java program that has been compiled into bytecode without the Java program having to have been compiled in a platform specific way.

Software developers being human are not perfect. As a result when software developers create or modify computer programs these programs frequently contain errors which cause the program to perform in a manner that was not intended. These errors are referred to as bugs and the process of identifying and correcting these errors is referred to as debugging .

Originally it was necessary for the software developer to make the correction in the source code and then compile the entire source code program into executable code. This process of correcting errors in the source code and then compiling the entire program again is time consuming particularly where only a single file needs to be modified.

In modern programming systems debuggers are used to assist programmers in locating problems in their programs by enabling the setting of breakpoints in the code and allowing the user to view and alter variables dynamically. More advanced systems allow users to modify their programs as they are debugging them with the modified program replacing the original instantaneously. Such a feature is called Hot Code Replace hereinafter HCR . In particular a software developer would use a computer program known as an application development tool usually having a graphical user interface hereinafter GUI to modify the software program that is being debugged. The application development tool is configured so that it can in response to the developer s changes build a single unit of code e.g. a Java class embodying those changes without having to rebuild the entire program. The original code unit is then replaced with the new code unit incorporating the developer s changes. An example of such a system is the Eclipse programming environment running with a compatible JVM. Unfortunately this HCR feature is limited by the environment to Java programs only.

HCR could be very useful for high level languages and visual paradigms such as BPEL Business Processing Execution Language Message Flows Data Maps Business Rules and the like. As used herein the term high level language refers to a language wherein the operations and data structures denoted in the language are strongly related to a problem domain such as for example business processes. Because of this such languages may be relatively difficult to compile directly into executable code and these languages and systems therefore often have their own specialized intermediate software layer or engine for executing programs written in that language. Typically the specialized intermediate software layer will generate instructions in a base language e.g. Java that will then be interpreted by an underlying intermediate software layer e.g. a JVM so as to cause the computer to implement the instructions embodied in source code written in the high level language. As used herein the term base language refers to a language wherein the operations and data structures denoted in the language are strongly related to machine level concepts. Base languages are therefore relatively easy to compile into executable code. For clarity intermediate software layers used to execute programs written in high level languages will be referred to herein as engines as noted above so as to distinguish them from the underlying intermediate software layer for the base language .

Unfortunately the engines for high level languages are frequently incompatible with the HCR functionality provided by the intermediate software layer for the lower level base language. Therefore when using such high level languages a software developer often has to use the old method of changing the source code compiling the program again and then re running the program to see the changes take effect. Even if the engine for the relevant high level language could support HCR it would be necessary to provide a mechanism to deliver changed programs to the intermediate software layer so that they could be incorporated into running system.

In one aspect the present invention is directed to a computer implemented method of transmitting a target code module to a server that is executing a computer program capable of using the target code module. The method comprises the steps of encapsulating the target code module in a base language code module and transmitting the base language code module to the server.

In one embodiment the step of encapsulating the target code module in a base language code module comprises representing the target code module as a character string and building a base language code module having a first parameter comprising the character string. In a particular embodiment the base language code module has a second parameter comprising a module identifier for the target code module and a third parameter comprising a version identifier for the target code module. In one embodiment the target code module is written in a high level language.

In another aspect the present invention is directed to a computer implemented method of obtaining a target code module for integration into an executing computer program capable of using the target code module. The method comprises the steps of receiving a base language code module having the target code module encapsulated therein and extracting the target code module from the base language code module. In one embodiment the target code module is written in a high level language.

In other aspects the present invention is directed to data processing systems and computer program products for implementing the above described methods.

Computer may be implemented using any suitable computer such as an IBM eServer computer or IntelliStation computer which are products of International Business Machines Corporation located in Armonk N.Y. Although the depicted representation shows a personal computer exemplary aspects of the present invention may be implemented in other types of data processing systems such as laptop computers palmtop computers handheld computers network computers servers workstations cellular telephones and similar wireless devices personal digital assistants and other electronic devices on which software programs may be installed. Computer also preferably includes a graphical user interface GUI that may be implemented by means of systems software residing in computer readable media in operation within computer .

With reference now to a block diagram of a data processing system is shown in which aspects of the present invention may be implemented. Data processing system is an example of a computer such as personal computer in in which code or instructions implementing the processes of the exemplary aspects may be located. In the depicted example data processing system employs a hub architecture including a north bridge and memory controller hub MCH and a south bridge and input output I O controller hub ICH . Processor main memory and graphics processor are connected to north bridge and memory controller hub . Graphics processor may be connected to the MCH through an accelerated graphics port AGP for example.

In the depicted example local area network LAN adapter connects to south bridge and I O controller hub and audio adapter keyboard and mouse adapter modem read only memory ROM universal serial bus USB ports and other communications ports and PCI PCIe devices connect to south bridge and I O controller hub through bus . Hard disk drive HDD and CD ROM drive connect to south bridge and I O controller hub through bus . PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS . Hard disk drive and CD ROM drive may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. A super I O SIO device may be connected to south bridge and I O controller hub .

A bus system may be comprised of one or more buses such as a system bus an I O bus and a PCI bus. Of course the bus system may be implemented using any type of communications fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. A communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter.

An operating system runs on processor and coordinates and provides control of various components within data processing system in . The operating system may be a commercially available operating system such as Microsoft Windows XP Microsoft and Windows are trademarks of Microsoft Corporation in the United States other countries or both . An object oriented programming system such as the Java programming system may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system .

Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processor . Aspects of the present invention may be performed by processor using computer implemented instructions which may be located in a memory such as for example main memory read only memory or in one or more peripheral devices.

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the present invention may be applied to a multiprocessor data processing system.

In some illustrative examples data processing system may be a personal digital assistant PDA which may be configured with flash memory to provide non volatile memory for storing operating system files and or user generated data. A memory may be for example main memory or a cache such as found in north bridge and memory controller hub . A processing unit may include one or more processors. The depicted examples in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a tablet computer laptop computer or telephone device in addition to taking the form of a PDA.

As used herein the term server refers to a computer system or portion thereof on which a computer program being debugged is running and the term client refers to an application development tool that is being used to debug that computer program. Accordingly it will be appreciated that as these terms are used herein the client and the server may reside on separate computer systems that are in communication with one another for example by way of a network on the same single computer system or even in the case of a Java environment on the same JVM. When debugging an application that is running on a server a channel will have been established between the client and the server. This channel is used to enable the client to send debugging commands to the server and to enable the server to send information to the client.

With reference now to there is shown a first exemplary arrangement in conjunction with which aspects of the present invention may be implemented where the client and the server reside on separate computer systems. In particular the client resides on a first computer system and the server resides on a second computer system . A channel between the client and the server enables the client to send debugging commands to the server and enables the server to send information to the client

Now referring to there is shown a second exemplary arrangement in conjunction with which aspects of the present invention may be implemented in which a client and a server reside on a single computer system . Analogously to the arrangement shown in a channel between the client and the server enables the client to send debugging commands to the server and enables the server to send information to the client

Systems that support HCR use the channel such as channel between the client and the server respectively for an additional function namely to send the units of code containing the developer s modifications to the program being debugged from the client to the server respectively . Thus the client the application development tool would build the single file representing the developer s changes to a particular portion of code and this file would then be transmitted along the channel to the server respectively at which point the debug portion of the server would immediately replace the running version of that file e.g. a Java class so as to enable immediate testing of the modifications.

As was noted above the engines for executing programs written in high level languages are frequently incompatible with the HCR functionality provided for the lower level base language used to cause the computer to implement the instructions embodied in source code written in the high level language. According to an aspect of the present invention a mechanism is provided by which changed programs can be delivered to an engine that has an application programming interface API for replacing running code even if it is running on a remote server. This mechanism can deliver such changed programs even where the changed program after being interpreted by its own intermediate software layer will ultimately be implemented by a different intermediate software layer typically one written in a base language and does not require the complexity of a separate channel to transfer the altered programs. Moreover the mechanism provided can leverage HCR capabilities provided by that other intermediate software layer. For example where the underlying programming system is a JVM compatible with Eclipse the mechanism can leverage the Java HCR provided by Eclipse. This invention assumes that the engine that executes the high level language has an API for replacing running code much as the JVM does. Accordingly one aspect of this invention is a mechanism for providing user updated code to a running engine.

Engines that interpret high level languages and which support debugging typically have hooks in the runtime which are callbacks to a debug runtime. Hooks represent the convention of calling a method or procedure in the debug runtime at regular defined intervals within the engine for the high level language. The debug runtime is thereby given a chance to check if a breakpoint is pending at that point in the high level program. The debug runtime can also perform other functions such as HCR.

The callbacks are the mechanism by which the debugger can implement breakpoints stepping etc. In accordance with an aspect of the present invention these hooks may be used to implement HCR as well. According to an aspect of the present invention the debug callback code will include an instruction to check to see if HCR has occurred and if so to provide the modified code to the engine. In order to do this it is necessary to transport the modified high level language code to the engine that will interpret it.

Because the software that generates the modified high level language code may be running on a different machine than the engine that will interpret it it is necessary to transport the modified high level language code on a channel that can transport between machines. Setting up an autonomous channel for this purpose can be complex may contravene security protocols and can also be slow. According to an aspect of the present invention an HCR mechanism provided by the base language tooling such as Java in Eclipse may be used to effect the transport of the high level language code.

Referring now to a computer implemented system for transmitting a target code module for example a module written in a high level language to a server that is executing a computer program capable of using the target code module is schematically illustrated.

An application development tool i.e. a client comprises a graphical user interface GUI a code generator and an encapsulator . The application development tool is connected to a server by way of a channel . In relation to and the application development tool corresponds to the client the server corresponds to the server and the channel corresponds to the channel . The server comprises an underlying base language software layer and a high level language software layer that is an engine .

In one example a human programmer not shown would use the GUI to make modifications to a computer program written in a high level language. The GUI would transfer the changes to the code generator which would produce modified code embodying the human programmer s changes. The modified code would then be transferred to the encapsulator . The encapsulator would then convert the modified code into a target code module and encapsulate the target code module in a base language code module . The base language code module is a code element written in the base language that can be executed by the underlying intermediate software layer for the base language. As noted above this base language software layer resides on the server to which the modified code is to be transmitted. One preferred example of a base language is Java in which case the base language code module may be a Java class. Typically the modified code and hence the target code module is written in a high level language. Once the target code module has been encapsulated within the base language code module the base language code module is transmitted via the channel to the server . Even where the target code module is written in a high level language because it is encapsulated within the base language code module it can be transported along the channel used for the base language. The base language code module having the target code module encapsulated therein will then be received by the server and processed by the HCR functionality within the base language software layer . The target code module can then be extracted from the base language code module and provided to the engine that will execute the target code module by means of appropriate APIs not shown .

In a preferred embodiment the encapsulator represents the target code module as a character string and builds a base language code module having a first parameter comprising that character string. Because the target code module is generally in the form of a human readable computer programming language made up of characters such as ASCII characters it is usually quite feasible to represent the target code module as a string of characters. ASCII stands for American Standard Code for Information Interchange and comprises a set of binary codes used to represent letters numbers and punctuation characters within computers. ASCII characters are those letters numbers and punctuation characters included within this set. The Unicode Standard may be used as an alternative to ASCII. Other suitable character standards may also be used.

Preferably the encapsulator will include a module identifier identifying the target code module within the base language code module . The module identifier may comprise for example a meaningful representation of the name of the target code module . In one embodiment the module identifier is a parameter of the base language code module and is represented by a character string. Also preferably the encapsulator will further include a version identifier within the base language code module . The version identifier provides an identification of the revision number of the target code module and in one embodiment the version identifier is a parameter of the base language code module and is represented by an integer. In a particular preferred embodiment the server will have a corresponding record not shown of the version identifier which upon system startup will be initialized to a default value of 1. In the application development tool when the encapsulator creates the first base language code module for a particular target code module it will set the value of the version identifier to 0 and for each subsequent base language code module for a particular target code module corresponding to a new iteration of that target code module the encapsulator will increment the version identifier by 1. The server will upon receipt of each base language code module having a new version of a particular target code module embodied therein check the value of the version identifier . This enables the server to track the current version of the target code module and also enables error checking e.g. whether the server failed to receive the base language code module for a particular version of a given target code module .

Thus the debug runtime for the application development tool includes a base language code module a class in the case of a Java based system which in a particular preferred embodiment includes three elements a module identifier a version identifier and a target code module . This base language code module is used as the medium by which modifications to the high level language program are transported to the engine such as engine .

With reference now to and two flow charts showing exemplary processes for implementing aspects of the present invention are shown. represents a process occurring on a client according to an aspect of the present invention and represents a process occurring on a server according to an aspect of the present invention. It will be appreciated as noted above that the client on which the process depicted in occurs e.g. application development tool will be in communication with the server e.g. server on which the process depicted in occurs for example by means of channel .

Referring first to at step a client such as application development tool in checks for a change in a component of a high level language program. For example a user may have modified the high level language program using a text editor or a visual editor and then saved the modified program. The modified program is usually saved in the form of a textual representation of the program such as an extensible markup language hereinafter XML representation. Where a GUI such as GUI in is used to make the changes the modified code may be created in response to the user input and saved by the code generator . Where Eclipse is used as the application development tool the change may be detected through the standard methodology of resource change listeners which are provided within Eclipse. If the client does not detect a change in the high level language program at step the client continues to monitor for such a change.

At step responsive to a determination that there has been a change in a component of a high level language program the newly saved textual representation of the high level language program is read and used by the application development tool for example by encapsulator in to create a new version of the base language code module such as base language code module having the textual representation encapsulated therein. This new version of the base language code module preferably has a version identifier such as version identifier in having a value equal to the previous value plus 1. The new version of the base language code module also preferably has a module identifier such as module identifier in having a value equal to the fully qualified name of the user s program. The name used is said to be fully qualified if it is sufficient to uniquely identify the program to the high level language engine which may be executing several different programs simultaneously.

At step the client will send the base language code module to the HCR mechanism provided for the intermediate software layer for the base language such as intermediate software layer . The HCR mechanism will transport the base language code module such as base language code module to the server such as server via the communications channel such as channel . Thus the intermediate software layer for the base language e.g. intermediate software layer on the server such as server will now hold the new version of the base language code module e.g. base language code module .

Reference is now made to where another process according to an aspect of the present invention is shown. The process shown in would be carried out on a server such as server .

At step the server receives a base language code module such as base language code module and passes it to the appropriate processes within the server. Step is preferably a recursive step in that the server preferably continues to be able to receive further base language code modules while and after passing an earlier received base language code module.

At step the target code module e.g. target code module stored as a variable within the base language code module e.g. base language code module is passed to the HCR API for the engine along with the value stored for the module identifier e.g. module identifier . An engine such as engine for the high level language will as one of the standard activities executed by the debug runtime at a debug callback check to see whether a component of the high level language program has been modified. In an exemplary embodiment the engine will check each incoming base language code module to determine whether the value of the version identifier such as version identifier for a particular component has been incremented. This enables the engine to update its database programs and begin executing the newly modified code embodied in the target code module.

In implementing aspects of the invention as described above one issue that must be considered is the possibility that the user could change multiple high level language programs in quick succession. Because a single base language code module e.g. base language code module is used to move each change to the high level language program such as target code module the possibility exists that a new change could be made before the previous change in the form of target code module is delivered to the engine such as engine . There are at least two possible approaches available to address this.

One approach is an acknowledgment based approach as illustrated in and . Analogously to and shows a process carried out on a client and shows a process carried out on a server.

Referring first to at step a client such as application development tool in checks for a change in a component of a high level language program. If no change is detected the client continues to monitor for a change. At step responsive to a determination that there has been a change in a component of a high level language program the application development tool creates a new version of the base language code module such as base language code module having the module corresponding to the change such as target code module encapsulated therein. At step the client will send the base language code module to the HCR mechanism provided for the intermediate software layer for the base language such as intermediate software layer so that the base language code module is communicated to the server for example by channel . Steps and are analogous to steps and in

At step the client such as application development tool waits for acknowledgement. This step will be described further below.

Now referring to at step the server receives a base language code module such as base language code module and passes it to the appropriate processes within the server. At step the target code module e.g. target code module stored as a variable within the base language code module e.g. base language code module is passed to the HCR API for the engine so that the engine can begin executing the newly modified code embodied in the target code module. Steps and are analogous to steps and in and some detail has been omitted from the above description to avoid repetition.

At step after the target code module such as target code module has been passed to the HCR API for the engine such as engine and the HCR process has completed the server sends an acknowledgement to the client such as application development tool . This acknowledgement may be transmitted through the channel used by the base level HCR mechanism e.g. channel . In one embodiment only a positive acknowledgement is transmitted following successful completion of the HCR process i.e. no acknowledgement is sent when the HCR process fails . In another embodiment a positive acknowledgement is sent when the HCR process completes successfully and a negative acknowledgement is sent when the HCR process fails. Such a negative acknowledgement can optionally provide additional information such as one or more reasons why the HCR process was unsuccessful.

As noted above at step the client awaits acknowledgement from the server. In the embodiment where only a positive acknowledgement will be sent the client e.g. application development tool may wait a predetermined period of time to receive the acknowledgement following transmission of the base language code module. If no acknowledgement is received within the predetermined period of time the client concludes that the HCR process failed. In the embodiment in which both positive and negative acknowledgements are sent the client will know from a negative acknowledgement that the HCR process failed. In either case the client such as application development tool preferably will not transmit any further changes in high level language programs to the server until an acknowledgement has been received. Preferably following a failed acknowledgement or a negative acknowledgment the client e.g. application development tool will not attempt HCR for any subsequent changes to that high level language program until the change for which HCR failed has been successfully implemented. At step in the case of a failed acknowledgement or if the client receives a negative acknowledgment the client delivers a message to the user that HCR has failed. Optionally a user may be permitted to override the system and direct that changes made subsequent to the failed HCR process be processed. If a positive acknowledgment is received at step the process returns to step to await the next change in a component of the high level language.

Optionally not shown in if the implementation technique chosen is to directly generate the revised base language code module such as base language code module in memory as will be discussed in greater detail below then the application development tool can continue to generate various new versions of the base language code module despite failure of the HCR process for a particular base language code module. These new base language code modules will simply be binary arrays in memory and will not actually be executing. The HCR mechanism provided for the base language can then be triggered for each base language code module in succession once appropriate acknowledgements have been received for previously triggered updates.

Another method by which to address the possibility that the user could change multiple high level language programs in quick succession is to maintain a rolling history in the base language code module. The base language code module such as base language code module can be modified in structure so that it holds updates to potentially several high level language programs. As updates are made they are appended to an update list which will reference all of the updates that are currently valid and are awaiting transport to the server. If this method is used it is desirable to limit the size of the update list for example by causing updates that were made more than a predetermined number of seconds ago to be expunged. While the implementation of a rolling history approach is more complex than the acknowledgement based approach it can be used in cases where the acknowledgement based approach is not practical. For example a rolling history approach can be used where network delays associated with waiting for acknowledgement are expected to be lengthy.

With reference now to and there are shown exemplary processes for using a rolling history technique to track successive changes to one or more high level language programs. Analogously to and and and shows a process carried out on a client and shows a process carried out on a server.

Referring first to at step the client checks for a change in a component of a high level language. If no change is detected the process continues to monitor for when a change occurs. At step responsive to a determination that there has been a change in a component of the relevant high level language program the client checks whether a base language code module already exists in memory. If no base language code module exists then at step the client reads the textual representation of the high level language program and creates a new version of the base language code module with the textual representation of the high level language program encapsulated therein. If at step it is determined that a base language code module already exists in memory then at step the client reads the textual representation of the high level language program and appends it to the update list in the existing base language code module so that the high level language program is encapsulated in the base language code module.

At step regardless of whether a new base language code module was created step or the high level language program was added to an existing base language code module step the client checks whether the condition s for transport of the base language code module to the server have been satisfied. One exemplary condition for transport of the base language code module to the server could be that a threshold number of updates are stored in the base language code module. For example if the user is modifying several high level programs as part of a group it may be desirable to wait until all the updates are completed before transporting the updates to the server.

If at step the condition s for transport of the base language code module to the server have been met then the client will at step transport the base language code module to the server and then clear the base language code module from the memory portion allocated to the current base language code module. It should be noted here that a copy of the base language code module may be retained in another portion of memory or in a storage medium even though it has been cleared from the memory portion it previously occupied. Such copy may be useful for example in case of a problem with the HCR process on the server. After the client has transported the base language code module to the server at step the client returns to step to wait for the next change in a component of a high level language program.

If at step the condition s for transport of the base language code module to the server have not been met the client returns to step to await the next change in a component of a high level language program.

With reference now to there is shown an exemplary process carried out by a server for example server for receipt and processing of a base language code module containing a plurality of target code modules embodying modifications to one or more high level language programs.

At step the server such as server receives the base language code module and passes it to the appropriate processes. At step the server such as server checks whether there are any target code modules remaining within the base language code module. If it is determined at step that at least one target code module remains within the base language code module then at step the server passes the next target code module for example the next target code module in the update list to the appropriate HCR API and then returns to step to check if there are any further target code modules in the base language code module. Optionally not shown if at step it is determined on the first test of a newly received base language code module that there are no remaining target code modules i.e. the base language code module was empty an error message can be returned to the client. If the server determines at step that there are no further target code modules in the base language code module then the server returns to step to await the next base language code module.

Although not shown it is to be appreciated that the acknowledgement based approach described in the context of and can be combined with the rolling history approach.

One factor in implementing aspects of the present invention is the means by which the application development tool is to construct the base language code module when modified code is saved by the user.

In one embodiment the application development tool such as application development tool can either automatically or in response to user commands construct a new program in source code and save it to disk. In a particular exemplary embodiment where Java is the base language the application development tool would construct the source code for a new class and save it with a suitable file name e.g. Transport.java . The saving of the program would trigger a builder which would generate a new class file e.g. base language code module using a compiler. The saving of the new class file would in turn trigger the base language HCR mechanism which would read the class and transport it to the server using the debug channel e.g. channel . This mechanism is simple but is not necessarily the most efficient.

An alternative approach which may be more efficient is to directly construct a new in memory version the base language code module e.g. base language code module thereby avoiding the compilation step. In the case of Eclipse and Java a new class file could be generated using one of the commonly available byte code manipulation libraries such as Byte Code Engineering Library BCEL . In the case of the exemplary embodiment described with respect to in memory construction of a base language code module is relatively straightforward because the structure of exemplary base language code module is simple namely an integer and two strings. Once the base language code module has been generated directly in memory the base language HCR mechanism can be triggered internally without the need to even save the base language code module to non volatile storage.

Furthermore the invention can take the form of a computer program product accessible from one or more computer usable or computer readable storage device providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable storage device can be any tangible apparatus that can store the program for use by or in connection with the instruction execution system apparatus or device.

The computer readable storage device can be an electronic magnetic optical electromagnetic or semiconductor system or apparatus or device . Examples of a computer readable storage devices include but are not limited to a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD RAN and DVD. The term computer readable storage device does not encompass a signal propagation media such as a copper transmission cable an optical transmission fiber or wireless transmission media.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

While the description of the present invention is directed toward the case where a target code module is written in a high level language it is to be appreciated that systems software and methods according to the present invention may also be used to transport a target code module written in a base language. Such an approach may be desirable for example where the base language in which the target code module is written is different from the base language in which the base language code module is written and HCR for the language of the target code module is not supported.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

