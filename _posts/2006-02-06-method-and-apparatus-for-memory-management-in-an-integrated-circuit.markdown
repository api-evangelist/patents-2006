---

title: Method and apparatus for memory management in an integrated circuit
abstract: Method and apparatus for managing memory logic is described. In one example, user logic, virtual port logic, and a processor are provided. The user logic is configured to provide allocation requests for the memory logic, access requests for the memory logic, and de-allocation requests for the memory logic. The virtual port logic is coupled to the user logic and the memory logic. The processor is coupled to the virtual port logic. The virtual port logic is configured to forward the allocation requests and de-allocation requests to the processor, and to process the access requests. The processor is configured to allocate space in the memory logic in response to the allocation requests and de-allocate space in the memory logic in response to the de-allocation requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07454587&OS=07454587&RS=07454587
owner: XILINX, Inc.
number: 07454587
owner_city: San Jose
owner_country: US
publication_date: 20060206
---
One or more aspects of the present invention relate generally to memory subsystems and more particularly to a method and apparatus for memory management in an integrated circuit.

Programmable logic devices PLDs exist as a well known type of integrated circuit IC that may be programmed by a user to perform specified logic functions. There are different types of programmable logic devices such as programmable logic arrays PLAs and complex programmable logic devices CPLDs . One type of programmable logic device known as a field programmable gate array FPGA is very popular because of a superior combination of capacity flexibility time to market and cost.

An FPGA typically includes an array of configurable logic blocks CLBs surrounded by a ring of programmable input output blocks IOBs . The CLBs and IOBs are interconnected by a programmable interconnect structure. The CLBs IOBs and interconnect structure are typically programmed by loading a stream of configuration data known as a bitstream into internal configuration memory cells that define how the CLBs IOBs and interconnect structure are configured. An FPGA may also include various dedicated logic circuits such as memories microprocessors digital clock managers DCMs and input output I O transceivers.

Currently circuits are designed for configuration in PLDs using either a behavioral language such as C Handel C and the like or a hardware description language HDL such as the very high speed integrated circuit hardware description language VHDL VERILOG and the like. In either case a circuit designer must explicitly specify memory architectures for the circuit design i.e. the allocation and partitioning of data over distributed memories . A circuit designer must spend significant design time for designing and coding the particular memory architecture for the design. Accordingly there exists a need in the art for a more flexible memory management in circuit designs for integrated circuits for example PLDs.

Method and apparatus for managing memory logic is described. In one embodiment user logic virtual port logic and a processor are provided by an integrated circuit. The user logic is configured to provide allocation requests for the memory logic access requests for the memory logic and de allocation requests for the memory logic. The virtual port logic is coupled to the user logic and the memory logic. The processor is coupled to the virtual port logic. The virtual port logic is configured to forward the allocation requests and de allocation requests to the processor and to process the access requests. The processor is configured to allocate space in the memory logic in response to the allocation requests and de allocate space in the memory logic in response to the de allocation requests.

In some FPGAs each programmable tile includes a programmable interconnect element INT having standardized connections to and from a corresponding interconnect element in each adjacent tile. Therefore the programmable interconnect elements taken together implement the programmable interconnect structure for the illustrated FPGA. The programmable interconnect element INT also includes the connections to and from the programmable logic element within the same tile as shown by the examples included at the top of .

For example a CLB can include a configurable logic element CLE that can be programmed to implement user logic plus a single programmable interconnect element INT . A BRAM can include a BRAM logic element BRL in addition to one or more programmable interconnect elements. Typically the number of interconnect elements included in a tile depends on the height of the tile. In the pictured embodiment a BRAM tile has the same height as four CLBs but other numbers e.g. five can also be used. A DSP tile can include a DSP logic element DSPL in addition to an appropriate number of programmable interconnect elements. An IOB can include for example two instances of an input output logic element IOL in addition to one instance of the programmable interconnect element INT . As will be clear to those of skill in the art the actual I O pads connected for example to the I O logic element are manufactured using metal layered above the various illustrated logic blocks and typically are not confined to the area of the input output logic element .

The FPGA architecture also includes one or more dedicated processor blocks PROC . The processor block comprises a microprocessor core as well as associated control logic. Notably such a microprocessor core may include embedded hardware or embedded firmware or a combination thereof for a hard or soft microprocessor. A soft microprocessor may be implemented using the programmable logic e.g. CLBs IOBs . For example a MICROBLAZE soft microprocessor available from Xilinx of San Jose Calif. may be employed. A hard microprocessor may be implemented using an IBM POWER PC Intel PENTIUM AMD ATHLON or like type processor core known in the art. The processor block is coupled to the programmable logic of the FPGA in a well known manner.

In the pictured embodiment a columnar area near the center of the die shown shaded in is used for configuration clock and other control logic. Horizontal areas extending from this column are used to distribute the clocks and configuration signals across the breadth of the FPGA.

Some FPGAs utilizing the architecture illustrated in include additional logic blocks that disrupt the regular columnar structure making up a large part of the FPGA. The additional logic blocks can be programmable blocks and or dedicated logic. For example the processor block PROC shown in spans several columns of CLBs and BRAMs.

Note that is intended to illustrate only an exemplary FPGA architecture. The numbers of logic blocks in a column the relative widths of the columns the number and order of columns the types of logic blocks included in the columns the relative sizes of the logic blocks and the interconnect logic implementations included at the top of are purely exemplary. For example in an actual FPGA more than one adjacent column of CLBs is typically included wherever the CLBs appear to facilitate the efficient implementation of user logic.

The circuit designer specifies a memory subsystem . The memory subsystem includes user logic memory virtual port logic and a processor . The user logic is coupled to the virtual port logic . The virtual port logic is further coupled to the processor and the memory . The processor is also configured to communicate with the memory . The user logic is configured to generate data to be stored in the memory and receive data from the memory as input. For example the user logic may provide data to be stored in the memory for use by software running on the processor . The user logic may receive data from the memory that has been stored by the software. That is the memory enables communication between the user logic and the processor .

The virtual port logic is a wrapper for the memory . That is the user logic does not interact with the memory directly but rather interacts with the memory through the virtual port logic . The processor is aware of the specific configuration of the address space for the memory and is configured to manage memory allocations and de allocations requested by the user logic . Once space is allocated the virtual port logic arbitrates access to the allocated space by the user logic .

In particular to obtain space in the memory the user logic provides an allocation request to the virtual port logic . The virtual port logic forwards the allocation request to the processor . The processor allocates a block of space in the memory in response to the allocation request and returns data indicative of the allocation to the virtual port logic . The virtual port logic registers the allocation and provides a handle to such allocation to the user logic .

To access the allocated block of space in the memory the user logic provides a memory access request to the virtual port logic along with the handle to the allocation. The virtual port logic grants access to the memory based on the allocation handle. In this manner the user logic may read data from the allocated block of space and write data to the allocated block of space.

To free the allocated space in the memory the user logic provides a de allocation request to the virtual port logic . The virtual port logic forwards the de allocation request to the processor . The processor de allocates the space in the memory and returns data indicative of such de allocation to the virtual port logic . The virtual port logic in turn un registers the memory allocation i.e. the handle becomes invalid .

The logic capture tool is coupled to the library . The library stores an application programming interface API associated with a memory model that provides dynamic memory management on PLD. The memory model is configurable and programmable via the API. Notably the API includes a set of primitives for defining structural and behavioral attributes of the memory model. A circuit designer employs the API to specify the memory subsystem of the circuit design . That is the memory subsystem is an instantiation of the memory model. In one embodiment the API includes a new construct and a free construct. When designing user logic an allocation request is implemented using the new construct. De allocation requests are implemented using the free construct. Such a programming model is similar to dynamic memory allocation in object oriented programming languages such as C .

The implementation tools are configured to receive the circuit design . The implementation tools produce physical design data for a target PLD from the circuit design . For example for FPGAs the implementation tools may include a map tool for mapping logic of the circuit design onto physical resources of the target PLD as well as a place and route PAR tool for placing the mapped design within the target PLD and routing connections. Such map and PAR tools are well known in the art. It is to be understood that the implementation tools may include other well known tools for other types of PLDs.

The logic block s coupled to each of the virtual ports comprise user defined logic for example using programmable logic of an FPGA. The memory or memories coupled to each of the virtual ports may comprise random access memory RAM such as BRAM in the FPGA. The processor may comprise an embedded processor in the FPGA such as a PowerPC processor or MICROBLAZE processor. With reference to the logic blocks e.g. logic blocks and comprise the user logic the memories e.g. memories and comprise the memory and the virtual ports comprise the virtual port logic . Each of the logic blocks may request memory allocation request memory access and request memory de allocation as described above for the user logic .

Notably the processor includes a table of virtual ports virtual port table . The virtual port table includes information indicative of which memories are coupled to which virtual ports . When the processor receives an allocation request from a given virtual port the processor allocates space in a memory that is coupled to that virtual port based on information in the virtual port table . In one embodiment the memory or memories coupled to a given virtual port have a particular base address in the collective address space. In other words each of the virtual ports is associated with a base address virtual port base address . When the processor receives an allocation request from a given virtual port the processor allocates space in accordance with the virtual port base address for the virtual port.

Returning to each of the virtual ports includes a table of memory allocations allocation table . The allocation table includes information indicative of associations between memory allocations and logic blocks. Each of the virtual ports provides a handle for each memory allocation. The allocation table may include a mapping between handles and logic blocks. In one embodiment each handle includes a base address in a particular memory to which space was allocated by the processor . In the present embodiment a logic block can only access those memories that are coupled its virtual port.

The logic block s coupled to each of the virtual ports comprise user defined logic for example using programmable logic of an FPGA. The memory or memories coupled to each of the virtual ports may comprise random access memory RAM such as BRAM in the FPGA. The processor may comprise an embedded processor in the FPGA such as a PowerPC processor or MICROBLAZE processor. With reference to the logic blocks e.g. logic blocks and comprise the user logic the memories e.g. memories and comprise the memory and the virtual ports e.g. and and the cluster managers comprise the virtual port logic .

In the present embodiment a hierarchical memory access scheme is provided. That is a logic block requests memory allocations memory access and memory de allocations from its respective virtual port as described above. The virtual port forwards allocation and de allocation requests to its cluster manager rather than to the processor directly. The cluster manger in turn forwards the allocation and de allocation requests to the processor . A logic block requests access to allocated memory e.g. read or write from its virtual port. The virtual port may access memories coupled thereto as well as memories coupled to other virtual port s through the cluster manager.

Notably the processor includes a table of cluster managers cluster manager table . The cluster manager table includes information indicative of which virtual ports a given cluster manager manages along with which memories a given virtual port manages. When the processor receives an allocation request from a given cluster manager the processor allocates space in a memory that is managed by that cluster manager based on information in the cluster manager table . In one embodiment the memory or memories managed by a given cluster manager have a particular cluster address in the collective address space. In other words each of the cluster managers is associated with a cluster address. When the processor receives an allocation request from a given cluster manager the processor allocates space in accordance with the cluster address for the cluster manager and a virtual port base address for a virtual port coupled to the cluster manager. The processor may allocate space using a virtual port base address for a virtual port that is not coupled to the requesting user logic but is controlled by the cluster manager.

Returning to each of the virtual ports includes a table of memory allocations allocation table . The allocation table includes information indicative of associations between memory allocations and logic blocks. Each of the virtual ports provides a handle for each memory allocation. The allocation table may include a mapping between handles and logic blocks. In one embodiment each handle includes a cluster address and a virtual port base address in which space was allocated by the processor . In response to an access request a given virtual port processes the handle to determine if the access request should be forwarded to the cluster manager. If the handle is associated with a memory coupled directly to the virtual port the virtual port processes the access request. Otherwise the virtual port forwards the access request to the cluster manager. The cluster manager then processes the handle to determine which of the other virtual ports the request should be forwarded. The cluster manager then forwards the access request to the appropriate virtual port which processes the access request.

At step the logic block provides an access request to the virtual port using the handle. At step a determination is made whether the access request is for a memory directly coupled to the virtual port. If so the method proceeds to step where the virtual port processes the request. Otherwise the method proceeds to step where the virtual port forwards the access request to the cluster manager. At step the cluster manager identifies another virtual port coupled to the memory associated with the access request and forwards the access request to the other virtual port. At step the other virtual port processes the access request. Steps through comprise access process . Access process may be repeated for each access request by the logic block.

At step the logic block provides a de allocation request to the virtual port using the handle. At step the virtual port forwards the de allocation request to the cluster manager. At step the cluster manager forwards the de allocation request to the processor. At step the processor de allocates the space in the memory. At step the virtual port un registers the memory allocation and invalidates the handle. The method ends at step .

The memory stores all or portions of one or more programs and or data to implement the system described herein. Although one or more aspects of the invention are disclosed as being implemented as a computer executing a software program those skilled in the art will appreciate that the invention may be implemented in hardware software or a combination of hardware and software. Such implementations may include a number of processors independently executing various programs and dedicated hardware such as ASICs.

The computer may be programmed with an operating system which may be OS 2 Java Virtual Machine Linux Solaris Unix Windows Windows95 Windows98 Windows NT and Windows2000 WindowsME and WindowsXP among other known platforms. At least a portion of an operating system may be disposed in the memory . The memory may include one or more of the following random access memory read only memory magneto resistive read write memory optical read write memory cache memory magnetic read write memory and the like as well as signal bearing media as described below.

An aspect of the invention is implemented as a program product for use with a computer system. Program s of the program product defines functions of embodiments and can be contained on a variety of signal bearing media which include but are not limited to i information permanently stored on non writable storage media e.g. read only memory devices within a computer such as CD ROM or DVD ROM disks readable by a CD ROM drive or a DVD drive ii alterable information stored on writable storage media e.g. floppy disks within a diskette drive or hard disk drive or read writable CD or read writable DVD or iii information conveyed to a computer by a communications medium such as through a computer or telephone network including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks. Such signal bearing media when carrying computer readable instructions that direct functions of the invention represent embodiments of the invention.

While the foregoing describes exemplary embodiment s in accordance with one or more aspects of the present invention other and further embodiment s in accordance with the one or more aspects of the present invention may be devised without departing from the scope thereof which is determined by the claim s that follow and equivalents thereof. Claim s listing steps do not imply any order of the steps. Trademarks are the property of their respective owners.

