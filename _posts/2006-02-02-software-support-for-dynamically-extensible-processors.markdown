---

title: Software support for dynamically extensible processors
abstract: A post-compilation tool can rewrite executable images produced by a compiler. The tool can add extension definitions, insert extension-trigger instructions, and add a security signature. Operating system software may be notified of extension capabilities when loading the executable image, and may proceed to load an appropriate processor extension. The operating system software can manage availability of processor extensions on behalf of the applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07757224&OS=07757224&RS=07757224
owner: Microsoft Corporation
number: 07757224
owner_city: Redmond
owner_country: US
publication_date: 20060202
---
While a CPU designer strives for generality every application program ever produced spends most of its time in a very small portion of the code that comprises its executable file image. This is true of general programs for personal computer use of programs for embedded computers and even for gaming platforms such as XBOX made by MICROSOFT Corporation of Redmond Wash. Analysis shows that the top two or three basic blocks in the executable file image generally account for well over 80 of the total execution count.

An appealing prospect for a more efficient execution of the program is to optimize the top running basic blocks with specialized processor instructions with the same semantic of the original sequence of general purpose software instructions but with a much more efficient implementation. Speed ups reported in the literature range from a factor of two to a factor of six and in some cases even larger to the tens and over. Our own experience leads us to consider a factor of three as the conservative estimate of the expected speed up.

The CPU of modem processors implements a well documented fixed set of processor instructions. The processor instructions are chosen to capture the largest possible set of application requirements in the most compact form possible. The CPU is normally realized in fixed logic in such a way that it is impossible to add any new processor instruction once the chip has been produced. On the other hand Field Programmable Gate Arrays FPGA are an alternative way to implement a CPU that does allow for later extensions and modifications even after the chip has been deployed in the field.

It is also possible to implement the CPU with fixed logic but with a dynamically changeable way to interconnect the internal components of the CPU. This approach can lead to new types of processors which we refer to as a dynamically extensible processors . These processors combine the advantages of fixed logic reduced size higher clock rate with the ability to add processor extensions to the base processor instruction set.

Practical use of an extensible processor should ideally make use of the extended instructions in application programs. Ordinarily a programmer makes use of an assembler or higher level language compiler to write the application program. This path can require re generating a new assembler and a new compiler for each new processor instruction. While certainly possible this is a rather time consuming operation. It is also fraught with limitations and dangers. If the program was in fact written in assembler it must be rewritten. Only high level language programs can automatically take advantage of the new instructions provided the compiler is modified to take advantage of them. Furthermore if we do not have the sources for the compiler the compiler may be impossible to modify. Compilers are large and complicated programs so it is very likely that subtle errors will be introduced. Finally we may not have the sources for the application program or for some crucial library it makes heavy use of.

Existing tools and operating systems are designed for a fixed processor instruction set and are not able to address the needs of a dynamically extensible processor. For example the XTENSA processor family manufactured by TENSILICA Corporation of Santa Clara Calif. is supported by a standard toolset in the following way The system designer uses special tools to define one or more processor instructions for a new processor starting from a base processor design provided by the manufacturer. The main purpose of this tool is to help create a Verilog code for the new extended processor. The tool automatically generates a new compiler and linker based on the manual definition of the new processor instruction. Notice that this procedure is static it requires the creation of a new chip as well as a new toolset before the application program can be compiled and optimized for it.

The following reference a copy of which is placed on file with the United States Patent and Trademark Office provides additional background on the design of customized and extensible processors Clark Blome Chu Mahlke Biles and Flautner . The Bibliography section refers to various other papers by the same and other authors that are also generally relevant to the work described herein.

Systems and methods are provided herein for software support of dynamically extensible processors. A tool can rewrite executable images produced by a compiler. The tool can add extension definitions insert extension trigger instructions and add a security signature. Operating system software may be notified of extension capabilities when loading the executable image and may proceed to load an appropriate processor extension. The operating system software can manage availability of processor extensions on behalf of the applications. Other advantages and features of the invention are described below.

Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the invention. Certain well known details often associated with computing and software technology are not set forth in the following disclosure however to avoid unnecessarily obscuring the various embodiments of the invention. Further those of ordinary skill in the relevant art will understand that they can practice other embodiments of the invention without one or more of the details described below. Finally while various methods are described with reference to steps and sequences in the following disclosure the description as such is for providing a clear implementation of embodiments of the invention and the steps and sequences of steps should not be taken as required to practice this invention.

In one embodiment the tool is distinct from a compiler that first compiles a particular application. The tool looks at a compiled executable image identifies basic blocks within the image and modifies the image by adding extension definitions inserting extension trigger instructions and adding a security signature . Supplementing an image with extension trigger instructions that cause a processor extension to perform effectively the same functional steps as would have been performed by a basic block enhances efficiency in executing the image.

In other embodiments the tool may be integrated into a compiler that is capable of identifying basic blocks and appropriately supplementing an executable image with definitions extension trigger instructions and a security signature as it compiles.

Extension definitions provide or refer to extensions that are used in extending a dynamically extensible processor. There may be a variety of extensible processors developed that use different extension techniques therefore no particular embodiment of a processor extension or particular extension definition is required. Instead an extension definition is defined herein as any information that may be used to extend a processor instruction set.

Extension trigger instructions are instructions that cause a processor extension to execute. Thus an executable image as modified by tool may comprise both extension definitions that are used by operating system to extend a processor and extension trigger instructions that cause the corresponding processor extensions to execute.

Security signature generally provides a means for checking that the modifications made to executable image were made by a credible authority and furthermore that the image has not changed subsequent to such modifications.

Operating system software loads the appropriate extensions e.g. and or and manages availability of requested extensions on behalf of the multiple applications. An operating system as that term is understood in the art is a software program that after being initially loaded into the computer by a boot program manages all the other programs in a computer. The other programs are the various application programs. The application programs make use of the operating system by making requests for services through a defined application program interface API . In addition users can typically interact directly with the operating system through a user interface such as a command language or a graphical user interface GUI .

To support dynamic extension of a processor operating system software may be notified of extensibility capabilities of executable image at application loading time either explicitly by the application invoking some API or implicitly by information contained in the executable file image . A security signature can attest to the correctness of the requested extension s . After checking the security signature the operating system can load a processor extension as provided by and into a processor extension slot e.g. .

The operating system can manage available processor extensions among multiple applications by keeping track of extension information on a per process basis as part of the protected state of the process. Extension information may also be tracked in a more complex multiprocessor setting. The operating system can ensure requested extensions are present and loaded when context switching between different application programs.

The modified executable image may contain the entire original basic blocks as well as the extension trigger instructions. This allows non extensible processors to nonetheless execute modified executable images simply ignoring the extension trigger instructions and falling through to the original basic blocks of code. The extensible processor on the other hand executes the extension trigger instructions and jumps over corresponding original blocks of code.

An extensible processor has only a limited number of slots for currently loaded extensions. The operating system manages these limited resources and can fall back to the non optimized cases when the requested extensions exceed the number of available slots .

For the purpose of this discussion a basic block is defined as a linear sequence of machine instructions that ends in a branch instruction. The branch can be conditional or not subroutine call and returns are branches. There cannot be jumps into the middle of a basic block it can only be entered on the very first instruction. In case of a jump into a block we will consider instead two blocks one each for the two entry points and both terminating at the same branch instruction.

With the now dominant use of higher level languages and compilers for code generation it becomes even more likely that basic blocks will repeat in actual code. Our analysis shows that if we consider a large set of application programs and look for repeated basic block patterns we will find that on average each pattern is repeated at least ten times. Some patterns repeat thousands of times.

In one embodiment tool rewrites executable images produced by a compiler and linker. Tool can be realized by modifying the linker of a regular compiler to perform tool operations thereby eliminating duplicated work. As shown in the input to the tool is the original executable program and a processor extension definition file . In an alternative embodiment processor extension definition file may be implemented as a database. Processor extension definition file identifies basic blocks that the tool can search for in an executable image . File may also provide the definition and machine readable coding of the extension trigger instructions which may be used to supplement the image when basic blocks are identified therein.

Finally file can supply extension definitions that may also be injected into image for use by an operating system in extending a processor. The tool finds basic blocks in the image that match the basic block patterns defined in the definition file and supplements them with new extension trigger instructions. At a logical level we can think of the rewriting operation as the act of supplementing a basic block or a set of basic blocks with an extension trigger instruction. Supplementing a basic block should be understood as acts including replacing the basic block replacing a portion of a basic block or adding to a basic block.

The exemplary file above identifies three instruction patterns each one being a basic block in canonical form plus some extra information. The first pattern which is named return by the bbname opening tag corresponds directly to the basic block used as a running example in . The other blocks called  ull div and R DrawColumnLoop c are presently considered useful in optimizing an actual application system.

As can be observed each pattern starts with the bbname clause that names the pattern. In this first section it is also specified to which type of processor the patterns belongs to in this case a Microprocessor without Interlocked Pipeline Stages MIPS BigEndian extensible processor. Depending on the implementation it may be desirable to collect patterns for different processors in a single file.

The encoding clause is a string that describes to the rewriter tool how to encode the actual arguments to a specific basic block instance of the pattern into an extension trigger instruction. The string is divided into two parts an optional precondition part depicted within angle brackets and a mandatory substitution part.

The precondition can contain multiple clauses separated by semicolons. Each clause refers either to a register or to a value that is a parameter of the pattern. For instance in the block return the clause specifies the condition that value parameter number 1 v1 must be equal to value parameter zero v0 plus eight. Very simple arithmetic expressions may be used that are quickly verified by the rewriter as preconditions before applying the pattern to a basic block instance. If the preconditions are not met the pattern is not applied. Preconditions on register parameters are of the form r and they refer to the register numbers themselves. We can avoid using precious space in the extended instruction if and when some register assignments can be inferred from some other register assignments.

The substitution part of an encoding comprises multiple clauses separated by semicolons. Each clause contains a bit field specification followed by a colon followed by an argument selector. The bit field starts with the letter b followed by the bit number of the first bit of the field inclusive. A dot separates the bit field size in bits inclusive. The argument selector can be either a register parameter r or a value parameter v or a binary constant c .

The code section is the binary representation of the basic block pattern for the processor. The keyword code is immediately followed by the size in bytes of the binary code that follows. In this exemplary embodiment each MIPS instruction requires 4 bytes. The code section thus provides the binary instructions that the extension replaces.

The disasm section is only for the user benefit as a reminder of what the meaning of the basic block is. Notice that the code here is in canonical form all registers have been renumbered starting at 1.

The registers section shows the assignment of actual register numbers found in the actual basic block that was abstracted into this pattern. The register substitution indicated in the first block return will lead directly to the code in . This clause indicates how many registers are specified by the pattern plus a special case for the MIPS processor who cannot make use of register number zero it being a special register with a wired value of 0.

The values section is used to represent constants in the pattern which could change from one instantiation to another. Here each value is a tuple of three elements enclosed in brackets. The first is the byte offset of the instruction that contains the value. The second is a processor specific code that indicates how the value is encoded. Typically a value here corresponds to a relocation code used by the linker loader to modify the instruction when it is moved around in the image file. The third is the actual value itself as found in the original basic block. This entire exemplary file except for the encoding section can be automatically generated by a separate tool as will be understood by those of skill in the art and which is not further described herein.

The tool will preferably be able to find every sequence of instructions that matches a given instruction pattern. One way to accomplish this pattern matching is as follows but more sophisticated algorithms are also possible and such variations will be appreciated by those of skill in the art.

The length of the instruction pattern and of the candidate block may be checked first then three processor specific analysis steps can be performed. In the first phase the two blocks are checked for opcode compatibility. A simple implementation might check that the instruction opcodes and opcode qualifiers in the two blocks are the same at the corresponding positions in the block.

The second step checks that the register assignments are compatible. If the instruction pattern contains a canonical register assignment the check for compatibility may proceed as follows First all register assignments for the candidate block are marked as unused. On each register encounter identify a register register N assigned to the canonical pattern. The register assigned to the candidate can be referred to as register M. Next identify a position of register N in the register assignment for the candidate block. If the position is unused the value of register M it can be assigned to it. If instead it has been assigned already check that the value is still M. If it is not then the two blocks are not compatible and the check fails.

The third step checks that any constant values embedded in the instruction blocks are compatible. If the instruction pattern indicates a value parameter for a given field then the candidate is free to have any actual value encoded otherwise the two fields must contain the same values. An example of a value parameter might be a branch offset field for the frequent case where two blocks only differ in their final branch destination. An example of a constant that must match might be a shift amount very rarely two sequences of instruction can be matched by simply changing such a field.

In a preferred embodiment the tool is not a replacement for pre existing compiler tools. Tool works after the tools of have been applied and the image has been fully optimized according to all the best known optimization techniques. In some embodiments it may be possible to gain further efficiencies by re applying the tools of after the tool has done its job.

A signed optimized executable binary image may take the form of the extended file format illustrated in . As illustrated the extended file format may comprise an image file header with section counts and offsets a security digest and signatures section an instruction extensions table two extensions are illustrated but there can of course be any number of extensions and any code section s .

Referring briefly back to there are at least four ways in which tool can supplement an image with extension trigger instructions. These various alternative embodiments are illustrated in . illustrates an original basic block before the image is supplemented by the tool. illustrate a basic block as supplemented with an extension trigger instruction. illustrates an embodiment in which the tool overwrites a first instruction in a basic block with an extension trigger instruction. illustrates an embodiment in which the tool overwrites the first instruction in the basic block with an extension trigger instruction and removes all the subsequent instructions in the block. illustrates an embodiment in which the tool inserts the extension trigger instruction before the basic block and moves all the remaining instructions in the image up. illustrates an embodiment in which the tool adds a pseudo branch instruction to the basic block which is moved elsewhere in the image.

In all cases executing the extension trigger instruction performs the same semantic actions as the original basic block and execution will continue exactly where the basic block would have led to. In for instance the basic block remains present but it is not executed when the extension trigger instruction is executed. In the remaining instructions of the block are similarly not executed when the extension trigger instruction is executed.

The extended instruction in encodes three arguments two registers and a stack offset. We would not be able to convey this information if we used therefore every block that matches this type of function epilogue would have to be coded separately. In other words cannot be reduced to like does.

Each solution has advantages and disadvantages. is efficient and easy to implement but is not backward compatible with non extensible processors. effectively require a full re linking of the image changing the relocation information the symbol tables etc. Modifying an original linker is one way to implement these solutions. can reduce the size of the executable image since on average one extension trigger instruction replaces a full basic block of at least two and typically many more instructions. Like it is not backward compatible. is functionally the richest it is backward compatible but it also creates slightly bigger images and it is more difficult to implement.

In some situations and may be the only acceptable embodiments. Consider the case of a basic block that contains a number of load and store instructions. To provide the required atomicity the loads and stores in the replacing extended instruction must either all succeed or all fail. This is not easy to realize in hardware it can be advantageous for the implementer of the extended instruction to be able to interrupt the execution at the equivalent address of one of the loads stores. To be fully compatible this may be the required implementation in some situations for instance if the load operation causes an exception.

Inserting extension trigger instructions in application images raises a number of additional considerations. Even though the processor is extensible we cannot assume that the extension is in fact available at execution time. The only processor instructions that are available with certainty are the ones in the basic set. We shall next consider the following two questions 1 What happens if the extensions are not loaded and we try to execute an extended instruction and 2 How can we guarantee that the extensions are loaded and managed properly 

The first question raises considerations which we refer to generally as backward compatibility . Whether the processor does not have the extension loaded or is not an extensible processor the executing system must either fail the image or execute it in the same manner as the original non optimized image. Failing the image is easy to realize the extended instructions can be considered illegal instructions and a trap can be generated when they are attempted. This is the most likely outcome on a non extended processor anyways. But failing the image is not the most desirable outcome in practice the user or system that asked for execution of that image expects it to work as originally intended despite the fact that not all the required preconditions are met.

If the tool has used the approaches of or this can be readily accomplished. The extended instructions can be considered as null instructions no op and execution will fall through or branch to the original basic block. A non extended processor will generate a trap to avoid performance penalties it is advisable for the operating system to realize what happens and transparently rewrite the offending extended instruction and replace it with a true non trapping null instruction. In one embodiment nullifying a portion of an application that calls for executing a processor extension instruction can be accomplished by changing a value of one or more processor extension control registers. An extensible processor may have this option as well the operating system might be lazily evaluating the requirement of loading the extensions and will use this trap as part of his extension managing algorithm. But it is also advisable that the processor has the option of non trapping and considering all illegal instructions as null instructions. One way to accomplish this is to provide in hardware a control register that software can use to define the processor behavior in the presence of extension instructions. In other words software should make the decision to trap or not.

With regard to the second question raised above there are a number of possible management schemes for handling processor extensions. In some instances the problem could simply be ignored. Consider the case of an embedded system or the case of a game console. In these cases the set of application programs is either known in advance or strictly controlled. For instance the manufacturer of the game console has put in place safeguards such that only certified games can be run on the console. The operating system in these cases will load the extension at power up time and will just assume that the application programs make proper use of the extensions.

In such scenarios one might ask why are those extensions not part of the base processor instruction set. There are many possible reasons on a game console the extension s could in fact evolve and over time new processor instructions are added but attention is always paid to preserve the old ones. Another reason might be economy of production. A single processor chip is produced in large quantities but it is then customized in different ways depending on its use. This could be rather appealing for embedded systems as the same processor would be optimized in different ways for different systems. If this is the management scheme used then the rewriter tool as described above will suffice.

Another approach that does not require any extra information in the executable file image is to uniquely encode each extended instruction such that the operating system can automatically identify the required extension when the instruction is first executed at which time it triggers an illegal instruction trap. The extensions themselves would be provided with to the operating system by other means. This approach has limitations guaranteeing uniqueness among unrelated parties such as the various software developers without a central clearinghouse is difficult and the number of extra opcodes available for encoding extended instructions can be quite limited. Any other management solution requires that the rewriter tool adds some extra information in the executable image.

If properly implemented the routing data cannot affect the security of the processor and therefore it is not necessary to apply security certificates to the executable image files to ascertain that the image has passed security validation. It is sufficient to insert a table in the image that associates the routing information with the specific extended opcode that uses it locally to this image. In the instruction extensions section holds a table with two such extensions the same routing data indicated generically in as Data . Notice that one such image is self contained and independent of any other image there is no need to deliver the extension data by other means and the operating system has enough information to be able to handle multiple images concurrently even though the same instruction opcode has different meanings for different images.

Another extensible processor embodiment might use a binary file that is loaded onto a FPGA as the extension data. The file is in common between many instructions. This type of processor design is such that an extension can perform arbitrary operations on the processor state and should therefore be certifiably secure. To secure such a processor an image that wants to make use of an extension can be required to uniquely identify the extension perhaps with a security certificate. The extension itself can be included in the image as encrypted and signed data.

In another extensible processor embodiment the extension is shipped and installed separately for example as part of an operating system. One advantage of this approach is that it minimizes runtime bookkeeping overhead. With reference to the route data elements in such embodiments comprise a small identifier for the given extension.

In a final extensible processor embodiment an extensible processor can be designed in such a way that the extensions cannot create a security threat as in the first embodiment described herein but they can still deliver many instruction implementations in a single extension as in the second embodiment described herein. For this embodiment it is preferable to identify the extension if it is not included with the image. The rewriter tool should add to the executable file image a security digest and signatures section depicted in .

In summary the rewriter tool inserts extension trigger instructions in the code section of an executable image and may also add extension definitions and or extension identifications and may further add a security signature and digest to the executable file image.

Software support for an application that is loaded on a system comprising a dynamically extensible processor and that has been rewritten as described above to take advantage of such a processor will now be described in detail. Software support maybe incorporated into an operating system comprising other operating system functionality.

In an exemplary embodiment the operating system is notified of an application s ability to take advantage of processor extensibility at application loading time. Such notification can be by explicit invocation of some Application Programming Interface API call or can be based on an inference made by the operating system based on information contained in the executable file image as defined in the previous section. Upon notification of extensibility the operating system can load any appropriate processor extensions into the extensible processor slots.

The operating system can keep track of the extensibility information on a per process basis as part of the protected state of the process. depicts the per process state that is required for the extensible processor of . It may also be advantageous to keep track of which processor extension is loaded in which slot of the available extensible processors in a multi processor system as is also depicted in . This knowledge can be useful for example if the extension data is relatively large and there are few extensions in use. In this case it might be possible to load extensions from different application programs at the same time. shows the route data replicated which requires potentially expensive comparisons. It is possible to keep the route data in a separate area and use pointers or indices instead.

The operating system loader can provide processor extensions to the operating system at application launch time. The loader may also help applications share processor extensions. Applications that are created by the rewriter tool using opcodes will generally have opcodes that all start at some value and progress in the same manner. This leads to collisions between opcodes among applications. To avoid this problem the loader can modify the opcodes in a newly loaded image such that they minimize the conflict with previously loaded images. shows the effects of this optimization. Because Process and Process use different opcodes they could both be scheduled on Processor without incurring in any management traps and Process can be scheduled on both processors. If we try to schedule Process on Processor we will instead incur a trap.

An extensible processor has only a limited number of slots for currently loaded extensions. The actual number could be as small as depicted in or much larger but it will always be finite. The operating system can be the arbiter that manages this limited resource on behalf of the application program s sharing it in an efficient manner.

This problem is similar to the problem of handling a floating point coprocessor and the state left in it by multiple application programs. Well known algorithms can be applied here with one crucial difference. In the floating point coprocessor case execution cannot proceed unless the coprocessor is made available because a there is changeable state left in it and b only the coprocessor is capable of executing the floating point instructions.

In our case assuming the rewriter tool uses the scheme illustrated in we are subject to neither of these constraints. Firstly the application state is held in the general purpose registers and not in a special unit unless the extension provides extra register state which is a case we do not further consider as it is similar to the floating point case. Notice that the route data is not changeable and does not need to be preserved across context switches. Secondly the code of the original basic block is still available therefore the operating system has the option of skipping the extended instructions and simply falling through to the original code. This is the reason why we prefer the extensible processor to leave it to software to decide whether to trap or not on an extended instruction.

Having the option to continue execution without the coprocessor opens the door to new more elaborate management algorithms. For example the operating system could 1 exclusively assign the resource to the application that 1a is observed to make the most use of it or 1b is selected by a human user and or 2 disable all extensions on interrupts assuming that interrupt service routines will not make use of them or to guarantee predictable response times and or 3 load as many extensions as there are available slots and fall back to the non optimized basic blocks otherwise and or 4 use a least recently used algorithm to handle what is effectively a cache of extension data.

In addition to the specific implementations explicitly set forth herein other aspects and implementations will be apparent to those skilled in the art from consideration of the specification disclosed herein. It is intended that the specification and illustrated implementations be considered as examples only with a true scope and spirit of the following claims.

