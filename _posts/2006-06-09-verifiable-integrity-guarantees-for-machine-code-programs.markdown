---

title: Verifiable integrity guarantees for machine code programs
abstract: A verifier performs static checks of machine code to ensure that the code will execute safely. After verification is performed, the code is executed. The code modules generated by the rewriter and verified by the verifier prevent runtime code modifications so that properties established by the verifier cannot be invalidated during execution. Guards ensure that control flows only as expected. Stack data that must be shared within a code module, and which may therefore be corrupted during execution, is placed on a separate data stack. Other stack data remains on the regular execution stack, called the control stack. Multiple memory accesses can be checked by a single memory-range guard, optimized for fast access to the most-frequently used memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08104021&OS=08104021&RS=08104021
owner: Microsoft Corporation
number: 08104021
owner_city: Redmond
owner_country: US
publication_date: 20060609
---
The subject matter of this application is related to that of U.S. patent application Ser. No. 11 036 121 titled Software Security Based On Control Flow Integrity and of U.S. patent application Ser. No. 11 036 801 titled Software Memory Access Control both of which were filed on Jan. 14 2005. Each of the above referenced patent applications is incorporated by reference in its entirety.

A computer system s reference monitor may look at memory accesses made by a program to ensure that the accesses are acceptable. Before use of the reference monitor computers may have had difficulty because one program could attempt to access another program s memory. Such accesses could be insidious causing programs to misbehave while creating difficulties in diagnosing problems. Thus reference monitors were inserted into hardware systems to observe accesses to memory. The reference monitor may generate an exception if a program attempts to improperly access memory.

A problem that may be associated with reference monitors is that they may not be able to prevent insidious memory accesses by one portion of a program vis a vis another portion of the same program. That is computer systems may not use the reference monitors at the lowest levels such as at the operating system s kernel level. Rather system operations may be separated into programs and the operating system may switch between them with each being subject to the reference monitor in a particular way. Therefore a program may be unable to protect different components or subprograms of itself from each other. Similarly the operating system kernel may be unable to protect itself from its components unless it forces those components to run as programs.

While software based solutions to problems associated with the reference monitor have been implemented many of these solutions are not practical. Specifically the solutions fail to address practical requirements or characteristics of software. For example software typically is multi threaded. Also the system may have to increase and decrease the amount of memory allocated to the software during execution. Software execution is sometimes interrupted. Finally software needs to handle exceptions or normal transitions in control flow. The solutions offered to combat problems associated with the reference monitor may not account for these practical requirements or characteristics of software.

A verification is performed to identify in a machine code module that is in a module having instructions that are directly interpreted by computer hardware that operations associated with shared state are proper. The verification may be a static verification to ensure for example that values assigned to references to the shared state are proper. The verification may also look at guards within the code modules to ensure that the guards will perform checks at execution to ensure proper assignment of values proper control flow integrity etc.

A verifier performs static checks of machine code to ensure that the code will execute safely. A stand alone code rewriter or a rewriter in conjunction with a compiler can be used to rewrite code including legacy code so that the code will pass the checks performed by the verifier. After verification is performed the code is executed. The verifier may perform static checks that include the verification that code for proper dynamic checks or inline guards are present in the code. These dynamic checks may be executed at runtime to ensure continued safe execution.

The protection offered by the verifier can benefit any host systems such as operating systems and web browsers that load binary modules into their address space to make use of their functionality. The code modules generated by the rewriter and verified by the verifier may prevent runtime code modifications so that properties established by the verifier cannot be invalidated during execution. Guards ensure that control flows only as expected even on computed transfers and that memory is accessed only as expected. Additionally stack data that must be shared within a code module and which may therefore be corrupted during execution is placed on a separate data stack. Other stack data including function return addresses remain on the regular execution stack called the control stack. The control stack is not accessed via computed memory references such as pointers and therefore can be used to provide incorruptible thread local storage. Moreover multiple memory accesses can be checked by a single memory range guard optimized for fast access to the most frequently used memory. Memory guard ranges are implemented as two paths one faster and the other slower.

The rewriter may complete static analysis e.g. of control flow stack use and registers and analysis may not be linear. In alternative embodiments analysis may be simplified and more precise if the code modules to be evaluated by the verifier were output by a code generation phase of the compiler . Such compiler support while not required could make more thorough use of mechanisms described herein help reduce overhead and remove some limitations that may be present without such compiler support.

After processing and structuring code a safe executable code module may be sent to the verifier . Thus the code module may be an executable binary that is structured to satisfy verification. The verifier may perform static analysis of code modules to ensure for example that all execution paths contain correct guards before any possible protection violation. In this way software that hosts such modules need trust only the verifier . In particular static verification may establish restrictions on control flow including computed control flow transfers such as calls via function pointers. The analysis may be facilitated by guards that may constrain control flow at runtime. Though they do not include logical proofs the code modules may be viewed as examples of Proof Carrying Code PCC as described in G. Necula Proceedings of the 24ACM Symposium on Principles of Programming languages pp. 106 119 January 1997 which is incorporated herein by reference in its entirety. Protections as described herein may be implemented to help prevent runtime code modifications so that any properties established or verified by the verifier cannot be invalidated during code execution.

The verifier may be relatively fast in that it may run as a simple linear pass over the bytes of the code module from the rewriter or in alternative embodiments the compiler . The verifier may perform comparisons and parse table lookups. That is the verifier may include a simple object file parser and instruction decoder. The verifier may do local reasoning about individual basic code blocks and may rely on hints about global analysis results that are placed into the object file e.g. by the rewriter. These untrusted hints may enable elaborate verification with a simple linear scan verifier . A similar strategy may be used by Java and CLR byte code verifiers or proof carrying code systems.

As explained the verifier may check that other safety mechanisms are used correctly by enforcing constraints. One constraint may be that the program use only certain machine instructions for which the verifier is able to enforce safety. Another constraint may be that memory access instructions are preceeded by appropriate runtime memory range guards. A third constraint may be that control transfer instructions either have known targets in a code segment or are indirect and are preceeded by a correct control flow instruction guard. Such guards are described in U.S. patent application Ser. No. 11 036 121 titled Software Security Based On Control Flow Integrity. Another constraint may be that the data stack and the control stack as described here are managed properly. For example data and control stack pointers may be updated only by constant amounts the code may contain stack overflow guards the return address and other virtual registers are saved and retrieved from the control stack only and the heights of both stacks are preserved across function calls.

The operations that may be verified through the method may be any operations that involve state that is memory that is shared between the machine code module being verified and any other code module. Such a shared state may be for example a hardware register. The hardware register may be for example an instruction pointer a stack pointer a flags register a processor control register or an implicitly referenced register. Such a shared state may be include a control stack a thread control memory a process control memory and control memory for handling of exceptions or signals.

The method may be performed at the creation of a code module or may be performed by an end user of the code module. Additionally the method may be performed at any point during distribution of the code module such as for example by a retail store preparing to sell the code module to a customer. As described herein the method may be performed by hand e.g. by a person reading the applicable program code . Alternatively the method may be performed by a verifier such as the verifier or by a rewriter such as the rewriter . In other alternative embodiments the method may be performed by a compiler such as the compiler or by a run time code generator.

The method may start at step with identification of references to shared state within a code module. The code module may include machine code. That is the code module may include code that is directly interpreted by computer hardware. An example of such a code module is a binary module. The code module may share state that is computer memory with other programs or code modules of a computer system. It is the references to this shared state that may be verified through the method .

After the references to shared state are identified a static verification of operations associated with the shared state may be performed at step . Step may be performed for example to verify assignment of values to the shared state. That is the verification method may include checking the assignment of values known prior to execution.

For other operations performed during execution of the code module that are associated with for example assignments or values that may be indeterminate prior to execution step may verify that in line guards within the code module are prepared to ensure that the other operations will be executed properly. For example the verification at step may ensure that guards will check values prior to assignment of the values to ensure that the values are proper. The guards may check the address of an assignment to ensure that the address unknown prior to execution is proper. The guards may ensure that an assignment will actually be executed during execution of the code module. The guards may include for example control flow integrity guards and therefore the verification at step may ensure that the guards will properly monitor control flow. Alternatively for example such guards may include a check of a first address of shared state at execution as well as a check of a range of addresses contiguous to the first address to ensure that other indeterminate data may be written to this contiguous range during later execution. Other such in line guards are also envisioned.

Verification may proceed by considering the execution of machine language instructions on abstract program states that encode known facts about the state of the execution. For each instruction the verifier may ensure that the abstract state guarantees safe execution of the instruction and may compute the abstract state for the successor instruction. These abstract states may be viewed as limited predicates describing concrete execution states and abstract execution of an instruction can be expressed as a Hoare triple start state instruction end state. shows a fragment of the verification state for an example program. On entry to this program fragment the verifier may know that the original value of the code stack pointer is 8 more than the current value the return address is in the virtual register at address CSP 4 control stack pointer 4 and the value on function entry of the data stack pointer is stored in the virtual register at address CSP. Finally the addresses between DSP 32 and DSP are known to fall into a contiguous accessible memory region.

The verification state may keep track of the contents of the virtual registers the control stack frame . This is possible because the verifier may enforce a requirement that all accesses to those memory locations can be statically detected as using known constant offsets from the control stack pointer.

The verifier may recognize the meaning of the instructions that make up the memory range guard in line and may add the corresponding fact to the verification state for the following instruction. All of the previously known facts are preserved in this case. For clarity shows only modifications to the verification state. All the memory accesses in this program may be checked using the valid facts. The arithmetic operation implicit in the pop instruction on line may be reflected in the verification state by replacing CSP with CSP 4. Note also that incrementing the CSP may effectively shrink the memory range accessible through CSP. This may help ensure that the code does not rely on the contents of the stack below CSP as it can be set to arbitrary values at any time upon an asynchronous interrupt. In line the verifier may recognize a function return and it may check that the stack pointers have been restored to their original values and the proper return address is used. To enable this reasoning the verifier may include support for manipulating linear equalities and inequalities.

To simplify the process of verification the module i.e. a protected binary may include a set of verification hints that guide the verifier . For the simplest version of the verifier the hints may provide the verification state for the entry to each basic block. A basic block is a sequence of machine code operations that execute in sequence without any control flow.

The verification may be done one basic block at a time and on basic block exit the verifier may check that the accumulated verification state implies the provided state for the successor blocks.

As described herein the verifier may also ensure that the proper control flow integrity guards are used at computed control transfers. First the verifier may expect hints to specify the set of possible targets of computed jumps which in turn may allow the verifier to collect the set of control flow integrity target identifiers used in the module. The verifier may also scan the machine code of the module to ensure that the only occurrences of the identifiers are at the beginning of basic blocks. Finally the verifier may allow computed control flow only when the verification state records the fact that an appropriate control flow integrity guard has been performed.

The structure that allows a module to pass verification can be established by hand by compilation from legacy source code or by automatic transformation of existing machine code binaries. It should be understood that verification of a code module may be completed for example by users of extensible systems to establish the module s safety before it is installed or executed. Verification may be useful in other scenarios as well. For instance for systems structured as distinct modules with clearly defined interactions verification may be a quality assurance step during software production.

The verifier may prevent execution of dangerous privileged instructions such as for example the IRET . As the verifier statically evaluates a code module it may ensure that for example there are no instances prohibited operations.

The verifier additionally may also access a counter placed in memory that may be inaccessible to a program. The counter may enable a special runtime guard to count how many instructions the program has executed. For example the counter may increment for all instructions included in a basic block. Such incrementing may also be completed simultaneously for basic blocks executing simultaneously. When the counter reaches a certain value an exception may be generated to halt program execution. Thus the special runtime guard may time limit or instruction limit program execution.

Protections described herein may benefit any host system that loads binary modules such as the code module into its address space to make use of their functionality. Operating systems are example host systems as are web browsers. Conversely those modules may rely on their host system by invoking support routines. For example the code module in can use two support routines and can be called through a single entry point by its host system. The module can read its code and constants or optionally all of memory . It may write to a section of its loaded module binary and to contiguous heap regions to which the host system has granted it write access.

The code modules protected in the manner described herein may be normal executable binaries e.g. DLLs and can be loaded and used as such. As a result host systems may be unaware whether or not they are using such a protected code module . For multi threaded systems or those with complex access to memory protection according to alternative embodiments does rely on some support components in particular for thread specific management and for the granting and revocation of memory access permissions.

The codes module may be a dynamically loadable executable in a host system appropriate object format. In one implementation the code module is one of a Microsoft Windows Portable Executable binaries often named EXEs or DLLs for example.

The code module may consist of multiple sections each of which may have different access permissions. Machine code may be in one executable section and program data such as read only constants and writable global variables may be in others. Data in import and export sections allow the determination of module entry points and use of host system support routines. Other sections and a module header may provide host systems with auxiliary data e.g. for load time relocation of the binary module versioning cryptographic signatures etc. Once a module is loaded auxiliary sections may be discarded from memory.

Protection in alternative embodiments may rely on several module sections. Import sections as well as host system policy may limit a code module s use of support routines similarly memory access may be constrained by section access permissions. A relocation section may be used to give proper values to module constants such as the constants A L used in memory range guards described further herein. Finally an auxiliary section may be used to hold untrusted verification hints also described further herein.

Code modules can help establish efficient memory protection. For example writable fastpath memory as described further herein may lie completely within the read write section of the code module . Once loaded the code module can have any amount of this memory a section header value gives its size . In this embodiment the code module or its host system may provide a heap implementation that allocates memory within that region. A large fastpath region may not be a waste of physical memory. That is host systems with virtual memory support can allocate physical pages as requested by the code module e.g. by a call to a support routine . This strategy may be attractive for 64 bit systems where ample virtual size can be given to fastpath memory.

While the verifier may perform a static check of a code module which may include the source code excerpt alternative embodiments may include runtime protection mechanisms as well. Broadly a stack may include two types of information. First a stack may include a summary of execution of a program so far. Second a stack may include prescriptive information related to what may happen in the future. An embodiment incorporates a recognition of these two types of information and the related functions of a stack.

Stack data that may be shared within a code module and that therefore may be corrupted during execution may placed on a data stack . The data stack thus may not be critical for safety but may instead keep track of certain intermediate program state. The data stack may therefore include a summary of execution of a program so far.

Other stack data including function return addresses may remain on the regular execution stack which may be referred to as the control stack . In the code module the control stack may be prevented from being accessed via computed memory references such as pointers and may therefore be used to provide virtual registers incorruptible thread local storage for code module state. In one embodiment the control stack may include a stack register that points to at least a fixed amount of writable stack memory. Additionally the stack may accurately reflect function calls returns and exceptions to that point. Thus the control stack include prescriptive information related to what may happen in the future.

Thus by including distinct data and control stacks embodiments provide safety in relation to memory accesses. For example for a computed write safety may depend not only on the address but also on the value being written. For safety the write may be prevented from corrupting memory that holds values whose integrity must be maintained such as return addresses stored on the control stack . Therefore the control stack may be used in a stylized structured manner and may not be the subject of a computed memory access. A separate data stack may be used for those stack values that a code module may access via a pointer. These may include all stack values whose address is taken e.g. local arrays or local variables passed as call by reference arguments to functions .

Explicit references to the control stack may be to for example CSP K where K is a positive properly aligned constant and CSP is the control stack pointer register. In one embodiment implementation of CSP is an x86 stack register ESP so that pushes pops calls and returns use the control stack . Furthermore at each instruction of a module function the control stack may be of a known constant depth. Finally within each function CSP can be lowered and raised by constant amounts in a controlled fashion.

The memory of control stacks may not be accessible to a code module except in the manner described herein. Therefore locations on the control stack can function as virtual registers that is like registers they are thread local state that may be accessed by name.

On the other hand thread local module data that is subject to computed memory access may be stored on the data stack indexed by a data stack pointer DSP register. In one embodiment an x86 register EBP may be used to hold DSP. Within each function DSP can be modified only in a controlled fashion by either a constant amount or one bounded by a guard. DSP may be preserved by a function call.

Usually both the control and data stacks may be accessed through hardware registers CSP and DSP. However sometimes an additional base pointer may be used for instance for variable size allocation of data stack memory of the kind done by alloca in C. In these cases more registers some of them virtual may act as stack pointers. Guards may be used be placed at each module entry point as well as in any cycle in the module s function call graph.

When the verifier inspects a program or module the verifier may ensure that the program uses the stacks properly. If a program does not use the control stack properly program execution may be halted. Thus the verifier may establish that when a function is called and when there is a return from a function the call and return operations incorporate a stack pointer pointing to the control stack . In one embodiment the verifier may ensure that no other operation modifies a value in the control stack register. Similarly there may be a data stack register and accesses to local variables and arguments of a function may be made through that data stack register. In further alternative embodiments a data stack register may only be changed in a controlled fashion. For example the data stack register may be changed to reflect all of the local variables of a function before that function calls another function. In one embodiment this can be implemented by having the calling function or caller subtract from the data stack pointer the space consumed by the caller function or the calling function local variables and the argument that it is about to pass on to the callee. Immediately after the called function the destination has returned the same value subtracted earlier may be added back.

Further the control stack in one embodiment may only be modified by call and return operations. In another embodiment the control stack may be modified by pushes and pops of register values as long as those pushes and pops are appropriately nested in the control flow so that there is a matching pop for every push as the program executes. The verifier would need to establish that. This might mean that dynamically at runtime all pushes will have to be matched to pops before the call of any function before the end of any function or before the end of a basic block.

Thus an embodiment includes a two stack model of execution. In general host systems may support this model in particular by allocating and managing the data stack and by copying arguments and results between stacks . In an alternative embodiment no data stack may be needed for certain simple code modules such as for example code that does not use stack arrays and does not take the address of stack memory. A host system that loads only such modules may omit all support for data stacks.

In alternative embodiments discontiguous threaded stacks may be maintained via stack validity checks. When a code module is executed memory may be preallocated for the execution. If the size of this preallocated memory is not large enough more memory discontiguous with the preallocated memory may be dynamically allocated during the execution. The verifier may need to check to ensure the structure of discontiguous stacks is maintained. For example the verifier may establish that on any modification to the stack pointer in particular a call to a function higher up in the function the structure is maintained.

Additionally guarantees may be implemented for example on the ESP register for x86 ring 0 avoidance of double faults. The verifier may ensure that the control stack pointer register includes a valid address with at least three spaces for writing. The x86 flags register may be safely saved on the control stack. Only condition codes may be changed and code may pushed and popped in safe ways.

In addition to using a incorruptible control stack distinct from a data stack another runtime memory protection mechanism involves optimized checking of multiple memory accesses by a single memory guard. This single memory guard may promote fast access to the most frequently used memory. This may help reduce the number of checks required by ensuring multiple instructions have been checked within this bounded padding area on either side of an address.

In alternative embodiments protections may be included to maintain a structural property or a structure of the control stack . Thus protections may be included to prevent any over writing. For example the control stack may be required to be structured in a particular sequence. The verifier may check to ensure that the stack maintains its required structure by evaluating the sequence. Thus the control stack may be protected such that its data is incorruptible and its structure is correct.

One aspect of the structure of the control stack for example that may be important to maintain is the exception frames. It may be important to maintain a first in last out sequencing of the frames. The exception frames may contain pointers to each other and thereby exception frames may be linked to previous exception frames. The verifier thus may help maintain the integrity of the nestedness property of the control stack . The verifier also may ensure that only the exception frame creation code can modify links that precede a frame.

Whether using separate data and control stacks a code module may be able to access memory that contains its code read only constants and writable global variables in order to execute read and read or write that memory respectively. In addition a host system may wish to give selective access to other memory regions. In alternative embodiments guards for enabling the use of those additional regions in any number and of any granularity and type of access may be used.

A code module may have access only to a certain set of contiguous memory regions for each type of access a certain range such as two bounds established by a loader such as for example A to B may be special as explained herein. For constant addresses and the control stack this property may be established by static verification by the verifier . A guard may be used for other accesses.

Memory range guards may help ensure that a register holds an accessible address they also ensure that a range around this address is also accessible within constant offsets L low below and H high above . Control flow integrity may imply that a single such guard can protect multiple memory accesses namely those that it dominates use the same register value and remain within the constant range bounded by L and H. Similar but more complex memory range checks may ensure that only accessible addresses are used in simple loops such as the x86 REP instructions for example. In this case L or H may be variable but are bounded by the guard.

Thus one embodiment may make use of a fastpath region with endpoints A and B. Those endpoints may be embedded as constants in the memory range guards and may be set during loading. Typically fastpath memory is a region of the code module and endpoints may be relocation constants which may be set automatically during loading. However the fastpath endpoints could be any region or even held in reserved registers.

If the fastpath comparisons fail then the guard may call a host system slowpath search with appropriate arguments. The slowpath may search to see if the address range lies within any other accessible memory regions. The address and the values L and H are parameters to this search. The search itself may be arbitrary code and may for example involve direct comparisons or data structures similar to page tables. The search may be invoked by a direct jump a trap or fault e.g. the x86 bounds exception or by other explicit or implicit control flow.

For example for an x86 processor the memory range guard may call a slowpath function. However as shown in this call is not placed inline because this may waste code cache and also because forward branches may be predicted as not taken by default. In one embodiment guards may raise exceptions caught by a slowpath guard provided by the host system paths. Alternatively the use of an x86 BOUND instruction may be avoided both because it is significantly slower than the example guard but also because for example in the Windows kernel bounds exceptions are treated as fatal conditions.

In addition to providing optimized checking of multiple memory accesses by a single memory guard another optimization may be to include the data stack in slowpath memory. One of the pieces of memory that may have to be added dynamically to a program is the set of threads that are currently executing in the program because the set of threads using a program may be unbounded. Therefore when the program is executed slowpath memory may be created and the data stack may be placed in that memory.

Thus there may be one range bounded by a special A and a special B and the memory range guard may check only whether X plus minus the padding is within that special range. This may be placed in the code itself. If that check for some dangerous operation fails then a check of all other A s and B s may be completed. In fact that first AB range might be part of the program itself because programs and packages like executable files or DLLs include both code and data.

Additionally in the slowpath memory range guards may search permission tables e.g. runtime data structures maintained by the host system that hold the set of accessible memory regions. There may be multiple such tables one for each type of slowpath access. Each search may check whether a range R L to R H lies within a contiguous memory region to which the host system has granted access.

Searching these tables may be fast as some software will access memory in a manner that frequently calls the slowpath of memory range guards. Fortunately fast permission tables can be implemented in several ways. In particular by making permission tables similar to page tables searches can use known efficient techniques for software filled translation look aside buffers.

In one embodiment permission tables are very simple a null terminated list of address pairs of the start and end of regions. Searches of this data structure can be lockfree at least on the x86 as long as updates are done carefully e.g. if an entry is revoked by setting its pair as 1 0 in two successive ordered 32 bit writes. Even though there may be faster alternatives this embodiment may maintain and search.

A host system may associate a data stack with each thread that executes in a code module. There are several considerations in such data stack management both in terms of performance and resource consumption. For instance a thread can keep using the same data stack if it uses a code module reentrantly i.e. if support routines call module entry points alternatively it may adopt a new data stack on each entry.

Therefore in one embodiment a pool may be used from which host system threads draw data stacks when they call code modules. Data stacks in the pool may be allocated in slowpath memory the size of the pool may be adjusted based on the concurrency in the code module. The pool s data structure may be a simple array guarded by a single lock it may be consulted to acquire and release data stacks as threads go through software call gates.

It should be recognized that embodiments described herein may not require hardware implementation. However in alternative embodiments hardware may be implemented to increase simplicity precision or efficiency of integrity enforcement. For example hardware instructions may be included that compactly and efficiently encode control flow integrity checks. This may be accomplished by including a label instruction for control flow integrity labels. The labels may be used for computed jumps or function pointer calls. The labels are instructions that encodes IDs in a certain way.

Control flow integrity guards may be implemented for example with instructions such as a cfilabel instruction. The cfilabel instruction may contain a 16 bit immediate identifier. The cfilabel may be the destination of checked branch instructions. It may contain a 16 bit immediate label value. The effect of the instruction may be to compare the immediate with the content of the control flow integrity register and to reset the register if the two are equal. This particular choice of semantics for the cfilabel may allow multiple cfilabel instructions with different immediates to be used in sequence to implement join points in a control flow graph. Such a join point may be the target of multiple branches with different labels. This may allow building more precise control flow graphs.

Additionally a control flow integrity variant of computer transfer functions may be implemented such as indirect jump return and jump to subroutine instructions. The control flow integrity transfer instructions may contain an immediate identifier instead of hint bits . After a control flow integrity transfer instruction with identifier ID a cfilabel with ID may be executed before any other type of instruction otherwise a hardware exception may be triggered. Between these instructions the value ID may be stored in a distinguished CFI register which may be a normal renamed register so multiple control flow integrity guards can simultaneously be in flight . The control flow integrity register need not be read on each instruction. For example it can be safely ignored when zero. Additionally this may be monitored with a two state automaton in the commit stage of the pipeline.

An alternative hardware implementation may facilitate the memory range guard. A register X and immediate constants for L and H may be used to establish that the memory range check is true for those three values and a set of implicit hardware registers for A and B. Thus the values for A and B may be either explicit or implicit. That is the values for A and B could be passed in as explicit arguments. If the formula does not evaluate correctly instead of failing or halting the execution of the program it may behave as it would for a call instruction. That is it may call a special function passing in as argument at least three values X H L. That function may take X H L run through all other As and Bs to determine if the expression holds true for any of them. Thus memory range guards may be implemented as three new instructions one for each type of access read write or execute . These instructions may take the form mem guard R L H naming a register R and providing L and H as for example 10 bit immediate constants. Each instruction may ensure that a range R L to R H lies within a region A to B when this is not the case an exceptional slowpath code is invoked.

In alternative embodiments designs for software machine code sequences may be implemented legacy hardware such as for example x86 for optimization. For example to optimize control flow integrity the identifying bit pattern may be placed before the function not within the function. A check may then be performed by evaluating a location immediately preceding for example a computed jump destination. For example if a destination is X a check may be performed at X 3 to evaluate the associated identifying bit pattern.

Another way of optimizing control flow integrity checks may involve C virtual functions. In embodiments implementing separate data and control stacks fewer checks may be necessary because most control flow integrity checks result from return instructions. Because return instructions use the control stack which may be incorruptible checks need not be performed. Checks may be necessary when calling function pointers. A large source of function pointer use is the C virtual function. One optimization for checks in the presence of C virtual functions is to not actually check identifier bits on a call to a virtual function but rather check whether its v table an immutable table of function pointers lies within a certain range. The v table pointers may be located in regions that are contiguous sequence of v tables which may be read only. If the v table lies in the range then there is a valid function pointer being called.

While a general purpose computer is described below this is merely one example. The present invention also may be operable on a thin client having network server interoperability and interaction. Thus an example embodiment may be implemented in an environment of networked hosted services in which very little or minimal client resources are implicated e.g. a networked environment in which the client device serves merely as a browser or interface to the World Wide Web.

Although not required embodiments can be implemented via an application programming interface API for use by a developer or tester and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers e.g. client workstations servers or other devices . Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. An embodiment may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an example system for implementing an embodiment includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a central processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology compact disc read only memory CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as ROM and RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data . RAM may contain other data and or program modules.

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the example operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

A computer or other client device can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. An embodiment of the present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

The methods of the present invention may be implemented in hardware software or where appropriate a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in computer readable medium. A processor that executes program code for performing the steps of the methods of embodiments as described in and as claimed constitute a computing environment that embodies the present invention. In the case of program code execution on programmable computers the computing environment will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computing environment. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the present invention has been described in connection with the specific examples in conjunction with the various figures it is to be understood that other embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. The examples are offered in explanation and are in no way intended to limit the scope of the invention as defined in the claims. In summary in no way is the present invention limited to the examples provided and described herein. Therefore the present invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

