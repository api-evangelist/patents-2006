---

title: Firmware socket module for FPGA-based pipeline processing
abstract: A firmware socket module is deployed on a reconfigurable logic device, wherein the firmware socket module is configured to provide both commands and target data to an entry point in a data processing pipeline, wherein each command defines a data processing operation that is to be performed by the data processing pipeline, and wherein the target data corresponds to the data upon which the data processing pipeline performs its commanded data processing operation. Also, the firmware socket module may be configured to (1) access an external input descriptor pool buffer that defines an order in which commands and target data are to be provided to the data processing pipeline, and (2) transfer the commands and target data from an external memory to the data processing pipeline in accordance with the defined order.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07954114&OS=07954114&RS=07954114
owner: Washington University
number: 07954114
owner_city: St. Louis
owner_country: US
publication_date: 20060126
---
Washington University a corporation of the State of Missouri and Data Search Systems Inc. a corporation of the State of Delaware now Exegy Incorporated a corporation of the State of Delaware are parties to a Joint Research Agreement.

The present invention is directed toward the field of interfacing hardware with software to support high speed data processing operations in hardware.

The ability to improve a computing system s data throughput capabilities when processing large volumes of data is an ever present challenge. In many instances processing large data volumes using software executed by a general purpose processor will be too slow to meet the needs of users. Therefore it is desirable to either relocate data processing functionality away from software executed by the general purpose processor of a computer and into firmware deployed on hardware or to partition data processing functionality between such firmware and software. However when doing so hardware devices such as reconfigurable logic devices need to be interconnected with external resources such as data storage and the software executed by the computer s general purpose processor in a manner that does not create a bottleneck as data and commands flow back and forth between the hardware and the software.

As used herein the term general purpose processor will refer to a hardware device that fetches instructions and executes those instructions for example an Intel Xeon processor or an AMD Opteron processor . The term reconfigurable logic will refer to any logic technology whose form and function can be significantly altered i.e. reconfigured in the field post manufacture. This is to be contrasted with a general purpose processor whose function can change post manufacture but whose form is fixed at manufacture. The term software will refer to data processing functionality that is deployed on a general purpose processor. The term firmware will refer to data processing functionality that is deployed on reconfigurable logic.

In an effort to address the needs in the art the inventors herein disclose a new design for a firmware socket module that interfaces at least one firmware application module deployed on a reconfigurable logic device with external memory and software. The firmware socket module is also preferably deployed on the reconfigurable logic device. The at least one firmware application module is configured to perform a data processing operation on any target data that it receives wherein the data processing operation that the at least one firmware application module performs is controlled by a software based command. Preferably the at least one firmware application module comprises a plurality of firmware application modules that are arranged in a pipeline. Each firmware application module in the pipeline is preferably individually addressable for command information. Thus commands can be issued to specific firmware application modules in the pipeline to control the data processing operations of those specific firmware application modules.

The firmware socket module is configured to access external memory and software to receive the commands and target data that are to be processed through the firmware application module pipeline. Preferably the firmware socket module issues transactions to a system bus to perform direct memory access DMA transfers of commands and target data from the computer system s memory to itself. The firmware socket module is configured to in turn provide these commands and target data to the first one of the firmware application modules in the pipeline in a predetermined order that is defined by software.

The firmware socket module and firmware application module pipeline are preferably configured to strictly maintain the predetermined order of inbound commands and target data when propagating commands and target data through the system. When target data reaches a firmware application module in the pipeline the firmware application module performs its specified data processing operation on the target data and then provides the so processed target data to the next firmware application module in the pipeline. When command data reaches a firmware application module in the pipeline the firmware application module will check to see whether the command is directed toward it and if it is will interpret that command to re arrange its data processing operation as appropriate. If the command is to be propagated further down the pipeline then the firmware application module will pass the command to the next firmware application module in the pipeline.

The flow of commands and target data either into the firmware socket module or into the entry point of the firmware application module pipeline can be thought of as a single stream in which both commands and target data are interleaved in accordance with the defined order. When it is said that the commands and data are interleaved this does not require although it does not exclude a stream of command data command data command data . . . . Instead the interleaved stream of commands and data described herein encompasses a stream such as command command command data data data data data command . . . wherein the order of commands and data in the stream is defined by software and preserved by the firmware socket module when it propagates the stream to the firmware application module pipeline.

Appropriate commands that control the firmware application module s data processing operation should precede that target data in the stream of commands and target data entering the firmware application pipeline thereby allowing the data processing operations of the firmware application modules to be appropriately controlled prior to processing target data. To facilitate the ease by which this strict ordering of commands and target data is maintained the firmware socket module is configured to provide both command and target data to the first firmware application module in the pipeline over the same communication path that links the firmware socket module with the first firmware application module of the pipeline.

The natural synchronization between commands and target data provided by this firmware socket module to firmware application module pipeline connection avoids complexity in the system and also enhances data throughput. In prior art socket interfaces known to the inventors herein commands are communicated to data processing modules via a different communication path than the communication path used to communicate target data to data processing modules. When such data processing modules are pipelined such dual communication paths create management difficulties when attempting to synchronize commands with data. In such cases when new commands are issued to a data processing module in the pipeline the entire pipeline will typically need to be flushed of previous commands and previous data before that command and any further target data can be processed through the pipeline thereby greatly detracting from the pipeline s throughput capabilities. By way of distinction however with the present invention one firmware application module of the pipeline can take action on a command while other firmware application modules in the pipeline are simultaneously processing data in accordance with their defined data processing operations. Thus commands can be issued to firmware application modules to adjust their data processing operations without requiring the entire pipeline to be flushed out.

High level software that is executed by the computer system s general purpose processor preferably defines the order of commands and data that are eventually propagated through the firmware socket module and the firmware application module pipeline. Lower level device driver software that is also executed by the computer system s general purpose processor then preferably preserves this defined order of commands and data and makes such ordered commands and data available to the firmware socket module. The device driver software preferably preserves this order by managing an input descriptor pool buffer in which pointers to commands and target data are stored. The firmware socket module will access the input descriptor pool buffer to learn of the commands and target data that are to be delivered to the firmware application module pipeline.

On the outbound side of the firmware socket module outbound to software the device driver software preferably maintains separate buffers for output commands and outbound data to notify the firmware socket module of where commands and data that have been processed by the firmware application module should be stored in memory for subsequent access by computer system software.

Among the advantages that the preferred embodiment of the invention provides are the ability to reliably deliver flow controlled data from software to a reconfigurable logic device and vice versa and the ability to develop firmware application modules independent of the computer system in which they are deployed so long as the firmware application modules conform to the signaling requirements of the firmware socket module . These and other features of the present invention will be in part pointed out and in part apparent to those having ordinary skill in the art upon review of the following description and figures.

The data store can be any data storage device system but is preferably some form of a mass storage medium. For example the data store can be a magnetic storage device such as an array of Seagate disks. However it should be noted that other types of storage media are suitable for use in the practice of the invention. For example the data store could also be one or more remote data storage devices that are accessed over a network such as the Internet or some local area network LAN .

The computer system defined by main processor and RAM is preferably any commodity computer system as would be understood by those having ordinary skill in the art. For example the computer system may be an Intel Xeon system or an AMD Opteron system.

The reconfigurable logic device has firmware modules deployed thereon that define its functionality. The firmware socket module handles the data movement requirements both command data and target data into and out of the reconfigurable logic device thereby providing a consistent application interface to the firmware application module FAM chain that is also deployed on the reconfigurable logic device. The FAMs of the FAM chain are configured to perform specified data processing operations on any target data that streams through the chain from the firmware socket module . Preferred examples of FAMs that can be deployed on reconfigurable logic are described in U.S. Pat. No. 6 711 558 entitled Associative Database Scanning and Information Retrieval pending U.S. patent application Ser. No. 10 153 151 filed May 21 2002 entitled Associative Database Scanning and Information Retrieval using FPGA Devices and published as 2003 0018630 published PCT applications WO 05 048134 and WO 05 026925 both filed May 21 2004 and entitled Intelligent Data Storage and Processing Using FPGA Devices U.S. provisional patent application No. 60 658 418 filed Mar. 3 2005 and entitled Biosequence Similarity Searching Using FPGA Devices U.S. provisional patent application No. 60 736 081 filed Nov. 11 2005 and entitled Method and Apparatus for Performing Biosequence Similarity Searching and U.S. patent application Ser. No. 11 293 619 filed Dec. 2 2005 and entitled Method and Device for High Performance Regular Expression Pattern Matching the entire disclosures of each of which are incorporated herein by reference. For example a non exhaustive list of exemplary data processing operations that can be performed by FAMs include data search operations of various types data encryption operations using any of a number of encryption techniques and or encryption keys data decryption operations using any of a number of decryption techniques and or decryption keys data compression operations using any of a number of data compression techniques data decompression operations using any of a number of data decompression techniques and data reduction operations.

The specific data processing operation that is performed by a FAM is controlled parameterized by the command data that FAM receives from the firmware socket module . This command data can be FAM specific and upon receipt of the command the FAM will arrange itself to carry out the data processing operation controlled by the received command.

Once a FAM has been arranged to perform the data processing operation specified by a received command that FAM is ready to carry out its specified data processing operation on the target data that it receives from the firmware socket module. Thus a FAM can be arranged through an appropriate command to search a specified stream of target data for the presence of the term Smith therein. Once the FAM has performed the search operation on the target data stream for the term Smith another command can be sent to that FAM that will cause the FAM to re arrange itself to search for the term Jones . Not only will the FAM operate at hardware speeds thereby providing a high throughput of target data through the FAM but the FAMs can also be flexibly reprogrammed to change the parameters of their data processing operations.

The FAM chain preferably comprises a plurality of firmware application modules FAMS . . . that are arranged in a pipelined sequence. As used herein pipeline pipelined sequence or chain refers to an arrangement of FAMs wherein the output of one FAM is connected to the input of the next FAM in the sequence. This pipelining arrangement allows each FAM to independently operate on any data it receives during a given clock cycle and then pass its output to the next downstream FAM in the sequence during another clock cycle.

A communication path connects the firmware socket module with the input of the first one of the pipelined FAMs . The input of the first FAM serves as the entry point into the FAM chain . A communication path connects the output of the final one of the pipelined FAMs with the firmware socket module . The output of the final FAM serves as the exit point from the FAM chain . Both communication path and communication path are preferably multi bit paths.

The application software layer corresponds to high level functionality such as the type of functionality wherein one or more users interact with the application to define which data processing operations are to be performed by the FAMs and to define what target data those data processing operations are to be performed upon.

The next layer is the module application programming interface API layer which comprises a high level module API and a low level module API . The high level module API can provide generic services to application level software for example managing callbacks . The low level module API manages the operation of the operating system OS level device driver software . A software library interface interfaces the high level module API with the low level module API . Details about this software library interface are provided below.

The interface between the device driver software and the firmware socket module serves as the hardware software interface for the system . The details of this interface will be described in greater detail in connection with .

The interface between the firmware socket module and the FAM chain is the firmware module interface . The details of this interface will be described in greater detail in connection with .

It is worth noting that in either the configuration of or the firmware socket can make memory accessible to the PCI X bus which thereby makes memory available for use by the OS kernel as the buffers for transfers from the disk controller to the FAMs. It is also worth noting that while a single FPGA is shown on the printed circuit boards of and it should be understood that multiple FPGAs can be supported by either including more than one FPGA on the printed circuit board or by installing more than one printed circuit board in the computer system. depicts an example where numerous FAMs in a single pipeline are deployed across multiple FPGAs.

As shown in inbound data from the kernel to the card is moved across the bus in the computer system to the firmware socket module and then delivered by the firmware socket module to the FAM chain . Outbound data from the card to the kernel are delivered from the FAM chain to the firmware socket module and then delivered by the firmware socket module across the PCI X bus to the software application executing on the computer system. As shown in the three interacting interfaces that are used are the firmware module interface the hardware software interface and the software library interface .

The firmware module interface which is shown in includes the signals exchanged between the firmware socket module and the signals exchanged between FAMs within the FAM chain . Table 1 and the description below further describe these signals.

The signal direction entries in the table are listed from the perspective of a firmware module. Thus signals through data in data cnt in data vld in ctrl vld in and wait upstrm comprise the interface signals with an upstream firmware module e.g. communication path . Signals through data out data cnt out data vld out ctrl vld out and wait dnstrm comprise the interface signals with a downstream firmware module e.g. communication path .

The signal clk is a 1 bit input signal that is used to clock the firmware socket module and FAM chain.

The signal reset is a 1 bit input signal that is used to reset the firmware socket module and the FAM chain to its start up state.

The signal module ID is a 6 bit input bus that informs each firmware module of its position in the FAM chain.

The signal data in is a 64 bit bus that is used to transfer target data and command data into the FAM chain. Of note by using the same bus to transfer both data and commands synchronization between commands and target data can be maintained with little complexity.

The signal data cnt in is a 3 bit bus that is used to determine how many of the 8 bytes on the input bus data in represent meaningful data. Preferably values of 1 7 are literally interpreted and a value of 0 means that all 8 bytes are valid.

The signal data vld in is a 1 bit input signal that is used to indicate that the data on the data in bus and the data cnt in bus are valid on a given clock cycle.

The signal ctrl vld in is a 1 bit input signal that is used to indicate that the data on the data in bus is valid command control information on a given clock cycle. It is worth noting that the ctrl vld in and data vld in signals into the same FAM should not be asserted at the same time.

The signal wait upstrm is a 1 bit output signal that is used to tell the upstream firmware module to stop pushing data into the current firmware module. Preferably the firmware module is configured to absorb 2 data values after the wait is asserted.

The signal data out is a 64 bit output bus that is used to transfer both data and commands out of a given FAM. Once again because the same bus is used to transfer both data and commands synchronization between commands and target data can be maintained through the FAM chain as each FAM operates on the received commands and target data.

The signal data cnt out is a 3 bit bus that is used to determine how many of the 8 bytes on the output bus data out represent meaningful data. Preferably values of 1 7 are literally interpreted and a value of 0 means that all 8 bytes are valid.

The signal data vld out is a 1 bit output signal that is used to indicate that the data on the data out bus and the data cnt out bus are valid on a given clock cycle.

The signal ctrl vld out is a 1 bit output signal that is used to indicate that the data on the data out bus is valid command control information on a given clock cycle. It is worth noting that the ctrl vld out and data vld out signals out of the same FAM should not be asserted at the same time.

The signal wait dnstrm is a 1 bit input signal that is used to indicate to the FAM that either the firmware socket module or a downstream module cannot absorb data at the moment. Preferably no more data should be shipped out from that FAM until wait dnstrm is deasserted.

It is worth noting that some contiguous FAMs in the FAM chain may form a FAM subset the FAM subset having its own entry point and exit point. In such instances the signal interface described in the table above would be maintained with respect to the entry point and the exit point of the FAM subset but a different signaling interface can optionally be used internally between the FAMs of the FAM subset. It is also worth noting that a FAM itself may be comprised of a chain of firmware application submodules wherein communications between the submodules may optionally follow a different signaling interface than that described in the above table.

As noted the information delivered across the firmware module interface on the 64 bit data in and data out buses can either be application data or command control information. Both the firmware socket module and the individual FAMs maintain the ordering of commands and data so this order is preserved throughout the chain of FAMs. Information flowing down the chain along the data in and data out buses from the firmware socket module to the first FAM in the chain from one FAM to the next downstream FAM and from the final FAM in the chain to the firmware socket module that is data is referred to as the data channel. Information flowing down the chain along the data in and data out buses that is command control information is referred to as the command channel. Commands that are delivered via the command channel are typically not consumed but are interpreted if appropriate and passed on to downstream modules. As a result many commands that enter the command channel are also delivered back to the software.

On the command channel a preferred format for individual commands is for them to have a 64 bit length with the following fields 

The command field is preferably encoded as two ASCII characters e.g. QY can be a query command but this need not be the case any 16 bit value is valid. Upon entry into the command channel the error bit is clear. Any module can thereafter set the error bit if appropriate which is then communicated back to the software when the command exits the FAM chain and firmware socket module. The sync bit is preferably set to control synchronization of the outbound commands and data on their way back to the software.

The module ID field identifies the specific firmware module that is to respond to the command. Preferably a value of 0 for the module ID means that all modules are to respond to the command including not only all of the FAMs but also the firmware socket module . Also it is preferred that a value of 1 for the module ID means that all modules except the firmware socket module are to respond to the command. Preferably the module ID value of 2 is reserved for the firmware socket module alone and module ID values greater than or equal to 3 are directed toward specific FAMs. Each FAM will know of its own module ID value by virtue of the input signal module ID described in connection with the firmware module interface s signal layer.

Preferred global commands for the firmware module interface include a reset command query command query response command pass through command start of data command and end of data command.

The reset command RS operates to reset the entire FAM chain or individual FAMs as indicated by the command s module ID field. Preferably the parameter field is unused for this command.

The query command QY operates to query a module to assess its current status. The module should respond with one or more Query Response QR commands. After the module has responded with its query responses that module passes the original QY command to the next module in the chain. Preferably the parameter field is unused for this command.

One or more query response commands QR are generated by a module when it receives a QY command. Upon receipt of a query response FAMs should simply forward them downstream. Preferably the parameter field for a QR command is module specific wherein this 32 bit field is split into two subfields the most significant 8 bits being a tag that indicates what type of information is being sent and the least significant 24 bits being the data associated with the given tag.

The pass through command PS informs a module if it is to pass data through unaltered or if it is to perform its normal data processing operation. The pass through mode does not impact command processing or command forwarding its impact is limited only to the data channel. Preferably the least significant bit bit of the parameter field enables disables the pass through mode with a pass through bit value of 1 enabling the pass through mode and a pass through bit value of 0 disabling the pass through mode.

The start of data command SD is used to mark the start of a data stream typically on a file boundary . The end of data command ED is used to mark the end of a data stream once again typically on a file boundary . The parameter fields for the SD and ED command are preferably unused although in some instances they can be used to specify a file ID or a frame ID.

Command propagation through the FAM chain preferably proceeds as follows 1 global commands those commands whose module ID value is 0 or 1 are propagated forward by each FAM in the FAM chain 2 a FAM will propagate forward any command whose module ID value is set for a different FAM and 3 a FAM will propagate forward any command whose sync bit is set.

Preferred commands that are or can be specific to the firmware socket module include a data count command reset command and a query response command.

A data count command DC can be used to ask the firmware socket module how much data has passed through the FAM chain since the last time it was reset. One DC command sent to the firmware socket module will result in the 3 DC commands being returned. The first responsive DC command will identify the number of bytes that have gone into the FAM chain. The second responsive DC command will identify the number of bytes of data that has exited the FAM chain. The third responsive DC command will be the original sent DC command that is being returned. Preferably an SD command or an RS command will operate to reset the data counts. With respect to the parameters field the sent DC command s parameters field is preferably ignored while the parameters field of the responsive DC commands will preferably identify the relevant number of bytes as described above.

The reset command RS format is described above in connection with the global commands. When the firmware socket module receives an RS command it preferably resets the entire FAM chain and also clears any input and output queues. Any data that may not yet have been returned from the card by the firmware socket module will be cleared by the RS command thus applications should make sure that they have received all expected data before sending a reset command to the firmware socket module. This can be achieved by sending a command with the sync bit set or by strobing the Flush bit in the firmware socket module s doorbell register.

The query response command QR format is also described above in connection with the global commands. Preferably when the firmware socket module issues a QR command its parameters field will be set as follows in Table 2 below 

Commands that are specific to the FAMs will vary as a function of each FAM s data processing operation. For example a set of commands applicable to a FAM that is configured to perform a search operation where a pattern is matched to a stream of target data would preferably include commands that define the pattern s against which the data stream is searched commands that identify how much context from the data stream should be returned when a match to the pattern is found in the data stream e.g. returning X number of bytes before and after the match within the data stream commands that define the number of mismatches allowed for a given pattern e.g. if the pattern is of length 10 a mismatch value of K will allow a match to occur when any 10 K of the 10 pattern characters match within the data stream commands that define which bits in a pattern must find a match in the data stream for a match to be declared commands that define a file within the data that is to be searched and commands that define a subset of data within a file that should be searched. The parameters field or optionally other fields of such commands can be used to define these aspects of the pattern matching operation performed by the FAM. Also the QR command from a FAM that is configured to perform a pattern matching operation preferably responds with tags whose values correspond to an identification of the FAM type an identification of the FAM type s version an identification of the FAM type s build and an identification of the number of patterns supported by the FAM.

As another example a set of commands applicable to a FAM that is configured to perform an encryption or decryption operation would preferably include commands that identify the key that should be used in the encryption decryption operation.

In addition to any other previously listed data processing operations that can be performed by FAMs possible data processing operations also include a field selection operation that takes in fixed length records and passes only the bytes of the record that have been selected wherein a command to such a FAM would indicate which bytes are to be selected a record gate operation that adds padding to records whose size is not a multiple of the data size processed through the FAMs 8 bytes in the preferred example described herein wherein a command to such a FAM would indicate the desired record size an inverse record gate operation that removes padding bytes from records wherein a command to such a FAM would indicate which bytes of a record are to be removed and a record select operation that searches within specified column boundaries of fixed length records for matches to one or more patterns an operation whose commands would be similar to the pattern matching commands described above but also including a command that identifies how records are to be masked to limit the searches to occur within specified column boundaries .

Preferably the FAMs that are deployed on the FPGA are dedicated to performing one type of data processing operation wherein the command signals operate to define specific aspects of that type of data processing operation. For example as shown in each FAM in the FAM chain is devoted to a type of data processing operation e.g. the first FAM is configured to performing a decompression operation the 4FAM is configured to perform one type of search operation the 5FAM is configured to perform another type of search operation and the second to last FAM is configured to perform an encryption operation. Through appropriate commands the specifics of each FAM s data processing operation can be controlled e.g. to arrange the 4FAM to search for the term Smith or to arrange the second to last FAM to perform an encryption operation using Key A . If a FAM is to be entirely reprogrammed to perform a different type of data processing operation it is preferred that the FPGA be reconfigured to achieve this end although this need not be the case.

Furthermore by appropriately turning on or off each FAM in the FAM chain specialized processing operations can be achieved by the FAM chain. For example to perform a search within a data stream for a given pattern wherein that data is stored in an encrypted format commands can be sent to the FAM chain that 1 turns on one of the search FAMs and arranges it with the given pattern 2 turns on the decryption FAM and arranges it with the appropriate key to decrypt the data stream and 3 turns off all other FAMs in the chain. In such an instance an encrypted data stream will be decrypted by the second FAM and the decrypted data stream will be searched by one of the search FAMs for the given pattern.

Preferably the firmware socket module uses a Xilinx PCI X core with a backend to transfer data to from the system s memory space when used in conjunction with driver level system software . The nature of this backend interface is described in greater detail herein.

The Xilinx PCI X Core Version 5.0 handles translation from the interface as described by the PCI X specification to an interface designed by Xilinx as described by the Xilinx LogiCore PCI X Design Guide Version 5.0 and the Xilinx LogiCore PCI X Implementation Guide Version 5.0. Preferably the configuration parameters are set to indicate that the PCI X connected printed circuit board is 64 bit and 133 MHz capable. Whether the system BIOS sets the speed of the device to 100 MHz or 133 MHz depends upon the 133 MHz capability bit and the physical voltage and time delay on the PCIXCAP pin. If the modules deployed on the FPGA only run at 100 MHz then the PCIXCAP pin should be set to indicate this. Also the PCI X configuration can be set to use up to 3 64 bit Base Address Registers BARs or 6 32 bit BARs. Preferably the firmware socket module uses the first BAR configured as a 64 bit BAR to map its device registers for communication with the device driver software .

The bulk of communications between the firmware socket module and the device driver software preferably occurs via three sets of descriptor pools. As shown in the buffers for these descriptor pools comprise a kernel to card input descriptor pool buffer a card to kernel output descriptor pool buffer that is for data and a card to kernel output descriptor pool buffer that is for commands. These descriptor pool buffers preferably reside in memory space that is managed by the OS kernel device driver software for example within RAM . Each entry in buffers and comprises a descriptor wherein each descriptor may span multiple addresses within the buffer.

In addition to the byte count fields and other flags described below the descriptors each preferably contain the physical and virtual address of memory locations for data movement either from the software to the hardware for an input descriptor or from the hardware to the software for an output descriptor . Thus the entries in the descriptor pool buffers serve as pointers to where the firmware socket module is to read data from or write data to.

The memory space from which and to which the firmware socket module is to read write data both commands and target data can be any memory in the physical address space of the computer system and any physically addressable data storage device connected to the computer system. As such memory space need not be limited to the motherboard of the computer system e.g. RAM . For example if memory of the card is made available to the driver level software then the memory space for storing commands and target data could include memory . Also the memory space can include addresses within data store or some other system connected storage device if the address space of data store or such a storage device is made available to driver level software e.g. through disk controller for data store .

When sending information from the software to the reconfigurable logic device all transfers both command and data are preferably managed by the common input descriptors stored in buffer . As long as individual FAMs in the FAM chain do not reorder data and commands the order of data and commands defined by the order of input descriptors in buffer will be maintained throughout processing within the reconfigurable logic device.

Strict ordering is not necessarily required for data and commands that are sent from the reconfigurable logic device back to the software. If strict synchronization is desired throughout the process including the return of commands and data to the software then the device driver software can set the sync bit in an individual command. When a command with the sync bit set arrives at the firmware socket module from the exit point from the FAM chain then the firmware socket module preferably performs the following functions 1 flush the data channel buffers to memory 2 create a null empty buffer in the data channel that has a sync flag set in the data output descriptor 3 ensure that this data output descriptor is flushed to memory and 4 flush the command channel buffer with the sync bit set in the command itself .

The firmware socket module preferably has 16 device registers that are mapped into the memory region of the first BAR identified above and which is configured as a 64 bit BAR . The physical addresses of each device register are the Base Address plus an offset. The registers and their offset from the BAR are listed in table 3 below 

The firmware ID is a 64 bit read only register composed of 2 values. The least significant 32 bits are the firmware ID number and the most significant 32 bits are the revision number of the particular firmware indicated by the ID.

The FPGA information register is a 64 bit read only register that contains 2 pieces of information the FPGA type and the FPGA size. The FPGA type is 4 ASCII characters 32 bits that indicate the type of FPGA. For example if the FPGA device is a Xilinx Virtex II device then the FPGA type would be xc2v . The FPGA size is a 32 bit integer that indicates what size FPGA is being used. For example if the FPGA device is a Xilinx Virtex II 4000 then the FPGA size would be 4000. The FPGA type is the least significant 32 bits of the FPGA information register while the FPGA size is the most significant 32 bits of the register.

The device status register is a 64 bit read only register containing 2 pieces of information about the hardware system attached to the hardware device. The least significant 32 bits indicate the type of hardware system that is attached to the hardware device. Table 4 below indicates an example of device type numbering.

The onboard RAM size is a 64 bit register that indicates the amount of memory in kilobytes that is attached to the FPGA device.

The doorbell register is a 64 bit read write register that contains flags used for communication between the driver level software and the firmware socket module . The doorbell flags and their functionalities are listed in table 5 below 

The Run bit is set by the driver level software to tell the firmware socket module to start or resume running. This bit will be cleared by the firmware socket module when it is acknowledged by the hardware. The Stop bit is set by the driver level software to tell the firmware socket module to stop running or pause. This bit will be cleared by the firmware socket module when it is acknowledged by the hardware. The Reset bit is set by the driver level software to reset the firmware socket module and all of the FAMs in the FAM chain. This bit will be cleared by the firmware socket module when it is acknowledged by the hardware. The Flush bit is set by the driver level software to flush the outbound buffer s on the firmware socket module that holds commands and data destined for the software. This bit will be cleared by the firmware socket module when it is acknowledged by the hardware. The Strobe Debug bit is a bit that can be used for debugging purposes. The Clock Counter Reset bit resets the counters in the firmware socket module that are used for determining the clock speed of the PCI X bus. The clock speed of the PCI X bus can be determined by reading the upper 9 bits of the firmware socket module parameters register.

The interrupt status register is a 64 bit read write register that is used to notify to the driver level software of the interrupt conditions listed in table 6 below. Any time an interrupt condition is set an interrupt is triggered on the PCI X bus to interrupt the operating system and should be responded to by the driver level software . If multiple interrupt conditions occur before the driver level software reads the interrupt status register then multiple bits will be set when the software reads the interrupt status register. When the interrupt status register is read it is cleared.

The firmware socket module sets Interrupt Bit 0 when it tries to read an input descriptor buffer of data and the next input descriptor buffer is not ready to be read by checking the Ready bit of the next input descriptor queued in the buffer . If Interrupt Bit 0 has been written then the driver level software must write to the Run bit of the doorbell register before the firmware socket module will the input descriptor pool buffer again.

Interrupt Bit 1 signals that an error has occurred when reading an input descriptor of data destined for input to the firmware socket module.

If the interrupt flag of the input descriptor pool buffer is set then the firmware socket module will set Interrupt Bit 2 after it is done reading an input descriptor buffer of input data.

The firmware socket module sets Interrupt Bit 3 if it has data to output to the kernel but the next data to kernel output descriptor buffer is unavailable by checking the Ready bit of the next data output descriptor queued in the buffer . Once the firmware socket module has set this interrupt the driver level software must write to the Run bit of the doorbell register after it has made the data to kernel output descriptor buffer s available before the firmware socket module will try again to output data.

Interrupt Bit 4 signals that an error has occurred when the firmware socket module tried to write data to an output descriptor buffer.

The firmware socket module set Interrupt Bit 5 whenever it writes data to a data to kernel output descriptor buffer and has closed the descriptor i.e. the firmware socket module is moving on to the next data to kernel descriptor buffer for writing data .

Interrupt Bit 6 is defined to indicate that there is no output data to be returned when a Flush bit has been set in the doorbell register.

The firmware socket module sets Interrupt Bit 7 if it has command data to output to the kernel but the next command to kernel output descriptor buffer is unavailable by checking the Ready bit of the next command output descriptor queued in the buffer . Once the firmware socket module has set this interrupt the driver level software must write to the Run bit of the doorbell register after it has made the command to kernel output descriptor buffer s available before the firmware socket module will try again to output command data.

Interrupt Bit 8 signals that an error has occurred when the firmware socket module tried to write command data to a command output descriptor buffer.

The firmware socket module sets Interrupt Bit 9 whenever it writes data to a command to kernel output descriptor buffer and has closed the descriptor i.e. the firmware socket module is moving on to the next command to kernel descriptor buffer for writing command data .

The data to card address register is a 64 bit read write register that is used to indicate the physical address of the beginning of the data to card input descriptor pool buffer . The driver level software should write to this register before the Run bit of the doorbell register is written to for the first time.

The data to card count register is a 32 bit read write register that is used to indicate the number of data to card input descriptor buffers available for reading data. The driver level software should write to this register before the Run bit of the Doorbell register is written to for the first time. When this address is read from a 64 bit value is returned wherein the upper 32 bits are padded with zeros.

The data to card next register is a 32 bit read write pointer to the next data to card input descriptor buffer that is to be read from. This is used to ensure that the firmware socket module and the driver level software are in sync. When this address is read from a 64 bit value is returned wherein the upper 32 bits are padded with zeros.

The data to kernel address register is a 48 bit read write register that is used to indicate the physical address of the beginning of the data to kernel output descriptor pool buffer . The driver level software should write to this register before the Run bit of the doorbell register is written to for the first time. When this address is read from a 64 bit value is returned wherein the upper 16 bits are padded with zeros.

The data to kernel count register is a 32 bit read write register that is used to indicate the number of data to kernel output descriptor buffers available for writing data. The driver level software should write to this register before the Run bit of the Doorbell register is written to for the first time. When this address is read from a 64 bit value is returned wherein the upper 32 bits are padded with zeros.

The data to kernel next register is a 32 bit read write pointer to the next data to kernel output descriptor buffer that is to be written to. This is used to ensure that the firmware socket module and the driver level software are in sync. When this address is read from a 64 bit value is returned wherein the upper 32 bits are padded with zeros.

The command to kernel address register is a 48 bit read write register that is used to indicate the physical address of the beginning of the command to kernel output descriptor pool buffer . The driver level software should write to this register before the Run bit of the doorbell register is written to for the first time. When this address is read from a 64 bit value is returned wherein the upper 16 bits are padded with zeros.

The command to kernel count register is a 32 bit read write register that is used to indicate the number of command to kernel output descriptor buffers available for writing command data. The driver level software should write to this register before the Run bit of the Doorbell register is written to for the first time. When this address is read from a 64 bit value is returned wherein the upper 32 bits are padded with zeros.

The command to kernel next register is a 32 bit read write pointer to the next command to kernel output descriptor buffer that is to be written to. This is used to ensure that the firmware socket module and the driver level software are in sync. When this address is read from a 64 bit value is returned wherein the upper 32 bits are padded with zeros.

The parameters register is a 64 bit register that is used to set programmable parameters in the firmware socket module. Some of these parameters are read write while others are read only as depicted in table 7 below.

The Max PCI X Burst Size parameter is used to set the maximum size transaction that the firmware socket module will try to execute on the PCI X bus . This maximum transaction size will be the 6 bit value in the parameters register times although setting this field to zero will set the maximum transaction size to 4096 the maximum transaction size allowed by the PCI X specification .

Bit 55 of the parameters register is used to indicate if the PCI X bus speed in the upper 8 bits of this register is valid wherein a 1 indicates validity and a 0 indicates invalidity .

The most significant 8 bits of the parameters register indicates the calculate speed of the PCI X bus in MHz. The Bus Speed Valid bit bit should also be read to determine if this value is valid or not. If the PCI X Bus Speed value is not valid the driver level software should wait a short time and reread the value.

As discussed communications between the firmware socket module and the driver level software occurs using 3 sets of descriptors 1 input descriptor pool and 2 output descriptor pools one for commands and the other for data . Each pool has its own set of descriptors which contain flags and fields with information about the descriptor buffers kernel buffers .

Each descriptor is preferably 32 bytes long broken down into 4 pieces of 8 bytes each as shown in table 8 below 

The flags field is a 64 bit field containing information about the descriptor buffer as described in table 9 below 

The Command Data bit is used to tell the firmware socket module whether the buffer contains command information or data. If the buffer contains command information this bit should be set otherwise this bit should be cleared. The firmware socket module reads this bit on the data to card input descriptor buffers and marks all the data in that buffer appropriately as either command or data .

The Data to Kernel bit indicates whether or not the data in the buffer is destined for the driver level software the kernel . If this bit is set the data is output from the firmware socket module destined for the kernel. The firmware socket module is responsible for setting this bit. Either this bit or the Data to Card bit should always be set but never both.

The Data to Card bit indicates whether the data in the buffer is destined for the firmware socket module deployed on the card . If this bit is set the data is input to the firmware socket module from the driver level software . The driver level software is responsible for setting this bit. Either this bit or the Data to Kernel bit should always be set but never both.

The Ready bit is set by the driver level software to indicate that a buffer is ready for use by the firmware socket module. The firmware socket module should clear this bit when it processes the buffer.

The Done bit is set by the firmware socket module to indicate to the driver level software that the firmware socket module has finished processing the buffer. Driver level software should clear this bit when it has finished cleaning up the buffer.

The Interrupt bit is set by the driver level software to instruct the firmware socket module to interrupt with a Data to Card Descriptor Buffer Done Interrupt after it has processed this buffer.

The byte count field is a 64 bit field that contains a byte count for the buffer. The meaning of the byte count differs for input and output descriptor buffers. For data to card input descriptor buffers the byte count field is the number of bytes of data contained in the buffer. The firmware socket module only uses 20 bits for the incoming byte count thus the maximum data to card buffer that the firmware socket module can handle is 1 MB 1 bytes. This byte count value should be set by the driver level software . For the data to kernel and command to kernel output descriptor buffers the byte count is initially set by the driver level software to indicate how many bytes are available in the buffer for writing. When the firmware socket module sets the done bit on the buffer it should also update the byte count with the actual number of bytes written to the buffer. This will also be a maximum of 1 MB 1 bytes.

The physical address field is a 64 bit field containing the physical address of the kernel buffer in main memory. This field is set by the driver level software . Preferably the firmware socket module only handles physical addresses that can be represented in 48 bits.

The virtual address field is a 64 bit field that contains the virtual address of the kernel buffer and is used only by the driver level software .

In operation when the firmware socket module receives a Run signal on its doorbell register the firmware socket module will read and continue to read data to card input descriptors in the buffers until it tries to read from a buffer that is not ready or until there is command information or data in an output FIFO maintained by the firmware socket module.

The firmware socket module preferably gives command information for output the highest priority. If there is any command information for output the firmware socket module will output it to an available Command to Kernel output descriptor buffer . If such a buffer is unavailable the firmware socket module will issue a Command to Kernel Output Descriptor Buffer Full interrupt. The firmware socket will then not try to output command information to a buffer again until the Run bit in the doorbell register is written to by the driver level software to indicate that buffers have been made available.

The firmware socket module preferably gives data for output the second highest priority. If the amount of data in the firmware socket module s output FIFO is greater than or equal to the maximum PCI X burst size then the firmware socket module will output data to an available data to kernel output descriptor buffer . If the next data to kernel buffer is unavailable the firmware socket module will signal a Data to Kernel Output Descriptor Buffer Full interrupt. The firmware socket module will then not try to output data to a buffer again until the Run bit in the doorbell register is written to by the driver level software to indicate that buffers have been made available.

The firmware socket module preferably gives incoming data or commands the lowest priority. If the next data to card input descriptor buffer is unavailable then the firmware socket module will signal a Data to Card Input Descriptor Buffer Empty interrupt. The firmware socket module will not try to read the next buffer again until the Run bit of the doorbell register is written to by the driver level software indicating that the buffers have been filled.

The firmware socket module will also preferably continue processing buffers and in order until the Next pointer reaches the Count at which point the Next pointer will reset to the first buffer.

The software API that supports application use of FAMs is preferably embodied in a class such as a class that could be labeled ExegyFpga. This class preferably includes the following public methods 

The SendCommand method delivers the given command to the firmware socket module and FAMs via the command channel. The argument TwoChars is a pair of bytes typically ASCII characters but this need not be the case that goes in the command field 16 bits . The error field is cleared set to 0 . The argument Sync goes in the sync field 1 bit . The argument ModuleId goes in the Module ID field 6 bits . The argument Parameter goes in the parameters field 32 bits . The argument WaitForIt is a flag that indicates whether the method invocation should block if WaitForIt is 1 or not block if WaitForIt is 0 until the command returns from the firmware. The method returns false on error.

The Write method delivers data from the given buffer to the data channel. The method returns the number of bytes transferred or an error in errno .

The ReadCmd method reads commands from the Command to Kernel output descriptor buffer s and delivers them to a user buffer. This method returns bytes placed in the buffer.

The Read method reads data from the Data to Kernel output descriptor buffer s and delivers them to a user buffer. This method returns bytes placed in the buffer or an errno . ENODATA is returned on a sync mark being encountered i.e. the null buffer which is the result of a command sync bit .

While the present invention has been described above in relation to its preferred embodiment various modifications may be made thereto that still fall within the invention s scope. Such modifications to the invention will be recognizable upon review of the teachings herein. As such the full scope of the present invention is to be defined solely by the appended claims and their legal equivalents.

