---

title: Incremental approach to an object-relational solution
abstract: The claimed subject matter relates to an architecture that can facilitate an incremental approach to an Object-Relational mapping solution. The architecture can provide a rich data model that is defined at the value layer. The rich data model can expose an interface that conforms with the interfaces exposed by common storage-specific data providers. The architecture can extend common storage-specific data provider to support common command representations, and provide entity services that work in terms of the rich data model as well as object services such as identity management, updating and change tracking.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07676493&OS=07676493&RS=07676493
owner: Microsoft Corporation
number: 07676493
owner_city: Redmond
owner_country: US
publication_date: 20060228
---
This application claims the benefit of U.S. Provisional Application Ser. No. 60 714 639 filed Sep. 7 2005 entitled INCREMENTAL APPROACH TO AN OBJECT RELATIONAL SOLUTION . This application also relates to U.S. patent application Ser. No. 11 171 905 entitled PLATFORM FOR DATA SERVICES ACROSS DISPARATE APPLICATION FRAMEWORKS and filed Jun. 30 2005. The entirety of each application is incorporated herein by reference.

Virtually all applications from desktop applications to enterprise applications access data in some form or fashion. When the data to be accessed resides in memory the application generally works with the data as strongly typed objects e.g. an object representing a contact . In contrast when the data to be accessed comes from a database an Application Programming Interface API for interacting with the data is dramatically different. In the latter case data is generally exposed as a structured tuple e.g. a data record representing the results of a query against invoices . A tuple is usually defined as a finite function that maps field names to a certain value. Its purpose is typically to indicate that a certain entity or object consists of certain components and or has certain properties but here these components are identified by a unique field name and not by a position which often leads to a more user friendly notation.

Traditionally there has been a fairly large division between how applications work with data in memory and interact with data from a database. Data from a database typically comes in terms of tuples e.g. records of data in a streaming fashion that the applications must convert to memory representations that are used within the application. Accordingly most applications of any size have what is called a data access layer or data abstractions layer which is essentially an abstraction that provides common services and common data modeling abstractions over the data that comes out of the database. The code within those abstraction layers is generally common and typically performs many of the same functions. Thus in the object oriented world it has become increasingly popular to provide a pre canned abstraction layer which will in a generic fashion take those tuples of flat relational data and turn them into objects within the object language.

Because APIs can differ depending upon where data resides a number of Object Relational Mapping products have been introduced which attempt to bridge this gap by mapping objects to relational stores. Due to the nature of this mapping additional services may be supported over the data such as a looser coupling between the database schema and the object schema state management services and update processing. However because these services build upon an object API e.g. at an object layer as opposed to a relational API they are tightly bound to the object view of the data. Accordingly these services are only available when using a separate object API which typically incurs overhead for example in object creation and identity management. Additionally this object API generally requires that the types being queried have been previously installed on the client machine.

Further developers accessing a database may be required to write to storage specific components e.g. providers or sometimes referred to as data providers drivers or other terms or rely upon a factory model and generic interfaces or base classes or a common abstraction layer in order to work across multiple providers. Even with generic interfaces base classes or a common abstraction layer a developer must deal with command syntax differences across different stores yet storage specific providers generally expose native storage specific query syntax. Therefore it is often difficult to produce storage independent code. Moreover a database application might need a client side nested relational transformation yet most relational stores today expose only a non nested e.g. flat relational model.

In addition developers may want results returned as typed objects that can contain business logic. As well when modeling results as business objects developers often want changes to those business objects to be tracked and later persisted. Furthermore developers may desire support for current and future operating systems such as operating systems that bridge disparate types of data representations with metadata.

The following presents a simplified summary of the claimed subject matter in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview of the claimed subject matter. It is not intended to identify key critical elements of the claimed subject matter or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts of the claimed subject matter in a simplified form as a prelude to the more detailed description that is presented later.

The subject matter disclosed and claimed herein in one aspect thereof comprises an architecture that can facilitate an incremental approach to an Object Relational mapping solution. We refer to this solution as incremental in that it provides layers of abstraction that expose incrementally richer views of the data starting from the flat relational model exposed by a store specific provider interface a nested relational model exposed by a mapping provider interface and a full object model exposed by object services built on top of the mapping or store specific providers . In accordance therewith an Entity Framework can employ a mapping provider which can expose a common data provider application programming interface API over extended storage specific data providers. The Entity Framework can leverage services that work in terms of a common data model including the mapping provider to incrementally build functionality typically found in an Object Relational layer on top of an existing API e.g. a relational API or value layer API rather than providing an entirely new set of components and APIs for working with objects. Services such as client side mapping to rich nested relational schemas state management update processing and the like can be added in terms of existing relational API classes. As well object services can be built on top of these rich services which can follow a common programming pattern.

By following a common well established relational programming pattern developers can build on existing knowledge rather than learn a new set of APIs for dealing with objects. Building on existing relational data access APIs can allow existing applications to be extended to employ objects or functionality typically found in an Object Relational framework where appropriate instead of requiring the entire application to be rewritten to a new API. Building on existing APIs can also allow developers to leverage existing tools and components.

For example existing data provider applications can benefit from incremental extensions where and when appropriate. The mapping provider can add client side mapping over existing data provider connections and can decouple the application from a particular storage schema. The mapping provider can also extend existing flat relational schemas to support rich relational concepts such as nesting inheritance complex types and rich relationships e.g. association or composition . Additionally such extensions can be accomplished without requiring changes to the capabilities or schema of the underlying relational store. Moreover at a higher level data objects can be used to query existing relational schemas or rich mapped schemas and results can be returned as data objects either through object level queries or by applying simple object mapping to tuples of results returned from existing data providers.

Developers of new data aware applications can work with a common set of familiar data provider classes such as a class provided by the store specific data provider and or the mapping provider. These classes can connect to query or retrieve results in terms of a rich conceptual data model. This rich conceptual data model e.g. the EDM can include concepts such as nesting inheritance complex types and relationships such as containment and association. The EDM can be mapped to various existing flat relational schemas without requiring changes or additions to the store schema. The store schema application schema and even the type of store can all evolve independently with the mapping to the store and store schema controlled through application configuration. The developer can have the choice of working entirely in terms of textual queries that return standard data records entirely in terms of object queries that return strongly typed object results or in any combination of the two.

In addition building on existing data access components and patterns can yield a better Object Relational mapping solution because this process can leverage programming patterns refined over years of use and customer feedback. At the same time the existing programming patterns can be enhanced with functionality commonly found only by moving to an entirely early bound Object Relational solution. By exposing the solution in terms of smaller well defined components the operation of the system can be more predictable and easier to understand as well as potentially facilitate better support for development debugging and the like.

In accordance therewith the architecture described herein can affect the incremental transition from an existing storage specific data provider class to a provider class for executing a canonical query format against a feature rich mapped EDM version of the schema. In other aspects the Entity Framework can provide additional classes for working with results mapped to application objects with services such as identity management and change tracking.

Aspects of the described subject matter can include a definition of a formal conceptual EDM at the value layer. Accordingly all services provided by the architecture e.g. schema query results . . . both at the provider value layer and the object layer can work within the context of a rich common data model e.g. the EDM . Likewise the data model can include concepts such as complex types inheritance relationships and the like.

According to another aspect of the claimed subject matter Object Relational mapping from objects to relational data can be split into two pieces. The first piece can provide the mapping from the store s relational model generally flat to a rich nested relational model. The second piece provides a simple mapping between this rich nested relational model and the Object model. Thus Object Relational mapping can be split into for example mapping between Schematized Data Objects and a rich Nested Relational model and mapping between the rich Nested Relational model and a standard Relational schema. By defining this rich mapping at the value layer the object mapping can be very simple providing for items such as name mapping value hiding mapping of properties to relationships and the like. Rich Object Relational mapping can be supported by having a simple mapping between Object the Nested Relational model and a rich mapping between the Nested Relational model and the Relational schema.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative however of but a few of the various ways in which the principles of the claimed subject matter can be employed and the claimed subject matter is intended to include all such aspects and their equivalents. Other advantages and novel features of the claimed subject matter will become apparent from the following detailed description of the claimed subject matter when considered in conjunction with the drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter can be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

As used in this application rich data model Common Data Model and Entity Data Model EDM are used interchangeably. As used herein the terms component and system are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component can be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components can reside within a process and or thread of execution and a component can be localized on one computer and or distributed between two or more computers.

Referring initially to a computer implemented system that facilitates object relational mapping is depicted. Generally the system can include an Entity Framework with a storage specific provider component that can exposes a common storage schema over a store schema of a data store based on a common data model . Further a mapping provider component that can expose a rich schema over the storage specific provider component in accordance to the same common data model is also shown. In addition the Entity Framework can also include a value layer services component that can operate in terms of the common data model and an object mapping component that can provide object services over the rich schema .

Accordingly the Entity Framework can define schema in terms of the common data model . The Entity Framework can expose a rich schema at the value layer in terms of the common data model through a mapping provider component . Exposing the rich schema at the value layer can provide a number of advantages over defining a framework entirely within an object layer. For example a common programming pattern in which a developer is already familiar can be employed rather than requiring an application to be rewritten to an object layer Application Programming Interface API for which the developer may have little or no knowledge. In addition defining the rich schema at the value layer can allow a developer to leverage existing tools and components as well as allowing existing code to be migrated incrementally to expand the functionality.

The mapping provider component can be employed to map the common storage schema which can be exposed by the storage specific provider component to the rich schema . The storage specific provider component can be a conventional data provider. As discussed in more detail infra the storage specific provider component can be extended to support a common command e.g. query representation. A data provider e.g. storage specific provider component can be defined as comprising four primary objects a connection a command a result object and a change processing object. The storage specific provider component can interact with and or expose a store schema of a data store as common schema in terms of the common data model . For example the storage specific provider component can have an object which represents a connection to the data store e.g. a DbConnection and using that connection object a command object can be built up that represents a command to the data store e.g. a DbCommand . The data store can return results e.g. results to the query command that are exposed by the storage specific provider component in the form of a result object e.g. a DataReader that is a typically a stream of tuples. The results can be placed in a cache e.g. a DataSet not shown provided by the value layer services component and changes made through the cache can be applied to the data store by employing the change processing object e.g. a DataAdapter .

As described herein the claimed subject matter can employ a different approach to object relational mapping in order to bridge the gap between relational representations and objects. For example rather than defining a complete new set of classes and components for working with objects against databases e.g. the data store data provider e.g. storage specific provider component connection command result and change processing classes can be extended to work with value layer services component and mapping provider component in the context of a rich common data model such that applications can work with the same services directly at the value layer or at the object layer through the object mapping component . Thus mapping and other components typically found only in object layers can become available at the value layer as well. Conventionally object relational solutions are defined at the object layer and the objects are defined to support a data model that is in some ways richer than the relational model of underlying databases. For instance relational databases typically have tables and a user can facilitate joins between the tables. Generally there are concepts of integrity rules between the tables such as keys that conceptually define a relationship between the tables that is often interesting to model within the classes of the objects of an application. Hence if a table has records for customers and orders a relationship can be created in the objects such that e.g. an order must have a customer.

However within the relational database there is no mechanism to utilize implicit relationships between the records e.g. customers and orders in querying or in navigation or in many other ways that may be useful to a developer. Thus in conventional systems object relational mapping is a matter of providing an object layer data model that supports concepts of explicit relationships between the classes such that e.g. a customer class has a collection of orders and an order class has a customer. Accordingly functionality such as navigating and querying the rich data model has typically been available only within an the object layer.

In contrast Entity Framework can extend the relational data model e.g. store schema of conventional relational databases e.g. data store by employing concepts that do not typically exist in relational databases such as inheritance hierarchy and relationships specifically composition and association relationships. Therefore services e.g. provided by the value layer services component such as a query can be employed against the rich schema or the common storage schema and return results as values e.g. as tuples that conform to the common data model . Thus rather than being traditional flat relational results hierarchical results can be returned inheritance within the results can be returned and or association and composition links can be returned within the results without ever materializing a class representing that data item.

The storage specific provider classes can continue to exist and can provide direct explicit unmapped access to a data store . Such a command can contain connection information that typically includes authentication information and the like and can be used to start a local transaction. The command can be explicitly associated with the local transaction and can contain a textual command representation that goes directly against the store schema with no mapping to the rich schema and no parsing and or query building on the client.

In order to facilitate working with other services such as the mapping provider component value layer services component and object mapping component storage specific providers can be enhanced to expose schema information according to the common data model e.g. common storage schema and consume for example an alternate canonical command representation e.g. a canonical command tree or common entity query syntax against that common storage schema . The extended storage specific provider need not be expected to expose nested relational views on top of flat relational schemas or to map objects to and from various schema. Rather the storage specific provider can simply expose a common view e.g. common schema command language and result format over the existing store schema and the mapping provider component can map this to the rich schema .

The next layer above the storage specific provider component can be the mapping provider component which itself can be exposed as a standard data provider so it has a connection a command a result object and a change processing object. A difference is that the mapping provider component also can support advanced common data model concepts e.g. identity complex properties nesting polymorphism relationships and so on on top of existing relational data providers and or storage specific data providers . Therefore the mapping provider component can support inheritance hierarchy relationships such as associations and compositions and richer types including names types and identities within the types and the mapping provider component can support these concepts over existing relational schemas such as store schema by way of e.g. client side mapping.

As detailed supra the mapping provider component can map the storage specific provider component to the common data model and expose the common data model as a data provider e.g. expose a connection a command a result object and a change processing object that can in turn be exposed as objects through object mapping component to the application consuming the entity framework . In accordance with an aspect of the claimed subject matter the entity framework can be implemented as a managed API. The entity framework need not have any hard dependencies on proprietary tools that is it can be installed and used over common development environment. However the entity framework can be implemented with certain tools in mind and can for example leverage features such as language integration extension methods defined outside of the classes and the like where available. Moreover the entity framework need not rely on new language features such as language integrated queries or data interfaces. Yet the entity framework can be implemented with such features in mind with the intention of supporting these language innovations. Furthermore the entity framework can define lower level explicit API classes suitable for particular packages. As well certain object types may interact with the system through higher level abstractions such as for example My classes exposed by common programming languages.

The entity framework can also include an object mapping component . The object mapping component can provide support for binding to results as application objects. Specifically an ObjectContext not shown can provide support for identity management state management updating objects and the like. In addition a typed canonical command builder not shown can provide strongly typed query building and can implement queries e.g. ObjectCommand for language integration. Results can then be returned as a typed enumerator e.g. IEnumerator .

According to an aspect the entity framework can be implemented in a 1 tier or 2 tier manner where connections and state may be maintained between method calls. Typically applications deploy the API Runtime components on a middle tier or on a smart client tier with explicit synchronization of data to a local store. As well some classes within the entity framework can be specific to a data store while other classes can be common across stores. Functionality that is specific to a store can be implemented in provider classes e.g. storage specific provider . Common functionality such as client mapping object query language parsing object materialization and the like can be factored out into common runtime classes e.g. mapping provider component value layer services component and object mapping component .

It is to be understood that the entity framework can support working with data as structured types as well as objects by way of the object mapping component . Whether a developer desires to access data through objects or structured types need not require a completely different programming model. The same developer working against the same mapped schema may generally query in terms of classes but occasionally is required to return results as structured types e.g. when formulating reports that rely on projections or aggregations over the data.

In accordance therewith the entity framework can provide support for many of the following values as well as objects a degree of penetrability between layers explicit mapping support separate object mapping and store mapping extensions to existing data provider models store specific functionality pushed to providers and common functionality built on top of providers.

Turning now to a system that facilitates object relational mapping is shown. As depicted the Entity Framework can enhance the value layer space. In particular the common data model can provide a common entry point for applications coding against multiple back ends including nested relational mapping and a canonical object query language over one or more data providers. As described supra the rich schema can be implemented by building the mapping provider component on top of an existing data provider not shown . The mapping provider component can expose the rich schema as a data provider. For example mapping provider component can expose a rich schema API that can have e.g. a connection a command and it can return the results of a result object and support updating through a change processing object. Accordingly the mapping provider component can expose an interface similar to the common schema API that conventional data providers expose so there is no need to go to the object layer. Moreover the existing programming model can also be exposed which is useful in a number of different ways.

First there has grown a community a set of tools knowledge and or products around existing data providers and that knowledge can be leveraged rather than forcing people to learn new interfaces. Secondly once the common data model is defined over existing relational stores then object services such as object materialization identity management and change tracking can be incrementally built on top of those existing common data model extensions. Hence developers are able to code against a common rich conceptual data model whether they are using objects or values and have the same services and the same richness of expression in both cases. Additionally this incremental approach can provide the ability to take existing code and migrate it incrementally to bring on new capability. For example an existing result object of a storage specific provider can materialize results as objects or as value records. Similarly an existing connection to a database can be employed to look at the store schema of a data store in terms objects in terms of the common data model or in terms of a flat relational model. Essentially by componentizing the architecture into individual well defined components each of which incrementally adds functionality to the base that an applications starts with can provide more flexibility and different programming patterns that a developer can utilize. Further this approach can enhance the adoption of the overall architecture by allowing developers to incrementally migrate to that architecture leveraging the knowledge tools documentation and background already developed rather than forcing them to start fresh coding to a new API a new set of components running new tools and so forth.

It is to be appreciated that by exposing the mapping functionality as a standard data provider e.g. mapping provider and using the same API e.g. classes or interfaces that mapping provider uses to communicate with storage specific provider not shown multiple instances of mapping provider could be layered one on top of the other. Thus mappings can be composed by layering an instance of a mapping provider with a mapping to one rich schema to another instance of a mapping provider that exposes an alternate rich schema for example. The mapping provider may include special code to optimize cases where one instance of a mapping provider consumes a second instance of a mapping provider or may treat the second instance identically to a storage specific provider not shown .

It is further to be appreciated that the mapping provider can provide a common entry point for applications writing storage independent code. The mapping provider can provide a common set of classes that expose a common data model e.g. common data model command e.g. query language and mapping functionality against any data store. In addition the mapping provider may include metadata and parsing logic necessary to provide additional client side functionality against any store for example the ability to fetch results one page at a time etc.

Turning briefly to a system that facilitates object relational mapping is illustrated. The system generally includes the Entity Framework described in . Additionally the system can include an extended data provider component . As described a data provider e.g. storage specific provider component or extended data provider component typically consists of three primary objects including a connection a command a result object e.g. a DataReader and may include a fourth change processing object e.g. a DataAdapter for interacting with a cache not shown . Alternatively the change processing functionality may be subsumed by one of the other provider objects such as the command or by the cache itself. Generally the storage specific provider will differ depending upon the type of data store . For example the data store can be an Oracle brand database DB2 brand database and or an SQL Server brand database etc. and in each case the data provider can differ. Therefore in accordance with an aspect of the claimed subject matter the storage specific provider can be extended e.g. to create the extended data provider component to provide for the ability to express a command in a store neutral manner.

In order to compose with other components in a data provider neutral way the extended data provider component can support a canonical command. A canonical command can be expressed in terms of a common string based syntax or a canonical command tree that provides common syntax for expressing a command across a variety of different data stores . Additionally the extended data provider component can support compensation for query or other command operators within the canonical command that may not be supported natively within the store e.g. compensation for a nested query . This compensation may be directly implemented by the storage specific provider or as a common entity service e.g. services provided by value layer services component of implemented on top of the canonical commands of the extended data provider component .

Moreover it should be appreciated that in some cases certain command operators may not be supported by the store . In such cases command compensation can be supplied either by the extended data provider component or a common component not shown that implements the compensation functionality built on top of the canonical command representation of the extended data provider component . For example extended data provider component can e.g. support nesting by executing multiple queries and combining the results. On the other hand a common component not shown could perform similar operations when e.g. it is invoked by the mapping provider component .

It is also to be appreciated that the extension can be affected in various ways. For example a data provider can be enhanced to comply with the common data model through both the mapping provider component and canonical extensions in the data provider itself. Enhancements may be in existing classes or in a definition of additional classes that are part of a data provider layer. In some cases these classes may be implemented in a separate assembly from the extended data provider component but can still be provider dependent e.g. in generating back end specific queries and updates . Accordingly it should be understood that the target data model for the mapping provider component can be the common data model . The common data model may be mapped to relational or other storage schemas through the extended data provider component but a programmer can code against the common data model .

With reference to a system that generally translates generic commands into provider specific commands is illustrated. The mapping provider component can send a canonical command to the extended data provider component . As described supra the canonical command can provide for common commands to be expressed irrespective of the type of data store . The extended data provider component can facilitate translating the canonical command into provider code that is data provider specific. For example the extended data provider component can translate the canonical command into e.g. Transact SQL T SQL commands for use with the data store . A number of other aspects will become apparent with reference to the various scenarios described below.

Turning now to a computer implemented system that facilitates object relational mapping is depicted. Generally the system can include an Entity Framework that has been described supra but depicted here in greater detail. The common data model can include one or more entities that embody concepts not typically found in relational data stores such as data store . For example the entity can be an entity with strong identity an entity with inheritance an entity with complex types an entity with relationships and so forth. Additionally the common data model can include one or more relationships e.g. compositions associations association entities common value or calculated relationships etc. that relate entity types. These relationships can define navigation and constraint enforcement between the entity types for example and may or may not reflect constructs in the store e.g. foreign key relationships .

The value layer services component as depicted can include a common component that can be employed to compensate for command operators intended for the data store but for which the data store does not support e.g. a command with nested results . As detailed above the functionality of the common component can additionally or alternatively be built into the canonical commands within the extended data provider . The value layer services component can also include a cache that can be employed for entity services such as identity management change tracking and the like. Additionally the value layer services component can include a common metadata service component to for example support services that require metadata. The object mapping component can include and or support one or more object services such as object materialization typed queries data aggregation object cache etc and can employ API patterns that are substantially identical to the API patterns provided by a storage specific provider and or the extended data provider .

In one aspect the common data model can represent rich schema resulting from nested relational mapping over the extended data provider component as well as canonical object queries over the rich schema which are passed through the mapping provider component to the extended data provider component . Since the Entity Framework the common data model the extended data provider and or the mapping provider component can be defined at the value layer the value layer services component can also be defined at the value layer. As such the object mapping can be a very simple matter.

There will always be customers who want to issue commands directly against a store schema . Generally those customers want to know that no mapping parsing or any other extra processing occurs on the client and want full control over connections transaction boundaries etc. These low level explicit programmers can use traditional data provider patterns e.g. ADO.NET brand data provider patterns that can explicitly create and open a connection specify a command in a provider specific syntax and can execute it to get a result of records. Observe the following code 

Certain providers can support the ability to take a canonical query or DML command in the form of a command tree e.g. through a SetCommand method a command tree property or a command constructor . For example 

Alternatively a canonical command for a particular store may be obtained through other means such as construction of a storage specific canonical command object or from a factory method such as might be obtained from the storage specific connection. This canonical command may support a common command syntax and a common set of operators such as nesting for example.

A generic data provider can provide a common entry point for working across storage specific data providers. Data provider connections may be explicitly specified such as through a constructor or property or configured through a configuration entry. Because storage providers support a canonical command representation the mapping provider s command object can expose a common language command syntax that passes a common canonical command representation to the underlying storage provider. Consider the following code segment 

The Mapping Provider e.g. mapping provider component can also provide client side storage mapping to expose a common schema over possibly disparate and changing storage schemas. This level of indirection is useful for providing a looser coupling between the application logic and storage schema. In addition this mapping can support exposing a rich nested relational schema over a flat relational schema. The mapping information may be provided explicitly by passing a metadata interface to the Mapping Provider s connection object or by specifying mapping information as part of the configuration such as in the following code 

The rich structured results can easily be mapped directly to schematized data objects with similar structure. The ability to materialize structured records as objects works with properly formed results from any source and gives the developer ultimate control over query formation.

With mapping to a rich data model supported as part of the Entity Framework at the value layer an object query component can relatively easily query and map rich structural schema to objects. Because the mapping provider exposes the same interface as the storage providers the object mapping can work over either the mapping provider or a storage specific provider. Consider the following code segment 

For languages that support the concept of generics a typed object command can be returned. The use of generics is shown below by way of illustration. A typed command can similarly be used in subsequent illustrative examples shown using ObjectCommand. In the case of a typed command the object mapping may be specified explicitly through a constructor or property on the typed command or a default mapping may be generated based on the type specified for the object command for example through reflecting on the types members.

In order to support identity management and change tracking at the object layer an object cache can be provided. Query results can be compared to and merged with existing results in the cache at the value layer. It is to be appreciated that although the cache may contain data objects data providers can work with items in the cache at the value layer for example in obtaining original and current values to process changes. In the following illustrative code a cache is supplied to the query object.

For a full strongly typed Object Relational experience a developer may want to retrieve results as a partial object graph that supports demand loading identity management and updating of objects within the graph. The demand loading change tracking and identity management can be provided through a higher level class representing the application s data context. This data context class provides a simple entry point that may generate for example a map connection and object cache and pass them to an object command. Calling a method on the data context to save changes passes the changes to the underlying provider for example by requesting a change processing object from the provider s connection object and passing the changed objects from the cache. For Example 

Certain programming languages e.g. C brand may include language extensions that integrate the building of query expressions into the language. These can be supported by the invention through the typed object command object as shown 

By using an instance of a typed object context for example generated from a particular schema the programming experience can be even more tightly bound to the language. Consider the following example 

Exemplary class definitions supporting the preceding examples follow. It is to be appreciated that the following class definitions are intended only as an exemplary representation of the invention for the purpose of illustration and not limitation. Other alternate implementations are envisioned to be within the spirit and scope of the claimed subject matter.

By way of example and in addition to storage specific provider components components of the Entity Framework may be separated into but not limited to the following namespaces 

The following classes can be implemented for each store for example each provider can have its own named versions of these classes for example SqlConnection SqlCommand SqDataReader SqlDataAdapter . The classes can exist in different namespaces according to the individual provider for example System.Data.SqlClient for the Microsoft SqlServer specific storage provider .

A DbConnection can serve as a connection to the store. From a DbConnection applications and services may be able to obtain a ProviderFactory to get to other storage specific provider objects for example a data adapter or canonical command object. An abbreviated example of a DbConnection is shown below.

A DbCommand can execute a query against the store. In addition to or as part of a DbCommand that supports a storage specific command syntax the data provider may expose a canonical DbCommand that supports the ability to specify a command in a canonical form with or without compensating for command operators not supported by the underlying store. An abbreviated example of a DbCommand is shown below.

A Canonical form of a DbCommand may support the ability to set a command through a command tree representation for example by implementing a common interface.

Results may be returned as a DbDataReader. The following class definition shows the core members of an exemplary DbDataReader.

The metadata for the result and field values for the current position may be obtained through the exemplary IDataRecord interface 

DbDataReaders can be extended to expose sufficiently rich metadata for describing and accessing rich structural results including complex typed fields polymorphic results and nesting. Rich metadata describing the currently positioned datarecord may be exposed through a RecordInfo property while the ability to set or get a complex typed field may be exposed through a GetDataRecord method for example.

In the case of polymorphism the RecordInfo property may return different metadata for each record within the result where each record derives from a common supertype whose metadata is described by the existing IDataRecord properties and is common across the result.

Where the currently positioned data record represents an entity with identity in the common data model the DataRecordInfo can be exposed as a more specific EntityRecordInfo which includes the identifier for the entity.

A DataAdapter may be provided that supports populating a cache from a store or updating a store based on changes made to cached data. The adapter may work with an individual or cache of objects that exposes original and current values through value layer concepts e.g. tuples . A DataAdapter may be extended to support working with a rich entity cache.

A common Mapping Provider can provide nested relational transformations and a richer conceptual schema based on client mapping information. The Mapping Provider can be exposed as a data provider.

A MapConnection can provide a mapped view over a DbConnection. The MapConnection can receive connection information for example through a named configuration section a connection string or an existing DbConnection with storage mapping. The MapConnection can then expose a schema MapCommand and results over that mapped view. For example 

The MapCommand can be a DbCommand against the possibly mapped schema. The syntax of the Mapping Provider s command text can be a canonical query language e.g. entity query language . This object can also expose a static method for generating query trees from for example entity query language strings and can e.g. generate entity query language strings from query trees. Consider the following exemplary class definition 

An ObjectCache can provide identity management and change tracking for objects. An ObjectContext may contain an ObjectCache. For example 

Although the cache may contain references to objects for example the storage provider can work with the contents of the cache using value layer entity abstractions. It is to be appreciated that caches containing other data abstractions for example XML could use the same value layer abstractions to provide an interoperable way for storage providers to work with the contained data.

An entry in the cache may be represented by for example a CacheEntry object that exposes original and current values at the value layer using tuples e.g. DataRecords . The names of the fields for example are taken from the nested relational side of the object mapping. It is to be appreciated that there may be members associated with the cached object such as identity or concurrency values that are not exposed by the cache object but are available through the value layer abstractions.

Object commands can optionally be executed within an ObjectContext to provide for example object identity change tracking and the like. For instance 

Local cached collections of objects can be exposed through an EntitySet object. The collection may represent a table in the store a set of local results or the members of a collection property for example. This local collection may support for example object enumeration local query add remove methods and access to the query used to define the collection.

ObjectCommand represents a query against objects. The ObjectCommand can be obtained from an ObjectContext or can be directly created given a DbConnection and object mapping.

ObjectCommand can represent a typed query. ObjectCommand can provide support for integration with query facilities built into the language. The ObjectCommand can be obtained from the ObjectContext through a CreateCommand method or can be directly created and given a DbConnection and object mapping. If the ObjectMapping is not specified it can be obtained from the type of the ObjectCommand. The ObjectCommand can support methods for incrementally building a command.

Typed results may be returned as a IEnumerable by calling GetEnumerator on the ObjectCommand. An IEnumerable may also be constructed over a properly formed existing result stream e.g. DataReader by providing the appropriate object mapping or cache. Similarly a single object may be obtained from a properly formed tuple e.g. DataRecord or object properties may be set or retrieved from an object. An ObjectMaterializer class can be constructed given the appropriate metadata for mapping between objects and the value layer or can expose static methods for constructing objects and getting setting properties through the value layer as shown.

Turning to a system that facilitates an object relational mapping solution by separating the object relational map is illustrated. In general the mapping provider component transforms the relational view exposed by the storage specific provider to a rich nested relational view . This rich nested relational view can then be transformed by the object mapping component to expose a corresponding object view . Hence the entity framework is able to decouple application logic and or a data model from the relational view that is exposed by the storage specific provider .

The entity framework can split the object relational mapping into an Object NestedRelational mapping component e.g. the object mapping component and a NestedRelational Relational mapping component e.g. the mapping provider component . In essence mapping from objects to relational data is segmented into two parts. The first part e.g. the NestedRelational Relational can encompass the mapping from the data store output e.g. relational view to a rich nested relational model e.g. rich nested relational view . Furthermore because the object view can be built upon a rich nested relational view at the value layer it follows that the object mapping can be very simple. For example rich Object Relational mapping can be provided by having a simple mapping between object view and rich nested relational view and a rich mapping rich nested relational view and relational view . The combination of the object view and corresponding rich nested relational view can represent a common schema that can be coded against at either the value or the object layers.

Turning now to a system that facilitates object relational mapping is illustrated. The cache can be used implicitly for object services supported by the entity framework such as identity management and or change tracking . In addition the cache can be used explicitly such that developer can directly populate data in the cache query data in the cache and do other cache operations such as bind to it and so forth.

On top of not only the cache but the extended data providers and or mapping provider component object services can be supported e.g. through mapping component . These can allow mapping of data records from the extended data providers directly or through mapping provider component to .NET framework Common Language Runtime CLR classes. Such mapping can allow object materialization e.g. results returned in response to commands can be materialized as data classes as well as building typed commands against a store schema not shown . In addition base data classes can be defined that can hook into the cache for tracking changes as well as other business logic and object service components. For example 

Data Classes e.g. those classes that represent the data may be written by hand or automatically generated from a Common Schema Definition Language schema definition . Classes generated from the schema definition can make use of common base class elements that may be used in hand written data classes and that can generate partial classes that may be extended by the designer of the class.

Object runtime classes e.g. ObjectContext need not make assumptions as to whether the data classes are generated written by hand using common base classes or are previously existing unadorned non prescriptive data classes. However the object runtime can make use of prescriptive functionality within the data class in order to add functionality such as lazy load or graph consistency or performance such as copy on write for data classes that support such functionality.

Inline collections entity associations and compositions may all be mapped to non prescriptive collections. Non prescriptive collections must minimally support Add Remove methods for population synchronization.

When an object is materialized outside of a cache with an inline collection entity association and or composition mapped to a non prescriptive collection the collection can be populated with the members of the collection association or composition. If the members of the collection association or composition are not present in the data record used to materialize the object the collection can be left empty. Helper methods may be provided outside of the data classes in order to build a query to return the members of the specific collection.

When objects containing non prescriptive collections that represent inline collections entity associations and or compositions are materialized by a cache the cache can maintain a related table for the collection members. The cache can initially merge any collection association or composed results from the data record into the related table and can then populate the non prescriptive collection with the related non deleted members from the related table. If results are subsequently added to or marked for deletion from the related table the cache can add or remove the corresponding objects from the non prescriptive collection as appropriate. However the application must in some manner synchronize the parent object with the cache in order to have objects added to or removed from the non prescriptive collection reflected in the related table.

References to inline types or entities may be mapped to standard CLR reference properties in data classes. Upon materialization of inline types or entities outside of a cache if the data record contains values for the referenced type or entities the appropriate class can be materialized and the CLR reference can be set to the materialized class.

Upon materialization of referenced entities by the cache the cache can maintain the referenced entity in a separate table. As well the cache can merge any values for the referenced entity to the separate table and can then set the CLR reference to the merged object.

Given a schema a typed object context that can provide strongly typed access to the EntitySets e.g. tables defined within the EntityContainer e.g. database or schema can be generated. For example given the following schema definition fragment 

A typed ObjectContext e.g. ItemContext can be generated for the WinFS brand OS. WinFS brand Data can contain WinFS brand specific functionality that can be employed in accordance with the claimed subject matter. As well it is to be appreciated that other aspects can employ N Tier Scenarios Client Tier w Explicit Sync to Local Store Middle tier SOA and the like without departing from the scope and spirit of the claimed subject matter.

Turning now to a system that facilitates streamed results from a data store is depicted. The object mapping component can receive a query . This query is passed through the mapping provider component to the extended data provider component and ultimately to the data store . Rather than inserting merging results from the query into the cache the object mapping component can provide a streamed result of data classes directly from a data store by way of the extended data provider component and mapping provider . While merging results with a cache can provide a consistent view of the object in case some objects have changed in memory typically the vast majority of queries e.g. query are read only. Therefore streaming the result to the query does not necessitate the overhead of maintaining an object in memory. However as described above it is to be appreciated that the claimed subject matter can allow for caching of objects identity management and change tracking for example when the cache is explicitly designated to be used.

It is to be further appreciated that by exposing the cache through public interfaces that work with object mapping component mapping provider component and or extended data provider the application can control the level of caching desired. For example the application can use the same cache across multiple query requests in order to track changes and manage identity across multiple results. Alternatively the application can use a separate instance of cache for each query in order to manage identity and track changes within a single result. In another alternative the application can use a separate instance of a cache for each subtree of a result in order to manage identity within that subtree. In yet another alternative the application may chose to put only individual data objects from within a result in order to manage identity and track changes only for those individual objects. Alternatively still an application may choose not to use the cache at all in order to have efficient read only streamed access without change tracking or identity management for example.

The following usage scenarios describe different targets for the object mapping component in relation to the above 

A common access pattern that deserves special consideration is the streaming scenario. The streaming scenario can allow large amounts of data to be processed without first or ever loading into a cache. The ultimate example of streaming is a continuous data feed. The fact that results can be exposed as objects rather than value records should not change the need to support this pattern. Consider the following code example 

In this case each value can be read only once and orders can be consumed in order for each customer. Once the application reads the next customer orders for the previous customer need not be available. In order to optimize this streaming pattern the consumer of the stream may be required to adhere to certain restrictions in how the data is accessed. In particular data can generally only be read sequentially. Once the next customer is read all knowledge of the previous customer including the ability to update it or enumerate its orders may no longer be available. Fortunately these potential restrictions exactly match the common coding pattern of nested enumerators shown above.

Because no cache is involved instance identity need not be maintained. For example multiple objects may be returned that represent the same entity in the database.

With reference now to an exemplary computer implemented methodology for incrementally extending a data provider is illustrated. At a canonical command can be created in terms of data objects. As detailed supra a canonical command can be defined as a command that can express a command e.g. a query across a variety of data providers and a canonical command can be represented as a canonical command tree or canonical text syntax for example. At the canonical command in terms of data objects can be translated to a canonical command against a rich nested relational schema for example by mapping object properties to constructs within the relational schema. This nested relational data model can be defined at the value layer and can utilize concepts not conventionally employed in relational databases such as nesting inheritance hierarchy complex types and rich relationships e.g. association or composition and the like. The nested relational data model can be exposed as a data provider e.g. it has a connection a command a result object and a change processing object to facilitate a rich object relational solution that can work with data at both the value layer and the object layer.

At the canonical command in terms of a rich nested relational schema can be translated e.g. by a mapping data provider into a canonical command against a relational storage schema for example by apply client side views to the command. At nested queries within the command may be broken into one or more flat queries for example to work against stores that do not support nesting operations.

At one or more queries can be converted to store specific requests for data for example native SQL in a format compatible with the database schema. At one or more requests for data are executed against the store yielding one or more results e.g. relational results .

At possibly multiple results can be assembled into a single result and the result can potentially be a nested result. At a single possibly nested result can be mapped to objects. The single possibly nested result might have been transmitted for example to an object materialization component from a data store e.g. in response to a command such as the canonical command .

Referring now to there is illustrated a block diagram of an exemplary computer system operable to execute the disclosed architecture. In order to provide additional context for various aspects of the claimed subject matter and the following discussion are intended to provide a brief general description of a suitable computing environment in which the various aspects of the claimed subject matter can be implemented. For example the computer implemented system that provides an incremental approach to an Object Relational mapping solution by extending a data provider can be implemented via the system . Additionally while the claimed subject matter has been described above in the general context of computer executable instructions that may run on one or more computers those skilled in the art will recognize that the claimed subject matter also can be implemented in combination with other program modules and or as a combination of hardware and software.

Generally program modules include routines programs components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations including single processor or multiprocessor computer systems minicomputers mainframe computers as well as personal computers hand held computing devices microprocessor based or programmable consumer electronics and the like each of which can be operatively coupled to one or more associated devices.

The illustrated aspects of the claimed subject matter may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules can be located in both local and remote memory storage devices.

A computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media can comprise computer storage media and communication media. Computer storage media can include both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computer.

Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

With reference again to the exemplary environment for implementing various aspects of the claimed subject matter includes a computer the computer including a processing unit a system memory and a system bus . The system bus couples to system components including but not limited to the system memory to the processing unit . The processing unit can be any of various commercially available processors. Dual microprocessors and other multi processor architectures may also be employed as the processing unit .

The system bus can be any of several types of bus structure that may further interconnect to a memory bus with or without a memory controller a peripheral bus and a local bus using any of a variety of commercially available bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS is stored in a non volatile memory such as ROM EPROM EEPROM which BIOS contains the basic routines that help to transfer information between elements within the computer such as during start up. The RAM can also include a high speed RAM such as static RAM for caching data.

The computer further includes an internal hard disk drive HDD e.g. EIDE SATA which internal hard disk drive may also be configured for external use in a suitable chassis not shown a magnetic floppy disk drive FDD e.g. to read from or write to a removable diskette and an optical disk drive e.g. reading a CD ROM disk or to read from or write to other high capacity optical media such as the DVD . The hard disk drive magnetic disk drive and optical disk drive can be connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The interface for external drive implementations includes at least one or both of Universal Serial Bus USB and IEEE 1094 interface technologies. Other external drive connection technologies are within contemplation of the claimed subject matter.

The drives and their associated computer readable media provide nonvolatile storage of data data structures computer executable instructions and so forth. For the computer the drives and media accommodate the storage of any data in a suitable digital format. Although the description of computer readable media above refers to a HDD a removable magnetic diskette and a removable optical media such as a CD or DVD it should be appreciated by those skilled in the art that other types of media which are readable by a computer such as zip drives magnetic cassettes flash memory cards cartridges and the like may also be used in the exemplary operating environment and further that any such media may contain computer executable instructions for performing the methods of the claimed subject matter.

A number of program modules can be stored in the drives and RAM including an operating system one or more application programs other program modules and program data . All or portions of the operating system applications modules and or data can also be cached in the RAM . It is appreciated that the claimed subject matter can be implemented with various commercially available operating systems or combinations of operating systems.

A user can enter commands and information into the computer through one or more wired wireless input devices e.g. a keyboard and a pointing device such as a mouse . Other input devices not shown may include a microphone an IR remote control a joystick a game pad a stylus pen touch screen or the like. These and other input devices are often connected to the processing unit through an input device interface that is coupled to the system bus but can be connected by other interfaces such as a parallel port an IEEE 1094 serial port a game port a USB port an IR interface etc.

A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor a computer typically includes other peripheral output devices not shown such as speakers printers etc.

The computer may operate in a networked environment using logical connections via wired and or wireless communications to one or more remote computers such as a remote computer s . The remote computer s can be a workstation a server computer a router a personal computer portable computer microprocessor based entertainment appliance a peer device or other common network node and typically includes many or all of the elements described relative to the computer although for purposes of brevity only a memory storage device is illustrated. The logical connections depicted include wired wireless connectivity to a local area network LAN and or larger networks e.g. a wide area network WAN . Such LAN and WAN networking environments are commonplace in offices and companies and facilitate enterprise wide computer networks such as intranets all of which may connect to a global communications network e.g. the Internet.

When used in a LAN networking environment the computer is connected to the local network through a wired and or wireless communication network interface or adapter . The adapter may facilitate wired or wireless communication to the LAN which may also include a wireless access point disposed thereon for communicating with the wireless adapter .

When used in a WAN networking environment the computer can include a modem or is connected to a communications server on the WAN or has other means for establishing communications over the WAN such as by way of the Internet. The modem which can be internal or external and a wired or wireless device is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof can be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.

The computer is operable to communicate with any wireless devices or entities operatively disposed in wireless communication e.g. a printer scanner desktop and or portable computer portable data assistant communications satellite any piece of equipment or location associated with a wirelessly detectable tag e.g. a kiosk news stand restroom and telephone. This includes at least Wi Fi and Bluetooth wireless technologies. Thus the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices.

Wi Fi or Wireless Fidelity allows connection to the Internet from a couch at home a bed in a hotel room or a conference room at work without wires. Wi Fi is a wireless technology similar to that used in a cell phone that enables such devices e.g. computers to send and receive data indoors and out anywhere within the range of a base station. Wi Fi networks use radio technologies called IEEE 802.11 a b g etc. to provide secure reliable fast wireless connectivity. A Wi Fi network can be used to connect computers to each other to the Internet and to wired networks which use IEEE 802.3 or Ethernet . Wi Fi networks operate in the unlicensed 2.4 and 5 GHz radio bands at an 11 Mbps 802.11a or 54 Mbps 802.11b data rate for example or with products that contain both bands dual band so the networks can provide real world performance similar to the basic 10BaseT wired Ethernet networks used in many offices.

Referring now to there is illustrated a schematic block diagram of an exemplary computer compilation system operable to execute the disclosed architecture. The system includes one or more client s . The client s can be hardware and or software e.g. threads processes computing devices . The client s can house cookie s and or associated contextual information by employing the claimed subject matter for example.

The system also includes one or more server s . The server s can also be hardware and or software e.g. threads processes computing devices . The servers can house threads to perform transformations by employing the claimed subject matter for example. One possible communication between a client and a server can be in the form of a data packet adapted to be transmitted between two or more computer processes. The data packet may include a cookie and or associated contextual information for example. The system includes a communication framework e.g. a global communication network such as the Internet that can be employed to facilitate communications between the client s and the server s .

Communications can be facilitated via a wired including optical fiber and or wireless technology. The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s e.g. cookie s and or associated contextual information . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers .

What has been described above includes examples of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the claimed subject matter are possible. Accordingly the claimed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms include or includes are used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

