---

title: Constraint injection system for immunizing software programs against vulnerabilities and attacks
abstract: A constraint is inserted into a program to address a vulnerability of the program to attacks. The constraint includes a segment of code that determines when the program has been asked to execute a “corner case” which does not occur in normal operations. The constraint code can access a library of detector and remediator functions to detect various attacks and remediate against them. Optionally, the detector can be employed without the remediator for analysis. The context of the program can be saved and restored if necessary to continue operating after remediation is performed. The constraints can include descriptors, along with machine instructions or byte code, which indicate how the constraints are to be used.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07945958&OS=07945958&RS=07945958
owner: VMware, Inc.
number: 07945958
owner_city: Palo Alto
owner_country: US
publication_date: 20060606
---
This application claims the benefit of U.S. provisional patent application No. 60 688 099 titled Constraint Injection System for Immunizing Software Programs against Vulnerabilities and Attacks filed Jun. 7 2005 and incorporated herein by reference.

Computer hosts are subject to a variety of attacks such as denial of service privilege elevation directory traversal buffer overflow unauthorized remote or local execution access information leakage and the like. Such attacks can be particularly damaging and costly for enterprises such as corporations governments and other large organizations. As a result an industry has been developed to protect against such attacks. For example protective software is developed proactively in anticipation of future attacks. Although proactive protection can prevent a large class of attacks host intrusion prevention cannot solely rely on proactive protection. There are many other possible attack vectors available on a system and no proactive system can guarantee 100 coverage against known and unknown attacks including those not yet developed. Current applications and operating systems are far too complex for any intrusion prevention system to accurately identify all possible attack vectors. Thus there is a need for a broad and flexible system that can react to any possible vulnerability or attack in a timely manner.

Further the current and most effective method of reactively handling vulnerabilities is to patch the system. When a vulnerability is discovered a patch is created typically by an independent software vendor ISV . A typical patch replaces an executable file or dynamically linked library requiring a restart of the application or a reboot of the system to activate a patch. A typical patch process involves fixing the bugs in the code then recompiling the code and releasing an executable with the necessary modules. However a patch update has many of the disadvantages of a software upgrade it typically requires a reboot of the application it is a single monolithic change to the application that can alter the normal operating behavior eliminating a problematic patch is cumbersome and there is no customer visibility into the effectiveness of a patch.

The technology herein roughly described provides a constraint injection system and technique for protecting software.

The constraint injection system and technique protects precisely in application memory near the vulnerability itself rather than outside the application memory at the system or network perimeter. A constraint is usually a few machine instructions that are inserted into the program. A constraint can also be inserted into an active application where the program instructions reside in memory. The system and technique provides the capability to address any known type of software flaw including those that permit attacks such as denial of service privilege elevation directory traversal buffer overflow unauthorized remote or local execution access information leakage and the like while maintaining critical business continuity. The system and technique complements conventional patching and because of the speed with which it can be deployed reduces the exposure of programs to attacks.

New constraints can be applied to running applications without restart or reboot and updates can be provided periodically or otherwise as needed. Similarly there is no need to upgrade hardware or other programs. Furthermore the constraint injection technique can be run in a detect mode in which it accurately indicates the risk of user application interference before the constraint is enabled and in a protect mode in which the constraint is enabled.

The constraint injection system and technique also enables fine grained administrative control by a server group or operating system for example.

In one embodiment a computer implemented method for protecting software includes inserting constraint code into the program at a patch point which is between instructions of the computer program and executing the constraint code when a control flow of the computer program reaches the patch point. The constraint code may include assembly code or machine instructions for instance. The constraint code can call a detector for detecting if a vulnerability is invoked in the computer program and call a remediator responsive to the detector for taking remediation action. In one approach the inserting includes copying a code fragment of the computer program to a cache and inserting at least one instruction of the constraint code into the code fragment in the cache between the instructions of the computer program. In another approach the inserting includes replacing at least one instruction of the computer program with at least one instruction of the constraint code and storing the at least one replaced instruction at a gateway in which case no cache is needed.

In another embodiment a computer implemented method for protecting software includes identifying a vulnerability in a computer program developing a constraint for eliminating the vulnerability the constraint comprising code which is inserted into the computer program at a specified point and releasing the constraint to at least one customer.

While a constraint injection system can be applied to many problems as described in section 3 one of the main applications is protecting vulnerabilities of a computer program. Most vulnerabilities are corner cases that should never happen in normal operation of the software. A corner case is a problem or situation that occurs only outside of normal operating parameters especially one that manifests itself when multiple environmental variables or conditions are simultaneously at extreme levels. They usually result from a developer failing to account for that case when writing the software code. Corner cases result in vulnerabilities than can be exploited to carry out actions that should not be allowed under the normal operating assumptions of the program.

For most vulnerabilities a simple check such as a few instructions e.g. assembly instructions carried out at the right point of the program execution is sufficient to detect the corner case. For example such a check may determine if a value is out of range or if certain patterns are present in a string. These checks don t detect the corner cases in normal operations. When the check inserted in the program detects the invocation of the corner case a simple remediation such as returning an error code changing an out of range data value so that it is in range truncating a string or changing the control flow of the program is sufficient to avoid exploitation of the vulnerability. Hard issues in dynamic program upgrades such as state changes or data structure changes are typically not required in checking and remediation of a vulnerability.

We introduce a technique that can provide immunization against program vulnerabilities. As previously mentioned the exploitation of a vulnerability can be avoided by inserting a simple check and remediation code into an existing application program. A constraint injection system is a system that allows insertion injection of one or more code segments constraints into an application for this purpose. In particular a constraint can include detector code which determines when a corner case is invoked and remediator code which takes remediation action once the corner case is detected.

Generally a constraint has a designated application and each constraint addresses one vulnerability. Usually a constraint targets a particular address in the application where it is inserted. This location is designated by the constraint developer. Once injected it is triggered by control flowing through the patch point.

Within the application specific components such as a library component and an executable component are named. For example with Microsoft Windows a Dynamic Link Library DLL and an Executable .EXE file are named. Generally any type of library and executable can be provided for use with any system including Unix and others. The application and components are identified by a version number and a hash. Filtering criteria can be used to identify the applicability of a constraint.

The following is a set of attributes present in some of the possible manifestations of a constraint injection system 

The constraint injection system is stable by itself and the system or the constraints within the system introduce only minimal disruptions to the system helping to increase the overall availability of the system.

The constraint injection system does not introduce any new exploitable attack vectors to the system. All communication and constraints are checked and verified for authenticity.

Most constraint implementations provide the ability to inject an arbitrary piece of code into an arbitrary point in the application code. This is an extremely powerful tool which has the ability to identify and fix most problems in a program as there are no restrictions in the ability to modify the program.

In implementations where the constraints are injected into application memory a new constraint can be inserted into a running application e.g. dynamically. In most implementations it is possible to turn a constraint on and off dynamically as the application is running. It is also possible to toggle any customer visible switches such as toggling between detection and protection mode dynamically.

It is possible to create a constraint to addresses a single vulnerability. Thus a typical constraint should have minimal impact on the overall system. A collection of constraints protects the system against known vulnerabilities.

The status and statistics of constraints can be made customer visible. For example each constraint can have a customer friendly description. Constraints can be maintained as customer visible databases. Furthermore the customer can control individual constraints such as turning them on or off and setting detector or protector modes. The customer can observe the behavior of active constraints such as the number of invocations of the detector the number of triggerings of the remediator the number of errors remediation action taken and a current state such as on or off or detector or protector mode. The ability to create a debug log with customer visible debug settings to understand false positives and errors can also be provided. The status of the constraint can indicate if it is on or off if it is applicable in a system and if it is active or passive. The system can also gather statistics about the effectiveness of the constraint such as how many times the constraint was invoked.

A constraint injection system is a flexible system that is not limited to solving program vulnerability problems. This section describes this and other possible applications of a constraint injection system.

A primary goal of a constraint injection system is to protect software systems against known vulnerabilities. Since vulnerabilities are known before most of the attacks against them are released protecting against the vulnerabilities in a timely manner provides a proactive Intrusion Prevention System IPS .

As with patching a vulnerability a constraint can be created against a known attack. In particular by analyzing the attack to understand how it deviates from the normal program behavior a constraint can be crafted to check and stop that deviation.

Since a constraint has the ability to change an arbitrary piece of code in an application it can be used to fix many other classes of bugs that do not lead to a vulnerability.

A constraint can monitor data flowing within an application and search and filter the data. This can be achieved by inserting a constraint that gets executed with the movement of data.

A constraint can enforce a security policy in an application such as by restricting the existing functionality of the application. A constraint can insert code to limit bypass or disable a specific feature.

As a corollary to security policy enforcement a constraint can be used to extend and enhance the functionality of an application.

A constraint can be used to monitor certain program behavior by inserting checks on the control flow path pertaining to that behavior and reporting relevant results to a monitoring system outside the program. This can also be used to monitor system and application performance stability and availability.

A constraint injection system can span three domains creation management and deployment. Most constraints are created at the security laboratories of a constraint vendor an Intrusion Prevention System IPS vendor an Independent Software Vendor ISV an Original Equipment Manufacturer OEM vendor which developed the application which is to be protected or a third party security professional. The constraints can be managed and administered by an Enterprise Network Operations Center NOC of a customer of the constraint injection system. The NOC is typically a physical space from which a large telecommunications network is managed monitored and supervised. Finally the constraints are deployed at the hosts in the enterprise.

Primary types of constraints include 1 constraints targeting a known vulnerability attack or a program bug 2 general constraints that can address a wide range of problems or enforce lockdowns or other policies these constraints may require configuration tuning or training and 3 built in constraints delivered with the constraint injection system that protect against known vulnerabilities and enforce accepted policies. The functionality of the constraint injection system can be understood further in view of the following description.

In a second possible path a security patch is released step . For example an OEM software vendor such as Microsoft Corp. periodically releases security patches in response to discovered vulnerabilities. The patch is differenced against the original module to identify the modified code step . Then the security laboratory determines how to force the program to execute the modified code e.g. by applying the correct input sequence or other another appropriate tool step . Subsequently the vulnerability is identified step .

In a third path when an attack is released step the attack is acquired step and its activities are traced step by observing what it does when attacking a controlled vulnerable system. Subsequently the vulnerability is identified step . Typically when an attack is released news of the release is publicized as a warning to others by customers software vendors software security industry groups and sometimes the general news media. In other cases customers may choose to handle attacks privately to avoid negative publicity.

Thus in all three paths after an analysis is performed the vulnerability is identified step and a constraint can be developed to detect the vulnerability and remediate against it step . The constraint code can be ported to different versions of the module that is patched step . That is multiple versions of the same software can exist in deployment. Some of these differences are not customer visible for example an earlier patch was applied or not . Each version typically has one or two slightly different files. Thus a patch should be ported to all the versions of a file that might be running in a customer machine. The constraints are extensively tested step before being released e.g. to customers step .

Delivery of the constraints such as in the form of libraries can also take multiple paths. For example the security laboratory can deliver the constraints directly to the customer . Or the security laboratory can deliver the constraints to the OEM software vendor which in turn delivers the constraints to the customer . In another approach the security laboratory can provide tools for developing and delivering the constraints to the OEM software vendor or to a constraint developer . Either of these entities can use the tools to prepare the constraints and deliver them to the customer as a service. The security laboratory optionally uses the help of a vulnerability information provider in multiple stages of constraint creation to develop the constraints. The vulnerability information provider can be individuals or companies who reverse engineer programs and or track and analyze the information on vulnerabilities to help the constraint developer create the constraints. The multiple stages of constraint creation generally refer to steps or or and of . Sometimes the vulnerability information provider can also perform steps and part of step to take some of the burden of constraint creation off of the constraint developer .

In another approach the customer itself develops the constraints and or constraint injection software if it has the available resources.

An original unmodified program which is to receive the constraint includes a code fragment which has a number of instructions e.g. instruction A instruction B instruction C and instruction D for instance. The original program refers to the program as it exists before a constraint is injected to protect against attacks. A Managed Program Execution Engine MPEE controls the creation and management of a secure code cache . Further details regarding a possible implementation of the secure code cache can be found in U.S. patent application publication no. 2005 0010804 published Jan. 13 2005 titled Secure Execution Of A Computer Program Using a Code Cache incorporated herein by reference.

The MPEE creates a modified code fragment from the original code fragment . In particular the modified code fragment includes a save context instruction a change stack instruction a call gateway instruction a return status instruction and a restore context instruction which are inserted at a patch point which is between the instruction B and the instruction C . Here we assume a constraint is a single unit that gets inserted into a single location with a single detector remediator function. However it is also possible for a constraint to be provided by using a collection of patch points where each patch point has its own insertion point detector and or remediator functions see . Generally a constraint can be inserted into any location in an application. The locations need not be predefined.

The specific location for inserting the constraint is specified by the constraint developer. The function of the save context instruction is to save the application context the function of the change stack instruction is to change the stack from the current stack to the MPEE stack the function of the return status instruction is to return a status of the detector to the user the function of the call gateway instruction is to call the constraint gateway and the function of the restore context instruction is to restore the application context. See for further details. The context is mainly denoted by the registers. Each context will have its own stack. However the current stack is identified by the stack pointer register thus changing the registers will change the stack.

A Constraint Management Engine CME coordinates with the MPEE so that when the original code fragment is copied from the original program location into the secure code cache it is correctly modified to reflect the modified code fragment . When the control flow invokes the constraint it calls the constraint gateway . In particular when the control flow passes through the modified fragment the call gateway instruction calls the constraint gateway . The constraint gateway using a deployment status given by the constraint management system calls the appropriate one or more constraints in constraint libraries . More than one constraint can be attached to the same instruction. The constraint libraries include a detector and a remediator which in turn may call a set of predefined functions from a predefined functions library . See section 19. The predefined functions may include e.g. string copy string compare and other functions that multiple constraints may use. The constraint libraries also include a constraint descriptor discussed below in section 9. The constraint gateway subsequently makes a call return to the code fragment such as to the return status instruction .

The detector determines whether the modified fragment is attempting to invoke the vulnerability in which case that fact is reported and the remediator is called. The detector should have no adverse impact on the program such as changing the program state. That is the detector code should not modify any program visible memory or program registers acquire program visible resources modify program control flow or crash and hang the system. Exception conditions should be caught and checks should be made for infinite loops. If a problem is encountered the constraint can be exited. For recurring problems the constraint can be disabled.

The remediator has the ability to change the application to fix a vulnerability such as by changing any application visible memory location or changing control flow of the program e.g. by returning from the current application function or jumping over a few application instructions after a trampoline. A trampoline is a small piece of code that is created at run time mainly in the stack. This code is generated to help the program transfer control from one place to another. The original code transfers control to the trampoline code which will then transfer control to the destination. There are multiple uses for trampolines. For example when the destination is not known at compile time the trampoline can do the control transfer without patching the binary. When the type of the branch is not known short or long the trampoline can help insert a variable sized instruction. Trampolines can also be used to handle long branches.

Allowed program level remediation action can also be taken such as killing a thread and or process and throwing an exception. The remediator code should change the program behavior only minimally to the extent needed to stop an attack.

The constraint management engine coordinates with the outside world via an external interface for managing constraints e.g. to set the deployment state of the constraints as well as to load new constraint libraries. For example the external interface can communicate with the central controller via the node manager .

The constraint system can be implemented on the Microsoft Internet Security and Acceleration ISA Server in one possible implementation.

The servers can also provide information to the central controller regarding stability and possible false positives thereby facilitating the deployment and improving the overall availability. When an event is triggered the server nodes can use intelligence to differentiate a security event from a false positive and also aggregate that information at the central controller to improve the accuracy and inform the system administrator. Furthermore each server or other end point can have a node manager that acts as an intermediary between the central controller and an application core within each individual application.

The central controller stores the constraints in a constraint store and collects information regarding the current status of the constraints in a constraint information module . A deployment settings and status module enables an administrator to manage the deployment of the constraints and informs the administrator of the current status. A statistics module collects statistical data regarding the constraints. See section below for further information.

Also in between the node manager and the core the notation read only memory denotes the mechanism to pass constraint information from the node manager to the application by sharing a memory page between the two processes the notation Constraint Library load denotes that the node manager loads information from the libraries and of into the application and the notation notification denotes a mechanism that notifies the application that new information is available for example this may be implemented using either an interrupt type or polling type mechanism . User preferences for constraint deployment such as on off detect or protect can also be provided in the notification. The notation read only memory denotes a shared memory page that communicates current operational characteristics from the application to the node manager . For example status information and statistics related to constraint deployments can be provided. Lastly the notation event log denotes that events generated by the core can be logged at the node manager .

The constraint gateway identifies the constraint that was executed step . If the constraint is active and selected decision block the detector in the constraint library is called step . If the current constraint is not in the protect mode the detector status is returned to the user step and execution continues at the application code step after restoring the application context step . Thus even if the constraint is not deployed in the protector mode status information statistics and the like can be reported. If the current constraint is in the protect mode decision block and if a return code from the detector indicates that remediation is necessary decision block then the remediator step is called. Depending on the return code of the remediator decision block different paths can be taken. In one path the current thread and or process is terminated step . In a second path the control flow is changed to a different application address in which case the fragment from the jump target is found or created step the modified application context is restored step and the fragment is executed step . In a third path the program continues executing from the point where the constraint was invoked in which case the application context which may be modified is restored step and the fragment continues executing step .

When a new constraint is loaded step the information about the constraint is recorded step . Next for all of the affected applications and the modules within the applications listed in the constraint step the system checks to see if the application is currently running and the module is currently loaded decision block . Note that step will be invoked multiple times by the step once per each module. If the module is loaded additional checks are carried out. For example the version of the module in memory can be checked against the version provided decision block . Specifically when a new module is loaded into memory step for each constraint step all the active constraints are queried to see if any of them includes the module being deployed decision block . Thus at decision block the version of the provided module can be compared to the version of the module in memory. If all the checks pass then for each patch point in the module step patch point selection logic is executed decision block . The patch point selection logic relates to matching the constraint application policy Section 11 below . If the patch point selection logic selects deployment a hash of the program bits around the patch point is calculated and compared to the provided hash in a hash check decision block . If the hash check indicates a match the patch point is deployed step .

The process is completed step when the module is not loaded decision block the module versions do not match decision block the patch point selection logic does not select deployment decision block or the hash check does not indicate a match decision block .

Constraints can be categorized by their interactions with the end user or the system administrator at the enterprise.

The constraint developer has the option of providing a constraint as a black box constraint. Black box constraints do not allow the customer any per constraint configurability. The only option the customer has is to decide where to deploy the constraint. However the constraint injection system may provide generic options for all constraints such as the ability to deploy in Intrusion Detection System IDS or Intrusion Prevention System IPS modes. In the IDS mode or detect mode intrusions are detected but preventative action is not taken while in the IPS mode or protect mode preventative action is taken in addition to the detection. The IDS mode thus can indicate the risk of user application interference before the constraint is enabled. Most constraints against vulnerabilities attacks and bugs can meet the customer s need while minimizing complexity when provided as black box constraints.

The user can supply a set of arguments or parameters to the constraint to tune the constraint. Further a constraint can check for broad or generic problems. Such constraints may need to be tuned to match each application and the deployment scenario. Thus the constraint can expose a per constraint interface to the customer. Most policy enforcement constraints fit into this category.

An advanced form of a parameter exposed constraint has a Graphical User Interface GUI component associated with it. This can be implemented using a simple GUI creation language an accompanying Java or Active X component or any other GUI technology.

Ultimately an Application Programming Interface API for constraint development can be exposed to the customer.

The scope of a constraint can be unlimited in its ability to insert arbitrary code or restricted to fit a specific method of program modification such as API interception. API interception refers to capturing the interactions between an application and an operating system at the API level. This section describes a set of possible scope restrictions as well as a detector and remediator model.

A constraint injection system has the ability to inject a constraint in the form of a small block of assembly code into a program. This provides the ultimate power to the constraint as it provides the ability to monitor or change the program s behavior without restrictions.

The assembly code injection can be restricted according to one or more Application Binary Interfaces ABIs . An ABI is a set of rules the code in the detector and the remediator has to follow. The ABI rules for the detector and the remediator are different. An ABI describes the low level interface between an application program and the operating system between an application and its libraries or between component parts of the application. An ABI allows compiled object code to function without changes on any system using a compatible ABI. The ABI can be tailored to support all the necessary functionality while disallowing any extra power that can negatively impact the application. For example an ABI for constraints used for data collection will not allow any modifications to the application state or any application control transfer.

Constraints for vulnerabilities can be developed within a detector remediator paradigm since most vulnerabilities are due to a corner case that should never occur in normal operation. As discussed previously the detector checks for the occurrence of the corner case and the remediator takes the necessary remediation action when the corner case is detected. Thus the detector can follow a very restrictive ABI so that it can provide a strong guarantee that it will not change the normal program behavior. This can be achieved by restricting the detector so that it cannot change normal program state including 

When the constraint is run in the detect mode it has no impact on the normal program operation. This is important because some constraints can generate false positives and remediation action taken as a result of these false positives can impact the normal program behavior. In this mode the customers can observe and test the constraint for false positives without impacting the application.

The remediator has the ability to modify the program state and change the control flow of the program. However the ABI for the remediator can also be restricted by providing it with an interface to carry out the remediation action.

Simple constraints referring to both the detector and the remediator will be stateless. However it is possible to extend the constraint injection system such that a constraint can capture store modify and share the internal state across time or with other constraints. Constraint state information should be decoupled from the program state.

As APIs are a publicly visible thus stable and known points in a program they provide a good opportunity for interception. A validation routine can validate the arguments passed in the API call. As all system calls are implemented as an API API interception is a superset of system call interception.

The API validators a type of constraint are also a small block of assembly code. However this block has to follow an even more restricted form of the ABI than that followed by general constraints. For example this code can only access memory that is part of the input data structures for the API. The API validator ABI will provide access to each of the arguments to the API. The data types of the arguments of individual APIs are validated thus making the allowed accesses more precise and restrictive.

The API validators can also be extended to accommodate simple interceptions similar to input filtering where for a given API and an argument a regular expression is provided to validate the argument.

A typical input filter is a regular expression. All inputs to the application the type of the input is given by the policy are checked against the regular expression. The alphabet used to build the regular expression can include ASCII and Unicode characters memory addresses and a set of special terms defined by the API. If needed a more powerful grammar can be developed to express the input filters.

Each application is analyzed to find appropriate filter points. Filters and filter points are tagged as belonging to one or more categories as indicated by Table 1. For applications that were not analyzed and tagged a set of generic rules can be used to identify what to filter and what category each filter point is associated with. Table 1 provides a partial list of possible input point categories.

1. Generic Monitors using the Microsoft Windows API for instance special API interceptors can be created as generic selectors that can be applied to any program.

2. Custom Monitors with the full knowledge of a given program a specific interception point can be monitored for input filtering.

It is important to precisely describe where to insert the constraint in the application code. As the application code is executed when the control flow passes over the patch point the constraint will be invoked. This section describes possible patch points for constraints.

When a constraint is inserted into a known module e.g. an executable or a library an offset from the starting address of the module can be provided to indicate the patch point.

If the module is guaranteed not to be relocated by the loader the absolute address can be used to describe the patch point.

In order to support multiple versions of a module that may be slightly different a symbolic address with an offset can be provided to describe the patch point. The constraint injection system can resolve the symbolic address and add the offset to determine the actual insertion point.

To describe a constraint at an API function provided by the operating system or the common libraries the name of the function can be used. Thus the constraint can be applicable across multiple major and minor versions of the library. Furthermore a constraint can be created without having access to the application.

Constraints can be inserted before and or after a system call. System calls can be identified by the special machine instruction that performs the kernel transfer. Some operating systems such as Microsoft Windows renumber system calls between versions in which case a table that maps the system call to the call number according to the Operating System OS version can be used to allow the system call identification to work across multiple OS versions.

Instead of identifying a location the constraint injection system can check for a particular collection of instructions to identify where to insert a constraint. A simple search involves matching an exact code sequence. However this search can be complex. For example regular expression matching may be used.

A multiple mode system uses criteria such as a symbolic offset or system call to identify a general region and then searches that area to find a code pattern to locate the exact patch point. There are other possible combinations for multi mode selection. The address calculation can also include more complex algorithms.

An important aspect of a constraint injection system is the method used to inject the constraint into the application code. Some of the injection methods only provide a partial set of desired attributes of a constraint injection system. This section describes a few possible injection methods.

The constraint can be invoked by inserting a trampoline or short section of code into the given location of the memory image of the application module. Since this insertion should occur concurrently with other active threads the trampoline insertion has to be atomic. Furthermore it can overwrite an instruction at a valid instruction boundary. These limitations impose restrictions on where trampolines can be installed and the type of instruction that can be inserted. It may be necessary to have a short jump to a nearby location before transferring control into the constraint code block.

This method discussed previously in connection with involves a system that creates a cache of the instruction blocks of the original program and executes the instructions out of the cache. The Memory Firewall available from Determina Corp. Redwood City Calif. is an example of a system that creates an instruction cache. However other approaches may be used as well. Since the instruction cache remaps the address space and provides an application transparent translation from the original address to the cache address it is possible to change the shape of the instruction block. Thus it is possible to insert multiple instructions into a program instruction block by expanding the block in cache. Furthermore the MPEE which provides a cache management system can provide synchronization between multiple threads so that the code insertion does not need to be atomic allowing the insertion of multiple instructions. This provides a flexible framework for constraint injection. When a code block is copied to the code cache the constraint injection system can check to see if an active constraint is designated to be inserted into that block. If an active constraint is so designated the constraint injection system can rewrite the block with the constraint code or insert a call to the constraint code. If a new constraint arrived while the application is running and the insertion point is already in the code cache that cache block can be flushed and recreated with the constraint inserted. The recreation can occur immediately or lazily when the program counter is transferred to that block next time.

In this method the executable or the library can be modified offline to insert the constraint e.g. by inserting a trampoline or rearranging the code. The constraint can be in lined or a constraint function can be added to the module. Note that this method is unable to provide dynamic injection of constraints.

In this method the modification occurs in the program development tool chain. This can occur at many points such as at the compiler assembler or the linker.

This method is applied when the program is released as byte code and can rewrite the byte code to include the constraints by the loader execute the constraints in the interpreter or insert the constraints in the Just In Time compiler when the byte code is translated into machine code.

Operating systems and complex applications provide APIs for inserting functionality for monitoring or changing the application behavior. In this method an application or operating system specific constraint injection system can be created using one of these APIs provided by the application or the OS. The constraint will get invoked when the underlying application or the operating system calls the API. However such a system cannot support insertion at any arbitrary point in the application.

When a module is loaded into the memory space the loader can scan the module and insert any applicable constraint. This can be done either by inserting a trampoline or inlining the constraint by rearranging the code in the module. However the loader method cannot support dynamic insertion after the library or the executable is loaded.

In this method a limited form of constraint that allows the monitoring of system calls can be implemented using a system call shim either from within the user space or the kernel space.

The constraint descriptor provides a description associated with each constraint that helps the constraint injection system decide when where and how to apply the constraint. There are many variations of constraint descriptors possible. Two example instantiations of a constraint descriptor are provided below. In particular Table 2 provides a basic constraint descriptor while Table 3 provides an extended constraint descriptor.

Table 2 depicts an instance of a descriptor provided by each constraint. The example is geared toward use with Microsoft Windows but is generally applicable. One possible representation uses an extensible markup language XML file. The constraints may use this descriptor in one approach.

The following fields Table 3 can be use to supplement or replace the fields in the basic descriptor Table 2 to provide a more extensive form of a constraint descriptor.

A constraint injection system may require each constraint to provide machine instructions along with the constraint descriptor. This can be either an arbitrary block of instructions or an instruction block that follows a given set of rules e.g. a restrictive ABI. When a constraint is invoked by the constraint injection system this code block can be executed. A constraint injection system can support a mix of these languages. Note that in a detector and remediator based solution each constraint can carry two code blocks one for the detector and one for the remediator. A constraint can be implemented using the following techniques.

When a constraint is injected a library file such as a DLL can provide the code for the constraint. This library can have an exported function for the constraint which is called by the constraint injection system. Each library can have functions for multiple constraints. The constraint injection system can support either a single comprehensive library with all the constraints or multiple libraries each with only the new constraints.

Instead of relying on the loader to load the constraint function library the constraint injection system can directly provide the machine code for the constraint function. This information is copied into the program s memory by the constraint injection system. However the constraint injection system has to resolve the symbols and perform the linking. The linking functionality required is simple since the constraint functions have a very limited ABI. Furthermore not exposing the constraint functions to the application makes the constraint injection system more transparent. Another issue is relocation of the code. The constraint injection system can either carry out the relocation or demand position independent code.

The constraint code provided as a code block can be directly inlined into application code at the appropriate locations when the code cache is built. This can lead to better performance when executing constraints.

This is very similar to machine instruction code block insertion where instead of inserting a code block the existing code block is replaced.

Instead of providing machine instructions a byte code can be used to describe the constraint. When the constraint code has to follow a restricted ABI the byte code provides a simple way of enforcing that ABI. The byte code should have a simple mapping to the machine instructions.

Table 4 provides an example of a simple constraint byte code format. The byte code can be either a part of the constraint descriptor or a separate file. SP denotes a space.

Combining the information provided in the constraint descriptor with the current machine state e.g. version of the OS application libraries loaded etc. current threat landscape information on other related constraints and user instructions the constraint injection system can decide which applications the constraint should be injected into and when to perform that task. The filtering of the constraints for a given application can be performed using the following information criteria 

The constraints can be created by an appropriate vendor as discussed previously in connection with . Users who wish to deploy the constraints using a central management console download the constraints and manage them as discussed in connection with . The controller interfaces with a node manager at each server. The node manager in turn interfaces with the core constraint injection system that runs on the protected applications. Using the controller the users have the ability to manage the system at the granularity of a constraint and obtain information on the status and effectiveness of each constraint. The user is able to dynamically turn a constraint on and off and to put a constraint into a detect or protect mode as discussed previously. The user is also provided with the deployment status and statistics on each constraint. This feedback information can include 

Once a patch point has been identified the injection takes place. The code injected can save the application s stack switch to the constraint stack push all of the application s registers on to the stack and start constraint execution. After constraint execution the application registers and stack are restored and the control flow resumes at the actual instruction at the patch point. After the injection is completed and before the constraint is executed constraint reset function is invoked to set up a state required by the constraint.

Bookkeeping such as status statistics violation reporting etc. can be done for each constraint so that the constraints execution can be wrapped in a sandbox. This can be done using a gateway function or a prologue epilogue function pair for instance. The advantage of using a gateway is that only the call to the gateway can be injected at the call site. However this means that the constraint both the remediator and detector can be invoked with a function pointer inside the constraint injection system which is considered to be a security hazard. This problem can be overcome using a prologue epilogue function pair. That is at the call site inject a call to a prologue function then a call to the detector then to the remediator and then to the epilogue along with control flow logic as needed. However one drawback is that a large amount of code has to be injected for a given patch point. If the security issue with the gateway model can be resolved using write protection for core text or doing a target validation before calling it that model should be favored.

If more than one constraint needs to be applied at a point the precedence Table 2 is used to determine the order of injection. Note that each constraint does not get a new clean set of application registers. There will be only one set. If an earlier constraint modifies it then the subsequent constraint can see the change. Otherwise the remediation offered by an earlier constraint will be lost. The constraint can be designed to handle this situation.

The atomicity of injection can be at the vulnerability level not policy level e.g. if all modules required by at least one set in a vulnerability are satisfied then its constraint will be injected even if other vulnerabilities in the same policy aren t ready. If injection isn t done at this level then a vulnerability can be exposed until others in its policy are ready to be patched which defeats the purpose of constraint injection.

Another dimension of atomicity is whether to inject the constraint as each DLL matches or wait until all DLLs required are matched for a given vulnerability when the libraries are DLLs. Injecting when all DLLs are matched for a given vulnerability is logical from an atomicity point of view. However if one DLL is loaded early and matches and another DLL is loaded later in the execution the security hole in the first DLL will be unpatched until the second DLL is loaded. This can be handled by creating another vulnerability for the same policy with a different set . Thus both the inject as you load and the inject after all are loaded approaches have merits and demerits.

Unlike injecting flushing happens only at a policy level. Flushing means that the fix offered by a policy is being removed which means for all its vulnerabilities . A policy can be flushed under one of the following circumstances 

As constraint information will be transmitted from the constraint developer to the customer site and eventually to the core of an application verifying the integrity of the information at the customer site is key to prevent problems due to tampering.

First the transmitted XML file e.g. descriptor file should be verified by the CME . Signed certificates can be used to communicate with the constraint developer s web site for instance to download the XML file. Once the file is obtained it can be verified using the xml file signature Table 2 .

Second the integrity of the constraint library transmitted should be verified. For each constraint dll in a policy there exists a constraint dll hash . Using this hash value the core can validate a constraint library. A verification failure will result in an event being logged.

Since constraints should have a minimal impact on the application and its availability what goes into a constraint library can be highly restricted to avoid an adverse impact on a live application. For example the following restrictions or set of rules can be imposed on the constraints using an ABI 

Each detector can be called with one argument namely a pointer to a context structure. Macros can be provided to the constraint writer to read and write to the application s registers using this pointer. Each detector can return one of the following status codes 

A program analysis tool can be used to check and enforce these guidelines during constraint development. However the guidelines are not absolute rules. In those rare occasions when no other option is available these guidelines can be ignored. But it should be done after much consideration approval from an oversight team and a lot of quality assurance. Note that byte code based constraints can make the task of enforcing these ABI restrictions simple and make it possible to validate the ABI in the constraint injection system.

Each remediator can be called with the two arguments. The first is the same as for the detectors which is used by the remediator to read and write to application registers unlike the detector which can only read . The second is a pointer to a buffer of fixed size which can be used by the remediator to provide information that can be written to the event log. The remediator can perform one or more of the following 

The execution of a constraint can result in an infinite loop or access violation exception due to dereferencing NULL invalid or protected memory . The constraint injection system need not deal with infinite loops instead the constraint writer can deal with it at constraint creation time as an ABI restriction.

In the case of an access violation a constraint injection system s exception handler can identify the exception to be related to a constraint terminate the constraint execution and return to the gateway prologue epilogue function with the appropriate status code and let the reminder of the cleanup and bookkeeping be done by that function.

The detector and remediator ABIs allow the detector and remediator respectively to call a predefined set of support functions including functions belonging to the following classes 

Care should be taken when the functions change the application visible state to avoid a program crash. Functions called by the detector have further restrictions such as avoiding modifications to any application visible state.

The Managed Program Execution Core in the Memory Firewall product available from Determina Corp. Redwood City Calif. provides a suitable substrate to implement a constraint injection system. Since the core creates a code cache and executes all instructions through the cache it is possible to insert any instruction sequence at an arbitrary address. The code cache creation process allows for atomic insertions and deletions of constraints. It also provides the basis for sandboxed execution of the constraints. The core also has the mechanisms to provide input output I O and memory management functions minimally visible to the application. However the use of this product is an example implementation only as other implementations are also possible.

It is difficult if not impossible to provide customized constraints for every application used by all customers. This would require having thousands of installations and quality assurance support. Furthermore application customization and multiple versions can make this task even more difficult. To simplify matters applications can be divided into three categories.

The following provides an example of constraint code for a constraint that protects against the vulnerability announced by Microsoft in their security bulletin MS03 007. This is an unchecked buffer vulnerability that can lead to a total system compromise in IIS due to the use of a long file name. Further details can be found at http www.microsoft.com technet security bulletin MS03 007.mspx. After analyzing the vulnerability the constraint developer produces a constraint. provides the source code detector and protector functions of the constraint. The vulnerability relates to the use of a long file name. As indicated the patch point is right before a call to the function RtlInitUnicodeString which is a function that truncates a Unicode string s length to 16 bits integer. provides a disassembly of the code in NTDLL.DLL where the constraint is applied. NTDLL.DLL is a core operating system component used to interact with the Windows kernel. There is a simple vulnerability in this code. The length of the argument is not checked against the maximum possible length of a file name creating an opportunity for a buffer overflow attack. Thus a constraint as described above is injected to check the length before calling the function RtlInitUnicodeString. provides an XML file that is produced and shipped to customers. The XML file provides the information needed to identify the need for a constraint and deploy the constraint to the Central Controller at the customer site. It provides information for the customer identifying which vulnerability is protected information on when and where to deploy the constraint and information about detector and protector functions provided.

Another embodiment of constraint injection involves using a standalone framework that loads and inject the constraints directly into the application memory without using a code cache. In this approach when a protected application is started a special DLL or other library that manages constraints is loaded. This library implements a routine that the Constraint Management Engine CME can invoke when a change to the set of constraints or change to the deployment has occurred. This can be done in two ways. One method is by inserting hooks or callbacks onto the application s regular control flow so that when the application executes it will invoke a DLL or other library routine on a regular basis. Another method is to use special operating system mechanisms to invoke a routine in the application from an external call from the CME.

When the constraint manager routine of the DLL or other library is invoked it will check with the CME regarding which constraints should be applicable to the application. This will occur either at the startup or when CME provides a notification that there is a change or when a new library is loaded. At startup all active libraries loaded into the memory are scanned and that version information is matched with the list of constraints given by the CME. When the CME provides a notification of a change to the list again that active library list is checked against the updated constraint list provided by the CME. The loading of a new library is detected by hooking the loading process. When this hook is invoked it will check the new library against the constraint list provided by the CME. A new constraint can be installed or an active constraint is deactivated using the following mechanism.

First it is desirable to guarantee that all the threads that are executing in the address space are at a safe point which allows modify of the memory image without creating race conditions. One way to enforce this is to suspend all the threads and check the program counter location on which the threads were suspended. If the program counter is at an unsafe location then that thread is resumed and allowed to reach a safe point at which it is suspended again. Or the current program counter can be relocated to the constraint gateway. It is desirable to ensure that this process is safe with respect to the loader modifying the application image since the loader may modify the memory image of the library. This can nominally be done by waiting until the loader finishes the modifying of the memory. An alternative method to enforcing safety without suspending all threads is to make sure that modifications to the memory image can coexist with execution of that region. This can be achieved e.g. by using atomic updates if the instruction inserted is small or by first atomically inserting a few instructions which will generate a fault if they are executed and then changing the needed instructions from the bottom up. If a thread reaches the modification region while it is being modified it will throw an exception which can be caught. When an exception is caught the thread is stopped until the injection is over.

Second the constraint can be loaded into the memory if it is not already loaded into the memory image. This can be done by using the loader if the constraint is given as a regular DLL or other library or by copying the constraint instructions into the memory using a custom loader.

Next each patch point is examined to ensure that it conforms to the specification of the patch point. In this case the patch point should have the following eight additional restrictions listed below in one example implementation.

1. A patch point specifies the address where the constraint is injected into the application code. The patch point must always be at an instruction boundary. The five bytes after the patch point are called a patch region and will be overwritten during constraint injection. The bytes taken by the instructions that start in the patch region are known as the extended patch region . If the last instruction in the patch region extends past the end of it the expended patch region will be greater than five bytes. For example 

2. None of the bytes in the patch region can be a target of a control transfer instruction anywhere in the program.

3. None of the instructions that end in the first four bytes of the patch region can be a CALL or a non conditional JMP instruction. It is acceptable for a CALL or JMP instruction to end at the last byte of the patch region.

8. The patch region must not cross a thirty two byte cache line boundary only required if using atomic injection .

Before proceeding with the injection we calculate the validity of the patch point by computing a hash function of the instructions in the vicinity of the patch point. However if another constraint was injected within the vicinity then the computation of the hash function needs to utilize the original instructions that were moved to the constraint gateway.

Next the patch point in the application memory is modified to insert a control transfer instruction to the constraint gateway. Before the modification occurs the application instruction s at the patch point are copied to the constraint gateway so they will get executed before or after the constraint is executed. However if the instructions that are copied over are control transfer instructions that have relative addressing the address has to be modified. This may require expansion of the relative address size.

If the constraint being injected requests control flow transfer to another location as one of its remediation actions and if that location is already patched with a different constraint then the control flow transfer is modified to go directly to that constraint. Furthermore if any other active constraints require control flow transfers to the patch point of the current constraint these transfers are also modified to go to the constraint directly.

The system also intercepts any memory protection to make a read only page writable. The constraints are removed and when the page is made executable again the injection process is performed again.

Two gateways can be called from the modified program via trampolines provided by code fragments and . The gateway for the call to CME includes a code fragment with a save context instruction a call CME instruction a restore context instruction the instruction Y and a back to program instruction . Instruction Y can be executed before or after instruction . A control flow is transferred from the gateway to the CME at the instruction . The control flow returns to the gateway from the CME for executing the restore context instruction for example. The gateway for the patch point includes a code fragment with a save context instruction a call detector and remediator instruction a restore context instruction the instruction C and a back to program instruction . A control flow is transferred from the gateway to the libraries at the instruction . The control flow returns to the gateway from the libraries for executing the restore context instruction for example.

The CME external interface for managing constraints constraint libraries including detector remediator and descriptor libraries and the predefined support functions library are comparable to their namesakes in described previously.

At a patch point an instruction of the code fragment is rewritten to provide the code fragment which includes a call via the go to gateway instruction to the custom gateway for the patch point . The saving and restoring is performed on the gateway for the patch point . In particular the application context is saved at instruction . The detector and remediator libraries are called at instruction . The control flow is returned to the gateway so that the application context is restored at instruction . Instruction C is also called before or after instruction . The control flow then returns back to the program at instruction . In particular the control flow can return to instruction D of the modified program for instance.

Note that the instructions that were overwritten are copied to the gateways. In particular instruction C which was overwritten by the go to gateway instruction was moved to the gateway for the patch point and instruction Y which was overwritten by the go to gateway instruction was copied to the gateway for the call to the CME . In order to change the control flow to the CME trampolines are inserted in the commonly executed paths as indicated by code fragment . The external interface for managing the constraints can also call the CME . Thus as the code fragment of the program executes the control flow is transferred to the gateway for calling the constraint libraries . As the code fragment executes the control flow is transferred to the gateway for invoking the special DLL or other library that manages the constraints such as by installing a new constraint deactivating an active constraint detecting the loading of a new library by the computer program and determining which constraints are applicable to the computer program.

The present invention can be accomplished using hardware software or a combination of both hardware and software. The software used for the present invention is stored on one or more processor readable storage devices including hard disk drives CD ROMs DVDs optical disks floppy disks tape drives RAM ROM flash memory or other suitable storage devices. In alternative embodiments some or all of the software can be replaced by dedicated hardware including custom integrated circuits gate arrays FPGAs PLDs and special purpose processors. In one embodiment software implementing the present invention is used to program one or more processors. The processors can be in communication with one or more storage devices peripherals and or communication interfaces.

The foregoing detailed description of the technology herein has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the technology to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the technology and its practical application to thereby enable others skilled in the art to best utilize the technology in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the technology be defined by the claims appended hereto.

