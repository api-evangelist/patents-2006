---

title: Data synchronization mechanism for change-request-management repository interoperation
abstract: Computer method and apparatus for managing software configuration repositories are disclosed. In a plurality of repositories each repository holds a respective set of change-request objects. One of the repositories in the plurality is a primary repository, and the other repositories are working repositories. In the primary repository, there is a respective proxy object for each change-request object of interest in a working repository. Each proxy object has a corresponding associated change-request object in the primary repository. For a given proxy object, changes made to the respective change-request object of interest in the working repository are mapped to the associated change-request object in the primary repository and vice versa.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07836429&OS=07836429&RS=07836429
owner: International Business Machines Corporation
number: 07836429
owner_city: Armonk
owner_country: US
publication_date: 20061219
---
A Change Request Management CRM system is used during development of a software system to record and track the changes which have been requested by the stakeholders e.g. users testers developers and designers of that software system. It is common for multiple CRM repositories to be in use in a single organization. In some cases this is because no one CRM repository has all the features needed by the organization. In other cases this is because it takes a long time to transition all of the business processes and projects from one CRM repository to a different CRM repository and so both CRM repositories remain in use for an extensive period of time. As a result users that participate in multiple software development projects will often have to use multiple CRM repositories.

One approach to minimize training costs and user mistakes when a single user must interact with multiple CRM repositories is to host all of the CRM repository clients in a common GUI framework but this can only address some generic aspects of the user interactions with the different CRM repositories. A deeper unification can be achieved when the CRM repositories provide an application programming interface API . In this case a single client can be implemented that can access multiple repositories but this frequently leads to a lowest common denominator client that only provides functionality that is common to all of the CRM repositories.

In addition to the problems identified above there are several other important problems that are not addressed by a common GUI framework or a common client. In particular there often are queries that must be run that require information from multiple CRM repositories and there often are important relationships that must be captured and maintained between objects in different CRM repositories. In addition executing these queries or traversing these relationships should be possible even when one of the required repositories is unavailable or unresponsive.

The present invention addresses the foregoing problems of the prior art. In particular the present invention provides a data synchronization mechanism for change request management repository interoperation.

In a preferred embodiment a computer method and apparatus manages software configuration repositories. In a plurality of repositories each repository holds a respective set of change request objects. One of the repositories in the plurality is a primary repository and the other repositories are working repositories. In the primary repository there is a respective proxy object for each change request object of interest in a working repository. Each proxy object has a corresponding associated change request object in the primary repository. For a given proxy object changes made to the respective change request object of interest in the working repository are mapped to the associated change request object in the primary repository and vice versa.

Illustrated in is a Change Request Management CRM system embodying the present invention. The Change Request Management system may be part of a software configuration management system new e.g. U.S. patent application Ser. No. 11 555 521 by assignee herein incorporated by reference or known in the art or the like. According to principles of the present invention in CRM system there are two or more change management repositories . In each change management repository there is maintained a respective set of objects . Each set of objects captures a respective set of changes that have been requested by the developers and users of a software system e.g. program . These change request objects are known by a variety of names in different change management repositories or software configuration management systems such as Modification Requests Enhancement Requests Work Items Defects and Bugs. In this disclosure the term Change Request is used to refer to these types of objects .

The information about a change request is captured in a set of properties of the Change Request object . The property is represented by either an atomic value such as a string an integer or a date or a reference to another object as illustrated by the XX and dotted line arrow respectively of object in . Some properties are pre defined and present on all Change Request objects but most properties are determined by a customer and can vary from project to project. The current state of a change request is summarized in a pre defined State property of the Change Request object . Although the State property is pre defined the legal values of the State property are determined by a customer. The customer defines a set of allowed transitions from one State value to another and defines the actions that perform those transitions.

One of the CRM repositories i is selected as the primary CRM repository. All other CRM repositories in use are considered external CRM repositories also known as working CRM repositories. A copy called a proxy is then created in the primary repository for each object in an working repository that is to participate in cross repository queries or has a relationship with an object in another repository. Each proxy object is then associated with a type of object in the primary repository that is closest semantically to the proxy object. Rules called incoming synchronization rules are then defined that map changes made to an object in the working repository into corresponding changes to the associated object in the primary repository i.e. the primary object associated with the corresponding proxy object of the subject object . Conversely rules called outgoing synchronization rules are defined that map changes made to an object in the primary repository into corresponding changes to the associated object in the working repository the association being defined through a respective proxy object .

The working repositories are periodically queried to see if the state of an object associated with a proxy has changed and if so the proxy is updated with the current state of that external object and incoming synchronization rules part of are run to make corresponding changes to the primary repository object associated with that proxy . Conversely if the state of a primary repository object that is associated with a proxy is updated outgoing synchronization rules are run to make corresponding changes to the state of the object in the working repository that is associated with corresponds to that proxy .

Process control in a CRM repository can abort a requested update to an object if the update violates the process defined for that object .

Incoming synchronization rules may depend on values of fields in objects referenced by the object being synchronized.

An object in an working repository can be modified in parallel with the primary repository object with which it is being synchronized.

In order to handle these situations each proxy is given a user visible synchronization status field . To ensure that synchronization processing never blocks operations in either the primary or working repository changes can always be made to the associated item or to the associated external object no matter what the current synchronization status is of the proxy for that item or external object.

To handle all of the situations described above the following proxy synchronization status values for field are defined 

PENDING Incoming or outgoing synchronization is currently being performed by the proxy . Because the working repository may be unavailable a proxy can have PENDING synchronization status for extended periods of time. This is the only synchronization status that will change without explicit user action.

UNINITIALIZED This synchronization status is for an external object whose state has never been retrieved from the working repository . This occurs when an external object has a reference to another external object but the state of that referenced object is not required for incoming synchronization. In this case the state of the referenced external object is not retrieved from the working repository and the proxy for the referenced external object is given UNINITIALIZED status . This is done because it is common for there to be a high degree of connectivity between change request objects and automatically retrieving the state of all referenced objects is likely to result in retrieving the state and creating a proxy in the primary repository for every change request object in the working repository . An UNINITIALIZED proxy will stay UNINITIALIZED until an explicit action by a user results in a request for it to be initialized.

OUTGOING ERROR When the item associated with the proxy has been changed but outgoing synchronization failed while trying to update the associated external object the synchronization status of the proxy is set to OUTGOING ERROR. Because outgoing synchronization is affected both by the current state of the item and by the current state of the associated external object outgoing synchronization is retried on a proxy with OUTGO IN ERROR synchronization status whenever the item or its associated external object is modified.

INCOMING ERROR When the proxy has been updated in response to a change to its associated external object but incoming synchronization failed while trying to update the associated item the synchronization status of the proxy is set to INCOMING ERROR. As with outgoing synchronization incoming synchronization is affected both by the current state of the external object and by the current state of the associated item so incoming synchronization is retried on a proxy with INCOMING ERROR synchronization status whenever the item or its associated external object is modified.

CONFLICT Whenever both an item and its associated external object are modified in parallel the proxy will attempt to auto merge the results of incoming synchronization with the changes made to the item . The auto merge succeeds if no field in the item is modified both by incoming synchronization and by changes to the item and if the result of combining those changes does not violate any process defined in the primary repository . If the auto merge does not succeed the synchronization state of the proxy is set to CONFLICT. When a proxy is in CONFLICT state a user can perform a manual merge of the results of incoming synchronization and the changes to the item . If auto merge succeeds or if a manual merge is performed the state of the item is updated to be the result of the merge and standard outgoing synchronization is attempted with the new state of the item. Since the success of auto merge is affected both by the current state of the external object and by the current state of the associated item auto merge is retried on a proxy with CONFLICT synchronization status whenever the item or its associated external object is modified.

CYCLE Because process automation can be defined in the primary repository when incoming synchronization modifies the state of an item the new state of the item must be inspected to determine whether it is different from the state defined by incoming synchronization. Any changes that resulted from process automation in the primary repository must be applied to the corresponding external object via outgoing synchronization. Conversely because process automation can be defined in an working repository when outgoing synchronization modifies the state of an external object the new state of the external object must be inspected to determine whether it is different from the state defined by outgoing synchronization. Any changes that resulted from process automation in the working repository must be applied back to the corresponding item via incoming synchronization.

This process of successive incoming and outgoing synchronizations that result from a change to either an item or its associated external object could result in an infinite cycle of updates. For a simple example process automation in the primary repository could automatically set a field in the item to false while process automation in the working repository could automatically set the corresponding field in the external object to true. The proxy must be designed to detect this kind of potential infinite loop in the synchronization processing.

In simple cases such as the preceding example it could do so by keeping track of the states that have been produced by successive incoming synchronization without intervening user activity but in general the process can produce an extremely large number of states such as by incrementing an integer and therefore a simple loop counter is preferable. The process designer should be allowed to specify the maximum value of this counter since the amount of legal cycling that is to be expected from process automation depends on the kind of process automation that has been defined.

OK If the associated item and the corresponding external object are successfully synchronized the synchronization state of the proxy is set to OK.

Client computer s devices and server computer s provide processing storage and input output devices executing application programs and the like. Client computer s devices can also be linked through communications network to other computing devices including other client devices processes and server computer s . Communications network can be part of a remote access network a global network e.g. the Internet a worldwide collection of computers Local area or Wide area networks and gateways that currently use respective protocols TCP IP Bluetooth etc. to communicate with one another. Other electronic device computer network architectures are suitable.

In one embodiment the processor routines and data are a computer program product generally referenced including a computer readable medium e.g. a removable storage medium such as one or more DVD ROM s CD ROM s diskettes tapes etc. that provides at least a portion of the software instructions for the invention system. Computer program product can be installed by any suitable software installation procedure as is well known in the art. In another embodiment at least a portion of the software instructions may also be downloaded over a cable communication and or wireless connection. In other embodiments the invention programs are a computer program propagated signal product embodied on a propagated signal on a propagation medium e.g. a radio wave an infrared wave a laser wave a sound wave or an electrical wave propagated over a global network such as the Internet or other network s . Such carrier medium or signals provide at least a portion of the software instructions for the present invention routines program .

In alternate embodiments the propagated signal is an analog carrier wave or digital signal carried on the propagated medium. For example the propagated signal may be a digitized signal propagated over a global network e.g. the Internet a telecommunications network or other network. In one embodiment the propagated signal is a signal that is transmitted over the propagation medium over a period of time such as the instructions for a software application sent in packets over a network over a period of milliseconds seconds minutes or longer. In another embodiment the computer readable medium of computer program product is a propagation medium that the computer system may receive and read such as by receiving the propagation medium and identifying a propagated signal embodied in the propagation medium as described above for computer program propagated signal product.

Generally speaking the term carrier medium or transient carrier encompasses the foregoing transient signals propagated signals propagated medium storage medium and the like.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

While this invention has been particularly shown and described with references to example embodiments thereof it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims.

For example other computer architectures and configurations instead of those described in are suitable.

Embodiments of the present invention are usable in software configuration management systems such as those described in U.S. patent application Ser. Nos. 11 459 743 and 11 561 558 by the current assignee herein incorporated by reference. Other software configuration management systems are suitable.

