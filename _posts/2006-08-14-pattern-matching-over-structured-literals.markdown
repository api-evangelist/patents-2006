---

title: Pattern matching over structured literals
abstract: A computer programming language, computer-readable medium and method for pattern matching over structured literals (e.g., XML literals, object literals, type literals, code literals, etc.). The programming language may have a pattern defined in an object-oriented programming language. The pattern may be a structured literal that is capable of matching a value contained in an incoming data stream. The structured literal may include one or more variables, which may be bound to the value if the pattern matches the value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08397226&OS=08397226&RS=08397226
owner: Microsoft Corporation
number: 08397226
owner_city: Redmond
owner_country: US
publication_date: 20060814
---
Most object oriented languages have some form of switch statement that allows the value of data to influence the control flow of a program. The following is an example switch statement in a Visual Basic program 

As illustrated above the values in the branches of the switch statement are usually limited to types that have numbers Booleans and or strings as literals. Thus in most object oriented languages such as Visual Basic for example only simple i.e. non structured types may have literals.

Functional languages such as Haskell and Service Modeling Language SML generalize such switch statements by using pattern matching as a convenient notation to bind variables based on the structure of incoming data. This is possible because functional languages typically support literals for structured types such as lists trees and the like. For example the statement below performs a pattern match on the argument list xs checking to determine whether it is either empty or of the form y ys in which case it binds y to the head hd xs of the list and ys to the tail tl xs of the list 

In this example the values have structure. Accordingly instead of switching only on constants i.e. non structured types switching may also occur on structured values. In addition substructures may also be bound to variables. By contrast where pattern matching is performed on non structured type literals there is nothing to bind. A variable may be bound when the variable is given a value. Thus a variable may have a name type and if bound a value.

The expressiveness of pattern matching may be derived from the fact that the compiler may perform extensive rewriting on the source code to extract the matched values binding them to the indicated variables while maintaining the correct branching control structure. With the introduction of structured literals e.g. XML literals object literals type literals etc. into various object oriented and functional programming languages it would be desirable to use structured literals to implement pattern matching in these programming languages.

The described embodiments contemplate a computer programming language computer readable medium and method for pattern matching over a structured literal. The programming language may have a first pattern defined in an object oriented programming language. The first pattern may be a structured literal e.g. an XML literal object literal type literal code literal etc. that is capable of matching a value contained in an incoming data stream. In one embodiment the structured literal may have one or more variables which may be bound to the value if the first pattern matches the value. In another embodiment the programming language may have a second pattern defined in an object oriented programming language. The second pattern may be a structured literal and may be checked against the value if the first pattern does not match the value.

The computer readable medium and method may include defining a first pattern in an object oriented programming language and determining whether the first pattern matches a value contained in an incoming data stream. In one embodiment the first pattern may be a structured literal with one or more variables. The variables may be bound to the value if the first pattern matches the value. In another embodiment the computer readable medium and method may include defining a guard expression and statement block evaluating the guard expression and executing the statement block if the guard expression evaluates to true.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

The inventive subject matter is described with specificity to meet statutory requirements. However the description itself is not intended to limit the scope of this patent. Rather the inventors have contemplated that the claimed subject matter might also be embodied in other ways to include different steps or combinations of steps similar to the ones described in this document in conjunction with other present or future technologies. Moreover although the term step may be used herein to connote different elements of methods employed the term should not be interpreted as implying any particular order among or between various steps herein disclosed unless and except when the order of individual steps is explicitly described.

Pattern matching may use a syntax similar to the construction of values for deconstructing structured values and binding constituent values to variables. A pattern may be syntactically similar to a literal except that it may appear in a variable binding position or in a expression list position of a switch statement. The leaves of the pattern may contain variable declarations that are bound when the pattern matches. Pattern matching has been popular in functional and logic programming languages because it facilitates the creation of concise programs that are capable of manipulating complex data structures. Now that object oriented languages such as C and Visual Basic have literals for structured types it has become possible to incorporate pattern matching capabilities to object oriented languages as well.

Pattern matching may make data processing code cleaner shorter and more concise by making forms that bind variables resemble the data syntactically as well as structurally. Consider the following example switch statement for analyzing the sub properties of country data 

Statement A may be rewritten in a cleaner shorter more concise form in which the variable binding code is in the form of a structured literal using enclosed expression syntax to bind variables. For example using XML literals Statement A may be rewritten as follows 

In another example the following switch statement may match an Email message. The first arm succeeds when the To element matches Erik while the second branch succeeds when the From child matches Brian 

In the first branch the variables From Subject and Body are in scope and are bound to the content of the respective elements. Similarly in the second arm the variables To Subject and Body are in scope. The third branch matches a element and binds its content to the variable Text.

The implementation of Statement C may be complex since each arm may be translated into code that checks whether the actual shape of the msg variable matches the pattern and then bind the respective variables to the correct child elements. The approximate translation of Statement C may be as follows 

The actual translation can be optimized to avoid repeated checking of overlapping shapes by factoring out common checks and partially binding variables along the way. As further discussed below example Statements C and D also suggest several possible extensions of a pattern matching construct using structured literals such as XML literals object literals type literals and the like.

The pattern matching construct may use a wildcard pattern which may enable the construct to match a pattern without necessarily binding a variable to the value if there is a match. For example the pattern matching construct may match on any Email message whose To child is Erik and bind the content of the message body but ignore the rest of the message. In one embodiment the wildcard pattern may be in the form for zero or more children.

The pattern matching construct may also match use a variable that is associated with a nested pattern thereby enabling the construct to match on a substructure yet bind the variable to the entire structure. For example as illustrated in the example statement below the construct may use an as pattern of the form 

The pattern matching construct may not be limited to shallow patterns i.e. patterns that matches direct children of the parent nodes of the pattern but rather may include a descendant pattern which may match to a descendant element that is nested arbitrarily deep in the structure or tree. For example the following statement binds the From variable to the content of the From node having a value that matches the pattern 

The From node may be arbitrarily deep in the email message. For example the email message may have the following structured value 

Statement F may incorporate a descendant pattern to facilitate matching without having to mention all intermediate nodes on the path. The descendant pattern may be in the form . Thus in one embodiment Statement F may be rewritten as follows 

The pattern matching construct may have other extensions either in addition to or lieu of those discussed above. More specifically the pattern matching construct may use guard expressions or guards which may be Boolean expressions in the arms of switch statements that enable additional tests to be performed once a match is found. If the guard evaluates to true a statement block within the respective arm of the switch statement may be executed. If the guard evaluates to false pattern matching may resume at the next arm of the enclosing switch statement. For example a guard may be used to check that From and To are not bound to the same value 

The pattern matching construct may use irrefutable patterns which may facilitate pattern matching in positions where variable declarations are allowed. In other words irrefutable patterns may enable the construct to bind variables without having to switch on the value of the pattern. For example given the following function 

Thus the declaration in Statement L may be translated into explicit access without conditional logic.

The pattern matching construct may also utilize type inferences with any defined variables thereby facilitating clear concise programs by eliminating the need to define the type for each variable defined in the pattern. For example if the pattern has a structured value x y a compiler may infer the types of variables x and y based on their position in the pattern.

It will be appreciated that foregoing examples are meant to illustrate various embodiments of the above extensions. Thus alternate syntax may be used to implement the same or similar mechanisms while remaining consistent with an embodiment.

In addition to XML literals the pattern matching construct may use other forms of literals such as object literals type literals and code literals. Pattern matching on object literals is similar to pattern matching on XML literals except that object literals may not support descendant patterns since there is no corresponding direct accessor and that the order in which members appear in object literals is irrelevant.

In the following example the first arm binds the Name and Street of customers in Seattle while the second arm matches any customer whose Name starts with A or B 

The example below illustrates a statement incorporating code literals. The statement uses . . . code literal . . . for quote and . . . embedded expression . . . for unquote 

As shown in at the first pattern may be compared to a value contained in an incoming data stream. At it may be determined whether the first pattern matches the value in the incoming data stream. If there is a pattern match the process may proceed to . If the first pattern does not match the value the process may proceed to . At the second pattern may be compared to the value. At it may be determined whether the second pattern matches the value. If there is a pattern match the process may proceed to . If the second pattern does not match the incoming data pattern the process may proceed to where another pattern i.e. a third pattern may be compared to the value. This process may be repeated until a pattern match is found or until there are no remaining patterns to check. It will be appreciated that the defined patterns may have structured and or non structured values.

At any variable that is defined in the first or second patterns may be bound to the value contained in the incoming data stream. At a type of the variable may be inferred based on the position of the variable in the first or second patterns. For example if the value represents an integer such as a primitive type may be inferred. At the guard expression may be evaluated. At it may be determined whether the guard expression evaluates to true. If the guard expression evaluates to false the process may return to or depending upon whether the second pattern was already checked. If the guard expression evaluates to true the process may proceed to . At the statement block may be executed.

It will be appreciated that the number and or sequence of steps described above may be varied while remaining consistent with an embodiment. For example in one embodiment the type of the variable may be inferred at before the variable is bound to the value at . In another embodiment the first or second pattern may not contain a variable and therefore steps and may be omitted. In yet another embodiment a guard expression may not be defined. Thus steps and may be omitted. Accordingly the inventors have contemplated that the claimed subject matter might be embodied in other ways to include different steps and or combinations of steps.

Although not required the invention can be implemented via an application programming interface API for use by a developer or tester and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers e.g. client workstations servers or other devices . Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. An embodiment of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an example system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology compact disc read only memory CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as ROM and RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data . RAM may contain other data and or program modules.

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the example operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

One of ordinary skill in the art can appreciate that a computer or other client devices can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. An embodiment of the present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

