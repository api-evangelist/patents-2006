---

title: Smartcard method and computer system
abstract: A method and computer system for determining the compatibility, for application to a smartcard, of smartcard personalization profiles, the respective smartcard personalization profiles describing respective file trees on the smartcard that are required by respective applications. The method involves determining if the sets of paths of the file trees described by the respective smartcard personalization profiles are disjoint.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07677460&OS=07677460&RS=07677460
owner: Hewlett-Packard Development Company, L.P.
number: 07677460
owner_city: Houston
owner_country: US
publication_date: 20060320
---
The present invention relates to the field of computer systems and more particularly without limitation to the field of smartcards.

This application claims priority to copending Europe utility application entitled A Smartcard Method And Computer System having serial no. EP 05300199.6 filed Mar. 182005 which is entirely incorporated herein by reference.

A smartcard is a typically credit card sized plastic case with an embedded microprocessor chip that offers a variety of services varying from simple secure data storage to sophisticated cryptographic services. Smartcards are becoming increasingly used for purposes of authentication and authorization of the person carrying the card storing information of a personalized nature and storing values.

The smartcard life cycle always starts with a personalization. Personalization of a smartcard is the process of creating and initializing smartcard objects such as directories files passwords and cryptographic keys on the smartcard for future use by one or more applications. Passwords by convention are often of numerical form known as personal identification numbers. Files include data files of arbitrary format as well as files of standardized format such as password files which hold one or several passwords or cryptographic key files which hold one or more cryptographic keys. Personalization is usually performed by the manufacturer or card issuing authority before shipping the smartcard to the end user. The personalization of a smartcard can be formally described by a personalization profile which defines the required smartcard objects and attributes.

Using a single smartcard for multiple applications is desirable to the end user who can perform multiple functions without having to carry multiple smartcards. It is also economical because it helps to prevent waste of smartcards. Further benefits arise when multiple applications can share information on the smartcard such as the same password the same cryptographic key or the user s bank account information.

However despite the benefits use of a single smartcard for multiple applications is rare today especially for applications supplied by multiple parties. Different applications that are not carefully coordinated may require mutually incompatible personalization profiles. Trying to apply a personalization profile for an application to a smartcard that has already been personalized for another application carries the risk of failure and loss of the smartcard if the personalization profiles are incompatible.

Prior efforts have been made to facilitate the use of multiple applications with a smartcard. Smartcard manufacturers today usually provide pre personalized smartcards and a smartcard access layer which hard codes the smartcard structure expected by a pre defined application interface. Multiple applications can access the same smartcard within the confines of a pre defined interface and smartcard structure.

The Public Key Cryptography Standard 15 describes a standard for the format of cryptographic credentials stored on cryptographic tokens of which smartcards are a special case. The standard specifies a limited set of smartcard objects and hard codes the names of the objects which need to be used by applications compatible with the standard.

For smartcards comprising a Java virtual machine support for loading multiple Java applications on the card is available. However the support applies to Java applications or applets running on the card and not to the smartcard objects such as directories password files or cryptographic keys.

In accordance with the present invention there is provided a method for determining the compatibility of first and second personalization profiles of a smartcard for respective first and second applications requiring first and second file trees to be installed on the smartcard for execution of the first and second applications by a computer that is coupled to the smartcard. The first and second file trees have respective first and second sets of paths used by the first and second applications to locate smartcard files on the smartcard. The first and second personalization profiles are preferably provided as files e.g. of Extensible Markup Language format that can be downloaded to the computer system running the applications from a database or web server or be installed as part of the application s installation package or be stored on the smartcard itself given there is enough memory on the smartcard. The method comprises determining if the first and second sets of paths are disjoint and returning a signal indicative of the compatibility if the first and second sets of paths are disjoint. Personalization profiles found to be compatible in this way can be applied to the same smartcard in any order.

The present invention enables personalizing the smartcard for the needs of different applications by applying personalization profiles either at the same time or incrementally at different times when the need appears and determining in advance that the personalizing will not fail due to an error caused by an incompatibility of the requirements of the different applications. Preferably the state of the smartcard is also examined determining that the personalization will not fail because of insufficiently available memory on the smartcard.

The first and second applications access information on the smartcard in the form of smartcard objects defined by the respective first and second personalization profiles. The smartcard objects may include data files of an application specific format stored on the smartcard but also passwords or cryptographic keys of which several can be contained in files of a standardized format. The first and second personalization profiles may further define respective mappings between logical names for the smartcard objects that are used by the respective first and second applications when accessing the objects and smartcard specific properties of the same objects that allow creating or accessing the objects on the smartcard. The mappings provided by the respective personalization profiles add a level of indirection allowing modifying the smartcard structure without modifying the application using it.

The present invention is particularly advantageous as it enables use of the same smartcard by different applications. For example the invention enables an end user or a developer or an administrator of smartcard applications to reuse existing smartcards for upgrading to new versions of an application or for applying a personalization profile for a new application to a smartcard that is already personalized for other applications. A new personalization profile can be applied to a smartcard independently of the computer where the smartcard was previously personalized. For example the present invention enables providing a single fidelity card to consumers that can be used for different shops chains hotels or transportation at the choice of the consumer the fidelity card would be a smartcard that is incrementally personalized at different shops.

The end user can personalize the smartcard herself or himself for applications he or she decides to add to the card after the card has been issued. One example for an application would be using the smartcard as a portable secure storage for certificates or objects containing digital rights definitions. The end user could dynamically download the certificates or digital rights objects directly at the point of usage of the smartcard for example a public terminal or a home computer. To store the objects just downloaded the smartcard would be personalized at the point of usage immediately when the objects are received.

The developer or administrator of smartcard applications can test smartcard personalization profiles prior to effectively modifying the smartcard structure avoiding smartcard waste. For example on the basis of the present invention smartcard application developers could be given a complete development environment allowing them to personalize smartcards without modifying applications accessing them to visualize graphically the personalization profiles their compatibility and the current card structure to change the definitions of the personalization profiles and visualize immediately the compatibility of the personalization profiles being created to check the compatibility of different personalization profiles as well as the compatibility of a given application s personalization profile with the smartcard structure required for previous versions of the same application to check if personalization profiles can be merged so that all objects defined in all personalization profiles can share the same security objects such as passwords or cryptographic keys or to debug and trace the smartcard personalization process.

In accordance with an embodiment each element of the first and second sets of paths comprises file attributes and one of the paths of the first set of paths is also an element of the second set of paths. For the one of the paths it is determined if its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree. A signal indicative of the compatibility is returned if the file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree. Personalization profiles found to be compatible in this way can be applied to the same smartcard if the first personalization profile is applied to the smartcard before the second personalization profile.

The embodiment is particularly advantageous as it enables sharing between different applications of a file stored on the smartcard. For example different applications can share a password file accessing the same passwords stored in the file or a cryptographic key file accessing the same cryptographic keys in the file or a data file of arbitrary format.

In accordance with an embodiment the file attributes which are considered when determining the compatibility of the first and second personalization profiles comprise a file existence flag indicating whether the one of the paths must exist prior to applying the respective first or second personalization profile a file size a file type and file access conditions. For the file existence flag of the one of the paths it is determined if it is either identical in the first and second file trees or the file existence flag of the one of the paths in the second file tree indicates that the one of the paths must exist prior to applying the second personalization profile while in the first file tree the file existence flag indicates that the same path may be created during the applying of the first personalization profile. For the file size of the one of the paths it is determined if it is identical in the first and second file trees or greater in the first than in the second file tree. For the file type of the one of the paths it is determined if it is identical in the first and second file trees. For the file access conditions of the one of the paths it is determined if they are identical in the first and second file trees.

In accordance with an embodiment the file type of the one of the paths is a password file in both the first and second file trees. The password file comprises a list of passwords each password comprising password attributes. Typically passwords including numerical passwords known as personal identification numbers are stored on smartcards in files of this type. The determining for the one of the paths if its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree further comprises determining if the number of passwords of the password file is identical in the first and second file trees and determining for each of the passwords if its password attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree.

In accordance with an embodiment the password attributes which are considered when determining the compatibility of the first and second personalization profiles comprise a password value a maximum number of retries before the password is blocked a further password value for unblocking the password once it has been blocked or an indication that no such further password value for unblocking exists and a mode of presentation of the password. The password value can be a literal value or the specification that a value has to be provided at the time of applying the respective personalization profile. For the password value it is determined if it is identical in the first and second file trees. For the maximum number of retries it is determined if it is equal in the first and second file trees or greater in the first than in the second file tree. For the further password value for unblocking it is determined if either no password value for unblocking exists in the second file tree or the further password value for unblocking is identical in the first and second file trees.

In accordance with an embodiment the file type of the one of the paths is a cryptographic key file in both the first and second file trees. The cryptographic key file comprises a list of cryptographic keys each cryptographic key comprising a key length. The determining for the one of the paths if its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree further comprises determining if the number of cryptographic keys is identical in the first and second file trees and determining for each of the cryptographic keys if its key length is equal in the first and second file trees or shorter in the first than in the second file tree. Preferably each cryptographic key further comprises either a literal key value or the specification that a key value has to be provided at the time of applying the respective personalization profile. The determining for the one of the paths if its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree then preferably further comprises determining for each of the cryptographic keys if its key length is equal in the first and second file trees or the key value in the first file tree has to be provided at the time of applying the first personalization profile or the key value in the second file tree is given as a literal key value.

The method can be extended to encompass further kinds of smartcard objects or even generalized to determining the compatibility of objects which are not stored on a smartcard. For example it can be used to determine the compatibility of access control policies for different applications in a corporate information technology environment. As an illustration a first access control policy for a first application shall be assumed to require authentication of a user through a password with a minimum length of 8 characters a maximum of 3 retries before blocking with unblocking permitted an expiry period of 10 weeks and an expiry date of Dec. 31 2005 or earlier. A second application shall be assumed to impose a second access control policy that is identical to the first with the exception that the minimum length of the password shall be 4 characters. The method can then be used to determine that the second access control policy is less restrictive than the first and grant a user already authenticated for the first application access for the second one without further authentication. On the contrary a user authenticated for the second application needs to re authenticate with a different password for the first application.

In accordance with an embodiment the intersection of the first and second sets of paths comprises more than one common element. The method further comprises repeating with respect to each of the common elements the determining for the one of the paths if its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree. The returning a signal indicative of compatibility if the file attributes for the one of the paths are identical in the first and second file trees or less restrictive in the first than in the second file tree is adapted to return the signal if the file attributes for each of the common elements are identical in the first and second file trees or less restrictive in the first than in the second file tree.

In accordance with an embodiment a state machine is provided. During each cycle of a loop iterating over the set of common elements the state machine is advanced according to the result of the determining for the one of the paths if its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree. The state that the state machine is found in after repeating with respect to each of the common elements determines whether the signal indicative of the compatibility of the first and second personalization profiles is returned. Preferably the repeating is terminated as soon as the state machine has reached a state signifying incompatibility otherwise after reaching the end of the set of common elements.

Preferably during each cycle of the loop it is determined for the respective one of the paths not only whether its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree but also whether the same holds with the first and second file trees reversed in other words whether the file attributes of the one of the paths are identical in the second and first file trees or less restrictive in the second than in the first file tree. If both hold true the file attributes of the one of the paths are defined as equivalent in the first and second file trees. If only the former holds true the file attributes of the one of the paths are defined as less restrictive in the first than in the second file tree. If only the latter holds true the file attributes of the one of the paths are defined as more restrictive in the first than in the second file tree. If neither the former nor the latter hold true the file attributes are defined as incompatible in the first and second file trees.

Unless for one of the common elements the file attributes are incompatible in the first and second file trees or more restrictive in the first than in the second file tree the first and second personalization profiles are determined to be compatible in the order of the first personalization profile being applied to the smartcard before the second personalization profile. Unless for one of the common elements the file attributes are incompatible in the first and second file trees or less restrictive in the first than in the second file tree the first and second personalization profiles are determined to be compatible in the order of the first personalization profile being applied to the smartcard after the second personalization profile.

In accordance with an embodiment the first personalization profile is already applied to the smartcard and information on the current state of the smartcard is retrieved from the smartcard. The embodiment relies on having access to a record of the second personalization profile comprising a description of all objects and relevant object attributes that the second application requires being present on the smartcard preferably in the form of a file of Extended Markup Language format. Access to a corresponding record of the first personalization profile is unnecessary because the information retrieved from the smartcard substitutes for the information comprised by the first personalization profile. In effect the embodiment serves to determine the compatibility of a given personalization profile here called the second personalization profile with the current state of the smartcard. In other words by determining whether the first and second personalization profiles are compatible in the order of the first personalization profile being applied to the smartcard before the second profile it is determined whether it the second personalization profile can be applied to the smartcard in its current state.

No assumption for the history of the current state of the smartcard is made the smartcard could be empty i.e. not containing any objects for use by a specific application or have previously been personalized for one or more unspecified applications. There is no need to access any records of personalization profiles that may have been applied earlier. Independent of being personalized for a specific application the smartcard could also contain objects created by default by the manufacturer of the smartcard.

Preferably to retrieve the information on the current state of the smartcard from the smartcard for each path being an element of the second set of paths an attempt is made to select the path on the smartcard. If the attempt is successful it is known that the path is an element of both the first and second sets of paths where the first set of paths is understood to mean the set of all paths currently existing on the smartcard. For each smartcard object listed in the record of the second personalization profile the system will try to select it on the smartcard and in the case the select is successful it will verify that that object attributes are compatible with those on the smartcard.

In accordance with an embodiment a set of personalization profiles of the smartcard for a set of respective applications is provided. The method is adapted to comprise repeating the method as defined for every ordered subset of two elements from the set of personalization profiles determining for each ordered subset whether the elements of the ordered subset are compatible to be applied to the smartcard given that the second element is applied after the first. An attempt is made to find a permutation on the set of personalization profiles so that every element of the permutation is compatible with all personalization profiles preceding it. If such a permutation is found a signal indicative of the compatibility of the set of personalization profiles is returned. Here compatibility means that there exists at least one permutation defining an order in which the set of personalization profiles can be applied to the smartcard.

The method can be put into use for configuring new personal digital assistants notebooks and other computer systems with a set of pre selected personalization profiles the compatibility of which has been determined. The user may choose to install one or more of the applications associated with these personalization profiles on the computer system. He or she can then personalize a single smartcard for the applications because the pre selected personalization profiles for the applications are compatible without the user needing to modify them. A configuration in this way is least difficult to achieve if applications do not share any objects and if personalization profiles refer to logical names instead of absolute paths on the card.

In accordance with an embodiment the personalization profiles determined to be compatible are applied to the smartcard in the order they were found compatible. Because the compatibility has been verified beforehand the applying of the personalization profiles in the order they were found compatible is guaranteed to succeed except for exceptional events such as card removal cable disconnection card reader failure or card reader driver failure. Preferably an equally possible failure because of insufficient memory available on the smartcard is ruled out by verifying before applying the personalization profiles that the necessary memory is available on the smartcard. Preferably the system furthermore verifies before applying the personalization profiles that all necessary data such as passwords needed to access or create objects on the smartcard are available.

Preferably the computer system provides an application programming interface comprising a function canpersonalize . . . that verifies whether a given set of personalization profiles can be applied to the smartcard. The function canpersonalize . . . takes as parameters a list of records of personalization profiles and a list of personalization parameters with associated values such as passwords needed to access or create objects on the smartcard that have to be supplied at the time of applying the personalization profiles. The function determines whether an order exists in which the personalization profiles supplied as named in the list of records of personalization profiles can be applied to the smartcard and returns a true value if the personalization profiles can be applied.

Preferably the application programming interface comprises a further function applypersonalizations . . . that requires the same parameters as the function canPersonalize . . . and performs the same verification. If an order exists in which the personalization profiles supplied as named in the list of records of personalization profiles can be applied to the smartcard the function applypersonalizations . . . applies to the smartcard the personalization profiles in the order found compatible using the values of the personalization parameters as supplied in the list of personalization parameters with associated values.

In operation the processor executes program instructions for determining if the first and second sets of paths are disjoint i.e. have no elements in common. From the sets being disjoint follows that the first and second applications can share the smartcard without interfering with each other because they do not require a file to be stored in a common location on the smartcard. If the sets have been determined to be disjoint the processor furthermore executes a signaller function which returns a signal indicative of the compatibility of the first and second personalization profiles meaning that both personalization profiles can be applied to the smartcard in any order.

Preferably if the first personalization profile has already been applied to the smartcard the processor obtains information on the second file tree required by the second application from a file e.g. of Extensible Markup Language format wherein the second personalization profile is recorded. For obtaining corresponding information on the first file tree the processor does not need to make use of a corresponding file that may or may not be available in which the first personalization profile is recorded. Instead the processor retrieves information on the first file tree from the smartcard by examining the stored file tree .

To obtain the information on the first file tree the processor executes program instructions for determining the intersection of the set of paths of the stored file tree as it exists on the smartcard with the set of paths of the second file tree as required by the second application and described in the file in which the second personalization profile is recorded. Using a path iterator the processor iterates over the second set of paths attempting for each element of the second set of paths to select the path on the smartcard. If the attempt is successful the processor has confirmed that the path exists in the stored file tree on the smartcard. If none of the attempts is successful the processor has determined that the first and second sets of paths are disjoint meaning that the second personalization profile can be applied to the smartcard in its current state.

The processor preferably comprises further program instructions for handling the case that one of the paths of the first set of paths is also an element of the second set of paths. Executing the program instructions the processor determines for the one of the paths if its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree. If this is determined to be true the signaller returns a signal indicative of the compatibility meaning that the first and second personalization profiles can be applied to the smartcard if the first personalization profile precedes the second personalization profile.

The processor preferably comprises a path iterator that is used for handling the case that more than one of the paths of the first set of paths is also an element of the second set of paths i.e. the first and second sets of paths have more than one common element. The path iterator repeats with respect to each of the paths common to the first and second sets of paths the determining for the one of the paths if its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree. The signaller for returning a signal indicative of the compatibility is adapted to return the signal if the file attributes for each of the common elements are identical in the first and second file trees or less restrictive in the first than in the second file tree. Preferably the path iterator advances a state machine according to the result of the determining for each of the common elements if its file attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree. The final state of the state machine then determines the compatibility of the first and second personalization profiles and the order in which if applied to the card they are compatible.

The processor preferably further comprises a personalization profile iterator and a permutator enabling determining whether a given set of personalization profiles is compatible to be applied together to the smartcard . In operation for every ordered subset of two elements from the set of personalization profiles the personalization profile iterator repeats determining the compatibility of applying to the smartcard the two personalization profiles being the elements of the subset. Using the resulting information on the compatibility of every ordered subset of two elements the permutator attempts to construct a permutation on the entire set of personalization profiles in which every personalization profile being an element of the permutation is compatible to be applied to the smartcard after any of the personalization profiles that precede it as elements in the permutation. If the permutator can construct the permutation the signaller returns a signal indicating compatibility in the sense that the set of personalization profiles can be ordered in a way allowing all of its elements to be applied to the smartcard.

Preferably the processor makes available an application programming interface comprising functions that can be called from any applications that a software developer may wish to create. The application programming interface preferably comprises a function canPersonalize . . . and a function applyPersonalizations . . . . Both functions expect as parameters a list of records of personalization profiles and a list of additional personalization parameters with associated values. Both functions attempt to find an order in which the personalization profiles specified in the list of records of personalization profiles can be applied to the smartcard considering also the already applied personalization profile implied by the stored file tree on the smartcard. If an order of applying is found in which the personalization profiles are compatible with each other and the stored file tree on the smartcard the function canPersonalize . . . returns a true value whereas the function applyPersonalizations . . . applies the personalization profiles to the smartcard in the order found compatible and then returns a true value.

For both examples shown and preferably for any type of file that the first and second personalization profiles may require to be stored on the smartcard the file attributes examined comprise a file existence flag which indicates whether the file must exist prior to applying the respective first or second personalization profile. When examining the file existence flag in the first and second personalization profiles the processor determines if either in the first and second file trees the file existence flag is identical or in the second file tree the file existence flag indicates that the file must exist prior to applying the second personalization profile while in the first file tree the file existence flag indicates that the file can be created during the applying of the first personalization profile. In the case of the first personalization profile being already applied to the smartcard this condition is implicitly fulfilled. The file attributes further comprise the file size the processor determining if the file size of the file is identical in the first and second file trees or greater in the first than in the second file tree. The file attributes further comprise a file type the processor determining if the file type is identical in the first and second file trees. The file attributes further comprise file access conditions the processor determining if the file access conditions are identical in the first and second file trees.

If the file type in both first and second file trees is a password file comprising a list of passwords or in both first and second file trees is a cryptographic key file comprising a list of cryptographic keys preferably further attributes are considered. For a password file comprising a list of passwords the processor determines if the number of passwords of the password file is identical in the first and second file trees. The processor further considers password attributes determining for each of the passwords if its password attributes are identical in the first and second file trees or less restrictive in the first than in the second file tree.

Preferably the password attributes considered comprise a password value the processor determining if the password value is identical in the first and second file trees. The password attributes further comprise the maximum number of retries before blocking the password the processor determining if the maximum number of retries before blocking is equal in the first and second file trees or greater in the first than in the second file tree. The password attributes further comprise a further password value for unblocking or an indication that no further password value for unblocking exists the processor determining if no further password value for unblocking exists in the second file tree or the further password value for unblocking is identical in the first and second file trees. Password attributes further comprise a mode of password presentation the processor determining if the mode of password presentation is identical in the first and second file trees.

For a cryptographic key file comprising a list of cryptographic keys the processor further determines if the number of the cryptographic keys is identical in the first and second file trees and if for each of the cryptographic keys its key length is equal in the first and second file trees or shorter in the first than in the second file tree. Preferably the processor further determines if for each of the cryptographic keys if the key length is equal in the first and second file trees or the key value in the first file tree has to be provided at the time of applying the first personalization profile or the key value in the second file tree is given as a literal key value.

Preferably in the case of the smartcard being partially damaged or any other exceptional event implying that the compatibility verification cannot proceed the system advances back to the start state to signify that the compatibility of the first and second personalization profiles is unknown and the state machine aborts its execution.

Preferably the iteration is aborted as soon as the state signifying incompatibility of the personalization profiles is reached. At the end of the iterating over the common elements the state machine is either in a state signifying incompatibility of the first and second personalization profiles in a state signifying compatibility provided that the first personalization profile is applied to the smartcard before the second personalization profile or in a state signifying compatibility provided that the first personalization profile is applied to the smartcard after the second personalization profile or in a state signifying compatibility of the first and second personalization profiles to be applied to the smartcard in any order or in the start state signifying that an exceptional event has occurred due to which the compatibility of the first and second personalization profiles could not be established.

