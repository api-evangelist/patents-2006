---

title: Script language for storage management operations
abstract: Described are techniques for configuring a target data store. Code written in a scripting language is provided. The scripting language includes environment blocks that retrieve data used in a subsequent block and execution blocks that execute an operation to configure said target data store. The retrieved data includes data from said target data store. The code is processed and includes retrieving data in accordance with environment blocks included in the code, and updating said target data store in accordance with execution blocks included in said code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08635594&OS=08635594&RS=08635594
owner: EMC Corporation
number: 08635594
owner_city: Hopkinton
owner_country: US
publication_date: 20060330
---
This application generally relates to configuration of a data storage system and more particularly to languages and techniques used in connection with configuration of a data storage system.

Computer systems may include different resources used by one or more host processors. Resources and host processors in a computer system may be interconnected by one or more communication connections. These resources may include for example data storage devices such as those included in the data storage systems manufactured by EMC Corporation. These data storage systems may be coupled to one or more host processors and provide storage services to each host processor. Multiple data storage systems from one or more different vendors may be connected and may provide common data storage for one or more host processors in a computer system.

A host processor may perform a variety of data processing tasks and operations using the data storage system. For example a host processor may perform basic system I O operations in connection with data requests such as data read and write operations.

Host processor systems also referred to as server systems may store and retrieve data using a storage device containing a plurality of host interface units disk drives and disk interface units. The host systems access the storage device through a plurality of channels provided therewith. Host systems provide data and access control information through the channels to the storage device and the storage device provides data to the host systems also through the channels. The host systems do not address the disk drives of the storage device directly but rather access what appears to the host systems as a plurality of logical disk units. The logical disk units may or may not correspond to the actual disk drives. Allowing multiple host systems to access the single storage device unit allows the host systems to share data stored therein.

Configuration information may be associated with a data storage system. The configuration information may include information describing the physical and or logical configuration in the data storage system. The logical configuration information may include for example information regarding RAID groupings logically defined devices and the like. There are times when it may be useful to replicate the configuration information from one data storage system such as for example for use in connection with configuring another data storage system. Existing techniques include manually extracting the configuration information for the data storage system from a storage location of the configuration information. Such a process is often cumbersome time consuming and error prone.

In accordance with one aspect of the invention is a method for configuring a target data store comprising providing code written in a scripting language said scripting language including environment blocks that retrieve data used in a subsequent block and execution blocks that execute an operation to configure said target data store said retrieved data including data from said target data store and processing said code wherein said processing includes retrieving data in accordance with environment blocks included in said code and updating said target data store in accordance with execution blocks included in said code. The retrieved data may include data from an input file specifying how to configure said target data store. The code may include an environment block resulting in execution of a routine which extracts data from said target data store and returns said data to an execution environment. The data in said execution environment may be referenced as a parameter in connection with performing an update operation to said target data store. Each execution block may correspond to a single programming interface causing execution of an update operation to said target data store using retrieved data. The environment block that results in execution of a routine which extracts data from said target data store may include a filter statement said filter statement filtering data returned to said execution environment in accordance with filter criteria. The filter statement may search for a particular property from retrieved data instances included in said execution environment. The code may be included in a first script and said code references a second script written in said scripting language. The processing may include caching at least a portion of said first script in a memory for use when said first script is referenced by another script. The input file may include one or more tag elements each having a context said code being included in a first script and wherein said first script is executed for each of said one or more tag elements using said context associated with said each tag element. The input file may have a structured format in accordance with a defined hierarchy and wherein said context associated with each of said tag elements may include a hierarchical context in accordance with placement of said each tag in said input file and said defined hierarchy. The scripting language may include tag elements included in a file in a structured hierarchical format.

In accordance with another aspect of the invention is a method of performing rollback processing for a target data store comprising receiving a transaction log and a rollback context file said rollback context file being a configuration schema instance with a unique identifier assigned to each element in said rollback context file said transaction log including a log of successful operations performed on said target data store said transaction log including records referencing unique identifiers and associated successful operations parsing a rollback master rule file specifying an order for processing rules wherein said rollback master rule file defines a context for each rule included therein determining if rollback processing or other processing is performed for each rule in said rollback master rule file and performing rollback processing for each rule having one or more matching occurrences in said transaction log file said rollback processing including determining if a complementary operation for said each rule was successfully performed for each matching occurrence. Performing rollback processing for said each rule for each matching occurrence in said transaction log may include executing said each rule for said each matching occurrence only if said complementary operation for said each rule was successfully performed for said matching occurrence as indicated in said transaction log. The rollback context file may describe configuration information included in said target data store and said rollback processing is performed to rollback said target data store to a previous configuration information state. The rollback context file and said transaction log file may be generated by a duplication engine in connection with duplication processing to store information as described by said configuration schema instance in said target data store. The method of performing rollback processing may be performed by the duplication engine executing in a rollback processing mode and said duplication processing is performed by the duplication engine executing in a duplication processing mode.

In accordance with another aspect of the invention is a computer readable medium having code stored thereon for performing rollback processing for a target data store the computer readable medium comprising code that receives a transaction log and a rollback context file said rollback context file being a configuration schema instance with a unique identifier assigned to each element in said rollback context file said transaction log including a log of successful operations performed on said target data store said transaction log including records referencing unique identifiers and associated successful operations parses a rollback master rule file specifying an order for processing rules wherein said rollback master rule file defines a context for each rule included therein determines if rollback processing or other processing is performed for each rule in said rollback master rule file and performs rollback processing for each rule having one or more matching occurrences in said transaction log file said rollback processing including determining if a complementary operation for said each rule was successfully performed for each matching occurrence. Performing rollback processing for said each rule for each matching occurrence in said transaction log may include executing said each rule for said each matching occurrence only if said complementary operation for said each rule was successfully performed for said matching occurrence as indicated in said transaction log. The rollback context file may describe configuration information included in said target data store and said rollback processing is performed to rollback said target data store to a previous configuration information state.

Referring now to shown is an example of an embodiment of a computer system that may be used in connection with performing the techniques described herein. The computer system includes one or more data storage systems connected to host systems through communication medium . The system also includes a management system connected to one or more data storage systems through communication medium . In this embodiment of the computer system the management system and the N servers or hosts may access the data storage systems for example in performing input output I O operations data requests and other operations. The communication medium may be any one or more of a variety of networks or other type of communication connections as known to those skilled in the art. Each of the communication mediums and may be a network connection bus and or other type of data link such as a hardwire or other connections known in the art. For example the communication medium may be the Internet an intranet network or other wireless or other hardwired connection s by which the host systems may access and communicate with the data storage systems and may also communicate with other components not shown that may be included in the computer system . In one embodiment the communication medium may be a LAN connection and the communication medium may be an iSCSCI or fibre channel connection.

Each of the host systems and the data storage systems included in the computer system may be connected to the communication medium by any one of a variety of connections as may be provided and supported in accordance with the type of communication medium . Similarly the management system may be connected to the communication medium by any one of variety of connections in accordance with the type of communication medium . The processors included in the host computer systems and management system may be any one of a variety of proprietary or commercially available single or multi processor system such as an Intel based processor or other type of commercially available processor able to support traffic in accordance with each particular embodiment and application.

It should be noted that the particular examples of the hardware and software that may be included in the data storage systems are described herein in more detail and may vary with each particular embodiment. Each of the host computers the management system and data storage systems may all be located at the same physical site or alternatively may also be located in different physical locations. In connection with communication mediums and a variety of different communication protocols may be used such as SCSI Fibre Channel iSCSI and the like. Some or all of the connections by which the hosts management system and data storage system may be connected to their respective communication medium may pass through other communication devices such as a Connectrix or other switching equipment that may exist such as a phone line a repeater a multiplexer or even a satellite. In one embodiment the hosts may communicate with the data storage systems over an iSCSCI or fibre channel connection and the management system may communicate with the data storage systems over a separate network connection using TCP IP. It should be noted that although illustrates communications between the hosts and data storage systems being over a first connection and communications between the management system and the data storage systems being over a second different connection an embodiment may also use the same connection. The particular type and number of connections may vary in accordance with particulars of each embodiment.

Each of the host computer systems may perform different types of data operations in accordance with different types of tasks. In the embodiment of any one of the host computers may issue a data request to the data storage systems to perform a data operation. For example an application executing on one of the host computers may perform a read or write operation resulting in one or more data requests to the data storage systems .

The management system may be used in connection with management of the data storage systems . The management system may include hardware and or software components. The management system may include one or more computer processors connected to one or more I O devices such as for example a display or other output device and an input device such as for example a keyboard mouse and the like. A data storage system manager may for example view information about a current storage volume configuration on a display device of the management system . The manager may also configure a data storage system for example by using management software to define a logical grouping of logically defined devices referred to elsewhere herein as a storage group SG and restrict access to the logical group.

An embodiment of the data storage systems may include one or more data storage systems. Each of the data storage systems may include one or more data storage devices such as disks. One or more data storage systems may be manufactured by one or more different vendors. Each of the data storage systems included in may be inter connected not shown . Additionally the data storage systems may also be connected to the host systems through any one or more communication connections that may vary with each particular embodiment and device in accordance with the different protocols used in a particular embodiment. The type of communication connection used may vary with certain system parameters and requirements such as those related to bandwidth and throughput required in accordance with a rate of I O requests as may be issued by the host computer systems for example to the data storage systems .

It should be noted that each of the data storage systems may operate stand alone or may also included as part of a storage area network SAN that includes for example other components such as other data storage systems.

Each of the data storage systems of element may include a plurality of disk devices or volumes. The particular data storage systems and examples as described herein for purposes of illustration should not be construed as a limitation. Other types of commercially available data storage systems as well as processors and hardware controlling access to these particular devices may also be included in an embodiment.

Servers or host systems such as provide data and access control information through channels to the storage systems and the storage systems may also provide data to the host systems also through the channels. The host systems do not address the disk drives of the storage systems directly but rather access to data may be provided to one or more host systems from what the host systems view as a plurality of logical devices or logical volumes. The logical volumes may or may not correspond to the actual disk drives. For example one or more logical volumes may reside on a single physical disk drive. Data in a single storage system may be accessed by multiple hosts allowing the hosts to share the data residing therein. A LUN logical unit number may be used to refer to one of the foregoing logically defined devices or volumes.

Referring now to shown is an example of components that may be used in connection with techniques described herein. The example may represent components illustrated in connection of configured in a storage area network SAN . Included in the example are data storage systems and a switch and hosts or servers and . The switch may be used in connection with facilitating communications between each of the hosts and and the data storage systems and . Communications between a host and the data storage system may be defined in terms of a path. Host communicates with the data storage system over a path designated as . Path is formed by the starting point the HBA or host bus adapter and the ending point port A of the receiving data storage system . Host communicates with the data storage system over two paths designated as and . Path is formed by the starting point the HBA and the ending point port d of the receiving data storage system . Path is formed by the starting point the HBA and the ending point port b of the receiving data storage system . It should be noted that different HBAs from the same or different hosts may also communicate with the data storage system through a same port of the data storage system although each path and use a different port. An embodiment may represent a path using the WWN world wide name of a host s HBA and the WWN of a data storage system port receiving the request. As known to those skilled in the art a WWN is a unique number assigned by a recognized naming authority that identifies a connection or a set of connections to the network. As also known to those skilled in the art various networking technologies that may be used in an embodiment make use of WWNs. In connection with the techniques described herein other embodiments may use other ways in defining a path that may vary with the connectivity in each embodiment.

Each HBA may include one or more ports although in the example illustrated each HBA has only a single port. As represented with element connections between the hosts using switch may be made with respect to data storage system . Although only two data storage system are illustrated for purposes of simplicity in illustration each of the hosts may have connections to other data storage systems in the SAN. Additionally each host may be connected to the data storage systems using other connections including direct cabling than as illustrated in .

The data storage system is illustrated as including one or more storage devices one or more computer processors an operating system a configuration object database a storage management component one or more libraries other inputs outputs and or components a capture engine and a duplication engine .

An example of an embodiment of the data storage system is the CLARiiON data storage system by EMC Corporation which includes two computer processors as represented by the element although an embodiment may include a different number of processors for use in connection with the techniques described herein.

The one or more storage devices may represent one or more physical devices such as disk drives that may be accessed in logical units e.g. as LUNs as described elsewhere herein. The operating system may be any one of a variety of commercially available proprietary or other operating system capable of execution by the one or more computer processors in accordance with the particulars of the data storage system . In one embodiment the operating system may be the Windows XP operating system by Microsoft Corporation.

The storage management component may be a component included as part of management software for management of the data storage system. The component may manage the configuration object database which includes data structures of configuration information for the data storage system . The configuration information may include data describing a defined configuration such as the different components as well as data regarding the performance and other aspects of these components. As described elsewhere herein in more detail the configuration information may include information regarding physical components logical components and other general configuration information. The physical component information may include information about physical components in the data storage system for example the physical disks fans and the like. The logical component information may include information about the logically defined components such as for example the LUNs defined RAID groupings RGs storage groups of LUNs SGs and the like. Such logical component information may include what storage groups are defined and what LUNs are included in each of the SGs. Additionally performance data regarding for example logical and or physical device usage may be included in the configuration information with the appropriate physical and or logical devices. Other general configuration information may include for example the WWN of the data storage system the serial number of the data storage system and the like.

Configuration information such as the logical device definitions and SGs may be defined by a data storage system manager using the management system . The foregoing configuration information may be received by component and may be used in connection with populating the configuration object database . It should be noted that although a database is used in connection with storing the configuration information it will be appreciated by those skilled in the art that other data stores or data containers may be used.

The other inputs outputs and or components may represent other hardware and or software components that may be included in the data storage system . The element may include software components such as for example other management software for management of the data storage system and the like. The element may also include hardware components such as for example memory other storage areas and the like. The element may also include other inputs and or outputs such as command line inputs configuration options and the like as described herein.

The capture engine may be used in connection with capturing the configuration or a portion thereof of the data storage system as may be represented in the database . Techniques are described in more detail in following paragraphs in which the capture engine may be used to extract specific information from the database . The extracted information may be characterized as the captured information describing the configuration of the data storage system in the form of an XML schema instance. The XML schema instance may be used as an input to a duplication engine of a target data storage system such as duplication engine of data storage system in order to duplicate the configuration of the source data storage system on the target data storage system . The duplication engine may be included in the source data storage system although may not be used in connection with applications in which the system is the source data storage system as described in this particular example. Similarly the capture engine of the target data storage system may not be used in connection with applications in which the system is the target data storage system as described in this particular example.

One or more libraries may be used by the capture engine and or duplication engine in connection with the capture and duplication processing described herein.

The components of data storage system are similar to those as described in connection with the data storage system . It should be noted that the use of the capture engines and duplication engines in connection with the techniques described herein should not be construed as a limitation of these techniques. As described herein the capture and duplication engines may be located and executed on a data storage system. In a different embodiment utilizing the techniques described herein the capture and duplication engines may be stored and executed on a component residing outside the storage system. The capture and duplication engines may use the APIs providing a published interface to access components such as the object database residing on the data storage system. As another example the techniques described herein may be used in connection with a remotely located target data storage system rather than a data storage system that may be included in the same LAN as the source data storage system.

The techniques described herein may be used in connection with capturing and duplicating a source data storage system s configuration on a target data storage system. For example it may be desirable to duplicate one or more aspects of the logical configuration information of a source data storage system on a target data storage system. As the configuration of a data storage system increases in complexity the benefits of the techniques described herein may be more fully appreciated by those skilled in the art.

Techniques using the components illustrated in the example are described in more detail in following paragraphs.

Referring now to shown is an example illustrating data flow between components included in as may be included in a source and target data storage system. The source data storage system may refer to the data storage system about which the configuration information is captured for duplication on a target data storage system. As described in connection with the capture engine may execute on the source data storage system such as and the duplication engine may execute on the target data storage system such as .

In the example the capture engine s inputs include a source configuration object database a layout file and one or more libraries . The layout file describes which elements of the configuration of the source data storage system as included in the configuration object database are to be extracted or captured. The libraries may be used by the capture engine in connection with accessing and extracting information from using routines included in . The capture engine stores the extracted source data storage system s configuration information in the configuration schema instance . In one embodiment the instance may be in accordance with an XML format and an XML defined schema although an embodiment may use other formats and techniques in connection with describing the extracted source data storage system s configuration information. It should also be noted that although the capture engine may be used in connection with capturing a configuration of a source data storage system an embodiment may use other techniques in connection with obtaining a configuration schema instance or other entity describing the source configuration information. The capture engine and its inputs and outputs are described in more detail in following paragraphs.

The duplication engine s inputs may include a master rule file one or more rule files the configuration schema instance one or more libraries and a target configuration object database . The master rule file describes the order in which rules as described in a rule file included in are processed the context for the rule the number of times to execute the rule and also indicates how the particular rule is implemented. A rule may be implemented or coded for example in XML C Java and the like. The master rule file indicates the order in which tags included in the instance are processed. Each tag included in the instance may result in the execution of one or more rules as also specified in the master rule file . The rule files may include commands to retrieve e.g. get and store or update e.g. put configuration information of the target configuration object database as specified in the instance . The duplication engine may invoke one or more routines included in a library of in connection with retrieving and or storing information of component . The duplication engine and its inputs and outputs are described in more detail in following paragraphs.

Although use of library routines are illustrated herein an embodiment may use other techniques in connection with storing and or retrieving configuration information of the databases and or .

In connection with the source and target data storage systems an embodiment may operate under certain criteria or assumptions that may vary with embodiment. For example the criteria may include that the target data storage system include at least those physical components of the source data storage system used in connection with extracted configuration information of the configuration schema instance .

Referring now to shown is an example representation of information included in the configuration object database. The example includes a tree like structure with nodes representing instances of objects included in the database. The lines connecting nodes identified as associations may also be represented using objects. Each association describes a relationship between two node objects. In connection with capture processing as may be performed by an embodiment of the capture operation the configuration information may be extracted from one or more instances related to a core instance represented as the root instance in the example . Any object in the example may be accessed by traversing a relationship chain originating from the root instance in which the relationships may be expressed using the illustrated associations. For example each Loo Goo or Foo instance may be determined directly from the root instance using a single association. Information regarding each Koo instance may be extracted indirectly using the root through Loo instance .

The foregoing example illustrates a structure that may be used in representing the configuration information. Additionally the particular objects represented in the example may be in accordance with a defined categorical hierarchy. In other words an object may be defined as belonging to one of the categories in the categorical hierarchy.

Referring now to shown is a representation of one example of a categorical hierarchy that may be used in an embodiment in connection with the techniques described herein. A category may be related to another category. In one embodiment a category may be characterized as embedded within another category e.g. a child of another category . A category may also be a peer to another category e.g. a sibling of another category . The example category tree of includes a root category Array representing the particular data storage system. Array has a single child category RAID Groups RGs identifying the particular RAID groupings. The RGs category has two child categories LUNs representing the logically defined device and Disks representing physical disk devices. LUNs and Disks are also peer categories with respect to each other and embedded within RGs. Similarly storage groups SGs is an embedded category of LUNs. As used herein an SG is a logically defined group of one or more LUNs.

By identifying categories of interest and defining a relationship between categories it may be specified at a high level how data is to be extracted and how the data may be represented in an output produced by the capture engine. Data included in the layout file and the configuration schema instance file may be in accordance with the defined categories and relationships. Using the techniques herein the data of and may be defined in a format that reflects the hierarchical relationship between the categories. As an example data describing a data storage system in accordance with the categorical hierarchy of may be as follows 

Other categorical relationships may be used in connection with the techniques described herein to represent a data storage system. As will be described in more detail herein also associated with each instance of an object may be one or more properties describing that instance. As an example a property associated with each instance of a disk may be its location. A property that may be associated with each RAIDGROUP instance may be an identifier such as a named identifier of the RAIDGROUP.

Based on the foregoing a layout file may be defined which reflects the hierarchical relationships between the categories. The layout file may also specify which one or more properties of each category instance are of interest. The layout file may also include one or more APIs application programming interfaces used in connection with querying the instances of a category in determining the particular properties. As will be illustrated the layout file may include the parameters for the APIs.

In one embodiment the layout file and the configuration schema instance may be XML files. To illustrate how the foregoing may be implemented in an embodiment following is a step by step example building of a layout file in accordance with the categorical hierarchy of .

In the foregoing the properties of interest are RAIDGroupID representing the RAID group identifier and SuffixAsInteger representing the slot location of a physical disk.

In the foregoing each Association may correspond to a particular API such as a method call used to obtain each instance of a particular class and properties of each instance. In other words the APIs correspond to associations used to traverse the objects in the tree structure as illustrated in in accordance with the hierarchy of categories of . The Associations set forth a way in which to query for every instance of a certain category e.g. the ResultClass by using an appropriate association class defined by the API e.g. the AssocClass and instances of a particular type e.g. the InputClass . In other words in connection with the foregoing example for every instance of use the association to get all instances of type .

In connection with each RAIDGROUP instance in this example the property RAIDGroupID may be extracted using two APIs in accordance with the defined interface provided in this embodiment. The use of two APIs in this case reflects the fact that the published APIs used in one embodiment specifies that one or more APIs may be needed in order to obtain the information desired such as the category instances. Referring back to for example the root instance may be EV Subsystem meaning this is the base singular instance needed to perform further queries using the published interface. In connection with one example instances are of type EV RAIDGroup may be desired e.g. corresponding to the Koo instance types in because instances of this type contain the necessary data to describe every defined RAID Group on an array. The API in one embodiment does not have a direct association between EV Subsystem and EV RAIDGroup e.g. more than a singe API call is needed for indirect associations between nodes . Rather there may be a first association between EV Subsystem and EV RAIDGroupFeature and a second association between EV RAIDGroupFeature and all EV RAIDGroups. Thus in order to obtain all of the EV RAIDGroup instances a first API may be invoked to obtain the EV RAIDGroupFeature instance s . Using an additional second API with EV RAIDGroupFeature as the input class all RAID group instances of type EV RAIDGroup may be obtained. If the API supported a direct association between EV Subsystem and RAIDGroups then a single API may have been used to return all such instances. In other words the particular APIs used and the number of APIs needed to obtain desired information varies in accordance with the defined hierarchical associations between nodes. Other information included with each association may be parameters used to perform the API.

The associations as included in the foregoing example may be bi directional in an embodiment with respect to the InputClass and ResultClass meaning that an instance of either class type may be used to retrieve any and all instances of the associated other class type. In one embodiment each category in the structure of may be associated with a class. The association may define the link between two instances in which one instance is of the InputClass and the second instance is of the ResultClass. Use of these associations representing an API and parameters are described in following paragraphs in connection with processing the layout file to generate a configuration schema instance.

The layout file may include only associations and property information in accordance with the configuration information that is to be extracted from the source configuration object database. For example processing the foregoing layout file may result in selectively extracting information about the RAIDGROUPS and Disks. If only information about the Disks is desired the following layout file may be used omitting the RAIDGROUP property from being extracted. However the associations for the RAIDGROUP are still included to indicate how to traverse between categories of the structure of to reach the Disks even though no information may be desired regarding the categories of Array and RGs. In other words the layout file indicates which APIs are used to traverse the categories of the example to extract the appropriate property information. The layout file may include APIs used to traverse between categories of objects even though no property information is being extracted for those instances

As another variation if a property about SGs is to be extracted the layout file may include a first association to traverse between the Array category and the RGs category a second association to traverse between the RGs category and the LUNs category and a third association to traverse between the LUNs category and the SGs category. No association is needed regarding RGs and Disks in this example. Additionally the layout file may indicate which one or more properties of the SGs are to be extracted.

It should be noted that in this particular example layout file all instances of each category are extracted. An embodiment may also include functionality in the layout file to specify filter criteria indicating which particular instances of specified categories of object are to be described in the configuration schema instance rather than all instances. The filter criteria may specify a particular attribute value and relationship for example so that only those instances meeting the specified criteria are retrieved. As an example an embodiment may specify filter criteria in the association such as 

which may result in retrieval of all instances of the specified result class having a RawCapacity greater than or equal to Value1.

What will now be described is processing performed by the capture engine using the layout file in order to generate the configuration schema instance.

Referring now to shown is a flowchart of processing steps that may be included in an embodiment in connection with processing a layout file. The steps of flowchart may be performed by the capture engine described herein. At step the layout file is accessed as an input to the capture engine. The layout file is parsed in step to produce an in memory object model or representation of the categories associations and properties included in the layout file. At step the object model from step is processed to extract configuration information for the particular instances defined in the input configuration object database. At step the formatted output for the configuration schema instance is generated. It should be noted that as will be described herein in one embodiment the formatted output of step may be generated as each information is extracted for the instances being processed.

Referring now to shown is a flowchart of processing steps that may be performed in connection with parsing the layout file and generating the object model. The flowchart represents more detailed processing that may be performed in an embodiment in connection with step of . Flowchart describes steps for processing each bracketed item or tag referred to as a bracketed token e.g. such as in the layout file. In this example the layout file is an XML file. As previously illustrated the layout file may include elements which indicate each category. Each element may be represented between delimiters and naming as a tag xxx a category from . Within each category may be nested another category or content that is an association or a property. Each defined association and property are associated with the most inner nested category. As mentioned above an item of content included within each pair of delimiters may be a token that is used in connection with flowchart processing. Processing may be performed in flowchart in connection with those tokens indicating a category beginning e.g. an association e.g. or a property e.g. . At step the next token in the layout file is obtained. At step a determination is made as to whether the current token represents a category beginning delimiter such as for ARRAY LUNs RGs and the like in accordance with the categories included in . If step evaluates to yes control proceeds to step where a category object is created. Additionally any relationship information regarding the category object may also be specified. For example if the newly created category object is an embedded object of another the relationship between the other object and the newly created object may be represented in the object model. Similarly any peer relationship may also be represented. Such relationships may be represented between objects in a tree like structure. In one embodiment category objects may be included in a table in the order in which the categories appear in the layout file. Information regarding embedded and peer relationships may be represented by including an indicator as to the type of relationship and a pointer or table index of the related category. From step control proceeds to step where a determination is made as to whether processing of the layout file is done. If so processing stops. Otherwise control proceeds to step where the next token is obtained and processed.

If step evaluates to no control proceeds to step where a determination is made as to whether the current token represents an association. If so control proceeds to step to create an association object for the current category. Control then proceeds to step . If step evaluates to no control proceeds to step where a determination is made as to whether the current element represents a property. If so control proceeds to step to create a property object for the current category and control proceeds to step . If step evaluates to no the current element is ignored at step and control proceeds to step .

In connection with the association objects created by flowchart processing each category object can contain a list of association objects that designate the association value as defined in the layout file for a particular category. Each category object can contain an associated list of property objects that designate the property values as defined in the layout file is being pertinent to the particular category. Additionally each property object may include additional information as specified in the layout file and illustrated in connection with examples previously described herein. In one embodiment each property may include a class property pair designating how to extract the value for the property. The class may be indicated in the same bracketed token as the property. The class indicated in the property token is also accounted for in one of the associations defined for this category. For example with reference to the property regarding a disk in 

Referring now to shown is an example representation of a table that may be created as a result of executing the processing steps of flowchart . The example table illustrates lists of properties and associations for categories such as category and category n. Also included in the example table is information regarding categorical relationships between categories in accordance with the defined hierarchy for example as illustrated in . For example category as represented by has category as a peer category e.g. as indicated by Peer in . Element also has category n as an embedded category e.g. as indicated by Embedded n . Element represents category n and has as its parent category represented by node . Element also has category m as an embedded category e.g. as indicated by embedded m . Other embodiments may use other techniques in connection with indicating relationships between various categories as represented in the particular data structure used for the object model produced as a result parsing the layout file.

It should be noted that information in connection with executing an API for each association may also be included with each association object. Such information may include for example one or more parameters as specified in the layout file. Parameters may be indicated for example with the enclosed delimiters identifying a property within the layout file.

Once the parsing of the layout file is complete a structured description regarding how the configuration schema instance is to be formatted has been constructed in the form of objects included in a memory object model with relationship data. What will now be described is how the object model produced as a result of parsing may be further processed in order to extract configuration information from the configuration object database describing the source data storage system. Once the information has been extracted it may then be formatted in a manner similar to as described in connection with the layout file. In one embodiment the configuration schema instance may be an XML file following the same general structure as described elsewhere herein for the layout file. An example of a configuration schema instance file is described in more detail herein.

Referring now to shown is a flowchart of processing steps that may be performed in an embodiment in connection with processing the object model produced as a result of parsing the layout file. The processing steps of flowchart may be performed by the capture engine and provide additional detail for step of flowchart previously described herein. The processing steps of flowchart may be performed for each category object.

At step the current category object is obtained for processing. In one embodiment the category objects may be obtained from the table as illustrated in . At step a determination is made as to whether an association list exists for the current category object. If so control proceeds to step to process each of the association objects associated with the current category. As part of step processing the list of association objects for the current category object is traversed. For every association object the indicated association call such as an API is executed. In connection with the embodiment described herein execution of an association call may return all of the instances of the particular result class. For example execution of the API for the following association 

Control proceeds to step where a determination is made as to whether a property list is defined for the current category. If so control proceeds to step to process the property objects associated with the current category. For every property object the value associated with the indicated class property is located in the targeted instances. The targeted instances may be found by using the class name associated with the property object as an index value into the indexed table populated at step . For example execution of the API for the following association 

If step evaluates to no control proceeds to step where a determination is made as to whether the current category is a peer category. If step evaluates to yes control proceeds to step to process the current category as a peer category. Information regarding the parent category of the current category may be used in connection with producing the formatted output of the configuration schema instance. Control proceeds from step to step where a determination is made as to whether all category objects have been processed. If so processing stops. Otherwise control proceeds to step to process the next category. If step evaluates to no control proceeds to step .

If step evaluates to no control proceeds to step processing. If step evaluates to no control also proceeds directly to step processing.

In one embodiment formatted output included in the configuration schema instance may be produced as values are extracted from instances being processed in connection with the steps of flowchart . As described previously in connection with a layout file the category information included in the layout file is in accordance with a defined hierarchy of categories. An embodiment may also generate the formatted output at the end of processing the entire object model or at other points in processing of the object model. The particular hierarchy of categories and their arrangement as indicated in the layout file may be reflected in the configuration schema instance file with particular parent child and sibling relationships being maintained between instances of categories.

Referring now to shown is an example representation of information that may be extracted from a configuration object database. The representation of may be generated as a result of parsing a layout file generating an object model e.g. by performing processing steps of flowchart and subsequently processing the object model e.g. by performing processing steps of flowchart . The configuration information included in the representation reflects the hierarchical categorical structure as may be described in the layout file for the particular instances retrieved from the configuration object database of a source data storage system. Additionally the representation may include extracted property information in accordance with the layout file.

In the example of array is defined as the root of the tree structure . The RGs category as represented by may be characterized as a data container for one or more instances of the RGs. Embedded relationships are represented in the example using solid lines drawn between nodes of the structure. Peer relationships are represented using dashed lines between nodes of the structure. In this example two RG instances are defined as represented by nodes and . RG has 3 LUN instances as represented by and and two disk instances as represented by and . LUN belongs to SG . LUN belongs to SG . LUN belongs to SG . The particular LUN instances as represented by and may be returned as a result of executing one or more APIs specified for an association included in the layout file to return the LUNs defined for a particular RAID group. As described elsewhere herein the particular APIs and number of APIs invoked to retrieve desired information may vary with each embodiment. For example one embodiment may return all LUN instances as a result of invoking a single API indicated with the RAIDGroupHasLUNs association using an input class defined for RAIDGroup. Another embodiment may define a published interface of APIs in which a first API may be executed to obtain the class instance represented by and a second API to obtain the LUN instances represented by and . Similarly the physical disks are represented by instances and which may be returned as a result of executing one or more APIs specified for an association included in the layout file to return the disks defined for a particular RAID group.

It should be noted that additional details regarding RG have been omitted from this particular example for purposes of simplicity and illustration. The foregoing is illustrative and may represent a portion of configuration information that may be included in a configuration object database. It should also be noted that an embodiment may use a variation of the conventions and techniques described herein to store and represent the configuration information extracted.

Referring now to shown is an example illustrating configuration information in more detail that may be specified regarding RG . The configuration information of may be included in the same structure of the example for the appropriate nodes but has been included in for clarity in illustration.

Associated with LUN is configuration information represented by and . Associated with RG is configuration information represented by and . Associated with D is configuration information represented by . It should be noted that information included in nodes and may be determined using the property object in accordance with a property specified in the layout file.

In connection with LUN performance data may include performance information about LUN such as for example the number of blocks read and or written the number of read and or write requests and the like. Capacity may include for example the amount of physical storage associated with LUN the amount of storage used and the like. Identification may include identification information for this particular LUN such as the LUN number. In connection with RG capacity as represented by may specify for example an amount of physical storage available for the raid group the amount actually used and the like. The identification as represented by may include an identifier for the particular RAID group represented by . The capacity as represented by may specify for example the amount of physical storage of the physical disk represented by D.

An embodiment may include other property information for each of LUNs and and the disk D represented by although such detail has been omitted for purposes of illustration. Following is a representation of information that may be included in a layout file to obtain the information as represented in .

Following is a general format of the structured output of the configuration schema instance output for the foregoing layout file as represented in 

As described herein the layout file may define a template of information to be extracted for each instance of a defined category. The particular configuration information for each instance may be included in the configuration schema instance. Although the particular examples illustrated herein include only a small number of LUNs etc. for purposes of illustration an actual data storage system configuration may include hundreds or thousands of LUNs and associated information. Similarly a data storage system may include hundreds of physical disks. As such one skilled in the art will appreciate that the benefit of using the techniques described herein increases with the complexity of a data storage system configuration.

It should be noted that although the layout file and configuration schema instance file are XML files other file formats may be utilized. For example an embodiment may utilize the techniques described herein in connection with CSV Comma Separated Value format files.

As just described capture processing as may be performed by the capture engine may be used in connection with extracting data from a configuration object database that includes an instance hierarchy. The particular information to be extracted may be specified in the layout file. For example the layout file may indicate that only a portion of configuration information for data storage system should be extracted from the configuration object database describing the data storage system s configuration. The extracted configuration information may be stored in the form of a formatted output such as the configuration scheme instance.

What will now be described is duplication processing as may be performed by the duplication engine previously described in connection with . The duplication engine may be used in connection with processing the configuration schema instance produced as a result of capture processing by the capture engine just described. It should also be noted that the duplication engine may utilize a configuration schema instance produced using other techniques including for example manual generation.

In one embodiment the configuration schema instance may be copied to a target data storage system. The configuration information included in the configuration schema instance may be used in connection with replicating the data storage configuration of a source data storage system on the target data storage system. Any one of a variety of different techniques may be used in connection with making the configuration schema instance available for use on the target system in connection with duplication processing. For example the configuration schema instance may be pushed from the source data storage system to the target data storage system. An embodiment may also pull the configuration schema instance from the source data storage system to the target data storage system such as by controlling duplication processing from the target data storage system. An embodiment may also control duplication processing from another location other than the source and target data storage systems. It should be noted that capture processing described herein may also be controlled from a location other than the source data storage system such as for example using APIs to control the capture engine. Similarly the duplication engine may be controlled from the source data storage system target data storage system or other location using APIs.

Referring now to shown is an example of components that may be included in an embodiment of the duplication engine in connection with performing duplication processing. As described herein duplication processing may be performed on the target data storage system. In the example the configuration schema instance may be parsed by a configuration schema parser . The configuration schema instance represents the data storage system configuration information that is to be duplicated. The configuration schema instance parser may create a memory context tree representing the information input from the configuration schema instance . In one embodiment the memory context tree may be represented and include information similar to as described and illustrated in connection with . The memory context tree may be stored in memory used during execution of the duplication engine. Once the parsing of the instance is complete control is passed to the master rules parser . The master rules parser parses the master rule file and generally drives the operation of the duplication processing from this point in duplication processing. The master rule file identifies an order in which elements included in the configuration schema instance are processed. In one embodiment the master rule file may be an XML file. An object tag e.g. may be used for specifying an XML element tag of the configuration schema instance to be processed. During execution the master rules parser reads a next object tag indicating the next XML element of the configuration schema instance to be processed. The master rules parser determines if any such elements are included in the memory context tree . If not the master rules parser proceeds to extract the next object tag from the master rule file . If the memory context tree includes an XML element corresponding to the current object tag the master rules parser determines if the master rule file specifies any rules to be executed for each instance of the XML element and executes the specified rule s .

An embodiment of the master rules parser may parse the master rules file searching for the next rule. Once the next rule is located context information for the context of the current rule may be determined. Such context information may include hierarchical information regarding the location of the rule with respect to object tags e.g. OBJECTs in the master rule file as described above corresponding to XML elements in the configuration schema instance file. Context information may also include data for the particular values or instances of tag elements. The master rules parser may use this context information when determining whether there is a match in the configuration schema instance for the current rule. The current context information may also be represented in the memory context tree by the particular location in the tree structure of the XML element of the instance determined as a matching context. In other words the parser may determine whether there is a matching context in the memory context tree in accordance with the context of the current rule using hierarchical information of the tree . Once the master rules parser has finished executing a rule the parser proceeds to the next rule. Each rule by its location in the master rule file has an associated implicit context for the execution of the rule. The master rules parser sets the appropriate context in accordance with the execution of each rule. As also described herein in more detail a matching context for a current rule may be determined in accordance with the context of an element in the configuration schema instance.

In connection with the execution of a rule the parser invokes the rules execution engine to execute the rule. In one embodiment the rule execution engine may include one or more different rule execution engines capable of executing rules in a variety of different input forms or types. In one embodiment rules implemented using an XML script C and Java may be supported. A different rules engine such as may be included for each supported rule type. The appropriate rules engine is invoked in accordance with the particular type of the rule. In one embodiment each rule may have a corresponding rule file or script included in . The name of the rule file or script as well as the particular type may be indicated in the master rule file and passed to the rule execution engine which then selects an appropriate rule execution engine from to execute the rule. Each rule file of may result in performing one or more put or set operations to update the configuration object database in accordance with the configuration information as represented in the memory context tree . Routines or methods may be invoked as included in one or more libraries of in connection with performing operations on the database . A rule file may also result in performing one or more retrieval operations to obtain information from one or more of the memory context tree the environment and the configuration object database . As will be described in more detail herein an environment may be associated with execution of a rule using environment blocks. Various items may be defined in the environment and used during execution of a rule. The environment may be characterized as a scratch pad memory area into which script statements may store information temporarily for reference by subsequent script statements. As will be described herein the information stored in the environment area may be retrieved from the memory context tree or from the target data storage system s object database e.g. configuration object database . As used herein a current context in connection with duplication processing may refer to that portion of the memory context tree for the XML element of the configuration schema instance currently being processed. In the event it is determined that there is a matching context between a current rule of the master rule file and the tree the same context may be represented in both the tree e.g. using the hierarchical tree structure and the master rule file e.g. as reflected using the structured XML tags and format .

The foregoing process of the master rules parser performing processing for each rule from the master rule file having a matching context as represented in the memory context tree continues until the entire master rule file has been read by the parser . Upon completion the configuration object database reflects the updating steps as may be performed by the rule execution engine in accordance with the configuration schema instance .

What will now be described is an example of what may be included in a master rule file of an embodiment. In one embodiment the master rule file may be an XML based file including object tags for specifying corresponding XML element tags from the configuration schema instance to be processed. Consider the following example snippet as may be included in a master rules file 

In the foregoing the handler tag indicates a particular rule to be executed. The type indicates the type of the rule and rules engine to be invoked. In one embodiment the type may be one of script indicating the rule is an XML script class indicating the rule is implemented using C or Java indicating that the rule is implemented using Java . Also in the foregoing the handler tag identifies a rule which by default is executed for each instance of a corresponding XML tag. In one embodiment an option may be supported to allow for altering the foregoing default execution. Use of the EXECUTIONOPTION EXECUTEONCE may identify a particular rule which is to be executed only once for the first instance of a corresponding XML tag. When the foregoing is read by the master rules parser the parser looks for all RAID group tags included in e.g. as represented in the memory context tree under the LOGICALS RAIDGROUPS tag and executes the Create RAID Group.xml script with the RAIDGROUP tag as the current context. This script will be executed for every instance of a RAID group included in the memory context tree . After execution of the foregoing Create RAIDGroup for each instance PollSubsystem.xml is executed once.

Within the master rule file object tags and associated rules to be executed may be specified in an order dependent on particular operations to be performed as part of duplication processing. For example as illustrated elsewhere herein an SG may be defined which includes one or more LUNs. Prior to performing operations to add one or more LUNs to an SG the SG is created and then each LUN is identified as belonging to the SG. The particular dependency or ordering is specified in the master rule file . The content and ordering of items included in the master rule file may vary in accordance with embodiment.

What will now be described in more detail is the rule files scripts . In one embodiment each of the rule files may be defined as an XML file. For example an XML file for a rule may include an XML script as may be executed by the XML script rules engine

A rule file may have a general format including zero or more environment blocks and an zero or more execution blocks. In one embodiment an environment block may be marked by tags . . . and an execution block may be marked by tags . . . . An environment block may be used in connection with getting or defining objects as may be referenced later in the script. For example objects may be defined in the environment block by retrieving information from the configuration object database and or the memory context tree. Such objects defined in the environment may be later referenced in connection with storing information in the configuration object database . The environment block may be used in connection with getting configuration information needed to execute the operation specified in a subsequent execution block. The execution blocks may be characterized as put operations which store information in the configuration object database . As described above information for a current context may be retrieved from the memory context tree and used in connection with the environment and or execution blocks.

In one embodiment different language elements may be defined for use in the environment and execution blocks. Following is an example grammar that may be used in connection with defining XML based rules. In the following the notation 4 sign is read as can have or may include. The rules below may also be referred to as production rules. An element on the left hand side may map to a bolded version of itself on the right side of a grammar rule. The right side bolded version is a terminal element with all others being non terminal elements.

Each of the foregoing non terminals correspond to XML tags that may be included in a rule file. The foregoing tags are now described in more detail as may be included in an embodiment.

 The script tag represents a script. A script can set up one or more environments using the ENVIRONMENT tag for its execution and one or more set or put operations to the database as may be specified using the EXECUTION tag.

 An Environment tag may be used for setting up objects in the environment. The objects may be used subsequently referenced later in the script. A method call may be specified using an environment tag. In one embodiment one or more methods may be defined which return all instances of a specified class. The specified class may be associated with each category of the hierarchy of categories as described elsewhere herein such as in connection with . One or more methods may also be defined to return a single object or multiple objects to the environment. Objects returned to the environment can be named explicitly. If no explicit name is defined the objects may be implicitly named such as may be referenced using the object class name. In one embodiment the ENVIRONMENT production rule may be used to define an ENVIRONMENT script element which performs a method call defines a filter or invokes a script. As described herein a METHODCALL and an IMETHODCALL may correspond to different method calls in accordance with different specific provider interfaces. An Execute tag may be used for set operations to the database performed by the script. In one embodiment the Execute tag may be used to specify a method call to perform the put operation. These tags may refer to method calls by a specific provider or interface. These tags may refer to method calls by a specific provider or interface. These tags may be used for filtering the objects retuned to the environment. The object s selected as a result of the filtering operation may be referenced by a different name. The Filter has one operator as may be specified using the OPERATOR tag for operating on the environment data. Specifies a supported operator. In one embodiment operators can use OPERATOR recursively. Operators supported in one embodiment are EQUALS AND OR . A condition tag has an operator tag to be evaluated. This tag may have an associated true handler e.g. TRUEHANDLER tag and a false handler e.g. FALSEHANDLER tag to perform processing depending on the return value of the operator. This tag is represents the block to be executed if the condition evaluates to true non zero . This tag is represents the block to be executed if the condition evaluates to false zero . This tag represents the name of a class the instance name of whose instances are determined from the environment. Execution of this tag can produce one or more instance names. The tag represents a parameter as may be used to specify a method parameter. This tag indicates that the parameter is a reference parameter and is determined either from the memory context tree or from the environment. This tag is used for specifying a property. This tag specifies that the property is a reference property indicating that the property is determined by those included in the memory context tree or the environment. This tag indicates that the specified property or class is determined by looking at defined properties and classes for the environment. This tag means that the property or class is determined using the memory context tree. The CONTEXTREF can in turn lookup a context return value by utilizing another CONTEXTREF unless CONTEXTREF returns a property. This tag represents a parameter as may be used with a method call and indicates that the parameter is a value. The value in this embodiment may be hardcoded or included in the script. This tag represents an array of values. This tag represents a hard coded value. This tag may be used to ensure certain constraints are valid before the execution of scripts. As an example the CONSTRAINT tag may be used to determine certain execution preconditions such as ensuring an object used by the script is available in the environment ensuring the context memory tree has certain embedded objects before beginning execution of a script and the like. This allows the script to tell the runtime engine to stop its execution of the current context. The runtime engine will proceed to the next context. This allows the script to inform the rules engine to execute the script again for the same current context. This tag may be used for example when a script determines that the objects that will be used are in a transition state. Existence of a transition state may be determined in accordance with statements of the script as executed. The script may retrieve an object from the target configuration object database and inspect a property for example which may not have an expected value providing an indication that the associated object is in a state of transition. Accordingly if such a state is detected the RUNAGAIN statement may be used in the script to cause the runtime engine to execute the script again for the same context. In one embodiment the rules engine may wait for a predefined amount of time and run the same script under the same context again. As an example in connection with a data storage system many operations may be dependent on LUNs such as operations performed to add one or more LUNS to a storage group SG . A LUN which is in transition such as in the process of being defined may be determined using the is Transitioning property associated with each LUN instance. Other embodiments may use other techniques in connection with defining and determining such a state of transition associated with an object 

It should be noted that scripts may be nested or invoked from one another to allow for code reuse. For example a script may define one or more environment blocks that are commonly referenced by one or more other scripts. One particular use of this may be in defining an environment to get certain information from the database and define one or more instances for use in the environment. For example a get operation may be defined to obtain objects for one or more physical components of the database .

What will now be described is a portion of what may be included in an XML rule file to illustrate various aspects of the foregoing language elements. In the example snippet below one or more LUNs are being added to a storage group. In connection with the example below it is assumed that defined in the environment are the storage groups SGs and LUNs for the data storage system. In other words appropriate ENVIRONMENT method calls have been executed to obtain the defined SGs and LUNs from the database . Comments are inserted in lines denoted with the for readability.

In one embodiment as described above one or more environment blocks may be used in connection with obtaining all objects needed for the one or more put operations as may be performed in subsequent one or more execution blocks. The objects obtained by the environment may be referenced along with items from the memory context tree in the execution blocks. Any one or more different techniques and defined interfaces may be used in connection with retrieving objects from the database for use in an environment block. Items from the memory context tree as well as objects of the environment may also be referenced in an environment block as well as an execution block in accordance with the particular processing performed by the script. In one embodiment the database may be in an initial state at the start of duplication processing. The initial state may be one in which the database includes at least objects for the physical components in the data storage system such as for example an array object disk objects and the like. The database may be in any one of a variety of different initial states which may also include some logical configuration information.

Referring now to shown is flowchart of processing steps that may be performed in an embodiment as part of duplication processing. The flowchart generally summarizes processing described herein in connection with the components of the example of . At step duplication and operation processing is initiated. This may be performed for example using APIs which issue commands to the duplication engine to initiate duplication processing. At step the configuration schema instance is parsed in the memory context tree is generated. At step the master rules parser parses the master rules file and determines the next rule and associated context information. At step memory context tree is searched for any matching occurrences for the current rule and associated context information. As described elsewhere herein a match is determined by determining a matching context such as in accordance with the one or more elements and associated hierarchical location. At step a determination is made as to whether a match exists between the current rule and the memory context tree. If step evaluates to yes control proceeds to step to execute the rule with the appropriate rules engine and in accordance with the context information. Additionally step is performed in accordance with any execution option as may be specified in the master rules file. For example as illustrated elsewhere herein the master rules file may include an option to mark a rule to be executed only in accordance with the first matching occurrence in the configuration schema instance file. As described elsewhere herein step may result in performing one or more operations to retrieve information from and or update the database . Additionally step may result in execution of multiple scripts in the event an embodiment utilizes XML based scripts with nesting for rule implementation. Following step control proceeds to step where a determination is made as to whether the master rules file processing is complete. If so processing stops. Otherwise control proceeds from step to step with the next rule from the master rules file. If step evaluates to no control proceeds directly to step skipping the current rule.

What will now be described is an example illustrating the duplication processing described herein as may be performed in an embodiment for the following portion as may be included in a master rules file 

Referring now to shown is an example representation of information as may be defined in an object database of a source data storage system. The example includes a logical portion which may be represented using the above referenced portion as included in a configuration schema instance. The configuration schema instance may be generated using the techniques described herein for capture processing as performed by the capture engine. The object database of the destination data storage system may include objects for the physical components as represented by and and the logical object . However no logical configuration information is yet included in the database . Duplication processing may be performed using the techniques described in connection with the components of of to include logical configuration information in the database .

Following is an example of what may be included in a configuration schema instance for portion in which LUN is defined as being physically located on disk D 

The configuration schema parser inputs and parses the configuration schema instance and represents the parsed input in the form of a memory context tree . In one embodiment as described herein the tree may be stored in memory referenced during execution of the components of . The memory context tree may be as represented by nodes and of the example . In the memory context tree the physical location of the LUN may be stored as a property of the LUN object of the tree . The master rules parser reads the object tag in the master rules file specifying the object tag for the XML tag element LUN as may be included in the configuration schema instance under the LOGICALS LUNs tag and determines the next rule is DefineLun.XML. The rule file in this example is an XML script DefineLun.xml which is executed for each occurrence of the LUN tag as included in the configuration schema instance. The master rules parser determines that there is a match in the memory context tree for the LUN tag. In this example there is only a single instance for LUN so the DefineLun.xml script is executed by the XML script rules engine once for LUN .

Referring now to shown is an example representation of operations that may be performed by an embodiment of the DefineLun.xml rulefile. Each occurrence of ENVx in the example may represent one or more environment blocks as may be formed using the ENVIRONMENT tag described elsewhere herein. Each occurrence of EXECx in the example may represent one or more execution blocks as may be formed using the EXECUTION tag described elsewhere herein.

In an embodiment the current context may be maintained as part of state information within the duplication engine. When processing is performed in connection with a particular portion of the memory context tree the duplication engine may maintain as a state variable a current context identifying the current portion of the memory context tree for which rule execution is being performed. When utilizing script language elements which reference objects from the memory context tree e.g. CONTEXTREF the language elements may reference an object from the context tree utilizing the current context. In the event that a particular item for which a search is being performed does not exist in the current context a search may be performed relative to the current context using a defined order. For example when searching for a particular object or property the search may begin with the current context and then move up the tree to the parent node of the current context. The particular order in which a search is performed for a particular context reference from the memory context tree may vary with embodiment. The script may reference particular instances using various scripting language elements. For example the script may reference an instance using scripting language elements causing the rule execution engine to retrieve a value from anywhere in the context tree. For example the script may cause the rule execution engine to go to the parent of a current context. The parent may be a RAIDGroup element and the script may include statements causing the rule execution engine to obtain the parent instance s RAIDGroup ID Property. By default the rule execution engine may look only to the current context for particular values. In connection with instances stored in the environment scripting language elements such as ENVREF in combination with FILTERs may be used to retrieve a particular instance in the environment. In the event that more than one object in the environment meets the specified FILTER criteria an embodiment may define a default behavior such as for example to return all object instances meeting the criteria the last referenced object meeting the criteria and the like.

In the example the environment block ENV may get the Array object from the database using a first method call or other API and returning the object to the environment. The object as well as other objects returned to the environment may be subsequently referenced as an environment object e.g. using ENVREF . A second method call may be made using the Array object as an input parameter. It should be noted that using the techniques described herein ENV may include 2 execution blocks defined by two EXECUTION tags one for each method call. The second method call may result in returning to the environment the logical object from the database . Using the logical object as an input parameter the execution block EXEC may use a third method call which creates a LUNs object instance and stores it in the database with the appropriate hierarchical relationships. The environment block ENV may get and return to the environment the LUNs object . The execution block EXEC may create a LUN object in the database using as a first input parameter the LUNs object and specifying other LUN information such as the name LUN as other input parameter data. The LUN information may be specified using information from the memory context tree e.g. by using a CONTEXTREF tag in the XML script . In order to complete the association as represented by ENV environment blocks may be executed. It should be noted that ENV may include 4 environment blocks defined using 4 ENVIRONMENT tags one for each method call corresponding to a get operation to retrieve information from the database . A first method call may be performed to get the LUN object created in EXEC. A second method call may be performed using the array object as an input parameter to return object physical to the environment. A third method call may be performed using the object as an input parameter to return the object disks to the environment. A fourth method call may be performed using the object as the input parameter to return object D to the environment. In the execution block EXEC a method call may be performed to update the database to associate LUN object with D object .

For each of the foregoing method calls scripting language elements such as ENVREF may be used to reference particular objects read from the database and returned to the environment. As illustrated herein such references may be made in connection with subsequent method calls in EXECUTION blocks and the like.

As described herein an embodiment may implement rules using a variety of different techniques. As illustrated herein a rule may be implemented using one or more XML scripts. A rule may also be implemented using C . In one embodiment rules may be implemented using one or more C classes. The name of a class factory for each rule may be registered with the duplication engine at compile time of the duplication engine. Multiple rules such as a same grouping of related rules may specify the same class factory. When the master rules parser encounters a rule of type class indicating a C based rule implementation a factory instance is created. The factory instance creates a rule object that performs processing for that rule for the current context. One advantage of using C based rule implementation over XML based scripts is that the C based implementation may utilize the richness of the C language as opposed to the XML scripting language. However C based rule implementations as described herein differ from the XML scripting in that when a change is made to the rule the code for implementing the rule and duplication engine is recompiled. Such a step of recompilation is not needed in the case of using XML scripts.

An embodiment of the duplication engine may also perform caching of scripts for example as an optimization if a same script is executed multiple times.

What will now be described is utilization of the techniques described herein in connection with providing rollback functionality to rollback or undo operations performed by the duplication engine. In one embodiment the use of rollback functionality may be initiated for example when there are errors encountered during the duplication operation or when it may be otherwise desirable to rollback the database to a particular point in time configuration. Rollback processing may be controlled in a manner similar to as described herein in connection with duplication processing using an API issuing commands to the components included in the data storage system. The rollback processing may utilize the duplication engine in connection with performing rollback processing.

An embodiment utilizing rollback functionality may have the duplication engine generate additional information during duplication processing. The additional information may be used as input to rollback processing performed at a later point in time. In one embodiment the duplication engine may be enabled to perform the following processing and generate the following additional information during duplication processing. The duplication engine 

1. Marks each XML element as may be represented as a node in the memory context tree with a unique ID and saves the XML elements and associated IDs to a file referred to herein as the rollback context file. In one embodiment a unique ID may be assigned to each node of the memory context tree. In an embodiment representing each node in the memory context tree as an object the unique ID may be a property for each object instance corresponding to a node in the tree. This rollback context file may be created after reading in the configuration schema instance. The rollback context file as will be illustrated in following paragraphs may be a version of the configuration schema instance with the unique IDs for each XML element added.

2. Each time a duplication script succeeds in completing its operation a transaction log is updated. The transaction log tracks what operations are performed for each node in the memory context tree as may correspond to XML elements from the configurations schema instance. In one embodiment the transaction log may record the name of the script executed successfully and also record the unique ID associated with the node of the memory context tree processed by the script execution instance.

At a later point in time the foregoing rollback context file and transaction log may be used as inputs in connection with performing rollback processing for example to rollback the target configuration object database . In one embodiment the duplication engine components may perform rollback processing using different inputs than in connection with duplication processing.

An embodiment of the duplication engine may use the following in connection with performing the rollback 

Additional detail about the foregoing used in connection with performing rollback processing is described in following paragraphs.

For purposes of illustration a complete example will now be described. Following is an example of a configuration schema instance as may be input to the duplication engine enabled to generate the transaction log and rollback context file as part of duplication processing.

When the foregoing configuration schema instance is used as an input into the duplication processing components as illustrated in the duplication engine enabled to generate the additional information used in connection with subsequently performing rollback processing may assign a unique ID to each XML element by adding the UniqueID attribute to each element encountered in the configuration schema instance. The duplication engine may generate the rollback context file including the unique IDs. In one embodiment the rollback context file may be generated by the configuration schema parser . Below is an example of a rollback context file that may be generated as part of duplication processing based on the foregoing configuration schema instance 

As the duplication engine proceeds the duplication engine may record operations performed in a transaction log. In one embodiment the duplication engine may record each script instance successfully executed and the particular XML element for which the script is being executed. For each successful execution instance of a script the script name and unique ID of the XML element for which the script execution was performed may be recorded in the transaction log. Following is an example representation of a transaction log snippet that may be generated when duplication processing is enabled to generate the additional outputs that may be used in subsequent rollback processing. The example transaction log snippet is based on the previous examples of the configuration schema instance and rollback context file 

The first line above indicates that script Create RAIDGroup.xml was successfully run for the XML element represented by the UniqueID . The second line above indicates that script BindLUN.xml was successfully run for the XML element represented by the UniqueID . The third line above indicates that script BindLUN.xml was successfully run for the XML element represented by the UniqueID .

The foregoing transaction log and rollback context file may be used in subsequently performing rollback processing to rollback the configuration object database . After rollback processing is performed the database may be characterized as restored to a previous configuration information state. Rollback processing may be performed for example if errors were encountered in connection with duplication processing. It may then be desirable to rollback the database to a state prior to commencing duplication processing.

In one embodiment rollback processing may be performed using the duplication engine components illustrated in with the inputs described elsewhere herein. As with capture processing and duplication processing rollback processing may also be controlled using an API. The API to perform rollback processing may enable the duplication engine to execute in a rollback execution mode rather than a duplication execution mode e.g. to perform duplication processing . When the duplication engine executes in the rollback execution mode the duplication engine may utilize those inputs described herein in connection with rollback processing. Alternatively when the duplication engine executes in the duplication execution mode the duplication engine may utilize those inputs described herein in connection with duplication processing.

What will now be described in more detail are the inputs and processing performed by the duplication engine executing in the rollback execution mode.

As described above the inputs to the duplication engine executing in rollback execution mode include the rollback context file the transaction log the rollback master rule file and the rule files scripts used in connection with rollback processing.

The rollback master rule file may include references to rules for undoing previously successful operations that may be performed in connection with duplication processing. For example duplication processing may bind a LUN to a particular SG RG and the like. Rollback processing may include undoing such operations such as for example unbinding the LUN . As will be described in more detail in following paragraphs the rollback master rule file for unbinding LUN instructs the duplication engine to run the unBindLUN.xml script only if the BindLUN.xml script has been previously executed successfully for a specified LUN element. The duplication engine may determine if the BindLUN.xml script has been successfully executed by referring to the transaction log. Furthermore the particular context of the previously successful execution may be determined by using the uniqueID to determine context information from the rollback context file.

Following is an example rollback script for performing an unbind LUN operation. An unbind LUN operation may be performed for example to remove LUNs from RGs or SGs. In this example the rollback script utilizes the same language as the duplication scripts as described above. The below script may be an XML script named unBindLUN.xml. In this example the method executed varies with the operation so that the method UnbindNumberedLun is invoked.

In the foregoing example the script language element ENVIRONMENT CACHE option may be used in connection with a script executed multiple times in accordance with the number of elements in the memory context tree. The ENVIRONMENT CACHE option causes enumerated objects in the environment to be cached or stored for all instances of execution of the script. Without use of this option any objects of the environment are not maintained from one execution of the same script to subsequent executions of the same script. In this example the SUBSYSTEM in the environment is cached meaning that this object will not be removed from the scratch pad e.g. environment when the script execution stops. When the same script is executed again use of the ENVIRONMENT CACHE option causes retrieval of the subsystem object from the cache. The ENVIRONMENT CACHE option may be used for example as an alternative to retrieving the object from the target configuration object database .

It should also be noted that the use of OBJREF in the foregoing example script indicates that the called method refers to a particular object instance.

In one embodiment the rollback master rule file is similar in functionality to the duplication master. The rollback master rule file may define the following 

Below is an example snippet from a rollback master rule file as may be used in connection with a rollback operation. The example below illustrates how the above mentioned items may be implemented in a rollback master rule file. In this example illustration the rollback master rule file indicates an ordering in accordance with unbinding the LUNs from a RG and then destroying the RG. The rule for unBindLUN is implemented in this example as an XML script e.g. Un BindLUN.xml above and has an appropriate type attribute with the HANDLER tag below.

The above example includes a script language option of REQMNT that may be used in connection with HANDLERs. As discussed above the HANDLERs may specify the script name and type. The REQMNT option in connection with a HANDLER for rollback processing may be used to specify the complementary operation for the processing performed by the associated HANDLER. For example the HANDLER UnBindLUN may have BindLUN specified with the REQMNT option. The REQMNT option causes the duplication engine to determine if the specified complementary operation was successfully performed using the transaction log file. If the complementary operation e.g. BindLUN was successfully performed as part of previous duplication processing the rollback processing continues by executing the rule indicated with the associated HANDLER e.g. unBindLUN . Otherwise an error occurs and the rule indicated with the associated HANDLER is not executed.

As described above the transaction log file from previous duplication processing includes a list of which scripts are executed for a given context so that the same context can be utilized in connection with rollback scripts.

Referring now to shown is a flowchart of processing steps that may be performed in an embodiment in connection with performing rollback processing using the techniques described herein. The steps of the flowchart summarize processing just described. At step duplication processing is performed in which the duplication engine is enabled to generate the rollback processing outputs. In one embodiment described herein these outputs include the transaction log file and the rollback context file. At step rollback processing may be initiated. As described herein step may be performed at some point in time after duplication processing. Step may be performed for example in response to detecting an error in connection with duplication processing. At step the rollback context file is parsed and the memory context tree is generated as described in connection with duplication processing. The memory context tree constructed in step also includes the additional uniqueIDs as generated for each node in the tree to uniquely identify each node associated with an XML element from the rollback context file. At step the master rules parser parses the rollback master rule file and determines the next rule and associated context information. At step a determination is made as to whether a requirement is specified in the master rule file for the next rule occurring in the master rule file.

If step evaluates to yes control proceeds to step . Recall that the requirement option may be specified in connection with rollback processing to indicate a complementary operation. Use of the requirement option causes the duplication engine to perform processing to determine if the complementary option indicated by the requirement option was successfully performed during previous duplication processing. This is determined by examining the transaction log at step and determining whether there are one or more matches for the complementary operation in the transaction log. If not control proceeds to step . If step evaluates to yes control proceeds to step where processing is performed for each matching complementary operation occurrence in the transaction log. At step for each match in the transaction log the corresponding context is extracted from the context tree in accordance with the unique ID e.g. unique ID from transaction log matches unique ID of node in tree to find matching context . The current rule is executed with the appropriate rules engine using the matching context from the context tree along with any execution options that may be specified in the rollback master rule file. From step control proceeds to step .

If step evaluates to no indicating no special requirements control proceeds to step where the memory context tree is searched for any matching occurrence s . It should be noted that step processing is similar to step of . Control proceeds to step where a determination is made as to whether there are any matches between the current rule and its associated context and with a node in the context tree. If step evaluates to no control proceeds to step . If step evaluates to yes control proceeds to step where the rule is executes with the appropriate rules engine for each matching context and any execution option from the rollback master rule file. From step control proceeds to step .

At step a determination is made as to whether processing of all rules in the rollback master rule file is complete. If so processing stops. Otherwise control proceeds to step with the next rule in the rollback master rule file.

In connection with the flowchart of it should be noted that if step evaluates to no the processing performed at steps and is similar to that performed respectively at step and of flowchart of in connection with duplication processing.

In connection with the duplication engine an option may be used to enable disable generation of the transaction log file and rollback context file that may be subsequently used in connection with rollback processing. Another option may be used to determine the execution mode of the duplication engine. As described herein the duplication mode may execute in a first execution mode to perform duplication processing or a second execution mode to perform rollback processing. Depending on which execution mode is specified the duplication engine utilizes particular inputs and performs specific execution mode processing as described herein.

As described herein the requirements option e.g. REQMNT may be used in connection with rollback processing in the rollback master rule file to indicate complementary operations. An embodiment may also have multiple requirements for a single rollback operation to be performed. The requirement option may be characterized as a mechanism for specifying preconditions which should be determined to exist prior to execution of a particular rollback processing operation performed by a rule file or script. Other requirements that may be specified in an embodiment may include for example determining if one or more expected objects are defined in the target configuration object database .

The environment as described herein may be characterized as an area which may be loaded with objects used in subsequent processing. As described herein objects may be cached in an environment associated with a script so that the same cached object s are defined or loaded with subsequent executions of the same script. In other words the cached object is loaded into the environment associated with the next execution instance of the same script. Objects from the context tree may also be loaded into the environment. In one embodiment the current context may be automatically loaded into the environment associated with a script.

It should be noted that the various components used in connection with the techniques described herein may be implemented using hardware and or software. For example the components of the capture engine and or duplication engine may be written in any one or more programming and or scripting languages such as for example C Java and XML.

While the invention has been disclosed in connection with preferred embodiments shown and described in detail their modifications and improvements thereon will become readily apparent to those skilled in the art. Accordingly the spirit and scope of the present invention should be limited only by the following claims.

