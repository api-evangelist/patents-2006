---

title: Minimal difference query and view matching
abstract: The subject disclosure pertains to efficient computation of the difference between queries by exploiting commonality between them. A minimal difference query (MDQ) is generated that roughly corresponds to removal of as many joins as possible while still accurately representing the query difference. The minimal difference can be employed to further substantially the scope of view matching where a query is not wholly subsumed by a view. Additionally, the minimal difference query can be employed as an analytical tool in various contexts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07558780&OS=07558780&RS=07558780
owner: Microsoft Corporation
number: 07558780
owner_city: Redmond
owner_country: US
publication_date: 20061130
---
This application is a divisional of U.S. patent application Ser. No. 11 352 628 filed on Feb. 13 2006 entitled MINIMAL DIFFERENCE QUERY AND VIEW MATCHING . This application is also related to U.S. patent application Ser. No. 11 558 029 filed on Nov. 9 2006 entitled MINIMAL DIFFERENCE QUERY AND VIEW MATCHING . The entireties of the aforementioned applications are incorporated herein by reference.

Data intensive applications such as decision support and e commerce rely on being able to integrate data from various sources. To accomplish this task a data transformation query is created between a data source and target. A variety of issues have to be addressed in identifying such a query. The data is often inconsistent owing to factors such as data entry errors and missing information. These inconsistencies must be removed before the data can be loaded and used for analysis. This is further compounded by the presence of mismatches between the source and the target schemas that need to be reconciled. As a result the problem of data integration is widely recognized to be a significant challenge.

The space of reasonable transformation queries between data source and target can be enormous and it is very difficult for users to consider and even conceive of all possible options. This is aggravated by the fact that a user may not understand the source data fully. As a result users need to try different queries iteratively until a satisfactory result is obtained. Previously published work has thus identified the need for interactive tools that help users understand the impact of a transformation query.

In such an interactive environment it is natural to reason about the difference between queries. Even a small change to a transformation query such as changing a join column relaxing an equi join to a join that exploits string similarities also known as similarity joins changing the thresholds for similarity comparison or adding an extra join can have substantial impact on the results of the query. It is therefore very natural to ask whether such a change produces tuples that are expected at the result but were previously absent or suppresses tuples that were erroneously generated.

Of course the difference between queries can be computed in SQL Structure Language Query using the EXCEPT EXCEPT ALL or MINUS clause. However the performance of this approach is highly inadequate especially when the two queries are closely related to each other. In particular assume there are two queries Qand Q. Conventionally the difference is computed by executing both Qand Qand then determining the difference.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the subject innovation pertains to systems and methods of efficiently computing the difference between queries. In accordance with one aspect of the subject innovation a principled approach is employed based on identifying joins that can be eliminated when computing the query difference. This is characterized by defining the notion of a minimal difference query MDQ that roughly corresponds to minimizing the number of joins. Systems and methods are disclosed for obtaining the minimal difference query that are adapted to both set and bag semantics.

In accordance with another aspect of the subject innovation the systems and methods can be extended to exploit known or determined metadata including but not limited to functional dependencies e.g. key constraints and inclusion dependencies e.g. foreign key constraints . This metadata can be employed to improve query difference performance further by providing an opportunity to eliminate additional joins for example based on redundant conjuncts.

According to yet another aspect of the subject innovation the query difference system and method can be exploited to further the scope of view matching technology in the case when the results of a query are only partially covered by a view. This can be accomplished by among other things incorporating the aforementioned difference operations into view matching. In an interactive environment this strategy widens the possibility of using the results of previously executed queries in answering a query. This approach is especially useful when the queries are closely related as is often the case in an interactive environment.

Additionally or alternatively aspects of the subject innovation can be employed in an analytical tool e.g. client and or server side useful in contexts including but not limited to data cleaning data integration and schema matching. For example utilizing such a tool an entity or individual can reason whether a specific change to a query produces tuples that were expected but not found or suppresses tuples that were erroneously returned.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

The various aspects of the subject innovation are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

As used in this application the terms component and system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an instance an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore all or portions of the subject innovation may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore examples are provided solely for purposes of clarity and understanding and are not meant to limit the subject innovation or portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented but have been omitted for purposes of brevity.

Collist Q denotes a list of returned attributes rellist Q identifies a list of involved relations and pred Q specifies conjunction predicates. It should be appreciated that since results extend to queries including union and difference the predicates can also include disjunction.

D can be a database. In such instance Q D denotes that query results of the evaluation of query Q on database D.

For notational convenience queries are written using the standard notation for conjunctive queries. In brief a conjunctive query has the following form Q V c c . . . c where V is a set of return variables called head variables also denoted as head Q and c . . . care conjuncts. Each conjunct can be a relational atom R V where Ris a relation and Vis a tuple of variables and constants or a Boolean predicate involving variables that are present in some relational atom. Herein the variables in V are called bound and the rest are free variables. The set of free variables in Q is denoted as V. By way of example and not limitation consider the following two queries Q and Q 

The similarity function is denoted herein as sim. Such notation is employed regardless of the type including but not limited to edit distance and jaccard similarity. For instance the following query Qrepresents a similarity join between relations R and S Q n p R n a USA S n p cc sim n n . It requires joining of all pairs of tuples whose similarity on the n column is above threshold .

Computing the difference between queries forms a natural analytical tool useful in many contexts including but not limited to data cleaning data integration and schema matching. For instance such a tool can be employed by a system or individual to reason about whether a specific change to a query produces tuples that were expected at the result but were absent or suppresses tuples that were erroneously generated.

Referring initially to a query difference system is illustrated in accordance with an aspect of the subject innovation. The system includes a receiver component and a difference component . The receiver component can receive retrieve or otherwise obtain or acquire at least two queries. For instance the receiver component can receive query Q and query Q . The receiver component can correspond to any one of a number of different technologies including but not limited to an application programming interface API or graphical user interface or environment. The receiver component is communicatively coupled to the difference component . The difference component receives or retrieves queries from the receiver component . Here the difference component receives Q and Q . The difference component generates a minimal difference query representing the difference between queries such as Q Q .

At present the difference could be computed using a difference operator such as minus except or except all in SQL but these conventional operators are very inefficient. In particular the difference between Q and Q is generated by executing both Q and Q and subsequently taking the difference. That is very expensive. The difference component can accomplish such a task by rewriting or generating a query that is much more efficient than executing Q and Q and then discovering the difference.

Consider the flowing example that illustrates why a na ve approach to compute query difference can be sub optimal and how the subject innovation provides an efficient rewriting. Consider a scenario where there are multiple customer databases in an enterprise with different attributes represented by tables R S and USAddr where the variable names for exemplary conjunctive queries presented infra appear in parentheses 

At first glance one may incorrectly conjecture that the difference can be generated by negotiating the extra predicate R.address USAddr.address in Q 

One could instead compute the difference using the EXCEPT clause Q EXCEPT Q . An alterative is to use a nested query 

It should also be noted that this example illustrates the computation of the set difference corresponding to SQL Q EXCEPT Q . The bag difference Q EXCEPT ALL Q is addressed in a later section. More formally let Q and Q be two queries that return the same set of attributes. The set difference between Q D and Q D denoted Q D Q D is the set of distinct tuples returned by Q D but not by Q D . The bag difference between Q D and Q D denoted as Q D Q D is obtained by taking the tuples in Q D and subtracting their multiplicities in Q D . Query DQ is said to be the set difference resp. bag difference between Q and Q if for every database D DQ D Q D Q D resp. DQ D Q D Q D .

It should be noted that conjunctive queries are not closed under difference. In other words a query Q Q may not be representable as a conjunctive query. The notation is utilized to allow NOT EXISTS sub queries. The difference query can be defined in the form DQ V c c . . . c c c . . . c where each cand c is a conjunct and the free variables present in c c . . . care disjoint from those present in c c . . . c by suitably renaming variables one can assume this without loss of generality .

The semantics of DQ V is to find the set of all values assigned to V such that the conjuncts c c . . . care satisfied but c c . . . c cannot. Conjuncts in the clause are called negative conjuncts and the rest are referred to as positive conjuncts.

Observer that the difference query DQ as written above is a straightforward or na ve set difference between Q and Q defined as follows 

The evaluation cost of a difference query is typically dominated by the number of joins which is roughly proportional to the number of atomic conjuncts it contains. Here difference component can produce a minimal difference query that minimizes the number of negative conjuncts. As a result it also tends to minimize the number of joins.

The minimal difference query generated by difference component can be defined logically as follows Let Q and Q be two conjunctive queries. Query DQ is a minimal difference query MDQ of Q Q if 1 DQ Q Q 2 the negative conjuncts in DQ are a subset of the conjuncts in Q and 3 there does not exist a query DQ such that DQ satisfies conditions 1 and 2 and contains less negative conjuncts.

By way of example consider the ongoing example concerning Q and Q . Another rewriting MDQ corresponds to the following conjunctive query and includes fewer negative conjuncts.

Referring now to a difference component is illustrated in accordance with an aspect of the subject innovation. The difference component includes a na ve difference generation component . The component generates a conventional standard or na ve difference query as is known in the art. In the ongoing example this corresponds to 

Upon receipt the partition component can partition conjuncts. More particularly negative conjuncts can be partitioned minimally so that no two chunks share free variables. As per the provided example the partition component can identify the fact that the negative conjunct S n p cc is not joined with any other negative conjuncts through free variables. Hence it follows that the predicate R n a cn S n p cc USAddr a can be split into the disjunction of two predicates R n a cn USAddr a and S n p cc since x y x y. As a result the above rewriting is equivalent to a union of the following two difference queries 

The partition component is also communicatively coupled to analysis component . Analysis component can receive retrieve or otherwise obtain or acquire a partitioned query from partition component . The analysis component can identify negative conjuncts that can be removed. The idea is that removing atom conjuncts corresponds to removing joins and hence can lead to improved performance. With respect to the above difference queries the analysis component can note that the query DQproduces an empty result because the negative conjunct S n p cc is inconsistent with the positive conjuncts R n a USA S n p cc . This inconsistency follows from the fact that Q S where

Minimal difference query generation component can generate a minimal difference query with redundant conjuncts removed. Generation component is communicatively coupled to both the analysis component and the na ve difference generation component . The generation component can receive retrieve or otherwise obtain the identity of redundant conjuncts from the analysis component . The component can also receive the na ve representation from the na ve difference generation component and generate the minimal difference query by removing the identified redundant conjuncts.

Turning attention to a query difference system is illustrated in accordance with an aspect of the subject innovation. The query difference system includes a receiver component and a constraint difference component . As described previously the receiver component can received retrieve or otherwise obtain or acquire two or more queries. For example the receiver component can receive query Q and query Q . The receiver component is communicatively coupled to constraint difference component . Accordingly the receiver component can transmit or otherwise provide queries to the constraint difference component . Similar to the difference component of the constraint difference component is operable to generate a minimal difference query that minimizes the number of conjuncts and as a result also tends to minimize the number of joins. However the constraint difference component can also exploit schema constraints to facilitate removal of more constraints based thereon. For instance knowledge of metadata such as key constraints foreign key constraints and functional dependencies can often further simplify the generated difference query.

Referring to the constraint difference component is illustrated in accordance with one aspect of the subject innovation. The constraint difference component includes a difference component as previously described. Additionally the constraint difference component includes and is communicatively coupled to functional dependency component and an inclusion dependency component . Functional dependency component aids the difference component by identifying conjuncts that can be eliminated based on functional dependencies including but not limited to key constraints. Formally let V v denote the fact that the values of variables in Vfunctionally determine the value of variable v. Component can use the functional dependency by noting that if all variables in Vare bound then v is determined and can be thought of as bound as well. This opens up the possibility of eliminating more negative conjuncts as illustrated by the example that follows.

Consider the ongoing example pertaining to Q Q . Suppose it is known or it can be determined that cname is the key of table R. Variable substitution can be applied and an extra bound variable set a can be generated. The two queries can be rewritten as follows 

The information determined by the functional dependency component can be provided to the difference component . The difference component can note that since variable a is considered as bound now the negative conjuncts can be partitioned into smaller independent partitions each with higher possibility to be redundant. Indeed as per the ongoing example the predicate R n a USA can be removed resulting in the following 

Inclusion dependency component can act similarly to further identify and aid removal of redundant conjuncts based on inclusion dependencies including but not limited to foreign key constraints. In the aforementioned example if it is known or can be determined by component that attribute address in R is the foreign key to relation USAddr for instance then it is known beforehand that all tuples in R can join with some tuple in USAddr. Accordingly Q is contained in Q and Q Q 0.

Formally let A and B be two relations not necessarily different . Let A V B V denote the inclusion dependency that the values of attributes in V must be included in the values of attributes in V . Consider a positive conjunct A V V and a negative conjunct B V V where Vand Vare two sets of variables. If Vcontains only free variables not occurring anywhere else the existence of tuple A V V according to the inclusion dependency implies the existence of tuple B V V . This constitutes a conflict that difference component can remove B V V upon generation of a minimal difference query.

Continuing with the previous example with respect to functional dependencies suppose it is known or it can be determined that the attribute address is a foreign key to relation S. Given the existence of positive conjunct R n a USA USAddr a can be removed and the result becomes 

It should be noted that the running time associated with the difference component and related algorithm is dominated by the time taken to check homomorphism. Let c be the number of conjuncts in Q and v and v be the number of free variables in Q and Q respectively. Finding homomorphism takes time v and homomorphism needs to be found for no more than c times. Thus the algorithm has a worst case time complexity of O c v .

Referring to a query difference system is illustrated in accordance with an aspect of the subject innovation. While previous systems and can deal with set semantics the innovative aspects can also be extended to bag semantics. Bag semantics differs from set semantics in counting duplicates. This has significant implications on query difference computation. System provides that extension in the form of transformation component communicatively coupled to the constraint difference component . Hereinafter it is first shown that the bag difference between two queries cannot always be written as a difference query. Next a subclass of queries where the bag difference can be expressed as a difference query is provided and the mechanism for generation of MDQs for such queries is presented.

Considering a class of 1 SQL queries where each relation occurs at most once the focus is on the case where rellist Q rellist Q . The transformation component can reduce the case to that of a set difference by suitable transformation. For example the transformation component can introduce id columns for all relations. The id functionally determines other attributes hence we can eventually apply a set difference means or mechanism.

By way of example a conjunctive query Q can be transformed by projecting the id column of each relation to the head of the query. This can be called Qas follows 

One should appreciated that query difference can be employed to improve view matching technologies. Conventional view matching techniques address only cases where a query is wholly subsumed by a materialized view. However one could utilize a view to partially answer a query and going to the base tables for example for the rest by posing a remainder query. This requires techniques that can compute an efficient remainder query for the input query and view s .

Referring to query and view portions are depicted in accordance with an aspect of the subject innovation. Let Q be a 1 SQL query and V be a materialized 1 SQL view. Suppose rellist Q rellist V . The problem pertains to rewriting Q utilizing V. As depicted in Q can be divided logically into two parts the intersection query IQ Q V and the remainder query DQ Q V. Since IQ is subsumed by V one would expect to evaluate it using V. A database can be employed to evaluate the remainder query DQ. Such a scheme can largely improve query execution efficiency if Q and V are highly overlapped and DQ can be computed efficiently.

Turning attention to a view matching system is depicted in accordance with an aspect of the subject innovation. The system includes an input component that receives retrieves or otherwise obtains or acquires a query and one or more views. The input component can provide this data to the intersection component and the constraint difference component communicatively coupled thereto. The intersection component can determine the intersection between the query and the view s . The determined intersection can be transmitted from the intersection component to the view map component . The view map component can then apply a view matching algorithm to the intersection and the view such that the intersection is rewritten in terms of the view. This new intersection representation is communicated to the query writing component . The constraint difference component determines the difference between the query and the view and produces a representation thereof. This representation is received or retrieved by the query writing component and together with the intersection is used to rewrite or generate a query as the union of the intersect and the difference.

To illustrate the operation of system consider the following based on the ongoing example. Q can be utilized to represent the query and a slightly modified version of Q as the view. The definition of the view V is shown below.

The intersection query can be written using V by adding the select predicate on R.country. The remainder query is generated by applying the bag difference algorithm. Hence Q can be written using V as follows 

It should be noted that when query Q and view V contain grouping and aggregation e.g. sum count min max . . . the system can proceed by first removing grouping and aggregation to extract the SPJ core of Q and V denoted as Qand Vrespectively. Thus view match component can rewrite Qusing V. Then to each input to the union all operation the grouping and aggregation can be added back. Finally the outer grouping and aggregation can be added to obtain the final aggregate.

The aforementioned systems have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet one or more components and or sub components may be combined into a single component providing aggregate functionality. The components may also interact with one or more other components not specifically described herein for the sake of brevity but known by those of skill in the art.

Furthermore as will be appreciated various portions of the disclosed systems above and methods below may include or consist of artificial intelligence machine learning or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Additionally it should be further appreciated that the methodologies disclosed hereinafter and throughout this specification are capable of being stored on an article of manufacture to facilitate transporting and transferring such methodologies to computers. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media.

Turning to a method of generating a minimal set difference query is illustrated in accordance with an aspect of the subject innovation. At reference numeral a na ve rewriting of the difference Q Q is generated. At the conjuncts in Q are partitioned. In particular each conjunct can initially form a partition by itself. For every two conjuncts that share the shave common free variables the partitions they belong to can be merged. This process can be continued until no more partitions can be merged. At numeral each partition can be analyzed to determine if any conjuncts are redundant contradictory or null. At a determination is made as to whether there are any redundant or like conjuncts. If no the method simply terminates. In such a case the na ve query is the minimal difference query. If yes then the method proceeds to reference numeral where a minimal difference query is generated with redundant negative conjuncts removed.

Referring to a flow chart diagram of a method of generating a minimal difference query exploiting constraints is illustrated. At reference numeral variables in Q and Q are renamed in accordance with functional dependencies. For example if Vfunctionally determines v then rename all occurrences of v using the same variable. At new bounded variables are generated for instance VV where for each variable v V there exists a set of variables VV that functionally determines v. At a na ve rewriting of the difference is generated. At conjuncts are partitioned. At numeral conjuncts are analyzed for redundancy contradiction or null. At a determination is made as to whether there are any redundant conjuncts. If yes a minimal difference query is generated without redundancies at and the method proceeds to . If no the method simply proceeds to . At reference numeral further redundant conjuncts are removed based on inclusion dependency. For example for each include dependency A V B V check if there is a positive conjunct A V V and a negative conjunct B V V where all variables in Vare free variables occurring nowhere else. If so remove B V V from Q Q .

Referring to an extended view matching methodology is depicted in accordance with an aspect of the subject innovation. At reference numeral grouping and aggregation are removed from a query and view. At the intersection query and difference query are generated utilizing view matching such as that described above with respect to method of . At numeral a check is made to determine if adding back the grouping and or aggregation will produce an appropriate result. If yes the method can proceed to where the intersection and difference query can be integrated to produce a new or modified query. If no the method will terminate. It should also be appreciated that adding back the grouping and or aggregation will produce inappropriate or incorrect results then the initial query can be returned upon termination rather than the modified query.

What follows is a brief description of experimental results. Aspects of the subject innovation can be implemented in a classical rule based query optimizer although implementation is not limited thereto. Additional operators are not required the cost of rewriting produced by the disclosed means and mechanisms can be evaluated utilizing existing techniques that today s commercial database servers utilize. For the experiments the techniques where implemented utilizing a client side implementation which naturally forms a component of an interactive data cleaning environment. Such implementation can also be useful in today s setting where the difference computation in the server is potentially expensive.

Two data sets were experimented on namely a Sales database on a real data warehouse and the TPCH benchmark. The Sales database is the one based on which we presented the ongoing example. The relation R has about fifty thousand tuples and S has about two million tuples. The TPCH database employed was of size 1 GB. The experiments were performed on a Microsoft SQL Server 2005 and ran on an Intel Pentium 4 CPU 3.40 GHz 1 GB RAM machine.

Turning to Table 1 below the na ve and set difference approaches where compared. As is evident the set difference approach of the subject innovation always performed better than the conventional na ve approaches event under different physical designs.

Referring to and charts and are illustrated. The experiments were run with the configuration where the result Q is materialized as a view. Chart illustrates the speedup of set difference over na ve approaches when the size of the relation R varies. In particular the size of the relation R was varied from 5000 tuples to 50 000 tuples. The chart shows the results where speedup is plotted against the number of rows in relation R in thousands . The set difference improved the performance by an order of magnitude. The speedup increased as the input size increased reaching a factor of 23.45 when the input was of size 50 000.

Chart shows the relationship between speedup and overlap. The variation between the speed up and the overlap between R and S was studied. As was expected as the overlap increases the difference Q Q becomes more selective and the speedup will also increase. The overlap between R and S was varied by adding a range predicate on R and changing the width of the range. As chart depicts as the overlap between two queries increased the speedup increased as well.

Next the effect of exploiting query difference for view matching was examined. The Sales database was used as described above. The query corresponds to that described above with respect to the view matching section. Further there was a clustered index on the USAddr.address attribute.

Experiments were also performed on the TPCH benchmark for decision support queries. Three combinations of queries and views were considered 1 The benchmark query Q coupled with a view over a subset of the lineitem table defined by a predicate on l shipdate 2 A join query that joins tables lineitem partsupp customer and supplier coupled with a view that joins lineitem with orders and 3 A group by aggregation query that finds for a subset of customers the number of lineitems ordered per customer coupled with a view that performs the same aggregation but restricted to Japanese customers. Japanese customers where identified by joining the customer table with the nation table. This choice of queries and views is intended to cover a span of queries ranging from simple to complex. illustrates a chart that plots the execution time of the queries under two settings without using the view and using the view as per the rewriting. Two things were observed. First for two out of the three cases there is a substantial improvement using the subject innovation with a speedup factor of 2.97 for the first query and 1.69 for the third query. This again shows that query difference can be exploited to further the scope of view matching technology. Additionally it was observed that for one of the queries using the subject innovation is more expensive because the anti join introduced turns out to be expensive. Accordingly the subject innovation can be employed based on a cost benefit analysis.

Finally note that the execution time of the rewriting of Q using V is an upper bound of the execution time of the difference query Q V The results imply that the subject innovation with respect to computing query difference also improves performance for the TPCH dataset.

The final experiment examined the rewriting efficiency of the subject query difference algorithm and view matching algorithm. Since the query difference algorithm is called as part of view matching the efficiency of the view matching is studied which is an upper bound on the efficiency of the query difference computation. This was studied by generating queries and views with varying number of joins. We fixed a schema of a large number of binary relations in the form of R A A . Queries and views were generated as the following for 1 n 20 a seed relation was randomly selected and a chain join of length n was generated. For each n multiple combination of queries and views were generated each expected to have n joins. The rewriting time was averaged over all these combinations. provides a chart that illustrates the results. Even with 20 way joins the rewriting time hardly exceeds 90 ms. This illustrates that the subject difference query algorithms to perform view matching adds negligible overhead especially for queries that are expensive to begin with.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the claimed innovation can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like displays e.g. flat panel and CRT speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems power modems and DSL modems ISDN adapters and Ethernet cards or components.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers .

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having or variations in form thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

