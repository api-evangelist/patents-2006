---

title: Method and apparatus for graphically constructing applications utilizing information from multiple sources
abstract: A software component and method for constructing computer applications running on different runtime environments, which consume services provided in multiple protocols. Usage of the component and method is preferably done by a content professional and does not require programming knowledge for supporting the runtime environments or the protocols.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08458647&OS=08458647&RS=08458647
owner: SAP Portals Israel Ltd.
number: 08458647
owner_city: Ra'Anana
owner_country: IL
publication_date: 20060307
---
The present invention generally relates to a method and apparatus for generating computer applications that utilize information from multiple diverse sources.

In environments such as large organizations using multiple data sources a known difficulty is the accessibility to existing information. Significant amounts of experience or prior knowledge about available data and used systems is required in order to access data including for example information about customers employees sales inventory billing bank accounts and the like. However even when such knowledge exists various systems do not necessarily provide compatible interfaces that enable automatic integration of information from multiple sources. Such systems communicate in various and possibly different protocols and do not always run on the same runtime platforms. When creating data access and integration applications a known methodology is to model an application once but generate it for various runtime platforms which use different execution mechanisms. For example a rich client application may run all application logic on the client while using the server only for persistence or state management while a thin client application may run its entire business logic in the server. The concept of common modeling and separate generation suffers from a number of drawbacks. First an application may be required to access back end services using different protocols depending on the specific runtime platform while keeping the runtime semantics the same for all used platforms. An application may be required to access a service using one protocol at one time and another protocol at another time. Therefore the protocol used to access back end services must be decoupled from the actual service consumed and from the client platforms. In addition certain platforms may suffer from performance degradation when using a generic modeling approach where known optimization techniques may fail to preserve model semantics and are therefore unusable in these scenarios. Thus in order to maintain the modeling semantics while keeping application performance reasonable some modeling aspects may also involve modeling of back end services.

In addition modeling of back end services and accessing services using multiple protocols and supporting multiple runtime environments require knowledge and skill in computer programming and non negligible effort. These factors necessitate professional computer programmers and time resources in order to efficiently produce applications answering specific needs. In addition such personnel is not necessarily a content specialist and needs cooperation with other professionals that possess accurate and up to date information about the customers needs in terms of information and presentation requirements.

There is therefore a need for a method and apparatus that will enable to efficiently construct applications running in different runtime environments and using different protocols to access data from multiple sources. Such method and apparatus should enable a graphical user interface and not require programming skills.

It is an object of the present invention to provide a novel method for enabling an application to consume services independent of the platform or the protocol. In accordance with the present invention there is thus provided a method for enabling one or more applications running in one or more environments to consume one or more services using one or more protocols the method comprising receiving one or more messages from the application identifying the protocol of the message performing structural parsing of the message to obtain a first parsed request performing contextual parsing of the first parsed request to obtain a second parsed request and sending the second parsed request to a service provider. The method can further comprise a receiving step for receiving one or more responses from the service provider one or more formatting steps for formatting the response to obtain one or more formatted response and a sending step for sending the formatted response to the application. Within the method the one or more formatting steps can be two formatting steps. One formatting step can perform structural formatting and one formatting step can perform semantic formatting. The method can further comprise the steps of modeling the application and generating computer code based on the modeling. The method can further comprise the step of compiling the computer code and generating the application. The method can also comprise the steps of uploading one or more applications to a server and storing one or more software components for enabling one or more applications to consume the service. The method can further comprise the step of running the application consuming one or more services using one or more protocols in the one or more environments. Another aspect of the disclosed invention relates to a data processing apparatus for enabling one or more applications running in one or more environments to consume one or more services using one or more protocols for transferring data the apparatus comprising one or more broker objects for receiving one or more requests using a protocol from the one or more applications running in the one or more environments and determining the protocol one or more broker protocols for structural parsing the request one or more request parsers for contextual parsing the request one or more service representing objects for communicating with one or more service entities and providing one or more responses from the service entity and one or more response formatters for formatting the one or more responses. The apparatus can further comprise one or more components for receiving one or more actions of a user and generating application code. Within the apparatus the user can be an application developer. The action can be of the group consisting of drag and drop choosing from menu mouse click keyboard stroke or voice commands.

Yet another aspect of the disclosed invention relates to a computer readable storage medium containing a set of instructions for a general purpose computer the set of instructions comprising receiving one or more messages from one or more applications identifying the protocol of the messages performing structural parsing of the messages to obtain a first parsed request performing contextual parsing of the first parsed request to obtain a second parsed request sending the second parsed request to a service provider receiving one or more responses from the service provider formatting the responses to obtain one or more formatted responses and sending the formatted responses to the applications.

The present invention overcomes the disadvantages of the prior art by providing a novel method and apparatus for automatic generation of computer program instructions to be used on multiple environments through multiple protocols.

The present invention comprises a computer program that enables an application developer to define generate and store an application that accesses data from multiple sources. The definition includes the data presented by the application the data flow and the user interface of the application including the presentation details and the response to external events such as mouse clicks and the like. The application is preferably generated through an automatic code generation and compilation of the generated code. The generated application implements the user interface and data flow as defined by the application developer and comprises a data processing apparatus that during runtime constructs objects that intermediate between the user interface and the data sources. For convenience the data processing apparatus is herein referred to as component. This code is not accessible to the end user of the application as well as to the application developer thus sparing both the bother of connecting different services employing different data transfer protocols and running on different runtime environments. The mediating component connects and resolves the unknown details resulting from the multiple runtime environments and multiple data transfer protocols possibly available for each service.

Making and using the disclosed invention is generally done in four stages. The first stage comprises writing a computerized tool which provide protocol free and environment free connectivity between one or more applications and one or more services. Executing the first stage further comprises writing a computerized tool which provides an application developer with a graphical UI for developing an application. This stage is done once and the developed tools can be used by application developers belonging to multiple organizations. During the second stage an application developer using the two sets of instructions develops one or more specific applications. For example a developed application can be intended for a commercial organization the application enabling an end user to see a profiling of customers according to their home address the articles bought by the customers or any other parameter. Since the application developer is not required to program in order to develop the application a domain or organization specialist rather than a programmer is a preferred professional for application development. At the third stage the developed application is deployed for usage preferably by a system administrator of the customer and at the fourth stage the application is used by one or more persons for example sales personnel within the commercial organization. The four stages are further detailed in association with below.

Referring now to which shows a typical environment in which the disclosed invention is used. An application developer is working on a computing platform designing and building an application which uses data acquired through communication channel from services running on servers which in turn communicate through channels and respectively with storages or storing relevant data. Once developer has completed his tasks developed application is ready and stored on storage and ready to be run by server . Then user using computing platform can run via connection application on server through communication channel and use the services offered by servers and . Neither developer nor user needs to know any details about the data transfer protocols used by the services or the runtime environments employed by computers or . Computing platforms and can be a personal computer a network computer a laptop computer a hand held device or any other computing platform provisioned with memory device not shown a CPU or microprocessor device and several I O ports not shown . Servers and can also be computing platforms as detailed above but can also be a DSP chip an ASIC device which store and execute commands. Each of storages and can be magnetic tape a magnetic disc an optical disc a laser disc a mass storage device or the like. Communication channels can be of any known technology including Internet Intranet over LAN WAN wireless network or the like.

Referring now to which shows a flowchart of the main steps in the implementation and usage of the disclosed invention. The steps are generally divided into four groups. Preliminary steps which are typically performed by an implementer of the invention application development steps which are typically performed by application developers using the invention deployment steps which are typically performed by a system administrator in which one or more applications constructed at steps are made available to users and runtime step which are typically performed by a user of the developed application. In Preliminary steps the implementer of the invention generates an application development platform which is later used by the application developer at step . Typically preliminary steps are performed once and their output is the application development platform. At step the invention implementer writes and compiles code of two types. At step the implementer writes and compiles a program for automatically generating code by application developers at steps . The code written at step enables the application developer to perform actions for modeling the application including dragging and dropping data items choosing from menus keyboard strokes and assigning behaviors to user s activities such as mouse clicks and provides a functionality to translate the actions into code that is later run at step . The implementer than compiles the code generating code into a component such as a library a DLL or any other executable component. Such code generation is known in the art and performed for example in environments such as visual basic DB schema creation code in SQL Server or the like. At step the implementer writes code for the mediating component which is responsible for communicating with various services using all supported protocols and runtime environments. The code is compiled and the resulting component is later deployed at step and run at step . The mediating code is further discussed in association with below. Application development steps are typically performed by an application developer using the application development platform developed at step and are typically performed once for each developed application. An application developer is preferably a person who possesses knowledge about the specific customer environment including the available data items the interrelationships between the data items and the needs and requirements of users who consume this data. When using the current invention the application developer is not expected to possess knowledge in computer programming. Application development steps comprise application modeling step during which the application developer planes the look and feel of the application including the elements shown on the screen the data items the relationships or conditions the data items represent their locations on the screen their reaction to users activities and the like. Once the application developer is satisfied he uses the mechanism supplied by the application development platform and generates code out of the actions at step . At step the generated code is compiled separately for each runtime environments such as HTML flash SAP HTMLB SAP Web Dynpro XAML and others thus generating one or more forms of the executable application referred to as application of . At step the compiled product of step is optionally associated with the mediating component generated at step so the compiled product can use functionalities supplied by the mediation component. Depending on the employed technology the association of the mediating component with the compiled product can be performed at compilation time deployment time or run time. At deployment step one or more of the forms of each application compiled at step is deployed on the server from which it is supposed to run so that the application is made available for intended consumers. The deployment process can take a number of ways such as uploading registering or the like. Further to deployment step the mediating component developed at step is installed on every computer running the applications developed at application development steps . Deployment steps are typically performed once for each runtime environment and each application. At step the application is run by an end user in a specific environment by executing the relevant version of the application from the server according to the desired runtime environment. During runtime the mediating component generates and uses the correct instances of objects according to the runtime environment and the used protocols without a requirement for awareness to the environment or the protocol from the application developer or the user. Step is performed any time a user wishes to run the application.

Referring now to showing the objects constructed and messages passed in the mediating component developed at step of to showing an example to a request sent to the mediating component and to showing an example to a corresponding response. The mediating component is preferably implemented in an object oriented environment and programming language such as C C Java or the like. As common in object oriented methodologies a unit such as the mediating component is described by the implemented objects and the messages passed between them. A description of the objects and their interrelationships is presented followed by a detailed explanation and example of the control flow and message passing.

A message representing a request from an application is sent to a broker object which is the main object that mediates between the application and the services. Broker object relates to by pointing referencing or any other method to a collection of broker protocol objects . Broker protocol objects preferably inherit from an abstract protocol object wherein each object implements the associated methods for a specific protocol. Broker object further relates to a collection of service representing objects wherein each service representing object is associated with one application specific service provided by an at least one service entity. Service representing object interfaces with the one or more service entities the interface comprising transferring the request for service in an appropriate protocol and receiving the return value or parameters in an appropriate protocol. Each service representing object relates to two additional objects a service specific request parser and a service specific response formatter . A user s request is translated by application to a message in any format such as XML Java SOAP Java RMI REST or the like sent in any relevant protocol such as HTTP HTTPS simple method calls or others. For example if the request is in XML format it can be sent as a byte stream in XML over HTTP format. shows an example to a request from a server to execute a function to provide a list of banks. The example request is in XML format and is sent by the user s browser in XML over HTTP protocol. Request such as the one shown in is sent at step by the application to broker . At step broker determines the protocol the request was sent in in the example of the protocol is XML over HTTP. Once the protocol is determined broker generates and calls or calls an already existing broker protocol implementing the methods for the specific protocol. In the example of broker invokes an XML over HTTP broker protocol to handle the request. Broker requests at step specific broker protocol to perform structural parsing of the request and retrieve the specific service associated with request since broker protocol is the entity that implements the determined protocol and can retrieve structural information from a request adhering to this protocol. Broker protocol which can parse a message in the specific protocol parses the message and determines the requested service. In the current example it is determined that the request is to execute a function. Once the specific required service is determined broker creates at step a specific service representing object . In the context of the current example such object will be a function executing object. Then at step a message to parse request is sent from broker to broker protocol . As mentioned broker protocol performs structural parsing. In the current example structural parsing comprises building an XML message from the original byte stream. The parsed request is sent at step to service object . Since the service and the protocol are known at this stage service requests at step that broker protocol being an XML over HTTP broker in the example generates an instance of a request parser and an instance of response formatter . Both instances are protocol and service specific. Therefore in the current example object is an XML over HTTP function execute parser and object is an XML over HTTP function execute response formatter. Instances and are sent to service object at step . Then at step service object asks request parser to contextually parse the request i.e. retrieve its type and the relevant parameters since request parser is aware both of the protocol and of the specific request. In the context of the current example the parser will determine as shown in that the request is to retrieve a list of banks and as shown in only those banks for which the country is US and to retrieve a maximum of rows. At step service object asks request parser for the retrieved parameters. At step once service representing object possesses all the relevant parameters object executes the service typically through interfacing or otherwise communicating with one or more actual service performing objects such as objects that communicate with one or more databases. In the case of a uni directional request wherein no response is expected by the application the process ends here without generating or sending a response. In other requests such as the current example at step service representing object sends a response received at step being a list of banks in the current case to response formatter . Response formatter being an XML over HTTP function execute response formatter can therefore format the response according to the desired protocol and generate the response shown in listing at item seven less than the allowed eleven US banks. At step service representing object asks response formatter for the formatted response and passes it to broker at step . At step broker passes the response to broker protocol for protocol related formatting. In the current context the formatting comprises translating the XML response into a byte stream. Once the byte stream is returned to broker at step it is sent back to application at step . In an alternative embodiment the response is sent directly from broker protocol to application . Occasionally for example when the request is a simple java method call the response is formatted into a java object which is returned to the application so only one formatting step is required. Preferably all mentioned objects are constructed during runtime for handling each request and are destroyed once the request is handled. Alternatively a methodology for using permanent objects can be designed which possibly saves time and processing power and enables session lasting logic which is kept within the objects and is not limited to a single request.

The present methodology enables the consumption of a multiplicity of services by a multiplicity of applications. Although the applications optionally run on different runtime environments and each service supports one or more protocols neither the runtime environments details nor the protocol details have to be dealt with by the designer of the application or by the user. Therefore the designer can be a content professional and work with a graphical user interface rather than use programming skills for constructing the application.

It will be appreciated to a person skilled in the art that the presented object and message diagram exemplifies a possible implementation of the invention and that other implementations using for example different distribution of the functionalities among objects or different calling orders are possible as well. Additional functionalities such as enabling internal states within the objects composing services and thus executing them within the same request enhancing performance for example by load balancing or other functionalities can be added to the apparatus.

It will be appreciated by persons skilled in the art that the present invention is not limited to what has been particularly shown and described hereinabove. Rather the scope of the present invention is defined only by the claims which follow.

