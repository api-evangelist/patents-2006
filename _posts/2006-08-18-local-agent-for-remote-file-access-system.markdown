---

title: Local agent for remote file access system
abstract: Systems and methods for remote file access are disclosed. According to an embodiment, a local agent polls a server for a task request at a polling interval scheduled by a schedule timer in accordance with a set of local agent and remote client preferences. The local agent is responsible for executing a task from the task request and causing a file to be uploaded to the server. The local agent uses a task processor for polling a server, a schedule timer for controlling polling, and one or more protocol stacks, such as TCP/IP and SOAP, for communicating with the server. The local agent can also interface with a MAPI database for message delivery.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09344482&OS=09344482&RS=09344482
owner: Benhov GmbH, LLC
number: 09344482
owner_city: Wilmington
owner_country: US
publication_date: 20060818
---
This application is a divisional application under 35 U.S.C. 121 of U.S. application Ser. No. 10 053 402 filed Jan. 17 2002 entitled LOCAL AGENT FOR REMOTE FILE ACCESS SYSTEM. This application claims the benefit under 35 U.S.C. 119 of U.S. Provisional Application Ser. No. 60 340052 filed Nov. 1 2001 entitled SYSTEMS AND METHODS FOR REMOTE FILE ACCESS which is incorporated herein by reference as if included in its entirety.

The invention pertains to computer resource management and access systems and in particular remote access to files stored in different locations.

An individual s home or work computer is typically used a central repository for information. Often however individuals do not work at the same physical site or much less with their repository computer at their fingertips. Rather an individual will work at one or more locations remote from their home or work computer and the computer being the central repository for information the user will need files or information stored in their repository computer.

There are a number of known solutions to this problem. The most common solution is the use of large file servers residing on private networks and some sort of network management software such at Windows NT . In such a system the individual s files are stored in a large shared disk system so that while working in a local site a user can logon and store and retrieve information on the shared disk usually from a desktop computer at a remote site. While on the road the individual may use a laptop computer that includes a wireless PSTN or LAN WAN communications card such as a PCMCIA card to dial up and connect to the network and retrieve and store files.

Known software systems that are commercially available to this end include the Windows NT operating system and the Terminal Services Client both by Microsoft Corp. in Redmond Wash. Another solution is PCAnywhere software available from Symantec Corp. in Cupertino Calif. Both of these systems involve maintenance of a real time connection between the client device needing access to the files and the server device which is communicatively coupled to the files . U.S. Pat. No. 6 131 096 by Mason Ng et al. which requires a special downloadable personal information manager executable and U.S. Pat. No. 6 131 116 by Mark D. Riggins et al. which requires special applet information before communications can be setup both issued to Visto Corporation shows an equivalent system. Basically these systems concern emulation of a desktop environment.

Other solutions we are aware of include WIPO publication WO01 59998 by Ash Gupte et al. for Etrieve Inc. This reference discloses a method and system for wireless receipt of electronic messages or e mail . In this system e mail messages are received by an e mail server where they are as is usually done stored with a unique record locator. After being saved the e mail server sends a notification signal to a wireless device with the unique record locator so that a user of the wireless device can initiate a one click return a signal indicating that the user wishes to receive the e mail at the wireless device from the e mail server.

WIPO publication WO98 49625 by Jonathan R. Engelsma et al. for Motorola Inc. discusses a system for accessing and transferring e mail messages from a private computer to a multiple access wireless communication system. Particular to the Engelsma et al. system is an information delivery agent and an internet interface. The information delivery agent is controlled by a server. Here information is retrieved via the information delivery agent which communicates via hypertext transfer protocol to an internet interface and the internet interface in turn to the private computer. E mail messages are converted to voice messages and then the voice message is automatically relayed to a mobile device.

U.S. Pat. No. 6 108 711 by Christoper C. M. Beck et al. issued to Genesys Telecommunications Laboratories Inc. discusses a multi media transaction processing system designed to share files of various media types between various layers and multiple parties to a business transaction by recording and extracting information from transactions querying records and threading records together. The Beck et al. system appears to be targeted more toward managing interactions and work flow between parties than it is toward providing access to resources.

U.S. publication US2001 0023448 by Musa Hanhan which says it is an improvement on the Beck et al. system discusses a proxy system whereby a worker remote from a communication center operates a workstation at the communication center through a light client or computing device. The Hanhan system is quite similar to the Beck et al. system but the Hanhan system is more focused on providing full and unfettered access to home center data and services. To this end Hanhan suggests that the proxy server establish and maintain a constant real time connection to a server or workstation at the home center over a two way data link so that software and data can be operated and accessed then transformed and sent to the light client.

We have invented systems and methods for remote file access. These systems and methods include a remote file access protocol a local agent architecture and methods and remote client methods. Aspects of our systems and methods are embodied in computer software. Features of each of the systems and methods are set forth below in the claims.

According to an embodiment the remote file access systems and methods are embodied in local agent software including a plurality of software modules the software comprising a transmission control protocol internet protocol stack for network communication with a server over a network an extensible markup language input output parser communicatively coupled to the transmission control internet protocol stack for breaking down data and commands a simple object access protocol interpreter communicatively coupled to the extensible markup language input output parser for creating file system instructions to poll the server for a task request and retrieve a file specified in the task request and a task processor communicatively coupled to the simple object access protocol interpreter for executing subsystem instructions and initiating poll commands based on a schedule timer. In one embodiment the local agent module can further include a communications module configured to provide a carrier for network communication to the server the local agent module configured to periodically connect to the server through the communication module at intervals set by the schedule timer.

In still another embodiment the local agent module can comprise a message application programming interface communicatively coupled to the task processor for allowing access to a message application protocol interface database.

According to another embodiment the remote file access systems and methods are embodied in a computer implemented method for a local agent comprising the acts of polling a server for a task request receiving a task request from the server executing a task from the task request uploading a file identified in the task request to a server waiting for a schedule timer to expire and repeating the above acts beginning with the act of polling.

According to one embodiment the local agent act of executing the task can include initiating a request to a subsystem for the file and receiving the file from the subsystem. In another embodiment the local agent act of executing the task includes initiating a request to a subsystem for the file instructing the subsystem to upload the file to the server and receiving an indication that the file was uploaded to the server. In yet another embodiment the local agent act of executing the task includes initiating a request to a message access protocol interface for the file from a message access protocol interface database and receiving the file from the message access protocol database.

According to another embodiment the remote file access systems and methods are embodied in a computer implemented method for a remote client comprising sending a task request to a server the task request identifying a file receiving a notification that the task request is complete and sending an instruction responsive to the notification concerning how to transfer the file identified in the task request. According to one embodiment the act of sending the instructing includes identifying another remote client to which the file is to be transferred. According to another embodiment the method further comprises polling the server for indication that the task request is complete wherein receiving the act of receiving the notification is responsive to the notification.

We have invented systems and methods for remote file access comprising a server a remote client and a local agent. These parts can be interconnected via a communications network. Files needed while away from a local desktop computer on which the local agent typically resides can be accessed by the remote client through a server preferably by way of an asynchronous communication protocol.

A system architecture a remote file access protocol server methods a database system local agent architecture and methods and remote client methods are disclosed to achieve this remote file access framework.

Turning first to the system configuration depicted under callout we begin with a server . The server is typically a web server and can run on a commercially available computer such as a Sun Microsystems Enterprise Server available from Sun Microsystems in Mountain View Calif. or a Dell or Gateway branded internet or application server. Such a system will include one or more microprocessors a volatile memory area a persistent memory area and one or more mass storage devices. One or more sections of computer program code or software either in a compiled or an interpreted form will run for instance in one of the memory areas to cause the microprocessor s to perform the sequences of operations and techniques described below.

The server should include a communications software stack such as an IP internet protocol stack and should be able to handle hypertext transfer protocol HTTP requests secure socket layer SSL transactions as well as a form of a standard generalized markup language SGML such as extensible markup language XML wireless markup language WML and optionally voice extensible markup language VXML . Preferably the variant of XML employed on the server is Microsoft s SOAP Simple Object Access Protocol although Java or X Windows could alternatively be employed. Hypertext markup language HTML files are preferably included on the server . The communications software stack and the programming languages mentioned above are generally known in the art of network communications and interface design and are widely available.

The server should further include a database management system such as Microsoft Corporation s SQL Server 2000 or a version of Oracle Corporation s in Redwood Shores Calif. flagship Oracle database running over an operating system such as Sun s Solaris or Microsoft s Windows NT operating system. Typically these commercially available database systems will include connectivity software for allowing one or more clients users logon privileges to the database so that instructions to and from the server can be answered and requested with respect to clients users that are logged onto the server .

A region of memory in the server is reserved for a task queue . The task queue is a special purpose memory structure for storing requests or tasks for a client user that logs on to the server . These tasks and the operation of the task queue will be described in further detail below. We note that the task queue can be an addressable part of the database or it can be a specially maintained region of memory in the server .

Files from the computer files are shown temporarily stored at the server . This is described in further detail below but we note that the files can be stored in the database a special memory region such as the task queue or another special memory region reserved for such files.

The server is preferably configured to be communicatively coupled with a series of clients comprising at least a remote client and a local agent . Connectivity can be maintained or provided through a TCP IP wireless access protocol WAP HTTP and or an SSL protocol as is depicted in the connectors between the various elements depicted in . Typically the server connections are maintained over a network for instance a wide area network WAN such as the Internet. If a remote client is to access the server through another network such as the public switched telephone network PSTN or a wireless device then an appropriate protocol is used and the server or an intermediary device handles the translation from the needed protocol and an IP protocol. In addition to connectivity features in the communications stack communication can be made using SOAP WML XML or VXML HTML programming languages.

Optionally the server can be configured to be coupled to a speech module which is a text to speech and speech recognition system. Such a system preferably implements a VXML 2.0 or higher standard such as one of the systems offered by BeVocal Inc. in Sunnyvale Calif. The speech module can be hosted on a separate server platform or it can be integrated into the server . What speech module does is provide a voice or tone activated series of menus for communication from client through the server via a standard telephone or a wireless telephone .

While applying equally to telephone and remote client if communication is maintained via a wireless carrier then any carrier can be used such as the well known and widely deployed GSM or CDMA standard systems as well as communications using the GPRS or Bluetooth standards. The speech module is further configured to read text from computer files to a listener on the telephone . The files are drawn from a memory location at the server and can be in a number of file formats such as text RTF Word WordPerfect and HTML formats. The speech module is configured to convert dial tone and speech from the phone remote client into HTTP requests such as POST or GET to the server .

Turning to the remote client it can be a portable digital assistant PDA such as products offered by Palm Inc. in Santa Clara Calif. or equivalent devices such as those offered by Compact Computer Corp. based in Houston Tex. or the Blackberry two way pager available from Research In Motion based in Waterloo Ontario. The remote client can also be a standard laptop computer or a standard desktop computer. Preferably the client includes a web interface means. The interface can be a standard web browser or another type of interface that allows at least minimal connectivity between a client server application implemented in a markup language such as HTML XML WML or another SGML variant.

The client is shown in a standard embodiment as having files . These files are from server copies from files and from computer files . If the speech module is employed however then the client does not need to have files since the file contents can be read to a user at a phone .

The local agent is another software module that is resident on a local computer or the home computer such as a personal desktop or work computer where a user s files are typically located. The local agent can also be resident on a local area network LAN to which the local computer where the files are typically located is connected or a local file server such as a database system or document management system are connected. Basically the local agent must be able to achieve file access to the user s home or local files. We will describe the local agent in terms of a local computer for the purpose of illustration.

As mentioned above files on a local computer are accessible by the local agent . The local computer is typically a host system for the software module that is the local agent so the local agent is installed and executed on the local computer . If the local computer is the host system for the local agent then most of the communications and standard software stack that are used by the local agent for connectivity and communication purposes can be found in the local computer . However as is mentioned above the local agent can be connected to the files by some other physical arrangement such as over a local area network or bus without necessarily using a full purpose computer. In such a case the local agent can include connectivity or communication software modules or the local agent can draw upon resources of another device upon which it is installed.

In a typical setup we envision three primary pieces of physical hardware that comprise the system in this example. First we have a remote client which is a PDA depicted as remote client . Second we have a server which is depicted and called out as ActiveRunner server . Third we have a local agent resident on a home computer which is called out as ActiveRunner agent on local system .

A user of remote client needs a file from her local system . At 12 03 PM she sends a task request for a particular file at act to the ActiveRunner sever . The ActiveRunner server receives the task requests and places it in a task queue. Previously the user configured her ActiveRunner agent on her local system to poll the ActiveRunner server every 15 minutes beginning at 12 00 AM. 

At 12 15 PM the ActiveRunner agent on the user s local system contacts the ActiveRunner server and checks to see if there are any task requests in the queue. This is depicted as act . The 12 03 PM task request is in the queue and received by the ActiveRunner agent.

The ActiveRunner agent on the local system processes the task request on the local system at act . For instance the task request might have been to retrieve a contract a Word file that the user was working on for a client. The Word file is returned to the ActiveRunner agent which in turn transfers or posts the file to the ActiveRunner server at act .

The ActiveRunner server stores the file and associates the file with the original task request. This association can be achieved by setting a notification status flag and indicating a location on the ActiveRunner server where the file is located.

At act the remote client again polls the ActiveRunner server to see if the task request is completed. The poll causes the ActiveRunner server to retrieve the Word file stored in the ActiveRunner server so that the file is downloadable by the remote client .

We note that in a presently preferred embodiment the ActiveRunner agent is in charge the agent decides when and how to connect to the server and process any task requests. Thus the agent can be operated independently of the server for control purposes.

Returning to we now describe an inventive asynchronous remote file access protocol that is our preferred embodiment of such a protocol used by the system . We describe this protocol with reference to the system architecture so we show dashed lines from the major components that indicate a start or stop point for communication. We note that we do not show start or stop points with respect to the speech module but this is only for simplicity. The speech module is an off the shelf component that is integrated into our system primarily for data translation purposes between the server and the client for situations where a remote user does not have access to a digital assistant laptop computer or another desktop computing device rather the user has primary access to a telephone .

Beginning with signal C the remote client sends a task request signal to the server . The task request signal C is received by the server and is then queued in the task queue . The local agent as part of its periodic poll of server polls the server with signal A. The signal A is received by the server which then checks its task queue for any task requests. The task request from signal C is located so the server sends or forwards the task request to the local agent at signal S.

The signal S is received by the local agent and processed. For instance the local agent generates a command to retrieve a local file from the computer and the local file is returned or identified to the local agent .

At signal A the local agent returns the task output file to the server with signal A. The server receives the signal A and sets a status notification flag in the task queue indicating that the requested task from signal C is complete together with a link to the file which is now stored on the server .

The server can then generate a notification signal S to the remote client . We note that the server can make a decision as to how the remote client is to receive the notification of the task complete signal. It can be a push type of task complete signal e.g. using telephone or a pull type of task complete signal depending on the preferences of the user at the remote client .

According to one embodiment when the notification signal S is received by the remote client it is processed by returning an instruction signal C back to the server . The instruction signal C indicates to the server how the task output is to be returned to the remote client . For instance a file might be instructed to be directly sent or it might be instructed to be read through the speech module to another person at particular telephone number at some location other than the user s location.

When the instruction signal C is received by the server it is processed accordingly and the task output here we refer to it as a transfer is returned to the remote client which can again be a remote client other than the remote client that initiated the original task request signal C as file transfer signal S.

An advantage of our communication protocol is that it is asynchronous meaning that a persistent connection between the various parts of our system or even any two parts of our system does not need to be persistently maintained the only exception might be where a circuit switched call is the carrier between the remote client and the speech module .

We note two other issues that we have considered. The first is security and the second is data or file synchronization.

As for the latter file synchronization can be achieved with a lock management system implemented on the server . Such systems are generally known in the art and some typical techniques of lock management are disclosed by Jim Gray and Andreas Reuter in their book Transaction Processing Concepts and Techniques Morgan Kaufmann Publishers San Francisco 1993 ISBN 1 55860 190 2 pages 406 429 which are incorporated herein by reference. As for how this fits into our protocol if an intent mode locking scheme is employed that is where lock modes specified according to the scope of use by the remote agent such as read or write then the intended lock mode can be passed with signal C. This lock mode can then be sent to the local computer which can maintain the lock modes so that the same file is not requested again by either the local computer or the remote client until the lock is released by synchronization of the file from the remote client .

Thus after we receive the file and make our corrections on the remote client we can then return the file in the same manner as we made the initial checkout following signals C and A. At signal S the updated file would be downloaded by the local agent where it would be updated into computer in files . The computer would release the lock and send a signal back to the server that the lock is released in which case a notification signal can be returned to the remote client . According to one embodiment a tiered lock management system can be employed wherein the server maintains a replication of the lock modes in its database based on the lock management information in the local computer .

Turning briefly to the former security issues where a firewall is employed with the files on the local computer it envisioned that the local agent will be placed behind the firewall. Where there is concern over an interloper receiving communications to the remote client a simple bit wise barrel shifting or more sophisticated encryption schemes such as public key private key pairs can be employed to maintain the security of the file or information transfers. Another option is to store files in a secured region of memory on the server using the Windows 2000 file system.

The software stack depicted in is shown in the order in which we have implemented our software architecture although other variations of this software stack could be implemented. We note that the drawing depicts each module in our software stack having two directional arrows between another software module this is to illustrate the manner in which data flow typically passes through each module as it flows through the software stack . Furthermore we note that software stack is a logical arrangement and that installation of the local agent on a computer can involve integrating the portions of the stack from the computer rather than being separately installed modules in short we use the resources available on the host computer to the extent possible where it is not possible we install the resources as shown in the stack .

First communication with the ActiveRunner server is achieved with a TCP IP transmission control protocol internet protocol stack. From this module of the software stack messages are parsed with an XML I O parser into message components. From there a SOAP interpreter handles the parsed messages and forwards them for actual processing to a task processor . For instance the SOAP interpreter interprets messages to or from the task processor for executing in the local computer subsystem operating system or basic input output system. Typically the task request from the ActiveRunner server is a SOAP structured request so the other layers are primarily for handling the carrier and packaging means for this SOAP request. 

The task processor can send or retrieve files from a local PC file system or provide functional calls into the hooks of a MAPI application programmer interface which is used to get into data and files stored in a local MAPI database .

A schedule timer is also shown. This timer is primarily for instructing the task processor to logon to the ActiveRunner server and check for task requests from the remote client or to upload files or information that may not have been transferred immediately when the local agent received the task request from the server .

Following the data flow back up through the various computer program modules of the software stack an electronic message is retrieved from the local MAPI database through the MAPI API . This was returned in reply to an inbound task request at the local agent .

The task processor prepares the electronic message into a SOAP XML format and posts the file back to the ActiveRunner server using the SOAP interpreter then the XML I O parser and then the TCP IP stack where the file is finally uploaded to the ActiveRunner server over the Internet.

According to one embodiment we have found that the Microsoft C 6 and C development kits are ideal for development of our various modules. As well the Microsoft .NET Mobile Software Development Kit works well for developing web based interfaces for the system parts.

Next we turn to which is a flowchart of an embodiment of the local agent software as implemented in the software stack depicted in .

We begin with act where general preferences for the local agent software are setup. For instance the software receives preference setup information from a user concerning the agent polling schedule of the server access numbers or IP addresses and other information concerning establishing a connection with the server . Furthermore the preferences may include file type information whereby the user tells the local agent software security information or remote access privileges for instance the agent software can receive a list of hard drives and folders where security is limited or restricted to the local computer from remote clients as well as public keys and private keys if encryption is employed.

In act remote clients can be setup. This can be done manually by configuring the remote client in the agent software or it can be done automatically. What is meant here is that remote clients can be setup and managed thereby giving a user of the local agent software the ability to individually tailor access security or file transfer type information for particular remote clients or globally setting such preferences with respect to a the local computer the local agent is associated with.

In act the local agent polls the server . This is done by logging on to the server typically using a user name and password pair via a modem or a LAN connection. At act a test is performed to determine whether a non fulfilled task request exists in the task queue of the server . If a task request does not exist then a wait state is entered in act where the local agent will logoff the server and then reconnect to the server once the next predetermined polling period setup in act has expired. However if a non fulfilled task request exists in the task queue then processing by the local agent software continues to act .

In act the task request is received sent or downloaded from the server to the local agent . In act the task request is parsed and executed which typically involves retrieval of a file from the local computer on which the local agent software is typically resident. And at act the task output is sent or uploaded to the server . We note again that this act can be performed while still logged on to the server or it can be performed after the next polling period has elapsed either way the agent software returns to act to wait for the next poll period to elapse.

In act preferences for the remote client are setup. This can involve establishing a return IP address e mail address pager number or telephone number to which task output from the local agent can be returned by the server . It can also involve establishing acceptable file types e.g. text HTML XML RTF Word voice etc. or rules for processing different file types e.g. file size file time parsing instructions special segmented delivery instructions etc. or rules for processing routing information if an error occurs. The setup preferences can also include rules for processing particular task requests that are uploaded to the server these rules can be used for determining whether to proceed to acts or after act which are described below.

In act the remote client sends a task request to the server . This task request is typically created as a result of the remote client receiving an input from a user usually a specific request such as get the e mail message from Jane Doe sent Feb. 1 2001 from my home computer entered through a web interface by a remote client.

Once the task request is sent to the server the remote client will wait for a reply from the server . According to one embodiment the remote client logs off of the server and the polls the server periodically to determine whether the task request was completed by the local agent . This process is depicted in optional alternate act depicted as individual acts and . However according to another embodiment remote client preferences established with the local agent or the remote client indicate that the server must notify the remote client when the task request is complete. This method is depicted a act where the remote client receives a notification from the server that the task request from act is complete.

At act having notification that that task request is complete a rule associated with the remote client is processed and instructions for delivery of the task output are returned by the remote client to the server . In act the remote client receives the task output from the server which usually involves downloading the requested file or information. From here the process terminates.

In act a test is performed to determine whether a client or agent is attempting to logon to the server . If a client is logging on then the process continues to client processing module otherwise it continues to agent processing module .

In the client processing module after the client has logged on then the task request is received in act . In act the task request is added to the task queue . And in act the client is logged out. Processing can continue to act .

In the agent processing module according to one embodiment after the local agent has logged on then the server first determines whether the logon is a standard poll of the server to determine whether any tasks are waiting in the task queue or if the logon is a file upload. According to one embodiment the two states are treated independently of each other meaning if you have one state then you do not have the other. In another embodiment the server first receives and processes the file uploaded by the agent and then checks the task queue for any new tasks that need attention.

According to another embodiment in act the poll is received. Task requests in a task list corresponding to the local agent are queried or looked up in the task queue in act . In act a test is performed to determine whether there are any outstanding tasks in the task queue . If there are no outstanding task requests in the task queue then the local agent is informed of such and logged out act . However if there are task requests in the task queue then processing continues to act .

In act the task request is sent using SOAP or XML syntax to the local agent . In act the completed task is received from the local agent typically this occurs by a file download to the server from the local agent . In act the server can lookup any user preferences or special instructions to the server that came with the task request and decide how to notify the remote client that the task is complete. In some instances a notification will be sent and instructions received but in other instances no notification is sent or the instruction is setup with the initial task request.

According to one embodiment if a notification concerning the task being complete is sent to the remote client then an instruction is received from the remote client thereafter indicating to the server how and where to send the task output file.

In act the task output is uploaded to the remote client and in act the original task request corresponding to the uploaded task output is deleted from the task queue . In act which can take place anywhere after act the local agent is logged out of the server .

Turning to it is a database systems schema we have developed according to an embodiment. The database which implements the schema as is mentioned above can be implemented in SQL Server 2000 which is available from Microsoft Corporation. The objective of the database is to provide a central repository for information concerning local agents and remote clients as well as tasks and notifications and the relationship of all of these entities to each other. Of particular advantage in our schema is the use special purpose tables as a server side cache means for storing temporary data on the server that is uploaded and in a transition state between the local agent more particularly a local computer and the remote client .

Primary keys for each table are indicated with a key icon to the left of the primary key field. Keyed lines with triangle like shapes at one end between the tables show the relationship between records e.g. one to many. Other lines with parallel slashes between particular fields in the table point out the joins between the respective fields in the tables. According to one embodiment not all of the joins shown in particular as is shown in the task and cache tables described below need to be maintained in the database system. The names of the fields are self explanatory and can obviously change between instances of the database or database schema .

We note that three identifying properties are exhibited in the tables First a userid field is the primarily link for a centralized set of tables and indeed most all of the tables in the database . Second a computerID field is used for identifying local agents and local computers which are roughly equivalent as the local agent resides on a local computer . Third a taskID field is the primary link between the task tables. Since the userid field is linked to the computerID field and the computerID field to the taskID field we are able to tie the local agent to tasks and the remote client to tasks and we do this in the database on the server .

According to one embodiment the task tables can include a remote clientID to identify a remote client that can tie back to a particular userid to the task. But for security purposes the taskID field itself can be used to identify the userid or remote clientID or computerID such as by appending values to one of the previously mentioned values to make the taskID and thus joining the tables through the prefix of the identifier .

Turning now to a detailed description of the schema table is a user table in it is stored information concerning particular users of the system . Typical user information is stored in this table such as contact information and billing information. A pricing plan table holds pricing information related to the various pricing plans available. Invoice and payment tracking tables can also be included in the schema . Also included are normalization or pull down tables which make data entry through an interface such as web interface on the server consistent and user friendly. Such a table is table which speeds entry of a state. Other normalization tables can also exist. We also note the existence of a pre signup table . This table is for temporarily storing user information for the user table prior to completing the signup task.

A set of notification tables and exist to assist the server in completing the remote file access protocol namely sending the notification signal to the remote client when a task is completed. These tables are joined to the user table through the userid field . Table is for storing general contact information for the alert while table is for storing specific alerts responsive to completed tasks. We note that the alerts can be specified or tied to tasks for instance with the addition of a taskID field in the notification tables in which case they might not be joined to the user table 

A set of task tables and essentially make up the task queue although the task queue can be a subset of the information stored in these task tables. The task queue can be a separate memory area that can be consistent addressed by the local agent and the remote client to retrieve task information the data in the task queue being continually updated from the task tables in the database .

Task requests from the remote client are uploaded into the task request table . Parameters for each task are stored in one or more records in the task parameters tables which is joined to the task request table through the taskID field . A server task table stores tasks that the server needs to perform which can be imparted based on the task request table there being a one to many relationship between table and respectively . As was the case with the task request table a server task parameter table exists to store parameters for the server tasks in the server task table .

Another set of tables and corresponds to retrieving e mail from the local computer . In particular table stores user information for retrieving the e mail while table is a server side cache for temporarily storing e mail that is retrieved downloaded by the server . These tables are linked back to the user table through the userid field . According to one embodiment an attachment table not shown can be joined to table the attachment table being configured to identify and store files attached to e mail.

Still another set of tables and includes local agent information for each of the local agents associated with a particular user. In particular table is primary agent table that corresponds to the local agent installed on a particular local computer . There will typically be one agent per computer. Tables and like table are server side cache tables for temporarily storing browse information corresponding to the file system directory and file structure in the local computer in table and files in table . Their primary relation is via computerID field .

An example of browsing is appropriate as it was first introduced above. Browsing is a standard task for our system while other standard tasks include e mail retrieval and file transfer . A task request from the remote client might be to retrieve a file but the file name and location may not be known by the user. In this situation the user will instruct the remote client to sent a task request to the server to browse the file system of the local computer . The task request will be stored in the task tables in database so that it is accessible in the task queue . When the local agent polls the server it will find the browse task waiting in the task queue and will retrieve from the local computer file structure information. This information will be uploaded from the local agent into the browse information table so that the remote client can navigate through the folder hierarchy this information corresponds to the files .

The remote client can then select a particular file from the information stored in the browse information table and create a new task request to send to the server . The new task request will be stored in the task tables and the local agent will poll the server recognizing the new task request in the task queue . The local agent will the receive the task request from the from the server and process the task. The particular file will in turn be uploaded to the server where it will be stored in the stored file table .

Notification that the task is complete will be forwarded to the remote client based on the information in the notification tables. The remote client can return instructions to the server on the particular delivery means desired for return of the task output file. Once the task output file has been transferred from the server to the identified remote client then the data in the server side cache tables can be deleted. According to one embodiment this data is deleted immediately. However according to another embodiment data in these server side cache tables can time out meaning that it will stay active and valid for a fixed expiration period. Employing a fixed expiration time can have the advantage of improving performance and response time in that statistically speaking once a user of a remote client has browsed the file system on the local computer there is a high likelihood that the user will again browse the file system.

According to another embodiment the schema can further included table for storing information related to file synchronization and remote client configuration and management as well as for task and resource scheduling beyond the data or information described above . For example the schema can include tables for managing an interactive mode between the local agent and either the server and or the remote client.

The systems and methods are described in relation to detailed figures of particular embodiments currently envisioned by the inventors. These figures and the accompanying detailed description are intended to be for illustration and not necessarily for purposes of limiting the invention except where expressly stated as such in the claims. Accordingly alternative embodiments in particular of the database schema and physical or logical software structures can be implemented without departing from the inventive concepts disclosed above.

Furthermore the methods disclosed herein are intended as computer implemented methods to be carried out on computer readable medium such as a medium stored persistently in a computer or stored and installed from a CD ROM or downloaded from the Internet. Thus it is intended that the methods disclosed above and claimed below are embodied in a computer readable medium that includes thereon computer program code or a computer software product configured to cause one or more processors the carry out the methods or protocols set forth in the claims. Because the design can be modules various means or programming modules can be included in the computer readable medium. As such it is not strictly necessary unless evident in the claims that all of the means or modules are stored in a contiguous stream of bits but can be broken up stored or taken from other programs associated with multiple microprocessors what matters is that all the pieces are accessible so that the methods can be performed.

