---

title: Method and system for sequential compilation and execution of rules
abstract: Systems and methods for matching objects against a set of rules are described. The present invention is a novel rule execution algorithm that generally operates with greater efficiency than known algorithms. The algorithm uses a test analyzer to determine the relationships that exist between pairs of tests within a ruleset. Each rule is then translated into loops and tests, and merged into a unified series of loops and tests using the output of the test analyzer. The algorithm then generates pattern matching code corresponding to the unified series of loops and tests for evaluation by a virtual machine, and auxiliary code that provides object manipulations and rule actions at the service of the pattern matching code. In its runtime, the algorithm loads objects into the pattern matching code through an access interface. The pattern matching code is then executed by the virtual machine against the loaded objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07809666&OS=07809666&RS=07809666
owner: International Business Machines Corporation
number: 07809666
owner_city: Armonk
owner_country: US
publication_date: 20061207
---
The present invention relates to algorithms that execute rules. More specifically this invention relates to systems and methods for matching objects against a set of rules.

Datasets are used in a wide variety of practical applications. Object models can be used to describe how datasets are organized. An exemplary object model in the e business domain would include a group of classes which may correspond to a group of tables containing data in a database. Each class contains a different set of data pertaining to for example customer personal information invoices or product inventory. These classes are related by common fields shared by the classes such as a customer number used in both the customer class and the invoice class or an item number used in both the invoice class and the product inventory class.

In this example a customer class would contain fields corresponding to columns in a table such as customer name customer number address and telephone number. The set of the aforementioned fields and the field types contained within each customer object would define the customer class. The individual objects correspond to rows of data in the table generally with values for each field associated with the object. For instance there would be an object for customer Allen and Allen s personal information would be stored as values corresponding to each of the name customer number address and telephone number fields.

Rules are used to organize objects. Rules act upon tuples which may comprise an object or a combination of objects. In many practical applications rules are used to segregate groups of data within datasets for use by the owner of the dataset. For example a retail business owner may want a set of customers to send marketing materials or to offer sales or promotions. To do so the retailer would use a ruleset to identify a subset of customers within the entire dataset.

Rules are composed of conditions which include one or more tests and one or more actions that are associated with the conditions. If the conditions of the rule are met then the action is performed.

There are several types of conditions commonly used in rules. These include simple conditions the exists condition the not condition and the collect condition. In order to process a given object a simple condition first determines if the object belongs to the desired class and then determines if the object satisfies the tests within the condition. The exists condition and the not condition operate upon a set of objects instead of a single object and determine whether or not the desired object exists or does not exist within the set. The collect condition functions by first constructing a set of objects from the dataset that satisfies an inner simple condition and then performs subsequent testing on the assembled set of objects.

Examples of rules include if the age of a person is not between 0 and 120 return an error or if the price value of a shopping cart exceeds 200 reduce the price value by 10 . In the preceding examples the if clause is the condition which must be met for the action to take place. The condition here is a simple condition because it acts upon a single object rather than a set of objects. Likewise the return and the reduce clauses are the actions which are executed when the conditions are true. Software platforms are currently used to build systems to work with sets of rules. One example of such a software platform is sold by ILOG Inc. of Mountain View Calif. under the title JRules.

To work with rules a software platform generally utilizes a rule language and a rule engine. A rule language is a computer language which allows description of the rules using formal syntax. A rule engine is the software that actually executes the rules in the order determined by a rule execution algorithm.

A rule execution algorithm generally converts the given rules written in the syntax prescribed by the rule language into an internal representation form reorganizes the rules through analysis and optimization and then executes them. Two examples of rule execution algorithms are known as the RETE algorithm and the Sequential algorithm.

It is believed that the RETE algorithm was originally described in Charles Forgy Artificial Intelligence 19 1982 at 17 37. Modifications of the original RETE algorithm are known in the art. The RETE algorithm generally works by first building a rule execution graph from the rules called the RETE network. In the RETE network each object is classified through a series of discrimination tests which organizes the objects based on one or more fields such as age and stores the results into a node or location in the RETE network. The discrimination tests in the RETE network are inferred from the conditions of the ruleset. The network is arranged such that the application of one rule may cause other rules to become executable a technique known as rule chaining. When a rule requires testing against multiple objects instead of a single object a join test is utilized. Join tests are more complex than discrimination tests but as indicated above are only used when a rule requires testing against multiple objects. When the rule conditions are met then the corresponding prescribed action or actions are executed.

The RETE algorithm is generally well suited for production rule sets and computation rule sets because it is stateful and maintains incremental behavior meaning objects can be added changed or removed from the data set while the algorithm is running.

A disadvantage of the RETE algorithm however is that it generally does not provide any efficiency advantages when the ruleset consists of simple compliance validation rules.

Compliance validation rules simply determine whether or not an object has certain characteristics or properties. Based upon the outcome of the condition a value is associated with the object. For example a set of compliance validation rules for a retailer could say if the customer has spent a total of 1000 or more his membership level value is gold if the customer has spent between 500 and 1000 his membership level value is silver and if the customer has spent less than 500 his membership level value is bronze. In this example the customer objects may or may not have membership level values stored before the rule is executed. If there are pre stored values when the rule is executed then the membership level value is overwritten for each customer object. A compliance validation rule example for the e business context is if the description of an item contains the terms sex or gun then the item is marked invalid. This rule could be used to screen classified advertisement or online auction listings before accepting the listing for example. Because compliance validation rules generally operate upon a single given object the RETE algorithm does not generally provide increased efficiency.

Another disadvantage of the RETE algorithm is that it lacks scalability because it can only in practice deal with several thousand rules. The RETE algorithm therefore cannot be used at all in some compliance validation applications which may involve hundreds of thousands of rules.

Another disadvantage of the RETE algorithm is that it cannot deeply optimize the ruleset because it is required to maintain consistency when objects are added deleted or changed. This in turn entails repeated execution of the ruleset when these changes are made resulting generally in further inefficiency.

A second example of a known rule execution algorithm is a sequential algorithm. In the sequential algorithm generally each of the given rules is converted to an if then function. Each object is then evaluated one by one against every rule. If for the first rule the condition is met then the corresponding actions are executed. Regardless of whether or not the actions for the first rule are executed the algorithm tests the object against the next rule. The process is repeated for every rule in sequence until all of the rules have been evaluated. The next object is then loaded and the rules are executed again until every object has been processed. The number of tests performed is therefore the product of the number of rules and the number of objects.

The sequential algorithm generally can handle hundreds of thousands of rules in compliance validation applications because it does not build a RETE network instead building loops and tests corresponding to each rule. The sequential algorithm also is generally transparent meaning it conceals the execution of the algorithm from the user and in doing so shields the user from the algorithm and engineering complexity. This engineering complexity includes dividing the generated code into segments that comply with the size restrictions of the programming language which would be difficult if the code was manually drafted. Furthermore the sequential algorithm can generally be configured for dynamic selection of the rules as active or inactive for each object resulting in higher accuracy of rule application and therefore greater efficiency.

The sequential algorithm has several drawbacks. First the algorithm s runtime can be significantly longer than other rule execution algorithms because every rule is applied to every object unless some dynamic selection is utilized. The sequential algorithm also is generally less efficient than other rule execution algorithms because it must evaluate all of the tests individually because sharing is not used to reduce the number of tests performed. The sequential algorithm is thus best suited for compliance validation applications.

Another drawback of the sequential algorithm is that it is restricted by the size limitations of the programming language it utilizes. For example in the Java programming language created by Sun Microsystems Inc. of Santa Clara Calif. code is stored in .class files which are restricted in size. If the code for the ruleset exceeds this size the sequential algorithm must decompose the code into multiple class files and chain them together a level of complexity that generally causes a loss of efficiency.

A further drawback of the sequential algorithm is that it does not support conditions that operate on a set of objects. As noted above examples of these conditions include the exists not and collect conditions. In order to process these types of conditions the sequential algorithm would need to be extended which would increase the algorithm s complexity and reduce efficiency.

The sequential algorithm does not manage loops on the dataset and generally requires a tuple to be passed. The tuples are generally generated by loops that are outside of the sequential algorithm. The tuples generally reflect every possible combination of objects in the dataset. Because the loops exist outside of the algorithm there is no way to share the loops for the rules that operate on the same subset of objects.

In view of the foregoing it would be desirable to have a rule execution algorithm that does not evaluate tests unnecessarily.

It would also be desirable to have a rule execution algorithm that is scalable to handle large quantities of rules without having to chain files together.

It further would be desirable to have a rule execution algorithm that is portable to different software languages.

It would also be desirable to have a rule execution algorithm with a shorter runtime when processing data than currently available rule execution algorithms.

It further would be desirable to have a rule execution algorithm that can directly operate upon a rule engine s working memory without use of a tuple generator.

It is therefore an object of the present invention to provide methods and systems that compile rules together to reduce the number of loops and tests evaluated.

It is also an object of the present invention to provide methods and systems that are scalable to handle large quantities of rules without having to chain files together.

It is further an object of the present invention to provide methods and systems that are portable to different software languages.

It is also an object of the present invention to provide methods and systems that have a shorter runtime when processing data than currently available rule execution algorithms.

It is further an object of the present invention to provide methods and systems that directly operate upon a rule engine s working memory without use of a tuple generator.

In accordance with these and other objects of the present invention methods and systems for a novel rule execution algorithm are described.

One embodiment of the present invention is designed to function with the Java software platform using the ILOG JRules software on a computer having a general purpose processor.

The present invention alleviates the problems associated with known rule execution algorithms. Accordingly the present invention allows sharing between rules which increases efficiency of the algorithm. Furthermore the present invention is scalable to handle large quantities of rules without chaining files together is portable to different software platforms generally has a short runtime compared to currently available rule execution algorithms and is able to directly operate upon a rule engine s working memory without use of a tuple generator.

A rule can be translated to a sequence of loops and tests. This is shown in which is an evaluation tree representation of an exemplary rule.

The exemplary rule shown in is that customers purchasing cars with price between 10 000 and 20 000 sold at vendor Alpha receive 2 cash back. The tuple in this example consists of a single car object. Evaluation tree displays this rule which is made up of loop and tests and . Loop starts a loop on the car objects. When a car object is loaded then the next step is to proceed to Test . Test determines for the given customer object if the vendor field has the value Alpha. If Test is true then the next step is to proceed to Test . If Test is false then the current car object does not comply with the rule and the next car object is considered. Test determines for the given customer object if the value of the price field is between 10 000 and 20 000. If Test is true meaning all tests are true then the action of giving 2 cash back is executed. If Test is false then the current car object does not comply with the rule and the next car object is considered.

The exemplary ruleset shown here consists of two rules. Rule composed of condition and action states that customers purchasing cars with price between 10 000 and 20 000 sold at vendor Alpha receive 2 cash back. The tuple for this rule consists of a single car object. Rule composed of condition and action states that customers purchasing cars sold at vendor Alpha with style code 2 signifying a convertible receive a free hard top. The tuple for this rule also consists of a single car object.

Before the novel rule execution algorithm is run test analyzer is used to determine the relationships between all of the tests contained in the conditions of the rules in the given ruleset. Test analyzer determines the relationships between the tests in the ruleset and temporarily stores these relationships for later use.

For example a given ruleset may have five single condition rules each condition containing two tests 1 if the name is Roger and age 10 2 if the name is Roger and age 20 4 if the name is Lucie and age 15 and 5 if the name is Lucie and age 20. Test analyzer used in the preferred embodiment described below would infer that for the first three conditions the tests on name are equivalent. Test analyzer would similarly identify that the age tests in conditions 1 and 2 are complementary. In this example it would also infer the following relationships disjoint between the name tests in conditions 1 3 and 4 subsumption between the age tests in conditions 1 and 3 disjoint between the age tests in conditions 2 and 3 disjoint between the age tests in conditions 3 and 4 equivalence between the name tests in conditions 4 and 5 and disjoint between the age tests in conditions 4 and 5 . Each of these relationships would be temporarily stored into data structure for later use by the rule execution algorithm. The form in which the relationships are temporarily stored can vary without affecting the operation of the present invention. One example of how the relationships may be stored is in the RAM of a computer.

Test analyzer in the preferred embodiment of the present invention is a syntactic and semantic analysis coupled with normalization techniques. One skilled in the art would recognize that test analyzer could test for a number of different relationships. In the preferred embodiment of the present invention five relationships between the tests are temporarily stored in data structure equivalence complement subsumption disjoint and unrelated. It is further preferred to use the test analyzer contained in version 6.1.2 of JRules software sold by ILOG Inc. For a more detailed description of these relationships please see the discussion corresponding to .

The novel rule execution algorithm of the present invention operates by first translating each individual rule to a coded series of one or more loops and tests which can be graphically represented as a sequential evaluation tree. The coded loops and tests of the first two rules are then unified into a single set of code. For the tests the unification is performed based upon the relationships between the tests within the rules which are recalled from data structure . For the loops the unification is performed when the datasets the loops iterate on are equivalent. Please see and the accompanying discussion which illustrate unification of rules based upon the preferred relationships.

The resultant code representing the previously unified rules is then unified with the next unprocessed rule s coded loops and tests. This process is continued until the entire ruleset is integrated into a single set of code graphically represented as unified evaluation tree having an organized series of nested loops and tests. Loop represents the loop on the car objects and correspond to the tests from rule on vendor and price respectively and action corresponds to action . Similarly loop represents the loop on the car objects and correspond to the tests from rule on vendor and style code respectively and action corresponds to action . The configuration of unified evaluation tree is explained in the discussion corresponding to .

While the unification process could be performed manually this is not practical when large numbers of rules are involved and can be highly time consuming. The present invention is desirable because the unification process may be performed transparently without user invention resulting in greater efficiency.

In an embodiment of the present invention it is possible to activate or deactivate rules before the actions associated with a given rule are performed. In this embodiment a check referred to as an activation guard test is done to determine whether or not the rule is active. If the activation guard test is true then action is taken when condition of rule is met. If activation guard test is false then rule is deactivated and action is not performed even if condition is met. This might be done when it is desirable to undertake the unification process only once and use the unified evaluation tree over an extended period of time. An example of this would be if a retailer that wished to offer a sale corresponding for instance to rule for a limited time. When the retailer wanted the sale to be active he could activate rule . Once the sale ended the retailer could simply deactivate rule instead of removing rule from the ruleset and repeating the unification process. This provides an advantage in circumstances where it may be undesirable to repeat the unification process.

In the second compilation step of the preferred embodiment of the novel rule execution algorithm the loops and tests of unified evaluation tree are translated into a pattern matching code for evaluation by a virtual machine VM and a satellite code that provides basic scripting services for pattern matching code . Pattern matching code utilizes the services the satellite code provides through the use of indexes. As the unified eval tree is compiled into pattern matching code during the second compilation step the novel rule execution algorithm generates the satellite code as indexed pieces of code that provide the necessary services. The satellite code at this stage remains platform neutral.

After it is generated the satellite code is adapted to the target platform in a second step. Using a translator which is known to one skilled in the art the satellite code is translated into auxiliary code for use by VM . In the preferred embodiment of the present invention the satellite code is translated to Java byte code using a byte code generator. The indexes of the services are not altered during the translation into auxiliary code thereby maintaining transparency for use by the pattern matching code.

Pattern matching code is a pseudo code representation of the unified evaluation tree that can be read by VM during the runtime of the novel rule execution algorithm. In computer science a VM generally designates a program capable of interpreting certain codes. In the preferred embodiment VM is written in Java. The VM of the present invention can be programmed to process code dedicated to rule execution and can also be programmed to iterate for e.g. search for objects in the Working Memory WM of the rule engine. One skilled in the art would recognize that the VM used by the novel rule execution algorithm can be written in many other programming languages. Use of pattern matching code is generally advantageous compared to translating rules directly into known programming languages because it is not restricted in size. This overcomes the scalability problems in known programming languages where the number of lines of code per class may be restricted. In the preferred embodiment pattern matching code is an int code rather than a byte code. One skilled in the art would recognize however that pattern matching code could be implemented in byte code and still function consistently with the principles of the present invention.

The first line of the exemplary pattern matching code above instructs the VM to not allocate memory for discrimination tests. When join tests exist the push memories code allocates local memory for discrimination tests. Here because no join tests are in the example ruleset the allocation is 0. The next line above instructs the VM to load the set of car objects from the WM to the top of the interpretation stack which is part of the VM using the push store command.

Line 2 of the exemplary pattern matching code commences an iterative loop on the car objects in the interpretation stack. Each car object is assigned to the 0th position of the tuple variable for processing by the pattern matching code. The first line of the exemplary pattern matching code also indicates that after the last car object has been processed the loop will exit by going to line 17 of the pattern matching code.

Line 3 of the exemplary pattern matching code instructs the VM to delegate to the auxiliary code the test of whether the current tuple is of the Car class or not using the type jump code. The TUPLE 0 Car code in line 3 is a text representation of the auxiliary code index for this test which is further discussed below. If the car type test is true then the VM proceeds to line 4 of the pattern matching code. Line 3 also instructs the VM that if the car type test is false the loop is to go to line 16 of the pattern matching code.

Line 4 of the exemplary pattern matching code instructs the VM to delegate to the auxiliary code accessing the weight field value of the current tuple using the push value code. The this.weight code in the line is a text representation of the auxiliary code index for accessing the weight field value. When the weight field value is returned by the auxiliary code the push value code loads the weight field value onto the top of the interpretation stack.

Line 5 of the exemplary pattern matching code instructs the VM to subtract 1000 from the value on the top of the interpretation stack using the table jump 1000 code. Table jump also acts as a switch statement testing the data at the top of the interpretation stack against the values 0 and 1. When equality is found between the value on the top of the interpretation stack and one of these values the VM advances to the prescribed line in the pattern matching code. For exemplary rule R when the weight field value is equal to 1000 for the current tuple the VM proceeds to line 7 of the pattern matching code. For exemplary rule R when the weight field value is equal to 1001 for the current tuple the VM advances to line 11 of the pattern matching code. If the value on the top of the interpretation stack does not equal 1000 or 1001 then the VM proceeds to line 6 which uses the jump code to instruct the VM to advance to line 15 of the pattern matching code.

By using the pop value code in line 7 of the exemplary pattern matching code the pattern matching code instructs the VM to remove the weight field value for the current tuple from the top of the interpretation stack. The VM then executes line 8 which uses the test jump code to instruct the VM to call the auxiliary code to test whether or not the vendor field value is Alpha. The code this.vendor.equals Alpha in line 8 is a text representation of the auxiliary code index for this test. If the value returned is false then line 8 instructs the VM to advance to line 16 of the pattern matching code. If the value returned is true then every test of R has been satisfied and the actions of the rule must be executed. This is done in line 9 where the VM is instructed by the rule then code to call the auxiliary code to execute actions A. The code R corresponds to a section of the auxiliary code that performs A. The VM then continues to line 10 of the pattern matching code which tells the VM to advance to line 16 of the pattern matching code using the jump code.

By using the pop value code in line 11 of the exemplary pattern matching code the pattern matching code instructs the VM to remove the weight field value for the current tuple from the top of the interpretation stack. The VM then executes line 12 which uses the test jump code to instruct the VM to call the auxiliary code to test whether or not the vendor field value is Beta. The code this.vendor.equals Beta in line 12 is a text representation of the auxiliary code index for this test. If the value returned is false then line 12 instructs the VM to advance to line 16 of the pattern matching code. If the value returned is true then every test of R has been satisfied and the actions of the rule must be executed. This is done in line 13 where the VM is instructed by the rule then command to call the auxiliary code to execute actions A. The code R corresponds to a section of the auxiliary code that performs A. The VM then proceeds to line 14 of the pattern matching code which tells the VM to advance to line 16 of the pattern matching code using the jump code.

Line 15 of the exemplary pattern matching code is then executed by the VM and the value at the top of the interpretation stack is removed by using the pop value code.

Line 16 of the exemplary pattern matching code instructs the VM to obtain the next car object from the interpretation stack load it into 0th position of the tuple for processing by the pattern matching code and return to line 3 of the pattern matching code.

If there are no more car objects to process then the for loop is complete. Line 17 which instructs the VM to remove the set of car objects from the interpretation stack using the pop store code is then executed. Line 18 of the exemplary pattern matching code instructs the VM to de allocate the local memory allocated in line 0 using the pop memories code. Line 19 ends the execution of the pattern matching code using the end code.

The binary jump code not included in the above example acts as a switch statement testing numeric data at the top of the interpretation stack of the VM against constant numeric values. Binary jump may also test the numeric data at the top of the interpretation stack against constant numeric intervals. These numeric intervals can either describe a range of numeric values such as 0 . . . 12 for example or they can describe an enumerated list of values such as 1 2 15.42 45 8 for example. Unlike the table jump code the binary jump code may be used to process non contiguous values or intervals.

The hash jump code not included in the above example acts as a switch statement testing the data at the top of the interpretation stack against constants that may be hashed. Hashing is a technique to classify objects that is known to one skilled in the art. Hashable constants are generally strings or dates.

Auxiliary code which is distinct from the pattern matching code is generated as part of the present invention to manipulate objects and execute rule actions which pattern matching code does not do. In the preferred embodiment of the present invention the auxiliary code is used to test an object s type obtain a field value from an object test an object or a group of previously matched objects and execute rule actions. The auxiliary code is linked to the pattern matching code by unique indexes assigned to the auxiliary code corresponding to each test or action. This is observed in the exemplary pattern matching code described above where the push value type jump test jump and rule then commands all reference auxiliary code indexes in their parentheticals. A benefit of this indexing system generally is that the auxiliary code may be altered i.e. changed to a different programming language without changing the pattern matching code as long as the indexes are not altered.

In the preferred embodiment of the present invention auxiliary code is generated in Java byte code and stored in Java class files. Java source code is generally not generated. The present invention is not limited to this embodiment and may be written in any language such as for instance in Microsoft .NET Intermediate Language MSIL developed by Microsoft Corp. of Redmond Wash.

Once the previous two compilation steps i.e. generating a single set of code from the ruleset and translating the single set of code into pattern matching code and auxiliary code are performed the runtime of the novel rule execution algorithm is started when the user triggers the pattern matching algorithm using an access interface. In the preferred embodiment of the present invention the access interface is a software application programming interface API .

VM then executes structured pattern matching code which performs the tests from the applicable rules on the objects in the dataset. The objects are obtained from working memory in the preferred embodiment of the present invention. One skilled in the art would recognize that working memory is exemplary and may be substituted with any data structure. Whenever a test or a value is needed VM calls auxiliary code to perform the test and return the necessary values.

The present invention is generally advantageous over known rule execution algorithms because the unification process leads to optimized loops that eliminate the unnecessary tests that are executed in the sequential algorithm generally resulting in greater efficiency and a faster runtime. The present invention generally is especially advantageous at optimizing loops that operate on the same objects.

The present invention also has the advantage of high portability because the virtual machine and pattern matching code are independent of software platform. Use of int code and a VM avoid the scalability problems of the sequential algorithm where efficiency is lost because the code must be broken into chained classes. Also because a RETE network is not generated at runtime the present invention can handle many more rules than the RETE algorithm. Also the present invention is able to operate upon a rule engine s working memory without use of a tuple generator resulting in greater efficiency than the sequential algorithm.

The compilation time for the present invention in many cases may be longer than known rule execution algorithms. However because the compilation time only occurs once and the runtime occurs for every execution request this is not generally a significant disadvantage.

As discussed above during the compilation phase of the present invention the coded loops and tests of the individual rules are unified into a single set of code starting with the first two rules in the ruleset. Before the present invention starts unifying tests it is preferred the conditions of the rules are examined to determine if they operate upon the same class or not. For instance two exemplary rules may be expressed in the following form 

The sharing of loops as implemented in the present invention yields greater efficiency than the sequential algorithm where two separate loops would have to be executed.

If the conditions of the two rules that are being unified operate on different classes under the present invention the loops are not unified and are executed sequentially. For instance two exemplary rules may be expressed the following form 

As stated above there are five test unification rules in the preferred embodiment of the present invention equivalence complement subsumption disjoint and unrelated. When two rules have tests that are equivalent the test is executed only once whereas in a sequential rule execution algorithm the test would be performed twice once for each rule. The reduction in number of tests executed generally results in greater efficiency.

When two tests are complementary they are unified into a single test with actions resulting from either outcome of the test. This is shown in as only test which determines if the weight field value is less than 1000 is applied. In a sequential rule execution algorithm there would instead be two separate tests checking the weight field value to determine first if it was less than 1000 and then if it was greater than or equal to 1000.

When the outcome of Test is true then Action increasing the price field value by 5 is executed. When the outcome of Test is false meaning the weight field value is equal to or greater than 1000 then Action giving 2 cash back to the customer is executed. As noted above this test unification prevents the novel rule execution algorithm from running the two aforementioned tests on the weight object separately generally resulting in greater efficiency than the sequential algorithm.

The price field value tests of the first and second rules in have a subsumptive relationship where the price field value test for the first test is the supertest and the price field value test for the second test is the subtest. As illustrates supertest which determines if the price field value is between 0 and 40 000 is applied first in accordance with the unification rule for subsumption. If supertest is true then and only then is subtest applied. If supertest is false then the current car object does not comply with any of the rules and the next car object is considered. If subtest is true then sequence node is executed meaning that the action from the first exemplary rule giving 0 financing to the customer and then the action from the second exemplary rule giving 2 cash back to the customer are executed sequentially. If the conditions of subtest are not met then only action from the first exemplary rule giving 0 financing to the customer is executed. Under the subsumptive test unification rule of the present invention the subtest is therefore only run in cases where the supertest is true. This results in fewer tests applied and greater efficiency than a sequential rule execution algorithm where both the supertest and the subtest are applied even when the supertest is false.

Node represents the loop on the car objects that is common to both of the aforementioned rules. For each car object the next test is performed upon the vendor field value. The rules contain tests that are disjoint as to the vendor field value and this is displayed at switch node . If the outcome of disjoint test is that the vendor field value is Alpha then predicate test is executed meaning that the weight field value is tested to determine if it is less than 1000. If predicate test is true then action is executed and the price field value is increased by 5 . If predicate test is false then the current car object does not comply with the rule and the next car object is considered. If the outcome of disjoint test is that the vendor field value is Beta then predicate test is executed meaning that the weight field value is tested to see if it is greater than or equal to 1000. If predicate test is true then action is performed and 2 cash back is given to the customer. If predicate test is false then the current car object does not comply with the rule and the next car object is considered. This represents an efficiency improvement over sequential rule execution algorithms which would instead execute separate tests on whether the vendor field value was Alpha and whether the vendor field value was Beta in sequence.

Nodes and are common to both rules they correspond to the loop on the car objects and the test to see if the vendor object s value is Alpha respectively. Because the tests on price and weight are unrelated they are performed in sequence which is represented at sequence node . First test tests to see if the price field value is between 10 000 and 20 000 and if the test is true then action is performed and 2 cash back is given to the customer. If test is false then the current car object does not comply with the rule. Next test tests to see if the weight field object is less than 1000 and if the test is true then action is performed and a free 4 year warranty is given to the customer. If test is false then the current car object does not comply with the rule and the next car object is considered.

Applying the relationships discussed to the following example the unified evaluation tree of the present invention can be generated as described below. For this example a ruleset of five rules each with a single condition will be used containing the following five conditions discussed in the context of the test analyzer of 1 if the name is Roger and age 10 2 if the name is Roger and age 20 4 if the name is Lucie and age 15 and 5 if the name is Lucie and age 20. In the first compilation step of the novel rule execution algorithm as applied to this exemplary ruleset rules 1 and 2 are unified. Pseudo code illustrating this unification U may be written in the following form 

The next step in the unification process of the present invention for this example is unification of U the unification of rules 1 and 2 with rule 3 . Pseudo code illustrating this unification U may be written in the following form 

The next step in the unification process of the present invention for this example is unification of U the unification of rules 1 3 with rule 4 . Pseudo code illustrating this unification U may be written in the following form 

The last step in the unification process of the present invention for this example is unification of U the unification of rules 1 4 with rule 5 . Pseudo code illustrating this unification U may be written in the following form 

Test is the age field value test from line 4 of U. If test is true then test the age field value test from line 5 of U is executed. If test is true then sequential node is executed and Action and Action are executed sequentially as is seen in lines 6 7 of U. If test is false then only Action is executed in accordance with lines 8 9 of U. If age field value test is false then Action is executed in accordance with lines 10 11 of U.

Node represents the disjoint relationship between the age field value tests described above as the switch statement in line 14 of U. Location is case 15 from line 15 of U and action is Action from line 16 of U. Likewise location is case 20 from line 18 of U and action is Action from line 19 of U. which is the unified evaluation tree corresponding to the unified ruleset U illustrates how the unified evaluation tree of a ruleset corresponds to a series of loops and tests in accordance with the principles of the present invention.

It should be noted that under the unification rules of the present invention test sharing is recursive meaning that it may occur at any nested level. For instance two equivalent exemplary rules may be described by pseudo code of the following form 

It should also be noted that under the unification rules of the present invention loop sharing is recursive meaning that it may occur at any nested level. For instance two exemplary rules with equivalent conditions may be described by pseudo code of the following form 

The present invention also supports the unification of heterogeneous rules. For instance two exemplary heterogeneous rules may be described by pseudo code of the following form 

The present invention is able to operate on a set of objects which as observed in the background section can not be done by the sequential algorithm. Furthermore the present invention is able to use discrimination tests to implement join tests an optimization used in the RETE algorithm but generally not used in the sequential algorithm. For example a rule may state that when a person has the age field value of 10 and an account balance greater than 10 000 then a promotional coupon is given to that person. This exemplary rule operates upon two classes the person class and the account class and may be expressed in pseudo code of the following form 

The present invention is able to implement and unify conditions that operate on sets of objects. For instance two exemplary rules may be expressed in the following form 

The present invention is able to implement and unify collect conditions. For instance two exemplary rules may be expressed the following form 

The present invention supports use of the in construct. For instance two exemplary rules may be expressed in pseudo code of the following form 

The present invention supports use of the from construct. For instance two exemplary rules may be expressed in pseudo code of the following form 

While a preferred illustrative embodiment of the invention is described above it will be apparent to one skilled in the art that various changes and modifications may be made therein without departing from the invention. The appended claims are intended to cover all such changes and modifications that fall within the true spirit and scope of the invention.

