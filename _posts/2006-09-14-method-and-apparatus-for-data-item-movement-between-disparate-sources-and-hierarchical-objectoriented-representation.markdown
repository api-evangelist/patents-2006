---

title: Method and apparatus for data item movement between disparate sources and hierarchical, object-oriented representation
abstract: Data moves between multiple, disparate data sources and the object-oriented computer programs that process the data. A data access server is interposed between the object-oriented programs and the data sources, and acts as an intermediary. The intermediary server receives requests for data access from object-oriented computer programs, correlates each request to one or more interactions with one or more data sources, performs each required interaction, consolidates the results of the interactions, and presents a singular response to the requesting computer program. The consolidated response from the intermediary server contains data items requested by the computer program, information regarding the hierarchical topology that relates the data items, and an indication of the possible object types that might embody the data items. The application program receives the consolidated response and builds an object hierarchy to embody the data items and to interface them to the rest of the application program. The class of an object used to embody data items is selected at execution time from a list of possible candidates.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07917538&OS=07917538&RS=07917538
owner: Bank of America Corporation
number: 07917538
owner_city: Charlotte
owner_country: US
publication_date: 20060914
---
This application is a divisional of U.S. patent application Ser. No. 10 299 456 filed Nov. 18 2002 which is a continuation of U.S. application Ser. No. 09 132 813 filed Aug. 12 1998 now U.S. Pat. No. 6 499 036 B1 issued on Dec. 24 2002. All of these applications are hereby incorporated by reference in their entirety.

The invention relates to data processing systems in particular data processing systems using object oriented computer programs to access managed data.

Large modern business organizations are in a constant state of flux. The makeup of the business organization changes with every merger acquisition and divestiture. Related data assets come and go accordingly. The rapid pace of change represents a difficulty in keeping enterprise computer applications in synchronization with the changing set of disparate data sources with which they may be forced to contend.

Modern business enterprises face another challenge in matching their computer applications to their data assets. The majority of data assets are maintained using traditional data management systems and techniques. Some reasons for this are the huge investment made in building and maintaining the existing assets the proven reliability of the existing systems and the cost of migrating to more modern systems. Object oriented databases are on the horizon moving from the laboratory to the field but have yet to make serious inroads to widespread moving from the laboratory to the field but have yet to make serious inroads to widespread commercial use. But while structured data management systems have lagged in adopting an object oriented design paradigm commercial application software designs have fully embraced it. Use of object oriented programming languages such as C and Java proliferates. Thus modern business organizations face a schism between the design paradigm underlying their application software and the design paradigm managing the data on which the software is to operate.

Attempts have been made to bridge the gap between legacy data management systems and object oriented programs. U.S. Pat. No. 5 499 371 Henninger for instance discloses method and apparatus for automatic generation of object oriented source code for mapping relational data to objects. The invention of Henninger can greatly speed the work of a programmer by automatically generating source code that supports a fixed correspondence between object classes of the source code and the data fields managed by a traditional structured database system. The resultant source code is combined with other source code created by the programmer and compiled into an executable computer program. Changes at the structured database can however necessitate regeneration of the object class source code and recompilation of every program in which it is incorporated. This threatens a software maintenance burden to the dynamic business organization. Consequently there is a need in the art to bridge the gap between the multiple disparate and ever changing data sources of a business and its object oriented application software while minimizing the impact of and maximizing the flexibility in responding to changes in the data source makeup.

The present invention is directed to the movement of data between multiple disparate data sources and the object oriented computer programs that process the data. A data access server is interposed between the object oriented programs and the data sources and acts as an intermediary. The intermediary server receives requests for data access from object oriented computer programs correlates each request to one or more interactions with one or more data sources performs each required interaction consolidates the results of the interactions and presents a singular response to the requesting computer program. The consolidated response from the intermediary server contains data items requested by the computer program information regarding the hierarchical topology that relates the data items and an indication of the possible object types that might embody the data items. The application program receives the consolidated response and builds an object hierarchy to embody the data items and to interface them to the rest of the application program.

The class of an object used to embody data items is selected at execution time from a list of possible candidates. The same data access request made by the same program on two different occasions could result in objects of different classes being used to embody accessed data items because of a change in the data available over time.

A configuration database stores information about the types of data access requests that application programs can make to the intermediary server the data sources with which the intermediary server interacts and the types of interactions that are possible. The user of a computer program with a graphical user interface maintains the contents of the configuration database. The configuration database may include procedural scripts that permit detailed and conditional control over the work performed by the intermediary server to satisfy a data access request.

Embodiments employing the present invention may permit an application program to progressively augment a programming object with data items retrieved over multiple data access requests to the intermediary server. Moreover the process of augmentation may result in some embodiments in the mutation of the underlying object from one class to another. In this way the set of behaviors for a programming object can adapt to match the set of data items the object contains.

These and other purposes and advantages of the present invention will become more apparent to those skilled in the art from the following detailed description in conjunction with the appended drawings.

Where the same element appears in more than one figure the same number designates the element is each figure.

The present invention is useful in moving data items between their locations in permanent storage and locations in temporary storage where they can be manipulated by user application programs. Permanent storage also known as persistent storage maintains data over time i.e. from one computing session to another. Permanent storage in a computer system may physically reside on mass storage devices such as magnetic disks. Temporary storage also known as transient storage maintains a data item for the time that it may be actively used and manipulated by an executing computer program. Temporary storage in a computer system may reside in the main memory devices of a computer such as DRAM integrated circuits well known in the art. User application programs contain computer instructions in a logical arrangement that carries out the data processing work required by the user.

A modern user application program seldom contains the specific computer instructions to directly access data items on the physical storage devices where the data items permanently reside. Rather a modern user application program invokes the execution of computer instructions contained in external software such as an operating system or database manager to mediate between a copy of the data item in permanent storage and a copy of the data item stored in temporary storage for the particular benefit of the user application program.

More specifically depicts that a plurality of transient data items embodied by programming objects on client computer are persistently maintained by multiple independent data sources . Object embodies data items A A A and B. Data items A A and A are maintained in persistent record by Data Source A. Data item B is maintained in persistent record by Data Source B. Object embodies data items D D D and D which are maintained in persistent record by Data Source D. Object embodies data items C C C C and C which are maintained in persistent record by Data Source D. In summary 3 programming objects embody transient data items maintained among the persistent records of 4 different data sources and a single object may embody transient data items from more than one data source e.g. object . It is noteworthy that the present invention imposes no rigid correspondence e.g. one to one between the data items from a single data source or data source record and the data items embodied by a programming object. This represents an advantage of the present invention.

To mediate between the transient and persistent copies of the plurality of data items embodied by programming objects and maintained by the plurality of data source computers client computer engages in a single client server CS transaction with server computer . A transaction comprises the generation of a request by a service requestor computer program the sending of the request to a service provider computer program processing of the request by the service provider to generate a response and the sending of the response from the service provider to the service requestor. Server computer processes the transaction request received from client computer by engaging in a plurality of server source SS transactions . Server computer thus acts as a data access mediator between a client application program and data sources. Server computer processes the transaction request utilizing information loaded into memory from a configuration database . Information from configuration database permits interpretation of the CS transaction request and resolution to a corresponding set of SS transactions.

For example consider the case where client computer desires to retrieve data items illustrated for programming objects from the data sources i.e. to make an inquiry. Client computer sends the request portion of a CS transaction to server computer . Server computer receives the request and identifies and interprets it based on information contained in configuration database . Information from configuration database also informs server as to the format of the response expected by client computer . Server prepares to generate the response by building data container objects with a topology that corresponds to the response format. In the presently described embodiment the data container and response format topology also corresponds to a topology of relationships between programming objects that will embody the data items in the client computer .

Program logic executing on server resolves the request of CS transaction down to atomic SS transactions . Server initiates SS transaction by sending a request to Data Source A that will return data items A A and A from persistent record . Data Source A may generate a response to server that contains all of the data items from record or only the requested data items. After Data Source A sends the response portion of transaction to the server program logic on server will isolate the desired data items i.e. A A and A out of the transaction response and store them in container object . Server then repeats the process for each of transactions and sending a request to the data source receiving the response and moving data items as necessary into the appropriate data containers .

After the last SS transaction is completed and its response data items D D have been moved into data container server transforms the data container contents and topology into a data stream. The resulting data stream is the response portion of CS transaction that is sent from server to client computer . Client computer receives the response data stream that consolidates the multiple SS transaction responses from the disparate data source computers . Program logic in software running on client computer processes the data stream to extract the data items it contains and embody them in programming objects .

In a preferred embodiment employing the present invention programming objects are constructed as a result of processing the response data stream for CS transaction . The specific class used to instantiate a particular programming object is selected at instantiation time i.e. dynamically during execution of the program and not statically during its development. A class serves as the definitional model for the object to be created. The class selected is determined by the field types of the data items contained in the response stream. For example programming object is instantiated from class Customer because of the field types associated with data items A A A and B. If for example object represents a banking customer and data item B contains the customer s password and an inquiry transaction fails because record was previously deleted so that no password data item is sent to the client computer in response to transaction then programming object may instantiate from the UnsecureCustomer class rather than from the Customer class because of the missing password data item. It is fundamental to object oriented programming that the class of an object determines the properties it can maintain and the behaviors it can perform which together determine its data processing characteristics. Instantiation under the UnsecureCustomer class could produce an entirely different set of behaviors for object than instantiation under the Customer class such as behavior that fails to authorize use of an automated teller machine. To pursue the example further if transaction occurs again for the same customer at a later time and if record had been restored in the meantime then object instantiates from the Customer class and normal ATM authorization resumes. The ability to determine object class at execution time based on the types of data items instantly available represents a further advantage of the present invention.

Execution environment includes data source computers server computer and client computer . Server computer includes DOM software . Client computer includes application program . Data source computers include data access software not shown . Application program includes program instructions of an FDO component and programming objects .

Configuration database and Application software participate in both the development and execution portions of the operating environment . Use of the development environment generally precedes use of the execution environment . The development environment is used to create and maintain application software and the configuration database . The application software and configuration database created and maintained by utilization of development environment are used in the execution environment to control operation of the client and server computers respectively.

Developer workstation is a general purpose computer such as a desktop personal computer. A software developer uses developer workstation to execute GUI based configurator software to create and maintain the contents of configuration database . The configuration database contains information about how a client program can request data services from the server and how the server can fulfill those requests using the disparate data sources . After knowing information loaded into configuration database an application developer can use workstation to create client application programs that will carry out transactions with server when executed.

A programmer uses development software to create an application program that will run on a client computer . Development software may include source code editors integrated development environments language compilers linkers debuggers and other tools used by programmers to develop software. In the preferred embodiment these tools support development in an object oriented language such as C or JAVA. Such tools are well known and understood in the art.

During the development process the development software creates maintains and uses various development files . Development files may include for example source code object code executables and related files. Development files may also include libraries of the above types of files in a form intended for generalized or standardized use e.g. subroutine libraries or graphical control libraries. Development files may be originally created by the user or come from the operating system software provider a software vendor or from another source. The types of files used in the development of application programs are well known and understood in the art.

At the culmination of the development process for an application program development software such as a linker creates a ready to use executable program and stores it as application software .

In a preferred embodiment development files includes libraries of generalized source code files. The files in the libraries define and implement classes and objects that when compiled with user source code into a ready to use executable program effectuate a transmutation between data exchanged with the server and object instances in a running copy of the persistently stored executable program . This transmutation process represents a further advantage of the present invention which is more fully discussed later in this detailed description.

Execution environment is used to perform data processing desired by the user for example maintaining the user s customer accounts. Application software such as persistently stored executable program is loaded into client computer to become executing program . Executing program contains instructions that initiate and respond to formatted transaction data streams exchanged with data object manager DOM server software . Notably foundation for distributed objects FDO instructions transmute between live programming objects in executing program and the contents of a data stream exchanged with the DOM server software . In a preferred embodiment FDO instructions result from program compilation in the development environment using generalized source code files as contained in library .

In one such exchange the FDO instructions may send a data stream to the DOM server software executing on the DOM server computer that requests account data for a customer. DOM server software receives the request and interprets it based on information extracted from configuration database . DOM server software acts as a data access Mediator between application program and data sources . The interpreted request may resolve to one or more data requests sent to one or more of data sources . This process is described earlier in relation to .

Data source computers are representative of the disparate types of data sources that can be accommodated in an embodiment employing the present invention. Data source is a computer running IBM s CICS software and implementing its external presentation interface EPI . CICS is a distributed online transaction processing system including system controller and utility software components that can support a network of many user display terminals interacting with user written transaction programs. The EPI interface component allows programs external to CICS to access CICS transaction programs by emulating a display terminal device and its operator. The external program reads the screen display information by analyzing the data stream sent by CICS. The external program communicates to CICS by generating a data stream that mimics the keyboard strokes that would be sent by a terminal operator.

Data source is a computer running IBM s CICS software and implementing its external call interface ECI . The ECI interface component of CICS is designed for program to program communication rather than program to terminal communication. The ECI interface allows an external program to invoke a CICS managed transactional program module and communicate with it via a formatted data area.

Data source is a computer running messaging system software that acts as the broker for transferring data messages between sender and recipient software programs. Message server data source can be thought of as an email system for computer programs. One example is IBM s MQSeries software which can transmit and receive messages between programs running on heterogeneous systems i.e. systems comprising hardware and software from various vendors and usually employing a variety of operating systems communication systems and protocols. Message server acts as a data source by providing a mechanism whereby a data using program can invoke the services of a data maintaining program but the message server software does not necessarily itself maintain a repository of business data.

Data source is a computer running an operating system that provides access services for rudimentary file structures such as flat files. An example is a POSIX operating system providing access to files formatted as a standard UNIX text file.

Data source is a computer running relational database management system RDBMS software. RDBMS software provides services to external programs for creating and maintaining data collections using a relational model. The relational model is well known and understood in the art. Examples of RDBMS s include ORACLE and INFORMIX products.

Notably the bulk of electronic data processing occurring in business today utilizes data sources as those mentioned above . In addition to data sources such as CICS systems also embody the huge investment that has been made in application programming to capture and automate business logic e.g. a transaction program running under CICS may perform many data processing operations other than merely retrieving or storing data such as editing verifying reformatting accumulating etc. . It is an advantage of an embodiment employing the present invention that the wealth of these legacy data sources can be accessed without any changes to the legacy system. This is possible because DOM server software interfaces to each legacy data source using an interface standard defined by the data source rather than one defined by the DOM software. It is a further advantage of the present invention that client programs can access this wealth of disparate data sources without each being aware of all of the details for accessing all of the available data sources but can rather utilize the unified interface provided by the DOM server.

Mass storage similarly may receive store and recall computer software and data but is generally slower and of much greater capacity than memory . Mass storage generally comprises non volatile or persistent storage devices. Mass storage may comprise read write and read only devices. Example mass storage devices include those supporting and incorporating storage recording media such as magnetic disks optical disks magneto optical disks and magnetic tape. The storage media for the device may be fixed or removable. Program files including operating system and application program files configuration and management data files and user data files are examples of computer software and data that reside on the storage media of mass storage .

Input output provides for human interaction with computer . Example input devices that allow a human operator to introduce data to signal bus include keyboard computer mouse trackball touch pad digitizing tablet and microphone. Example output devices that allow data from 312 to be presented to a human operator include video display printer and audio speakers.

Data communication provides circuitry to exchange data on signal bus of computer with computers or other data devices attached to connection . While Input output provides for interaction with a human operator data communication provides for interaction with other computers. For example data present in computer may be conveyed via data communication circuitry to computer via connection and network .

General purpose computer is representative of the computing devices illustrated in as Developer workstation client computer DOM server computer and data source computers .

It can be seen that a particular layer in a layered architecture can itself be divided into sublayers. For example the CS communication layer comprises a proxy layer a proxy facade PF communication channel layer and a facade layer. The proxy layer comprises protocol specific proxy that functions to interface the client transactor layer to the formats and protocols required by the particular PF communication channel in use. The PF communication channel layer comprises PF communication channel that functions to transfer data bi directionally between the proxy layer and the facade layer. The Facade layer comprises protocol specific facade that functions to interface the server processor layer to the formats and protocols required by the particular PF communication channel in use.

Computer elements depicted in underlie and form part of elements already described in relation to the layered architecture. Computer elements depicted in include client computer server computer and source computers . Client computer and server computer each provides general purpose computing circuitry and support software to execute associated program code in the architecture. Source computers represent general purpose computers corresponding to data sources in . Each of source computers provides general purpose computing circuitry and support software to execute associated program code in the architecture e.g. data accessor programs .

Other elements depicted in operate together with those already discussed to serve the overall objective of data item transfer between data sources and user application programs. These elements include process activation daemon PAD configuration database and execution processes which are described in the detailed structural and operational description of the architecture that follows.

The operational overview described in reference to is repeated here with attention to the architectural components depicted in . Client computer communicates with server to gain access to persistent data maintained by data sources . Client computer executes client application program comprising user application program code FDO program code and protocol specific proxy . Application program code includes program objects . Client computer connects to server via communication channel .

DOM server computer executes DOM server software comprising the program code of process activation daemon PAD protocol specific facade resource adapters and DOM core . DOM server computer connects to data sources via communication channels . DOM server software executes using execution processes .

Data sources comprise the executing program code of data accessors and stored data . A data source such as data source comprises the executing program code of data accessor software and the stored data maintained by that code. A data source such as data source corresponds to one of the data sources depicted in .

User application code includes program logic to carry out the specific data processing desires of the user. User application code may include code to interact with the operator of client machine via its input output devices see . Possibly in response to user input part of the program logic of user application code directs utilization of data items maintained in data sources . The program logic directing utilization of such data items connects to FDO program code .

FDO program code includes generalized program logic for communicating with the DOM server software . The generalized program logic is tailored by development time e.g. compilation or execution time e.g. variable assignment processes to perform the instance specific processing directed by the user application program .

In the presently described embodiment when sending a service request to server software FDO program code transmutes programming objects such as objects into a data stream for transmission to the server. In receiving replies to service requests from server software FDO program code transmutes a data stream received from the server into programming objects such as objects . The details of this transmutation process are fully described later in this detailed description.

FDO program code connects to the program code of protocol specific proxy to begin the exchange of a data stream with server software . Protocol specific proxy communicates with FDO program code in a format used universally by FDO program code to communicate with the CS communication layer elements of the architecture. This facilitates interchangeability of specific components occupying the CS communication layer in a specific implementation particularly PSP . Protocol specific proxy converts data streams and related request and control information between the common FDO program code format and the format required by the communication channel to which it is connected .

Communication channel connects protocol specific proxy to protocol specific facade . Communication channel supports the bi directional transfer of data. Communication channel may comprise a physical communication medium interposed between support circuitry and software at each end. The channel may provide for communication between programs executing on the same computer or on computers located thousands of miles apart. Examples of communication channels that may be employed in the presently described embodiment include TCP IP network connections Common Object Request Broker CORBA facilities and Distributed Component Object Model DCOM facilities. These and other inter program interaction and communication vehicles are well known and understood in the art.

Protocol specific facade converts data streams and related request and control information between the format required by the communication channel to which it is attached and a format useable by DOM core program code . DOM core communicates with protocol specific facade in a format used universally by DOM core to communicate with the CS communication layer elements of the architecture.

In the aggregate protocol specific proxy communication channel and protocol specific facade effectively form a client server CS communication channel between FDO program code in the user application program and the core program code of the DOM server i.e. the CS communication layer of the architecture . Furthermore CS communication channel in combination with the FDO program code together represent a client server interface that connects user developed code with the DOM core . Program code implementing such client server interface in an embodiment may advantageously adhere to an industry standard interface specification. For example the FDO program code on the client side of such a client server interface could comply with an industry standard application programming interface API for data access such as open database connectivity ODBC or object linking and embedding OLE .

DOM core program code contains program logic to receive process and reply to requests received from client application program . When DOM core receives a request it uses information in the request data stream sent by the client to determine the action required to satisfy the request based on information loaded into memory from configuration database . The required action will resolve to one or more requests that need to be directed to appropriate data sources i.e. SS transaction requests.

For each SS transaction request that needs to be directed to a data source the DOM core connects to program logic in one of resource adapters to initiate the transaction with the associated data source. As to transactions between the DOM server software and the data sources the DOM server software acts as the client and the data sources each act as a server. For example the DOM core connects to resource adapter to begin an exchange with data source . Resource adapter communicates with DOM core program code in a format commonly used by all resource adapters . Resource adapter accepts requests in the common DOM format and perform is the requested transaction by communicating with data source in accordance with requirements imposed by communication channel and data access software

Communication channel connects resource adapter to data access software . Communication channel is a bi directional data communication channel. Communication channel may comprise a physical communication medium interposed between support circuitry and software at each end. The channel may provide for communication between programs executing on the same computer or on computers located thousands of miles apart. Examples of communication channels that may be employed in the presently described embodiment include TCP IP network connection and SDLC network connections. These and other inter program communication and interaction facilities are well known and understood in the art.

Data access software contains program logic to receive process and reply to requests received from DOM core . The requests received from DOM core relate to accessing stored data maintained by data access software . When data access software receives a request from DOM core it interprets the request and may read modify insert or delete certain contents of stored data to satisfy the request. Data access software also generates a response back to DOM core software appropriate to the request.

Resource adapter and communication channel together operate as described above to give the DOM core access to data source . Resource adapter and communication channel operate similarly to give the DOM core access to data source . Resource adapter and communication channel operate similarly to give the DOM core access to data source . In the presently described embodiment there are only practical limits such as memory and CPU capacity restricting the number of data access pipelines associated with an executing DOM server . The ability of the DOM server to simultaneously interact with multiple and disparate data sources represents a further advantage of the present invention.

The DOM server software depicted in also includes process activation daemon PAD . PAD program logic loads and executes on server machine to initiate operation of the DOM server software . PAD reads configuration information from configuration database . Based on the information obtained from configuration database PAD starts multiple processes . Each process is viewed by the operating system software of server computer as an independently manageable and dispatchable unit of work. PAD starts processes and to execute DOM core and resource adapter program logic respectively. Starting each process includes loading the program code that directs the execution of the process. For example starting process includes loading DOM core program code from mass storage into main memory.

PAD program logic also monitors ongoing operation of the processes it starts and will restart any process that terminates in accordance with restart information contained in configuration database . Such information may include for example an amount of time to wait before attempting a restart. In the presently described embodiment PAD also maintains a log file not shown where it records activity such as starts terminations and restarts of the processes it manages.

PAD starts resource adapter processes after starting DOM core process is shown. In the presently described embodiment one process executing DOM core program logic . All inbound communication channels from client machines and all outbound communication channels to data sources connect to the single executing copy of DOM core program logic . In other embodiments multiple processes running DOM core program logic may be started on a single server machine . Inbound requests from client machines and outbound requests to data sources may then be distributed among the multiple executing DOM core processes to manage or enhance performance. One skilled in the art recognizes that these and other variations can be made without departing from the scope and spirit of the invention.

Because an embodiment practicing the invention can provide a generalized data access capability the specifics of any desired data access operation must be declared for the DOM server and the client application program. This is the implementation process. is a flowchart showing the implementation process for one system employing the present invention. The implementation process prepares a data processing system to perform data accessing operations in accordance with the present invention. The implementation process occurs using the development environment as described in relation to .

Steps through are performed using the GUI configuration utility described earlier. Steps through populate the DOM configuration database which stores information used to direct the operation of the DOM server software during its execution. Step records configuration information for the DOM server s Process Activation Daemon PAD . Step records its output in PAD Configuration file which is contained in configuration database . PAD Configuration file contains three sections. An ENVIRONMENT section contains information about the identity and location of computing resources on the server host. Such resources may include for example file directories or communication ports. RESOURCE ADAPTER and DOM sections contain information the PAD needs to start control and monitor resource adapter and DOM core processes. Such information may include for example a name that identifies a computer to run the process an indicator whether restart should be attempted for a failed process how many times how often and how long to wait for restart attempts information the operating system should provide to the process if specifically requested the command string to submit to the operating system to start the process and the command string to submit to the operating system to restart the process. The RESOURCE ADAPTER and DOM sections may additionally include information to facilitate concurrent execution of multiple resource adapters or DOM cores on the server machine. Such information may include for example the number of DOM or resource adapter occurrences the PAD is to run.

Step records configuration information used by executing resource adapters. DOM configuration resources as defined in step refer to data sources. Each resource definition corresponds to a run time resource adapter process and the SS transactions that the particular resource adapter can perform. The output of resource definition step corresponding to a particular resource adapter goes to a particular resource adapter configuration file . Resource adapter configuration file is contained in configuration database . Configuration database in the presently described embodiment contains one resource adapter configuration file for each resource adapter specified in PAD configuration file .

A resource definition contains information concerning the resource adapter. For example such information may include the type of data source to which the resource adapter connects location authorization and interface information used to establish secure and reliable communication with the data source and process management information about the resource adapter such as the amount of time to wait for initialization restart parameters environment information such as file directory names a shell command for starting the resource adapter and whether multiple concurrent copies of the resource adapter may execute.

A resource definition also contains information concerning each particular SS transaction that the related resource adapter can accommodate. For example information about a transaction may include an identifier for the transaction type parameters to control transaction execution the format of the transaction request the format of the transaction reply the correspondence between transaction data items and DOM server data container data items and procedural logic needed to conduct the transaction. Because different resource adapters can connect to different types of data sources and because different data sources may each have their own particular defined interfaces the specific information required to engage in a transaction may vary from data source type to data source type. In a preferred embodiment each transaction definition corresponds to what the data source considers to be a single atomic transaction. i.e. one request process reply sequence. The atomic transaction may also include required handshaking such as session set up and tear down.

 Methods are defined in step . DOM Configuration methods refer to CS transactions. Each method definition corresponds to a type of CS transaction that a user application program may engage in with the DOM server. The output of method definition step goes to a DOM Configuration file . DOM Configuration file is contained in configuration database . Each method definition contains information needed by DOM core software to identify process and respond to a CS transaction request from a client user application program. Information about a transaction may include for example an identifier for the transaction type parameters to control transaction execution the format of the transaction request the format of the transaction reply the correspondence between transaction data items and DOM server data container data items and procedural logic needed to conduct the transaction.

At the completion of steps through the DOM configuration database contains the information needed by DOM server software to manage its own operation on the server computer define the data access transactions it will make available to its clients and define the data access transactions it may conduct with data sources in order to satisfy client requests. Each of steps through must be conducted once before a fully functional DOM server can be executed using configuration database . Each of steps and may then be repeated individually or in combination as needed to reflect additions or changes to the information contained therein.

Step creates a client application program. The output of client program creation step is an executable program in mass storage that can be loaded and executed in a client computer. In a preferred embodiment the client program is written by a computer programmer using an object oriented computer language such as C or Java. The programmer includes source code in the program to send a request to a DOM server. The request is formulated to invoke a method defined in step . The source code is compiled and linked to form executable program . Application program will control the operation of a client computer at execution time. After step the implementation process is complete.

The implementation process described in relation to begins by loading configuration information into files in a DOM configuration database. The files comprising the DOM configuration database in the presently described embodiment are stored in a text format. This format represents a compromise between a format optimized for human readability and a format optimized for machine readability. Storage of configuration files in text format permits a user to maintain the configuration files using any of the readily available text editor programs available on the particular server platform. Maintenance of the configuration files using a text editor is however error prone and requires the user to have detailed knowledge about the many files that together comprise the configuration database. The presently described embodiment includes graphical user interface GUI based configurator software to provide easier more understandable less error prone maintenance of the configuration database. The GUI based configuration is described in relation to .

The leftmost portion of title bar identifies the window as belonging to the DOM Configurator software. The rightmost portion of title bar includes customary window control buttons to invoke window minimization window maximization and termination processing for the configurator program.

Menu bar displays File Edit and Help options. Each menu option when selected by a keyboard or pointer device displays a list of functions that the user can perform using the configuration software. Functions listed under the File menu option principally relate to storing and loading configuration database information to and from mass storage devices. Functions listed under the Edit menu option principally relate to modifying configuration information that is graphically depicted as the visible content of the method and resource display areas . Functions listed under the Help menu option principally relate to displaying information about the DOM configurator software and its use.

Tool button bar depicts an array of graphical icons each of which may be selected by the user using a pointing device to invoke certain processing by the configurator program. An icon displayed on tool button bar may correspond to a particular function in the list associated with a menu bar option. For example a tool button bar icon may invoke the same processing to save configuration information on a hard disk as does a menu option listed under the File option of the menu bar . A tool button bar may include icons to invoke processing that creates a new configuration loads an existing configuration from mass storage stores a configuration to mass storage presents a dialog window with which to edit PAD configuration file data displays configuration data in text format exchanges data with a clipboard facility adds or deletes a configuration element in a display area and its underlying data presents a dialog window with which to modify the data underlying a configuration element displays helpful information or that finds and highlights a particular configuration element.

Status bar may display such information as the name and location of a configuration file on mass storage associated with the display contents in method and resource display areas . Status bar may also display the current date and time of day.

Method display area graphically depicts the configuration information associated with any DOM configuration file in a configuration database. This information defines and describes the client server CS transactions available to a client application program through a DOM server. Resources display area graphically depicts the configuration information associated with any resource adapter configuration file in a configuration database.

The visible contents in the display areas shown in and described in more detail in subsequent figures illustrate one way to configure the operating example depicted and discussed earlier in relation to . The chief difference between the operating example of and the configuration example of and subsequent figures is that the four data records of come from two data sources in the configuration example of rather than from four data sources A D as shown in .

Dialog box area displays information about the execution environment of the target data source. Such information may include for example whether the data source resides on the same or different computer as the resource adapter software or information about the coding methods used to represent data on the computer where the target data source executes.

Dialog box area displays information principally used by the PAD software to manage any process executing a resource adapter using the instant configuration. The Resource Type field indicates the kind of data source to which the resource adapter connects. The Resource Name field indicates a name to be used by other software components to identify the resource adapter. The Config File Name field indicates the name of a resource adapter file in the configuration database where the instant configuration information is stored. The Host Name field indicates the name by which the data source computer can be contacted by software components attached to a common communication system. The Instances field indicates the number of concurrent resource adapters that may execute using the instant configuration information. The Command field indicates a command that the PAD may send to the operating system to initiate the resource adapter process. The Restart Command field indicates a command that the PAD may send to the operating system to attempt a restart of the resource adapter process after an earlier failure. The Retries number sec fields indicate the number of times the PAD issues the restart command if the previous start or restart command fails within the specified number of seconds. The Wait field indicates the amount of time that PAD should wait after issuing a start or restart command to determine whether the command was successful. The Restart field indicates whether PAD should issue a restart command after detection of an earlier start or restart failure. The Environment field indicates information that the operating system should make available to the executing resource adapter software should it make a request for such information using operating system services.

The information displayed in area of resource dialog box is common to all types of resource adapters. Particular types of resource adapters may require that specific additional information be included in their configuration files. Display area of resource dialog box accommodates such information. For example the CICS Region field indicates the name of a particular execution copy of CICS EPI software running on the target data source computer.

Dialog box illustrates the configuration information immediately represented by GetCustomer element . A Name field indicates a transaction name by which the CS transaction is known within the configuration database. The transaction name must be unique within the resource adapter configuration to which it belongs.

Dialog box illustrates the configuration information represented by EPI Script element . A script field contains procedural logic necessary to carry out the SS transaction. The procedural statements in the script emulate the actions of a computer terminal operator to the data source when executed. Such actions may include for example reading an item off the screen entering an item using a keyboard or depressing control keys on the keyboard. Data items read from or keyed to the emulated terminal screen go to or come from named variables or literal string. Named variables may reside within data container objects in the DOM core.

To start the CICS transaction suggested by the example script of dialog box a terminal user would send a message to the EPI data source containing the transaction code to identify the desired transaction CINQ followed by an ATM card number to identify the particular customer for which the transaction is being requested. The first line of the script in dialog box duplicates this message format using a literal value for the transaction code CINQ and variable substitution for the ATM card information atmCardCode . After receiving such a message the EPI data source responds with a data stream to produce screen image for the terminal user to read. Screen image corresponds to persistent data record of . The EPI script in dialog box reads the screen image data stream using the second and subsequent lines of the script. The second line reads field and places the data item in a variable named output.id. Similarly the third and fourth lines read fields and and place the data items in variables named output.name and output.branch respectively. Table 1 portrays EPI scripting language elements useful to emulate terminal operations.

Dialog box area displays information about the execution environment of the target data source. The types of information contained in display area are the same as for display area described earlier in reference to . Dialog box area displays information principally used by the PAD software to manage any process executing a resource adapter using the instant configuration. The types of information contained in display area are the same as for display area described earlier in reference to . Display area contains no information as no additional information beyond that accommodated in display areas and is needed to manage the execution of an RDBMS type resource adapter

Dialog box displays the configuration information underlying session element . The Session Name field indicates an identifier by which the instantly configured session may be known. The Database Type field indicates the name of a library file containing program code that can transform SS transaction requests and responses between a generalized RDBMS format and a format required by a particular RDBMS data source. The Database Type field is used because the design of this embodiment employs a generalized RDBMS resource adapter that is specialized to a particular RDBMS server by this association to a related library file. The Server Name field indicates the name by which the data source computer can be contacted by software components attached to a common communication system. The Database Name field indicates the name by which the RDBMS server identifies the particular database containing the data items targeted for access. The Database Role field indicates the function of connection e.g. whether the connection is used to connect a client for data access requests or whether the connection is used for performing data base administration activities. The User ID and Password fields indicate security parameters that will authenticate and authorize the resource adapter to utilize the services of the RDBMS data source. The of Connections field indicates the number of logical connections the resource adapter should establish between itself and the data source using the instant configuration information. The of Output Rows field indicates the default maximum number of table rows that should be included in the response to an SS transaction request originating from the resource adapter.

Notably no sessions list is included in the configuration information for a CICS EPI data source already described in relation to . This is because different data sources impose different interface requirements. In a preferred embodiment the construction of the DOM configurator software is similar to that of the DOM server software wherein the resource adapters interface to the DOM core in a common fashion to provide a degree of modularity. In a preferred embodiment resource adapter configuration maintenance code including the program code to effectuate the dialog boxes related to the particular resource adapter are modular in design and interface to core GUI based DOM Configurator code using a common interface. Such a construction improves the upgradability of the DOM Configurator as new types of data sources become desired.

When display element for the Informix RDBMS data source is added to the resource display area at the specific request of the user Transactions element is automatically available for display. Transactions element serves as the anchor point for a list of server source SS transactions that the Informix RDBMS resource adapter can process. The user of the DOM Configurator specifically adds the GetSecurity display element to the transactions list anchored by graphical element . When GetSecurity is added to the transactions list Parameters Field Map and SQL elements are automatically anchored off of GetSecurity element . Parameter and SQL configuration elements each directly possess underlying configuration information. Field map element serves as the anchor point for a list. Each entry in the field map list establishes the correspondence between a data item in a DOM data container object and a data item accessed using the RDBMS.

Dialog box illustrates the configuration information immediately represented by GetSecurity element . A Name field indicates a transaction name by which the CS transaction is known within the configuration database. The transaction name must be unique within the resource adapter configuration to which it belongs.

Dialog box illustrates the configuration information represented by Parameters element . A Type field indicates whether the database processing for the transaction is defined by structured query language SQL statements supplied to the data source by the resource adapter or by a predefined procedure stored on the data source computer. If a predefined procedure is to be used the name of the procedure must be indicated in the Proc Name field. If SQL statements are to be supplied to the data source by the resource adapter the SQL statements are specified using dialog box . SQL statements specified using dialog box may include substitution variables such as the id variable shown in dialog box . SQL and variable substitution techniques are well known and understood in the art. A Session Name field in dialog box indicates the name of database session to utilize in conducting the transaction. Such a session must have already been configured in accordance with the discussion regarding . A of Output Rows field indicates the maximum number of table rows that should be included in the response to the instant SS transaction request. This number overrides the default specified in the session configuration as discussed previously in reference to .

Dialog box illustrates the configuration information represented by password element . Password element belongs to the field map list. Field map list items direct the automatic transfer of data items between data container objects in the DOM server and data fields managed by the RDBMS data source. The user of the DOM Configurator specifically adds the password display element to the field map list anchored by field map element . An Attribute Name field indicates the name of a particular data item stored in a data container object within the DOM server. The data container determines the direction of the data item transfer. If the relevant data container object relates to a request message from a client to the DOM server the data item moves from the data container object to the data source field before the SS transaction request is sent to the data source. If the relevant data container object relates to a response message to be sent from the DOM server to the client the data item moves from the data source field to the data container object after the SS transaction response is received from the data source. The same attribute name may be configured into both the request related and response related data containers configured for a CS transaction. Configuration of request and response data containers is discussed later in reference to . A Field Name field in dialog box indicates the name used by the RDMBS data source to identify a particular data item field.

In this example the Field Name of Pass Phrase is used to identify a data item from the second column of relational table . Row of relational table corresponds to persistent data record of . In this example the data item in the Pass Phrase column comes from Row of relational table .

After resources have been configured i.e. SS Transactions methods that use them can be configured i.e. CS transactions . The configuration activity represented by correspond to the activity represented by step of .

When element for the GetCustomerInfo CS transaction is added to the methods display area at the specific request of the user Input Message element Output Message graphical element Transactions graphical element and Script graphical element are automatically available for display. Input Message and Output Message elements represent the request and response messages respectively exchanged between the client and the DOM server. Transactions and Script elements represent the processing performed by the DOM server to satisfy the client s request. In the presently described embodiment either the Transactions element or the Script element will determine the processing for the transaction and only one of the two may be further configured. Input Message and Output Message elements each serve as the anchor for a potentially multi level hierarchical list of message node elements. The hierarchical arrangement of the message node lists reflects the hierarchical arrangement of data container objects that DOM server software constructs at run time to embody the input and output messages as well as the hierarchical arrangement of programming objects in application program .

The user of the DOM Configurator specifically adds the atmCardCode message node element to the Input Message list anchored by element . The atmCardCode element represents the sole data item passed from a client to the DOM server when requesting a GetCustomerInfo transaction. The atmCardCode data item is then used as a search argument by the DOM server when preparing a request for SS transaction GetCustomer to fulfill the client s GetCustomerInfo request discussed in reference to . Dialog box illustrates the configuration information immediately represented by atmCardCode element . A Name field indicates a name to uniquely identify the node within parent message element . The Type field indicates the role of the message node within the hierarchical list. A component type message node corresponds to a data item to be transferred between the client application program and the DOM server. The Option field is used when dialog box is used to insert a new message node. The Option field indicates the position in the hierarchical list for the node to occupy relative to the most recently selected element. Here the most recently selected element is . Next and Previous indicate that the new node should occupy the subsequent or preceding position respectively at the same level in the hierarchy. Child indicates that the new node should occupy a related position one level lower in the hierarchy. The Index field is described later in relation to message mode . The Index field is meaningful only for component type message nodes.

While the input message configured under anchor element contains only one element the output message for the GetCustomerInfo CS transaction configured under element contains multiple elements arranged in a two level hierarchy. The hierarchy corresponds to the programming object hierarchy illustrated in . The upper level of the object hierarchy includes an object to represent a banking customer. The lower level of the object hierarchy includes multiple objects each of which represents a particular account owned by the banking customer. In the output message configuration depicted in the upper level of the hierarchy begins at Customer element and the lower level of the hierarchy begins at Account element .

The user of the DOM Configurator specifically adds the Customer message node element to the Output Message list anchored by element . Dialog box illustrates the configuration information immediately represented by Customer element . The fields and their meanings are the same for all message nodes as described above in relation to dialog box . The Type field in dialog box however indicates the role of this message node to be of type Folder. A folder type message node indicates within a message that the object in the application program that embodies data items represented by immediately subordinate nodes is instantiated from a class type that is dynamically determined at run time. The customer folder node represents the finite family of class types from which the object may be instantiated. Notably the customer folder represents the family of class types without having any awareness of what the members of the family are. That information is created by the application programmer and is ensconced within the application program itself. The list of component message nodes immediately subordinate to the folder node represents the set of all field types that can potentially be exchanged during the servicing of a particular instance of a GetCustomerInfo transaction. The list of field types actually exchanged for a particular instance of the GetCustomerInfo transaction will correspond to the class type family member used to instantiate the related programming object in the client application program .

In reference to the user of the DOM Configurator specifically adds the immediately subordinate id message node element to the Customer folder node . Dialog box illustrates the configuration information represented by id element . The name branch and password elements exist under the Customer folder node in like fashion.

The user of the DOM Configurator specifically adds the Account folder node under Customer folder node . The configuration information represented by Account folder graphical element parallels that for Customer folder node as displayed by dialog box see with the obvious change to the contents of the Node Name field.

The user of the DOM Configurator specifically adds the Account array message node under Account folder node . The configuration information represented by Account array element is displayed by dialog box . The noteworthy difference between the configuration information for the account array message node and the configuration information for the message nodes previously described is the selection of Array for the contents of Type field . An array type message node indicates within a message that multiple occurrences of the set of message nodes subordinate to the array type message node may be contained within a single message occurrence. In the presently described example account array node provides for the GetCustomerInfo response message to contain data regarding multiple accounts.

The user of the DOM Configurator specifically adds the number message node under Account array node . The configuration information represented by number element is displayed by dialog box . The noteworthy difference between the configuration information for the number component type message node and the configuration information for the component type message nodes previously described is the affirmative entry for the contents of Index field . The affirmative entry for the contents of Index field indicates that the data item represented by the number component node can serve to uniquely identify one set of account array subordinate nodes from among the multiple sets that may exist by virtue of array node . Component type nodes type status balance and creditLimit are configured as other component type nodes. If any of these nodes is also configured with an affirmative indication in its Index field then it is combined with the number node to form the unique identifier for the set of array subordinate nodes.

 Transactions and Script elements represent the processing performed by the DOM server to satisfy the client s request. As mentioned earlier in the presently described embodiment either the Transactions element or the Script element will determine the processing for the transaction and only one of the two may be further configured. In the present example Transactions element is further configured to represent the data source processing for the GetCustomerInfo CS transaction. Transactions element serves as an anchor for an ordered list of SS transactions. In the present example the EPI.GetCustomer Informix.GetSecurity EPI.GetSavings and EPI.GetBankcard elements were actively placed under Transactions element by the user of the DOM Configurator. This action may have been performed in a preferred embodiment by using a drag and drop user interface technique well known in the art to copy an SS transaction element such as GetCustomer from the resource display area of to Transactions element . When copied the SS transaction is identified by the concatenation of the resource element name under which the SS transaction element is configured a period . and the SS transaction element name. When the DOM Server performs a CS transaction using a Transactions list the SS transactions are performed sequentially in the order they appear in the list. Other embodiments may permit non sequential and or out of order processing of the transactions in the list by providing automatic or user specified mechanisms to mandate ordered processing between transactions having an interdependency. An example of such an interdependency is hypothetical transaction B the request message for which includes data originating from hypothetical transaction A.

Alternatively DOM server processing for a CS transaction can be directed by the configuration information of a Script graphical element such as element . In this case a dialog box like the dialog box used to maintain SQL statements of or the dialog box used to maintain CICS EPI scripts of is used to maintain the script configuration information represented by Script element . In a preferred embodiment the scripting language is DOM specific but modeled closely after a widely known programming language such as C. The scripting language may include support for a variety of data types variable manipulation arithmetic and logical operators program flow control statements and structures string related functions and specialty functions useful in navigating and manipulating hierarchical lists and object structures. Elements of an exemplary scripting language appear in Table 2. The scripting language of a preferred embodiment also provides the capability to execute configured SS transactions. Such a scripting language extends the capability of the DOM server to provide advanced functionality e.g. as conditional error handling or user implemented commit and rollback processing across disparate data sources. The extended capability provided by the scripting language represents a further advantage of the present invention.

 DOM Configuration area displays configuration information in text format. In the sample text depicted in display area Simplemethod refers to a CS transaction and Submethod refers to an SS transaction. The contents of display area corresponds to the contents of a DOM configuration file as depicted in .

It is noted that other GUI configurator screen displays similar to those depicted in may be implemented to provide viewing and or editing of any information in the configuration database. For example GUI configurator screens maybe be implemented for the PAD configure. One skilled in the art recognizes that various screen formats and organizations may be used without departing. After the implementation process depicted and described in relation to is complete execution of an embodiment employing the present invention can begin.

Step initializes the DOM server. The DOM server may run on a host computer shared with one or more data sources or it may run on a separate machine. The software program code for the DOM server is loaded into computer memory from mass storage media such as a hard disk. The loading operation is performed by the operating system on the DOM server host computer. Once loaded into memory the operating system passes control of the computer to the program code of the DOM server software. The program code then prepares the DOM server host computer to receive and process CS transaction requests. The DOM server software uses information from the configuration database to direct the initialization process. As part of initialization The DOM server software may establish communication with one or more data sources started in step in anticipation of sending SS transaction requests to the data sources in order to process the CS transaction requests the DOM server software receives.

Step initializes the user application program. The user application program may run on a computer shared with one or more data sources on a computer shared with the DOM server or it may run on a separate machine. The software program code for the application program is loaded into computer memory from mass storage media such as a hard disk. The loading operation is performed by the operating system on the application program host computer. Once loaded into memory the operating system passes control of the computer to the program code of the application program. The program code then performs the data processing operations desired by the user. In the course of these data processing operations the client application program makes a CS transaction request.

The running application program makes a request to the DOM server in step to perform a CS transaction. In making the request the application program communicates information to the DOM server. Such information may include for example the type of CS transaction to perform and identifiers for the specific data items to be accessed.

In step the DOM server determines the SS transactions needed to fulfill the request made by the application program in step . The DOM server identifies the transactions using information loaded from configuration database . The identities of the SS transactions come from either the transactions list or the script configured for the method the CS transaction as recorded in the configuration database and discussed earlier in reference to .

In step the DOM server requests performance of an SS transaction identified in step using information loaded from configuration database . In making the SS transaction request the DOM server communicates relevant information to the appropriate data source. Such information may include for example the type of SS transaction to perform and identifiers for the specific data items to be accessed. Some of the information communicated to the data source by the DOM server may have originally been communicated to the DOM server by the client application program. For example the application program may communicate a customer number to the DOM server which in turn communicates the customer number to the data source. The data source in turn accesses specific data items contained among its stored data that are associated with that customer number.

In step a data source receives the SS transaction request communicated by the DOM server in step . The data source processes the request accessing relevant data items contained among stored data . The data source concludes the SS transaction by indicating the results of the processing in a response information message that is communicated to the DOM server.

After receiving the response information communicated from the data source in step the DOM server determines whether any SS transactions identified in step have yet to be performed. If transactions remain the DOM server returns to step to process the next SS transaction. If the needed SS transactions are completed the DOM server resumes operation with step .

In step the DOM server completes the processing for the CS transaction using information loaded from configuration database . The DOM server determines the format of the response message based on the type of CS transaction. The DOM server then constructs a response message in the required format using data items received and consolidated from possibly multiple SS transactions. The constructed response message is then communicated to the client application program.

In step the application program receives the formatted response to its CS transaction request as communicated by the DOM server in step . Data items represented in the response message are extracted from the message. Program code in the application program embodies the extracted data items into programming objects. The programming objects are interrelated into a topology which is itself also represented in the response message. After the programming objects embody the data items from the response message the application program continues execution in step . Downstream instructions in the application program may then utilize the programming objects of step to usefully employ the data items the objects embody. In accordance with the present invention the programming object data items reflect persistent copies of corresponding data items contained in stored data and maintained by the data access software.

For format group I tokens the first character may be 0 through 4 and represents the number of bytes of token data to immediately follow. A first character of 0 indicates that zero bytes follow and thus may be used to represent an empty value. Token instance depicts an example of a format group I token. The first character is a 2 indicating that two bytes of token data follow those being the characters RW. For format group II tokens the first character may be 5 through 9 and represents a number of characters to follow that themselves contain a representation for the number of bytes of token data to follow immediately thereafter. Token instance depicts an example of a format group II token. The first character is a 6 indicating that two bytes representing the length of token data follow. The next two characters are 11 indicating that eleven bytes of token data follow those being the characters creditLimit. For format group III tokens the first character of the token is not the length of data but rather is the data itself having an implied length of one byte. Token instance depicts an example of a format group III token. The first character is a C indicating that the character C is the token data with an implied length of one byte.

Five different types of tokens may be used to construct a data stream. The various types of tokens differ according to their content. Some token types may be used to aggregate multiple tokens into a single token thus encapsulating the multiple tokens. Such nesting by the tokenization process producing tokens within other tokens is advantageously employed to represent information in the data stream about the hierarchical topology that relates data items conveyed in the data stream. The hierarchical topology information logically segregates and distinguishes data items belonging to different levels of the hierarchy as well as those belonging to the same level. For example a parent is segregated from its children at a lower level and each child is segregated from the others on the same level.

The first type of token is the data stream token that contains the entire data stream. The data stream may correspond to either a request or a response message for exchange between a client and a DOM server. Data stream tokens correspond to the aggregation of all message nodes subordinated to an input message or output message element for a CS transaction Method configuration as discussed in relation to .

The second type of token is the family token that occurs at the head of a branch in the topology of the hierarchy and specifies the object type family to incorporate immediately following data items. Token is also a family type token. Family tokens correspond to folder type message nodes in the input or output message configuration for a CS transaction Method as discussed in relation to and may contain the name of the folder type message node as the specifier for the object type family.

The third type of token is the branch token that immediately follows a family token. A branch token contains all of the token information that logically depends from the preceding family token. Token is also a branch type token. Branch tokens correspond to the aggregation of all message nodes subordinated to a folder type message node in an input or output message configuration for CS transaction Method as discussed in relation to .

The fourth type of token is the business object token . A business object token corresponds to an instance of an object having an object type i.e. class belonging to the family represented by its immediately preceding family token. Tokens and are also business object tokens. The business object token aggregates data items to be embodied by an object instance. A business object token further corresponds to some subset or the full set of component type message nodes directly subordinated to the same message node in an input or output message configuration for a CS transaction Method as discussed in relation to . For example a business object token populated by the DOM core using data obtained from a GetSavings SS transaction will aggregate tokens corresponding to number type status and balance component message nodes directly subordinated to Account array node of . It will not include a token corresponding to the creditLimit component message node similarly subordinated. This is because the CICS EPI SINQ display screen of underlying the GetSavings CS transaction does not provide a creditLimit data item.

The fifth type of token is the leaf token . A leaf token corresponds to one particular component type message node in an input or output message configuration for a CS transaction Method as discussed in relation to . Token is the only leaf token depicted in although a multiplicity of such embedded tokens are implied by the dashed line portions depicting business object tokens and . Token comprises tokens . The data item itself is contained by token the value token. The remaining tokens contained by leaf token contain information about the data item i.e. they contain metadata. Field type token specifies the role of the data item. For example the data item may be the number 4445678 but the field type contents will instruct whether that is a phone number or an account number. Data format token specifies the storage and representation format of the data item e.g. integer floating point or character string. State token specifies the state of the data item relative to the persistent storage copy to which it corresponds. For example a state of C for clean indicates that the data item has not been changed. Permission token specifies the degree of control the client application may exercise over the persistent storage copy corresponding to the data item. For example a permission of RW indicates that the client application program is registered via access control mechanisms to access the persistent storage copy for both read and write operations. The access control mechanisms may be implemented in one or more architectural layers occurring between the application program and the stored data e.g. the data access layer. Original value token reflects the data item as it resided on persistent storage when first retrieved i.e. its unchanged state.

Inclusion of metadata along with a data item facilitates data stream to object transformation and permits sophisticated functionality to be included in the CS transaction processing performed by the DOM server. For example a Method script on the DOM server could utilize the state value and original value data to implement commit rollback processing for a CS transaction defined across multiple data sources. Using the same information the commit rollback script could minimize the SS update transactions performed to those that maintain data items that were actually changed by the application program. Inclusion of metadata along with a data item exchanged between a client and the DOM server represents a further advantage of the present invention. Inclusion of a scripting language facility in the DOM server that permits a user to configure the processing for a CS transaction using a procedural language and that permits conditional processing based on data items and related metadata represent further advantages of the present invention.

Objects and have a correspondence to the transient data items shown within programming objects and in and discussed earlier in reference thereto. These objects are utility programming objects that support the work of primary application programming objects in representing a business object. Each of these objects belongs to a primary object and stores a particular data item and its metadata. Each object also provides an interface to the data item for other portions of the client application program. The interface further supports the exchange of the embodied data item and metadata with the DOM server.

Objects and have a correspondence to the Customer and Account folder type message nodes respectively depicted and discussed in relation to . These programming objects are also utility programming objects that support the work of primary application programming objects in representing a business object. Each of the folder utility objects facilitates the instantiation population organization inventory and exchange of primary application programming objects. Folder utility objects also participate in constructing a hierarchical topology by serving as a central point through which primary objects belonging to the folder object are subordinated to the primary object to which the folder object belongs.

The hierarchy of programming objects depicted in is such as may be constructed from the data stream depicted and discussed earlier in relation to . When the data stream of is for example transmitted from a DOM server to a client application program a transmutation of the data stream components into programming objects objectization occurs. The correspondence between data stream tokens and the programming objects extant after objectization is described next followed by a procedural description of the objectization process in reference to .

Data stream token of corresponds to the entire collection of objects depicted in . Customer family type token of corresponds to Customer folder utility object of . Customer branch type token of corresponds to the entire collection of objects connected directly or indirectly via connection beneath Customer folder utility object of . Customer business object token of corresponds to Customer primary object of . Account family token of corresponds to Account folder utility object of . Account branch type token corresponds to the entire collection of objects connected directly or indirectly via connections and beneath Account folder utility object of . Account business object token of corresponds to Savings Account primary object of . Account business object token of corresponds to Bankcard Account primary object of . Representative leaf token of corresponds to data item utility object of .

To facilitate an understanding of the processing performed by the application program in order to further appreciate the present invention the application program processing depicted in is directed at a specific example. assumes an application program communicating with a DOM server using a configuration database configured as described earlier in relation to . Particularly describes the request and objectization for a GetCustomerInfo CS transaction so configured. Further a GetCustomerInfo CS transaction executed in accordance with results in communication of a CS transaction response message data stream from the DOM server to the application program. The GetCustomerInfo response data stream is constructed of tokens as depicted and described in relation to . Accordingly references to tokens in the discussion that follows refer to .

Step of shows user application code sending a CS transaction request to the DOM server. The request identifies GetCustomerInfo as the desired transaction. The request also includes an atmCardCode data item as required by the configuration for the GetCustomerInfo input message. The DOM server processes the request and returns a response message to user code in the form of data stream token .

In step the application program prepares for objectization by instantiating a folder object to serve as the root for an object hierarchy. The application program expects a customer rooted hierarchy out of the GetCustomerInfo transaction and so instantiates a folder object of customerFolder type.

In step user written program logic invokes the deserialize method of the customerFolder object . The deserialize method is a request for objectization. User program logic includes data stream token as an input to the deserialize method.

In step the customerFolder object invokes FDO service code to deserialize the data stream token. From this point forward FDO service code drives the objectization deserialize process. Bracket indicates the long lifetime of the FDO service code deserializeo function. While FDO service code drives the process it enlists the help of other objects along the way. Notably FDO service code will invoke the services of folder type objects and primary type objects to assist in forming and filling the portions of the object hierarchy they contain. This is illustrated in the steps that follow.

FDO service code progressively unpeels data stream token to proceed with objectization. In step FDO service code passes data stream token to CustomerFolder object with specific reference to family token . The CustomerFolder object responds to the FDO service code indicating that it is aware of a folder type object associated with the specifically referenced token .

Because of the affirmative response in step FDO service code turns around in step and instructs the CustomerFolder object to instantiate an object that can embody ensuing tokens in the data stream. FDO service code passes data stream token to CustomerFolder object with specific reference to token . The CustomerFolder object unnests the tokens embedded within token to ultimately compile a list of the field types represented in the leaf tokens contained within business object token . CustomerFolder object uses the compiled list of field types to determine that a Customer type object should be used to embody the data items from token . This object type selection process is discussed in detail in reference to . Accordingly CustomerFolder object instantiates Customer type object in step . Instantiation of Customer object causes instantiation of other objects in the hierarchy immediately depending from it namely leaf type objects and AccountFolder object . CustomerFolder object passes the identity of newly instantiated Customer object to FDO service code to conclude the makeObject request of step .

FDO service code continues to unpeel the tokens embedded in data stream token . In step FDO service code passes data stream token to CustomerFolder object with specific reference to the first leaf token embedded in Customer business object token . Customer object responds to the FDO service code indicating that it is not aware of a folder type object associated with the specifically referenced token.

Because of the negative response in step FDO service code turns around in step and instructs the Customer object to populate an object that embodies the subject leaf token from business object token . Leaf object is populated with the data item and metadata from the subject leaf token. Steps through are repeated for each leaf token embedded within business object token .

FDO service code continues to unpeel the tokens embedded in data stream token . In step FDO service code passes data stream token to Customer object with specific reference to family token . Customer object responds to the FDO service code indicating that it is aware of a folder type object associated with the specifically referenced token .

Because of the affirmative response in step FDO service code turns around in step and instructs the AccountFolder object to instantiate an object that can embody ensuing tokens in the data stream. FDO service code passes data stream token to AccountFolder object with specific reference to token . The AccountFolder object unnests the tokens embedded within token to ultimately compile a list of the field types represented in the leaf tokens contained within business object token . Processing at this point proceeds after the fashion described in relation to step . As FDO service code progressively unpeels the tokens in the data stream and iteratively and recursively makes and populates objects the object hierarchy depicted in is completely formed and filled. When the tokens of the data stream are exhausted the FDO service code objectization process started at step completes. The user application program logic may then proceed to take full advantage of the object hierarchy and the data items it embodies.

In step the folder sets up to perform a loop through all of the object types in the family by pointing to the first one. In step the folder performs a preliminary test to quickly ascertain whether the currently considered object type has the potential for success. This step is performed in one embodiment by comparing the number of inbound data items to the number of data items in an object of the currently considered object type. If it is greater the currently considered object type is not large enough and processing proceeds to step . If it is less than or equal a detailed comparison of the field types in the inbound data stream and the field types attributes of the object type is made in step . In step the folder then determines whether the comparison is successful. In the presently described embodiment the comparison is successful if every inbound data item is represented in the attributes of the currently considered object type. If the comparison is unsuccessful processing resumes at step . If the comparison is successful differences between the list of inbound data items and the list of object type attributes may be recorded in step .

Step determines whether any other object types in the family remain to be considered. If so step identifies the next candidate object type for consideration and processing loops back to step . If not processing continues at step where the folder determines whether any of the candidate object types is a successful match. If not failure is indicated in step object type selection is finished and the report of failure is available for subsequent processing in step . If any candidate has been successful step determines the best candidate. In the presently described embodiment the best candidate is the first successful object type in the list having the smallest number of attributes in excess of the number of field types in the inbound data stream. Once identified step informs subsequent program logic of the object type to be used for primary object instantiation.

In an embodiment that supports multiphase object initialization this same object type selection process could be used to provide a best fit object type for a primary object augmented by multiphase initialization with additional data items. In this case step determines a list including not only inbound data items but data items populated in the preexisting primary object as well.

AccountFolder class is defined by the application programmer. An object oriented language such as C is used. The application programmer defines the AccountFolder class by coding an FDOfolder class template with the familyName parameter Account. In the presently described embodiment source code representing the FDOfolder class template is contained within generalized development file libraries because a folder type object lends itself to generalization i.e. many different folder type objects may be needed all of which perform in the same way.

FDOfolder class template contains program code to perform the functions previously described for a folder type object including the object type selection instantiation and management of related primary objects. The application programmer implicitly or explicitly declares an AccountFolder as static so that one AccountFolder is built into the executable version of the client program. The one AccountFolder in storage satisfies the needs for the entire client application program. The static AccountFolder serves as a repository for information about all of the object types classes belonging to the family during program execution. In this example the AccountFolder includes family registration information about a savingsAccount family object type and a bankcardAccount family object type.

The application programmer defines Account class . Account class serves the purposes of channeling the functionality of FDOnode class to classes deriving from it via inheritance and relating classes deriving from it to the static execution copy of AccountFolder . The application programmer defines the Account class by coding a class declaration specifying inheritance from FDOnode class . Code representing the FDOnode class is contained within generalized development file libraries in the presently described embodiment. FDOnode class includes program code that causes any inheriting class e.g. to place certain information about itself into the family registration information of a related folder for program execution. In the presently described embodiments definitions of data items with a static storage class achieve this objective. Declaration of the static storage class in source code causes the compiler to generate executable code in the prologue of the resulting program that populates the family registration data of the AccountFolder when the program first initializes. The operational charateristics of static storage data are well understood in the art.

The application programmer associates Account class to AccountFolder class . The association may be made explicitly or may be made implicitly e.g. by the common Account portion of the two class names.

The application programmer also specifically codes the declarations and definitions for savingsAccount class and bankcardAccount class . These classes specialize generic Account class adding new object types to the object type family represented by AccountFolder class . Class savingsAccount underlies execution object shown in .

In the presently described embodiment savingsAccount class definition includes code to incorporate leaf type objects as data members of the class for number type status and balance data items. The inclusion of the four leaf type objects is depicted in by the association shown between savingsAccount class and FDOleaf class . The corresponding execution time objects are shown by leaf objects and in respectively.

Class bankcardAccount underlies execution object shown in . In the present embodiment bankcardAccount class definition includes code to incorporate leaf objects as data members of the class for number type status balance and creditLimit data items. The inclusion of the five leaf type objects is depicted in by the association shown between bankcardAccount class and FDOleaf class . The corresponding execution time objects are shown by leaf objects and in respectively.

Family registration information depicts the execution time contents for savingsAccount class and bankcardAccount class . Family registration information may hold similar information for Account class itself and any other classes deriving from it. Family registration information is principally used in the objectization process for selecting the type of object within the family to embody inbound data items from a data stream as described earlier in reference to . Family registration data contains the list of candidate object types and the data items attributes belonging to each. Table contains the list of candidate object type names in column . For each candidate object type name in column column holds a pointer to a list of data item names belonging to the candidate object type. The pointer in column for the savingsAccount object type points to attribute name list containing the attributes names number type status and balance. The pointer in column for the bankcardAccount object type points to attribute name list containing the attributes names number type status balance and creditLimit. When an object of AccountFolder type receives a makeObject request during execution the data item names contained in the field type tokens e.g. of embedded within the leaf type tokens e.g. of embedded within the business object type token e.g. of presented with the makeObject request are compared against lists and of by AccountFolder logic represented by process step of to select the object type for the programming object to embody the data items of the business object token e.g. of . If exemplary business object token of were to originate from the SINQ screen of SS transaction GetSavings depicted and described in relation savingsAccount object type will be chosen over bankcardAccount object type because the list of data item types from the SINQ screen processing is an exact match to the list of attributes of the savingsAccount object type. Because exemplary business object token of originates from the BINQ screen of SS transaction GetBankcard depicted and described in relation bankcardAccount object type will be chosen over savingsAccount object type because the list of data item types from the BINQ screen processing is an exact match to the list of attributes of the bankcardAccount object type and the attributes of the savingsAccount object type are insufficient to contain the data items from the BINQ screen processing. These results are based on default object type selection rules incorporated into the presently described embodiment.

As an alternative to the default object type selection rules the presently described embodiment provides for the application programmer to substitute custom object type selection logic. The application programmer defines a function for each family object type that receives at least the relevant business object type token data from the data stream for its input and provides as its response an indication whether it can embody the business object type token data items. The application programmer incorporates code into the program to register each object type selection function in column of family registration information alongside the name of the object type to which the function relates. Functions must be registered for all or none of the family object types listed in table . If functions are registered the object type selection process of is replaced with the object type selection process depicted in . The use of functions to replace default object type selection processing permits the selection of object type using criteria other than the list of inbound field types alone. For example the value of the field i.e. the data item in a particular instance of a message can factor into the determination of object type e.g. number fields beginning with 51 indicate a savingsAccount object. The flexibility in run time object type determination represents a further advantage of the present invention.

It is noted that numerous examples have been used throughout this detailed description to explain the operation of an embodiment employing the present invention. The discussion of the examples principally described data access operations for retrieving data from a data source i.e. inquiry transactions. One skilled in the art recognizes the obvious modifications required of the examples shown to describe employment of the present invention for data access operations that add or update to a data source. In general the flow of data items is reversed.

Various modifications to the preferred embodiment can be made without departing from the spirit and scope of the invention. Thus the foregoing description is not intended to limit the invention which is described in the appended claims in which 

