---

title: Virtual multidimensional datasets for enterprise software systems
abstract: Techniques are described for specifying virtual datasets within an enterprise software system. A computer-implemented system, for example, includes an enterprise planning system and a computing device coupled to the enterprise planning system via a network connection. The computing device includes an object store that stores a dataset, an application programming interface (API) that defines an operation for specifying the virtual dataset from the dataset, and an object model that stores a virtual dataset to the object store in response to receiving the operation defined by the API. The computing device further includes a plurality of applications that utilize the virtual dataset for a further operation defined by the API without resolving the virtual dataset. Because virtual dataset may be utilized without first resolving them, the virtual datasets may require less storage space within a memory, may automatically remain synchronous with the underlying dataset, and may quickly layer to more readily perform complicated operations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07747562&OS=07747562&RS=07747562
owner: International Business Machines Corporation
number: 07747562
owner_city: Armonk
owner_country: US
publication_date: 20061128
---
This application claims the benefit of U.S. Provisional Application Ser. No. 60 837 659 filed Aug. 15 2006 the entire content of which is incorporated herein by reference.

The invention relates to software systems and for example to enterprise planning and performance management systems.

Enterprise software systems are typically sophisticated large scale systems that support many e.g. hundreds or thousands of concurrent users. Examples of enterprise software systems include inventory management systems budget planning systems order management systems inventory management systems sales force management systems business intelligent tools enterprise reporting tools project and resource management systems and other enterprise software systems.

A computing device for a user typically connects to the enterprise software system via a computing network. The user computing device may provide an operating environment for concurrent execution of multiple planning applications that access multidimensional data stored to a cache on the computing device. Typically the user computing device includes a cache to store datasets requested by the user. In many cases the cache stores complex multi dimensional datasets i.e. data cubes which the user computing device may download from the enterprise software system via the network connection.

Frequently the planning applications perform operations that require access to a subset of the data within the multidimensional datasets. To perform these operations the computing device may create and maintain additional multi dimensional datasets within the cache to temporarily hold the subset of the data being manipulated. The additional datasets consume additional memory resources and require synchronization so as to maintain consistency with the original datasets. These data synchronization techniques may present significant overhead which may further delay execution of the operations.

In general the invention is directed to techniques for specifying and utilizing virtual datasets within a software system such as an enterprise system having one or more enterprise software applications. The virtual datasets may be referenced and manipulated as multidimensional data cubes. However instead of storing actual multidimensional data the virtual datasets contain software for resolving to all or portions of one or more underlying multi dimensional data cubes when necessary. The enterprise software applications manipulate the virtual datasets in the same manner as a real dataset that stores multidimensional data. In this regard the virtual datasets are generally indistinguishable from real datasets from the view of the enterprise software applications. The enterprise software applications can create virtual datasets and perform intermediate operations to manipulate the virtual datasets without necessarily resolving the virtual datasets to the multidimensional data contained within the underlying datasets. In this manner the virtual datasets do not consume vast amounts of resources by storing multidimensional data. Further the virtual datasets avoid any consistency and synchronization issues that may arise when separate datasets storing multidimensional data are created and manipulated.

For example in one embodiment the techniques provide a consistent and flexible object model interface having an application programmers interface API that enables a plurality of enterprise software applications to specify virtual datasets from underlying datasets and perform operations on those virtual datasets. The API accepts as inputs references to virtual datasets possibly in combinations with references to actual datasets and may not require that the virtual datasets be resolved thereby allowing the applications to utilize the virtual dataset in further operations without first resolving the virtual dataset. Thus the applications may layer further operations upon one another. Because the virtual dataset need not be resolved prior to performing further operations the virtual datasets typically require less space in memory may remain synchronous with the referenced dataset and delay complex calculations until the applications demand resolution. Thus the techniques may also significantly decrease the time necessary to perform operations through the use of virtual datasets.

As an example the techniques may be applied to a computing device connected via an enterprise software system via a network. The computing device provides an operating environment for one or more enterprise software applications and includes the object model interface described herein for interacting with multidimensional data cubes. The object model interface provides the API for invoking and manipulating objects in accordance with an object model that defines objects of varying types. An object store located on or possibly remote from the computing device stores datasets as well as virtual datasets. The enterprise software applications execute within the computing device and invoke operations of the API to create and manipulate virtual datasets. For example the API may support a dataset selection operation to select all or a portion of a multidimensional dataset a compound operation that combines multiple datasets a functional operation that performs a mathematical operation on one or more datasets a time series operation or an operation to produce a sequence of values according to a fixed pattern based on a start value and an increment. Each of these operations may be invoked to produce a virtual dataset.

Upon receiving the selection operation for example the API forwards the selection operation to the object model which performs the selection operation on the underlying multidimensional dataset. As inputs the selection operation may allow both datasets and virtual datasets to be specified as source of the select or as the selector. Thus the object model may perform selection operations without first resolving the virtual datasets i.e. resolving the reference to the underlying items of the referenced dataset. In this manner the techniques enable the enterprise software applications to utilize a virtual dataset in subsequent selections via the API without first resolving the virtual dataset.

Similarly the compound function time series and sequence dataset operations provided by the API may be invoked so as to result in the generation of virtual datasets. The compound operation allows the applications to interact with the object model to combine any two or more datasets and or virtual datasets and store this combination to a new virtual dataset. Using the compound operation the applications may more easily present two or more of the datasets and or the virtual datasets within a conventional grid of numbers or spreadsheet like display. The function operation allows the applications to apply a defined function to two or more datasets and or virtual datasets and exposing the result of this function through a new virtual dataset. Using the function operation the applications may perform mathematical functions and through layered functions complex mathematical functions to yield particular results in the form of a new virtual dataset. Finally the sequential time series operation allows an application to apply a time series function to the dataset or a virtual dataset and store the result as a new virtual dataset.

In one embodiment a method comprises storing a dataset to an object store with an object model via an application programming interface API that exposes the object model specifying a virtual dataset from the dataset via an operation defined within the API with a plurality of applications and utilizing the virtual dataset in a further operation defined within the API without resolving the virtual dataset.

In another embodiment a computing device comprises an object store that stores a dataset an application programming interface API for invoking an operation to specify a virtual dataset from the dataset and an object model that stores the virtual dataset to the object store in response to receiving the operation defined by the API. The computing device further comprises a plurality of applications that utilize the virtual dataset for a further operation defined by the API without resolving the virtual dataset.

In another embodiment a system comprises an enterprise planning system and a computing device coupled to the enterprise planning system via a network connection. The computing device comprises an object store that stores a dataset an application programming interface API that defines an operation for specifying the virtual dataset from the dataset and an object model that stores a virtual dataset to the object store in response to receiving the operation defined by the API. The computing device further comprises a plurality of applications that utilize the virtual dataset for a further operation defined by the API without resolving the virtual dataset.

In another embodiment the invention is directed to a computer readable medium containing instructions. The instructions cause a programmable processor to store a dataset to an object store with an object model via an application programming interface API that exposes the object model specify a virtual dataset from the dataset via an operation defined within the API with a plurality of applications and utilize the virtual dataset in a further operation defined within the API without resolving the virtual dataset.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention will be apparent from the description and drawings and from the claims.

For exemplary purposes the invention will be described in reference to a performance management and enterprise planning system such as an enterprise wide financial management system or budget planning system. The techniques described herein may be readily applied to other software systems including other large scale enterprise software systems. Examples of enterprise software systems include order management systems inventory management systems sales force management systems business intelligent tools enterprise reporting tools project and resource management systems and other enterprise software systems.

In the example embodiment of enterprise planning system enables and automates the reconciliation of top down targets with detailed bottom up forecasts for an enterprise. Enterprise planning system implements and manages an enterprise planning process which can be divided into three functions 1 modeling 2 contribution and 3 reconciliation.

Initially high level enterprise managers or executives referred to as analysts define organizational targets and build planning models for the enterprise. The analysts may include for example financial analysts such as the chief financial officer senior financial analysts or product and sales analysts. More specifically the analysts develop a model having a number of hierarchically arranged nodes representing various cost centers within the organization such as business units or departments. The analysts specify corporate target data for each node of the organizational hierarchy. Corporate target data may include financial data revenue data order data inventory data and the like depending on the particular enterprise planning activity being carried out by the enterprise.

Next the analysts assign one or more enterprise users to each node such as managers supervisors sales representatives lab managers or the like that are responsible for enterprise planning for the cost center corresponding to the node. Each enterprise user may be designated as a contributor that provides planning data to enterprise planning system a reviewer that accepts or rejects contributions from the contributors or both. The contributors and reviewers may be authorized users within the enterprise or within other entities coupled to network such as suppliers or customers.

Typically enterprise users that are designated as contributors interact with enterprise planning system to input detailed forecasts in the form of contribution data. As described above enterprise users may provide detailed financial forecasts revenue forecasts order forecasts inventory forecasts estimated resource requirements and the like depending on the particular enterprise planning activity being carried out by the enterprise.

Enterprise planning system automates the reconciliation of the forecast data with the corporate target data provided by the analysts. In particular enterprise planning system operates in accordance with a defined model i.e. the enterprise planning model created by the analysts to provide a hierarchical planning process having multiple reconciliation levels. As each of the contributors provides his or her contribution data enterprise planning system automatically aggregates the contribution data across the enterprise in real time and provides access to the aggregated data to enterprise users designated as reviewers associated with higher levels of the enterprise. In particular upon receiving contribution data from the contributors enterprise planning system identifies all higher levels of the organizational model affected by the newly received contribution data and calculates new aggregate totals at each level in real time.

Consequently the reviewers view aggregated data across the enterprise in real time during the enterprise planning session. At each level enterprise planning system ensures that the reviewers as defined by the nodes of the enterprise model reconcile the target data with the forecast data. Each of the reviewers may for example reject or accept the contribution data in view of corporate targets provided by the analysts. This process continues until the contribution data is ultimately approved by the highest level of the organizational hierarchy thereby ensuring that the contribution data from the contributors reconciles with corporate targets provided by the analysts.

In this manner enterprise planning system may provide more accurate enterprise planning than with conventional techniques. For example enterprise planning system may improve the accuracy and predictability of enterprise planning by enabling organizations to reconcile corporate models and organizational targets with detailed forecasts. The techniques may provide a platform that delivers collaborative real time planning capabilities without requiring offline consolidation and aggregation of forecasts. Because enterprise planning system can aggregate contribution data in real time all users can be presented with an accurate up to date view of the numbers. Further the architecture of enterprise planning system can readily scale to thousands of users and may be designed around best planning practices. In addition the techniques enabling high participation by enterprise users i.e. the contributors and reviewers allowing accurate planning cycles to be reduced

Enterprise users may utilize a variety of computing devices to interact with enterprise planning system via network . For example an enterprise user may interact with enterprise planning system using a laptop computer desktop computer or the like running a web browser such as Internet Explorer from Microsoft Corporation of Redmond Wash. Alternatively an enterprise user may use a personal digital assistant PDA such as a Palm organizer from Palm Inc. of Santa Clara Calif. a web enabled cellular phone or similar device.

Network represents any communication network such as a packet based digital network like the Internet. In this manner system can readily scale to suit large enterprises. Enterprise users may directly access enterprise planning system via a local area network or may remotely access enterprise planning system via a virtual private network remote dial up or similar remote access communication mechanism.

Enterprise planning system may utilize a cut down process by which the multi dimensional data store is sliced for each user in accordance with the defined enterprise model. During this process enterprise planning system identifies areas of the defined model to which users are assigned either as contributors or reviewers and slices the data store based on the assignments. When a given user logs in and proceeds with an enterprise planning activity enterprise planning system communicates the respective data slice to the respective computing device for display to the user via the extended spreadsheet application. In this fashion enterprise planning system need not communicate the entire model to each of users thereby reducing communication time as well as resource requirements. Instead each user receives only relevant information. Users interact with computing devices to capture contribution data and to reconcile the contribution data with organizational targets.

As described herein each of computing devices provide a consistent and flexible object model interface by which planning applications not shown in executing within computing devices may specify virtual datasets locally within computing devices or remotely on enterprise planning system . These virtual datasets may reference a subset of one or more multi dimensional data cubes typically referred to as datasets. The object model interface allows the planning applications to specify these virtual datasets store these virtual datasets to the same object store according to the same object model as the datasets and utilize these virtual datasets for further selections without first resolving the virtual datasets. In this manner the object model interface remains consistent because it enables the planning applications to store both datasets and virtual datasets within the same object store and according to the same object model unlike conventional enterprise systems that store these in separate object stores according to different object models. It is flexible because it allows the planning applications to utilize the virtual datasets for further operations without having to first resolve the virtual datasets.

The object modeling techniques described in more detail below provide consistent and flexible data storage that may reduce the processing time required to perform further operations upon a virtual dataset because computing devices need not resolve the virtual datasets prior to requiring access to the underlying data referenced by the virtual datasets unlike conventional enterprise systems. Moreover the virtual datasets may require significantly less storage space because they store only a reference to items within the dimensions of the datasets not the items themselves thereby possibly decreasing the size of memory necessary to perform enterprise planning operations or increasing the total number of datasets and virtual datasets that can be stored to a cache. Further by only storing a reference to the items and not a copy or duplicate of the item the virtual datasets enables enterprise system to avoid time consuming execution of typical database data synchronization techniques that ensure changes to the data also result in appropriate updates to the copy of the data.

Planning applications represent planning applications executing on computing device A. For example planning applications may include reporting tools modeling tools spreadsheet applications data collection templates business intelligence tools or other types of enterprise planning applications.

Object model interface comprises an application programming interface API that exposes object model . For example object model may be a metadata model for data sets that represent multidimensional data from one or more data cubes. Object store may comprise memory such as a cache that stores specific instantiations of object model .

In general object model represents any hierarchy of data objects and may comprise a series of collections and objects within the collections. In other words object model may comprises a hierarchy of objects each of which contains a collection which in turn provides access to one or more objects. Object model may be wrapped to protect the objects within the collections. In this way user A and planning applications cannot directly alter the data within object model . Instead planning applications interacts with object model via object model interface and more particularly API to specify operations object model may perform. In particular object model interface receives operation calls from planning applications via API and may return the result of the operations to planning applications .

In the example of enterprise planning user A may interact with web browser to enter and manipulate enterprise planning data such as budget or forecast data. Data sets contain multidimensional planning data which may include top down targets and bottom up contribution data and allows all calculations for an enterprise planning session to be performed locally by computing device A. Therefore in this example a contributor can modify his or her respective contribution data and perform calculations necessary for the enterprise planning process without necessarily accessing enterprise planning system . User A may save the planning data locally and submit the planning data to enterprise planning system for aggregation with the planning data from other users .

Enterprise planning system automatically aggregates the contribution data across enterprise in real time and provides access to the aggregated data to reviewers associated with higher levels of the enterprise. This process continues until the contribution data is ultimately approved by the reviewers associated with the highest level of the organizational hierarchy thereby ensuring that the contribution data from the contributors reconciles with corporate targets.

In one embodiment calculation engine and data sets are loaded for use during the enterprise planning session. Calculation engine may for example comprises a forward calculation engine wrapped in an Active X object built in an array based language. In other embodiments calculation engine may be implemented by creating layered function datasets within object store .

As illustrated in object store includes datasets and virtual datasets . Datasets each comprises a multi dimensional or single dimensional object stored in accordance with object model . In some embodiments object model may differentiate between multi and single dimensional objects and instantiate single dimensional objects as lists instead of datasets. Object model may specify lists separate from datasets because the method by which the operations are performed may vary depending upon whether fields within the operations such as the field of the selection operation specifies a list or a dataset. Thus in this embodiment object model may for example specify a different .select method or selection operation for list objects from the .select method for dataset objects. For ease of illustration the invention is discussed herein as if datasets may store lists however the principles of the invention may include embodiments wherein lists remain distinct from datasets.

Virtual datasets may each store information relating to the result of performing an operation on datasets as depicted by the dashed arrow to datasets . Virtual datasets may be manipulated by planning applications as if actual datasets. However virtual datasets are represented in as dashed boxes and termed virtual because they do not actually store the result of a selection but only information referring to the location of the actual underlying data that comprise the result. Because virtual datasets do not store the result but only refer to it virtual datasets may occupy less space in a cache not shown in of computing device A. Further as described below computing device A need not resolve the result i.e. access the underlying hierarchy of data objects referred to by virtual datasets unless planning applications actually require the underlying data objects. Moreover because virtual datasets only store a reference to the data objects object store need not repeatedly synchronize virtual datasets upon altering editing and or updating data objects referenced by virtual datasets and stored within datasets .

Planning applications specify operations that object model performs upon virtual datasets through interactions with object model interface . Specifically API of object model interface provides the following syntax by which planning applications may specify for example a selection operation .Select Planning applications specify the and fields of the .Select method or selection operation. The and fields may accept any of datasets and virtual datasets . As described below the selection operation may accept multiple datasets via the field thereby allowing planning applications to specify dataset projections through the use of the selection operation as described in more detail below. The field may be referred to as the argument list of the selection operation in these and other instances. The field requires that planning applications specify a unique name by which planning applications may later access the result of the selection operation.

Typically the object identified by the field comprises a virtual dataset however in some embodiments the object identified by the field may comprise a dataset as well. In these embodiments object model may require that object model interface indicate whether to resolve the virtual dataset indicated in the field. If object model interface indicates that the resulting virtual dataset should be resolved object model will build a dataset containing the items referred to by the resulting virtual dataset. Planning applications issue this select command to object model interface via API which in turn causes object model to perform the select and instantiate a new virtual dataset in object store containing the reference to one or more of datasets .

In order for object model to perform the select both the and the fields must specify objects that are compatible meaning that the element type must be a member of one of the dimensions of the object. Object model determines whether these are compatible prior to performing the select. For example a object of type salary may comprise a salary dataset referencing month and grade dimensions and a object of type grade may comprise another dataset referencing an employee dimension. In this example object model determines that the salary object referencing a grade dimension and the object having a type grade are compatible because both refer to type grade. Therefore object model performs the selection operation.

Generally object model creates a new virtual dataset identified by the specified name defined in the field by planning applications to which it stores the result of the selection. Next object model performs the selection and stores the resulting information referring to the locations of the underlying items of one of datasets defined in the field. New virtual dataset comprises an object of the same type as that of the source object but may comprise different dimensions. Thus continuing the above example new virtual dataset comprises an object of type salary but this salary object references month and employee dimensions.

After performing an operation such as the selection operation object model may return a reference to the newly selected virtual dataset within object store to object model interface which in turn forwards the reference to planning applications . Planning applications may utilize this reference to virtual dataset for further selections in either the or fields or in fields of other operations such as a compound a function or a sequential operations without first resolving the newly specified virtual dataset . Thus API of object model interface does not require that planning applications only perform operations upon datasets and instead allows planning applications to specify virtual datasets .

API may define other operations than the selection operation such as the compound operation the function operation the time series operation and the sequence generating operation all of which are described below in more detail. Briefly the compound operation allows planning applications to interact with object model to combine any two or more datasets and or virtual datasets and store this combination to a new virtual dataset . Using the compound operation planning applications may more easily present two or more of datasets and or virtual datasets within a conventional grid of numbers or spreadsheet like display. The function operation allows planning applications to apply a defined function to two or more of datasets and or virtual datasets and store the result of applying this function to a new virtual dataset . Using the function operation planning applications may perform mathematical functions and through layered functions complex mathematical functions to yield particular results in the form of a new virtual dataset . The time series operation allows applications to apply time series functions to one or more datasets to generate a new virtual dataset . Finally the sequence operation generates a sequence of data from a specified pattern to produce a virtual dataset .

Because object store stores object for each of datasets and virtual datasets according to the same object model object model interface may provide a consistent API by which planning applications may access each of datasets and virtual datasets . In particular the API provides the operations discussed above by which planning applications may specify virtual datasets and utilize virtual datasets in other operations without first resolving virtual datasets . Because object model may perform these operations without first resolving virtual datasets object model interface enables planning applications to layer these operations upon each other and object model need not resolve virtual datasets until planning applications actually require the underlying data object.

Datasets A named Salary includes a salary object referencing grade version and month dimensions as represented by the three arrowed lines of the cube. Dataset B named EmployeeGradeByMonth includes a grade object referencing employee and month dimensions as represented by the two arrowed lines of the square. Virtual dataset named EmployeeSalary includes a salary object referencing employee month and version dimensions as represented by the three dashed arrowed lines of the dashed lined cube. Virtual dataset also includes reference information that specifies lookup indices in the grade dimension of dataset A as indicated by the dashed line from reference information to dataset A. Reference information represents lookup indices object that when resolved contains indices to employee and month dimensions.

In the example illustration of object model has resolved virtual dataset and therefore computed the necessary indices and stored these indices to reference information as reflected by the above mentioned dashed line to dataset A. Object model typically provides on demand resolution or only resolves reference information i.e. computes the indices and accesses dataset A when requested or demanded by one of planning applications . Thus when one of planning applications invokes the API to create virtual dataset object model defines virtual dataset as a cube shown in dashed form having the proper dimensionality depending on the particular operation being applied without allocating space to store multidimensional data from the underlying dataset A and optionally without computing and storing the indices necessary to retrieve the multidimensional data.

In this example object model creates virtual dataset in response to a selection operation issued by one of planning applications specifying dataset A in the field dataset B in the field and virtual dataset in the field of the .select method as follows EmployeeSalary Salary.Select EmployeeGradeByMonth The resulting EmployeeSalary virtual dataset only stores the specified selectors and the dimensions of the virtual cube along with the indices stored in reference information that were generated upon resolving the virtual data set when demanded by one of the planning applications. Notably object model stores the indices in a two dimension square even though the indices reference the three dimensional data cube of dataset A. Because the indices may require less storage space than the underlying data objects and only two dimensions need be stored rather than three virtual dataset may require less storage space than a corresponding dataset.

Initially API of object model interface receives an operation in accordance with a predefined syntax such as that described above in reference to the selection operation from planning applications . Planning applications for example may specify the and fields as described above. Upon receiving the operation API verifies the syntax and forwards the operation to object model which may determine the compatibility of the specified source and selector datasets as per the selection operation discussed above . Object model may only determine compatibility if two or more selector datasets are specified as described above. If two or more are specified object model may for example access the datasets specified in the field which may comprise one of datasets or virtual datasets stored within object store in order to determine whether they are compatible as described above. API may search the dimensions of each dataset to determine whether each dataset references a different dimension of the dataset. Referring to the example if no two datasets reference the same dimension of the dataset the and datasets are compatible and object model may perform the specified selection operation YES . However if two or more datasets reference the same dimension of the dataset the datasets are incompatible and object model rejects the selection operation and waits for another selection operation NO .

Assuming that the operation specifies compatible datasets if required object model performs the operation . Object model may for example execute the above described selection operation by mapping the dataset s specified by the field onto the compatible dimensions defined in the dataset. After performing this mapping object model stores the result of the mapping to a newly created virtual dataset such as virtual dataset of . As illustrated in virtual dataset includes reference information which object model creates initially as a placeholder in the eventuality that object model resolves virtual dataset . After storing virtual dataset object model returns a reference or handle back to the newly created virtual dataset that stores the result of the selection operation .

In some embodiments the API of object model interface or some other component may indicate whether object model should resolve virtual dataset . In other embodiments object model may only resolve virtual dataset on demand meaning that object model only resolves virtual dataset when planning applications specifically request access via API to items indicated by indices stored in reference information for example. In this embodiment a selection operation for example may never require object model to resolve virtual dataset because a selection operation does not constitute a request operation. On demand resolution may decrease the computational steps necessary to perform a selection operation and therefore possibly reduce the time necessary to perform the selection operation.

Assuming an embodiment offering on demand resolution of virtual dataset object model may not initially resolve virtual dataset and therefore no determination of whether to resolve virtual dataset is necessary . However in some embodiments object model may offer on demand resolution and subsequently receive a request for virtual dataset . Assuming this instance for purposes of illustration object model determines to resolve virtual dataset based on this demand resolves virtual dataset by computing and storing the reference to the underlying items of dataset A in reference information for example and returns the underlying items referenced by virtual dataset in order to satisfy the demand YES . However if no demand for virtual dataset follows object model need not resolve virtual dataset NO . In either instance object model continues to wait for subsequent operations .

As illustrated in object store stores datasets A D datasets and virtual datasets A C virtual datasets . Object model stores each of virtual datasets after receiving an appropriate .select operation from API of object model interface . Planning applications may invoke the .select operation via the API in the following sequence EmployeeSalary Salary.Select EmployeeGrade UKEmployeeSalary EmployeeSalary.Select UKEmployee UKCurrentMonthSalary UKEmployeeSalary.Select CurrentMonth This sequence reflects a successive invocation of the .select method. Other ways of performing the first two .select methods of the above sequence may include a layered approach such as the following UKEmployeeSalary Salary.Select EmployeeGrade .Select UKEmployee or UKEmployeeSalary Salary.Select EmployeeGrade.Select UKEmployee Finally the following more complex multi dimensional layered approach may reach the same result as the three step sequence above UKCurrentMonthSalary EmployeeSalary.Select UKEmployee CurrentMonth All of the above demonstrate the flexibility that API of object model interface may provide to planning applications in invoking various .select methods. For ease of illustration only the first sequence is discussed below.

Referring to object store initially stores datasets A B. Dataset A identified by the name Salary is an object of type salary that references grade and month dimensions. Dataset B identified by the name EmployeeGrade is an object of type grade that references an employee dimension. Planning applications via object model interface issues the following .select operation which is the first selection operation of the above sequence to object model EmployeeSalary Salary.Select EmployeeGrade Because only one dataset B identified as EmployeeGrade operates on the dataset A identified as Salary object model need not determine compatibility as described above. Thus object model performs the mapping of dataset B onto dataset A yielding virtual dataset A which object model creates within object store to store the result of the .select operation.

Virtual dataset A identified by the name EmployeeSalary is a virtual object referencing dimensions employee and month that store virtual elements of type salary as the object must always store elements of the same type as the object. Virtual dataset A references these dimensions because object model translates the grade dimension of dataset A onto the employee dimension of dataset B yielding the employee dimension defined by virtual dataset A.

Virtual dataset A also includes reference information A that may store lookup indices in the grade dimension of dataset A but only in the event object model resolves virtual dataset A as described above. If object model receives no demand from planning applications object model creates reference information A as a placeholder. Thus reference information A includes the text lookup indices in grade dimension only to suggest that object model may store lookup indices to reference information A. Once object model finishes creating virtual dataset A it may await further .select operations.

In this example object model receives the following next .select operation in the above sequence of operations UKEmployeeSalary EmployeeSalary.Select UKEmployee Referring to object store now includes virtual dataset A identified by the name EmployeeSalary from the previous .select operation in the sequence. This second .select operation references virtual dataset A via its name EmployeeSalary and utilizes it in the field without first resolving virtual dataset A as illustrated in by dashed box which indicates that it remains unresolved. The .select operation also references dataset C via its name UKEmployee and utilizes it in the field. Dataset C is shown in as a single arrow which indicates that it is an identity dataset. The value for each cell in the identity dataset is the corresponding member of the single dimension.

Object model receives this second .select operation via the API of object model interface from planning applications . Any one of planning applications may have issued this second .selection operation and the same planning application need not issue all of the .select operations in the sequence. Object model again need not determine the compatibility between now virtual dataset A and dataset C for the reasons described above. Object model first builds virtual dataset B by building a virtual object that references UK employee and month dimensions and stores virtual elements of type salary. Virtual dataset B is identified by the name specified in the result field i.e. UKEmployeeSalary. Next object model creates reference information B as a placeholder where the text lookup indices in employee dimension only suggests that object model may resolve and store the lookup indices in the employee dimension of virtual dataset A. Reference information B may refer to the underlying location of items within virtual dataset A which themselves may refer back to items within dataset A. In particular reference information B includes lookup indices in the employee dimension of virtual dataset A. Once object model finishes building virtual dataset B it may await further .select operations.

In this example object model receives the following final .select operation in the above sequence of operations UKCurrentMonthSalary UKEmployeeSalary.Select CurrentMonth Referring to object store now includes virtual dataset B identified by the name UKEmployeeSalary from the previous .select operation in the sequence. This third.select operation references virtual dataset B via its name UKEmployeeSalary and utilizes it in the field without first resolving virtual dataset B as illustrated in by the dashed box which indicates that it remains unresolved. The .select operation also references dataset D via its name CurrentMonth and utilizes it in the field. Dataset D is shown in as a single square box which indicates that it is a zero dimensional dataset. A zero dimensional dataset is another way of referring to a single scalar value with no dimensions.

Object model receives this third .select operation via API of object model interface from planning applications . Any one of planning applications may have issued this third selection operation and the same planning application need not issue all of the .select operations in the sequence. Object model need not determine the compatibility between now virtual dataset B and dataset D for the reasons described above. Thus object model performs the third .select operation.

Object model first builds virtual dataset C by building a virtual object that references UK employee dimension removing the current month dimension and storing a series of virtual elements of type salary. This provides a generic mechanism for removing specified dimension from a data set. Virtual dataset C is identified by the name specified in the result field i.e. UKCurrentMonthSalary. Next object model creates reference information C as a placeholder unless a subsequent demand requests items referenced by virtual dataset C. If resolved reference information C refers to the underlying location of items within virtual dataset B i.e. lookup indices which themselves may refer back to items within virtual dataset A i.e. further lookup indices that refer back to items within dataset A. In particular reference information C may include a lookup index in month dimension of virtual dataset B. Once object model finishes building virtual dataset C it may await further .select operations or other operations that require object model to resolve any one of virtual datasets .

Although described as referring back to one another e.g. reference information C refers back to virtual dataset B the techniques described herein may allow each of reference information A C to refer directly to the underlying items stored for example by dataset A. In these embodiments object model may compute the lookup indices of each of reference information A C independently such that demand for reference information C for example does not require object model to re resolve reference information B. In other words having once resolved reference information B new reference information C is generated when needed to enable data values to be retrieved directly from the source dataset without repeated reference through reference information B. This technique allows enterprise system to more quickly compute store and return items referenced by reference information C for example.

Although described above in reference to a sequence of .select operations object model may perform layered .select operations as well as complex layered .select operations such as those mentioned above. In performing these operations object model may follow typical syntactical rules pertaining to common programming languages. For example object model will perform the following operation UKEmployeeSalary Salary.Select EmployeeGrade.Select UKEmployee by unwrapping the various .select operations as follows Temp EmployeeGrade.Select UKEmployee UKEmployeeSalary Salary.Select Temp Thus the API of object model interface provides flexible layering of .select operations by breaking the layered and complex layered .select operations into discreet .select operations.

As shown in object store stores a dataset A dataset B and a virtual dataset . Initially object store only stores datasets A B until an object model such as object model of receives a .select operation which may cause object model to build virtual dataset . Planning applications invoke the following .select operation via API of object model interface in order to cause object model to build virtual dataset EmployeeSalary Salary.Select EmployeeGradeByMonth Planning applications specify dataset A by its name Salary in the field dataset B by its name EmployeeGradeByMonth in the field and a new virtual dataset by its name EmployeeSalary in the field. Dataset A comprises an object of type salary that references grade and month dimensions. Dataset B comprises an object of type grade that references employee and month dimensions. Virtual dataset comprises an object of type salary that references employee and month dimensions.

Upon receiving this .select operation or selection operation object model proceeds to perform the .select operation in the manner discussed above. Object model stores a reference to the result of the .select operation to reference information included within virtual dataset . Reference information may include lookup indices in the grade dimension of dataset A if resolved otherwise it remains as a placeholder for future storage of lookup indices. Because dataset B i.e. the dataset specified in the field comprises a multi dimensional dataset this allows for employees to change grade and for the relevant salary to be selected according to the grade in a given month. Although virtual dataset appears similar to virtual dataset A of virtual dataset takes into account grade changes unlike virtual dataset A.

As shown in object store stores a datasets A C and a virtual dataset . Initially object store only stores datasets A C until an object model such as object model of receives a .select operation which may cause object model to build virtual dataset . Planning applications invoke the following .select operation via API of object model interface in order to cause object model to perform the dataset projection storing the result to virtual dataset EmployeeSalary Salary.Select Grade Department . Planning applications specify dataset A by its name Salary in the field dataset B by its name Grade in the first field dataset C by its name Department in the second field and a new virtual dataset by its name EmployeeSalary in the field. Dataset A comprises an object of type salary that references grade and department dimensions. Dataset B comprises an object of type grade that references employee and month dimensions. Dataset C Virtual dataset comprises an object of type salary that references employee and month dimensions. The above selection operation enables planning applications to perform a dataset projection where employee salaries are projected from the dataset specified in the field or dataset A onto the dimensions specified by the datasets specified in the field or datasets B C. If dataset A is changed virtual dataset updates automatically. If selector datasets B or C are changed such as an employee changing grade within dataset B reference information is re resolved.

Upon receiving this .select operation or selection operation object model first determines whether the two datasets are compatible in the manner described above. Here datasets A C are compatible and object model proceeds to perform the .select operation also in the manner discussed above. Object model stores a reference to the result of the .select operation to reference information included within virtual dataset . Reference information includes lookup indices that reference dataset A based on the two selector datasets i.e. datasets B C once resolved otherwise reference information acts as a placeholder until resolved. Because virtual dataset remains virtual or unresolved changes to datasets A C automatically update virtual dataset . Thus should an employee change grade within dataset B for example object model need not make changes to virtual dataset as virtual dataset merely stores a reference to datasets A C. In this manner object model may perform dataset projection to scatter point select individual values from dataset A.

As shown in object store stores a dataset A a dataset B and a virtual dataset . Initially object store only stores datasets A B until an object model such as object model of receives a .select operation via API which may cause object model to build virtual dataset . Planning applications invoke a .select operation similar to those described above via API in order to cause object model to build virtual dataset . Planning applications specify dataset A by its name in the field dataset B by its name in the field and a new virtual dataset by its name in the field similar to the selection operations described above.

Dataset A comprises an object that references respective grade employee version month and salary category dimensions A E in that particular order. Dataset B comprises an object that references respective salary category grade and month dimensions E A D also in that particular order. Virtual dataset comprises an object having reference information that references respective salary category grade employee version and month dimensions E A B C D in that particular order and includes lookup indices if resolved otherwise lookup indices act as a placeholder until resolved by object module . Because multi dimensional object having more than three dimensions are difficult to illustrate a dimensional view or cube illustration is not shown in contrary to the illustrations of previous .

Upon receiving this selection operation object model first determines whether the two datasets are compatible in the manner described above. Here datasets A B are compatible and object model proceeds to perform the selection operation also in the manner discussed above. Object model stores a reference to the result of the selection operation to reference information included within virtual dataset . Reference information includes lookup indices in one of dimensions A E once resolved also as described above. Notably the selection operation ensures that reference information references dimensions A E in a particular order.

Specifically the selection operation ensures that the respective order of salary grade and month dimensions E A D of dataset B carries through to reference information . Reference information as illustrated in reflects this adherence to respective order by ordering salary dimension E first followed by grade dimension A and ending with month dimension D. This order is respective in that dimensions B D which are not referenced by dataset B may be interspersed within this ordering. Because object model while creating reference information must reorder salary dimension E but not any other of dimensions A D to adhere to the respective ordering of dimensions E A D of dataset B it reorders only those dimensions A E that require reordering so as to limit the complexity thereby possibly saving time. Moreover consistent ordering enables users to quickly determine the ordering of referenced dimensions A E within virtual dataset . In one embodiment use of the selection mechanism to reorder the dimensions of source dataset A utilizes three individual selector datasets instead of one selector database B in this example. In this case a 1 dimensional selector dataset is used for each of the dimensions that are having their order specified similar to the identity dataset C of but in this case containing the full source dimension rather than a subset.

Generally the selection operation may operate according to three ordering rules. First the selection operation honors the order of the dimensions of the dataset specified in the field or the order of dimensions E A D of dataset B. Second new dimensions or dimensions not present in the dataset specified field are introduced as early in the sequence as permitted by the first rule. Third the dimension order of the resultant virtual dataset is kept as close to the dimension order of the dataset specified in the field as permitted by the first and second rules. To further elaborate upon these rules the following notation may be helpful 

Let X v a b mean dataset X with dimensions a and b and values from v where the values may possibly be members of a dimension themselves.

Utilizing this notation to express an instance where object model replaces an existing dimension with another dimension and inserts this other dimension at the position of the replaced dimension the following results Sourcev a b .select Selectora q r Selectionv q r b . Here object model performs a selection operation upon a source dataset with dimension a and b and values from v with a selector dataset with dimensions q and r and values from a. Object model creates a new virtual dataset similar to virtual dataset with dimensions q r and b and referencing values v from the original source dataset. As shown via the notation object model honors the respective order of the dimensions of the selector dataset according to the first rule in the selection dataset.

Utilizing this notation again to express an instance where object model performs a selection operation having a dimension b or a one dimensional dataset in the argument list of the selection operation the following same selection dataset as above results Sourcev a b .select Selectora q r bb b Selectionv q r b According to the above notation object model performs a selection operation upon a source dataset with dimension a and b and values from v with both a selector dataset with dimension q and r and values from a and a b dataset with dimension b and values from b. Object model creates a new virtual dataset similar to virtual dataset with dimensions q r and b and referencing values v from the source dataset.

Further use of the notation may further exemplify the first rule as follows Sourcev a b .select bb b Selectora q r Selectionv b q r where contrary to the preceding example the b dataset comes before the selector dataset in the .select argument list. Object model creates a new virtual dataset similar to virtual dataset but in this instance arranges the b dimension before the q and r dimensions due to the switch of the b and selector dataset ordering in the .select argument list.

To express with the above notation that object model inserts new dimensions or dimensions introduced by the selector dataset and not found in the source dataset as early as possible the following results Sourcev a b .select Selectorx q r Selectionv q r a b . Here object model performs a selection operation upon a source dataset with dimensions a and b and values from v with a selector dataset with dimension q and r and values from x. Object model creates a new virtual dataset similar to virtual dataset with dimensions q r a and b and referencing values v from the source dataset.

The notation may also be used to express instances where a disagreement in the dimension order between arguments in the selection operation exist and what object model generates as a result Sourcev a b .select Selector1a q r Selector2b r q Selectionv q r . Here object model performs a selection operation upon a source dataset with dimensions a and b and values from v with both a first selector dataset and a second selector dataset. The notation expresses the disagreement in that the first selector dataset has dimensions q and r and the second selector dataset has dimensions r and q both in that order. Object model resolves the disagreement by honoring the dimension ordering of the first selector dataset thus creating a new virtual dataset similar to virtual dataset with dimensions q and r in that order.

The notation may also express that object model may transpose a source dataset as follows Sourcev a b c .select cc c bb b aa a Selectionv c b a . Here object model performs a selection operation upon the source dataset with dimensions a b and c and values from v with three single dimension datasets a b and c. Object model creates a new virtual dataset similar to virtual dataset by transposing the ordering of the dimensions of the source dataset.

All of the above illustrate that the selection operation provides a flexible and consistent approach to specify virtual datasets.

As shown in object store stores datasets A B and a virtual dataset where virtual dataset stores the result of a stacking compound operation. Initially object store only stores datasets A B until an object model such as object model receives a stacking compound operation via API which may cause object model to build virtual dataset . Planning applications invoke the stacking compound operation via API according to the following syntax in order to cause object model to build virtual dataset compound . . . In the illustrated embodiment of planning applications specify dataset A by its name Salary in the field dataset B by its name Pension in the field and new virtual dataset by its name in the field. As shown by the above syntax planning applications may utilize the stacking compound operation to combine any number of datasets and or virtual datasets as the stacking compound operation similar to the selection operation is not limited for use on strictly datasets.

Dataset A comprises an object of type salary that references grade and month dimensions. Dataset B comprises an object of type numerical Pension that references grade and month dimensions. The result of this example stacking compound operation is a three dimensional result dataset. The dimensions of the resultant virtual dataset are Grade Month where is a newly generated two member dimension containing the members Salary and Pension i.e. one member for each source dataset. Reference information references respective grade and month dimensions and includes lookup indices . Virtual dataset differs from those described above in that it references entirely datasets A B and not a combination of select items within those datasets A B. Lookup indices therefore contain lookup indices for referencing both of datasets A B in their entirety once resolved otherwise lookup indices act as a placeholder until resolved by object model .

Upon receiving this stacking compound operation object model first determines whether the two datasets are compatible i.e. whether datasets A B maintain all of their respective dimensions in common. If not compatible object model does not perform the stacking compound operation. However if compatible object model proceeds to perform the stacking compound operation by creating reference information and in particular lookup indices as a placeholder such that upon resolution of virtual dataset lookup indices reference both of datasets A B in their entirety. Object model arranges reference information such that the reference to datasets A B share their common dimensions which in the illustrated example comprises the grade and month dimensions. As described above after storing virtual dataset object model may return a reference to virtual dataset via object model interface such that planning applications may access virtual dataset . Also as described above with respect to the selection operation planning applications may demand resolution of virtual dataset and object model may resolve virtual dataset in the manner described above.

Referring to object store stores datasets A B and a virtual dataset where virtual dataset stores the result of an appending compound operation. Initially object store only stores datasets A B until an object model such as object model receives an appending compound operation via API which may cause object model to build virtual dataset . Planning applications invoke the appending compound operation via API according to the following syntax in order to cause object model to build virtual dataset compound . . . In the illustrated embodiment of planning applications specify dataset A by its name Salary in the field dataset B by its name EmployeeGradeByMonth in the field and new virtual dataset by its name in the field. Whether a stacking compound operation or appending operation is desired is inferred from whether the input datasets have all dimensions in common stacking or whether they have at most one dimension unique to each appending . Further the appending order may be determined from the order of the source datasets supplied to the compound operation. As shown by the above syntax planning applications may utilize the appending compound operation to combine any number of datasets and or virtual datasets as the appending compound operation similar to the selection operation is not limited for use on strictly datasets.

Dataset A comprises an object of type salary that references grade and month dimensions. Dataset B comprises an object of type employee grade that references employee and month dimensions. Virtual dataset comprises an object of two types salary and employee grade having reference information that references respective month and grade employee dimensions and includes lookup indices . The dashed box of virtual dataset differs from those described above in that it references entirely datasets A B and not a combination of select items within those datasets A B. represents this virtual compound dataset via the dashed box where the upper half of the box references dataset A as shown by the name Salary and the lower half of the box references dataset B as shown by the name EmployeeGradeByMonth. Lookup indices therefore contain lookup indices for referencing both of datasets A B in their entirety once resolved otherwise lookup indices act as a placeholder until resolved by object model .

Upon receiving this appending compound operation object model first determines whether the two datasets are compatible i.e. whether datasets A B maintain only a single uncommon dimension. If not compatible object model does not perform the appending compound operation. However if compatible object model proceeds to perform the appending compound operation by creating reference information and in particular lookup indices as a placeholder such that upon resolution of virtual dataset lookup indices reference both of datasets A B in their entirety. Object model arranges reference information such that the reference to datasets A B share their common dimensions which in the illustrated example comprises the month dimension. As described above after storing virtual dataset object model may return a reference to virtual dataset via object model interface such that planning applications may access virtual dataset . Also as described above with respect to the selection operation planning applications may demand resolution of virtual dataset and object model may resolve virtual dataset in the manner described above.

In this way planning applications may quickly create virtual compound datasets such as virtual datasets through the invocation of the two variations of the compound operation. These virtual compound datasets may enable planning applications to arrange multiple sources of data for easy presentation to a user via a single grid of numbers or spreadsheet like view unlike conventional enterprise planning systems that require the users to switch between a number of grids of numbers or spreadsheet like views.

As shown in object store stores datasets A B indexers A B and a virtual dataset . Initially object store only stores datasets A B and indexers A B until an object model such as object model receives a function operation via API which may cause object model to build virtual dataset . Indexer A B respectively comprise an indexer into dataset A B hence the names A Indexer and B Indexer as shown in . Virtual dataset is an exemplary embodiment of a virtual function dataset. Planning applications invoke the function operation via API according to the following syntax in order to cause object model to build virtual dataset function In the illustrated embodiment of planning applications specify dataset A by its name in the field dataset B by its name in the field a function in the field and new virtual dataset by its name in the field. Planning applications may specify any sort of discreet mathematical operation in the field such as addition subtraction multiplication division etc. Planning applications may layer function operations similar to the above described layering of selection operations to perform complex mathematical operations involving numerous discreet mathematical and non mathematical operations such as string operations.

Dataset A B and virtual dataset are illustrated in a more generalized manner than datasets and virtual datasets of previous FIGS. Datasets A B comprise respective object generally referred to as A and B which may each include an object of any type referencing any number of dimensions. Although shown as datasets either or both of datasets A B may be replaced with virtual datasets as the function operation permits virtual datasets as sources. Virtual dataset comprises reference information where reference information specifies A references A B references B an A indexer reference C a B indexer reference D and a function E once resolved otherwise reference information acts as a placeholder until resolved as described above.

Once resolved A references A represent references to dataset A which is generically termed A. B references B represent references to dataset B which is generically termed B. A indexer reference C represents a reference to A indexer A where A indexer A is an object capable of retrieving the underlying items of object A specified by dataset A in a particular order. B indexer reference D represents a reference to B indexer B where B indexer B is an object capable of retrieving the underlying items of object B specified by dataset B in a particular order. Finally function E specifies the discreet mathematical function to apply to datasets A B and defined by planning applications in the field.

Upon receiving this function operation object model first determines whether the datasets A B are compatible. Object model determines whether datasets A B are compatible by comparing the dimensionalities of each of datasets A B. If the dimensionalities do not match object model does not perform the function operation. However if the dimensionalities match object model proceeds to perform the function operation by creating reference information and in particular A references A B references B A indexer reference C B indexer reference D and function E as placeholders until object model receives a demand for resolution of virtual dataset . As described above after storing virtual dataset object model may return a reference to virtual dataset via object model interface such that planning applications may access virtual dataset . Also as described above with respect to the selection operation planning applications may demand resolution of virtual dataset In response to this demand object model may resolve virtual dataset by calculating A references A B references B A indexer reference C and B indexer reference D.

In this way planning applications may quickly create virtual function datasets such as virtual dataset through the invocation of the function operation. These virtual function datasets may enable planning applications to layer multiple function operations to perform complex mathematical functions on datasets and virtual datasets alike. Because virtual function datasets need not be resolved until demanded they take up less space in memory remain synchronized despite changes to the underlying items and require little computation to create relative to datasets. Thus using the function operation planning applications may quickly organize complicated mathematical functions via layers of virtual function datasets such as virtual dataset and only demand the actual results of the complicated mathematical functions when needed thereby limiting costly computations during the organizational process.

As shown in object store stores datasets and a virtual dataset . Initially object store only stores datasets until an object model such as object model receives a function operation via API which may cause object model to build virtual dataset . Virtual dataset is an exemplary embodiment of a virtual time series or sequence dataset. Planning applications invoke the function operation via API according to the following syntax in order to cause object model to build virtual time series dataset YTDUnitsSold function UnitsSold YTD Current Date .

In the illustrated embodiment of planning applications specify dataset by its name UnitsSold in the field the year to date YTD function in the field Current Date represents the current date and new virtual dataset by its name YTDUnitsSold in the field. In some embodiments the Current Date parameter may not be necessary if a time dimension is still present in the resulting YTDUnitsSold dataset. Planning applications may layer sequential operations similar to the above described layering of selection operations to perform complex sequential operations involving numerous time series operations.

Dataset comprises an object referred to as UnitsSold of type units that references the time and product dimensions. Virtual dataset comprises reference information where reference information specifies UnitsSold references A UnitsSold indexer B and function C as placeholders until resolved. Once resolved UnitsSold references A represent references to dataset . UnitsSold indexer B represents an object capable of retrieving the underlying items of the UnitsSold object specified by dataset in a particular order. Function C specifies the YTD function to apply to datasets and defined by planning applications in the field.

Upon receiving this function operation object model ordinarily determines compatibility which it may do by determining whether dataset varies by a dimension of type time. Here dataset varies by the time dimension and object model determines that dataset is compatible with the time series YTD function. If dataset did not vary by a time increment object model typically rejects the sequence function as it is necessary to perform the YTD function. Object model knows to perform this compatibility test based upon the function type specified in the field of the function operation. Moreover based on type of function specified by the function field object model generates virtual time series dataset in the manner described below.

Upon determining compatibility object model proceeds to perform the sequence operation by creating reference information and in particular UnitsSold references A UnitsSold indexer B and function C as placeholders until resolved. Unlike the previous function operation described in reference to this sub function or sequence operation does not compute a mathematical function in reference to two or more datasets. Instead the sequence operation such as the YTD function computes a total YTD calculation upon a single dataset . The previous function operation computes a mathematical function on a cell to cell basis by referencing items pairs applying the function and storing the result when resolved. Object model does not perform this scalar computation in this instance but instead performs its computation at the list level when resolved. Thus object model generates reference information such that it may perform these list level computations upon receiving a demand to resolve virtual dataset .

In other words object model generates virtual dataset such that it represents a one dimensional sub selection of UnitsSold dataset locked on to a single product at a time. illustrates this by including within virtual dataset a dashed box showing YTDUnitsSold varying by the single dimension labeled Time. The resulting virtual dataset in this example no longer includes the time dimension but only varies by product. In other words a single number has been calculated for each product. Upon receiving a demand for resolution object model calculates reference information such that it specifies a method to move to the next product specified within the product dimension of dataset via UnitsSold indexer B. In response to the demand object model further accesses reference information to position the YTD calculation on a first product computes the YTD for that product and repeats this process until a YTD calculation exists for each product along the product dimension of dataset .

Although not shown in dataset may include more than two dimensions. For example dataset may include an additional dimension titled Channel by which UnitsSold may vary. If object model performed this YTD calculation upon the three dimensional dataset object model would generate additional reference information to navigate dataset so as to successfully calculate a YTD number for each product and channel. In this example the additional reference information may specify how to navigate a two dimensional sub dataset i.e. product by channel dataset instead of the single dimensional sub dataset i.e. product dataset.

In some embodiments a virtual dataset may define a custom view of an underlying dataset. For example an indexer object associated with the virtual dataset may sequentially follow a pattern described by the custom view yet traverse the underlying dataset in a non sequential pattern. Moreover the indexer may not necessarily traverse all of the elements of the dataset and may access some of the elements multiple times depending on the defined view. Examples of indexer objects that may be used with virtual dataset are described in U.S. patent application Ser. No. 11 563 485 filed Nov. 27 2006 entitled ENTERPRISE PLANNING AND PERFORMANCE MANAGEMENT SYSTEM PROVIDING DOUBLE DISPATCH RETRIEVAL OF MULTIDIMENSIONAL DATA the contents of which are incorporated herein by reference.

While described herein in reference to a computing device the invention may reside within other contexts such as an enterprise planning system. In this embodiment the enterprise planning system may comprise similar components as the computing device described herein such as an object model interface an object model and an object store. Typically in this embodiment each computing device would receive their own allocation of memory within the enterprise planning system to which the object model interface the object model and the object store would be stored. The computing devices would interact with enterprise planning system to make selections as described herein however the virtual datasets would reside within the object store on the enterprise planning system instead of within the computing device.

Finally while described herein in reference to various computing devices and enterprise planning systems the principles of the invention may apply equally to a processor capable of executing instructions stored to a computer readable medium. The instructions may cause the processor to perform the various functions pertinent to the invention as described above. Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

