---

title: Framework for modeling continuations in workflows
abstract: Enabling creation of control flow patterns in a workflow via continuations. Each continuation represents an activity execution context for an activity executing in the workflow by a workflow engine virtualizing a managed execution environment. Responsive to a request, the activity execution context is recreated via the continuation and the activity is executed within the recreated context.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08069439&OS=08069439&RS=08069439
owner: Microsoft Corporation
number: 08069439
owner_city: Redmond
owner_country: US
publication_date: 20060330
---
Existing systems attempt to model business processes or other real world interactions between autonomous agents via high level workflows. However the workflows may vary in a variety of dimensions such as a execution and modeling complexity b knowledge of the structure of the flow at design time c statically defined or ad hoc dynamic d ease of authoring and editing the flow at various points in its lifecycle and e weak or strong association of business logic with the core workflow process. Existing workflow models fail to accommodate all these factors.

Further most existing workflow models are based on either language based approaches e.g. BPEL4WS XLANG S and WSFL or application based approaches. Language based approaches are high level workflow languages with a closed set of pre defined constructs which help model the workflow process to the user programmer. The workflow languages carry all of the semantic information for the closed set of constructs to enable the user to build a workflow model. However the languages are not extensible by the developers and represent a closed set of primitives that constitute the workflow model. The languages are tied to the language compiler shipped by the workflow system vendor. Only the workflow system product vendor may extend the model by extending the language with a new set of constructs in a future version of the product. This often requires upgrading the compiler associated with the language. In addition the languages usually do not declaratively expose or define functions or operations that can be readily and efficiently used by other programs.

Application based approaches are applications that have the workflow capabilities within the application to solve a domain specific problem. These applications are not truly extensible nor do they have a programmable model.

Embodiments of the invention enable the creation of control flow patterns in a workflow. In an embodiment the invention generates continuations for program fragments during execution of the program fragments by a meta runtime engine. The meta runtime engine virtualizes a managed execution environment having fixed functionality. Responsive to a request from a user or other source aspects of the invention recreate an activity execution context via the generated continuations and execute within the recreated activity execution context the program fragments or portions thereof.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Referring first to a block diagram illustrates a typical programming paradigm for modeling process centric activities in a workflow. In this figure the diagram shows a three level virtualization model with a managed execution environment at the highest level virtualizing an operating system . The managed execution environment virtualizes the execution of a program executing in the environment in terms of an abstract stack machine that may be implemented independent of the processor architecture of a computing device. The operating system virtualizes a processing unit at the lowest level. Programs at the managed execution environment level lack the ability and efficiency to accommodate complex interactions between processes in a workflow due to the fixed functionality available in the managed execution environment . The managed execution environment also includes various strict requirements unsuitable for handling the complexity and capability of workflows modeling real world workflows. Further the programming codes or routines in the operating system are dependent on the type or configuration of the processing unit and the type of computing architecture e.g. compatible with IBM brand personal computers APPLE brand personal computers or other systems among other constraints. In addition programming languages typically require hardware specific data structures such as a stack heap or thread for the operating system to function properly.

Referring next to aspects of the invention include a continuation based workflow engine meta runtime engine or other framework virtualizing the managed execution environment . The workflow includes a hierarchical composition of activities with each activity representing a unit of work. The workflow engine provides an asynchronous abstract model of execution of the operation codes op codes or the activities in the workflow representing real world processes. The workflow engine is a continuation based runtime that is capable of suspending the programs and resuming them at any point during the execution cycle. While an activity is domain specific the workflow engine is agnostic of domain specificity. Moreover the workflow engine knows nothing about a specific control flow pattern that is packaged in terms of an activity. As such the execution model provided by aspects of the invention is abstract. Further while the entire workflow instance may logically run for an arbitrary amount of time e.g. days months or years the activities associated with the workflow may perform short lived work and yield in a co operative multitasking manner. The abstract execution model of aspects of the invention allows the workflow engine to suspend an instance in the middle of execution and or evict it from memory and resume it in the future. The workflow engine manages such operations across program passivation.

In one embodiment the workflow engine operates to virtualize one or more of the following aspects of the managed execution environment domain specific op codes a thread a synchronization primitive an execution machine an object lifetime a source format an exception a fault fault propagation and fault handling. For example aspects of the invention enable users to write custom op codes in terms of custom activities. In general the workflow engine uses a thread a stack and or a heap from the managed execution environment . With the capability to execute programs written in any programming language and composed in any file format the workflow engine enables program developers to design programs without compromise. By defining activities representing workflow tasks or processes as the base class to be executed by the workflow engine aspects of the invention enable developers to easily and efficiently build domain specific op codes without adhering to the rigid hard coded inflexible and fixed set of functions or activities classes in the managed execution environment . The op codes may be specific to the healthcare industrial financial industry or other domains. The workflow engine in may be any continuation based runtime layered on top of any existing execution framework e.g. the managed execution environment operating system or processing unit in that enables the modeling of continuations and various aspects thereof to allow the programmer to model complex and dynamic control flow patterns. Aspects of the invention enable the definition of activities in any fashion or representation e.g. a flow chart a diagram a numbered description or the like .

Continuations may be used to model complex and dynamic control flow patterns. A continuation represents a program frozen in action and may include a single functional object containing the state of a computation. When the object is evaluated the stored computation may be restarted where it left off. In solving certain types of problems it can be a great help to be able to save the state of a program and restart it later. In multiprocessing for example a continuation conveniently represents a suspended process. In nondeterministic search programs a continuation can represent a node in the search tree.

While the managed execution environment creates a common yet fixed communication environment between programs the ability to model real world processes in such an environment is lacking. For example applications executing in the managed execution environment are limited to an intermediate language to share functions or common object oriented classes. The intermediate language has fixed parameters arguments or schemas or functions.

Referring again to a user e.g. a human an application program an operating system or the like interacts with a computer providing the workflow foundation framework. The computer and a processor associated therewith not shown have access to a memory area storing an execution journal and one or more computer readable components or modules that have computer executable instructions for implementing the workflow foundation. In the embodiment of the computer executable components or modules include an execution machine component a state component a memory component and a replay component . The execution machine component when executed by the computer executes a plurality of program fragments associated with a workflow and virtualizes the managed execution environment having fixed functionality. The state component generates a plurality of continuations for the program fragments being executed by the execution machine component .

Each of the plurality of continuations includes a runtime state and an application state and generally represents an activity execution context or other state of the program fragment at a given point in time. The activity execution context is available independent of the stack associated with the physical thread from the managed execution environment . The runtime state indicates a scheduler queue status e.g. the items in a queue associated with the scheduler or otherwise indicates a program counter identifying an exception handler next scheduled for execution. The application state indicates an activity status e.g. with a reference to the activity tree . The memory component serializes the continuations and stores the serialized continuations in an execution journal. The continuations serialized by the memory component model one or more of the following a control flow pattern an iteration a parallel for each statement a state machine a page flow controller a sequence generator and another continuation. The replay component re creates responsive to a request from the user the runtime state and the application state associated with one or more of the continuations serialized by the memory component . When executed by the computer the replay component executes within the re created runtime state and the application state the program fragments associated with the one or more continuations.

For example using the reference to the continuation an execution handler e.g. a method associated with an activity may schedule more execution handlers e.g. a composite activity may schedule the execution of its children . In one embodiment the reference to the continuation includes the activity execution context as a direct or implicit argument. Compensation of the successfully completed activities may be executed in the future by re invoking the persisted context and executing the compensator method of the activity instance within the context.

Any of the elements in the other figures and language herein constitute means for managing the generated plurality of continuations.

Referring next to an exemplary workflow is shown. In the example of the workflow is a workflow for processing a purchase order. The activities in the workflow may be sequenced such that some of the activities may be performed parallel to or simultaneous with other activities in the workflow while some of the activities in the workflow are executed after completion of other activities in the workflow . The workflow starts from a starting point such as the receipt of an order from a customer. The workflow includes a conditional statement e.g. an IF statement or a WHILE statement which branches into conditional statements and depending on the outcome of the condition in conditional statement . Following conditional statement the workflow includes a parallel structure having two sequences to be executed asynchronously. In the example shown in a Send Email activity and a Get Approval activity are processed in parallel before the workflow completes at .

After conditional statement a drop activities here area indicates that the activity writer or other user may add activities into the workflow before the workflow completes at .

Referring next to a block diagram illustrates a hierarchical structure e.g. a tree structure of a workflow activity. Execution of the activity includes execution of the activity tree starting at the root of the tree. The activity may be configured by software code in any programming language. For example the software code may represent business or application logic or rules written in a specific domain or execution environment. The activity may include one or more work items or other activities implementing the logic or rules. In the embodiment of the activities and associated work items are arranged and executed according to the structure or other execution sequence.

The meta runtime engine defines a scope or boundary for each of the work items associated with an activity. This scope or boundary includes and exposes information e.g. in the form of data metadata or the like such as the shared data or resources to be accessed by the work items associated properties handlers constraints events and the like.

Referring next to an exemplary state automaton defines a set of states through which an activity may transition. Generally the state automaton defines an execution lifetime for the activity. In the exemplary automaton of the activity transitions through the defined set of states as the meta runtime engine executes the activity and evaluates transitions conditions. The meta runtime engine enforces execution of the activity per the abstract automaton. In one embodiment the execution of an activity is performed in terms of the states in the automaton and the specific possible transitions for each of the states.

One exemplary automaton includes an initialized state an executing state and a closed state. In the example of the state automaton includes an initialized state an executing state a canceling state a faulting state a compensating state and a closed state . In another embodiment one or more additional states may be defined in the state automaton without departing from the scope of embodiments of the invention.

In general the state automaton has one or more transition conditions defining transition of the activity through the set of states. In one embodiment if a first automaton is associated with a first activity and a second automaton is associated with a second activity a transition condition of the first automaton of the first activity may be dependent on a current state of the second automaton of the second activity.

Further the state automaton may establish one or more relationships between work items or activities in a composite activity. For example one of the relationship rules may include that before transitioning methods or work items in the root node of the activity tree to the closed state all the work items in the children nodes should be in the initialized state or the closed state . Another rule may specify that the work item in the root node should be in the executing state before transitioning the work items in the children node of the activity tree to the executing state .

Referring next to a diagram illustrates a system for processing workflow activities according to an embodiment of the invention. The system includes a processor which may be a processing unit such as processing unit in or a collection of processing units. The system also includes a storage or memory area for storing data accessible by the processor . In one embodiment the system may be a computer having one or more processors or processing units e.g. processor a system memory e.g. memory area and other components to couple various system components including the processor to the memory area .

For example the memory area stores a plurality of activities for processing in a workflow e.g. the workflow in . Each of the plurality of activities includes one or more work items and the work items may be organized in a hierarchical structure such as a tree structure see . In processing the plurality of activities the processor accesses or executes a scheduler . The scheduler includes a queue of work items e.g. a workqueue and a dispatcher which dequeues the items and invoke the corresponding implementations that perform the work associated with the dequeued work item until the queue is empty. Each unit of work in the queue corresponds to a method implemented by an activity. The method may be referred to as the execution handler. A given activity s complete execution may span invocation and execution of a set of execution handlers enqueued in the queue at an earlier point in time.

A state automaton such as state automaton in defines an execution flow for the work items e.g. work items in a workflow activity. The processor accesses the work items in the plurality of activities via a component or a set of computer executable instructions such as the scheduler to initialize the work items and enqueue or store the work items to a queue . For example the work item as illustrated in is initialized and enqueued in the queue . The work item is next dequeued or removed from the queue by a dispatcher before transitioning to an executing state e.g. executing state in for execution.

In one example the work item includes an activity method or an activity operation routine or a collection of codes for performing a function of requesting input from a user . One or more other activity methods activity operations routines or codes may be included in each of the work items without departing from the scope of aspects of the invention.

As the dispatcher dispatches the work items the processor executes the methods in each of the work items at . In the example of work item the processor may provide a user with a user interface UI to input the requested information or data. In another embodiment the processor may connect to or access an external data source for input. Upon completion of the activity method or activity operation the processor concludes execution of the work item at .

Alternatively the processor may passivate or otherwise capture the executing state of work items e.g. work item at to a data store for subsequent retrieval and continued execution.

Depending on the parameters or conditions during the execution of the work item the work item may proceed to a canceling state e.g. canceling state in or a faulting state e.g. faulting state in . In one embodiment the work item may proceed from the canceling state to the faulting state. In an alternative embodiment a compensating state e.g. compensating state in describes a set of operations or functions to be performed when a fault or exception has occurred.

Referring next to an exemplary flow chart illustrates the modeling of continuations in a workflow. The method includes generating a plurality of continuations for one or more program fragments during execution of the program fragments by a meta runtime engine at . For example the continuations may be generated responsive to a request from an activity associated with one or more of the program fragments. In one embodiment the execution of the program fragment is episodic with each episode persisted as a continuation. The meta runtime engine virtualizes a managed execution environment having fixed functionality. Each of the generated plurality of continuations represents an activity execution context that includes in one embodiment a runtime state associated with the meta runtime engine and an application state associated with the program fragments. A data boundary for the continuations is defined by for example determining the extent scoping and binding of variables to the state in the ambient enclosing context s .

The method stores the generated plurality of continuations at to persist the selected continuation through passivation and to create an execution journal for the program fragments. In one embodiment the continuations are stored according to an execution order of activities associated with the program fragments. The method enables the user to browse the execution journal e.g. via an application programming interface exposed by an activity writer and receives from the user a selection of the one of the stored continuations from the execution journal. The method also enables the user to sort the execution journal and to search the execution journal for continuations that are being executed and or are not being executed.

The method further selects one of the stored continuations from the execution journal and retrieves the selected continuation responsive to a request from a user at . The method also recreates the activity execution context associated with the retrieved continuation at and executes within the re created activity execution context the program fragments associated with the retrieved continuation at .

Computer in and processor in are examples of general purpose computing devices. In one embodiment of the invention a computer is suitable for use in the other figures illustrated and described herein. The computer has one or more processors or processing units and a system memory. The computer typically has at least some form of computer readable media. Computer readable media which include both volatile and nonvolatile media removable and non removable media may be any available medium that may be accessed by computer. By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. For example computer storage media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that may be used to store the desired information and that may be accessed by computer. Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. Those skilled in the art are familiar with the modulated data signal which has one or more of its characteristics set or changed in such a manner as to encode information in the signal. Wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media are examples of communication media. Combinations of any of the above are also included within the scope of computer readable media.

The system memory includes computer storage media in the form of removable and or non removable volatile and or nonvolatile memory. The computer may also include other removable non removable volatile nonvolatile computer storage media.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer. The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer.

Although described in connection with an exemplary computing system environment including computer embodiments of the invention are operational with numerous other general purpose or special purpose computing system environments or configurations. The computing system environment is not intended to suggest any limitation as to the scope of use or functionality of any aspect of the invention. Moreover the computing system environment should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment. Examples of well known computing systems environments and or configurations that may be suitable for use with aspects of the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Embodiments of the invention may be described in the general context of computer executable instructions organized into one or more components or program modules executed by one or more computers or other devices. The data processors of the computer may be programmed by means of the computer executable instructions stored at different times in the various computer readable storage media of the computer. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. Aspects of the invention may be implemented with any number and organization of such components or modules. For example aspects of the invention are not limited to the specific computer executable instructions or the specific components or modules illustrated in the figures and described herein. Other embodiments of the invention may include different computer executable instructions or components having more or less functionality than illustrated and described herein. In operation the computer executes computer executable instructions such as those illustrated in the figures to implement aspects of the invention. Aspects of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

An interface in the context of a software architecture includes a software module component code portion or other sequence of computer executable instructions. The interface includes for example a first module accessing a second module to perform computing tasks on behalf of the first module. The first and second modules include in one example application programming interfaces APIs such as provided by operating systems component object model COM interfaces e.g. for peer to peer application communication and extensible markup language metadata interchange format XMI interfaces e.g. for communication between web services . The interface may be a tightly coupled synchronous implementation such as in Java 2 Platform Enterprise Edition J2EE COM or distributed COM DCOM examples. Alternatively or in addition the interface may be a loosely coupled asynchronous implementation such as in a web service e.g. using the simple object access protocol . In general the interface includes any combination of the following characteristics tightly coupled loosely coupled synchronous and asynchronous. Further the interface may conform to a standard protocol a proprietary protocol or any combination of standard and proprietary protocols. The interfaces described herein may all be part of a single interface or may be implemented as separate interfaces or any combination therein. The interfaces may execute locally or remotely to provide functionality. Further the interfaces may include additional or less functionality than illustrated or described herein.

The following examples further illustrate embodiments of the invention. A control flow is considered to be dynamic in nature when the number of children activities is not known at compile time. For instance a composite activity that models a typical document review process sends messages to the reviewers by concurrently executing a set of primitive reviewer activities. However the number of reviewers may not be known statically at the time the program is authored and hence the exact quantity of children of the composite activity cannot be configured at that time. In such cases the composite activity is configured with a single reviewer activity acting as a template to generate a set of dynamic instances at execution time based on the actual reviewers available. Not only are the control flow aspects of these constructs dynamic in nature but the runtime state including its locality and bindings is also dynamic. For instance an activity that models a state machine is configured with a set of children activities that represent a state. Each state activity is a continuation that represents the state of the meta program or the state machine frozen at a given point in time. The continuation may be executed multiple times and in arbitrary order by aspects of the invention.

Looping constructs may be viewed as special case of dynamic control flows. For example the semantics of an activity that models a ForEach construct dictate that each iteration should create a distinct scope for the state that is contained within the ForEach activity. Scoping of the state involves the locality of the state managing the referential integrity or binding of the states across scopes and managing the extent or the lifetime of state enclosed in a given scope. With aspects of the invention the program state is captured in terms of fields and dependency properties of activities in the program tree. In this manner the notion of locals or temporary variables for activities that model looping constructs is created by effectively generating instances of activities dynamically. This captures the local state of the iteration based on the template activity that represents the body of the loop.

Further unlike a program construct in a non durable non transactional programming environment activities may request to be compensated during subsequent program execution. For example a successfully completed iteration of a DoWhile activity may be compensated at a later point in its lifecycle if its parent activity faults. Aspects of the invention enable such compensation e.g. implementing undo semantics for each iteration by capturing and storing the execution state of the activity corresponding to each iteration as a continuation. The continuation representing the stored execution state may be invoked at a later time to make the original state of execution available when the compensating methods associated with any of the activities attempt to execute.

The order of execution or performance of the operations in embodiments of the invention illustrated and described herein is not essential unless otherwise specified. That is the operations may be performed in any order unless otherwise specified and embodiments of the invention may include additional or fewer operations than those disclosed herein. For example it is contemplated that executing or performing a particular operation before contemporaneously with or after another operation is within the scope of aspects of the invention.

When introducing elements of aspects of the invention or the embodiments thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

Having described aspects of the invention in detail it will be apparent that modifications and variations are possible without departing from the scope of aspects of the invention as defined in the appended claims. As various changes could be made in the above constructions products and methods without departing from the scope of aspects of the invention it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

