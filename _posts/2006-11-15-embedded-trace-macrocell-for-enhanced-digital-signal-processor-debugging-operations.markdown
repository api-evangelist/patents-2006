---

title: Embedded trace macrocell for enhanced digital signal processor debugging operations
abstract: Techniques for the design and use of a digital signal processor, including (but not limited to) for processing transmissions in a communications (e.g., CDMA) system. The method and system improve software instruction debugging operations by capturing real-time information relating to software execution flow and include and instructions and circuitry for operating a core processor process within a core processor. A non-intrusive debugging process operates within a debugging mechanism of a digital signal processor. Non-intrusively monitoring in real time predetermined aspects of software execution occurs with the core processing process and occurs in real-time on the processor. An embedded trace macrocell records selectable aspects of the non-intrusively monitored software execution and generates at least one breakpoint in response to events arising within the selectable aspects of the non-intrusively monitored software execution. The present disclosure controls aspects of the non-intrusive debugging process in response to at least one breakpoint.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08341604&OS=08341604&RS=08341604
owner: QUALCOMM Incorporated
number: 08341604
owner_city: San Diego
owner_country: US
publication_date: 20061115
---
This application is related to the following co pending U.S. patent application Ser. No. 11 560 217 filed Nov. 15 2006 entitled NON INTRUSIVE THREAD SELECTIVE DEBUGGING METHOD AND SYSTEM FOR A MULTI THREAD DIGITAL SIGNAL PROCESSOR U.S. patent application Ser. No. 11 560 323 filed Nov. 15 2006 entitled METHOD AND SYSTEM FOR A DIGITAL SIGNAL PROCESSOR DEBUGGING DURING POWER TRANSITIONS U.S. patent application Ser. No. 11 560 332 filed Nov. 15 2006 entitled METHOD AND SYSTEM FOR TRUSTED ENTRUSTED DIGITAL SIGNAL PROCESSOR DEBUGGING OPERATIONS and U.S. patent application Ser. No. 11 560 344 filed Nov. 15 2006 entitled METHOD AND SYSTEM FOR INSTRUCTION STUFFING OPERATIONS DURING NON INTRUSIVE DIGITAL SIGNAL PROCESSOR DEBUGGING.

The disclosed subject matter relates to data processing systems and processes such as may find use in data communications and similar applications. More particularly this disclosure relates to a novel and improved method and system for digital signal processing debugging operations including providing and making use of an embedded trace macrocell for enhance debugging operations.

Increasingly telecommunications and other types of electronic equipment and supporting video complex audio videoconferencing and other rich software applications involve signal processing. Signal processing requires fast mathematical calculations and data generation in complex but repetitive algorithms. Many applications require computations in real time i.e. the signal is a continuous function of time which must be sampled and converted to digital signals for numerical processing. The processor must execute algorithms performing discrete computations on the samples as they arrive.

The architecture of a digital signal processor DSP is optimized to handle such algorithms. The characteristics of a good signal processing engine include fast flexible arithmetic computation units unconstrained data flow to and from the computation units extended precision and dynamic range in the computation units dual address generators efficient program sequencing and ease of programming.

One promising application of DSP technology includes communications systems such as a code division multiple access CDMA system that supports voice and data communications as well as text messaging and other applications between users over a satellite or terrestrial link. The use of CDMA techniques in a multiple access communication system is disclosed in U.S. Pat. No. 4 901 307 entitled SPREAD SPECTRUM MULTIPLE ACCESS COMMUNICATION SYSTEM USING SATELLITE OR TERRESTRIAL REPEATERS and U.S. Pat. No. 5 103 459 entitled SYSTEM AND METHOD FOR GENERATING WAVEFORMS IN A CDMA CELLULAR TELEHANDSET SYSTEM both assigned to the assignee of the claimed subject matter.

A CDMA system is typically designed to conform to one or more standards. One such first generation standard is the TIA EIA IS 95 Terminal Base Station Compatibility Standard for Dual Mode Wideband Spread Spectrum Cellular System hereinafter referred to as the IS 95 standard. The IS 95 CDMA systems are able to transmit voice data and packet data. A newer generation standard that may more efficiently transmit packet data is offered by a consortium named the 3Generation Partnership Project 3GPP and embodied in a set of documents including Document Nos. 3G TS 25.211 3G TS 25.212 3G TS 25.213 and 3G TS 25.214 which are readily available to the public. The 3GPP standard is hereinafter referred to as the W CDMA Standard.

Complex DSP operational software employing the W DCMA Standard for example requires robust development tools. Such development tools may include those for code generation integration testing debugging and evaluating application performance. In developing and operating software or complex DSP applications such as advanced telecommunications applications there is the need for sophisticated yet non intrusive debugging software. That is debugging software applications must be not only sufficiently robust to monitor test and support the correction of software defects and operational problems but also they may operate so as not to interfere with the core processor software during debugging operations. Otherwise any problems in the core processing software may not be detected or detected properly during the use of such debugging software.

During debugging operations there is a need for associating the non intrusive software debugging process software executing tracing facilities for the associated processor. Such a system may provide information on the processor s state for permitting such information to be captured both before and after a specific event. At the same time such features cannot adding any significant burden to the processor s performance even while the DSP operates at full speed. In combination with a non intrusive debugging operation such a process may provide for configuration in software for capture select trace information for example after a specific sequence of conditions. Such a monitoring and recording mechanism may also operate in conjunction with the non intrusive debugging process for thread selectable operation in a multi threaded processor for permitting various types of configuration and breakpoint determinations and permissions.

Yet a further need exists for a non intrusive debugging system capable of capturing in real time detailed information about the DSP s execution flow and to do so in a non intrusive manner.

A further need exists for a software execution monitoring and recording system for operation in conjunction with a non intrusive debugging mechanism which itself provides for the limitation and focusing of the generation of trace information to one or more regions of interest within the DSP core.

Still further there is a need for a non intrusive debugging system that may respond to the operation of a software execution and monitoring process and system. A need clearly exists for a way to initiate the debugging system itself upon the initiation or a transition in the operation of the software execution monitoring and recording system. Accordingly such a feature may be provided by the associated non intrusive debugging system for such close and operationally synergistic functioning with the software execution monitoring and recording system.

Techniques for providing non intrusive thread selective debugging method and system for a digital signal processor including a multi threaded digital signal processor are disclosed which techniques cooperate with an embedded trace macrocell for initiating debugging operations in response to certain monitored events in core processor operations. The method and system here disclosed improve both the operation of a digital signal processor and the efficient use of digital signal processor instructions for increasingly powerful software applications including applications operating in personal computers personal digital assistants wireless handsets and similar electronic devices as well as increasing the associated digital processor speed and service quality.

According to one aspect of the disclosed subject matter a method and system are provided for improving software instruction debugging operations by capturing real time information relating to software execution flow in a processor. The method and system include and instructions and circuitry for operating a core processor process within a core processor associated with the digital signal processor. The disclosed subject matter operates a non intrusive debugging process within a debugging mechanism of the digital signal processor. Non intrusively monitoring in real time predetermined aspects of software execution associated with the core processing process and occurring in real time on the processor using an embedded trace macrocell. The embedded trace macrocell records selectable aspects of the non intrusively monitored software execution and generates at least one breakpoint in response to events arising within the selectable aspects of the non intrusively monitored software execution. The present disclosure controls aspects of the non intrusive debugging process in response to at least one breakpoint. As a result the disclosed subject matter cooperates with the non intrusive debugging process for multi thread trace instruction sequencing and timing for up to all threads of a multi threaded digital signal processor.

These and other advantages of the disclosed subject matter as well as additional novel features will be apparent from the description provided herein. The intent of this summary is not to be a comprehensive description of the claimed subject matter but rather to provide a short overview of some of the subject matter s functionality. Other systems methods features and advantages here provided will become apparent to one with skill in the art upon examination of the following FIGUREs and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the accompanying claims.

The disclosed subject matter for a non intrusive thread selective debugging method and system for a multi threaded digital signal processor has application for multi threaded processing of any type for which the benefits here presented may be advantageous. One such application appears in telecommunications and in particular in wireless handsets that employ one or more digital signal processing circuits. For explaining how such a wireless handset may be used provides a simplified block diagram of a communications system that may implement the presented embodiments of the disclosed interrupt processing method and system. At a transmitter unit data is sent typically in blocks from a data source to a transmit TX data processor that formats codes and processes the data to generate one or more analog signals. The analog signals are then provided to a transmitter TMTR that modulates filters amplifies and up converts the baseband signals to generate a modulated signal. The modulated signal is then transmitted via an antenna to one or more receiver units.

At a receiver unit the transmitted signal is received by an antenna and provided to a receiver RCVR . Within receiver the received signal is amplified filtered down converted demodulated and digitized to generate in phase I and Q samples. The samples are then decoded and processed by a receive RX data processor to recover the transmitted data. The decoding and processing at receiver unit are performed in a manner complementary to the coding and processing performed at transmitter unit . The recovered data is then provided to a data sink .

The signal processing described above supports transmissions of voice video packet data messaging and other types of communication in one direction. A bi directional communications system supports two way data transmission. However the signal processing for the other direction is not shown in for simplicity. Communications system may be a code division multiple access CDMA system a time division multiple access TDMA communications system e.g. a GSM system a frequency division multiple access FDMA communications system or other multiple access communications system that supports voice and data communication between users over a terrestrial link. In a specific embodiment communications system is a CDMA system that conforms to the W CDMA Standard.

Output from execution data paths goes to register file write circuit also configured to accommodate individual threads T T for returning the results from the operations of DSP . Thus the data path from circuit and before to register file write circuit forms a processing pipeline . The present embodiment may employ a hybrid of a heterogeneous element processor HEP system using a single processor with up to six threads T T. Processor pipeline has six stages which matches the minimum number of processor cycles necessary to fetch a data item from circuit to registers and . DSP concurrently executes instructions of different threads T T within a processor pipeline . That is DSP provides six independent program counters an internal tagging mechanism to distinguish instructions of threads T T within processor pipeline and a mechanism that triggers a thread switch. Thread switch overhead varies from zero to only a few cycles.

DSP therefore provides a general purpose digital signal processor designed for high performance and low power across a wide variety of signal image and video processing applications. provides a brief overview of the DSP architecture including some aspects of the associated instruction set architecture for one manifestation of the disclosed subject matter. Implementations of the DSP architecture support interleaved multithreading IMT . In this execution model the hardware supports concurrent execution of multiple hardware threads T T by interleaving instructions from different threads in the pipeline. This feature allows DSP to include an aggressive clock frequency while still maintaining high core and memory utilization. IMT provides high throughput without the need for expensive compensation mechanisms such as out of order execution extensive forwarding networks and so on. Moreover the DSP may include variations of IMT such as those variations and novel approaches disclosed in the commonly assigned U.S. patent applications by M. Ahmed et al and entitled Variable Interleaved Multithreaded Processor Method and System and Method and System for Variable Thread Allocation and Switching in a Multithreaded Processor. 

Sequencer provides hybrid two way superscalar instructions and four way VLIW instructions to S Pipe unit M Pipe unit LD Load Pipe and LD ST Store Pipe unit all of which communicate with general registers . AXI Bus also communicates via Bus I F with shared data cache LD ST instructions to threads T T. Optional L Cache TCM signals include LD ST instructions with shared data TCM which LD ST instructions further flow to threads General Registers . From AHB peripheral bus MSM specific controller communicates interrupts with T T including interrupt controller instructions debugging instructions and timing instructions. Global control registers communicates control register instructions with threads T T.

DSP therefore includes six virtual DSP cores each containing global control registers and private supervisor control registers . Global control registers are shared between all threads. Each thread shares a common data cache and a common instruction cache. Load store and fetch operations are serviced by a common bus interface. High performance AXI bus and a lower performance AHB bus are used to connect the data and instruction traffic to off core memory and peripherals. An integrated level two memory cache and or TCM input is optional. Peripheral access may be through memory mapped loads and stores. The physical address partition between AHB and AXI may be configured at the MSM level.

Clearly the presented architecture for DSP may evolve and change over time. For example the number of instruction caches that DSP may use could change from six to one or other numbers of caches. Superscalar dispatch L data at TCM and other architectural aspects may change. However the present subject matter may have continued relevance in a wide variety of configurations and for a large family of modifications of DSP .

ISDB through JTAG interface provides a hardware debugger for DSP . ISDB provides software debug features through JTAG interface by sharing system or supervisor only registers that are divided into supervisor control registers on a per thread basis as well as global control registers between all threads. The system control registers are used for per thread interrupt and exception control and per thread memory management activities. Global registers allow interacting with the ISDB for debugging operations.

ISDB enables software developers to debug their software while DSP operates. ISDB hardware in combination with a software debugger program operating in ISDB may be used to debug the DSP operating system software. ISDB supports debugging hardware threads individually. Users may suspend thread execution view and alter thread registers view and alter instruction and data memory single step threads stuff instructions to threads and resume thread execution. Trusted users have access to all of ISDB features while untrusted users have access to a subset of features.

ISDB may interface with a debugger interface card to communicate with ISDB debugging software residing on a program counter yet all through JTAG interface . Host debugger software may interact with the ISDB by reading and writing ISDB control registers. Communication for example may be through a 40 bit packet which identifies the ISDB register to which read write is to occur as well as a 32 bit data payload. A packet format supporting this operation may be up to 64 control registers which may be 32 bits wide each.

ISDB includes a trusted register for controlling security during a debugging operation. If the ISDB trusted is set then all ISDB registers are visible to the debugger software and all ISDB commands are available for use. In the case that ISDB trusted is cleared then ISDB only permits a restricted set of operations. These aspects of the present disclosure appear in more detail below.

Certain ISDB registers may be made visible to core software. These are accessible via SUPERVISOR mode control register transfer instructions. The core instructions include a breakpoint instruction. When ISDB trusted is set this instruction causes the executing thread to enter a debugging operational mode. This transition shifts thread control to ISDB . In addition to the thread that executed a breakpoint other threads may optionally enter DEBUG mode according to ISDB programming. If ISDB is not trusted or not enabled this instruction is treated as a NOP. Preferably the breakpoint instruction is the only instruction in a packet.

Having listed the various components of ISDB what follow are a brief operational description and introduction to the constituent parts of the control or logic circuitry for performing non intrusive trusted and untrusted debugging operations of DSP . ISDB controller handles a variety of tasks including a implementing various ISDB registers b synchronizing the MCD external breakpoint and resume triggers and the ETM breakpoint trigger to DSP before they are forwarded to CU for further processing c generating MCD breakpoint and resume triggers based on debug mode status of core and d adding a pipeline stage for signals sent out to DSP sub system such as ISDB interrupt breakpoint event etc.

CU includes circuitry and instructions capable of handling the tasks such as a processing breakpoints and generating breakpoint triggers to each thread b generating micro breakpoint and micro resume commands c maintaining ISDB status and mailbox registers and d implementing the certain ISDB registers. CU includes a breakpoint processing logic BPL block as appears in for processing all the breakpoints and generating a macro breakpoint request to a micro command generator of CU ISDB controller . The micro command generator processes the macro breakpoint request along with instruction stuff commands instruction step and resume commands and issues micro breakpoint and resume commands to CU for pipeline control.

CU ISDB controller maintains the state of ISDB based on the breakpoint and resume acknowledge signals received back. The mailbox functions of CU ISDB controller maintain mailbox registers used for communication between the host debug software and the DSP core processor. These mailbox functions also contain ISDB status registers.

The per thread mode state diagram of is supported by various instructions or events. These include Except or internal exception event an Int or external interrupt event an RTE or software return instruction from exception mode and SSR or update to SSR register instruction a Stop or software stop instruction that may be entered from any mode a Start or software Start Instruction that also may be entered from any mode a trap or software Trap Instruction a Wait or software wait Instruction a Resume or software Resume Instruction a DE or Debug Event and a DR or Debug Instruction. While the functions in different implementations of the claimed subject matter may vary slightly from those here presented the meanings of Start Wait Resume DE and or DR may be given their broadest interpretations consistent with the scope of the claimed subject matter.

Registers are available in DSP in both USER mode and SUPERVISOR mode . The user mode registers are divided into a set of general registers and a set of control registers. General registers are used for all general purpose computation including address generation scalar and vector arithmetic. Control registers support special purpose functionality such as hardware loops predicates etc. General purpose registers are 32 bits wide and may be accessed as single registers or as aligned pairs of two registers. The general register file provides all operands for instructions including addresses for load store data operands for numeric instructions and vector operands for vector instructions.

DEBUG mode provides a special state where the thread is waiting for commands from ISDB . Whenever an ISDB Debug Event occurs such as by the execution of a software breakpoint instruction a breakpoint command from ISDB or occurrence of a hardware breakpoint indicated threads may enter DEBUG mode . While in DEBUG mode the core is controlled by ISDB via commands from JTAG interface . When the ISDB releases the thread due to execution of a resume command the thread may resume operation according to their current mode settings. When a thread is in DEBUG mode it is controlled by ISDB and cannot be controlled by other threads. A Wait Resume Start or Stop instruction from a running thread targeting a thread in DEBUG mode may be ignored. Similarly a Non Maskable Interrupt NMI may be ignored by threads in DEBUG mode .

A HARDWARE RESET mode not shown in and DEBUG mode are global to all threads. Whenever the hardware reset pin is asserted regardless of any thread s processing state DSP may enter HARDWARE RESET Mode. In HARDWARE RESET mode all registers are set to their reset values. No processing may occur until the hardware reset pin is de asserted. When the reset pin is asserted the processor may transition into reset mode and all registers may be reset to their HARDWARE RESET values. After the reset pin is de asserted thread T may be given a soft reset interrupt. This may cause thread T to enter SUPERVISOR mode and begin executing at the reset vector location. All other threads may remain off. At this point the software is free to control mode transitions for each thread individually.

In it is seen that breakpoint logic or BPL circuit of CU ISDB controller includes breakpoint triggers from six different sources including hardware breakpoints 0 1 HWBKPT and HWBKPT software breakpoint SWBKPT JTAG breakpoint JTAGBKPT ETM embedded trace macro breakpoint ETMBKPT and external breakpoint EXTBKPT . Breakpoint triggers through and debug mode status input go to encode breakpoint encoder to cause DSP to operate in DEBUG mode . Output from encoder includes three 3 breakpoint information bits and a breakpoint valid bit . Breakpoint information data enters breakpoint information circuit to cause a breakpoint information JTAG interface command . Breakpoint bit also generates OR gate input and reset circuit input. Reset circuit receives either a UCG resume thread number or a reset input to generate reset control output into OR gate . Either valid bit or reset output may cause OR gate to generate BPL breakpoint output .

The breakpoint triggers in BPL circuit are processed along with the corresponding TNUM mask to generate macro breakpoint trigger to each of the threads. The macro breakpoint trigger bpl breakTnum ANY 0 is maintained until the corresponding thread is resumed. The number of pipeline stages that can be used in BPL is driven by hardware breakpoints which are precise breakpoints i.e. the instruction that triggers hardware breakpoint match must not be executed. The thread switches to debug mode after executing the program until that instruction. The disclosed embodiment provides a macro breakpoint trigger one cycle after the breakpoint triggers arrive. For that reason the breakValid input is logically OR ed with its latched version input to generate bpl breakTnum ANY 0 output .

Through the use of breakpoints the six threads of DSP may individually enter and exit DEBUG mode . A breakpoint trigger may come from five sources which correspond to the five different types of breakpoints supported in ISDB . Upon hitting a breakpoint a thread transitions from its current mode e.g. WAIT RUN to DEBUG mode . In DEBUG mode the thread waits for commands from ISDB . A thread in OFF mode is powered down and may not accept any commands from ISDB . The latency of entering DEBUG mode is implementation defined such as in the present disclosure as relating to the event a power collapse. For example an implementation may choose to complete a given operation for example finish an outstanding load request before entering DEBUG mode . In one embodiment a thread identifier register contains an 8 bit read write field and is used for holding a software thread identifier. This field is used by the hardware debugger to match breakpoints.

There are a number of different ways to enter a breakpoint process. For example for HWBKPT and HWBKPT breakpoints if a register equals a predetermined value then when the program counter PC matches the predetermined value then the process goes into the DEBUG mode . ASIDs Address Space Identifiers are tags similar to process IDs in a process or a particular thread in a multithreaded process. So physical address virtual address ASID PC or other qualifiers may be used to optionally obtain a fix of the location of the program in a space at which point a breakpoint may occur. The uses of breakpoints here referenced are more particularly disclosed in the commonly assigned U.S. patent applications by L. Codrescu et al and entitled NON INTRUSIVE THREAD SELECTIVE DEBUGGING METHOD AND SYSTEM FOR A MULTI THREADED DIGITAL SIGNAL PROCESSOR. The disclosed subject matter provides a path for moving into a DEBUG mode in the event of a breakpoint such as those of . The disclosed subject matter controls which thread or sets of threads in the DSP go into the DEBUG mode .

Of significance for the present disclosure is the embedded trace macrocell ETM unit of DSP which enhances user debugging of code by capturing in real time detailed information about the software execution flow. The ETM non intrusively monitors and records selected DSP execution forms the execution information into packets and sends out the packet stream either off chip or to an on chip memory known as an ETB. The ETM also contains a number of mechanisms to limit or focus the generation of trace information to the region of interest. Using the packet stream a reconstruction of the execution can be created giving the user direct visibility of the code s runtime behavior.

In the implementation of ISDB JTAGSync circuit receives JTAG isdb chain in signal into ISDB Test Data Register to generate JTAG isdb chain out signal . ISDB Test Data Register includes read write R W bits Address bits 6 0 and Data bits 31 0 . Values in R W bits go to AND gate as do Sync circuit output and CU trustedDebug input . JTAG isdb chain update tkl signal and ISDB CLK signal control the operation of Sync circuit . Address information from Address bits may be received by Address Decode circuit which feeds ISDB Registers . ISDB Registers transfers data with Data bits 31 0 in response to a write enable signal from AND gate .

ETM provides comprehensive debug and trace facilities for DSP and other similar digital signal processors. They allow information on the processor s state to be captured both before and after a specific event while adding no burden to the processor s performance as DSP runs at full speed. The ETM may be configured in software to capture only select trace information and only after a specific sequence of conditions. A dedicated configurable trace port and FIFO then allow the compressed trace data to be read from the chip by an external trace port analyzer without interrupting or affecting the processor.

The trace port can be configured from a 1 to 32 bit data bus with trace clock independent to the core clock. For example the data rate from the ETM can be half of the core clock and the number of pins increased to maintain the data bandwidth. Similarly the number of pins can be halved and the data rate increased. The ETM may be used in both stand alone and within a multi core environment to allow the developer to view simultaneous correlated trace from multiple asynchronous cores.

As shown in the ETM monitors the DSP pipeline. Using this information ETM performs two primary functions filtering triggering and compression packetization. The filtering and triggering operations are programmed by the user through JTAG interface and are used to define when to turn tracing on and off. The compression packetization unit takes the DSP execution information and efficiently forms it into packets that are sent out of ETM through the trace port. The trace stream leaving ETM is fed into trace repository . Trace repository provides a large memory capacity for recording trace records and may be either off chip or on chip. The on chip repository is known as an embedded trace buffer ETB . Decompressor component is a software component running on ISDB that takes the packet stream from trace repository and along with the program image reconstructs the execution flow of DSP giving the user detailed visibility into the DSP pipeline . ETM provides trace instruction sequencing and timing for all six threads as well as the ability to record and send out profiling counts cache misses bank conflicts and micro tlb misses . ETM may trigger on PC and LDST addresses as well as on LDST data. ETM supports serial and external event detections. Moreover ETM has the ability to generate ISDB breakpoint trigger events external trigger event and DSP interrupts. ETM is programmable through JTAG and may support a dedicated ETB trace repository of 512 32 bits in one embodiment. ETM may contain 4 trigger blocks each with 2 address and 1 data comparators and may contain a 3 state sequencer. ETM tracing may operate under the control of a secure DSP enable register and may be programmed for operation during DSP power collapse.

ETM generates an instruction trace as a recording of the full progression of the program counter for a thread over a given window in time. Optionally the timing of the program counter progression i.e. identification of stall cycles can also be included in an instruction trace. The event resources mechanisms are used to define when to generate these instruction traces. The trigger and filtering functions are controlled through the programming of the event resources. In more detail the event resources control filtering triggering and ISDB breakpoint generation. Filtering includes the functions of deciding when to enable and disable an instruction trace. Triggering involves deciding when to insert a trigger marker into the packet stream. ISDB breakpoint determination involves specifying the conditions under which ISDB generates and responds to a breakpoint for debugging operations.

ETM contains a number of primary event resources e.g. address and data comparators to detect when specific conditions within DSP occur e.g. whether a certain PC is executed or if a certain memory location is read . In addition there are secondary event resources trigger blocks and the sequencer which enable detection of more complex arrangements of events.

ETB trace repository provides an on chip memory area where trace information is stored during capture rather than being exported immediately through a trace port at the pins of the device. The stored information can then be read out at a reduced clock rate from ETB trace repository once capture has been completed. This is done through JTAG interface . This two step process removes the necessity for a wide trace port that uses many high speed device pins. Effectively a zero pin trace port is created where the device already has a JTAG port at the pins. ETB trace repository may accept data at a higher frequency and with the full 32 bit data port exceeding trace port bandwidth limitations and may integrate with a RAM block supplied by the system integrator.

In one embodiment ETB trace repository has a size of 2 KB arranged as 512 entries each 32 bits wide. ETB trace repository interfaces with the user through a set of JTAG accessible registers. Each register can be read or written through JTAG interface . These registers are used to set up ETB trace repository for a trace capture session and to read out the contents of ETB trace repository once trace capture is complete. ETB trace repository provides a read pointer as an index into the ETB trace repository memory array. When reading out the contents of ETB trace repository through JTAG interface the read pointer indicates the location to read. ETB trace repository also provides a write pointer as an index into the ETB trace repository memory array. When trace data is written into ETB trace repository it is written to the entry indicated by the write pointer. Each of the write operations auto increment the write pointer to the next location after write occurs. ETB trace repository may only capture a small window of the ETM trace stream. The ETB looks for a trigger packet from the ETM to determine when to capture data and the trigger counter is used to specify the division between pre trigger data and post trigger data captured by ETB trace repository .

Each trigger block circuit contains ASID and TID match registers to optionally limit SAC circuit and DC circuit matches to a particular thread or group of threads. In addition each trigger block circuit may be limited to a single hardware thread. SAC circuit detects when an address generated by a memory access instruction matches a pre programmed value. SAC circuit supports 32 bit comparison. The memory source for the comparison is programmable among program counter and load store address. For one embodiment the comparison type may be programmable with the following options equal not equal greater than or equal or less than 

DC circuit detects when a memory access data value matches a pre programmed value and can perform 32 bit comparisons. For 64 bit accesses source is programmable between upper and lower word. Supports equal and not equal comparison types. A 32 bit mask register may be used to filter out portions of the comparison. DC circuit supports any byte matching and the access type can be set as load or store load only or store only. In addition output of DC circuit may be selectably disabled.

SAC circuit and DC circuit matches determine when counter circuit decrements. As shown in SAC circuit match results can either be ANDed or ORed together. This result is then combined with the DC circuit match result. This final result is used to enable counter circuit . Counter circuit may be preloaded with a user defined value and decrement as matches occur. When the trigger counter reaches 0 the trigger block signals a match to the sequencer.

Counter circuit contains a three bit state enable mask that controls when the counter is reloaded. When a new state is entered if this state matches one of the enabled states in the state enable mask then the counter is reloaded. The counter is also automatically reloaded anytime it reaches zero. The counter can be bypassed by setting the count to 1. The match results from the two SAC circuits are also used to enable or disable instruction flow tracing.

Filtering portion permits trigger block circuit to trace on individual SAC circuit matches. Thus for each SAC circuit if the associated state enable mask matches and if SAC circuit matches tracing is enabled. Trace can occur also on address range match. Tracing is enabled based on the AND of SAC circuit matches. The match is then further qualified with a state enable mask. Each of the three trace sources has a separate three bit state enable mask to qualify the match with the current state. Using the above rules the user may for example define different trace regions. One region may include trace instructions flow for thread i if the program counter PC is greater than 100 and less than 200 and only if the circuit is in state 1.

A second region may be for trace instruction flow for thread j if the PC is less than 100 and if we are in state 0 or if the PC is greater than 200 and in state 2. Because multiple trigger blocks exist the final trace enable is the OR of each trigger block s trace enable. All threads that match the combined results of the address comparison the state enabling and the thread matching may be traced. If multiple active threads match the enabling conditions those threads may be traced concurrently.

Each trigger block circuit therefore thread match circuit which functions to limit the operation of both triggering portion and filtering portion to a particular thread or group of threads. Each trigger block contains TID match circuit TID mask circuit ASID match enable circuit and TNUM match enable circuit . To use this capability the match registers may be programmed with reference values that are used to compare against the current thread s identifiers. For a TID match circuit the comparison can be restricted to certain portion of the TID through the TID mask circuit . This allows a group of TIDs to be matched. In addition for each match type the matching can be disabled through user programmable enable registers. trigger block circuit only operates on threads that meet all of the qualifying conditions.

One aspect of ETM includes a sequencer process for chaining of events and more complex event detection scenarios. To illustrate operation of the sequencer process and associated trigger block circuits presents sequencer flow diagram . In response to trigger block circuit inputs sequencer process operates in the shown example at three states S S. For operation of sequencer process from state S process flow may go to S or S. From S sequencing advances either ahead to S or back to S. From S sequencing advances to either S or S.

Sequencer process therefore includes three states S S with the transitions between states being programmable and based on matches from trigger blocks circuits . The table of lists the programmable rules for each transition. Sequencer process has use in trace filtering for enabling each trigger blocks circuits to be conditioned on state enables. This allows tracing to be restricted to certain states. Upon entering a new state the counter in each trigger blocks circuits may be reloaded to an initial value. Upon entering a given state an ISDB breakpoint can be asserted. Upon entering a given state a trigger marker can be inserted into the trace stream. Upon entering a given state an external trigger control may also be asserted. The external trigger may remain asserted anytime that the sequencer is in the given state. Upon entering a given state an interrupt to DSP may be asserted. After reset the counter is initialized to state 0. If multiple transitions fire at the same time the sequencer remains in the current state.

ETM contains six counters that can record various events related to DSP performance. The basic operation makes use of each counter as a programmable source. A user programmable region counter divides execution into windows of a fixed number of cycles. During the window the events are accumulated into counters. At the end of the window the counter values are formed into packets and sent out through the trace port. The counters are then reset and the process begins again. When the profiling unit is operated in at the same time as the program flow tracing this results in the program flow trace being overlaid with detailed information about performance events. In addition the profiling unit contains a state enable mask to limit when the unit is active.

A region counter is used to divide up the execution into windows of a fixed number of cycles. The size of the region is determined by a user programmable register. The region counter is initialized to the user specified value and all of the profiling event counters are reset. The region counter then begins counting down. When the region counter reaches zero the value for each of the profiling event counts is emitted in the trace stream. The process then begins again. The region counter only counts when the state enable matches. When the profiling is inactive the region counter maintains its value and resumes when an enabled state is re entered.

Different events for which a profiling counter may accumulate information include a d cache misses b d cache stall cycles c i cache misses d i cache stall cycles e ITLB and DTLB misses and f total stall cycles. In addition each profiling counter contains a six thread mask to restrict the counter to events that occur in certain hardware threads.

As with the region counter the profiling counters are only active when the state enable mask matches the current state. During all other times the counts maintain their values and counting resumes when an enabled state is re entered.

The functioning of ETM is determined by the setting of various user programmable registers. Each register is accessed through JTAG interface . provides a table listing ETM control registers for this purpose.

In summary the disclosed subject matter provides a method and system for improving software instruction debugging operations by capturing real time information relating to software execution flow in a processor. The method and system include and instructions and circuitry for operating a core processor process within a core processor associated with the digital signal processor. The disclosed subject matter operates a non intrusive debugging process within a debugging mechanism of the digital signal processor. Non intrusively monitoring in real time predetermined aspects of software execution associated with the core processing process and occurring in real time on the processor using an embedded trace macrocell. The embedded trace macrocell records selectable aspects of the non intrusively monitored software execution and generates at least one breakpoint in response to events arising within the selectable aspects of the non intrusively monitored software execution. The present disclosure controls aspects of the non intrusive debugging process in response to at least one breakpoint. As a result the disclosed subject matter cooperates with the non intrusive debugging process for multi thread trace instruction sequencing and timing for up to all threads of a multi threaded digital signal processor.

The processing features and functions described herein for trusted and untrusted non intrusive thread selective debugging in a multi threaded digital signal processor may be implemented in various manners. For example not only may DSP perform the above described operations but also the present embodiments may be implemented in an application specific integrated circuit ASIC a microcontroller a digital signal processor or other electronic circuits designed to perform the functions described herein. Moreover the process and features here described may be stored in magnetic optical or other recording media for reading and execution by such various signal and instruction processing systems. The foregoing description of the preferred embodiments therefore is provided to enable any person skilled in the art to make or use the claimed subject matter. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments without the use of the innovative faculty. Thus the claimed subject matter is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

