---

title: Query condition building using predefined query objects
abstract: A method, system and article of manufacture for query processing and, more particularly, for managing execution of a query against data in a database. One embodiment comprises receiving a query having (i) at least one result field configured to return data from at least one data record included with the database, and (ii) a query condition comprising a field and a query object associated with the field by an operator configured to select values for the field from the query object. The method further comprises determining whether the query object is configured to provide one or more valid values for the field. If the query object is not configured to provide one or more valid values for the field, the query object is transformed into a transformed query object that is configured to provide one or more valid values for the field. Then, the query is executed against the database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07584178&OS=07584178&RS=07584178
owner: International Business Machines Corporation
number: 07584178
owner_city: Armonk
owner_country: US
publication_date: 20060420
---
This application is related to the following commonly owned application US Patent U.S. Pat. No. 6 996 558 issued Feb. 7 2006 entitled APPLICATION PORTABILITY AND EXTENSIBILITY THROUGH DATABASE SCHEMA AND QUERY ABSTRACTION which is hereby incorporated herein in its entirety.

The present invention generally relates to query processing and more particularly to creating query conditions for queries against data in a database using predefined query objects.

Databases are computerized information storage and retrieval systems. The most prevalent type of database is the relational database a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways. A distributed database is one that can be dispersed or replicated among different points in a network. An object oriented programming database is one that is congruent with the data defined in object classes and subclasses.

Regardless of the particular architecture a database management system DBMS can be structured to support a variety of different types of operations for a requesting entity e.g. an application the operating system or an end user . Such operations can be configured to retrieve add modify and delete information being stored and managed by the DBMS. Standard database access methods support these operations using high level query languages such as the Structured Query Language SQL . The term query denominates a set of commands that cause execution of operations for processing data from a stored database. For instance SQL supports four types of query operations i.e. SELECT INSERT UPDATE and DELETE. A SELECT operation retrieves data from a database an INSERT operation adds new data to a database an UPDATE operation modifies data in a database and a DELETE operation removes data from a database.

Any requesting entity including applications operating systems and at the highest level users can issue queries against data in a database to obtain required information. Queries may be predefined i.e. hard coded as part of an application or generated in response to input e.g. user input . Queries may include both an explicit specification of result fields for which data is to be returned upon execution of the queries and criteria used for selection of the data. The data selection criteria are generally represented as query conditions that serve to filter the data returned for the result fields upon execution of the query. Accordingly a query may be thought of as group of filters put together to sift out only the result field data of interest.

One common technique in query condition building consists in defining subqueries that are configured to define suitable data selection criteria. More specifically for a given outer query an inner query or subquery can be defined such that a corresponding result set of the subquery is suitable to filter the data returned for the result fields of the outer query. In SQL this can be performed using a so called IN condition that links a field of a query condition of the given outer query to the subquery. Thus by executing the subquery valid values for the field of the query condition can be identified. Such a subquery is particularly useful in cases where the valid values need to be retrieved from a different database table than the data that is to be returned for the result field s of the given outer query.

However several difficulties occur in creating and using subqueries as query conditions for SQL queries against underlying databases. First the users generally need some knowledge of the layout of an underlying database and of SQL to be able to accurately create a subquery for a given outer SQL query. This can be difficult and is error prone if the outer SQL query and or the subquery are complex. Furthermore while a data type check may be performed on each query condition of the outer SQL query it is not determined whether the values included with a retrieved query result for the subquery are suitable for an associated field of the outer SQL query. For instance assume that a patient id field of a query condition of a given outer query requires integer values and that an associated subquery returns integer values for a weight field. In this case the data types of the patient id field and the weight field are compatible and the outer SQL query is validated. However a result set obtained in executing the outer SQL query may not be useful as the weight values may not be suitable for the patient id field. Thus merely confirming that the data type of the returned result set i.e. weight values which are integer values corresponds to the data type of the outer query does not ensure that the returned values are in fact the values needed since weight values are not patient IDs . Thus mere data type checking is inadequate. Moreover the subquery must return values only for a result field that matches the field of the query condition to which the subquery is linked. For instance assume that the subquery returns values for the patient id field and for another result field such as a LastName result field or the weight field as described above. In this case the subquery would return too many output values and therefore the outer SQL query would result in an error when being executed.

The present invention is generally directed to a method system and article of manufacture for query processing and more particularly for managing execution of a query having a query condition that is defined using a predefined query object against data in a database.

One embodiment provides a computer implemented method of managing execution of a query against data in a database. The method comprises receiving a first query having i at least one result field configured to return data from at least one data record included with the database and ii a query condition comprising a field and a query object associated with the field by an operator configured to select values for the field from the query object. The method further comprises determining whether the query object is configured to provide one or more valid values for the field. If the query object is not configured to provide one or more valid values for the field the query object is transformed into a transformed query object that is configured to provide one or more valid values for the field. Then the first query is executed against the database the first query including the transformed query object if the transforming was performed.

Another embodiment provides a computer readable medium containing a program which when executed by a processor performs operations for managing execution of a query against data in a database. The operations comprise receiving a first query having i at least one result field configured to return data from at least one data record included with the database and ii a query condition comprising a field and a query object associated with the field by an operator configured to select values for the field from the query object. The operations further comprise determining whether the query object is configured to provide one or more valid values for the field. If the query object is not configured to provide one or more valid values for the field the query object is transformed into a transformed query object that is configured to provide one or more valid values for the field. Then the first query is executed against the database the first query including the transformed query object if the transforming was performed.

The present invention is generally directed to a method system and article of manufacture for query processing and more particularly for managing execution of a query against data in a database. In general queries are executed against one or more underlying databases each having a multiplicity of data records. Each query includes at least one result field for which data from the underlying database s is to be returned in a corresponding result set. A query may further include one or more query conditions for filtering which of the data records contained in the underlying database s are returned for each result field.

In one embodiment a given query includes at least one query condition having a field and a query object. The query object is associated with the field by an operator configured to select values for the field from the query object. By way of example the at least one query condition is a so called IN condition that is defined using SQL.

According to one aspect different types of query objects such as subqueries or predefined data sets can be associated with the field of the query condition. A subquery can be created by a user using a suitable query building user interface. Alternatively the subquery can be retrieved from a repository of persistently stored queries. A predefined data set can be retrieved from a repository of persistently stored data sets that may include one or more query results.

In one embodiment it is determined which type of query object is included with the given query. Then it is determined whether the query object is configured to provide one or more valid values for the field of the at least one query condition. For instance if the field of the at least one query condition is a patient id field that requires integer values and if the query object is a subquery it is determined whether the subquery returns integer values that are suitable for the patient id field. If the query object is not configured to provide one or more valid values for the field the query object is transformed on the basis of the determined type of the query object into a transformed query object that is configured to provide one or more valid values for the field. For instance if the subquery in the given example returns character values for a LastName field the subquery is modified to return suitable integer values for the patient id field. Then the query is executed against the underlying database s .

In the following reference is made to embodiments of the invention. However it should be understood that the invention is not limited to specific described embodiments. Instead any combination of the following features and elements whether related to different embodiments or not is contemplated to implement and practice the invention. Furthermore in various embodiments the invention provides numerous advantages over the prior art. However although embodiments of the invention may achieve advantages over other possible solutions and or over the prior art whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus the following aspects features embodiments and advantages are merely illustrative and unless explicitly present are not considered elements or limitations of the appended claims.

One embodiment of the invention is implemented as a program product for use with a computer system such as for example computer system shown in and described below. The program s of the program product defines functions of the embodiments including the methods described herein and can be contained on a variety of computer readable media. Illustrative computer readable media include but are not limited to i information permanently stored on non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive ii alterable information stored on writable storage media e.g. floppy disks within a diskette drive or hard disk drive or iii information conveyed to a computer by a communications medium such as through a computer or telephone network including wireless communications. The latter embodiment specifically includes information to from the Internet and other networks. Such computer readable media when carrying computer readable instructions that direct the functions of the present invention represent embodiments of the present invention.

In general the routines executed to implement the embodiments of the invention may be part of an operating system or a specific application component program module object or sequence of instructions. The software of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine readable format and hence executable instructions. Also programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular nomenclature that follows is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

In any case it is understood that is merely one configuration for a computer system. Embodiments of the invention can apply to any comparable configuration regardless of whether the computer is a complicated multi user apparatus a single user workstation or a network appliance that does not have non volatile storage of its own.

The computer could include a number of operators and peripheral systems as shown for example by a mass storage interface operably connected to a storage device by a video interface operably connected to a display and by a network interface operably connected to the plurality of networked devices which may be representative of the Internet via a suitable network. Although storage is shown as a single unit it could be any combination of fixed and or removable storage devices such as fixed disc drives floppy disc drives tape drives removable memory cards or optical storage. The display may be any video output device for outputting viewable information.

Computer is shown comprising at least one processor which obtains instructions and data via a bus from a main memory . The processor could be any processor adapted to support the methods of the invention. In particular the computer processor is selected to support the features of the present invention. Illustratively the processor is a PowerPC processor available from International Business Machines Corporation of Armonk N.Y.

The main memory is any memory sufficiently large to hold the necessary programs and data structures. Main memory could be one or a combination of memory devices including Random Access Memory nonvolatile or backup memory e.g. programmable or Flash memories read only memories etc. . In addition memory may be considered to include memory physically located elsewhere in the computer system for example any storage capacity used as virtual memory or stored on a mass storage device e.g. direct access storage device or on another computer coupled to the computer via bus . Thus main memory and storage device could be part of one virtual address space spanning multiple primary and secondary storage devices.

The application s is configured to issue queries against the database . However it should be noted that any suitable requesting entity including an operating system and at the highest level users may issue queries against the database . Accordingly all such different implementations are broadly contemplated.

The queries issued by the application s may be predefined i.e. hard coded as part of the application s or may be generated in response to input e.g. user input . In one embodiment the application s issues a query as defined by a corresponding application query specification . The resulting query is generally referred to herein as an abstract query because the query is composed according to abstract i.e. logical fields rather than by direct reference to underlying physical data entities in the database . The logical fields are defined by the data abstraction model which generally exposes information as a set of logical fields that may be used within a query e.g. the abstract query issued by the application s to specify criteria for data selection and specify the form of result data returned from a query operation. In one embodiment the application query specification may include both criteria used for data selection selection criteria and an explicit specification of the fields to be returned return data specification based on the selection criteria as illustrated in .

The logical fields of the data abstraction model are defined independently of the underlying data representation i.e. one of the plurality of exemplary physical data representations being used in the database thereby allowing queries to be formed that are loosely coupled to the underlying data representation. More specifically a logical field defines an abstract view of data whether as an individual data item or a data structure in the form of for example a database table. As a result abstract queries such as the query may be defined that are independent of the particular underlying data representation used. Such abstract queries can be transformed into a form consistent with the underlying physical data representation for execution against the database . By way of example the abstract query is translated by a runtime component into a concrete i.e. executable query which is executed against the database to determine a corresponding result set for the abstract query .

In one embodiment illustrated in the data abstraction model comprises a plurality of field specifications and five shown by way of example collectively referred to as the field specifications also referred to hereinafter as field definitions . Specifically a field specification is provided for each logical field available for composition of an abstract query. Each field specification may contain one or more attributes. Illustratively the field specifications include a logical field name attribute collectively field name and an associated access method attribute collectively access methods . Each attribute may have a value. For example logical field name attribute has the value FirstName and access method attribute has the value Simple . Furthermore each attribute may include one or more associated abstract properties. Each abstract property describes a characteristic of a data structure and has an associated value. In the context of the invention a data structure refers to a part of the underlying physical representation that is defined by one or more physical entities of the data corresponding to the logical field. In particular an abstract property may represent data location metadata abstractly describing a location of a physical data entity corresponding to the data structure like a name of a database table or a name of a column in a database table. Illustratively the access method attribute includes data location metadata Table and Column . Furthermore data location metadata Table has the value contact and data location metadata Column has the value f name . Accordingly assuming an underlying relational database schema in the present example the values of data location metadata Table and Column point to a table contact having a column f name .

In one embodiment groups i.e. two or more of logical fields may be part of categories. Accordingly the data abstraction model includes a plurality of category specifications and two shown by way of example collectively referred to as the category specifications. In one embodiment a category specification is provided for each logical grouping of two or more logical fields. For example logical fields and are part of the category specifications and respectively. A category specification is also referred to herein simply as a category . The categories are distinguished according to a category name e.g. category names and collectively category name s . In the present illustration the logical fields are part of the Name and Address category and logical fields are part of the Birth and Age category.

The access methods generally associate i.e. map the logical field names to data in the database e.g. database of . As illustrated in the access methods associate the logical field names to a particular physical data representation in the database. By way of illustration two data representations are shown an XML data representation and a relational data representation . However the physical data representation indicates that any other data representation known or unknown is contemplated. In one embodiment a single data abstraction model contains field specifications with associated access methods for two or more physical data representations . In an alternative embodiment a different single data abstraction model is provided for each separate physical data representation .

Any number of access methods is contemplated depending upon the number of different types of logical fields to be supported. In one embodiment access methods for simple fields filtered fields and composed fields are provided. The field specifications and exemplify simple field access methods and respectively. Simple fields are mapped directly to a particular entity in the underlying physical representation e.g. a field mapped to a given database table and column . By way of illustration as described above the simple field access method shown in maps the logical field name FirstName to a column named f name in a table named contact . The field specification exemplifies a filtered field access method . Filtered fields identify an associated physical entity and provide filters used to define a particular subset of items within the physical representation. An example is provided in in which the filtered field access method maps the logical field name AnyTownLastName to a physical entity in a column named l name in a table named contact and defines a filter for individuals in the city of Anytown . Another example of a filtered field is a New York ZIP code field that maps to the physical representation of ZIP codes and restricts the data only to those ZIP codes defined for the state of New York. The field specification exemplifies a composed field access method . Composed access methods compute a logical field from one or more physical fields using an expression supplied as part of the access method definition. In this way information which does not exist in the underlying physical data representation may be computed. In the example illustrated in the composed field access method maps the logical field name AgeInDecades to AgeInYears 10 . Another example is a sales tax field that is composed by multiplying a sales price field by a sales tax rate.

It is contemplated that the formats for any given data type e.g. dates decimal numbers etc. of the underlying data may vary. Accordingly in one embodiment the field specifications include a type attribute which reflects the format of the underlying data. However in another embodiment the data format of the field specifications is different from the associated underlying physical data in which case a conversion of the underlying physical data into the format of the logical field is required.

By way of example the field specifications of the data abstraction model shown in are representative of logical fields mapped to data represented in the relational data representation shown in . However other instances of the data abstraction model map logical fields to other physical representations such as XML.

An illustrative abstract query corresponding to the abstract query shown in is shown in Table I below. By way of illustration the illustrative abstract query is defined using XML. However any other language may be used to advantage.

Illustratively the abstract query shown in Table I includes a selection specification lines 004 008 containing selection criteria and a results specification lines 009 013 . In one embodiment a selection criterion consists of a field name for a logical field a comparison operator 

An illustrative data abstraction model DAM corresponding to the data abstraction model shown in is shown in Table II below. By way of illustration the illustrative Data Abstraction Model is defined using XML. However any other language may be used to advantage.

By way of example note that lines 004 008 correspond to the first field specification of the DAM shown in and lines 009 013 correspond to the second field specification .

As was noted above the abstract query of Table I can be transformed into a concrete query for query execution. An exemplary method for transforming an abstract query into a concrete query is described below with reference to .

Referring now to an illustrative runtime method exemplifying one embodiment of transforming an abstract query e.g. abstract query of into a concrete query using the runtime component of is shown. The method is entered at step when the runtime component receives the abstract query such as the abstract query shown in Table I as input. At step the runtime component reads and parses the abstract query and locates individual selection criteria and desired result fields. At step the runtime component enters a loop defined by steps and for processing each query selection criteria statement present in the abstract query thereby building a data selection portion of a concrete query. In one embodiment a selection criterion consists of a field name for a logical field a comparison operator 

After building the data selection portion of the concrete query the runtime component identifies the information to be returned as a result of query execution. As described above in one embodiment the abstract query defines a list of result fields i.e. a list of logical fields that are to be returned as a result of query execution referred to herein as a result specification. A result specification in the abstract query may consist of a field name and sort criteria. Accordingly the method enters a loop at step defined by steps and to add result field definitions to the concrete query being generated. At step the runtime component looks up a result field name from the result specification of the abstract query in the data abstraction model and then retrieves a result field definition from the data abstraction model to identify the physical location of data to be returned for the current logical result field. The runtime component then builds at step a concrete query contribution of the concrete query that identifies physical location of data to be returned for the logical result field. At step the concrete query contribution is then added to the concrete query statement. Once each of the result specifications in the abstract query has been processed the concrete query is executed at step .

One embodiment of a method for building a concrete query contribution for a logical field according to steps and is described with reference to . At step the method queries whether the access method associated with the current logical field is a simple access method. If so the concrete query contribution is built step based on physical data location information and processing then continues according to method described above. Otherwise processing continues to step to query whether the access method associated with the current logical field is a filtered access method. If so the concrete query contribution is built step based on physical data location information for a given data structure s . At step the concrete query contribution is extended with additional logic filter selection used to subset data associated with the given data structure s . Processing then continues according to method described above.

If the access method is not a filtered access method processing proceeds from step to step where the method queries whether the access method is a composed access method. If the access method is a composed access method the physical data location for each sub field reference in the composed field expression is located and retrieved at step . At step the physical field location information of the composed field expression is substituted for the logical field references of the composed field expression whereby the concrete query contribution is generated. Processing then continues according to method described above.

If the access method is not a composed access method processing proceeds from step to step . Step is representative of any other access method types contemplated as embodiments of the present invention. However it should be understood that embodiments are contemplated in which less then all the available access methods are implemented. For example in a particular embodiment only simple access methods are used. In another embodiment only simple access methods and filtered access methods are used.

Referring now to a relational view of software components in one embodiment is illustrated. The software components illustratively include a user interface a DBMS one or more applications only one application is illustrated for simplicity and an abstract model interface . The abstract model interface illustratively provides an interface to a data abstraction model e.g. data abstraction model of and a runtime component e.g. runtime component of . The DBMS illustratively includes a database e.g. database of having one or more database tables and a query execution unit having a query engine and a query rewriter .

According to one aspect the application and more generally any requesting entity including at the highest level users issues queries against the database . The database is shown as a single database for simplicity. However a given query can be executed against multiple databases which can be distributed relative to one another. Moreover one or more databases can be distributed to one or more networked devices e.g. networked devices of . The database is representative of any collection of data regardless of the particular physical representation of the data. A physical representation of data defines an organizational schema of the data. By way of illustration the database may be organized according to a relational schema accessible by SQL queries or according to an XML schema accessible by XML queries . However the invention is not limited to a particular schema and contemplates extension to schemas presently unknown. As used herein the term schema generically refers to a particular arrangement of data.

In one embodiment the queries issued by the application are created by users using the user interface which can be any suitable user interface configured to create submit queries. According to one aspect the user interface is a graphical user interface. However it should be noted that the user interface is only shown by way of example any suitable requesting entity may create and submit queries against the database e.g. the application an operating system or an end user . Accordingly all such implementations are broadly contemplated.

In one embodiment the requesting entity accesses a suitable database connectivity tool such as a Web application an Open DataBase Connectivity ODBC driver a Java DataBase Connectivity JDBC driver or a Java Application Programming Interface Java API for creation of a query. A Web application is an application that is accessible by a Web browser and that provides some function beyond static display of information for instance by allowing the requesting entity to query the database . An ODBC driver is a driver that provides a set of standard application programming interfaces to perform database functions such as connecting to the database performing dynamic SQL functions and committing or rolling back database transactions. A JDBC driver is a program included with a database management system e.g. DBMS to support JDBC standard access between the database and Java applications. A Java API is a Java based interface that allows an application program e.g. the requesting entity the ODBC or the JDBC that is written in a high level language to use specific data or functions of an operating system or another program e.g. the application .

Accordingly the queries issued by the application can be in physical form such as SQL and or XML queries which are consistent with the physical representation of the data in the database . Alternatively the queries issued by the application are composed using the abstract model interface . In other words the queries are created on the basis of logical fields defined by the data abstraction model and translated by the runtime component into concrete i.e. executable queries for execution. As was noted above such queries are referred to herein as abstract queries . An exemplary abstract model interface is described above with reference to .

Illustratively the application issues a query against the database as illustrated by a dashed arrow . In one embodiment the query is specified by a user using the user interface . The query includes at least one result field for which data from the database is to be returned and one or more query conditions . The query conditions are configured for filtering which data record s contained in the database is are returned for each of the result fields . At least one of the query conditions includes a field that is associated with a query object using an operator which is configured to select values for the field from the query object . By way of example the field can be a column of a database table such as the table or a logical field of an underlying data abstraction model such as the data abstraction model . The query object is an object that is usable to determine values for the field .

More specifically in one embodiment the query object is a subquery of the query that is either created upon specification of the query or retrieved from a query repository having one or more predefined queries as indicated by a dashed arrow . By way of example a user may use the user interface to create the subquery using a corresponding query building application. Alternatively the user interface may display a plurality of predefined queries of the query repository to the user in order to allow user selection of the subquery. In both cases the user interface can be configured to allow only specification or selection of a suitable query object .

The subquery may include a single result field that matches the field . In this case the query can be executed using techniques that are well known in the art and therefore not explained in more detail. However in one embodiment the subquery includes a plurality of result fields that either include a particular result field that matches the field or not. If no matching result field is included with the subquery the subquery may still access the same database table as the query i.e. table as indicated by a dashed arrow . In these cases the subquery can be processed such that it returns only valid values for the field . An exemplary method of processing a subquery in one embodiment is described below with reference to .

Furthermore in one embodiment the query object can be defined using a predefined data set. For instance the query object can be defined by a query result included with a result repository as illustrated by a dashed arrow . In these cases the predefined data set can be processed in order to determine the valid values for the field therefrom. An exemplary method of processing a predefined data set in one embodiment is described below with reference to .

In one embodiment processing a subquery or a predefined data set that defines the query object includes determining whether the query object is configured to provide one or more valid values for the field . Exemplary methods for determining whether the query object is configured to provide the valid value s are described by way of example below with reference to . If so the query object is transformed into a transformed query object whereby the query object is rewritten using the query rewriter such that is returns valid values for the field . Thereby a rewritten query is created that can be executed against the database . Operation of the query rewriter is described in more detail by way of example with reference to below.

However it should be noted that the query rewriter is merely described by way of example to illustrate a component which is suitable to implement aspects of the invention. In other words the functions of the query rewriter can be implemented into other functional components. For instance in one embodiment the functions of the query rewriter are implemented by the query engine or a component which is implemented separate from the query execution unit . All such implementations are broadly contemplated.

The rewritten query is executed by the query execution unit against the database using the query engine to determine a query result . It should be noted that the query execution unit illustratively only includes the query engine and the query rewriter for simplicity. However the query execution unit may include other components such as a query parser and a query optimizer. A query parser is generally configured to accept a received query input from a requesting entity such as the application s and then parse the received query. In one embodiment the query parser may be configured to identify the type of the query object and then forward the parsed query to the query rewriter for rewriting the query if required. The query parser may then parse the rewritten query and forward the parsed rewritten query to the query optimizer for optimization. A query optimizer is an application program which is configured to construct a near optimal search strategy known as an access plan for a given set of search parameters according to known characteristics of an underlying database e.g. the database an underlying system on which the search strategy will be executed e.g. computer system of and or optional user specified optimization goals. But not all strategies are equal and various factors may affect the choice of an optimum search strategy. However in general such search strategies merely determine an optimized use of available hardware software components to execute respective queries. Once an access plan is selected the query engine then executes the rewritten query according to the selected access plan.

When executing the rewritten query against the database the query engine identifies each data record of the database that satisfies the query condition s to identify the result set for the query . In one embodiment the result set is persistently stored for subsequent retrieval in the result repository . The result set is then returned from the query execution unit to the application . Operation of the query execution unit is described in more detail below with reference to .

Referring now to one embodiment of a method for managing execution of a query e.g. query of having a query condition with a query object is illustrated. In one embodiment at least part of the steps of the method is performed by the query execution unit of . Furthermore at least several steps of the method can be performed on the basis of user input received via the user interface of . Method starts at step .

At step a query against an underlying database e.g. database of is received from a requesting entity e.g. application of . The query includes at least one result field e.g. result fields of and one or more query conditions e.g. query condition of . At least one query condition includes a field e.g. field of and a query object e.g. query object of associated with the field by an operator e.g. operator of configured to select values for the field from the query object.

At step it is determined whether the query object is a subquery. For purposes of illustration assume that the received query was composed by a user using the user interface of . For instance assume a researcher who wants to perform a study concerning employees of a hospital that have been treated by medical staff of the hospital in order to determine whether the treated employees received better care than customers. To this end the researcher wants to determine whether specific types of expensive treatments or diagnosis tests that are suitable to detect certain diseases are more frequently performed on employees. Illustratively an exemplary disease is pancreatic cancer and exemplary expensive treatments therefore are chemotherapy and node removal surgery. Accordingly the researcher defines the query in order to retrieve information for patients that have had a pancreatic cancer diagnosis node removal surgery and chemotherapy. The researcher further defines the subquery such that it restricts the retrieved information to information for patients that are also employees of the hospital.

An exemplary query is illustrated in Table III below. By way of example the query of Table III below is defined using SQL. However note that the exemplary SQL query of Table III has been simplified such that the relevant parts thereof are not obscured by irrelevant code language. Furthermore persons skilled in the art will readily recognize complete SQL and or corresponding XML representations such as used to describe the exemplary abstract query of Table I. Accordingly it should be noted that implementation of the exemplary query of Table III is not limited to a particular machine readable language and that an implementation in any machine readable language known or unknown is broadly contemplated.

The exemplary SQL query of Table III is configured to retrieve the required information for particular patients from a database table Treatment Table line 002 . The particular patients which are also employees of the hospital are identified using an IN condition lines 007 014 that links an illustrative subquery lines 008 014 to a field patient id of one lines 007 014 of the query conditions defined in lines 003 014 using the SQL operator IN line 007 . The subquery is configured to retrieve values for any field line 008 included with a database table Employee Table line 009 having data for each employee of the hospital. Note that in the given example the Patient Table line 002 is merely used to provide the patient id field that is used to join the different tables. However as SQL is well known in the art the exemplary query of Table III is readily understood by persons skilled in the art and is therefore not explained in more detail.

In the given example it is determined at step that the query object is a subquery that includes a multiplicity of result fields Select in line 008 of Table III . Accordingly processing continues at step where the subquery is processed such that it returns valid values only for a single result field that matches the field of the at least one query condition i.e. the patient id field line 007 . An exemplary method of processing a subquery is described below with reference to . In one embodiment processing the subquery includes rewriting the received query in order to obtain a rewritten query e.g. rewritten query of that is executable against the underlying database. The method then proceeds with step .

If however it is determined at step that the query object is not a subquery processing continues at step . At step it is determined whether the query object specifies a reference to a persistently stored query e.g. a query included with query repository of . If so the stored query is retrieved and included as a subquery with the received query at step . For instance assume that in the given example the exemplary query illustrated in Table IV below is received at step . By way of example the query of Table IV below is also defined using SQL and simplified as described above with reference to Table III.

It should be noted that lines 001 007 of the exemplary query of Table IV correspond to lines 001 007 of Table III above. However instead of an explicit subquery as included with lines 008 014 of Table III above the exemplary query of Table IV only includes a reference to a persistently stored query saved query referred to as Research Candidate List in line 008.

Assume now that the Research Candidate List query is defined by the exemplary query illustrated in Table V below. By way of example the query of Table V below is also defined using SQL and simplified as described above with reference to Table III.

It should be noted that the exemplary query of Table V essentially corresponds to the subquery defined in lines 008 014 of Table III. However instead of having any field of the Employee Table as result field Select in line 008 of Table III the exemplary query of Table V is configured to retrieve only values for a LastName FirstName and Address field line 007 of Table V .

If at step the Research Candidate List query is retrieved and included with the exemplary query of Table IV above the query illustrated in Table VI below is obtained.

In the given example the exemplary query of Table VI is then processed at step as described above. If however it is determined at step that the query object is not a reference to a persistently stored query processing continues at step .

It should be noted that including the retrieved Research Candidate List query of Table V with the exemplary query of Table IV above is merely described by way of example. Alternatively the Research Candidate List query of Table V can simply be joined to the exemplary query of Table IV. Thus any subsequent changes to the Research Candidate List query of Table V are reflected in the exemplary query of Table IV. For instance assume that the researcher stores the exemplary query of Table IV for future use. Assume further that the researcher then wants to limit the search only to doctors of the hospital and therefore removes the query condition or Employee Job Class Administrator line 006 of Table V from the Research Candidate List query of Table V. If the Research Candidate List query of Table V is only joined to the query of Table IV the performed change is automatically reflected by the query of Table IV as the query of Table IV re accesses in this case the query of Table V for each execution. However in the example described above where both queries were combined to the exemplary query of Table VI the researcher would also need to change the exemplary combined query of Table VI by removing the query condition in line 013 thereof. All such implementations are broadly contemplated.

At step it is determined whether the query object specifies a reference to a predefined data set e.g. a query result included with result repository of . For instance assume that in the given example the exemplary query illustrated in Table VII below is received at step . By way of example the query of Table VII below is also defined using SQL and simplified as described above with reference to Table III.

It should be noted that the exemplary query of Table VII corresponds to the exemplary query of Table IV above. However instead of a reference to a persistently stored query as included with line 008 of Table IV above the exemplary query of Table VII includes a reference to a persistently stored data set saved data set referred to as Research Candidate List Output in line 008 of Table VII. Assume now that the Research Candidate List Output data set is defined by the exemplary query result illustrated in Table VIII below.

By way of example the query result of Table VIII includes three exemplary data records lines 002 004 each having a unique patient identifier Patient ID associated with a unique employee identifier Employee ID to uniquely identify the patients that are also employees of the hospital. Furthermore each data record includes first and last names FirstName LastName and a corresponding job class description Employee Job Class for each employee. It should be noted that the exemplary query result may include one or more additional fields such as an Address or Hire Date field. However for simplicity such fields are not included with Table VIII.

If it is determined at step that the query object is a reference to a persistently stored data set processing continues at step where the data set is processed. Otherwise processing continues at step . An exemplary method of processing a predefined data set in one embodiment is described below with reference to . In one embodiment processing the predefined data set includes rewriting the query that was received at step in order to obtain a rewritten query e.g. rewritten query of that is executable against the underlying database. The method then proceeds with step .

At step the query is executed against the underlying database to obtain a corresponding result set e.g. result set of . The obtained result set is output to the requesting entity at step . Method then exits at step .

Referring now to one embodiment of a method for processing a subquery according to step of is illustrated. According to one aspect the steps of the method are performed by the query rewriter of . In one embodiment the method is performed in order to determine whether the subquery is configured to return valid values for the field e.g. field of of the query condition e.g. query condition of that is associated therewith. The method is further configured to perform suitable processing in order to ensure that the subquery returns the valid value s as described below by way of example.

Method starts at step where it is determined whether the subquery includes one or more result fields. If so processing continues at step where the one or more result fields are identified from the subquery. Otherwise processing continues at step .

After identification of the one or more result fields from the subquery at step it is determined at step whether the identified result fields include a given result field that matches the field of the query condition. If so processing proceeds with step . Otherwise processing proceeds with step .

Assume now that the subquery corresponds to lines 008 014 of Table III above. In this case all fields of the Employee Table are result fields of the subquery Select in line 008 of Table III . Assume now that the Employee Table includes a patient id field. Accordingly it is determined at step that the subquery includes a given result field i.e. the patient id field that matches the patient id field of the query condition line 007 of Table III . Thus processing continues at step where all non matching result fields are removed from the subquery. In other words the subquery is rewritten such that it only includes the patient id field as result field. Thereby the exemplary query of Table III is rewritten and the rewritten query e.g. rewritten query of illustrated in Table IX below is obtained.

Note that the subquery in lines 008 014 of Table IX only includes a single result field patient id line 008 that matches the field patient id of the query condition line 007 . Processing then continues at step of .

Assume now that the subquery corresponds to lines 008 014 of Table VI above. In this case the subquery includes the result fields LastName FirstName and Address as noted above. Accordingly in this case it is determined at step that the subquery does not include a given result field that matches the patient id field of the query condition line 007 of Table VI . Thus processing continues at step where all result fields are removed from the subquery. Processing then proceeds with step of .

At step it is determined whether the received query and the subquery access an identical database table or an identical table instance. In one embodiment this includes determining whether the subquery accesses a table or table instance that has a field that matches the field of the query condition. If so processing proceeds with step . Otherwise a notification is issued at step indicating that the subquery cannot be processed and the method then exits at step . In one embodiment issuing a notification includes prompting a user for further input. For instance the user can be requested to modify the subquery such that it is suitable to determine valid values for the field of the query condition.

In the given example it is determined at step that the subquery accesses the Employee Table line 009 of Table VI that includes a patient id field as was noted above. Accordingly the Employee Table is accessed at step to identify the patient id field therefrom. In one embodiment identifying the patient id field from the Employee Table includes verifying whether this field and the patient id field of the query condition line 007 of Table VI have an identical data type and purpose. For instance corresponding metadata can be checked in order to determine whether both fields relate to unique patient identifiers. Thus it can be avoided that the data types of both fields match but that the fields themselves serve different purposes e.g. a patient identifier field versus a weight field . Other verifications that are performed to determine the suitability of the patient id field of the Employee Table are also broadly contemplated. Furthermore such verifications can also be performed in the context of step described above.

At step the identified result field is included with the subquery. In the given example the exemplary query of Table VI would thus also be rewritten to the rewritten query of Table IX above. Processing then continues at step of .

Referring now to one embodiment of a method for processing a predefined data set according to step of is illustrated. According to one aspect the steps of the method are performed by the query rewriter of . By way of example the steps of the method are explained with respect to a query result defining the predefined data set such as a query result included with result repository of .

Method starts at step where it is determined whether the query result includes valid values for the field e.g. field of of the query condition e.g. query condition of . In one embodiment determining at step whether the query result includes valid values for the field includes performing corresponding verifications to ensure that values included therewith are suitable such as described above with reference to step of .

If it is determined at step that the query result includes valid values for the field processing proceeds with step . Otherwise a notification is issued at step indicating that the query result cannot be processed and the method then exits at step . In one embodiment issuing a notification includes prompting a user for further input. For instance the user can be requested to indicate another query result that it is suitable to determine valid values for the field of the query condition.

For instance assume that the received query is defined by the exemplary query of Table VII above. Assume further that the query result is defined by the exemplary query result of Table VIII above which includes a Patient ID column having the patient identifier values 1 12 and 35 that are valid values for the field patient id line 007 of Table VII of the query condition defined in lines 007 008 of Table VII.

At step the valid values are identified from the query result. At step the identified values are included with the query. Accordingly in the given example the exemplary query of Table VII is rewritten at step and the rewritten query e.g. rewritten query of illustrated in Table X below is obtained.

It should be noted that the rewritten query of Table X explicitly includes all identified valid values for the patient id field in line 007. Processing then continues at step of where the rewritten query is executed to determine a corresponding result set e.g. result set of .

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

