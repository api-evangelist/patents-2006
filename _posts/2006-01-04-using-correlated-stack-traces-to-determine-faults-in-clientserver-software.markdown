---

title: Using correlated stack traces to determine faults in client/server software
abstract: A method, apparatus and computer program product for using correlated stack traces to determine faults in client/server software is presented. Client/server software is executed. A client call stack is maintained on the client and a server call stack is maintained on the server. When an unexpected occurrence is detected while running the client/server software then the client call stack is collected, as is the server call stack. The client call stack and the server call stack are correlated to produce a correlated call stack and the correlated call stack is provided to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09064046&OS=09064046&RS=09064046
owner: EMC Corporation
number: 09064046
owner_city: Hopkinton
owner_country: US
publication_date: 20060104
---
Computer software applications may be run in a single computer system environment. In such an environment a call stack may be used. A display of a call stack may be used as an aid for debugging applications. As a method is called information about the method is placed on the call stack. The call stack includes multiple stack frames which represent each method that is executing on the current thread. The call stack may include one or more of a Module name a Parameter name a Parameter type a Parameter value a Line number and a Byte offset. In the event of an error the call stack can be examined and a determination made regarding the cause of the error.

Modern computer software applications are often distributed between computer systems and require the ability to access and exchange information with other remotely operating software applications. Such exchanges of data and access to functionality often take place over a computer network such as a local area network LAN or a wide area network WAN such as the Internet.

In a distributed system such as a client server based system each distributed member has its own respective call stack. Thus in a client server distributed system the client thread has its own call stacks client call stacks and the server thread has its own call stacks server call stacks .

Conventional distributed systems such as those explained above suffer from a variety of deficiencies. One such deficiency is that in a distributed system a stack trace stops at the boundary between the client and the server. In the event of an error it is difficult to correlate the server call stack with the client call stack since typically there are multiple processes and calls going on.

Embodiments of the invention significantly overcome such deficiencies and provide mechanisms and techniques that provide a method for correlating a client call stack with a server call stack to provide a correlated call stack which is useful for determining causes of unexpected occurrences errors exceptions or the like in a distributed computing environment.

In a particular embodiment of a method of using stack traces to determine faults in client server software the method begins by executing the client server software. A client call stack is maintained on the client and a server call stack is maintained on the server. When an unexpected occurrence is detected while running the client server software the client call stack is collected as is the server call stack. The client call stack and the server call stack are correlated to produce a correlated call stack and the correlated call stack is provided to a user.

Other embodiments include a computer readable medium having computer readable code thereon for using stack traces to determine causes of unexpected occurrences in client server software. The medium includes instructions for executing the client server software. The medium further includes instructions for maintaining a client call stack on the client and for maintaining a server call stack on the server. Additionally the medium includes instructions for detecting an unexpected occurrence of an error while running the client server software. Further the medium includes instructions for collecting the client call stack for collecting the server call stack and for correlating the client call stack with the server call stack to produce a correlated call stack. The medium may further include instructions for providing the correlated call stack to a user.

Still other embodiments include a distributed system configured to process all the method operations disclosed herein as embodiments of the invention. In such embodiments the distributed system includes client device and a server device each of which includes a memory system a processor communications interface in an interconnection mechanism connecting these components. The memory system is encoded with a process that provides using stack traces to determine causes of unexpected occurrences in client server software as explained herein that when performed e.g. when executing on the processor operates as explained herein within the client and server devices to perform all of the method embodiments and operations explained herein as embodiments of the invention. Thus any computerized devices that performs or are programmed to perform the processing explained herein is an embodiment of the invention.

Other arrangements of embodiments of the invention that are disclosed herein include software programs to perform the method embodiment steps and operations summarized above and disclosed in detail below. More particularly a computer program product is one embodiment that has a computer readable medium including computer program logic encoded thereon that when performed in a computerized device provides associated operations providing for using stack traces to determine causes of unexpected occurrences in client server software as explained herein. The computer program logic when executed on at least one processor with a computing system causes the processor to perform the operations e.g. the methods indicated herein as embodiments of the invention. Such arrangements of the invention are typically provided as software code and or other data structures arranged or encoded on a computer readable medium such as an optical medium e.g. CD ROM floppy or hard disk or other a medium such as firmware or microcode in one or more ROM or RAM or PROM chips or as an Application Specific Integrated Circuit ASIC or as downloadable software images in one or more modules shared libraries etc. The software or firmware or other such configurations can be installed onto a computerized device to cause one or more processors in the computerized device to perform the techniques explained herein as embodiments of the invention. Software processes that operate in a collection of computerized devices such as in a group of data communications devices or other entities can also provide the system of the invention. The system of the invention can be distributed between many software processes on several data communications devices or all processes could run on a small set of dedicated computers or on one computer alone.

It is to be understood that the embodiments of the invention can be embodied strictly as a software program as software and hardware or as hardware and or circuitry alone such as within a data communications device. The features of the invention as explained herein may be employed in data communications devices and or software systems for such devices such as those manufactured by EMC Corporation of Hopkinton Mass.

A distributed system is shown in . The distributed system includes a client and a server . Client server software is executed by system . The client may request data from server as part of the execution of the client serve software. As part of the execution of the software call stacks are used. Client has a client call stack and server has a server call stack . A single operation by the system may result in several frames being pushed onto the stacks. For example in an operation has resulted in frames L and L being pushed onto the client call stack and further operation has resulted in frames L and L being pushed on the server call stack . Frame L was pushed onto the server call stack and an unexpected occurrence such as an exception an error condition or a fault condition was encountered by the server as indicated by the X shown in stack frame L of server call stack . On the client side once the unexpected occurrence has occurred the client has no idea what happened or how to determine a possible route cause of the unexpected occurrence.

Referring now also to when the unexpected occurrence happens by way of the present invention the client call stack is collected as is the server call stack . A correlation operation is performed on the two call stacks to produce a correlated call stack . Correlated call stack includes frames L and L from client call stack a ServerStack frame and frames L L and L from client call stack . The correlated call stack is presented to the user and can be used to help determine a route cause of the unexpected occurrence.

A particular embodiment of a system for using stack traces to determine causes of unexpected occurrences is shown in . The system includes a client and a server as well as a client call stack and a server call stack . The client further includes a handler which is aware of the client call stack and the server . The server also includes a handler which is aware of the server call stack and packages its knowledge of the server stack into a data structure that the client call handler will interpret upon receipt..

Due to the complexities and varying mechanisms of implementing functionality and data formats within modern software applications software developers often employ software commonly referred to as middleware that provides a standardized mechanism for the exchange of information and access to functionality between two or more remotely operating software programs. Middleware is generally connectivity software that consists of a set of enabling services that allow multiple processes running on one or more machines to interact across a network.

Middleware allows a software developer to create a software application using calls to a middleware specific application programming interface or API in order to insulate the software developer from having to know the details of how to access the remotely operating software application and associated remote data structures or objects. By incorporating a set of middleware specific function calls into the application under development the software developer relies on the middleware transport and data access mechanisms and does not need to be concerned with details such as creation of connections to remote computer systems. Middleware is thus software that connects otherwise separate applications or separate products and serves as the glue between the applications. Middleware is thus distinct from import and export features that may be built into one of the applications. Developers often refer to middleware plumbing because it connects two sides of an application and passes data between them. For example there are a number of middleware products that link a database system to a web server. This allows a user application to request data from the database using forms displayed on a web browser and it enables the web server to return dynamic web pages based on the user application s requests.

One example of commonly used middleware architecture is called CORBA. CORBA is an acronym for Common Object Request Broker Architecture. The CORBA environment is an industry standard that is maintain by Object Management Group Inc. OMG of Needham Mass. USA. As described on OMG s web site CORBA provides a vendor independent architecture and infrastructure that computer applications use to work together over data networks. Using standardized protocols a CORBA based program from any vendor on almost any computer operating system programming language and network can interoperate with a CORBA based program from the same or another vendor on almost any other computer operating system programming language and network.

For each object type a developer using middleware such as CORBA defines an interface in an OMG Interface Description Language IDL . The interface is a syntax part of a contract that a server object offers to client programs that invoke functionality and access data within that server object. Any client that wants to invoke an operation on the object must use this IDL interface specification i.e. object specification to specify the operation it wants to perform and to marshal arguments i.e. parameters or data that the client sends and receives from the server for access to that object. When the invocation reaches the target object the same interface definition is used there to unmarshal the arguments so that the object can perform the requested data processing operation with the arguments. The interface definition is then used to marshal the results for their trip back to the client and to unmarshal them when they reach the client destination.

A conventional IDL interface definition is independent of a selected programming language but maps to all of the popular programming languages via industry standards. As an example there are standardized mappings from IDL to C C Java COBOL and other languages.

The use of a middleware specific interface such as a CORBA call that is separate from the middleware implementation enabled by the IDL is one essence of middleware such as CORBA and explains how conventional middleware enables interoperability between applications. The interface to each object using a conventional middleware platform is defined very strictly. However CORBA and other middleware platforms hide the implementation of an object i.e. its running code and its data from the rest of the system that is middleware encapsulates the implementation behind a boundary that the client application may not cross. Clients access objects only through their advertised CORBA or other middleware specific interface invoking only those CORBA or other middleware operations that the object exposes through its IDL interface with only those CORBA or other middleware parameters input and output that are included in the invocation.

Client server software is executed by system . The client may request data from server as part of the execution of the client serve software. As part of the execution of the software call stacks are used.

In this embodiment when an unexpected occurrence occurs the client call stack is collected as is the server call stack . In this example the unexpected occurrence comprises an exception. A correlation operation is performed on the two call stacks to produce a correlated call stack. The collecting of the client call stack the collecting the server call stack and the correlating the client call with the server call stack comprises overriding a default stack data collection mechanism with a custom stack data collection mechanism including the client call stack and the server call stack.

The custom stack data collection mechanism may be written in middleware or may preferably be written into a generative aspect oriented layer. .

In a preferred embodiment the handlers may be inserted into the client server environment by use of generative aspect oriented techniques. Configurations herein disclose a system and method in a software build system for emitting a handler into a client and or server component to access interfaces of client and or server components. The system of the invention provides a generation tool that emits a method declaration and further emits the method s definition in a handler. With application of the invention locating a mediator is delegated to a server infrastructure and the names of the sought after interface and the required component are emitted.

The custom stack collection mechanism includes mapping an exception in a first protocol on the server into an exception in a second protocol sending the exception in a second protocol to the client receiving the exception in a second protocol at the client and mapping the exception in a second protocol back to the exception in a first protocol.

The mapping an exception in a first protocol on the server into an exception in a second protocol and the sending the exception in a second protocol to the client is performed by the server side handler . The receiving the exception in a second protocol at the client and the mapping the exception in a second protocol back to the exception in a first protocol is performed by a client side handler . In this example the first protocol comprises Java and the second protocol comprises Corba.

The stack trace created in a server process will be displayed in the client process. In a particular embodiment this is done by including the stack trace elements as strings in a CORBA exception object and overriding the methods for displaying stack traces in an adapter object on the client side. This involves overriding the standard behavior of showing only the stack trace in the conventional process. The override allows the code that handles the error to see the multiprocess stack trace without having to do anything differently than it would to see the stack from the local process only.

As an example there is an exception class ObjectNotFoundException that can be thrown by a method with the function of looking up an object in a repository. The method s signature is as follows 

IManagedObject lookupObj IMoId id throws ObjectNotFoundException If an implementation of this method was called locally not from code running in a different process it might look like this 

The second stack trace contains all of the elements of the first stack trace plus some stack elements that are introduced by the middleware. It would even be possible for the invention to present the stack without the middleware lines to further simplify diagnostic activity with a resulting stack trace something like 

For the remote interface in a particular implementation CORBA is used as the middleware and CORBA IDL as the interface definition language. The IDL operation which corresponds to a remotely available method declares that it throws an exception that contains data about the stack trace in the server. The exception declaration in IDL is as follows 

For the server side processing code in the server catches the Java exception ObjectNotFoundException and creates and throws the corresponding IDL exception ObjNotFoundIdl. The server code that catches the Java exception and throws the IDL exception is shown below.

Line is used to catch the Java exception ObjectNotFoundException. Line is used to create the structure that will contain stack trace data and other data for the exception in this case it uses a bridge factory and creates a bridge as per our previous patents although it could as easily create the CORBA construct . Line sets the message of the data structure with the message of the Java exception. and line sets the stack trace strings of the data structure using a utility method for this purpose. Line creates the exception that will be thrown across the network by the bridges and middleware the remote exception . Line sets the stack trace and message data of the remote exception. Line sets other information about the exception in this case the id of the object that could not be found . Line throws the remote exception.

The client side is responsible for catching the remote exception and rethrowing it as the original Java exception thrown by the server but with the behavior that the full stack including the stack from the server is displayed from methods that have this responsibility.

The client code creates an adapter exception for this purpose. The code for this adapter exception is below.

The exception adapter ObjNotFoundIdlAdapter extends the class ObjectNotFoundException. This allows code that declares that it throws ObjectNotFoundException to throw an instance of this exception using the object oriented property of extension.

This code has a constructor at line that creates an instance related data structure EccApiRemoteException for the purpose of holding the remote stack trace strings. The printStackTrace methods at lines and delegate the implementation of this call to the method of the same name at line . This call in turn prints the client side stack on line and the server stack on line . The code illustration is completed by including the class EccApiRemoteException below 

A flow chart of the presently disclosed method is depicted in . The rectangular elements are herein denoted processing blocks and represent computer software instructions or groups of instructions. Alternatively the processing blocks represent steps performed by functionally equivalent circuits such as a digital signal processor circuit or an application specific integrated circuit ASIC . The flow diagrams do not depict the syntax of any particular programming language. Rather the flow diagrams illustrate the functional information one of ordinary skill in the art requires to fabricate circuits or to generate computer software to perform the processing required in accordance with the present invention. It should be noted that many routine program elements such as initialization of loops and variables and the use of temporary variables are not shown. It will be appreciated by those of ordinary skill in the art that unless otherwise indicated herein the particular sequence of steps described is illustrative only and can be varied without departing from the spirit of the invention. Thus unless otherwise stated the steps described below are unordered meaning that when possible the steps can be performed in any convenient or desirable order.

Referring now to a method of using stack traces to determine faults in client server software begins with processing block which discloses executing client server software. As recited in processing block the client server software includes application code and as disclosed in processing block the application code includes at least one synchronous call.

Processing blocks and respectively state maintaining a client call stack on the client and maintaining a server call stack on the server. Processing block recites detecting an unexpected occurrence o while running the client server software. This unexpected occurrence may comprise an exception an error condition or a fault as disclosed in processing block .

Upon detection of the error processing block is performed which recites collecting the client call stack. Similarly processing block is also performed which states collecting the server call stack.

Processing block discloses correlating the client call stack with the server call stack to produce a correlated call stack. As discloses in processing block this includes overriding a default stack data collection mechanism with a custom stack data collection mechanism including the client call stack and the server call stack. As stated in processing block overriding a default stack collection mechanism with a custom stack data collection mechanism includes mapping an exception in a first protocol on the server into an exception in a second protocol. Processing block discloses that this is performed by a server side handler. Processing block states sending the exception in a second protocol to the client and processing block recites receiving the exception in a second protocol at the client. The correlating continues with processing block which recites mapping the exception in a second protocol back to the exception in a first protocol which is performed by a client side handler as recited in processing block .

Processing block recites providing the correlated call stack to a user. This aids the user in determining a root cause of the unexpected occurrence.

The memory system may be any type of computer readable medium that is encoded with an application A that represents software code such as data and or logic instructions e.g. stored in the memory or on another computer readable medium such as a disk that embody the processing functionality of embodiments of the invention for the agent as explained above. The processor can access the memory system via the interconnection mechanism in order to launch run execute interpret or otherwise perform the logic instructions of the applications A for the host in order to produce a corresponding agent process B. In other words the agent process B represents one or more portions of the agent application A performing within or upon the processor in the computer system. It is to be understood that the agent operate as explained in former examples are represented in by the agent application A and or the process B.

It is to be understood that embodiments of the invention include the applications i.e. the un executed or non performing logic instructions and or data encoded within a computer readable medium such as a floppy disk hard disk or in an optical medium or in a memory type system such as in firmware read only memory ROM or as in this example as executable code within the memory system e.g. within random access memory or RAM . It is also to be understood that other embodiments of the invention can provide the applications operating within the processor as the processes. While not shown in this example those skilled in the art will understand that the computer system may include other processes and or software and hardware components such as an operating system which have been left out of this illustration for ease of description of the invention.

Having described preferred embodiments of the invention it will now become apparent to those of ordinary skill in the art that other embodiments incorporating these concepts may be used. Additionally the software included as part of the invention may be embodied in a computer program product that includes a computer useable medium. For example such a computer usable medium can include a readable memory device such as a hard drive device a CD ROM a DVD ROM or a computer diskette having computer readable program code segments stored thereon. The computer readable medium can also include a communications link either optical wired or wireless having program code segments carried thereon as digital or analog signals. Accordingly it is submitted that that the invention should not be limited to the described embodiments but rather should be limited only by the spirit and scope of the appended claims.

