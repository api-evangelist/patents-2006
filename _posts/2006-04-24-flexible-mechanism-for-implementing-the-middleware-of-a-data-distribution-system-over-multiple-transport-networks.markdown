---

title: Flexible mechanism for implementing the middleware of a data distribution system over multiple transport networks
abstract: A method of providing transports for a data distribution middleware over a plurality of transport networks is provided. A data distribution middleware with a pluggable transport layer is provided. A plurality of transport plugins in the transport layer are provided. Aliases are assigned to each of the transport plugins of the plurality of transport plugins, wherein at least one of the transport plugins of the plurality of transport plugins has a plurality of aliases.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08671135&OS=08671135&RS=08671135
owner: Real-Time Innovations, Inc.
number: 08671135
owner_city: Sunnyvale
owner_country: US
publication_date: 20060424
---
This application is related to co pending and concurrently filed application Ser. No. 11 379 986 filed Apr. 24 2006 entitled MEMORY USAGE TECHNIQUES IN MIDDLEWARE OF A REAL TIME DATA DISTRIBUTION SYSTEM by Stephen Jisoo Rhee Yi Dai Gerardo Pardo Castellote and Rajive Joshi which is incorporated by reference herein for all purposes.

This application is related to co pending and concurrently filed application Ser. No. 11 410 563 filed Apr. 24 2006 entitled A FRAMEWORK FOR EXECUTING MULTIPLE THREADS AND SHARING RESOURCES IN A MULTITHREADED COMPUTER PROGRAMMING ENVIRONMENT by Stephen Jisoo Rhee Elaine Yee Ting Sin Gerardo Pardo Castellote Stefaan Sonck Thiebaut and Rajive Joshi which is incorporated by reference herein for all purposes.

The present invention relates to the interface between middleware and the underlying transport services e.g. network stack that allow separate processes and computers to communicate with each other.

In the context of this invention middleware is a layer of software that lies between a lower layer or software typically the operating system and higher layers of software which include the end user application. Middleware can implement one or more communication models and offer those as a service to the higher layers. For instance middleware can implement a real time publish subscribe communications model to allow distributed processes to share data without concern for the actual physical location or architecture of their peers. The middleware may include support for best effort and reliable communications. For example the Object Management Group s OMG Data Distribution Service for Real Time Systems DDS is a standard specification for middleware that implements and offers a publish subscribe data distribution system model to the software layers above. The purpose of the specification is to provide a common application level interface that clearly defines the capabilities and behavior of the data distribution service.

DDS uses a publish subscribe P S communication model. The P S communication model employs asynchronous message passing between concurrently operating subsystems. The publish subscribe model connects anonymous information producers with information consumers. The overall distributed system is composed of processes each running in a separate address space possibly on different computers. In this patent application each of these processes of the distributed system is referred to as a participant application . A participant application may be a producer or consumer of data or both.

Using the middleware data producers declare the topics on which they intend to publish data data consumers subscribe to the topics of interest. When a data producer publishes some data on a topic the middleware operates such that all the consumers subscribing to that topic receive it. The data producers and consumers remain anonymous resulting in a loose coupling of sub systems which is well suited for data centric distributed applications. This is referred to as a DCPS data centric publish subscribe architecture.

The DCPS model employs the concept of a global data space of data objects that any entity can access. Applications that need data from this space declare that they want to subscribe to the data and applications that want to modify data in the space declare that they want to publish the data. A data object in the space is uniquely identified by its keys and topic and each topic has a specific type. There may be several topics of a given type. A multiplicity of independent Global Data Spaces may be created. Each global data space is identified by its domain id. Each subscription publication must belong to the same domain in order to communicate.

For example the reader is referred to the Object Management Group s Specification entitled Data Distribution Service for Real Time Systems Specification Version 1.1 dated December 2005. See http www.omg.org docs formal 05 12 04.pdf referred to herein as DDS Specification . In the DDS Specification a DCPS architecture is specified that includes the following entities DomainParticipant DataWriter DataReader Publisher Subscriber and Topic. All these classes extend Entity which is an abstract base class for all the DCPS objects that support QoS policies a listener and a status condition. The particular extension of Entity represents the ability to be configured through QoS policies be enabled be notified of events via listener objects and support conditions that can be waited upon by the application. Each specialization of the Entity base class has a corresponding specialized listener and a set of QoSPolicy values that are suitable to it.

A Publisher represents the object responsible for data issuance. A Publisher may publish data of different data types. A DataWriter is a typed facade to a publisher participants use DataWriter s to communicate the value of and changes to data of a given type. Once new data values have been communicated to the publisher it is the Publisher s responsibility to determine when it is appropriate to issue the corresponding message and to actually perform the issuance the Publisher will do this according to its QoS or the QoS attached to the corresponding DataWriter and or its internal state .

A Subscriber receives published data and makes it available to the participant. A Subscriber may receive and dispatch data of different specified types. To access the received data the participant must use a typed DataReader attached to the subscriber.

The association of a DataWriter object representing a publication with DataReader objects representing the subscriptions is done by means of the Topic. A Topic associates a name unique in the system a data type and QoS related to the data itself. The type definition provides enough information for the service to manipulate the data for example serialize it into a network format for transmission .

The DDS middleware handles the actual distribution of data on behalf of a user application. The distribution of the data is controlled by user settable Quality of Service QoS .

Data distribution middleware is characterized by delivery of data over a variety of physical and logical communication media such as Ethernet based networks other LAN Wireless or WAN technologies shared memory local busses PCI VME high speed serial interconnects etc. A flexible approach is needed to enable the specification configuration and seamless usage of multiple transport networks in a data distribution system.

To achieve the foregoing and in accordance with the purpose of the present invention a method of implementing data distribution middleware over a plurality of transport networks is provided. A domain participant is created. A transport plugin for the domain participant is created. The transport plugin is registered with the domain participant.

In another manifestation of the invention a method of providing transports for a data distribution middleware over a plurality of transport networks is provided. A data distribution middleware with a pluggable transport layer is provided. A plurality of transport plugins in the transport layer are provided. Aliases are assigned to each of the transport plugins of the plurality of transport plugins wherein at least one of the transport plugins of the plurality of transport plugins has a plurality of aliases.

In another manifestation of the invention a method of providing transports for a data distribution middleware over a plurality of transport networks is provided. A data distribution middleware with a pluggable transport layer is provided. A plurality of transport plugins are provided. A plurality of domain participants are provided. A plurality of transport plugins are associated with the plurality of domain participants.

In another manifestation of the invention a method for creating transport plugins is provided. Commands from the Data distribution middleware are sent to a plurality of transport plugins to create send resources and receive resources. Send resources and receive resources are created before the resources are needed. The send resources and receive resources are kept and managed in the data distribution middleware core. Requests from the data distribution middleware are sent to the plurality of transport plugins to share send resources and receive resources.

In another manifestation of the invention computer readable media for providing transports for a data distribution middleware implementation over a plurality of transport networks is provided. Computer readable code for creating a domain participant is provided. Computer readable code for creating a transport plugin for the domain participant is provided. Computer readable code for registering the transport plugin with the domain participant is provided.

In another manifestation of the invention computer readable code for providing transports for a data distribution middleware over a plurality of transport networks is provided. Computer readable code for providing a data distribution middleware with a pluggable transport layer is provided. Computer readable code for providing a plurality of transport plugins in the transport layer is provided. Computer readable code for assigning aliases to each of the transport plugins of the plurality of transport plugins is provided wherein at least one of the transport plugins of the plurality of transport plugins has a plurality of aliases.

In another manifestation of the invention computer readable media for providing transports for a data distribution middleware over a plurality of transport networks is provided. Computer readable code for providing a data distribution middleware with a pluggable transport layer is provided. Computer readable code for providing a plurality of transport plugins is provided. Computer readable code for providing a plurality of domain participants is provided. Computer readable code for associating the plurality of transport plugins with the plurality of domain participants is provided.

In another manifestation of the invention for creating transport plugins is provided. Computer readable code for sending commands from the Data distribution middleware to a plurality of transport plugins to create send resources and receive resources is provided. Computer readable code for creating send resources and receive resources before the resources are needed is provided. Computer readable code for keeping and managing the send resources and receive resources in the data distribution middleware core is provided. Computer readable code for sending requests from the data distribution middleware to the plurality of transport plugins to share send resources and receive resources is provided.

These and other features of the present invention will be described in more detail below in the detailed description of the invention and in conjunction with the following figures.

The present invention will now be described in detail with reference to a few preferred embodiments thereof as illustrated in the accompanying drawings. In the following description numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some or all of these specific details. In other instances well known process steps and or structures have not been described in detail in order to not unnecessarily obscure the present invention.

Within the context of this invention middleware is the software that resides between an application and the operating system. Data distribution middleware moves data around among the nodes of a data distribution system. The OMG Data Distribution Service DDS is an API specification for accessing a data distribution middleware from a higher layer of code such as the application code sometimes referred to as user application code .

DDS does not specify a transport model. Instead it focuses on the logical model of data distribution. A DDS middleware implementation must run over some physical or logical transports to distribute data. This invention describes a flexible and general purpose mechanism for implementing the middleware of a data distribution system over multiple transport networks and in particular a mechanism to implement DDS middleware that can deliver data using multiple transports in a DDS domain

A data distribution system can implement this logical data distribution model to run over multiple transports. A data distribution domain may include producers or consumers that can send and receive messages over multiple transports. To facilitate understanding is a schematic view of a data distribution system with a first transport network Transport X Network and a second transport network Transport Y Network . In this data distribution system a first consumer application a second consumer application and a third consumer application are shown. The consumer applications subscribe to various topics of interest. A first producer application and a second producer application are also shown. The producer applications declare topics on which they intend to publish data and then publish data on those declared topics. The consumer applications then receive published data on topics to which they subscribe. A producer and consumer application is also shown which both produces data on a topic and subscribes to data on a topic. In this example each application has a Transport X plugin for communication over Transport X Network and a Transport Y plugin for communication over Transport Y Network. In general an application may have one or more transport plugins for communication over one or more transport networks. Some of the transport types that may be used for Transport X Network or Transport Y Network are IPv6 IPv4 shared memory serial links or serial interconnect networks including StarFabric Infiniband Rapic Fabric RapidIO Advanced Switching or bus based networks including VME PCI PCI X or other physical media used to move bits around. New transport networks may be developed in the future. It would be desirable to be able to easily configure an existing data distribution system to use new transport networks as they are developed. In an embodiment of the invention each Transport X plugin is an instance of a Transport X plugin class and each Transport Y plugin is an instance of a Transport Y plugin class. A transport plugin class implements a way to communicate on a specific transport network. Different transport networks may have different internal addressing schemes. A transport plugin maps the transport specific addressing scheme to a transport independent addressing scheme. A transport independent addressing scheme is used by the data distribution system to uniformly address different nodes connected over one or more transport networks. One or more applications may be run on the same node.

A well defined transport API specifies the interface that must be implemented by all transport plugin implementations. A new transport plugin class can be developed for a new transport network by implementing the transport API . The transport API is used by the Middleware core implementation and includes methods to map a transport independent address representation to a transport network specific address representation and methods to send and receive messages over the transport network.

A transport plugin provides transport plugin implementation specific public transport API to create and delete transport plugin instances and possibly to change their properties. This public transport API is used by the user application code to create new instances of a transport plugin class that can then be registered with the Middleware core using the registration methods defined in the Middleware API .

When a transport plugin is registered with the Middleware core the transport plugin is associated with at least one alias. An alias is a way of symbolically referring to the transport plugin registered with the Middleware core from other entities for example Data Readers and Data Writers defined in the Middleware API . Multiple transport plugins can be registered with the same alias and a transport plugin can be registered under multiple aliases. Thus aliases provide a very powerful and flexible mechanism for organizing and referring to a collection of transport plugins from various data distribution system API entities. For example a StarFabric transport plugin may be registered under the aliases fast and large since StarFabric is a very fast transport capable of transferring large messages in a single operation. Either alias may be used to refer to this transport plugin. In addition the fast alias may also be used to refer to a transport plugin for Gigabit Ethernet since it can also transfer messages very fast. In this example scenario when a data distribution middleware entity refers to transport plugins using the alias fast both the StarFabric and the Gigabit Ethernet transport would be used however when a data distribution middleware entity refers to transport plugins using the alias large only the StarFabric transport would be used.

A transport plugin implementation provides the notion of Interfaces via which it accesses the physical transport network. An Interface can be thought of as a logical access point associated with a unique unicast address and gives access to a subnet specific to the transport network. A transport plugin provides at least one Interface to the transport network. To illustrate the concept of an Interface consider for example an IP network when an Interface may represent the physical network interface cards NICs that can be used by an IP transport plugin. Or for example in a shared memory transport network an Interface may represent a software access point with a unicast address that can be used to send and receive messages via shared memory. In general a transport plugin provides access to one or more transport networks for a given transport class via one or more interfaces. The Middleware core can access multiple classes of transport networks via different types of transport plugins.

The data distribution system uses N bits of transport independent addressing. For example in the preferred embodiment of the invention modeled after IPv6 addressing scheme N 128 bits. The transport API requires a transport plugin implementation to declare how many bits it needs for addressing within a transport network of that class. This property is known as the address bit count and is fixed for all transport plugins of a given class. For example in the case of an IPv4 network N 32 bits in the case of a single point to point serial link N 1 bit since there are only two possible interfaces in the entire point to point serial link network.

A transport plugin is expected to use only those bits the remaining N address bit count bits are referred to as the network address and can be freely assigned when registering a transport plugin with the Middleware core .

The network address is used by the Middleware core and is chosen to ensure that the unicast address of each transport plugin interface across multiple transport plugins is unique. This ensures that each Interface in the domain across multiple classes of transport networks has a unique identifying unicast address thus a message can be un ambiguously routed to a specific Interface and therefore the appropriate transport plugin . Thus if a domain includes multiple identical transport networks a judicious choice of network address can ensure that identical interfaces in the two networks have unique unicast addresses in the domain and that there is no address collision.

The network address is chosen when a transport plugin is registered with the Middleware core . The network address must be chosen to ensure that the unicast address of each interface used by the transport plugin is unique in the domain. For built in transport plugins that are registered automatically the network address can be automatically generated. For example in a preferred embodiment of the invention the network addresses for shared memory and built in UDP transport plugins are automatically generated so they can co exist without address collision.

For transport plugins explicitly registered by the application code the network address must be chosen judiciously to ensure that each interface in the data distribution system domain has a unique unicast address. Since the full N bit unicast address is a combination of a transport independent network address and a transport specific address the network address does not need to be unique and the transport address does not need to be unique to provide the required unique unicast address. However the combination shown in however must result in a unique unicast address of N bits used to identify an interface in the data distribution system domain across multiple transport types and networks.

A transport plugin Interface may join one or more multicast groups. In a preferred embodiment of the invention the multicast addressing scheme is modeled after the IP addressing scheme. All transport plugin interfaces that have subscribed to a multicast group address receive all the messages sent to that multicast group address. A transport plugin is responsible for mapping the notion of a transport independent multicast group into a transport specific notion of multicast and joining leaving transport specific multicast groups.

The numeric representation of an address of N bits can be un wieldy and awkward for the user application code or the user. Therefore a string representation can be used for the network address and for the transport specific address portions of an address. A transport plugin provides a string to address method for converting between the transport specific string representation and the transport independent numeric representation using address bit count bits. This is illustrated in for a StarFabric transport plugin where a StarFabric node may be naturally identified by the string 0 0 R and gets mapped by the StarFabric transport plugin into the transport independent numeric representation expressed in address bit count bits. As discussed previously the transport plugin would internally map this transport independent representation into a transport network specific representation for example the StarFabric FID in the example above .

The network address portion of an address can be represented using any conventional string representation for binary addresses. For example in a preferred embodiment modeled after IP addressing the network address would be represented in a string form using IP notation. The network address in string representation can be concatenated using a separator with the transport address string representation to yield an address string that can be naturally manipulated by a user or user application code. Furthermore a transport alias or class name can be concatenated using a separator with the address string to yield a locator string. is a schematic view of a locator string illustrated for a StarFabric transport example where the locator string representation comprises a transport name which may designate either an alias or class a first separator a network address represented as a string a second separator and a transport address represented as a string.

The Middleware core uses the transport independent addressing scheme to specify a destination for sending messages. A destination is specified by a locator which includes a class id a transport independent address N bits and a port number. The address identifies one or more transport interfaces exactly one interface in the case of a unicast address and zero or more interfaces in the case of multicast group address . A port number identifies a resource for receiving messages at a given transport interface. A locator can be represented in user friendly string format by expressing it as a locator string and port number string pair. Note that a locator string and a port number pair can represent multiple locators since a transport name can refer to multiple transport plugin for different transport classes. A user or user application code can specify the information about the location of initial peer participants using string based addressing.

The consumer Application comprises a user application code which upon determining that data samples are available uses the read or take operation on a Data Reader to access data samples delivered to the Data Reader. The consumer user application code creates a Domain Participant and from it is created a Subscriber and from it is created a Data Reader .

Transport plugins are registered with a Domain Participant however the user application code may want to specify the transport plugins that a Data Writer should use to send messages or the transport plugins from which that a Data Reader ought to receive messages. This is achieved by specifying Transport QoS policies with the Data Writer Data Reader and the Domain Participant entities. The transport QoS policies use aliases to refer to one or transport plugins.

A default Transport Unicast QosPolicy and a default Transport Multicast QosPolicy is associated with a Domain Participant . If a Transport Unicast QosPolicy is not explicitly specified on an endpoint Data Writer or Data Reader the default Transport Unicast QosPolicy of the Domain Participant is used. If a Transport Multicast QosPolicy is not explicitly specified on an endpoint Data Writer or Data Reader the default Transport Multicast QosPolicy of the Domain Participant is used. If the default Transport Unicast QosPolicy and a default Transport Multicast QosPolicy are not explicitly specified on a Domain Participant then the default value of these QoS Policies is to use all the transport plugins registered with the Domain Participant with default values for port number and multicast address.

A Discovery QosPolicy is specified on a Domain Participant and includes fields that specify the transport plugins available for use by the peer discovery mechanism used by the Domain Participants to exchange information about each other. The Discovery QosPolicy also includes a list of initial peer strings that specify the locator strings for peer participant unicast interfaces over various transport networks or multicast locator strings. This field can be used to configure the physical discovery and startup topology of a data distribution system. The information exchanged among Domain Participants during the peer discovery includes information about their endpoints and the locators at which their endpoints can receive messages. For example a Domain Participant may specify that it has three Data Writers on two different topics and the locators over which each a Data Writer is able to receive acknowledgements while another Domain Participant may specify that it has two Data Readers on one topic and the locators on which each Data Reader is able to receive incoming messages. Once the Domain Participants exchange their locators they can determine if they have compatible Data Readers and Data Writers that can communicate over a common transport network once a match is established the Data Writer and the Data Reader can communicate with one another over the common transport networks. This scheme supports many different use cases for specifying the traffic flow in a data distribution system. In one embodiment peer Domain Participants may be discovered over one transport network and but user data may be exchanged over another transport network

A Transport Builtin QosPolicy is associated with a Domain Participant to specify the built in transport plugins that should be automatically created and registered with the Domain Participant on behalf of the user application code. A default value is specified for the Transport Builtin QosPolicy so that the user application code can run out of the box without requiring any explicit transport configuration. For the builtin transport plugins the steps to create a transport plugin specify aliases network address register transport plugin and add routes steps are automatically performed on behalf of the user application code. The user application code can specify the use of a builtin transport plugin by turning on a corresponding bit in the Transport Builtin Qos Policy

A transport plugin registered with a Domain Participant can be restricted to send outgoing messages to a certain sets of address ranges adding send routes in a Send Routing Table. A transport plugin registered with a Domain Participant can be restricted to receive incoming messages from a certain sets of address ranges adding receive routes in a Receive Routing Table. is a schematic view of a routing table . Each row in the routing table lists a range of addresses from address1 to address2. In the example illustrated in the address range address1 to address2 is linked to transport plugin with alias aliasA . This transport plugin will be used to communicate messages destined for an address in the range address1 to address2 . Several routing table entries may be linked a transport plugin. If a send or receive route is not explicitly added to the send or receive routing table a default route is automatically added when the Domain Participant is enabled corresponding to the address range specified by network address associated with the transport plugin when it is registered with the Domain Participant. The send and the receive routing tables may be used to restrict communication within certain address boundaries often important to ensure privacy and security of messages.

The Middleware Core maintains the aliases network address the send routes and the receive routes associated with a transport plugin . These are used by the Middleware core to determine the transport plugin s used to communicate with other nodes using one or more transport networks.

The notion of a transport Resource is used in the methods used to send and receive messages. A Send Resource or Receive Resource represents a transport specific object that can be used to send or receive messages. The Middleware core asks a transport plugin to create a Send Resource or a Receive Resource for example by invoking the create send resource or create receive resource methods. The Send Resources or Receive Resources can be thought of a cookies that the Transport Plugin creates and understands but that are opaque to the Middleware core . The Middleware core keeps and manages the Send Resources and Receive Resources on behalf of the transport plugins. When the Middleware core needs to use a transport plugin to send a message to a particular locator the Middleware core uses the Send Resource associated with that locator with the send method provided by the transport plugin . When the Middleware core needs to use a transport plugin to receive a message on a port number or multicast group address and a port number the Middleware core uses a Receive Resource to receive messages on that port number and multicast group address . The Middleware core can create a separate receive thread per Receive Resource to wait for incoming messages. The receive method on the transport plugin retrieves the messages received on a Receive Resource . The transport plugin may copy the incoming message into a buffer provide by the caller or loan an internal transport plugin buffer to the caller in the latter case the loaned transport plugin buffer must be returned to the caller for example using the return loaned buffer method. A thread waiting for incoming messages on a Receive Resource may be unblocked by calling an unlock operation for example the unblock receive method.

The transport resources Send Resources or Receive Resources are associated with an address a port number and a transport priority used for communicating messages. The transport resources are pre created by the Middleware core as soon as the need to send to an address and port number is determined or the need to receive from a port number or multicast group address is determined. Thus the overhead of creating or setting up resources is eliminated in the critical data path of incoming or outgoing messages. This helps mitigate the end to end latency and makes the operations of sending or receiving messages more predictable both key considerations for a real time middleware implementation. A transport resource may be associated or shared for use with several address port priority combinations. A transport plugin provides methods for creating sharing and unsharing a resource for a address port priority combination and methods for deleting resources. The Middleware core uses these methods to manage transport send and receive resources.

Besides precreation and optimization of both the data path and the resources used this scheme has several advantages. A key one being that it allows the transport plugin to be in control and determine how to implement the notion of a resource. The transport plugin has to determine if it can support multicast messages and how to join and leave a multicast group. For example a transport plugins may join a multicast group address in the share   resource method and leave the multicast group in the unshare   resource method. Another example is when a transport plugin can determine whether a resource may be used for a range of addresses or if different resources are needed for different addresses. Generally send resources that need to establish a connection cannot be shared because they are required for maintaining the connection whereas connection less resources are more often shared. For example in a connection oriented transport a send resource cannot be shared for more than one address port combination whereas for a connection less transport a send resource could potentially be send to any address port in that transport network.

The transport plugin architecture described above enables improved security in a data distribution system from a user application code point of view. Improved security can be achieved using a secure transport plugin for example one that encrypts messages. Since the secure encryption is performed in the transport plugin and not in the operating system this scheme can potentially be more secure as there is a smaller chance of intrusion or snooping by other code executing on the operating system. Furthermore routes can be added to the Domain Participant to restrict the data distribution message traffic to authorized sub networks.

CPU is also coupled to a variety of input output devices such as display keyboard mouse and speakers . In general an input output device may be any of video displays track balls mice keyboards microphones touch sensitive displays transducer card readers magnetic or paper tape readers tablets styluses voice or handwriting recognizers biometrics readers or other computers. CPU optionally may be coupled to another computer or telecommunications network using network interface . With such a network interface it is contemplated that the CPU might receive information from the network or might output information to the network in the course of performing the above described method steps. Furthermore method embodiments of the present invention may execute solely upon CPU or may execute over a network such as the Internet in conjunction with a remote CPU that shares a portion of the processing.

In addition embodiments of the present invention further relate to computer storage products with a computer readable medium that have computer code thereon for performing various computer implemented operations. The media and computer code may be those specially designed and constructed for the purposes of the present invention or they may be of the kind well known and available to those having skill in the computer software arts. Examples of computer readable media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs and holographic devices magneto optical media such as floptical disks and hardware devices that are specially configured to store and execute program code such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer code include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. Computer readable media may also be computer code transmitted by a computer data signal embodied in a carrier wave and representing a sequence of instructions that are executable by a processor.

While this invention has been described in terms of several preferred embodiments there are alterations modifications permutations and various substitute equivalents which fall within the scope of this invention. It should also be noted that there are many alternative ways of implementing the methods and apparatuses of the present invention. It is therefore intended that the following appended claims be interpreted as including all such alterations modifications permutations and various substitute equivalents as fall within the true spirit and scope of the present invention.

