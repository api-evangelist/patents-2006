---

title: System and method for formatting data for transmission between an embedded computer and a host computer having different machine characteristics
abstract: A system and method for providing seamless communication with threads executing on an embedded computer. Using a DAT system, a programmer can test the communication interfaces of a thread via either a scripting program, any COM-compliant program, or a graphical test utility. The DAT system automatically formats a block of data that is transmitted between the embedded computer and a host computer and accounts for machine specific enumeration sizes, machine specific pointer sizes, machine specific structure alignment boundaries, machine specific integer sizes, and machine specific byte ordering.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07392526&OS=07392526&RS=07392526
owner: S2 Technologies, Inc.
number: 07392526
owner_city: Cardiff
owner_country: US
publication_date: 20060807
---
This application claims priority to is a continuation of and incorporates by reference in its entirety U.S. patent application Ser. No. 10 105 061 filed Mar. 22 2002 now U.S. Pat. No. 7 111 302 issued on Sep. 19 2006 which claims the benefit of the following applications U.S. Provisional Application No. 60 278 212 filed Mar. 23 2001 titled SYSTEM FOR DEBUGGING AND TRACING THE PERFORMANCE OF SOFTWARE TARGETED FOR EMBEDDED SYSTEMS and U.S. Provisional Application No. 60 299 555 filed Jun. 19 2001 titled MESSAGING SYSTEM AND PROCESS and U.S. Provisional Application No. 60 363 436 filed Mar. 11 2002 titled DEVELOPMENT AND TESTING SYSTEM AND METHOD. 

This application is related to and incorporates by reference in their entirety the following commonly owned patent applications that have been filed on even date herewith U.S. patent application Ser. No. 10 104 989 titled SYSTEM AND METHOD FOR BUILDING A DATABASE DEFINING A PLURALITY OF COMMUNICATION INTERFACES U.S. patent application Ser. No. 10 104 985 now U.S. Pat. No. 7 062 772 issued on Jun. 13 2006 titled SYSTEM AND METHOD FOR PROVIDING AN INTERFACE FOR SCRIPTING PROGRAMS TO COMMUNICATE WITH EMBEDDED SYSTEMS U.S. patent application Ser. No. 10 105 062 titled SYSTEM AND METHOD FOR PROVIDING AN INTERFACE FOR COM COMPLIANT APPLICATIONS TO COMMUNICATE WITH EMBEDDED SYSTEMS U.S. patent application Ser. No. 10 105 069 now U.S. Pat. No. 7 237 230 issued on Jun. 26 2007 titled SYSTEM AND METHOD FOR GENERATING DATA SETS FOR TESTING EMBEDDED SYSTEMS and U.S. patent application Ser. No. 10 104 997 now U.S. Pat. No. 7 020 867. issued on Mar. 28 2006 titled SYSTEM AND METHOD FOR AUTOMATICALLY GENERATING CODE TEMPLATES FOR COMMUNICATION VIA A PREDEFINED COMMUNICATION INTERFACE .

The field of the invention relates to development and testing. More particularly the field of the invention relates to the development and testing of software.

An embedded device typically includes a microprocessor and application software. The application software runs under the control of a real time operating system RTOS and is typically partitioned into one or more threads. A thread is an independent unit of executable software that shares the control of the microprocessor with other defined threads within the embedded system. In many embedded devices a thread is allocated its own stack space given a priority and assigned other resources that enable the thread to run as an independent entity. Stack space is a section of memory reserved for temporary storage of local variables. Priorities are used by the RTOS to determine which thread gets control of the microprocessor if more than one thread is waiting. Resources can include miscellaneous items such as queues flags etc. that are required by the RTOS to manage a thread. Other common terms used for a thread are task and process. A process also implies a separate address space which protects different processes from adversely affecting each other. An example of a process running on a desktop computer using Microsoft s Windows Operating System OS is Microsoft Word.

A common method for threads to communicate with each other is via a messaging application programming interface API that is provided by the operating system. A message typically includes an event and optionally a block of data that is sent between at least two threads. For example a thread the sender builds a message and invokes a specific API from the RTOS. The RTOS notifies the other thread the receiver that some type of event has occurred. The receiving thread then reads the incoming message. Another common method for threads to communicate is via a function call. Using a function call provided by one thread can be invoked by another thread. Likewise functions can be called by other functions that co exist in the same thread. Other common terms for a function include a subroutine a procedure or a method. As used herein the term communication interface is intended to embrace any interface for communicating data between two threads such as via either messaging or remote function call communication.

There are several problems associated with known development and testing systems for embedded devices as described above. First known testing systems require the use of the embedded device that has an operational RTOS to test the communication interfaces of the threads and to test the execution of the threads themselves. Disadvantageously known systems do not have the ability to simulate communication interfaces and the corresponding threads that support them.

Second when using more than one platform to host running threads there is a compatibility problem representing interfaces on different machines. Different types of machines store messages differently in their respective memory space. Known testing systems do not automatically format data for transmission to different platforms. An example of incompatibility between two computers is when one computer stores a 16 bit integer 2 bytes with the least significant byte in low memory Little Endian and the other computer stores the least significant byte in high memory Big Endian . When the applications want to exchange this 16 bit integer the value of the integer is interpreted differently depending on the computer.

Third known systems require the creation of a custom desktop tool that can communicate with the embedded software. The process of building interface functionality for a specific embedded application is a time consuming and manual process. The desktop tool and the embedded software both require manual updates to their application to enable them to communicate with each other. Thus there is no seamless and automatic access via a desktop tool to the interfaces for an embedded software application.

Fourth desktop applications developed in other programming languages that are incompatible with standard C C interface definition files cannot interact with the embedded computer seamlessly. Typically interface definition files define the format of the messages expected by the embedded software. Languages such as Visual Basic LabVIEW etc. cannot use standard C interface definition files that define the format of the interfaces. Thus software engineers that use these languages cannot test the threads executing on the embedded device.

Thus there is a need for improved devices for development and testing of embedded software that do not have the foregoing limitations.

One aspect of the invention comprises a system for transmitting data. The system comprises a host computer a first application executing on the host computer an embedded computer a second application executing on the embedded computer and a database. The database identifies at least one interface characteristic of a plurality of interfaces of the first application and the second application. The database is automatically generated in response to a user request and is based at least in part upon an interface description file that is provided by the user.

The system also comprises a communication module that defines an interface for communication with the embedded computer. The first application communicates with the second application via the communication module. The host computer stores host computer machine characteristic information for the embedded computer. The host machine characteristic information includes information selected from the group comprising an enumeration size an adaptive enumeration indicator a short size a long size a float size a double size a double long size a pointer size a structure alignment boundary an integer size a byte ordering a Boolean size and a character size.

The host computer stores embedded computer machine characteristic information for the host computer. The embedded computer machine characteristic information includes information selected from the group comprising an enumeration size a pointer size a structure alignment boundary an integer size and a byte ordering. In response to receiving a communication from the second application that is targeted for the first application the communication module modifies the communication prior to transmitting the communication to the first application and wherein the modification is based at least in part upon the host computer machine characteristic information the embedded computer machine characteristic information and the interface characteristic.

Another aspect of the invention comprises a method of transmitting data. The method comprises automatically generating a database wherein the database includes interface information that describes a plurality of interfaces. The method also comprises receiving a communication from an embedded computer and formatting the communication based at least upon the interface information and machine characteristic information that describes at least one characteristic of the embedded computer.

Another aspect of the invention comprises a method of transmitting data. The method comprises receiving a communication from an embedded computer and formatting the received communication wherein the formatting is based at least in part upon interface information that describes at least one characteristic of the communication and information that describes at least one characteristic of the embedded computer.

The following detailed description is directed to certain specific embodiments of the invention. However the invention can be embodied in a multitude of different ways as defined and covered by the claims. In this description reference is made to the drawings wherein like parts are designated with like numerals throughout.

The DAT system comprises an embedded computer that is in data communication with a host computer . The embedded computer executes an embedded computer communication module that is used to route communications to threads executing on the embedded computer . The host computer executes a host computer communication module that is used to route messages to threads executing on the host computer . The embedded computer communication module and the host computer communication module are able to route to each other messages and or other communications sent via other interfaces originating from one platform that are destined for transmission to the other platform. In one embodiment of the invention all communications from one platform to the other platform are transmitted via the embedded computer communication module and the host computer communication module .

The embedded computer can reside on a telephone a card on a peripheral device an automobile a refrigerator or any other electronic device. The host computer can include any computing device that includes a display and an input device e.g. mouse keyboard.

The host computer also comprises a communication database that automatically compiles the embedded and host s interface definition files to capture the characteristics of a communication interface.

The DAT system provides a standardized API for messaging and tracing contains a protocol suite used to implement a seamless messaging and tracing environment and implements the communication link between the two platforms. In one embodiment of the invention the API that is provided by the DAT system includes interfaces for the following i registering a message ii reading a message iii sending command data iv sending response data v broadcasting a message vi subscribing to a message vii returning the list of messages stored in the communication database viii returning the message format of a specific message and ix returning the name and or identifier of a specific message. Further exemplary API of the DAT system are described below.

A studio module provides a graphical user interface and testing environment for testing the communication interfaces that are identified by the communication database . The DAT system provides complete visibility and control of all the messages and remote function calls defined by an embedded software application. As an example using the studio module a developer can scan the entire list of messages and or remote function calls within the database and display them on a screen. Once a specific message or remote function call is selected the communication database can be queried to return the element types and names associated with the message.

Upon execution each of the threads in the embedded computer and the host computer register with the DAT system . Registration enables the DAT system to dynamically route messages without having to hardcode a routing table. Threads at anytime can call a specific application programming interface API that is offered by the DAT system to inform the DAT system that the requesting thread owns a selected message. Owns in this context means that the specific thread receives the message anytime another thread and or application sends it. When a request to send a message is issued the DAT system determines whether the owning thread is local or on the other platform. If the platform is local the message is directly routed to the owning thread. If the platform is remote the message is directly routed to the other platform. If the message originates at the embedded computer upon receipt the host computer formats the message to be compatible with the machine characteristics of the host computer . If the message originates at the host computer the host computer formats the messages to be compatible with the machine characteristics of the embedded computer .

The embedded computer communication module the host computer communication module and the studio module each comprise various sub routines procedures definitional statements and macros. The computer communication module the host computer communication module and the studio module may be written in any programming language such as C C BASIC Java Pascal and Fortran and may be run under the well known operating system. C C BASIC Pascal Java and Fortran are industry standard programming languages for which many commercial compilers can be used to create executable code.

The embedded computer may execute under the control of any off the shelf or proprietary real time operating system such as VxWorks Nucleus ThreadX Windows CE RTXC and Embedded Linux.

The host computer may execute under the control of any off the shelf or proprietary operating system such as UNIX LINUX Disk Operating System DOS OS 2 PalmOS VxWorks Windows 3.X Windows 95 Windows 98 Windows NT Windows CE and Windows XP. Each of the threads on embedded computer and the host computer can communication respectively with the embedded computer communication module and the host computer communication module via a predefined application programming interface API. Set forth below are described certain routines provided by the API. It is to be appreciated that other routines may also be provided.

The information from the interface definition files is organized and stored in the communication database such that it that can be accessed by other desktop applications via the host computer communication module . An exemplary process of building the communication database is described below with respect to .

In one embodiment of the invention the DAT system provides seamless and automatic ability for an application on the host computer to make a remote function call to a routine that is on the embedded computer and vice versa without requiring modification of the application other than to link the libraries and header files of the DAT system . An exemplary process of automatically generating code in support of a remote function call is described below with reference to .

With respect to the embodiment of the invention shown in the DAT system also comprises a messaging automation component MAC and a script engine for executing a script. In one embodiment of the invention the MAC is a COM compliant object that provides interfaces for performing the following functions designating ownership of an interface generating a data set sending a field of information sending a data set receiving a message and listing each of the messages that are managed by the DAT system . The script engine can be any proprietary or off the shelf engine that supports scripting languages such as JavaScript Visual Basic VBScript Tcl JScript Python etc.

Set forth below is a description of the various objects that are provided by the MAC for communication. In one embodiment of the invention there are 6 classes of interface objects i owner message objects ii user message objects iii spy message objects iv owner function objects v user function objects and vi spy function objects. It is to be appreciated that other type of objects may also be used.

In one embodiment for message objects datasets are sets of data associated with either the command command payload or response response payload and out pointer data . One way messages have command datasets broadcast messages have response datasets and two way messages have both. For function objects datasets are associated with either the input parameter list and or the output return value and out pointer data .

Scripting languages allow developers to customize automate testing and add macro capabilities. Scripting languages in general are easy to use for this type of functionality. Scripting languages also contain much of the same capability found in compiled languages such as loops conditional statements etc. A script program is text written in a script language that is executed by a script engine. The messaging automation component provides a script program seamless and instant access to the communication interfaces of each of the threads in the embedded computer and the host computer . Using the messaging automation component fields in a message or parameters in a remote function call can be set read tested against or used in expressions. Via the messaging automation component the scripting program can also transmit and receive communications seamlessly with software running on either an embedded computer or the host computer . Furthermore establishing such communication does not require code changes of the threads executing on either the embedded computer and or the host computer .

In one embodiment of the invention the script program is launched via an interface that is provided by the studio module . In another embodiment of the invention the script program does not have to be launched by the studio module but instead can be launched and communicate directly with the host computer communication module .

The generated component provides the COM compliant application seamless and instant access to the communication interfaces of an embedded application through predefined API. Using the generated component the COM compliant application seamlessly communicates with threads executing on the embedded computer and the host computer . The host computer communication platform automatically formats communication in a form suitable for its destination. An exemplary process of formatting a communication is described below with reference to .

Set forth below is a description of the application programming interfaces that are provided by the generated component .

It is noted that in one embodiment the MAC the studio module the generated component can be utilized together to provide a communication system for various types of applications. For example using the application programming interface of the MAC a scripting program in a first language can communicate with a scripting program in the same or a second language a COM compliant application via the generated component a thread executing on the embedded computer a thread executing on the host computer and the studio module .

Furthermore for example using the application programming interface of the generated component a COM compliant application can communicate with a scripting program via the MAC another COM compliant application a thread executing on the embedded computer a thread executing on the host computer and the studio module .

Furthermore for example using the studio a user can send and receive messages to and from the COM compliant application a scripting program a thread executing on the host computer a thread executing on the embedded computer .

The communication database includes a platform specific configuration section . The platform specific configuration section contains embedded computer machine characteristics and host computer machine characteristics. The characteristics can include items such as an indication of whether the platform is big or little Endian enumeration sizes pointer sizes structure alignment boundaries etc. It is noted that in one embodiment of the invention the embedded computer machine characteristics and the host computer machine characteristics are stored in a location other than the communication database such as the host computer communication module or the embedded computer .

The communication database also includes a messages section and a prototypes section . The messages section and the prototypes section respectively describe the characteristics of each of the messages and remote function calls on the embedded computer and the host computer . The characteristics can include i the unique name and or identifier of the message ii the total size of the message iii the type of the communication e.g. one way message two way message broadcast message remote function call and iv the types of data are passed as part of the communication. A one way message is sent from a user of the communication to the owner of the communication. A thread can request ownership of a message via a registration routine that is provided via an application programming interface of the host computer communication module . A two way message comprises a command that is sent from the user to the owner and a response that is sent from the owner to the user. A broadcast message is sent to all threads that have registered to receive the broadcast.

The communication database also includes a trace points section for maintaining trace points. The communication database also includes a description of the data types that are supported by the messages identified in the messaging section and the functions listed in the prototypes section .

The data types section includes i a description of the data types in the data structures that are part of a message or remote function call e.g. integer character Boolean floating point arrays etc ii the field name of each of the elements in each of the messages iii and a description of characteristics of embedded pointers that may be part of the message.

Next at a step the programmer adds API calls to invoke a read method that is provided by the DAT system . Continuing to a step the programmer adds where applicable API calls to invoke a send method that is provided by the DAT system .

Continuing to a state the programmer adds API calls to subscribe to a message. Subscribing to a message allows a subscriber to bind to a specific message and thereafter receive all broadcast transmissions. Other messaging APIs may be provided by the DAT system such as for the following sending a command sending a response broadcasting a message and defining the data content and meta data characteristics of the payload of a message.

Starting at a state the studio module reads and extracts information from each of a plurality of interface definition files that are provided by the user. Next at a step the studio module extracts the communication interfaces from each of the interface definition files. Information that is extracted can include i the type of the communication e.g. one way two way broadcast remote function call ii the types of data are passed as part of the communication iii a description of the data types in the data structures that are part of a message or remote function call e.g. integer character Boolean iv a description of characteristics of embedded pointers that may be part of the message e.g. whether the memory is pooled or private a method of transmitting the memory that is associated with the communication interface and pointer data that is associated with the communication interface.

Next at a step the studio module stores the embedded computer machine characteristics. The embedded computer machine characteristics can be provided by user entry automatic diagnosis of the embedded computer or automatically provided by the embedded computer . Examples of the embedded computer machine characteristics are described above with respect to . In one embodiment it is assumed that these characteristics are fixed i.e. exactly the same on each connection.

Proceeding to a step the studio module stores the host computer machine characteristics. The host computer machine characteristics can be provided by user entry or automatic diagnosis of the host computer . Examples of the host computer machine characteristics are described above with respect to .

Continuing to a step the DAT system formats the payload for transmission to its destination thread. It is noted that if the destination thread is local to the transmitting thread then formatting may be unnecessary. An exemplary process of formatting data for transmission to a remote platform is described below with reference to . Moving to a step the DAT system transmits the formatted payload to the destination thread.

The use of the process shown in provides interoperability between applications communicating with each other on distributed heterogeneous computing platforms. In one embodiment of the invention to reduce processing and memory requirements on embedded devices the DAT system performs all data formatting on the host computer .

The host computer uses the platform characteristics of the embedded computer and the host computer and the individual interface definition information the communication interface information to properly map messages when two applications on the different computers are communicating. In one embodiment the embedded computer always sends and receives messages in its native form i.e. the form in which the message is stored in its memory. The host computer maps these messages into its form when receiving them and transforms the messages into the embedded computer platform s native form when transmitting the messages to the embedded computer .

Starting at a decision state the host computer communication module determines whether the destination thread is local or remote. If the thread is local the process proceeds to a step and the payload is queued for transmission to the destination thread. If the transmission is local no further modification of the payload is necessary.

Referring again to the decision step if the destination thread is not local the process proceeds to a step wherein the host computer communication module copies data in payload and data referenced by pointers into a message for transmission to the embedded computer . An exemplary process of managing pointer data is described in further detail below with reference to B C and D.

Continuing to a step the host computer communication module formats if necessary the byte order of the elements in data in the payload. For example if the host computer is Big Endian and the embedded computer is Little Endian or vice versa the host computer communication module reverses the order of the bits in the data.

Proceeding to a step the host computer communication module formats the size of the data types in the payload. For example if the embedded computer uses a certain bit length for certain data types and the host computer uses a different bit length the host computer communication module adjusts the size of the data for transmission to the other platform. Moving to a step the host computer communication module adjusts alignment of the data structures according to any requirement of the receiving platform.

Before starting at a state a thread on the embedded computer has invoked a send command that is part of the application programming interface of the embedded computer communication module . In response the embedded computer communication module has built and then transmitted an inter platform message to the host computer communication module . The inter platform message includes the payload that was identified as part of the send command and if applicable the data that is referenced by the pointers in the payload.

Starting at a step the host computer communication module gets the embedded pointer attributes of a selected pointer in the payload of the transmitted communication. In one embodiment of the invention the attribute information is stored in the transmitted communication. A first attribute of each pointer is whether the pointer is classified as IN OUT or IN OUT . The IN attribute designates that the data referenced by the pointer is passed from the sender of the command to the owner of the message but no data is to be returned by the owner of the message. The OUT attributes designates that the sender of the command will not transmit any data that is referenced by the pointer but data will be returned by the owner and stored in the address referenced by the pointer. The IN OUT attribute indicates that the data that is referenced by the pointer will be sent from the sender of the command and that the owner of the message will return data that is stored in the memory referenced by the pointer.

A second attribute of each pointer is whether the pointer is private or pooled. Management freeing of the memory when not in use of private memory is handled by the DAT system . Management of pooled memory is handled by the user and or the owner of a message.

Continuing to a step the host computer communication module creates a local buffer to hold the pointer data. Continuing to a decision step the host computer communication module determines whether the pointer attribute is either IN or IN OUT . If the pointer attribute is IN or IN OUT the process proceeds to a step . Continuing to a step the host computer communication module copies the pointer data that was transmitted from the embedded computer into the local buffer. At this step the host computer communication module formats the pointer data in accordance with the process described above with reference to steps and .

Next at a step the host computer communication module copies the address of the buffer into the payload. Proceeding to a decision step the host computer communication module determines whether the first attribute of the pointer is IN . If the first attribute of the pointer is IN the process proceeds to a decision step . At the decision step the host computer communication module determines whether the second attribute of the pointer is private . If the second attribute of the pointer is private the process proceeds to a step . Otherwise if the second attribute of the pointer is not private i.e. pooled the process ends.

Referring again to the decision step if the first attribute is not IN or IN OUT the attribute is the OUT and the process proceeds to a step . At the step the host computer communication module copies the address of the local buffer into the payload. From step or from decision step if the first attribute is IN OUT the process proceeds to a step . At this step the host computer communication module waits for thread on the host computer to invoke a response command that is provided by the application programming interface of the DAT system . Upon receiving the response the process proceeds to a step . At this step the response data is formatted for transmission to the embedded computer .

From either step or from the decision step if the second attribute of the pointer is private the process proceeds to a step wherein the host computer communication module waits for a thread on the host computer to invoke a read complete command that is in the application programming interface of the host computer communication module . Upon receipt of the read complete command the process proceeds to a step wherein the host computer communication module frees the memory.

Starting at a step the host computer communication module creates a buffer to hold an inter platform message for transmission to the embedded computer . Also at this step the host computer communication module creates a header in the inter platform message for the embedded pointer. Furthermore at this step the host computer communication module stores the pointer attributes of the pointer in the inter platform message.

Continuing to a decision step the host computer communication module determines whether the pointer attribute of the pointer is OUT . If the attributes of a selected pointer is OUT the process ends. However if the pointer attribute is not OUT i.e. it is IN or IN OUT the process proceeds to step . At the step host computer communication module copies the data referenced by the pointer into the header. Furthermore the host computer communication module formats the data for use by a thread on the embedded computer . For example the host computer communication module performs the steps described above with respect to steps and .

Next at a decision step the host computer communication module determines whether the pointer attributes is IN. If the pointer attribute is IN the process proceeds to a step . At this step the host computer communication module frees the memory if warranted i.e. the attributes of the pointer designate pool . However if the pointer attribute is not IN the proceeds ends.

Before starting at a state a thread on the embedded computer has invoked a send response command that is part of the application programming interface of the embedded computer communication module . In response the embedded computer communication module has built and then transmitted an inter platform message to the host computer communication module . The inter platform message includes the payload that was identified as part of the send response and if applicable the data that is referenced by the pointers in the payload.

Starting at a decision step the host computer communication module determines whether the pointer attributes of the pointer in the inter platform message designate the attribute IN . If the pointer attributes designate the attribute IN the process proceeds to a step and the host computer communication module formats the received data for use with the host computer . For example in one embodiment the host computer communication module performs the steps described above with respect to steps and .

However if the pointer attributes do not designate IN i.e. the pointer attributes designate IN OUT or OUT the process proceeds to a step . At the step the host computer communication module creates a local buffer to store the pointer data that was transmitted by the embedded computer . Continuing to a step the host computer communication module copies the pointer data from the inter platform communication into the local buffer. Next at step the host computer communication module copies the address of the buffer into the received payload.

Proceeding to a decision step the host computer communication module determines whether it should free the pointer. In one embodiment of the invention this is determined by reading the pointer attributes. If the pointer attributes designate private the host computer communication module decides to free the memory. However if the pointer attributes designate pooled the host computer communication module allows the user to free the memory.

If the host computer communication module determines in step to free the memory the process proceeds to a step wherein the host computer communication module waits for a thread on the host computer to invoke the read complete command. Continuing to a step the host computer communication module frees the local buffer. From either decision step if the host computer communication module does not free the pointer or the step the process ends.

Before starting a thread on the embedded computer has sent a command message and a thread on the host computer has responded by invoking the send response routine of API of the DAT system .

Starting at a step the host computer communication module allocates space in an outgoing buffer a header to store the data that is referenced by the pointer. The outgoing buffer is part of an inter platform message that is sent from the host computer communication module to the embedded computer communication module . Proceeding to a decision step the host computer communication module determines whether the pointer attributes designate IN . If the pointer attributes do designate IN i.e. they do not designate OUT or IN OUT the process proceeds to a decision step . At the decision step the host computer communication module determines whether to free memory that is associated with the memory that was allocated during the corresponding send command. In one embodiment of the invention this is determined by reading the pointer attributes. If the pointer attributes designate pool the host computer communication module decides to free the memory. However if the pointer attributes designate private the host computer communication module allows the user to own and eventually free the memory via an routine provided by the local operating system . If the host computer communication module determines it should free the memory the process proceeds to a step and the host computer communication module frees the memory. From either step or decision step if the pointer attributes does not designate IN the process proceeds to a step and the host computer communication module formats the data referenced by the pointer for transmission to the embedded computer. For example in one embodiment the host computer communication module performs the steps described above with respect to steps and . As part of the formatting the formatted data is stored in the header step .

Moving to a step the studio module identifies the corresponding script engine that is associated with the script type. Continuing to a step the studio module initializes the script engine .

Next at a step the studio module loads the messaging automation component MAC . The process of loading the MAC is described below with reference to . Proceeding to a step the MAC is exposed to the script engine . In one embodiment of the invention exposing the MAC includes providing the script engine a handle to the MAC . Next at a step the script engine is launched allowing the script loaded in a step to access the API of MAC . Moving to a step a script program can communicate with threads using the API of the MAC . An exemplary process of using the MAC is described below with respect to .

Continuing to a step the MAC database object retrieves the message definition information from the communication database . In one embodiment of the invention the message definition information is retrieved via the host computer communication module . In another embodiment of the invention the message definition information is retrieved directly from the communication database . The message definition information includes i the type of the communication e.g. one way two way broadcast remote function call and ii the types of data that are passed as part of the communication. Next at a step the MAC database object creates a MAC message object based upon the prototype definition retrieved from the communication database .

Proceeding to a step the MAC database object retrieves any data sets from the communication database that are stored with respect to the requested message object. Next at a step the MAC database object adds the data sets to the message object created in step .

Moving to a step the MAC database object returns a reference to the message object to the script. Next at a step the script can set the data fields of the message using reference to the message object. The script has access via the MAC database object to a plurality of readable and writeable data sets. At this step the script can identify one of the data sets for subsequent usage. Continuing to a step the script invokes a send method of the method object. Proceeding to a step the MAC database object sends a data set that is referenced by the current index to the thread that owns the message.

Next at a decision step the MAC database object determines whether auto increment is enabled. Auto increment enables a script to send different data sets with each send command. If auto increment is enabled the process proceeds to a step and the MAC database object selects the next data set. Referring again to the decision step if auto increment is not enabled the process ends.

Continuing to a step the MAC database object retrieves the remote function call prototype definition information from the communication database . In one embodiment of the invention the prototype definition information is retrieved via the host computer communication module . In another embodiment of the invention the message definition information is retrieved directly from the communication database .

Next at a step the MAC database object creates a MAC remote function call object based upon the remote function call prototype definition retrieved from the communication database .

Proceeding to a step the MAC database object retrieves any data sets from the communication database that are stored with respect to the requested remote function call object. Next at a step the MAC database object adds the data sets to the MAC remote function call object.

Moving to a step the MAC database object returns a reference to the remote function call object to the script. Next at a step the script can set the data fields parameters of the remote function call using the remote function call object. The script has access via the MAC database object to a plurality of readable and writeable data sets. At this step the script can identify one of the data sets for subsequent usage. Continuing to a step the script invokes a call method of the remote function call object. Proceeding to a step the MAC database object sends a data set that is referenced by the current index to the thread that handles the remote function call.

Next at a decision step the MAC database object determines whether auto increment is enabled. Auto increment enables a script to send different data sets with each send command. If auto increment is enabled the process proceeds to a step and the MAC database object selects the next data set. Referring again to the decision step if auto increment is not enabled the process ends.

Starting at a step the script calls a read method of the MAC database object. Next at a step the MAC database object calls a read API of the host computer communication module . Continuing to a step the host computer communication module waits for a message to be received. Proceeding to a step the MAC database object receives the message and a message identifier from the host computer communication module . Next at a step the MAC database object returns a message object to the script which can in turn access the contents of the requested message.

Continuing to a step the MAC database object waits for a remote function call command message to be received. Next at a step the MAC database object receives the remote function command message and the function identifier.

Proceeding to a step a remote function call object is returned to the script program. Next at a step the script program access the input parameters of the remote function call object.

Moving to a step the MAC database object returns a reference to the remote function call object to the script. Next at a step the script invokes a return method of the remote function call object. Continuing to a step the remote function call object calls the send application programming interface of the host computer communication module . Proceeding to a step the MAC database object sends a data set that is referenced by the current index to the thread that handles the remote function call.

Next at a decision step the MAC database object determines whether auto increment is enabled. Auto increment enables a script to send different data sets with each send command. If auto increment is enabled the process proceeds to a step and the MAC database object selects the next data set. Referring again to the decision step if auto increment is not enabled the process ends.

Next at a step the COM composer builds the generated component . The generated component is a COM object that is accessible by other COM compliant programs. Using the generated component a COM compliant program can easily test a interface send a communication to a thread that is executing on the embedded computer or the host computer receive a communication that is sent from a thread this executing on the embedded computer or the host computer and other functions as described herein. The generated component provides a plurality of predefined interfaces for performing each of the foregoing functions. An exemplary process of building the generated component is described below with reference to .

Continuing to a step the generated component is accessible via any COM compliant language. An exemplary process of using the generated component is described below with reference to .

Starting at a step a user identifies a database. The DAT system can support multiple databases for multiple projects. Continuing to a step the user selects which messages or functions of the selected database are to be included in the generated COM object. In one embodiment of the invention the user selects the messages and or remote function calls via a graphical user interface utility.

Proceeding to a step the user selects the compiler version. The COM composer needs to know the version of the compiler that is being used to build the generated component to provide the proper control files in the proper format. Moving to a step the COM composer requests the user to designate the type of build e.g. release or debug.

Starting at a step the COM composer tool loads the data that was identified by the user step into memory. Next at a step the COM composer tool begins a process that is performed with respect to the following i all of the messages and or remote function calls identified by the user step ii all of the payloads of the identified messages and or remote function calls and iii the root object that is used to access all other objects in the generated component . In one embodiment steps and are performed for each of the foregoing objects.

At the step the COM composer generates a software interface for each of the objects. An exemplary process of generating an interface is described below with reference to . Next at a step the generated component generates a COM class definition for the object otherwise known as a co class. Proceeding to a step the COM composer generates a COM class implementation for each of the COM objects. For further information regarding generating software interfaces COM class definitions and a COM class implementations please see the following references which are each incorporated by reference in their entirety DON Box ESSENTIAL COM 1998 and BRENT RECTOR CHRIS SELLS JIM SPRINGFIELD ATL INTERNALS 1999 .

Moving to a decision step the COM composer determines whether it has processed all of the messages remote function calls payloads and the root object. If all of these items have not been processed the process returns to the step discussed above . However if all of the items have been processed the COM composer proceeds to a step and provides any compiler specific files that are needed if any.

Next at a step the COM composer launches the selected compiler to build the generated component . In one embodiment of the invention the COM component is provided in a dynamic link library .DLL . Moving to a step the COM composer registers the dynamic link library with a registry in the host computer .

Starting at a step the COM composer generates method definitions for built in member functions. Next at a step the COM composer generates accessor function for child objects . For example the children of the root object includes each of the messages and or remote function calls. Furthermore for example the children of a message object and or a remote function call object includes one or more payloads that are associated with the object. Moving to a step the COM composer generates interface for setting and getting properties of objects.

Before starting at a step the user has opened a COM development environment and located the via the COM development environment the generated component .

Starting at the step the user creates a reference to the generated component . Next at a step the user creates an instance of the root object. Moving to a step the user can use the root object accessor function to retrieve a desired message object or remote function call object. Continuing to a step the user can use the accessor function of the object to select a desired payload object.

Proceeding to a step the user invokes a method of the payload object to get or set properties of the payload object. For example the user can store data in the payload object. Next at a step the user invokes methods on the message object or the remote function call object to send a communication. The user may also invoke other methods on a message object such as register the message such any broadcast on the message is received by the invoking process. Other methods are described above with reference to . Next at a step the user implements an event handler to receive asynchronous communications that are received if any.

Starting at a step the user specifies the communication data paths that are to be traced. For example the DAT system can trace that data is sent via a message or via a remote function call.

Next at a step the DAT system monitors and stores the data that is transmitted across each of the designated communication paths. In one embodiment of the invention the data is stored in a persistent test data object. Proceeding to a step any thread can then select and retrieve the contents of any of persistent test data objects and use the data for testing. Continuing to a step one of the threads of the DAT system uses one of the persistent data object to transmit data from one of the selected persistent data object across one of the communication data paths.

Using the data set fields the user can build a payload for a particular command message and set the payload of the response message. Furthermore the user can select a store data set icon to store the values in the data set fields in the communication database . Later the user can select a load data set icon to load the stored values. Furthermore the user may select a clock icon to have the studio module automatically iterate and transmit the data values in sequence at a user configurable time interval.

Starting at a step the user identifies one or more interface definition files that define the communication interface. For example in code block of illustrates a portion of an interface definition file.

Continuing to a step the user selects one or more of the communication interfaces in the selected interface definition files. In one embodiment of the invention a code generator provides a graphical user interface utility for selection of the communication interfaces.

Next at a step a code template of a thread is generated for handling each of selected messages in the interface definition file. An exemplary process of generating a thread is described below with reference to . An exemplary template is shown in code block of .

Moving to a step a template of a thread is generated for each of the selected functions in the interface definition file. An exemplary process of generating a thread is described below with reference to . An exemplary template is shown in code block of .

Before starting at a step a message handling routine is created to handle all messages that have been identified by the user. The message handling routine includes a loop and subsequent to the loop a switch statement. See e.g. code block . Starting at a step a loop is entered and steps and are performed for each of the identified messages. Continuing to a step the code generator adds a line of code to register each of the messages. See e.g. code block . In one embodiment of the invention the source code includes code to invoke a registration routine that is provided by the embedded computer communication module or the host computer communication module . The call to invoke the registration route is placed prior to the generated switch statement.

Next at a step the code generator generates message handling code for each of identified messages. An exemplary process of generating message handling code is described below with reference to . Continuing to a step the code generator creates routines for sending a message. An exemplary process of creating a routing for sending a message is described below with reference to .

Starting at a step the code generator generates a case statement. Proceeding to a step the code generator generates a comment to the user to instruct the user to add code.

Proceeding to a decision step the code generator determines whether the message is two way . If the message is two way the process proceeds to a step . Otherwise the process proceeds to a step .

At the step the code generator adds code in the generated case statement to invoke a send response routine. As an example code block of includes a call to the SendMesessageTwoWayResponse routine. The process of generating a response routine such as the SendMesessageTwoWayResponse routine is described below with reference to of . In one embodiment of the invention the generated code will invoke an API e.g. SendResponse of the DAT system . At this step the code generator may also generate other APIs for convenience of the user e.g. routines to setup and attach pointers. Moving to a step the code generator may also generate code to invoke a release routine that is provided by the API.

Referring again to the decision step the code generator determines whether message is a broadcast message. If the message is a broadcast the process proceeds to a step . At the step the code generator adds code to invoke an broadcast routine that is part of the API of the embedded computer communication module and the host computer communication module . From steps if the communication is one way and the process proceeds to a step . At the step the code generator determines whether there are pointers present in the payload of the message. If pointers are present the process proceeds to a step . At the step the code generator generates code to invoke a pointer setup command that is part of the communication library API. Next at a step the code generator generates code to invoke the API attach pointer. It is noted that the generated commands during steps and are inserted into the generated code prior to the generated send response command step .

Depending on the embodiment additional steps may be added others removed and the ordering of the steps rearranged. Starting at a step a loop is performed with respect to steps and . In the loop template code is generated for exestuation on a local platform i.e. either the embedded computer or the host computer . The local platform in this context is defined to be the computer that does not have the routine that is to be invoked. Steps and are performed with respect to each of the functions identified by the user in step of . At the step the code generator generates a send command. Next at a step the code generated generates a read command. Proceeding to a step the code generator generates code to return a response. An exemplary code block resulting from steps and is shown in code block of .

Next at a step a loop is performed with respect to steps and . In this loop template code is generated for execution on the remote platform. Proceeding to a step the code generator generates code to invoke a registration routine of the API. Moving to a step the code generator generates code that invokes the local API that was requested by the thread on the other platform and sends a response message. An exemplary code block resulting from steps and is shown in code block .

Next at a decision step the code generator determines whether there are any pointers in the parameters of the function. If there are no pointers in the parameters of the function the process ends. However if there are pointers the process proceeds to a step and the code generator generates code to invoke the API to setup a pointer. Moving to a step the code generator generates code to invoke the API to attach a pointer. The process then ends.

The DAT system provides a single virtual environment that enables threads to be located on different platforms and still seamlessly communicate with each other. The DAT system provides communication interoperability between the two platforms by automatically transforming the data depending on the machine characteristics of the embedded computer the host computer and the communication interfaces that are stored in the communication database . The DAT system provides automatic and seamless access to the message based and remote function call interfaces designed into the embedded computer s software application. The DAT system automatically extracts interface information and builds a database of messaging and remote function call information.

Using the studio module a user has complete visibility and control of the embedded application s interfaces without having to address the following issues i updates to a desktop tool to accommodate new messages ii updates to the embedded software to support the desktop tool s new functionality iii what target compiler is used iv what RTOS is used and iv what platform the thread s are executing on. The DAT system allows seamless access to interfaces stored in the communication database via scripting languages or any COM compliant application.

While the above detailed description has shown described and pointed out novel features of the invention as applied to various embodiments it will be understood that various omissions substitutions and changes in the form and details of the device or process illustrated may be made by those skilled in the art without departing from the spirit of the invention. The scope of the invention is indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

