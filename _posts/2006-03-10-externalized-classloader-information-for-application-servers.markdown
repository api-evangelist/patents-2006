---

title: Externalized classloader information for application servers
abstract: Modules which are running outside of a first application server virtual machine (VM) are enabled to introspect into modules running inside the first VM by notifying a manageable component factory by an application module being executed by a first application server VM of a need to allow a second VM to introspect into and to load class information regarding objects already running in the first VM, wherein the first and second virtual machines are separate virtual machines; registering the already-running object class information to a manageable component server using a descriptor; and loading the registered class information by the second VM from the manageable component server, wherein a tool object or administrative object running in the second VM introspects into and loads the objects already running in the first virtual machine without use of an application programming interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07761862&OS=07761862&RS=07761862
owner: International Business Machines Corporation
number: 07761862
owner_city: Armonk
owner_country: US
publication_date: 20060310
---
This patent application is a continuation of U.S. patent application Ser. No. 10 346 291 filed on Jan. 16 2003 now U.S. Pat. No. 7 051 324 by Thomas R. Gissel which is now under allowance.

The related U.S. patent application Ser. No. 10 346 291 filed on Jan. 16 2003 by Thomas R. Gissel is hereby incorporated by reference in its entirety.

This patent application is a continuation of U.S. patent application Ser. No. 10 346 291 filed on Jan. 16 2003 by Thomas R. Gissel which is now under allowance. This invention relates to technologies to allow program objects being executed by processes outside a virtual machine process to be accessed via standard or normal class loading operations by program objects being executed inside the virtual machine process.

Object oriented programming OOP methodologies are well known and widely adopted as they promote efficient team development of software products allow minimized maintenance activities and provide abilities to easily and dependably integrate modules and objects from older designs other designers and new designs together.

In contrast to procedural programming methodologies OOP allows programmers to define data types of data structures and types of operations or functions which can be performed on those data structures which defines the data structure as an object . Relationships between objects may be defined as well such that some objects may share or inherit characteristics from other objects allowing variations of existing objects to be quickly and efficiently developed. Categories of objects are referred to as a class of objects. Objects of a given class share common properties as defined by the class.

A number of companies have developed and marketed software development tools which support GOP programming languages OOPL including but not limited to Xerox Corporation s TM Smalltalk TM Bell Laboratory s TM C TM Microsoft Corporation s TM Visual C TM Sun Microsystems TM Java TM and Open Management Group s OMG TM Unified Modeling Language UML TM are programming languages which among others implement OOP concepts and methodologies.

In particular Sun Microsystem s Java TM language has gained widespread use for its support of Internet technologies such as applets and embedded Java scripts in web pages servlets which can be run by a web server or application program server etc. Java TM is especially useful for its portability or non machine specific design which enables Java code to be run or executed by any computing platform which is equipped with a Java interpreter. The open nature of Sun s Java TM specifications has also allowed many vendors to participate in the marketplace whether by developing and providing application programs administrative tools or programming tools.

Java code is pseudo compiled into bytecode which is later executed by a machine specific Java TM interpreter. The interpreter converts the bytecodes to machine specific instructions which are executed by the particular computer on which the Java program is being executed. Java defines the virtual computer for which the bytecode is designed as a virtual machine and thus programming is done as if it is to be executed by the theoretical virtual machine. During actual execution on a computer one or more Java Virtual Machines JVM may be created by the computer s operating system each JVM executing Java programs as if it were a real independent computer. Java code can also be converted directly into machine specific executable language using a special compiler the results of which may also be executed within a JVM.

An enterprise server generally refers to a mainframe class computer which is suitable for running programs of a magnitude commensurate with an enterprise . Such as making bulk airline reservations online tracking large real time trading and commodities etc. Java 2 Platform Enterprise Edition J2EE TM which was developed by Sun Microsystems TM with other notable partners such as International Business Machines IBM TM provides a Java compliant platform for enterprise class computers and is in many ways a subset of functionality of the Java 2 Platform Standard Edition J2SE TM .

J2EE provides several key features which make it useful in enterprise computing environments including support for a thin client tiered arrangement between client computers and servers as well as supporting platform independence of modules and code e.g. portability so that vendors may easily target a wide array of enterprise computers with a single design of software.

Additionally J2EE supports Common Object Request Broker Architecture CORBA and a more Java specific and further evolved Enterprise Java Beans EJB concept. CORBA and EJB concepts allow objects to discover the existence and availability of other classes and objects which they may need for data or processing functions and to utilize instances of those objects on an as needed basis whether running on the same computing platform or working together over a computer network. In particular EJB is a server based technology for the delivery of program components in an enterprise environment. EJB supports the Extensible Markup Language XML to define Java Beans e.g. program modules which are designed conformant to the Java Component Architecture and provides enhanced deployment and security features which have gained it rapid adoption by many enterprise server owners and operators.

Java Message eXtensions JMX is the Java specification which if implemented by an vendor of a software product allows software developers to easily integrate their new designs with existing network management solutions. To take advantage of JMX objects are written compliant to the standard as MBeans e.g. manageable Java Beans . A JMX client can invoke methods and access attributes of MBeans via a JMX container in which they reside. Additionally clients can register with an MBean to receive notifications as needed.

The term application server is used widely to refer to a program running on a computer which provides a function needed by a client computer such as a web server as related to a web browser or a banking database server as related to a Automated Teller Machine ATM . Application servers can be small insubstantial programs executed by computing platforms with minimal resources they may be substantial programs e.g. groups of many objects running on enterprise class computers or any combination there between.

Application servers clients computer networks OOP OOP languages Java TM J2EE JMX and MBeans are all well known in the art and information regarding these concepts and specifications is openly available from the vendors mentioned.

Turning to one possible arrangement in an application server AppServer is shown in which multiple client or customer application modules . . . are executed within the same AppServer process such as J2EE compliant AppServer JYM process as a tool user interface UI module . The application modules . . . are represented in this example by Enterprise Archives EAR which are containers of multiple Java objects. The Tool UI may directly access administrative information about the other modules within the same AppServer JYM process using standard JMX application programming interface API calls and thus the tool module may provide administrative functions such as console operations statistical reports etc. Because Java TM allows for easy integration and cooperation of modules by different vendors the vendors of the tool module s and application modules may be many.

However by running the Tool UI module s in the same JVM as the customer s application modules . . . several undesirable issues arise. First the JVM processing bandwidth is divided between all the modules running in it so a tool module or process may negatively impact the performance of an application process. Additionally the running of tool modules in the same AppServer as application processes may represent a security issue. As such many owners of enterprise servers have adopted policies that only application modules may be run in their AppServer JVM s and all other administrative and support modules must be run in other JVM s.

In addition many enterprise server owners have experienced difficulties getting effective diagnosis and support of problems which arise when application modules from a wide variety of vendors are run inside the same JVM. So many of them have adopted even stricter policies that only application modules from the same vendor or supplier may be run in an AppServer JVM.

So tool vendors for such application servers are forced to design their modules for execution outside the AppServer JVM where application modules are running. However J2EE AppServers do not allow modules which are running outside of an AppServer JVM to introspect into modules running inside the AppServer JVM which prevents tool modules running outside the AppServer JVM from obtaining administrative information regarding modules running within the AppServer JVM.

One attempt to solve this problem is shown in . In this approach the tool vendor may place a minimized module or servlet into the AppServer JVM . The Classloader Tooling EAR exports information to a set of tools running outside the AppServer JVM . This approach though means that application modules must perform proprietary or non J2EE standard operations to load interface or class information about the tools from the tool module. This means that in order for the tools to be effective the application modules must be designed to take advantage of non standard interfaces which makes the application modules less portable and less reusable in environments that have other configurations. Also while minimizing the performance impact of placing an non application module in the AppServer process it still may produce a security problem and technically still violates the policies of many enterprise server owners and operators.

Therefore there is a need in the art for a system and method which provides external access by tools for information regarding the performance and administration of application modules running within an application server process such as a J2EE AppServer JVM without the need for the tools to run within the same JVM as the application modules and without the need for the application modules to implement custom or proprietary application programming interfaces.

Modules which are running outside of a first application server virtual machine VM are enabled to introspect into modules running inside the first VM by notifying a manageable component factory by an application module being executed by a first application server VM of a need to allow a second VM to introspect into and to load class information regarding objects already running in the first VM wherein the first and second virtual machines are separate virtual machines registering the already running object class information to a manageable component server using a descriptor and loading the registered class information by the second VM from the manageable component server wherein a tool object or administrative object running in the second VM introspects into and loads the objects already running in the first virtual machine without use of an application programming interface.

The present invention is preferrably realized in conjunction with a standard enterprise class web server suite such as IBM s WebSphere Version 4.0 or greater executing on an server such as an IBM iSeries computer. According to the preferred embodiment J2EE MBeans are used as an integral part of the solution to the problem of externalizing classloader information to a JVM. However it will be recognized by those skilled in the art that other combinations of web server software and OOP programming technologies which achieve the same functionality may be employed without departing from the spirit and scope of the present invention.

Turning to a generalized configuration of a web server computing platform is illustrated including a central processing unit CPU which is typically comprised of a microprocessor associated with random access memory RAM and read only memory ROM . Often the CPU is also provided with cache memory and programmable FlashROM . The interface between the microprocessor and the various types of CPU memory is often referred to as a local bus but also may be a more generic or industry standard bus.

Many computing platforms are also provided with one or more storage drives such as hard disk drives HDD floppy disk drives compact disc drives CD CD R CD RW DVD DVD R etc. and proprietary disk and tape drives e.g. Iomega Zip TM and Jaz TM Addonics SuperDisk TM etc. . Additionally some storage drives may be accessible over a computer network.

Many computing platforms are provided with one or more communication interfaces according to the function intended of the computing platform. For example a computer is often provided with a high speed serial port RS 232 RS 422 etc. an enhanced parallel port EPP and one or more universal serial bus USB ports. The computing platform may also be provided with a local area network LAN interface such as an Ethernet card and other high speed interfaces such as the High Performance Serial Bus IEEE 1394.

Some specialized computing platforms such as wireless networked computers may also be provided with a radio frequency RF interface with antenna as well. In some cases the computing platform may be provided with an infrared data arrangement IrDA interface too.

Computing platforms are often equipped with one or more internal expansion slots such as Industry Standard Architecture ISA Enhanced Industry Standard Architecture EISA Peripheral Component Interconnect PCI or proprietary interface slots for the addition of other hardware such as sound cards memory boards and graphics accelerators.

Additionally many units such as portable computers are provided with one or more external expansion slots allowing the user the ability to easily install and remove hardware expansion devices such as PCMCIA cards SmartMedia cards and various proprietary modules such as removable hard drives CD drives and floppy drives.

Often the storage drives communication interfaces internal expansion slots and external expansion slots are interconnected with the CPU via a standard or industry open bus architecture such as ISA EISA or PCI. In many cases however the bus may be of a proprietary design.

A computing platform is usually provided with one or more user input devices such as a keyboard or a keypad and mouse or pointer device and or a touch screen display . Additionally a microphone is supplied with the computing platform which may be used for a variety of audio enabled applications such as recording audio and voice signals making Internet telephone calls voice navigation of web sites dictating text and commands using voice recognition capabilities etc. Some computing platforms are also equipped with a camera device such as a still digital camera or full motion video digital camera.

One or more user output devices such as a display are also provided with most computing platforms. The display may take many forms including a Cathode Ray Tube CRT a Thin Flat Transistor TFT array or a simple set of light emitting diodes LED or liquid crystal display LCD indicators.

One or more speakers and or annunciators are often associated with computing platforms too. The speakers may be used to reproduce audio and music and annunciators may take the form of simple beep emitters or buzzers.

These user input and output devices may be directly interconnected to the CPU via a proprietary bus structure and or interfaces or they may be interconnected through one or more industry open buses such as ISA EISA PCI etc.

A computing platform is also typically provided with one or more software and firmware programs to implement the desired functionality of the computing platforms.

Turning to now more detail is given of a generalized organization of software and firmware on this range of computing platforms. One or more operating system OS native application programs may be provided on the computing platform such as word processors spreadsheets contact management utilities address book calendar email client presentation financial and bookkeeping programs.

Additionally one or more portable or device independent programs may be provided which must be interpreted by an OS native platform specific interpreter such as a Java TM interpreter. Often computing platforms are also provided with a form of web browser or micro browser which may also include one or more extensions to the browser such as browser plug ins .

The computing device is often provided with an operating system such as Microsoft Windows TM UNIX IBM OS 2 TM LINUX MAC OS TM or other platform specific operating systems. Smaller devices such as PDA s and wireless telephones may be equipped with other forms of operating systems such as real time operating systems RTOS or Palm Computing s PalmOS TM . It is conceivable that the trend of increasing memory and processing capabilities will continue throughout the near future to a point where such small devices reach a utility level to operate a server platforms and as such the present invention may become applicable to such platforms.

A set of basic input and output functions BIOS and hardware device drivers are often provided to allow the operating system and programs to interface to and control the specific hardware functions provided with the computing platform.

Additionally one or more embedded firmware programs are commonly provided with many computing platforms which are executed by onboard or embedded microprocessors as part of the peripheral device such as a micro controller or a hard drive a communication processor network interface card or sound or graphics card.

As such describe in a general sense the various hardware components software and firmware programs of a wide variety of computing platforms including but not limited to personal computers PDAs PIMs web enabled telephones and other appliances such as WebTV TM units. As such we now turn our attention to disclosure of the present invention relative to the processes and methods preferably implemented as software and firmware on such a computing platform. It will be readily recognized by those skilled in the art that the following methods and processes may be alternatively realized as hardware functions in part or in whole without departing from the spirit and scope of the invention.

According one embodiment a J2EE JMX MBean is used to provide an external connection to another JVM process e.g. a non AppServer JVM where the non application object e.g. tools and administrative objects are running. JMX is employed in order to provide access to administrative information from and regarding the running application modules. This allows the application modules to load tool classes in a standard well understood manner which makes the system more open to tool vendors and less dependent on proprietary methods and interfaces while simultaneously maintaining the separation of JVMs for application modules and non application modules e.g. tool modules .

Using this system design tools appear to the application modules to be running co resident with the application modules in the same AppServer JVM and the tool may introspect into the application modules. The standardized methods can be used by the application modules to use a well known API e.g. JMX in this implementation to obtain administrative information from the AppServer JVM including the ClassLoader information instead of interfacing in a proprietary manner to a special tooling servlet or module.

In our exemplary embodiment there are two methods externalized via Module MBeans that provide the classloader information getClassloaderDepth and getClassLoaderInfo.

The getClassloaderDepth method takes no input parameters and returns the number of classloaders visible the module via an integer.

The getClassLoaderInfo method has four input parameters. The first input parameter is an integer level which indicates the level of the classloader information to return wherein 0 zero is the first classloader that will be checked when loading classes and getClassLoaderDepth 1 is the last classloader that will be checked. The second input parameter is a Boolean value atDepthOnly which when true causes the getClassLoaderInfo method to only return the classloader information at the specified level. If atDepthOnly is false upon invocation of the getClassLoaderInfo method all levels between 0 and level will be returned.

The third input parameter to the getClassLoaderInfo method is a Boolean value showClasses which if true then loaded classes are returned. The fourth input parameter to the getClassLoaderInfo method is also a Boolean value showCodeSource which if true when showClasses is true then the codeSource for each class will be returned.

The getClassLoaderinfo method returns a String which contains the classloader information in the form of extensible markup language XML in our exemplary embodiment. Table 1 presents a portion of our Module MBeans XML Descriptor as just described.

Turning to an AppServer process and exemplary implementation of the invention is shown. When the AppServer JVM is equipped with JMX an administration client is also provided which provides interfaces to the external Classloader Tooling vendor s code . The JMX administration client is provided with connectors such as a Remote Machine Interface RMI connector or a Simple Object Access Protocol SOAP connector .

The JMX MBean Server which is a default component of the Java TM management extensions manages the application module MBean s . The MBean Factory receives notification of a need by an application module to load the externalized class during AppServer runtime which then uses the XML descriptor to register the MBean with the MBean server .

As such the externalized classes may be loaded as if they were actually running within the same AppServer process e.g. within the same JVM as the application modules . This provides the best of all possible previous solutions and within a standard or open programming paradigm such as J2EE with JMX. The need to run the non application class objects into the AppServer virtual machine is avoided thus minimizing or eliminating the security and performance risks associated with running the non application class objects into the AppServer virtual machine. Further the application modules are allowed to load the externalized non application modules class information without need for implementation of a custom or proprietary interface.

It will be recognized by those skilled in the art that the scope of the present invention is not limited to the specific detailed exemplary embodiment provided herein. Use of alternate programming languages computing platforms operating systems enterprise server suites and models and module descriptor languages is possible without departing from the spirit and scope of the invention. Therefore the scope of the invention should be determined by the following claims.

