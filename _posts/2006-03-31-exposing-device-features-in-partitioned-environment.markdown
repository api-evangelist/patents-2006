---

title: Exposing device features in partitioned environment
abstract: An embodiment of the present invention is a technique to process an input/output (I/O) transaction. An emulated device driver in a guest partition interacts with a virtual machine (VM) manager in processing an input/output (I/O) transaction on behalf of an application via an operating system (OS). The I/O transaction is between the application and a device. A device emulator in a service partition communicatively coupled to the emulated device driver interacts with the VM manager in processing the I/O transaction on behalf of a device specific driver via the OS. The device specific driver interfaces to the device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08249853&OS=08249853&RS=08249853
owner: Intel Corporation
number: 08249853
owner_city: Santa Clara
owner_country: US
publication_date: 20060331
---
Embodiments of the invention relate to the field of partitioning technology and more specifically to device drivers in a partitioned environment.

In partitioned environment e.g. a virtualized environment many instances of guest operating environments may be created. These guest environments or partitions may run independently of each other. Typically a software layer such as a hypervisor runs directly on the system hardware and exposes the virtual platform to the guest partitions. Under this scheme devices or hardware elements may be exposed to the guest partitions as models having some generic characteristics.

The software layer abstracts the underlying device features into a generic model that may be common to similar devices. One problem with this abstraction is that the particular or unique features of a device may not be fully utilized. In many applications it may be desirable to access the device specific functionalities to utilize the value added or unique features offered by the device.

An embodiment of the present invention is a technique to process an input output I O transaction. An emulated device driver in a guest partition interacts with a virtual machine VM manager in processing an I O transaction on behalf of an application via an operating system OS . The I O transaction is between the application and a device. A device emulator in a service partition communicatively coupled to the emulated device driver interacts with the VM manager in processing the I O transaction on behalf of a device specific driver via the OS. The device specific driver interfaces to the device.

In the following description numerous specific details are set forth. However it is understood that embodiments of the invention may be practiced without these specific details. In other instances well known circuits structures and techniques have not been shown to avoid obscuring the understanding of this description.

One embodiment of the invention may be described as a process which is usually depicted as a flowchart a flow diagram a structure diagram or a block diagram. Although a flowchart may describe the operations as a sequential process many of the operations can be performed in parallel or concurrently. A loop or iterations in a flowchart may be described by a single iteration. It is understood that a loop index or loop indices or counter or counters are maintained to update the associated counters or pointers. In addition the order of the operations may be re arranged. A process terminates when its operations are completed. A process may correspond to a method a program a procedure etc. A block diagram may contain blocks or modules that describe an element an item a component a device a unit a subunit a structure a method a process a function an operation a functionality or a task etc. A functionality or an operation may be performed automatically or manually.

One embodiment of the invention is a technique to process I O transactions between an application and an I O device in a partitioned environment. The technique allows a generic emulated device to expose and service functionality that may be unique or special to the driver and hardware of the real device. This may be performed by proxying the standard driver I O control interface from a guest partition to a service partition that owns or controls the real device hardware. With the I O control proxying all queries from the application to perform certain action whether those are standard or custom are passed directly to the standard device driver. The queries are opaque to the model that is created to represent the real hardware. Any custom commands that are specific to the device then may be honored by the device specific driver. The technique is not limited to strictly virtualization environments. It may be expanded to any environment in which a real device hardware is owned or controlled by one partition and an emulated device of the same class is presented to the other partitions. Any partitioned environment whether created using virtualization or any other type of technology may be employed.

Each of the campuses and represents an enterprise using network interconnections to link personal computers PCs workstations and servers. They may have aggregation of multiple 1000BASE X or 1000BASE T segments into 10 Gigabit Ethernet downlinks. The link may be a single mode fiber link that connects the two campuses and over a long distance e.g. 40 km .

Campuses and may be similar in their infrastructure. The network in each campus may encompass buildings data centers or computer rooms. The campus may include switches routers such as switch router and switch router and a LAN . The campus may include switches routers such as switch router and switch router and a LAN . Switch routers and are typically located at the edge of the corresponding campuses. They are connected together via the link . Switches routers and are connected via a multimode fiber link over shorter distances e.g. 30 80 meters at speed of up to 10 Gigabits per second Gbps . The switch router is connected to the LAN . Similarly switches routers and are connected via a multimode fiber link over shorter distances e.g. 30 80 meters at speed of up to 10 Gigabits per second Gbps . The switch router is connected to the LAN .

The LAN provides connectivity to servers PCs or workstations such as a server and a personal computer PC workstation . Similarly the LAN provides network connectivity to servers PCs or workstations such as a server and a PC workstation . The server or provides specific operations to support the computing environment. They may be a print server connected to a variety of printers a storage server connected to mass storage devices such as tape drive redundant arrays of inexpensive disks RAIDs a media server to provide multimedia services such as video audio or graphics or any server with specific functions. Each server typically includes one or more network interface cards NICs with network connectivity to the corresponding LAN. The PC workstation or may be a processing system running a virtualization platform environment.

The processor unit represents a central processing unit of any type of architecture such as processors using hyper threading security network digital media technologies single core processors multi core processors embedded processors mobile processors micro controllers digital signal processors superscalar computers vector processors single instruction multiple data SIMD computers complex instruction set computers CISC reduced instruction set computers RISC very long instruction word VLIW or hybrid architecture.

The MC provides control and configuration of memory and input output devices such as the main memory and the IOC . The MC may be integrated into a chipset that integrates multiple functionalities such as graphics media isolated execution mode host to peripheral bus interface memory control power management etc. The MC or the memory controller functionality in the MC may be integrated in the processor unit . In some embodiments the memory controller either internal or external to the processor unit may work for all cores or processors in the processor unit . In other embodiments it may include different portions that may work separately for different cores or processors in the processor unit .

The main memory stores system code and data. The main memory is typically implemented with dynamic random access memory DRAM static random access memory SRAM or any other types of memories including those that do not need to be refreshed. The main memory may include multiple channels of memory devices such as DRAMs. The DRAMs may include Double Data Rate DDR2 devices with a bandwidth of 8.5 Gigabyte per second GB s . In one embodiment the memory includes a partitioned environment . The partitioned environment may support I O transactions between an application and a device that expose the add on or unique features of the device to the application. The partitioned environment provides the creation of multiple VMs that may operate independently of one another.

The graphics processor is any processor that provides graphics functionalities. The graphics processor may also be integrated into the MC to form a Graphics and Memory Controller GMC . The graphics processor may be a graphics card such as the Graphics Performance Accelerator AGP card interfaced to the MC via a graphics port such as the Accelerated Graphics Port AGP or a peripheral component interconnect PCI Express interconnect. The graphics processor provides interface to the display monitor such as standard progressive scan monitor television TV out device and Transition Minimized Differential Signaling TMDS controller. The display monitor may be any display device such as Cathode Ray Tube CRT monitor TV set Liquid Crystal Display LCD Flat Panel and Digital CRT.

The IOC has a number of functionalities that are designed to support I O functions. The IOC may also be integrated into a chipset together or separate from the MC to perform I O functions. The IOC may include a number of interface and I O functions such as peripheral component interconnect PCI bus interface processor interface interrupt controller direct memory access DMA controller power management logic timer system management bus SMBus universal serial bus USB interface mass storage interface low pin count LPC interface wireless interconnect direct media interface DMI etc.

The interconnect provides interface to peripheral devices. The interconnect may be point to point or connected to multiple devices. For clarity not all interconnects are shown. It is contemplated that the interconnect may include any interconnect or bus such as Peripheral Component Interconnect PCI PCI Express Universal Serial Bus USB Small Computer System Interface SCSI serial SCSI and Direct Media Interface DMI etc.

The mass storage interface interfaces to mass storage devices to store archive information such as code programs files data and applications. The mass storage interface may include SCSI serial SCSI Advanced Technology Attachment ATA parallel and or serial Integrated Drive Electronics IDE enhanced IDE ATA Packet Interface ATAPI etc. The mass storage device may include compact disk CD read only memory ROM digital video versatile disc DVD floppy drive and hard drive tape drive and any other magnetic or optic storage devices. The mass storage device provides a mechanism to read machine accessible media.

The I O devices to may include any I O devices to perform I O functions. Examples of I O devices to include controller for input devices e.g. keyboard mouse trackball pointing device media card e.g. audio video graphic network card and any other peripheral controllers.

The NIC provides network connectivity to the server . In one embodiment the NIC is compatible with both 32 bit and 64 bit peripheral component interconnect PCI bus standards. It is typically compliant with PCI local bus revision 2.2 PCI X local bus revision 1.0 or PCI Express standards. There may be more than one NIC in the processing system. Typically the NIC supports standard Ethernet minimum and maximum frame sizes 64 to 1518 bytes frame format and Institute of Electronics and Electrical Engineers IEEE 802.2 Local Link Control LLC specifications. It may also support full duplex Gigabit Ethernet interface frame based flow control and other standards defining the physical layer and data link layer of wired Ethernet. It may support copper Gigabit Ethernet defined by IEEE 802.3ab or fiber optic Gigabit Ethernet defined by IEEE 802.3z. The NIC may be a wireless network adapter. It may be compliant with the PCI bus and Universal Serial BUS USB standards. It may cover up to 1000 the coverage and range of the IEEE 802.11g standard.

The NIC may also be a host bus adapter HBA such as a Small System Small Interface SCSI host adapter or a Fiber Channel FC host adapter. The SCSI host adapter may contain hardware and firmware on board to execute SCSI transactions or an adapter Basic Input Output System BIOS to boot from a SCSI device or configure the SCSI host adapter. The FC host adapter may be used to interface to a Fiber Channel bus. It may operate at high speed e.g. 2 Gbps with auto speed negotiation with 1 Gbps Fiber Channel Storage Area Network SANs . It may be supported by appropriate firmware or software to provide discovery reporting and management of local and remote HBAs with both in band FC or out of band Internet Protocol IP support. It may have frame level multiplexing and out of order frame reassembly on board context cache for fabric support and end to end data protection with hardware parity and cyclic redundancy code CRC support.

The guest partition may be an instance of virtual partitions created on the platform or the processing system to operate on physical hardware components. It may include a standard device application a custom device application a layer of operating system OS and an emulated device driver . The standard device application may be an application that uses a standard device. A standard device is a device that may be modeled as a generic device which has some minimal subset of features. The custom device application may be an application that uses a custom interface device. A custom interface device may be a device that has add on features that may be unique or special. These features may be useful to the application. It is therefore desirable to be able to access these unique or special features rather than the generic or minimal features as in the standard device. The layer of OS may include components of the OS that supports the guest partition . It may include standard application programming interface API function calls. The emulated device driver may use these standard API calls to communicate with the application or .

The emulated device driver is a part of a device interface . The device interface is coupled to the VM manager to service a device . It may be implemented by software firmware hardware or any combination thereof. The device interface provides a mechanism to retain or expose the unique or special features of the device . These unique or special features are not masked out by the traditional techniques and are exposed to the application . The device interface may be generic to work with different devices of the same class. Devices may be formed into classes with different characteristics and or functionalities. For example a network class may include all network adapters a storage class may include all storage devices etc. The emulated device driver interacts with the VM manager in processing an I O transaction on behalf of the application or via the OS . The I O transaction is between the application or and the device .

The VM manager manages the VMs created on the platform. These include the guest partition and the service partition . The VM manager acts as a conduit to transfer information between the guest partition and the service partition . It manages the VM interfacing tasks including sending notifications to the device interface .

The service partition may include a device emulator a layer of the OS and a device specific driver . The device emulator is a part of the device interface . It is communicatively coupled to the emulated device driver and interacts with the VM manager in processing the I O transaction on behalf of the device specific driver via the OS . The OS may contain the components of the OS that are pertinent to the device drivers in the service partition . It may be the same as the OS . It may include standard application programming interface API function calls. The device emulator may use these standard API calls to communicate with the device specific driver .

The device specific driver interfaces to the device and has the specific programs or routines in firmware or software to control or configure the device . The device may be any I O device that has add on or special features that may be useful to the application . It may be the NIC shown in .

Upon START the process interacts from a guest partition with a VM manager in processing an I O transaction on behalf of an application via an operating system OS Block . The I O transaction is between the application and an I O device. The I O transaction may be initiated from the application such as an I O control IOCTL function call. An example of such an IOCTL call may be a request to a wireless network adapter to return a list of all the access points that are within the range as seen by the adapter. The I O transaction may also be initiated from the I O device such as an unsolicited notification. An example of such an unsolicited notification may be a status change e.g. disconnected cable down link status . The interaction with the VM manager from the guest partition is explained further in .

Next the process interacts from a service partition with the VM manager in processing the I O transaction on behalf of a device specific driver via the OS Block . The device specific driver interfaces to the device. It may contain specific functions or programs that set up configure or control the device. The interaction with the VM manager from the service partition is explained further in . Then the process is terminated.

Upon START the process receives an I O transaction request from the application Block . The I O request may be intercepted by the OS component that interfaces directly to the application. Next the process determines if the I O transaction request may be handled locally Block . I O transaction may be handled locally when the processing has been performed before and the result has been cached e.g. stored in cache. For example device name or link status may be cached. By caching the values or results of I O transactions the processing may be performed efficiently and fast.

If it is determined that the I O transaction request may be handled locally the process returns a status to the OS Block . The status may indicate that there is no need to wait for the operation because it may be completed within some pre determined time period. Then the process processes the I O transaction locally Block . For example the device name may be retrieved from the cache and returned to the requesting application. The process is then terminated.

If it is determined that the I O transaction request may not be handled locally the process proceeds to process the I O transaction in the remote mode Block . The processing in the remote mode is performed by the device interface and is explained more fully in B A and B. The process is then terminated.

The flow A starts when the OS in the guest partition receives a remote I O transaction request e.g. IOCTL call from the application Block . The application may be the standard device application or the custom device application . The OS then passes the call to the emulated device driver . The emulated device driver places the IOCTL call in a memory shared by the guest partition and the service partition Block . This may involve obtaining the call information e.g. command arguments and prepare the call information in a proper format for retrieval. The emulated device driver then proxies the IOCTL call to the VM manager Block . This may involve making a call to the VM manager to notify of the request. The emulated device driver then returns a pending status to the OS to indicate that an I O transaction is pending Block . This is to ensure that the process is compatible with some time limit provision of the OS . The OS then waits for the pending status cleared Block .

Upon receipt of the notification from the emulated device driver the VM manager notifies the service partition of the pending I O transaction e.g. IOCTL call Block . This may be performed by sending a software interrupt followed by a resume operation or any other notification to the service partition . The service partition then proceeds with the processing as shown in . Subsequently the VM manager receives a notification from the service partition of the completion of the I O transaction. It then notifies the guest partition of the result of the I O transaction Block . This may be performed by sending a software interrupt followed by a resume operation or any other notification to the emulated device driver .

Upon receipt of the notification from the VM manager the emulated device driver obtains the result from the shared memory Block . Then it notifies the OS that the result is available and clears the pending status Block . Upon receipt of the cleared pending status the OS obtains the result and returns the result to the application Block .

The flow B starts when the device emulator receives a notification from the VM manager . The device emulator obtains the IOCTL call information from the shared memory Block . Then it performs the IOCTL call using a standard API call to the OS Block . The OS passes the IOCTL call to the device specific driver which executes or sends the command to the device . Since the device specific driver is specific to the device it is able to access unique or add on features of the device. Accordingly these unique features may be made available or exposed to the requesting application. The device then carries out the requested I O transaction. Depending on the specific nature of the I O transaction it may return the result to the device specific driver or update its status in the status register. The device specific driver then obtains the result accordingly. The OS then obtains the result of the I O transaction from the device specific driver Block . It then places the result in a memory shared by the service partition and the guest partition Block and inform the device emulator . This may be the same shared memory that stores the I O transaction information or a different shared memory. The device emulator then notifies the VM manager of the result Block . The VM manager then notifies the guest partition as shown in Block in .

The flow A starts when the OS receives a notification from the device specific driver of a status change Block . The status change may be any change in the status of the device that may need attention. This may be caused by an event such as disconnected cable down link status etc. Then the OS notifies the device emulator of the status change Block . Upon receipt of the notification the device emulator places the status change information in a memory shared by the service partition and the guest partition Block . It then proxies the status change notification to the VM manager Block . Upon receipt of the notification the VM manager notifies the guest partition of the status change Block . This may be performed by a software interrupt followed by a resume operation or any other notification techniques.

Upon receipt of the notification from the VM manager the emulated device driver obtains the status change information from the shared memory Block . It then posts the status change to the OS using a standard API call to the OS Block . The status change is now available and or accessible to the application Block .

Elements of embodiments of the invention may be implemented by hardware firmware software or any combination thereof. The term hardware generally refers to an element having a physical structure such as electronic electromagnetic optical electro optical mechanical electromechanical parts components or devices etc. The term software generally refers to a logical structure a method a procedure a program a routine a process an algorithm a formula a function an expression etc. The term firmware generally refers to a logical structure a method a procedure a program a routine a process an algorithm a formula a function an expression etc. that is implemented or embodied in a hardware structure e.g. flash memory . Examples of firmware may include microcode writable control store micro programmed structure. When implemented in software or firmware the elements of an embodiment of the present invention are essentially the code segments to perform the necessary tasks. The software firmware may include the actual code to carry out the operations described in one embodiment of the invention or code that emulates or simulates the operations. The program or code segments can be stored in a processor or machine accessible medium or transmitted by a computer data signal embodied in a carrier wave or a signal modulated by a carrier over a transmission medium. The processor readable or accessible medium or machine readable or accessible medium may include any medium that can store transmit or transfer information. Examples of the processor readable or machine accessible medium include an electronic circuit a semiconductor memory device a read only memory ROM a flash memory an erasable ROM EROM an erasable programmable ROM EPROM a floppy diskette a compact disk CD ROM an optical disk a hard disk a fiber optic medium a radio frequency RF link etc. The computer data signal may include any signal that can propagate over a transmission medium such as electronic network channels optical fibers air electromagnetic RF links etc. The code segments may be downloaded via computer networks such as the Internet Intranet etc. The machine accessible medium may be embodied in an article of manufacture. The machine accessible medium may include data that when accessed by a machine cause the machine to perform the operations described above. The machine accessible medium may also include program code embedded therein. The program code may include machine readable code to perform the operations described above. The term data here refers to any type of information that is encoded for machine readable purposes. Therefore it may include program code data file etc.

All or part of an embodiment of the invention may be implemented by hardware software or firmware or any combination thereof. The hardware software or firmware element may have several modules coupled to one another. A hardware module is coupled to another module by mechanical electrical optical electromagnetic or any physical connections. A software module is coupled to another module by a function procedure method subprogram or subroutine call a jump a link a parameter variable and argument passing a function return etc. A software module is coupled to another module to receive variables parameters arguments pointers etc. and or to generate or pass results updated variables pointers etc. A firmware module is coupled to another module by any combination of hardware and software coupling methods above. A hardware software or firmware module may be coupled to any one of another hardware software or firmware module. A module may also be a software driver or interface to interact with the operating system running on the platform. A module may also be a hardware driver to configure set up initialize send and receive data to and from a hardware device. An apparatus may include any combination of hardware software and firmware modules.

While the invention has been described in terms of several embodiments those of ordinary skill in the art will recognize that the invention is not limited to the embodiments described but can be practiced with modification and alteration within the spirit and scope of the appended claims. The description is thus to be regarded as illustrative instead of limiting.

