---

title: Supporting applets on a high end platform
abstract: To execute legacy smart card applications in a next generation smart card environment, a mechanism converts the applications into a format executable by the next generation smart card platforms. For instance, in a Java-based environment, a normalizer tool translates a CAP file into a Java Class file. Additional mechanisms recreate, on next generation smart cards, a specialized environment that allows the legacy applications to execute without impacting legacy and non-legacy application performance. For example, mechanisms create new instances of previously shared objects so that legacy applications can continue to expect exclusive access to those objects. Moreover, mechanisms manage the communication between a legacy application and non-legacy applications by controlling how and when calls are sent to the legacy application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08032872&OS=08032872&RS=08032872
owner: Oracle America, Inc.
number: 08032872
owner_city: Redwood City
owner_country: US
publication_date: 20061218
---
This application claims benefit of Provisional Application Ser. No. 60 757 780 filed Jan. 9 2006 entitled Techniques for Supporting Java Card 2.2 Applets on High End Bandol Platform by Violleau et al. the entire contents of which are incorporated by reference as if fully set forth herein.

This application is related to U.S. patent application Ser. No. 11 591 426 entitled Class Pre Loading Mechanism filed by Violleau et al. on Oct. 31 2006 the entire contents of which is hereby incorporated by reference for all purposes as if fully set forth herein.

Smart cards are cards with embedded circuitry that provide a variety of functionality. Currently smart cards may be used for credit or debit cards SIMs for mobile phones authorization cards for pay television access control cards electronic wallets public transport payment cards and for a wide variety of other purposes. One quickly growing use for smart cards is in the area of digital identification. Smart cards are becoming common as tools for verifying and maintaining digital identification information. The reason for the use of smart cards in the area of digital identification is that the cards are engineered to be secure and tamper resistant.

In general current smart cards are about the size of a credit card although the card may be bigger or smaller depending on its function . The type and amount of embedded circuitry on a smart card also varies. A typical smart card in use today will include around 512 bytes of volatile storage e.g. RAM a slightly greater amount of non volatile storage e.g. around 16 kilobytes of EPROM and a small microprocessor.

Accordingly software written for current smart cards has to be compact in order to execute in current smart cards limited computing resource environments. An example of a software framework for developing and executing applications for current smart cards is Sun Microsystem s Java Card 2.2 technology Java Card Java is registered trademarks owned by Sun Microsystems Inc. Mountain View Calif. . To make use of the limited resources on current smart cards Java Card provides an operating framework that includes an abridged version of the standard Java virtual machine e.g. the Java Card virtual machine JCVM . The JCVM implements a subset of the standard Java virtual machine instructions.

Because the JCVM does not contain all the standard Java virtual machine instructions applications for current smart cards are compacted into a specialized CAP file format. Compressed applets or CAP files are traditional Java class files that have been compressed by translating standard Java virtual machine instructions into a more compact format. This is done by stripping unnecessary information from the Class files from which the CAP files are generated and reducing the number of commands and functions available to be called.

In a Java based environment stripping unnecessary information can include substituting long strings of characters for tokens e.g. a few characters or a small number representing a longer string . For example an original Class file may make an external call to the JavaCard.Framework.Shareable library. A conversion tool translates that call so that all instances of the external JavaCard.Framework.Shareable call are replaced with a token usually only a single byte in size that references that particular library. Thus the original command containing 28 characters or 28 bytes is significantly reduced. Accordingly the size of a CAP file is much smaller than an ordinary Class file. Note that after converting the Class file to CAP format in order to keep external calls and names consistent among multiple applications the mapping of the call to the token may be stored in a separate file such as a JCA or EXP file . Then when other applications are translated those applications can use the same tokens for specific calls. In this way only one copy of the external resource with its tokenized name needs to be stored in the smart card environment.

Moreover since smart cards have limited resources the smart card s virtual machine generally supports a subset of the instructions a normal virtual machine would support. Accordingly during the translation process instructions in a Class format e.g. Java byte code are translated into similar CAP instructions. Often multiple Class file instructions have to be reduced to a single instruction to perform a similar function. Generally compacting commands reduces functionality. In many cases a Class file instruction is simply not supported by a smart card. In those cases the conversion tool may terminate because it cannot complete a translation or it may simply ignore the command throw an exception prompt the user to change the Class file instruction enter a corresponding CAP file instruction or launch a debugging interface. Because of the limited number of commands supported by current smart cards the size of the applications is considerably reduced.

To further reduce the size of the virtual machine on a smart card the conversion tool may take additional steps to preprocess a file before converting it into CAP format. Basically this means that some of the tasks that current Java virtual machines perform are done prior to converting the file into CAP format. For example in a standard Java environment static variables are typically initialized either when a program is launched or the variable is used. In the Class to CAP conversion process static variables are preinitialized and symbolic references in the Class file are resolved before the file is converted. Moreover to further reduce the resources required to execute CAP files Java Classes are checked to make sure they are properly formed and use only the subset of the Java programming language that is properly supported by the smart card platform before converting a Class file to CAP format. This preprocessing keeps the Java virtual machine on current smart cards as small as possible by reducing the amount of error checking and error handling the smart cards need to perform.

After a Java Class file has been converted into CAP format in some cases additional files such as a Java Class Assembly JCA file or export EXP file may also be created. As mentioned above these extra files contain public interface information about the Classes in the CAP file and provide information about the fields and methods in each CAP file and any of its associated files.

Once a Class file has been converted into CAP format the CAP formatted file CAP file can be downloaded to a current smart card using an on card installer program and hardware.

Going forward however a next generation of smart cards is being developed that provide far greater computing resources than current smart cards. Note although the next generation smart cards have far greater computing resources than current smart cards e.g. legacy smart cards the computing resources are still relatively limited when compared to other computing devices e.g. notebook computers cell phones personal computers etc. . Because of the greater computing resources the next generation smart cards can provide a more sophisticated computing environment than the legacy smart cards. As a result software developers have begun developing more sophisticated software for the next generation smart card.

For example Sun Microsystem s next generation Java Card technology takes advantage of the next generation smart cards greater resources by among other things creating a virtual machine that can execute Java Class files. By providing support for Java Class files the next generation Java Card virtual machine expands what a smart card can do. For instance the new virtual machine can implement a much larger set of Java Class libraries e.g. Strings can execute applications in a multi threaded environment and can make available many of Java access control mechanisms. Basically the next generation Java Card environment provides support for many if not all of Java s traditional features.

Moreover by providing support for Java Class files application development costs for the new smart card platform are reduced since applications can be developed with traditional development tools and ported to the new platform without drastic changes to the application design or code. In this sense the next generation Java Card platform drastically reduces the need for CAP files.

In fact as it stands problems can arise when attempts are made to execute applications in CAP format on a next generation smart card. For example CAP files have been designed to run as single threaded applications. As a result applications on the legacy smart cards have been designed to share common resources e.g. application data units or certain system files . In next generation smart card environments sharing a single common resource among multiple applications causes the JCVM to slow down because the JCVM has to perform additional checking to flag the unsafe storing of references. For example an application may contain a reference to an APDU object that is now in use by a different application. The JCVM performs checks to flag these bad references. Otherwise an application could use its stored reference to access information in the APDU object even though another application has assumed control of it.

Beyond just runtime performance issues another problem with supporting CAP files or other legacy applications on next generation smart cards is the development and resource costs of implementing the equivalent of two virtual machines one to support CAP files and another to support Class files. Although next generation smart cards have more computing resources than legacy smart cards they generally do not have sufficient resources to implement the two different virtual machines or the equivalent thereof .

A proposed solution is to simply update legacy applications to be compatible with the next generation smart card. Unfortunately the cost and time involved in updating and upgrading CAP files and other legacy applications can be quite significant. Software users may not have the time to wait for new software releases and even so they may not be able to afford the updated applications once released. Similarly software developers may not put a high priority on updating older applications. Hence it may be months or years or maybe never before an application is updated.

Overall the current solutions for enabling both legacy and non legacy applications to be executed on a next generation smart card are not satisfactory.

The approaches described in this section could be pursued but are not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

An approach for executing legacy smart card applications in a next generation smart card framework is described herein. A legacy smart card application generally refers to a single threaded application which expects to be the only active application at any given time. A next generation smart card framework generally refers to a multi threaded smart card environment in which multiple applications can be executing concurrently. In the legacy smart card environment to ensure the safe execution of a legacy smart card application access to the legacy smart card application by other applications is permitted only through a shareable interface object.

Accordingly in one embodiment of a next generation smart card framework a specialized single threaded environment is created so that a legacy smart card application can execute safely. One aspect of the specialized environment includes a proxy object. The proxy object encapsulates the legacy smart card application s shareable interface object in order to control how other applications access methods objects references functions and routines within the legacy smart card application. In one embodiment the proxy object only allows one application to access the shareable interface at a time.

Further in one embodiment the specialized environment in the next generation smart card framework creates new copies of objects that in a legacy smart card environment were shared. In one embodiment the new copies of objects are generated whenever another application requests access to the shared object. In one embodiment the amount of data used to create the copies is limited to just the object type itself.

Also described herein is an approach for converting a legacy smart card application from a compressed format such as the CAP file format into a non compressed format.

Techniques for executing applications developed for legacy smart cards and other low resource environments on next generation smart card platforms are described herein. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

Techniques are discussed herein for executing legacy smart card applications legacy applications on a next generation smart card. In one embodiment the techniques include mechanisms for converting the legacy applications into a format executable on next generation smart card platforms. For instance in a Java based next generation smart card environment a converter mechanism translates a CAP file into a Java Class file.

The techniques described herein provide further mechanisms that imitate or recreate on the next generation smart cards the specialized environment that legacy applications are designed to execute in. For example because of limited resources a legacy smart card often requires legacy applications to share common objects with other alternatively running applications. As a result those legacy applications were designed with the expectation to have sole access to a given resource until completion of the command processing cycle. The techniques described herein provide mechanisms to create new instances of shared objects so that legacy applications have exclusive access to the previously shared objects.

Moreover the techniques provide mechanisms to manage the interaction between a legacy application and next generation applications e.g. by serializing calls to the legacy application . For example in one embodiment a proxy mechanism is created to manage the communication between a legacy application and non legacy applications.

These and other techniques are provided so that legacy applications may co exist with the more sophisticated applications without significantly impacting both the legacy and non legacy application s performance. Moreover the techniques and mechanisms help create a runtime environment on next generation smart cards that is compatible with the one expected by legacy applications. Note that the techniques and mechanisms may be implemented by an application on a smart card computer or other computing device or by a combination of server based and client based tools or by other methods.

The procedures and tools described in this invention are often described in terms of Java Card 2.x technology Java Card and the next generation Java Card development and runtime environments. These environments are meant only to serve as exemplary environments in which the techniques of the present invention are employed. In alternative implementations the techniques may be employed in other environments.

Generally framework provides a runtime environment in which both non legacy applications such as servlet based applications and extended applets and legacy applications such as legacy applets can execute. Note that non legacy and legacy applications may be collectively referred to as applications herein. The applications executing in framework can perform a wide variety of functions. For instance they can act as single sign on servers providing access to a number of different computing resources with a single user name and password provide digital rights management services by verifying a user s access rights to digital media filter spam by passing a user s email through the smart card and other functions.

In servlet based applications are example applications that can execute within framework . The servlet based applications include applications that were specifically designed and written for the next generation smart card framework. As such servlet based applications typically do not need to be converted from one file format to another to be executable by virtual machine . In a next generation Java Card environment servlet based applications are Java Class files.

In addition to servlet based applications framework may also execute extended applets . Extended applets refer to legacy applications that have been rewritten by software developers to take advantage of the new libraries and lower level functionality of the next generation smart card framework . Extended applets are not compressed class files or translated versions of compressed class files. In a next generation Java Card environment an extended applet can be a Java Class file written to include Java Class features.

In legacy applets generally refer to applications that were designed to run on legacy smart cards and were converted from a more fully featured version into a compressed format to run on the limited resource environments of legacy smart cards then translated back into the functional equivalent of the original file. In a next generation Java Card environment legacy applets include files that were translated into the CAP file format and then translated back into a Java Class format.

In framework non legacy applications and legacy applications are interpreted by virtual machine . Virtual machine generally refers to any software interpreter used to interpret applications on a next generation smart card. Depending on implementation virtual machine may be Java based so that virtual machine runs Java Class files. In other embodiments virtual machine may execute other types of files.

Virtual machine is designed to run in the resource environment of next generation smart cards. In addition in one embodiment virtual machine also creates a runtime environment in which legacy applications can execute. To help create the environment in which legacy applications can execute virtual machine includes code that transitions the runtime environment from using a single shared copy of an object to an environment that creates separate objects for each application thereby avoiding deadlock and other security issues. Moreover in one embodiment virtual machine includes code to generate proxy objects that control access to legacy applications. By doing so legacy applications can run as single threaded applications in a multi threaded environment. In various implementations these features may be performed by components other than virtual machine .

Note that in addition to carving out a single threaded environment for legacy applications virtual machine can be further enhanced to improve overall application performance. Basically virtual machine is designed to improve performance of all applications running on next generation smart cards.

Each of the other building blocks can be a software module. For example the other building blocks can be application programming interfaces dynamic link library files separate applications integrated components of virtual machine or some other software tool that defines interfaces between virtual machine and the applications. Moreover each of the other building blocks may refer to more than one module or software file. For instance applet container may refer to several files that contain object definitions for objects and methods called by extended applets .

The functions provided by the other building blocks generally help reduce the collective amount of resources needed by individual applications by for example off loading code common to a number of applications. For instance new APIs provide a set of building block routines protocols and tools specific to the next generation smart environment that developers can call upon when designing and writing software to run on virtual machine . For example a servlet based application can be designed to use a new API that provides a common interface for applications running on virtual machine . This makes using applications easier for users since the applications will have a similar interface. In a next generation Java Card environment the new APIs include APIs that provide routines interfaces protocols and functions that are specific to the next generation Java Card virtual machine e.g. support for Strings .

In one embodiment like the new APIs common APIs provide access to applications and virtual machine to commonly requested functions routines protocols and interfaces. For example if a number of applications commonly call the same function e.g. a data sort function that function can be written as a separate helper file and packaged as one the common APIs .

Servlet container and servlet API in one embodiment include additional resources such as classes functions interfaces and routines that enable servlet based applications to execute properly. For example servlet container creates an environment in which non legacy applications can spawn multiple threads. The applet container and applet API can help provide an environment in which both legacy and non legacy applications can execute. For example they can spawn multiple threads so that non legacy applications can execute at peak performance and they can also provide an environment in which legacy applications remain thread safe and execute securely.

The legacy APIs also contain other classes and resources such as Java Card 2.x APIs that provide interfaces functions and routines so that virtual machine can execute extended and legacy applets. When extended and legacy applications are executing applet container and applet API may provide additional support and library files so that those applications can execute properly.

In an embodiment the other building blocks or a subset thereof particularly the applet container and applet API can help provide the special runtime environment in which legacy applications execute.

In one embodiment framework includes a class pre loading mechanism as described in Class Pre Loading Mechanism filed by Violleau et al. The class pre loading mechanism isolates legacy application library files and code such as legacy APIs from multi threaded applications in the framework. By isolating the library files from multi threaded applications much of a legacy application s code becomes inaccessible to non legacy applications. As a result a legacy application can run more securely since only legacy applications running in a single threaded mode can access the code.

As mentioned above servlet based applications and extended applets are applications that have been designed and updated to run in a next generation smart card framework. Legacy applets on the other hand are legacy application that were developed to run in legacy smart card environments and that have not yet been updated to run in next generation smart card environments. As a result legacy applets include applications that are in a compressed file format incompatible with next generation smart card frameworks.

To execute the legacy applications in the next generation smart card framework in one embodiment the legacy applications are converted from their compressed format into a format compatible with next generation smart cards. Then the next generation smart card framework particularly the runtime environment is adapted to recreate the specialized environment in which the legacy applications were designed to execute in. For example the next generation smart card framework creates new objects where previously they were shared. In addition the next generation smart card framework uses proxy objects to control access to legacy applications. In this way legacy applications can run as single threaded applications in the next generation multi threaded smart card framework.

To be compatible with next generation smart card runtime frameworks legacy applications generally need to be converted from the format created for the limited resource environments of legacy smart cards into a format compatible with next generation smart cards. For instance in a next generation Java Card environment the underlying virtual machine does not directly support CAP files. This is generally a design decision based on the fact that providing direct support for non legacy and legacy applications would consume too many computing resources. Hence in one embodiment the legacy application files are converted into a format compatible with the next generation smart card s virtual machine before the legacy application is executed.

In an embodiment a normalizer tool translates a compressed Class file into a non compressed Class file format. The normalizer tool essentially recreates lost information in the legacy application files. For example in the most basic setting a user imports a CAP file into a normalizer tool to convert the CAP file into a Class file s . The normalizer tool then creates a new file and maps each CAP file instruction to a corresponding Class file instruction and places the translated instruction into the new file. Once all the instructions have been translated the new file is saved as a Class file.

As part of converting the legacy application it should be noted that the process may be attempting to re create a file or application that had originally been written in a non compressed format. In such a case it may be difficult to generate an exact duplicate of the original file from which a legacy application was generated. Hence in one embodiment the normalizer tool converts legacy applications to files that are the functional equivalents of the original files. Basically normalizer tool generates code that substantially duplicates the function of the original application. For example in a next generation Java Card environment a normalizer tool converts a CAP file back into a file executable by the next generation virtual machine and functionally equivalent to the original Java Class file. Although in some implementations the normalizer tool may be able to recreate in its entirety an original noncompressed file.

It should be noted that there may be some case in which an application was originally written directly as a CAP file. In such a case the normalizer tool does not attempt to recreate an original file but instead the tool tries to create a next generation smart card application file that performs substantially the same function as the CAP file performs.

In one embodiment system for converting legacy application is part of the next generation smart card framework. In this embodiment the legacy applications are converted at the time the legacy application is launched on the next generation smart card. Alternatively system is separate from the next generation smart cards. For example a legacy application can be downloaded from the legacy smart card and passed through an off card normalizer tool to convert the legacy application into a format interpretable by a next generation smart card.

In one embodiment system includes normalizer tool that receives as input a legacy application with any associated helper files and outputs converted code . The converted code generally refers to any non compressed application format. For example it can refer to a Class file or some other non compiled set of instructions byte code a non legacy application or other symbolic representation of an application performing the functional equivalent of legacy application . In one embodiment converted code is Java Class byte code.

To illustrate how the normalizer tool works consider the example of converting a CAP file to a Class file. Typically a CAP file along with any associated helper files include enough information to create Class files that can act as the functional equivalent of the original Class file from which the CAP file was generated. The process for converting a CAP file to a Class file generally includes translating instructions in the CAP file and its component files to a corresponding set of instructions in the Class file.

In a Java based environment normalizer tool takes as input a CAP file and any associated files e.g. an EXP file that contain information about external classes associated with the CAP application . The instructions contained in the CAP file and its associated files are converted into Java Class instructions and saved as a JAVA Class file e.g. converted code.

The process of converting the instructions in a CAP file is performed by the normalizer tool . The process includes identifying instructions in the CAP file and performing look ups in an index or table to determine a corresponding set of Class instructions. Below Table 3 illustrates an example byte code conversion table showing CAP file instructions with their corresponding Java Class byte code instructions. Note that in Table 3 the first three columns of the table relate to CAP file instructions a number value the corresponding HEX or byte value and the corresponding text representation of the instruction. The next three columns relate to Java Class byte code instructions a number value the corresponding HEX or byte code value and symbolic representations. In some cases an instruction also includes a brief description of what it does or why it is mapped in a particular way.

To convert the CAP file into a Class file the normalizer tool iterates over the entire CAP file mapping each CAP instruction to its corresponding Class instruction. For example using Table 3 as a guide suppose the normalizer tool encounters the CAP file instruction 0 70 . The normalizer tool performs a table look up to find the corresponding Java Class instruction 0 A7 and replaces the CAP instruction with the Java Class instruction in converted code .

During the conversion process the normalizer tool may also consult the additional helper files. For example if the CAP file includes an instruction to an external function or routine that has its mapping stored in an EXP file the normalizer tool consults the EXP file for the appropriate call mapping. In the end normalizer tool generates converted code that performs the functional equivalent of the CAP file. In this example the resulting converted code is Java Class byte code.

As noted above normalizer tool attempts to create a file that performs the functional equivalent of the original application. Generally the differences between the converted code created by normalizer tool and an original Class file should be few. Some of the more common differences can include the following 

1 The names of non public and non shareable classes in an applet package may be different. This can occur when converting Classes to CAP format the name of a Class file is typically converted to a token or numerical representation. Then when the CAP file is converted back the Class name is converted into something different. For example if a Class file is originally entitled Person and then converted to CAP format. In CAP format the Person Class may now be a numeric token e.g. 12 . During that translation the actual title for the Person Class is lost because to a computer names mean nothing. Thus when the CAP file is translated back normalizer tool may have to automatically generate a new title for the Person Class e.g. Class 1 . Note that although the name has changed the underlying function should remain the same.

 2 For similar reasons the names of non public methods and fields may be different from what they were originally named.

 3 The names of public fields and methods in an applet package that are not inherited from a class in another package may also vary.

 4 Finally the source file attribute for the class file e.g. the attribute that defines the source and destination directories for a class may be different from the original.

Although these are the four most common differences it should be noted that in some instances certain attributes associated with a Class file may also be difficult to reproduce. For instance some methods in a Class have an optional exceptions attribute that may not be recreatable by the normalizer tool. Similarly the line number and local variable table attributes may also differ after a CAP file has been reverse converted. Finally converted code may be different from the byte codes in the original class files due to optimizations that take place on the byte code before converting a Class file to a CAP file.

Once a legacy application has been converted into converted code in one embodiment signer tool signs the converted code with a private key so that other applications and users may verify the integrity of the Classes provided.

To further break down the process of converting a legacy application into a non legacy application consider the procedure illustrated in . It illustrates an example procedure for converting a legacy application into a non legacy application. The procedure involves three main steps 1 reading and verifying the legacy application and associated files 2 generating non legacy files corresponding to the legacy application and 3 writing the non legacy files to disk so they can be tested .

At step a normalizer tool like the normalizer tool illustrated in reads a legacy application such as a CAP file to verify its integrity. In one embodiment an off card tool can be used to perform this step. The step of verifying its integrity involves ensuring that the file is complete and does not contain errors or other inconsistencies e.g. bad instructions or calls to invalid routines . If the legacy application is valid and complete the application is then translated into its corresponding non legacy application format.

At step a normalizer tool like the normalizer tool illustrated in generates the corresponding non legacy application files. For example suppose the normalizer tool is used to convert a CAP file to corresponding Class file structures. In this example those file structures include a separate files for separate Classes and within each Class a section for constants a table for defining various interfaces and routines in a Class a field table that outlines the names of variables and fields in a Class and a method table that identifies the separate methods within the CAP file. The normalizer tool analyzes the CAP file in order to identify each Class associated with a CAP file and the Class file structures originally associated with the Class file. Once each Class and its corresponding structures have been identified then the normalizer tool using predetermined offsets converts the CAP file commands into corresponding Class file instructions and fills the appropriate information into the converted Class file. To aid in the conversion process the normalizer tool may use a conversion table such as conversion table illustrated in to map CAP file instructions to corresponding Class file instructions.

The normalizer tool is designed to know the order it should encounter instructions in a CAP file and in what order those commands should be placed in the corresponding Class file. In an embodiment the original Class file structures and their order are defined by a descriptor component contained in the CAP files themselves or alternatively one of their associated configuration file . The descriptor component can define an entire Class as well as its corresponding Class file structures. For example the descriptor component may correctly outline the fact that a Class should list some basic Class identification information such as its major and minor version numbers. The descriptor component may also outline which constant pool entries for a Class may be generated as well as additional features such as access flag information interface definitions and other field data. Finally the descriptor component can define where methods and attributes definitions fit within a Class.

In some embodiments a specific descriptor component may not be available. In such cases the normalizer tool may analyze the entirety of a CAP file at the outset to determine the structures it defines and then using that information develops the corresponding Class file.

It should be noted that generally the descriptor component acts as the starting point for getting the information necessary to build Class file s since it contains information about all of the Classes in a CAP file. However even with a descriptor component in one embodiment the normalizer tool may perform several passes over the CAP file in order to extract information that defines Class file structures and then input information into those Class file structures.

For example the process of building a Class file can require the normalizer tool to perform several analytical passes over the corresponding CAP file. In an embodiment the first pass over the CAP file involves the normalizer tool analyzing the descriptor component to identify the basic components of a corresponding Class file and add basic information regarding the implemented interfaces fields methods and attributes to a constant pool portion of the Class file. In subsequent passes over the CAP files the normalizer tool can add additional information to the constants pool about other Classes being referenced including interfaces fields methods associated with those other Classes. In one embodiment after the CAP file and its associated files have been analyzed a constants pool count is created to describe the number of entries in the constants pool. That information identifies the number of additional structures that need to be built in the Class. Moreover the constants pool count can be an indicator to determine the offset for specific values and instructions to be inserted into the Class file.

In addition to creating the constants pool during passes over the CAP and associated files the normalizer tool may create additional placeholder type structures such as an interfaces array and methods array for the Class file. The type and number of these structures will vary based on the actual files being analyzed and implementation of the CAP files Class files and normalizer tool.

In one implementation a placeholder structure e.g. an array is created for each general structure in a Class e.g. an array is created for constants flags interfaces methods fields attributes etc. These placeholder structures contain indexes for the interfaces flags fields methods and attributes directly implemented in a Class. The reason for creating these placeholder structures is because in a CAP file it can be difficult to determine exactly which components are implemented directly by the Class being processed e.g. a CAP file can contain information regarding the current Class and all of its super classes . So these placeholders are meant to keep track of which interfaces belong to which Class.

Once all the individual structures have been identified e.g. how many methods flags interfaces etc. per Class the normalizer tool performs additional passes over the CAP and associated files in order to fill out information for each identified structure. For example the normalizer tool performs a pass over the CAP file in order to identify and extract information for each of the methods identified. Then the normalizer tool converts those instructions into its corresponding Java Class instruction and places the instruction in the associated method file structure.

It should be noted that during the conversion process the normalizer tool may not find names for particular methods. In such cases the method names especially for private or package private methods are generated automatically by the normalizer tool. If the name of a method can be found the normalizer tool performs checks to verify the method name is not being used elsewhere e.g. in a super class and names the method.

The result of this process is that the normalizer tool converts all the code into converted code. Each instruction in a CAP and its associated file is evaluated and mapped to a corresponding Class file instruction.

Once the conversion process is complete as noted above there may be differences between an original Class file and the one generated by the normalizer tool for example some names access flags and attributes may be slightly different but the files themselves should behave as functional equivalents.

In other implementations a different set of components and structures may be used to parse and extract information from a legacy application.

Once the Class file has been created at step the Class file is checked to ensure its validity. In one embodiment the normalizer tool generates a JAR file that contains all the newly created non legacy application files as well as the legacy application files. The reason for storing both is so that the two sets of files can be compared on subsequent installations to ensure the data is complete and accurate. In an embodiment other files and Classes such as a proxy shareable interface object class may be added to the JAR file in order to help the converted application execute in a next generation smart card framework. In addition in an embodiment the newly created files are tested for example by loading it using a Java class loader.

Once an executable file for the next generation smart card framework has been created for the legacy applications tools and techniques recreate the specialized environment in which those applications executed.

To ensure the safe execution of legacy applications in the next generation smart card framework a specialized environment is created for the legacy applications. This specialized environment ensures that the legacy applications can execute as single threaded applications.

To understand how to create the specialized environment for the legacy applications additional information about the legacy smart card environment is provided herein. In the legacy smart card environment when a legacy application is launched the runtime environment including the virtual machine creates objects in which it stores and manipulates data. The objects created by the runtime environment are owned by the application that creates it. A firewall mechanism protects each legacy application from intermitted external access. Thus a legacy application cannot access another application s objects or object methods unless they are explicitly shared.

The firewall mechanism is a virtual machine runtime enforced protection created for legacy smart card environments. For example in a Java Card environment the Java Card virtual machine ensures application isolation through its firewall mechanism. As a result a legacy application can access resources within its own context but not beyond it. The way the firewall controls access to an application is by assigning an object space called a context to each application on the card when it is initially executed. The legacy smart card environment s firewall mechanism creates and manages each generated context. In a legacy environment only one context is active at any one time e.g. because the legacy environment is single threaded . When an external resource attempts to access a resource protected by a firewall the firewall mechanism checks the call to determine if access should be allowed. Generally when a call is made from within the same context access to the called resource is allowed. On the other hand calls made from an application or resource in a different context is generally prohibited by the firewall.

There are however a number of cases when applications from different contexts need to share data. Thus when necessary the legacy smart card environment provides secure ways of sharing data. In a Java Card environment those mechanisms include entry point objects EPO global arrays and shareable interface objects SIO .

Briefly an EPO is a mechanism in Java Card that allows certain objects to be flagged e.g. either by the virtual machine at runtime or by the developer as entry point objects. Once flagged those methods become accessible to any context.

Global arrays refer to specific data structures that by their nature are accessible in any context. For example for applications to communicate APDU messages are sent between applications. The APDU Application Data Unit buffer holds those messages until they can be processed. In order for an application to send and receive those messages the application has to have access to them. Accordingly an APDU buffer is implemented as a global array that applications and resources from any context can access.

Although EPOs and global arrays are two of the mechanisms for sharing some data between applications ultimately in a Java Card environment shareable interface objects SIO are the mechanism for accessing another application s methods.

An SIO generally refers to an instance of a Class that implements a shareable interface. Through the shareable interface an object can export its methods to other applications. Thus if a developer wants certain methods in an application to be exported those methods are declared in an interface that extends the tagging interface javacard.framework.Shareable . This indicates to the Java Card runtime environment that these methods can be accessed from other contexts. When the defined interface is implemented in a Class and instantiated as an object of that Class that newly created object is an SIO.

A requestor application that requires access to an object held by a receiving application sends a call to the receiving application which determines whether it will share the requested object with the requestor application. In a Java Card embodiment the requestor application may call the JCSystem.getAppletShareableInterfaceObject method to access another application s object interface. Upon receiving the call if the receiving application determines that it can grant access to requestor application then the receiving application returns a reference of type SIO to the requested object.

The requestor application can then invoke methods using the SIO. For example the requester application invokes an interface in the SIO to access the appropriate object or object method in the receiving application s context.

Thus in Java Card an application can only invoke methods from another application through the SIO mechanism. This prevents obvious hacks such as casting an object reference to gain access to all of the public object methods bypassing the restriction of the interface.

Techniques are used during on card execution to provide the specialized runtime requirements of legacy applications without imposing a significant performance penalty on other applications.

To recreate the specialized legacy application environment in a next generation smart card framework mechanisms create fresh copies of objects that were previously shared. The reason why fresh copies are created of previously shared objects is to remove from the firewall the burden of monitoring references to shared objects and preventing an application from keeping non local references to such objects.

As noted before legacy smart cards have very limited resources. As a result in the legacy smart card environment applications often share objects that are common to more than one application. For example one of the more common objects used in legacy smart card environments is the APDU Application Data Unit . An APDU buffer is used to facilitate the exchange of messages between applications. When APDUs are exchanged between applications a lot of sensitive information is passed through APDUs. For instance as part of the process of verifying a user s rights to a piece of digital media as APDUs are sent back and forth from a media player to the smart card one of the messages contains the user s password to access to the digital content.

Because of their size in the legacy smart card environment APDUs are often shared and or reused. Sharing APDUs creates the potential for security leaks. For example since APDUs can be shared and or reused it might be possible for one application to access information from another application stored in the APDU because the APDU and the information in the APDU are common to both applications . Thus an application could snoop for and capture confidential information meant for another application.

For example by monitoring APDUs a requesting application could find out the name of the responding application and monitor messages destined for the responding application. Accordingly to prevent these types of security leaks the legacy smart card environments granted exclusive access to the APDUs until an application terminated. Then before granting access to other applications the APDU buffers were cleared. Accordingly legacy applications were developed with the expectation of having exclusive access to certain shared objects.

In next generation smart card frameworks enforcing the legacy smart card restrictions imposes unnecessary performance penalties on non legacy applications. For instance suppose that a user is playing encrypted video. To decrypt the digital video signal a smart card is used to verify the user s access rights. Decrypting the digital video signal involves processing a significant amount of data by the card. In a legacy smart card environment video playback performance is significantly affected by the constraints imposed by its operating environment. By removing many of the legacy smart card constraints next generation smart card frameworks improve playback performance.

For example in the next generation smart card framework provides mechanisms for creating separate copies of objects that were previously shared in legacy smart card environments. In an embodiment the new objects created for each application are not duplicates of existing objects but are new objects created to work in conjunction with a particular application or thread.

In an embodiment virtual machine generates a new copy of shared objects in memory each time an application calls for one. Accordingly in framework previously shared objects are allowed to proliferate. For example in one embodiment a legacy applet executing on virtual machine receives an APDU from an external process. This APDU is encapsulated in an APDU object. Upon receiving the APDU object in a legacy smart card environment the legacy applet responds using the same APDU object. The problem in the legacy smart card environment is that the next command processing cycle e.g. the next application waiting to be executed has to wait until after an APDU object is released until it can begin to be processed. In an embodiment of the next generation smart card framework virtual machine allocates one APDU object to encapsulate APDUs sent to and returned from legacy applets but now a different APDU object may be used for the next command processing cycle.

Creating new copies of previously shared objects helps virtual machine avoid the potential performance penalties that can occur when applications have access to the same object resource e.g. virtual machine does not need to perform additional checking to flag bad object references stored by an application . In this way the next generation smart card framework creates an environment in which legacy applications can execute smoothly.

Furthermore by creating new copies of previously shared objects legacy application security concerns are minimized. In other words each new object is created fresh minimizing the amount of data in any one shared object. Thus even if sensitive data is added to a shared object the legacy application does not hold a reference to the shared object for very long. This means that even if another application has access to a previously shared object the information in any one particular object becomes stale very quickly.

In one embodiment next generation smart card framework provides a multi threaded environment in which legacy applications can execute. However to ensure execution safety and the integrity of non thread aware applications in a multi threaded environment a proxy object is introduced to the next generation smart card framework . The proxy object acts as a surrogate to the legacy application s SIO. In addition the proxy objects help prevent legacy applications from unnecessarily tying up resources and slowing down the performance of other applications.

Even in the next generation smart card framework a legacy application assumes that it is the only active application at any given time. However as discussed above in a next generation smart card environment that assumption may not be accurate. Other applications non legacy or legacy can be running concurrently. To avoid potential conflicts in an embodiment framework creates proxy objects that control access to the legacy application. Thus to a legacy application it appears as if it is the only application running.

For example in the next generation smart card framework messages sent to the legacy applications can be in the form of APDUs. A legacy application accepts and responds to those messages in a single threaded manner. Thus when a legacy application receives an APDU it expects to be able to process the entire request and respond back to the calling service before receiving any additional information.

At the same time in framework non legacy applications such as servlet based applications and extended applets may be running concurrently spawning new threads. For instance when a servlet based application receives an HTTP message it may respond with a message indicating that the message was received and is being processed. At the same time the servlet based application may start a separate thread to begin processing the call. Thus multiple threads may be running at any given time in the framework . As a result multiple simultaneous calls may be made of a legacy application.

To handle those calls the legacy application s SIO in one embodiment is encapsulated by a proxy object. A proxy object generally refers to an object of type class proxy. In one embodiment there is a proxy object for every SIO.

According to one embodiment the proxy type acts as an envelope around the SIO so that when calls are received the proxy object simply check to see if another thread is already executing the SIO s legacy application code. If so the calling thread is suspended until the thread accessing the legacy application code terminates. In one embodiment it performs these functions using Java thread synchronization primitives.

In other embodiments a proxy class implements methods and interfaces that ensure that the SIO and legacy application code are accessed by one thread at a time. For example in an embodiment the proxy class includes methods and attributes to intercept and store messages intended for an SIO. Accordingly the proxy class implements a list queue stack or array with associated methods to store the messages intended for the SIO. In another embodiment the proxy object performs call serialization in some other way to the SIO object. In addition the proxy class also implements methods to control access to the SIO object. For example the proxy class may include methods to instantiate the SIO methods to destroy the SIO after all calls from a particular requesting application have completed an invoke method to access the SIO s methods synchronization methods that control how and when a requestor application is allowed to access the SIO a priority method to determine the priority in which the receiving application should respond to calls a polling method to determine if the legacy application is busy error checking methods to verify that a call is valid identification methods to verify the identify of the requestor application a forwarding method that sends APDUs messages to the legacy application a reply method that stores and forwards responses from the legacy application back to the requesting applications and a variety of other methods that may be useful in controlling access to an SIO. Note that the above listed methods are example methods and depending on implementation may vary from one framework to another.

Other attempts to access legacy application code may be managed by an APDU dispatcher. The APDU dispatcher is a system component or a component of the virtual machine that receives APDU messages and upon receiving an APDU message to be processed by legacy application code checks to see whether another thread is already executing the legacy application code. In one embodiment the APDU dispatcher performs this check via the same locking mechanism used for serializing calls to the legacy applet SIO. If the legacy application code is free then the APDU dispatcher can grant access to the legacy application code.

In an embodiment access to a legacy application is controlled by using an execution context lock or a global container lock. In other words the proxy object can use synchronization mechanisms such as those found in Java to ensure only one application has access to the legacy application at a given time.

According to one embodiment the next generation smart card framework automatically detects when a legacy application is invoked. In one embodiment a normalizer tool inserts tags into the code to indicate that an application is a legacy application. Thus when the legacy application s SIO is invoked framework checks for the tag indicating a legacy application and instantiates a proxy object for the legacy application s SIO. Then all calls to the legacy application s SIO are intercepted by the proxy object and serialized before invoking the original SIO s methods. In alternative embodiments the legacy application can be determined in some other way e.g. by checking a major minor version of a Class maintaining a registry or list that identifies which applications are legacy applications etc .

In one embodiment applet API creates the proxy object for a legacy application. Alternatively virtual machine automatically instantiates the proxy object when a legacy application is invoked.

Referring again to framework suppose a non legacy application calls information from a legacy application. In one embodiment framework intercepts the call and detects that the call is being sent to the legacy application. Accordingly in one embodiment framework launches the legacy application and instantiates a proxy object for the legacy application s SIO. In one embodiment the SIO is also instantiated at this time. In addition framework creates an entry in its applications list to redirect any messages sent to the legacy application to the proxy object.

Once the proxy object has been instantiated the original message intended for the legacy application is forwarded to the proxy object. In one embodiment the message is serialized and processed. When the message is finally processed by the proxy object in one embodiment the proxy object invokes the appropriate method and or called data called through the legacy application SIO.

Once the call has been answered in one embodiment the legacy application sends the response to the proxy object which then forwards the response to the requesting application. By sending the response through the proxy object the proxy object can track when the legacy application becomes available. Moreover the proxy object can ensure a certain level of performance. Alternatively the legacy application responds directly to the requesting application.

Suppose that during the interval that the legacy application is creating a response to the first received message several other calls from other applications are simultaneously sent to the legacy application. In one embodiment those messages are redirected to the proxy object which serializes them. Then each time the legacy application completes a response to a message the proxy object processes the next message. In this way the proxy object prevents the SIO from dropping incoming messages.

Basically the proxy object intercedes when a call comes in from a source external to the legacy application. When the SIO is in use the proxy object holds up other calls until the SIO is released. Then the proxy object calls the requested information through the SIO. Accordingly requesting applications can communicate with legacy applications.

With reference to suppose legacy applet is executing in framework . Accordingly framework has generated a proxy object for legacy applet s SIO. Thus when a servlet based application calls data from the legacy applet in an embodiment virtual machine detects the call sent from servlet based application to legacy applet . The call is redirected to the proxy object which then forwards the call through the SIO to legacy applet . Then legacy applet processes the call.

Now suppose that before legacy applet has completed processing the call from servlet based application extended applet also sends a call to legacy applet . In an embodiment the call from the extended applet is intercepted by the proxy object and held until legacy applet has finished processing the call from servlet based application and released its resources. Similarly if other calls are made of legacy applet those calls are intercepted and held by the proxy object until the calls can be serviced.

In this way legacy applet can continue to function without being compromised by other applications. It should also be noted that the proxy object should not create much of a performance penalty. Only applications attempting to access a legacy application are directly affected. Other processes and applications continue executing around the legacy application.

Accordingly at step a specialized environment is created for the legacy application. In one embodiment the next generation smart card virtual machine creates and manages the specialized environment. As described above a legacy application is usually only accessible to other applications through an SIO. Since the next generation smart card environment allows multiple applications to execute concurrently the legacy application may receive numerous calls at a time even though its SIO may only be designed to handle one call at a time . As a result in one embodiment a proxy object is created to encapsulate the SIO. By doing so access to the SIO can be controlled. Basically the proxy object intercepts calls and forwards them to the legacy application through the SIO as each previous call is completed. Thus only one call or however many calls the SIO is capable of handling is allowed to access the shareable interface at a time.

In one embodiment the next generation smart card s virtual machine may also further enhance the specialized environment by creating copies of objects that were intended by the single threaded application to be shared. It does so by detecting when the legacy application is accessing an object in memory that in the legacy smart card environment is intended to be shared. When the next generation smart card framework detects the object it simply creates a new copy of the object in memory. Thus the object is no longer a shared object.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for the tools and techniques described herein. According to one embodiment of the invention tools and techniques are provided by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. One or more processors in a multi processing arrangement may also be employed to execute the sequences of instructions contained in main memory . In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to nonvolatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory .

Common forms of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge or any other medium from which a computer can read.

For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infrared transmitter to convert the data to an infrared signal. An infrared detector coupled to bus can receive the data carried in the infrared signal and place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the worldwide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface . In accordance with the invention one such downloaded application provides for techniques as described herein.

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

