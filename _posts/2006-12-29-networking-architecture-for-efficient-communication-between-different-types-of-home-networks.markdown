---

title: Networking architecture for efficient communication between different types of home networks
abstract: A method is described that involves performing the following between first and second appliance networks: receiving a packet from the first appliance network; removing header information for the first appliance network from the packet; and, sending the packet's payload into the second appliance network without having appended any header information for the second appliance network to the payload. Another method is described that involves performing the following with a network interface to a first appliance network: receiving a first command through an API for the first appliance network where the command identifies an appliance and an action to be taken by the appliance; translating the first command into a second command that identifies the appliance and the action to be taken by the appliance, where the second command is in a format for a second appliance network that is a different type of appliance network than the first appliance network; and, constructing a packet having header information formatted for the first appliance network and a payload containing the second command.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08346954&OS=08346954&RS=08346954
owner: Intel Corporation
number: 08346954
owner_city: Santa Clara
owner_country: US
publication_date: 20061229
---
The field of invention relates generally to the computer sciences and more specifically to a networking architecture for efficient communication between different types of home networks.

The commoditization of silicon chips has permitted the integration of intelligence in the form of a processor or microcontroller executing program code and connectivity in the form of some kind of network interfacing capability into many household or office appliances such as a remote controls televisions telephones security systems lights and or lighting systems music and or video players recorders and or receivers thermostats smoke detectors garage door openers meters etc. Unfortunately a number of different networks have come into existence for permitting such household devices to communicate e.g. X10 ZigBee Z Wave IEEE 802.11 based networks and Universal Plug n Play UPnP leaving the home owner or IS manager with the problem of bridging between networks so that an appliance connected to one type of network can communicate with another appliance connected to another type of network.

Embedding all of the appliances   through     through     through   with dual network capability as depicted in allows each of these appliances to communicate both with its respective local network     or  N and the UPnP network . A problem with this approach however is that is has the potential to raise the complexity and or cost of these appliances in terms of additional or more advanced hardware e.g. additional physical interface components and or memory and or higher performance processing cores and or software e.g. a pair of executable protocol stacks one for each the networks .

The act of turning on a light connected to the X10 network from a PC becomes more complex however if the PC that issues the command is located on another network such as the UPnP network e.g. PC   . Specifically because the PC   is connected to the UPnP network the PC   only has a network interface   with corresponding API for a UPnP network. As such the PC   can only issue a command through its UPnP API and send a UPnP packet to gateway  .

A UPnP X10 translator   residing on the gateway   is responsible for comprehending the UPnP command contained in the payload of the packet and translating it into the same command but crafted in the X10 format. That is the payload of the packet is changed from a command to turn on a specific light scripted in the UPnP format into a command to turn on the same light scripted in the X10 format. Routing and transport layer headers may also need to be changed removed as well in order to construct a complete new X10 packet containing the command originally issued by the PC   on the UPnP network . The gateway   then sends the X10 packet created by the translator   to the light   over the X10 network   and the command is executed.

Although the prior art approach of avoids increasing the complexity cost of the appliances in the manner that the approach of does the approach of nevertheless still exhibits efficiency problems in the form of fairly complex costly gateways   through  N. Here the software that performs the translation functions     through  N is somewhat complex in the sense that ideally they are each designed to comprehend any command contained by a received packet and rewrite that command into the proper format for the packet to be transmitted.

This typically involves an understanding of how specific appliances are identified in both the incoming and outgoing packet languages and the ability to map the identification of a particular appliance articulated in the incoming packet format to the identification of the particular appliance articulated in the outgoing packet format and an understanding of how specific appliance actions are specified in both the incoming and outgoing packet languages and the ability to map the identification of a particular appliance articulated in the incoming packet format to the identification of the particular appliance articulated in the outgoing packet format . Because of the relative sophistication of the translator software the processing power of the gateways   through  N should be fairly powerful.

The approach of is believed to be potentially more cost effective than the approach of because although the approach of embraces the use of gateways   through  N similar to the approach of the functionality of the gateways is much less sophisticated in the approach of as compared to . The approach of instantiates all translation software   through  N for communication between the UPnP network and any other network   through  N into a single appliance e.g. a computer such as a personal or laptop computer . Thus whereas the UPnP X10 command translation needed to successfully communicate a command from an appliance connected to the UPnP network to an appliance connected to the X10 network   was performed on gateway   in the approach of in the approach of that same command translation can be performed   on the appliance   that actually sends the original command.

As a consequence the function of gateway of   is now reduced merely to a simplistic encapsulator decapsulator which is a much less sophisticated function that full translation. As will be described in more detail below the encapsulator decapsulator merely involves the adding and or stripping of packet headers for a particular network type format. For instance for communication from appliance   to any appliance on the X10 network   gateway   will simply remove the UPnP headers on the received packet.

As described in more detail below depending on implementation the X10 headers needed to construct a complete X10 packet may be formed by the sending appliance  . In this case the sending appliance   not only constructs a command written in the X10 format because of its local translation   capability but also constructs an entire X10 packet complete with X10 headers. Here the sending appliance   appends UPnP headers to the complete X10 packet. As such a complete X10 packet corresponds to the payload of the packet formed by appliance   and sent to the gateway  .

Alternatively the X10 headers may be formed by the gateway  . In this case the payload of the packet sent by the sending appliance   merely corresponds to an X10 command rather than a complete X10 packet. Thus the packet sent by the sending appliance   has UPnP headers appended to a payload having an X10 command. The gateway   strips off the UPnP headers from the received packet and appends X10 headers to payload containing the X10 command. The former approach X10 headers created by the sending appliance   is expected to result in the most cost effective solution because the gateway   just strips off UPnP headers as opposed to stripping off UPnP headers and adding X10 headers. Better said in the former case the gateway   does not need to comprehend any transport or routing protocol semantics formats of the X10 network while in the later case it does.

The approach of is believed to be very suitable to the typical situation involving multiple appliance networks in the home or office where efficiencies exist by having a master control hub that controls many if not most or even all appliances across all networks. For instance an automated shut down procedure to be executed every evening may involve 1 setting the thermostat to a lower temperature 2 setting the burglar alarm and 3 turning off certain lights. The thermostat burglar alarm and lights may be spread across the plurality of networks   through  N e.g. the thermostat is on the X10 network   the burglar alarm is on the Z Wave network   and the lights are on the IEEE 802.11 network  N . The shut down procedure therefore involves the control hub   sending a number of commands into the various networks   through  N.

Having the control hub is an efficient solution because different types of procedures are apt to be desired e.g. a shut down procedure a bring up procedure an emergency procedure an entry procedure an exit procedure etc. and having the application software   through  X for each of these procedures each one of which includes its own set of invoked appliances to whom commands are to be sent and a corresponding command for each such appliance running on one machine or one type of machine such as a machine having a particular type of operating system with a substantial amount of processing power such as a personal computer laptop computer or notebook computer permits at least the possibility of better integration compatibility and or reuse of the this application software   through  X.

Another efficiency is observed in in that the different smart appliance application software programs   through  X can be written so as to invoke only a single type of network interface API in the case of UPnP network interface   . This should be more cost effective than a more distributed approach in which different appliances connected to different networks are responsible for overseeing different procedures. For instance if appliance   was responsible for running the shut down procedure appliance   was responsible for running the bring up procedure and appliance   was responsible for running the emergency procedure the shut down application software would need to be written for an X10 network interface API the bring up procedure application software would need to be written for a Z Wave network interface API and the emergency procedure application software would need to be written for an 802.11 network interface. Thus having a centralized control hub architecture should result in less expensive application software implementations.

Note that having a centralized control hub approach may also as a general trend result in commands being largely sent in one direction and responses to commands which usually entail a simple statement that the command was or was not successfully executed being largely sent in the opposite direction. For instance in the case of where appliance   is the control hub commands will largely be sent from the control hub   and often thereafter from the UPnP network into the other networks   through  N. Likewise responses to commands will largely be sent to the control hub   and often from the other networks   through  N into the UPnP network .

According to the methodology of using an example where appliance   corresponds to the control hub and appliance   corresponds to an appliance that is targeted to receive a command from the control hub   initially the application software running on the control hub   issues a command through the API of a network interface   for a first appliance network type UPnP network . The network interface   of the control hub in response to the command performs the following 1 translates   the command from the first appliance network type UPnP to the second network type X10 that the targeted appliance   is connected to 2 forms a complete packet of the second network type X10 having both header information of the second network type X10 and the translated command 3 forms a packet of the first network type UPnP having header information of the first network type UPnP appended to a payload the is packet formed in 2 above.

The packet formed in 3 above is then sent 503 into the network of the first type UPnP network . The packet is received by the gateway   for the second network   to which the targeted appliance   is connected. The encapsulator decapsulator   of the gateway   simply strips off the UPnP header information from the received packet and sends the payload which is a complete X10 packet into the X10 network  . The targeted appliance   receives the packet from the X10 network   and executes the received command .

Recalling from above that there exist two basic approaches one in which the encapsulator decapsulator comprehends the networking and transmission protocols semantics of the targeted X10 network and another it which it does not note that the methodology described above corresponds to the later. If were redrawn to depict the former process would ultimately form a packet having header information of the first network type UPnP and a payload that is only a command written in the second network type format X10 rather than both a command and header information in the second network type. Moreover the encapsulator decapsulator   process would not only strip off the first network type UPnP header information but also append second network type X10 header information to the payload found in the received packet.

The methodology of describes a process for responding to a command. According to the methodology of continuing with the example above where appliance   is the control hub and appliance   is the targeted appliance that is responding to a command sent by the control hub   the targeted appliance   forms and sends a packet into the second network X10 whose header information and payload are formatted according to the X10 format. Note that the payload contains the response which typically indicates whether or not the command was accepted and or executed successfully. The gateway   receives the packet and merely appends header information of the first network type UPnP to the received packet and resends it into the UPnP network.

The control hub   receives the packet and removes the UPnP header information to reveal the complete X10 packet originally sent by appliance  . The UPnP X10 translator   of the control hub network interface   then translates the X10 command into a UPnP command. The application software running on the control hub that sent the initial command then receives the translated response through the UPnP API.

Again recalling from above that there exist two basic approaches one in which the encapsulator decapsulator comprehends the networking and transmission protocols semantics of the targeted X10 network and another it which it does not note that the methodology described above for corresponds to the later. If were redrawn to depict the former gateway encapsulator decapsulator process could ultimately form a packet having header information of the first network type UPnP and a payload that is only a response written in the second network type format X10 rather than both a response and header information in the second network type. As such process of the control hub s network interface need only involve the removal of the UPnP header information to reveal the X10 response.

For each broadcast response that is received by the new control hub   the new control hub   will interrogate the gateway that sent the response for information pertaining to the gateway and its corresponding appliance network. For example gateway   will be interrogated by the new control hub   so that the new control hub   can learn more about network   e.g. what type of network it is in this case an X10 network and the appliances connected to it e.g. the network addresses of appliances     and their corresponding appliance type light TV etc. respectively . By interrogating each gateway in this manner and by interrogating other devices on UPnP network that respond to a same similar broadcast the new control hub   can fully educate itself of the inter networked community it is coupled and to support its instance of the UPnP API e.g. so proper constructs for specific types of appliances can be instantiated . Alternative to an interrogation each gateway can simply report such information to the new control hub as part of its response to the new control hub s broadcast.

A similar process applies when a new appliance is attached to an appliance network behind an already known gateway. A new appliance broadcasts its entry to its network. For example if a new appliance is added to X10 network   the broadcast is issued into network  . In response the gateway   to the network   forwards the broadcast to the control hub   according to previously described processes e.g. processes associated with . In response the control hub interrogates the appliance according to previously described processes e.g. processes associated with . Note the information associated with the interrogation whether for a new gateway event or a new appliance event could also be supplied as part of a broadcast as well.

It is important to emphasize that although the above example uses a UPnP network as the network to which the control hub is attached conceivably any appliance network could be used as the network to which the control hub is connected. Moreover the functions of the above described network interfaces e.g. translation packet formation packet header information removal etc. as well as the encapsulator decapsulator function could be performed in hardware e.g. with logic circuitry and or memory implemented on one or more semiconductor chips software e.g. program code executing on a processor processing core microcontroller etc. or some combination of both.

As mentioned above processes taught by the discussion above may be performed with program code such as machine executable instructions that cause a machine that executes these instructions to perform certain functions. In this context a machine may be a machine that converts intermediate form or abstract instructions into processor specific instructions e.g. an abstract execution environment such as a virtual machine e.g. a Java Virtual Machine an interpreter a Common Language Runtime a high level language virtual machine etc. and or electronic circuitry disposed on a semiconductor chip e.g. logic circuitry implemented with transistors designed to execute instructions such as a general purpose processor and or a special purpose processor. Processes taught by the discussion above may also be performed by in the alternative to a machine or in combination with a machine electronic circuitry designed to perform the processes or a portion thereof without the execution of program code.

It is believed that processes taught by the discussion above may also be described in source level program code in various object orientated or non object orientated computer programming languages e.g. Java C VB Python C C J APL Cobol Fortran Pascal Perl etc. . The source level program code may be converted into an intermediate form of program code such as Java byte code Microsoft Intermediate Language etc. that is understandable to an abstract execution environment e.g. a Java Virtual Machine a Common Language Runtime a high level language virtual machine an interpreter etc. or may be compiled directly into object code.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

The exemplary computing system of includes 1 one or more processors 2 a memory control hub MCH 3 a system memory of which different types exist such as DDR RAM EDO RAM etc 4 a cache 5 an I O control hub ICH 6 a graphics processor 7 a display screen of which different types exist such as Cathode Ray Tube CRT Thin Film Transistor TFT Liquid Crystal Display LCD DPL etc. 8 one or more I O devices .

The one or more processors execute instructions in order to perform whatever software routines the computing system implements. The instructions frequently involve some sort of operation performed upon data. Both data and instructions are stored in system memory and cache . Cache is typically designed to have shorter latency times than system memory . For example cache might be integrated onto the same silicon chip s as the processor s and or constructed with faster SRAM cells whilst system memory might be constructed with slower DRAM cells. By tending to store more frequently used instructions and data in the cache as opposed to the system memory the overall performance efficiency of the computing system improves.

System memory is deliberately made available to other components within the computing system. For example the data received from various interfaces to the computing system e.g. keyboard and mouse printer port LAN port modem port etc. or retrieved from an internal storage element of the computing system e.g. hard disk drive are often temporarily queued into system memory prior to their being operated upon by the one or more processor s in the implementation of a software program. Similarly data that a software program determines should be sent from the computing system to an outside entity through one of the computing system interfaces or stored into an internal storage element is often temporarily queued in system memory prior to its being transmitted or stored.

The ICH is responsible for ensuring that such data is properly passed between the system memory and its appropriate corresponding computing system interface and internal storage device if the computing system is so designed . The MCH is responsible for managing the various contending requests for system memory access amongst the processor s interfaces and internal storage elements that may proximately arise in time with respect to one another.

One or more I O devices are also implemented in a typical computing system. I O devices generally are responsible for transferring data to and or from the computing system e.g. a networking adapter or for large scale non volatile storage within the computing system e.g. hard disk drive . ICH has bi directional point to point links between itself and the observed I O devices .

It is believed that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments Java based environments such as a Java 2 Enterprise Edition J2EE environment or environments defined by other releases of the Java standard or other environments e.g. a .NET environment a Windows NT environment each provided by Microsoft Corporation .

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

