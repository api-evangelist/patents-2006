---

title: System and method of remotely managing and loading artifacts
abstract: A system and method for remotely loading artifacts is disclosed. The system and method involves monitoring application installation events on a computing device. In response to detecting an application installation event, the application installation event is intercepted. The application associated with the application installation event is searched for artifacts, and any artifacts found within the application are stored in a centralized location. The artifacts are further indexed according to a target namespace. In one embodiment, the system and method further involved receiving a query from a client to locate an artifact, locating the artifact from previously extracted artifacts and returning the artifact as URL address.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07761559&OS=07761559&RS=07761559
owner: International Business Machines Corporation
number: 07761559
owner_city: Armonk
owner_country: US
publication_date: 20061013
---
The present disclosure generally relates to a method apparatus and computer usable code for remotely loading and managing artifacts.

An artifact is data that an application requests for use in running or executing a process. This data may be for example an entry from a database a text file a table a class a dynamically linked library DLL file a value or a like object. Artifacts are often required to be shared between one or more applications.

Some typical solutions for sharing artifacts include sharing by copy shared library database artifact registry models and passing artifacts with instance data.

A shared by copy approach involves copying the artifact into each application s scope. However there are many drawbacks to such an approach. One drawback is that version control becomes hard. When the shared artifact needs to be changed each of the applications which uses the artifact needs to be uninstalled and redeployed. Another drawback with the shared artifact approach is that implementing dynamicity is quite difficult. For example in the case of a generic administrative application which manages other applications on a server each time a new application with new artifacts is installed that the administrative application needs to manage the administrative application must be stopped and even uninstalled. The new artifacts then must be copied to the administrative application. Further the administrative application has to be redeployed. Finally there is a lack of proper data isolation with the shared by copy approach. For example consider application A has artifact A which defines customer using a first target namespace and application B has artifact B which defines customer with a different field but using the same target namespace. For the administrative application that manages both applications A and B copying artifacts A and B to the administrative application will cause confusion as to which customer to use when an instance of customer needs to be created.

Another well known approach is using a shared library model. For example a shared library can be created and common java classes and artifacts can be copied to this library. This shared library can be added to an application s classpath so that the application has access to those artifacts and java classes. This approach is an improvement over the shared by copy solution. However it still has the same drawbacks related to implementing dynamicity and data isolation as discussed above. For example in the case of the dynamicity issue when new artifacts are defined or created in new applications the shared library needs to be re deployed. In the case of data isolation since multiple applications can see load everything in their shared library the issue still exists in this approach. If artifact A and artifact B define the same target namespace and type such as customer placing artifacts A and B directly into the same shared library will cause a conflict to arise. Another major drawback of this approach is the lack of remote loading. Since a shared library is local to a server or cluster a shared library could not be used by servers on different clusters let alone servers on different cells.

A variation of the shared library approach is using a database to store artifacts. The database in this approach is sometimes called an artifact registry. Although this approach solves the remote access loading issue any server application has access to the database or artifact registry could use artifacts this approach still does not resolve the dynamicity issue. It does not define how an application behaves when it can access conflict artifacts. Second this approach requires database access. In Java 2 Platform Enterprise Edition J2EE and Java 2 Platform Standard Edition J2SE integrating an application with a central database is not an easy task as it requires extensive Java Database Connectivity JDBC or J2EE entity bean design and programming.

Another solution has been to pass artifacts which can include meta data along with instance data. This way when a client receives instance data it can use the attached artifact to interpret the instance data. One example of this is a scenario supported by Microsoft .Net. In this scenario a Web Service Definition Language WSDL response generated by .Net contains a response e.g. an instance data along with meta data. For example the meta data may be in Extensible Markup Language XML or more specifically an XML Schema Definition XSD schema. .Net expects the service caller interprets response using the attached XSD schema. The biggest problem of this approach is performance. Meta data only needs once after it is loaded in memory the consequent creating instance data shall be supported. By always passing schema with instance data the same meta data will need to be loaded again and again for handling subsequent instance data. The second issue of this solution is that it is artifact types specific and protocol specific. The .Net approach only provides a solution for XSD schema passed using web services.

In one aspect of the disclosure a computer program product comprises a computer useable medium having a computer readable program. The computer readable program when executed on a computer causes the computer to monitor one or more application installation events on a computing device. Further in response to detecting an installation event the computer readable program when executed on the computer causes the computer to intercept the application installation event. The computer readable program when executed on the computer causes the computer to further extract any artifact associated with the application and store the artifact in a centralized location. The artifact is indexed based on at least its target namespace. In addition the computer readable program when executed on the computer causes the computer to locate the artifact based upon a query.

In yet another aspect of the disclosure the computer readable program can be implemented as a method. Accordingly the method can perform the functionality of the computer readable program without a computer program product.

In another aspect of the disclosure a system is disclosed. The system has a monitoring module that monitors one or more application installation events on a computing device and in response to detecting an application installation event extracts an artifact found within an application associated with the application installation event that was detected. The system further includes a centralized location that stores the artifact and indexes the artifact according to a target namespace. The system also includes a communication module that receives a query for the artifact.

An artifact is data used by an application in order to run or execute a process. This data may be for example an entry from a database a text file an XML file a table a class a dynamic link library file a value or some other object.

As XML becomes popular more and more modern applications are using artifacts defined in an XML file. There are two main categories of XML files. One defines meta data e.g. xsd schema and another contains instance data. XML schema files express shared vocabularies and provide a means for defining the structure content and semantics of XML documents. XML schema is one example of an artifact or data needed by an application to run. Applications use artifacts to define meta data and based on meta data to create an instance e.g. XML file or Java object.

An artifact can be identified by a Target NameSpace TNS . In general a namespace is an abstract container providing context for the items such as artifacts it holds and allows disambiguation of items having the same name residing in different namespaces . For example as a rule names in a namespace cannot have more than one meaning that is two or more things cannot share the same name. A namespace is also called a context as the valid meaning of a name can change depending on what namespace applies.

Therefore the target namespace is only guaranteed to be unique within the universe that it is created or contained. Most often such a universe is an application. However in a distributed computing environment where multiple applications need to communicate with each other and each of the applications may be located in different servers or even on different networks issues may arise.

In some cases applications have totally different artifacts that use the same target namespace. This makes sharing and maintaining artifacts difficult. In modern software applications hardly only work independently. Very often data is exchanged between applications. To interpret validate or transform the data among different applications the meta data needs to be shared by the involved applications. This brings up a problem of how to share artifacts.

The present disclosure provides for a method apparatus and computer readable medium of remotely managing and loading artifacts. In one aspect a method for managing artifacts involves monitoring application installation events on a server and intercepting an application installation event when detected. Any artifacts found within the application are extracted and stored in a centralized location. The artifacts are indexed based on the target namespace. A service is provided for receiving queries to locate an artifact and returning the location of the requested artifact to the requestor.

In another aspect a method for remotely loading artifacts is disclosed. The method involves storing and indexing a plurality of artifacts in a central location. A query is received from a client to locate an artifact and the artifact is located within the central location. A reply is then returned to the client wherein the reply includes an address to the artifact. In one embodiment the method of remotely loading artifacts further involves artifacts are previously extracted from an application during the installation of the application.

It should be understood that the remote artifact loader can be implemented as one or more physical devices that are coupled to the CPU through a communication channel. Alternatively the remote artifact loader can be represented by one or more software applications or even a combination of software and hardware e.g. using application specific integrated circuits ASIC where the software is loaded from a storage medium e.g. a magnetic or optical drive or diskette and operated by the CPU in the memory of the computer. As such the remote artifact loader including associated data structures of the present invention can be stored on a computer readable medium e.g. RAM memory magnetic or optical drive or diskette and the like.

In one aspect the system is implemented within a communications network. The communications network includes connections such as wire wireless communication links or fiber optic cables. For example one or more systems as may be operably connected via a communications network. For exemplary purposes two computers or servers and are shown in . Servers and are on a network and able to communicate with each other. Servers and may be application servers which host one or more applications which operate thereon. Servers and may also provide other data and services such as boot files operating system images to clients or other servers within the communication network. As can be seen from server hosts Application A and Application B and server hosts Application C and Application D. Furthermore Applications A and B on server may communicate with Applications C and D on server .

Each of Applications A B C and D require Artifacts A B C and D respectively to run. However Applications A and B may also need to access or share Artifacts C and D.

In these examples an artifact is data needed by an application requesting the data to run or execute a process. This data may be for example a table a class a dynamic link library file a value or some other object. In one example the data may be meta data and in the case of XML the data may be XSD schema.

In one aspect the remote artifact loader comprises two distinct modules a remote artifact loader client module RAL client module and a remote artifact loader server module RAL server module . In general the RAL client module is responsible for formulating queries in response to requests for artifacts from applications and the RAL server module collects and hosts artifacts and responds to queries from the RAL client module. An RAL client module and an RAL server module are preferably installed on each of the application servers and . In one aspect the RAL server module manages artifacts within a system by extracting artifacts when an application is installed and storing the artifacts in a centralized location so that they can be accessed by applications. The RAL server module monitors the application server environment for any application installation events. When the artifact loader server module detects an application is to be installed the artifact loader server module searches the associated application files to locate any artifacts. Any artifacts found are extracted by the artifact loader server module and stored in a central location. In one embodiment the artifacts are indexed for example by target namespace application and type of artifact.

For example RAL server module which resides on application server is configured to constantly monitor any application installation events on application server . RAL server module detects the installation of Application A. RAL server module searches the application installation files for any artifacts associated with the Application A. In this example Artifact A is associated with Application A as is shown in . Artifact A is therefore extracted and stored in central location by RAL server module. illustrates Artifact A being stored in a central location . Similarly RAL server module detects the installation of Application B. RAL server module searches application installation files of Application B for any artifacts associated with the application. Any artifacts found within Application B are extracted by the RAL server module and stored in a central location. Artifacts associated with Applications A and B are now stored in a central location accessible by RAL server module. The artifacts are preferable indexed so that they may be easily located at a later time.

In one embodiment each RAL server module hosts artifacts local to its own environment. For example RAL server module hosts artifacts from server or Artifacts A and B. Similarly RAL server module hosts artifacts from Applications on server or Artifacts C and D. In other embodiments a single RAL server module may be configured to host artifacts from applications installed on more than one server.

The present disclosure allows for artifacts to be defined created and maintained in an application centric view. Artifacts are deployed with an individual application but are collected by a remote artifact loader service and stored in a central location where they may be accessed by a plurality of applications at a later time.

In another aspect the RAL server module further acts as the search engine for locating artifacts in response to requests for artifacts by applications. The RAL client module communicates with applications and queries the RAL server module in order to locate artifacts needed by the applications. In one embodiment the RAL client module communicates only with applications on the same application server. For example RAL client module communicates with applications A and B. Similarly RAL client module communicates with Applications C and D.

In one example RAL client module may receive a request from Application A for an artifact. In one embodiment RAL client module queries its own local RAL server module for the artifact associated with Application A. RAL server module returns the location of the Artifact A to the RAL client module which in turn returns a response to the Application A.

However an application may share an artifact from an application on another server. Therefore in another embodiment RAL client module queries a remote RAL server module for an artifact. Referring to assuming there are two application servers server and . In application server Application A is configured to use artifacts in Application C located on remote application server . Application C uses Artifact C which was previously extracted and now resides in a central location managed by RAL server module . Application A therefore sends a request to RAL client module . RAL client module then queries RAL server module which is running on application server . RAL server module will return the URL of Artifact C. Application A then loads Artifact C from the URL using http protocol. It may be noted that when a thread loads artifacts from different remote applications a new classloader is created in order to isolate conflict artifacts.

Example criteria found in a query include namespace application identifier and type. Namespace essentially defines the scope of a name or a symbol that potion of a program or collection of classes in which the name or symbol has meaning. Distinct namespaces protect variable and method names from conflicts which are also called name collusions. A type is data describing the types of data that may be present. A type may be for example XML schema complex type XML schema simple type and XML element type. A type also may be for example a file extension of MIME type. An application identifier such a the application name may be included as criteria in a query. For example the application requesting the artifact or the application from which the artifact is requested to be shared may be included in the query.

While the address or location of artifacts may most simply be represented as a URL any other form of address may be used. The address may take other forms such as memory address or a path depending on the particular environment and implementation.

Therefore queries for artifacts are handled by the RAL client module. If an artifact needs to be loaded from a remote application the RAL client module is responsible to locate the remote RAL server module and query RAL server module for the location of artifacts.

The remote artifact loader can be configured in a number of ways. Configuration is generally set at the application level. The configuration determines which RAL servers local or remote are queried and in what order.

In one embodiment a static configuration is utilized. In a static configuration the RAL client module automatically queries the local RAL server module first. If the artifact matching the namespace cannot be located by the local RAL server module the RAL client module may be configured to query a remote RAL server module.

For example consider Application is configured to load artifacts from Application . The following artifacts are present.

A query for an artifact matching target namespace tns would result in artifact C be returned since it is in local application and defines tns. A query for an artifact matching target namespace tns will return d.xsd since it is in local application and defines tns.

However a query for an artifact matching target namespace tns will return f.xsd because there is no artifact defines tns locally. It should furthermore be noted that in this example Artifact e.xsd will not be used since its target namespace is already defined by a local artifact c.xsd.

In another embodiment the RAL client module may be configured in a dynamic configuration. In a dynamic configuration the scoping works in an opposite manner to that of the static RAL client configuration. After a RAL client is created dynamically the remote RAL server module will be searched first for artifacts and if the remote RAL server module does not define an artifact with the namespace that is being queried the local RAL server module will be queried.

In the case of a dynamically created RAL client a new classloader is created. The current thread s context classloader will be set as the parent classloader of this newly created classloader. The new classloader will be set to the thread s context classloader. This new classloader will be removed only when it is being unset. At unset the thread s original context classloader will be restored.

The reason for creating a new classloader for each dynamically created RAL client module is for data isolation. For example assuming a RAL client module is created dynamically. A new classloader is created and associated with this new RAL client module that points to remote app.ear. Assuming app.ear has an utility.jar that contains c.xsd and c.xsd defines tns the following query will receive the address to artifact c.xsd in return 

Now a user calls unset api to cleanup the remote AL after that he she created a new dynamic RAL client module. A new classloader is created and associated with this new RAL client module that points to remote app.ear. Assuming app.ear has a utility.jar that contains an artifact e.xsd and e.xsd defines tns the following query will receive the address to artifact e.xsd in return 

The above scenario is perfectly fine since this design covers data isolation. Artifact c.xsd is only visible to dynamic classloader and artifact e.xsd is visible only to dynamic classloader .

The remote artifact loader configuration can be set through following several options. In one embodiment the configuration can be set completely through administration such as through an administrative console. The RAL is transparent to the application.

In another embodiment configuration can also be set programmatically. In this option internal components can use a programming model to dynamically create one or multiple RAL configurations. In yet another embodiment the configuration may be set programmatically by creating a configuration template. For example the RAL client can be configured programmatically to load artifacts from multiple remote applications

An RAL server module is configured to monitor application installation events within a specific environment such as an application server. Once an application installation event is detected installation is intercepted as shown at block . The application to be installed is searched and analyzed for any artifacts present. Any artifacts associated with the application are extracted as is indicated at block . The RAL then stores the extracted artifacts in a central location as shown at block so that they may be accessed at a later time by the application or any other requesting applications. The artifacts are preferably indexed at block . The RAL server module finally hosts the artifacts as indicated at block by accepting queries for artifacts from requesting applications locating artifacts and responding with the appropriate address indicating the location of the artifact.

The RAL server module first stores a plurality of artifacts in a central location as indicated at block . The central location may be a database a directory structure etc. The RAL server module preferably indexes the artifacts so that they may be easily located by requesting applications. In one embodiment each artifact is at least indexed according to target namespace. Artifacts may also be indexed according to other criteria such as application and data type. Indexing artifacts is indicated at block . As shown at block the RAL server module accepts a query for an artifact from an RAL client module. In response to such a query the RAL server module searches the central location where artifacts are stored for a matching artifact. The query for example contains criteria such as target namespace or requesting or target application. Once a matching artifact is located the RAL server module returns the address of the artifact to the RAL client module as indicated at block . In one embodiment the address is simply a URL.

At block the RAL client module receives a request from an application for an artifact. Depending on the configuration the RAL client proceeds to query an RAL server module. The RAL server module may be on the local machine or on a remote machine. In on aspect a local RAL server is queried first. If there is no artifact matching the requested target namespace a secondary remote RAL server may be queried. Alternatively in another aspect a remote RAL server is queried first and the local RAL server module is only queried if there is no artifact matching the target namespace on the remote RAL server. Once the RAL server module locates the matching artifact it sends a response to the requesting RAL client module as indicated at block . Finally the RAL client module forwards the address or URL of the artifact to the requesting application as shown at block .

Remote Artifact Loader provides a mechanism for remotely loading artifacts such as XSD files. Without this feature it is very difficult to run a remote client against a server providing web services. After a new application is deployed the artifacts such as XML schemas have to be exported and physically copied to the remote client machine. This procedure is complex and error prone. When the application s artifacts get updated the remote client also needs to be updated with the same artifacts.

There are several advantages to the remote artifact loader of the present disclosure. First artifacts are collected and indexed from applications automatically. Second the query application programming interface API is decoupled from whether artifacts are local or remote. Using a simple protocol such as Hypertext Transfer Protocol HTTP to host remote artifacts resolves several previous issues.

Finally the remote artifact loader allows any application to load artifacts from any other application no matter where they are.

The remote artifact loader of the present application makes version control easy. Artifacts are still defined and maintained by the original application. As long as the original application updates its artifacts all the other applications that share those artifacts will be updated automatically.

The remote artifact loader furthermore makes implementing dynamicity easier. Administrative or generic applications that receive instance data from other applications no longer need to copy those artifacts. Even if a new application is added as long as an administrative or generic application knows which application the instance data came from it can load artifacts from the new application.

The remote artifact loader of the present disclosure defines a proper data isolation solution where conflicting artifacts in different applications can be used.

The remote artifact loader in accordance with the present disclosure also addresses performance issues with prior art methods which involved passing artifacts with instance data.

Thus the present disclosure provides a method apparatus and computer usable code for remotely managing and locating artifacts. This is a generic solution for remote artifact loading not specific for a particular artifact not specific for XSD schema . The method and apparatus can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the remote artifact loader is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the remote artifact loader can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

While the apparatus and method have been described in terms of what are presently considered to be the most practical and preferred embodiments it is to be understood that the disclosure need not be limited to the disclosed embodiments. It is intended to cover various modifications and similar arrangements included within the spirit and scope of the claims the scope of which should be accorded the broadest interpretation so as to encompass all such modifications and similar structures. The present disclosure includes any and all embodiments of the following claims.

