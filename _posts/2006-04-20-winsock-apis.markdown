---

title: Winsock APIs
abstract: To improve upon existing Winsock implementations, the claimed system and method adapts an existing Winsock system to use out-of-process NSP services. The claimed method and system provides asynchronous Winsock Next calls to provide client application processing flexibility. Further, the claimed method and system provides additional structures for passing additional NSP specific information for a result set to enable further client functionality. One embodiment of the claimed system provides additional client Winsock API functions to aggregate and manage asynchronous calls to multiple NSPs and/or multiple namespaces.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07770188&OS=07770188&RS=07770188
owner: Microsoft Corporation
number: 07770188
owner_city: Redmond
owner_country: US
publication_date: 20060420
---
Operating systems may manage name space providers NSPs for a client application. Windows Sockets in Microsoft Windows may be an example. Name space providers may provide an interface for interacting with a particular name space such as a domain name system DNS . Existing Winsock systems may require that third party name space providers provide an in process component to interact with a Winsock component such as a Winsock dynamic link library DLL . This in process dependency may present problems during runtime when third party components fail. For example a failure of a third party component may cause a name service process and an associated client application to fail along with it.

Additionally existing Winsock systems may not provide an efficient and client friendly process for querying multiple NSPs and or multiple namespaces for resolving a name space query. For example an existing Winsock implementation may require a client application to manage a sequence of Begin Next End calls which while providing a basic and universal method of NSP access does not make client application programming efficient for querying multiple providers or name spaces. Also existing Winsock systems may require synchronous communication with an NSP which further hinders a client application from managing a plurality of NSP queries as well as limiting the client application s own processing capacity by requiring it to wait for Winsock calls to complete before performing any other processes.

Further existing Winsock implementations may not provide an extensibility mechanism for NSPs to use. Thus for example when an NSP has additional information that it may provide but may not be anticipated in an existing Winsock specification existing Winsock implementations may not be able to propagate the information to a client application. This information may enable a client application to implement further functionality.

Still further existing systems may only enable name resolution functions which e.g. allow for resolving name space queries but do not allow for publication.

The claimed method and system enables an existing Winsock system to handle out of process name space provider components. The claimed method and system also provides a set of asynchronous name space functions which may enable a client application to perform other processing during a name space query. The claimed method and system also provides an extensibility mechanism for communicating name space provider specific information and a client application programming interface that enables multiple NSPs multiple name space queries and publication.

Although the following text sets forth a detailed description of numerous different embodiments it should be understood that the legal scope of the description is defined by the words of the claims set forth at the end of this patent. The detailed description is to be construed as exemplary only and does not describe every possible embodiment since describing every possible embodiment would be impractical if not impossible. Numerous alternative embodiments could be implemented using either current technology or technology developed after the filing date of this patent which would still fall within the scope of the claims.

It should also be understood that unless a term is expressly defined in this patent using the sentence As used herein the term        is hereby defined to mean . . . or a similar sentence there is no intent to limit the meaning of that term either expressly or by implication beyond its plain or ordinary meaning and such term should not be interpreted to be limited in scope based on any statement made in any section of this patent other than the language of the claims . To the extent that any term recited in the claims at the end of this patent is referred to in this patent in a manner consistent with a single meaning that is done for sake of clarity only so as to not confuse the reader and it is not intended that such claim term be limited by implication or otherwise to that single meaning. Finally unless a claim element is defined by reciting the word means and a function without the recital of any structure it is not intended that the scope of any claim element be interpreted based on the application of 35 U.S.C. 112 sixth paragraph.

The blocks of the claimed method and apparatus are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the methods or apparatus of the claims include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The blocks of the claimed method and apparatus may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The methods and apparatus may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the blocks of the claimed method and apparatus includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture USA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media may be any available media that may be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which may be used to store the desired information and which may accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that may be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components may either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not illustrated may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interfaces and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It should be noted that the network connections illustrated are exemplary and other means of establishing a communications link between the computers may be used.

A name space may refer to a capability to associate at a minimum a protocol addressing attribute s or object s of a network service with one or more stable names. A stable name may be a name that remains constant even if its addressing attributes may change. A stable name may represent a human friendly name. Many name spaces are currently in wide use including Domain Name System DNS the Peer Name Resolution Protocol PNRP the bindery and NetWare Directory Services NDS NIS X.500 SAP etc.

These name spaces may vary in how they are organized and implemented. For example the Domain Name System DNS namespace is a tree of domains where host names and IP addresses are contained. Name resolution allows computers to use the DNS namespace to resolve host names to IP addresses and IP addresses to host names. Similarly a directory namespace is a defined area where a network name directory element can be resolved into an object regardless of where it resides within the namespace. In the case of Active Directory the namespace may be a forest and Active Directory provides name resolution services. A directory service may store information about resources on a network including resolution information and may make the information accessible to users and applications. The directory may be a physical database where information about the network may be stored.

A namespace provider NSP may provide an interface s to interact with a namespace which may be performed for example through the directory service. The NSP may be a third party component.

Winsock may be a component of an operating system that manages name service providers NSPs for a client application. illustrates an architecture diagram for a general Winsock system . An application may request resolution of a name or may request registration of a name in a specific name space. The application may access a Winsock component via a Winsock application programming interface API . The Winsock component may be connected to at least one name space provider NSP via a name space service provider interface SPI respectively. The NSP may in turn connect with a namespace . A name space provider may be a locally resident piece of software that knows how to map between a WinSock name space SPI and some existing name space which could be implemented locally or be accessed via the network . The Winsock component may provide a number of different connection and query management functions for an application to interact with an NSP s . An NSP may enable communication with a single name space or a plurality of name spaces .

Existing Winsock systems may implement the NSP component as a dynamic link library DLL illustrated as part of the in process components of the system using dashed line . Using an NSP DLL requires an application to import the DLL at runtime. This may be referred to as an in process service. An application that needs to obtain name resolution may be required to import the NSP DLL at runtime along with the Winsock DLL . When a component is run as an in process implementation the client application may be inextricably tied to its in process parts. Because some existing Winsock implementations use in process NSP components NSP bugs or errors may cause failures to a Winsock system and its associated client application. For example during a name space resolution call by a client application if a third party NSP provides faulty code a failure at the NSP component may cause a failure to the client application . Furthermore a service provider is granted access to all of an applications data in this model preventing any security separation between application and NSP.

The out of process NSP may use the LRPC to service client requests. Each provider may create an RPC endpoint using the LRPC protocol or ncalrpc where the string endpoint parameter may be a string representation of the name space provider s GUID the GUID under which the namespace provider was installed in a Winsock catalog . This mechanism may enable multiple namespace providers for the same namespace. While this embodiment illustrates the use of LRPC as an LPC implementation it should be noted that COM and other LPC systems may also be used.

In one embodiment registration information may be maintained per logged on user. In this case the namespace provider may create multiple LRPC endpoints or multiple instances of the provider may exist in different user contexts. There may be the general LRPC endpoint which consists of an NSP GUID and or an LRPC endpoint for each user on the system as there may be multiple users logged on with fast user switching . The format for the LRPC endpoints for each user may be  . However other formats may be available. In one embodiment a stable function may be used to map uniquely map an NSP GUID and user SID to an endpoint identifier. The stable function may have additional inputs such as a user session where one user might be logged into a system multiple times.

When an application makes a query Winsock may first attempt to connect to the user specific LRPC endpoint. If the LRPC connection to the user specific endpoint fails Winsock may then by default connect to a general LRPC endpoint e.g. the NSP GUID only .

An embodiment of the out of process system may implement the general startup process illustrated in . When an application sends a request for an NSP a first check may be to determine whether the RPC endpoint for the given provider already exists . If the check succeeds then the existing endpoint may be used to communicate with the NSP . If the check fails then another check may determine if the NSP entry specifies sufficient information to initialize the provider process. For example if the entry specifies a Windows service name that service may be started by the Winsock API . If no service is specified and the provider file name is an executable then the executable may be started .

It may be desirable to stop the name service process after a period of inactivity. For some namespace providers NSP queries may only occur when certain applications are started. When these applications exit the service may need to be stopped as well since there may be a long period of inactivity until another query is made. Other NSPs such as DNS may be so frequently called that those NSPs may not need to be stopped as often. A namespace provider may determine its own instantiation and termination period to increase efficiency.

Existing Winsock implementations using an in process NSP may only provide synchronous function calls which are functions that may tie up an application process until a return result may be obtained from a function call thereby halting or blocking the application process. Each of the existing namespace functions may block for some period of time. When a query is initiated a handle may be returned to describe the particular initiated query session. After obtaining a handle a Next call may be initiated. Because a Next call may involve a significant amount of time a synchronous Next call may inefficiently halt a client processing thread. This may mean that an application must await a response from the Winsock function before it may proceed to process other instructions. This may greatly delay response times for the application.

The Begin and End functions may not need to be modified because their duration of operation may be short. A Begin function may simply create a query session state save the query parameters and return a query session handle which may be associated with a call back function without performing any operation that may block. Similarly WSALookupServiceEnd may clean up any state without performing any operation that may block. The WSALookupServiceNext function may be modified as illustrated in . The Next function may be modified to use additional parameters called Overlapped and or a callback function e.g. an asynchronous procedure call or APC called a Completion Routine. It should be noted that Winsock and an out of process NSP may still support synchronous or blocking type calls in addition to the new functionality provided in the claimed embodiment thereby providing backward compatibility. 

An existing WSALookUpServiceNext Next may be extended using the following definition called WSALookUpServiceNextEx where the Ex suffix may designate a function extension where the additional parameters Overlapped and Completion Routine are italicized 

The Error parameter may indicate an error code if the callback fails. The Bytes parameter may indicate the number of byes returned. The Overlapped parameter may indicate an asynchronous context and refer to an associated Overlapped object. The Overlapped object may be a standard asynchronous overlapped structure that contains a pointer to a system event that may be triggered upon completion of an asynchronous call.

Because the query handles returned by the provider to describe a given query may not be true operating system handles the query handles may not be associable with an input output IO completion port. Instead Winsock may be modified to provide a method of associating a completion port handle with a client query session.

The Lookup parameter may be a handle returned from a Begin function when setting up a query. The Iocp parameter may be a IO completion port handle. The context parameter may be a blob context representing a third party specific extension to be discussed further below .

WSASetService may be a function that registers or removes from a registry a service instance within one or more name spaces. WSASetService may be used to affect a specific name space provider all providers associated with a specific name space or all providers across all name spaces. In one embodiment the following modified definition for WSASetService called WSASetServiceEx may be used to register an NSP Additional parameters may be illustrated by the italicized portions of the function 

The Overlapped and Completion Routine are described previously. The SetHandle parameter may be a handle returned that references the set operation. A handle may be returned only if the WSASetServiceEx function is called asynchronously. The handle may be used in WSACancelNameSpaceCall to cancel pending asynchronous operation.

After an operation has completed either successfully or by calling a cancel routine an additional WSASetServiceEnd function may be required to be called to free associated resources. WSASetServiceEnd may be defined as follows 

This routine may use a SetHandle returned from a previous call to WSASetServiceEx to free resources associated with the set operation. This routine may required to be called after an asynchronous WSASetServiceEx call completes.

In existing Winsock NSP systems only a single function may require multiple steps i.e. WSALookupServiceBegin Next End . In the claimed asynchronous system several functions may require a cleanup or end operation. In order to limit copying code a common end routine called WSANameSpaceCallEnd may be implemented by other Winsock functions as needed to perform the clean up operation 

Using a common end function provide function name consistency. For example WSASetServiceEnd may be called to end a WSASetServiceEx call. This end routine may invoke the common routine WSANameSpaceCallEnd. By keeping the names similar developers may be more likely to call the function correctly. Other multi step functions like GetAddrInfoEx and SetAddrInfoEx to be discussed below may have similarly named end functions for consistency as well.

A WSACancelNameSpaceCall function may initiate a cancel of a previously posted asynchronous WSALookupServiceNextEx call. The calling application may still need to wait for completion notification before freeing the resources associated with the canceled asynchronous call. A WSACancelNameSpaceCall function may be as follows 

Because a single call to a Winsock WSALookupServiceNext call may actually result in multiple calls to different NSPs Winsock may not be able to use the application s asynchronous structures e.g. WSAOVERLAPPED and Completion Routine in the RPC call since a single NSP may return WSAENOMORE and Winsock may drop the overlap and completion routine when it queries the next NSP in the same application call. If this were not the case when the first NSP indicated no more data the application s call may complete itself and Winsock could not continue the query to other NSPs.

In a case where an application makes an asynchronous overlapped call with a non zero timeout the worker thread may wait on a result as long as the smallest timeout value of all outstanding operations. In the event the application posts another operation with a shorter timeout Winsock may post an event to the completion port to adjust its minimum timeout value e.g. the minimum timeout value may be adjusted up to the most current operation time out value . A completion port may offer better scalability than overlapped events or asynchronous procedure calls APCs such as Completion Routine.

One change to an existing Winsock DLL may be to export NSP extension functions to an out of process component such as an executable.

A second change may be to adapt a Winsock DLL to maintain some state information for queries that associate a completion port handle on a query . Because the query handle returned from any given NSP may not be unique Winsock DLL may be required to generate a unique query handle that maps to an NSP returned query handle and an optional completion port. In this case Winsock DLL may use the following structure 

This structure may contain the query handle returned from the NSP along with an associated IOCP handle. The address of this structure may then be returned to the application as a usable query handle. In this manner when the application passes in the query handle Winsock DLL may have the necessary context information to make and complete the call.

A third change may be to enable a Winsock DLL to determine whether the NSP to be called is an out of process server that may have to make an RPC call instead of calling a function pointer directly as with an in process DLL function . Additionally if the RPC call fails because the service has not yet been started the Winsock may be required to first start the service and make the call again.

Existing Winsock systems may not provide an extensibility mechanism for NSP specific information. NSP specific information may be used to enable additional functionality within a client application. In one embodiment of the claims modifications may be made to Winsock functions to propagate blob data which may represent additional information associated with a query result that is provided by an NSP. Blob data may be provided by an NSP for a particular namespace where additional filtering of the results may be desired by the client but requires additional information specific to the NSP and which may not normally be provided by the regular query mechanism.

An example of blob data may be information regarding the authority of an NSP over a name space and hence over a result set for the namespace. An NSP may be authoritative or non authoritative for a result set. An authoritative NSP for a namespace may mean that the NSP may provide a level of certainty or guarantee that the resolution results provided by the NSP are accurate. A non authoritative NSP may not provide the guarantee. A non authoritative NSP may be one that derives its result set from other indirect sources to a namespace.

Authoritative and non authoritative result sets may be processed differently by a client application once the application is provided with this NSP specific information. Thus the claimed embodiment provides a client the opportunity to handle resolutions differently based on whether they are from an authoritative or non authoritative NSP. Furthermore because the NSP may provide resolution for more than one namespace the NSP may have different authority depending on the namespace. For example an NSP that manages two names spaces may be authoritative for the first namespace and non authoritative for the second name space.

An example of a name space that may have authoritative and non authoritative resolutions is the email name space. Because the email name space may be segmented into separate domains their may be several name space providers providing duplicate or conflicting name resolutions. Depending on the association of an NSP to a name service directory the NSP may be authoritative or non authoritative for a domain. For example multiple providers may use email names as identifiers for their namespaces although they do not own the domain name in the DNS infrastructure for that part of the namespace. A first user may own the domain barneyrubble.net and Microsoft Passport and thus MSN Messenger may let the first user register a messenger name barneyrubble barneyrubble.net. However Microsoft Passport may not monitor the name after it is registered. Thus even if the domain barneyrubble.net is sold to another person the user may still use barneyrubble barneyrubble.net in MSN messenger. Thus MSN Messenger may by non authoritative for the barneyrubble.net domain. Conversely because Microsoft may own a domain such as hotmail.com and may be authoritative for all email names hotmail.com.

An NSP that is authoritative for a domain or a namespace may provide a guarantee or level of certainty that its results may trump any conflicting name resolution result. Thus blob data may be used to help structure a request to an NSP or tag results from an NSP such that a client application may accordingly filter a result. Other NSP extension information may be supplied by the blob data.

Registry entries may be managed using modified Winsock functions. Optional provider specific blob data may be saved in the registry location with the rest of the NSP information. In order to implement the additional blob data a new registry key may be defined for example by adding a ProviderInfo key.

The following embodiment of a Winsock function may be used for installing an NSP with a provider specific blob shown in italics 

The Identifier parameter may identify the NSP and the PathName may provide the location of the NSP component. The name space parameter may be used to designate the type of name space for example a DNS name space may be designated using a parameter value of NS DNS. The Version parameter may designate whether an NSP service component is in process or out of process. The Version parameter may indicate whether the NSP is a DLL or an executable. In one embodiment backward compatibility may be enabled by using this parameter. The provider ID may be a designated GUID of the namespace. The blob parameter may provide third party NSP component specific data. The blob data may enable an NSP third party to register NSP specific or name space specific values to be used in communicating with the NSP component. In an embodiment the WSAInstallNameSpaceEx may insert into a client system registry a listing of available NSPs and corresponding blob data specifying parameter and or parameter value options when sending queries to the namespace. Thus the blob parameter may provide extensibility in the NSP dialogue and interaction with Winsock. As discussed above an example of blob data may be an indication of which name space the NSP may be authoritative for.

Because additional information may be associated with a provider entry an updated namespace structure WSANAMESPACE INFOEX may be created to contain an additional blob parameter accommodate the provider blob data shown in italics 

The general Winsock function WSAEnumNameSpaceProvidersEx may then be used with the new WSANAMESPACE INFOEX structure to enumerate all providers along with their associated provider specific blob data 

In an asynchronous out of process embodiment a name space provider NSP may be required to implement a service provider interface that includes a set of interface functions. In an embodiment requiring backward compatibility an NSP may be required to continue to support previous existing interface functionality along with the functionality enabled by the claimed system. As previously discussed the Winsock functions may be modified for an RPC implementation. Accordingly some NSP functions may need to be modified as well. The following may be function definitions that a namespace provider may be required to implement as illustrated in where italicized parameters may be modifications according to an embodiment of the system it should be noted that the function names listed below may be modified slightly to differentiate them from previous function versions. For example the NSPStartup below may be named NSPV2Startup to represent a newer function definition 

In order to implement an RPC process each of the NSP calls listed above may be required to implement a hBinding handle as a reference handle for an RPC call. hBinding may be a handle containing information that the RPC run time library may need to access binding information. The lpClientContext parameter of the NSPStartup and NSPCleanUP functions may be a new RPC context handle returned by the RPC server. This handle may be important if the client process exits unexpectedly. In this event the handle may be used to call an RPC rundown routine to direct the RPC server to clean up any context associated with the client.

The pAsyncState parameter used in NSP Next End and SetService functions is used to pass a binding handle on an asynchronous remote procedure call. This handle may be passed when the Winsock Next call is asynchronous.

A namespace provider may simply need to compile against a public IDL file which contains the RPC interface definition and then provide an implementation of each function within the interface.

NSP providers may return RPC style error codes which may be translated caught by the Winsock infrastructure and set with WSASetLastError to enable a calling application to retrieve the error code.

In an alternative embodiment the SPI may be modified to be an in process component in which case RPC details may be shielded from the NSP. In this manner there may be no need for to modify existing NSP functions.

The claimed out of process NSP asynchronous Winsock system may be further modified at the client application programming interface API level to provide a client application new functionality. An extension of the GetAddrInfo function called GetAddrInfoEx may initiate a series of WSALookUpServiceBegin WSALookUpServiceNext and WSALookUpServiceEnd sequence calls of the Winsock service to perform multiple name resolution queries on a single NSP as well as multiple name resolution queries over a plurality of NSPs. This function may be used to query for an address in a namespace and aggregate query results returned from one or more NSP components. In one embodiment an NSP identifier parameter e.g. NS DNS NS ALL etc. a namespace parameter an overlapped parameter and or a completion routine parameter may be used to enable further client functionality.

Optional flags that may be passed to the underlying query e.g. flags defined for WSALookupServiceBegin may be designated using dwFlags. Additionally a new flag called LUP NON AUTHORITATIVE may be used to indicate to the NSP s that all addresses including those from a non authoritative source may be returned. In one embedment any addresses returned from the NSP which are not marked as authoritative may not be aggregated into the data returned to the application. Similarly a flag such as LUP SECURE may be specified to restrict the results to secure registrations.

An optional namespace identifier such as NS DNS NS ALL etc. may be designated using dwNameSpace. Specifying NS ALL may result in all installed and active namespaces being queried. Passing a specific namespace ID may result in only that namespace being queried.

An optional GUID of a specific NSP to query in the event there are multiple providers registered under a single namespace number may be designated by lpNSPId.

Hints may be an optional addrinfo structure which is also used to pass additional flags to further clarify the name resolution request. Additional ai flags values may be defined that may correspond to flags to be passed to the underlying WSALookupServiceBegin call. For example If the AI NON AUTHORITATIVE is passed as a hint in the ai flags then the query may include non authoritative responses.

A linked list of addrinfoex structures that may be returned upon successful completion of a call may be designated using IpResults. The addrinfoex structure may be used in this function for consistency since a base GetAddrInfo function may use it. The addrinfoex structure may also provide a way of returning canonical names socket type and protocol information. Also the ai flags field for each address may contain a new flag AI NON AUTHORITATIVE if the address indicates that it comes from a non authoritative name provider. In one embodiment if the application passes LUP NON AUTHORITATIVE then no non authoritative results may be returned. It may be necessary to set this flag on each address returned because a single call to GetAddrInfoEx may result in multiple resolution requests from one or more providers and the entire set of addresses may then contain both authoritative and non authoritative addresses.

The timeout parameter may be an optional parameter specifying how long to wait for a result from the NSP. Passing NULL may direct a Winsock function to wait until the call completes. An asynchronous call using an overlapped structure may use a timeout parameter. For example if the timeout occurs before the overlapped call may be completed the call may be canceled and completed with an error WSAETIMEOUT . The timeout parameter may be a struct timeval structure that may contain a seconds and a microseconds field.

The lpOverlapped parameter may be an optional WSAOVERLAPPED context structure required when making an asynchronous call as described previously .

The lpCompletionRoutine parameter may be an optional function which when called asynchronously may be invoked upon successful completion of the call as described previously .

The lpNameHandle parameter may be used only for asynchronous calls and may be required to be present if making an asynchronous call . GetAddrInfo may returns this handle value that describes an operation posted. When the operation completes the application may be required to call AddrInfoEnd to free associated resources. While the call is pending an application may cancel the call by using AddrInfoCancel.

In asynchronous embodiment additional processing may be implemented. A check to determine if a call is asynchronous may be made . If it is not asynchronous then the synchronous processing and may be used. If it is synchronous then an Overlapped and or Completion Routine may be passed in to the Begin Next End calls. Additionally the Next call may use the NextEx call as described above. After the NextEx call completes a notification event may be initiated before the Winsock call End. The Notify event may invoke a system event that may be defined by the Overlapped structure or an asynchronous procedure call APC to the Completion Routine.

The data returned from GetAddrInfoEx may be returned in an ADDRINFOEX structure. This structure contains extra information relevant to the information returned. As GetAddrInfoEx may aggregate information returned form multiple calls to an NSP as well as multiple NSPs themselves extra information may be passed back so that the application does not need to perform the low level query WSALookupServiceBegin Next End itself.

The extra fields may be the blob data parameters ai blob and ai bloblength and the provider ID. The blob data may be used to return provider specific information that may be associated with the name beyond just a list of addresses. The provider ID may be a GUID of the namespace which may have provided the result. This may be used by the application to prefer one set of results over another. Additionally two query flags used by WSALookupServiceBegin Next End LUP NON AUTHORITATIVE and LUP SECURE may be propagated in the ADDRINFOEX structure in the ai flags field upon return. If these flags are set in the results returned by the NSP GetAddrInfoEx may set these values in the ADDRINFOEX structure associated with the returned addresses. For consistency these flags may be mapped to AI NON AUTHORITATIVE and AI SECURE but have the same underlying defined value .

In addition to authoritative and non authoritative NSPs for a name space an NSP may provide a secure versus non secure result. This may be implemented to distinguish namespaces that provide a security mechanism to prevent tampering with namespace mappings versus namespaces that do not provide a security mechanism. An example of a secure name space may be peer name resolution protocol PNRP which may require a security mechanism for each resource member node on the name service.

Additionally a setAddrInfoEx function may be used to register a name and address with a name space. This may be used if the NSP and or name space allows for this functionality. Some name spaces may only allow insertion through a secure mechanism not provided by Winsock. In an embodiment the following definition may be used for setAddrInfoEx 

An array of addresses to be associated with pName may be designated by pAddresses. SetAddrInfoEx may use SOCKET ADDRESS structures over addrinfo structures for ease of use and simplicity. Requiring an application to allocate a linked list of addrinfo structures which then may contain pointers to address structures may be cumbersome and may require writing macros to manipulate the structures similar to the WSACMSG macros for WSASendMsg and WSARecvMsg . Additionally the many flags and fields of the addrinfo structure may be unused for registration and may require extra parameter validation complexity if some of them were used. Any additional information that the provider may need may be passed as a part of the blob data parameter in a provider defined structure instead of Winsock imposing a particular structure which may or may not fit the needs of the provider .

It should be noted that while SetAddrInfoEx may use SOCKET ADDRESS structures if future name space implementations require an association of socket type or protocol with an address the API specification may be modified to include this information.

The dwAddressCount parameter may be the number of addresses in the array. If the address count is zero the service name may be deregistered from the given namespace s .

The dwNameSpace parameter may be an optional namespace number to register information with e.g. NS DNS .

The lpNspId parameter may be an optional GUID of a specific namespace query in the event there are multiple providers registered under a single namespace number .

The timeout parameter may be an optional parameter specifying how long to wait for a result from the NSP.

Preferred names may be the notion that a given user has several identities which can be used to describe him or herself. In this instance an application may want to query the available NSPs for available names not addresses. In this case an extra flag may be created and passed to the WSALookupServiceBegin call which may define a query as a preferred name lookup.

When an application invokes a query with LUP RETURN PREFERRED NAMES those NSPs queries which may not support this type of query may simply return an appropriate error WSAEOPNOTSUPP . Those that may support the query may return a list of preferred names in a predefined blob structure for example 

The lpPreferredNameList may be a series of NULL terminated strings with the entire list being NULL terminated as well i.e. each string is NULL terminated and the last string in the list has two consecutive NULL characters .

