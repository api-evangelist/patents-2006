---

title: Delivering callbacks into secure application areas
abstract: A native callback function is registered with a calling component in a native code environment, wherein registering the native callback function is initiated from a secure application area in a managed code environment. A callback is delivered from the native callback function into the secure application area.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07962922&OS=07962922&RS=07962922
owner: Microsoft Corporation
number: 07962922
owner_city: Redmond
owner_country: US
publication_date: 20060828
---
Secure application areas are used to isolate applications running in a managed code environment. In some systems today in order to maintain the security of a secure application area the ability to directly call into the secure application area from anonymous threads in native code is prohibited. This security feature often conflicts with the callback model of native code to notify an application in a secure application area that a registered event has occurred.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

Embodiments of the invention provide for delivering callbacks into a managed code environment without directly calling into a secure application area. In one embodiment an operating system OS event object is shared between a managed code environment and a native code environment. When an event registered by managed code occurs the native callback function places callback data in a data region and sets the OS event object. The OS event object signals the managed code environment that the registered event has occurred. The managed code environment may then retrieve the callback data from the data region.

Many of the attendant features will be more readily appreciated as the same becomes better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present examples may be constructed or utilized. The description sets forth the functions of the examples and the sequence of steps for constructing and operating the examples. However the same or equivalent functions and sequences may be accomplished by different examples.

Although not required embodiments of the invention will be described in the general context of computer readable instructions being executed by one or more computers or other computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects application programming interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

Additionally device may also have additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement embodiments of the invention may be stored in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

The term computer readable media may include communication media. Device may also include communication connection s that allow the device to communicate with other devices such as with other computing devices through network . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency infrared and other wireless media.

Device may also have input device s such as keyboard mouse pen voice input device touch input device laser range finder infra red cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a remote computer accessible via network may store computer readable instructions to implement one or more embodiments of the invention. Computing device may access remote computer and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at remote computer . Those skilled in the art will also realize that all or a portion of the computer readable instructions may be carried out by a dedicated circuit such as a Digital Signal Processor DSP programmable logic array and the like.

Turning to an embodiment of an environment for delivering callbacks into a secure application area from a native code environment is shown. Operating system OS includes native code environment and managed code environment . OS also includes services that may be accessed by managed code environment and or native code environment.

As used herein a callback includes a notification that an event registered for monitoring has occurred. The callback may or may not include associated callback data. In embodiments herein a callback is a communication from native code environment to managed code environment due to a previous event notification request from managed code environment .

While embodiments of the invention are described in connection with the Microsoft .NET Framework one skilled in the art will appreciate that embodiments herein may be implemented in other environments such as Java and the Java Virtual Machine JVM by Sun Microsystems Inc. As used herein the term managed code refers to any interpreted code for use in a runtime environment and is not limited to code executed in the Microsoft .NET Framework.

Managed code environment includes a runtime environment for compiling and executing intermediate code. In one embodiment managed code environment includes computer instructions executed by a Common Language Infrastructure CLI compliant virtual machine such as Microsoft s .NET Framework Common Language Runtime CLR component.

The Microsoft .NET Framework is a development and execution environment that allows different programming languages and libraries to work together to create applications. The .NET Framework includes a Common Language Runtime CLR component and Framework Class Libraries FCL . CLR serves as an execution environment for .NET applications. The FCL provide a collection of classes or types that may be used to build .NET applications. The .NET Framework supports various programming languages such as Visual C Visual Basic .NET and Visual J .NET. The source code is compiled into intermediate code called Microsoft Intermediate Language MSIL . The intermediate code is compiled by the CLR at runtime.

In managed code environment the intermediate language is compiled at runtime into native machine code. Managed code may be verified before actually executed to ensure the execution does not cause a system failure. Managed code environment may verify the reliability of managed code by inserting traps performing type safety performing array bounds and index checking and the like.

Managed code environment includes secure application area supporting an application . A secure application area is used to separate applications from one another so that the faults of one application do not affect the operations of another application. A single secure application area is shown in for clarity but it will be understood that managed code environment may include multiple secure application areas.

An embodiment of secure application area includes an application domain commonly referred to as an appdomain . In the .NET Framework an application domain may be used to provide isolation between applications. Several application domains may be run in a single process with the same level of isolation that would exist in separate processes. Also an individual application in an appdomain may be stopped without stopping the entire process.

Native code environment includes unmanaged machine code also referred to as native code. Native code is executed without the same controls as managed code in managed code environment . While typical OS management activities such as memory management occur with native code typically native code is loaded into memory and executed without the same control as in a managed code environment.

Turning to a flowchart shows an embodiment of delivering callbacks into a secure application area. Discussion of flowchart will make reference to . Embodiments of the invention are described for use with Event Tracing for Windows ETW however it will be understood that embodiments herein are not limited to use with ETW. ETW enables application programmers to instrument an application for event tracing for debugging and performance analysis. ETW allows users to start and stop event tracing sessions log user or kernel events and consume events from a file.

Starting in block an OS event object is created. In OS event object is shared between secure application area and native code environment . In managed code environment thread pool is used to wait on OS event object . In an alternative embodiment a static thread may be assigned to wait on OS event object .

In one embodiment OS event object is created using a CreateEvent Application Programming Interface API from Win32 APIs. The event is able to be returned across the secure application area boundary since the created event was created on a thread originating from secure application area . CreateEvent API returns a handle to the new event object. In one embodiment the CreateEvent API is called by application .

In one embodiment OS event object is a manual reset event object. When a manual reset event object is signaled the event object keeps signaling until manually told to reset. In another embodiment OS event object is an auto reset event object that is the auto reset event object automatically resets to a non signal state when a waiting thread responds to the signal.

Alternative embodiments of the invention may use other techniques to signal the managed code area for indirectly delivering a callback. For example secure application area may be signaled by writing data to a file monitored by secure application area . In another example a network packet may be sent for delivery to application .

Proceeding to block a data region is created. In one embodiment data region may be implemented as a memory region shared between managed code and native code. For example the managed code environment may allocate a piece of native memory area that may be used by managed code. In one embodiment this may be done through a memory allocation technique. The managed code and the native code agree on the data format and other relevant information of this shared memory region. For example in the .NET Framework the method Marshal.AllocHGlobal IntPtr may be used to allocate memory from a process s unmanaged memory. In another embodiment a portion of managed code environment memory may be allocated for data region .

In an alternative embodiment data region is not created through memory allocation as described in connection with block above but instead data region is part of native code memory resources for caching data associated with a callback. In this way the location formatting and the like of the callback data is managed by native code environment . Managed code environment may use a GetData API to retrieve the callback data from the native code environment memory resources described below .

Proceeding to block the OS event object is registered for callback. In one embodiment a RegisterEvent API is called by managed code environment to register the OS event object with the native code environment. In one embodiment the RegisterEvent API is called by application . In turn a native callback function in native code is registered with a calling component that needs to deliver a callback to managed code environment . In native callback function is registered with calling component .

In an ETW example native callback function may be registered with the ETW infrastructure that is the calling component . In this example the native callback function is called whenever a trace in application is to be changed from enabled to disabled or disabled to enabled. ETW wants to convey this change of state to application in secure application area . However since secure application area does not allow anonymous threads from native code to perform a callback into secure application area ETW may not perform the callback directly across the secure application area boundary. Instead ETW may signal the enabled disabled event using embodiments described herein.

It will be appreciated that blocks may be considered a setup phase. After block the logic of flowchart waits for the registered event to occur. When the registered event occurs as shown in block then the logic proceeds to the delivery phase described in blocks where the callback data if any is placed in data region OS event object is set and subsequently data in data region is read by managed code environment .

After the registered event occurs in block the native callback function is called as shown in block . In the embodiment of calling component calls the native callback function when the registered event has occurred. In an ETW implementation ETW notifies users when ETW is enabled or disabled. In this case whenever ETW changes between enabled and disabled i.e. tracing on or off this change causes a call to the native callback function from ETW.

Continuing to block data associated with the callback is placed in the data region. In some embodiments no data is associated with the callback so data is not placed in the data region. For example in the case of ETW enabled disabled no data is cached in the data region because query functions are available in ETW to get any relevant trace data.

In one embodiment data region may be implemented as a queue to store data associated with multiple callbacks. When secure application area wants to access the data region it can track which data is associated with which callback using a generation identification discussed below in conjunction with .

In another embodiment some of or the entire data placed in data region may be encrypted. In this way the data is secured so that only authorized components in secure application area may read the data. In one implementation secure application area provides a public key to native callback function for encrypting the data when placed in data region . When the data is retrieved from data region secure application area may use a private key to decrypt the data.

After block the logic continues to block to set OS event object . Setting OS event object will cause a thread in thread pool waiting on the event to respond as shown in block . In native callback function sets OS event object which causes a managed thread in thread pool to respond to the signaling OS event object .

Continuing to block the data placed in the data region is retrieved for consumption by callback consumers of application . In one embodiment the managed thread retrieves the data from data region and makes the data available to callback consumers . In another embodiment callback consumers are aware of data region and callback consumers retrieve the data from data region when notified by the managed thread that the registered event has occurred.

In one embodiment the data may be retrieved from data region using a GetData API. In short GetData API pulls data from data region . With the GetData API the allocation and format of memory for data region is managed by native code environment . The GetData API returns the data or a pointer to the data to the caller such as callback consumers in secure application area .

Turning to a flowchart shows an embodiment of delivering callbacks into a secure application area. Discussion of flowchart will make reference to . It will be appreciated that some blocks of flowchart are similar to blocks of flowchart .

In the embodiment of flowchart logic is provided to track the number of times native callback function in native code environment has actually been called. Since OS event object is used to indirectly deliver the callback into managed code environment there may be a loss of information such as how many times native callback function was called. As described below logic of secure application area may use the number of times native callback function was called to determine how many data records in data region need processing.

In the logic proceeds through blocks as described above in connection with . After the native callback function is called in block the logic proceeds to block to update a data region generation identification ID . As shown in the embodiment of data region generation ID may be kept as part of data region . In one embodiment data region generation ID may be a counter that is incremented each time native callback function is called.

After block the flowchart continues through blocks as described in connection with . After block the logic proceeds to block to update a managed code generation identification that indicates how many times OS event object has been set. In managed code generation ID is updated by the managed thread from thread pool . In one embodiment managed code generation ID may be a counter that is incremented when OS event object is set.

Continuing to block the data in the data region is retrieved. Proceeding to block the data region generation ID is retrieved. In the embodiment of data region generation ID is retrieved from data region . In one embodiment the data region generation ID may be returned as part of the GetData API return.

Proceeding to block the managed code generation ID and the data region generation ID are compared. In decision block the logic determines if the IDs match. If the answer is yes then the logic ends. In this case all of the native callback function calls have been attended to by managed code environment . In other words each call to the native callback function has resulted in a corresponding signal from OS event object .

If the answer to decision block is no then one or more native callback function calls have been missed by secure application area . For example a call to native callback function may have occurred while OS event object was still signaling a previous call. In this case the logic proceeds to block to retrieve previous data from previous native callback function calls.

In an ETW example if the sequence of events is enabled disabled enabled then the managed code environment may miss the disabled event. The use of the Generation IDs allows managed code environment to recognize a missed signal from the native callback function and thus the missed disabled event. Managed code environment may then take action such as re reading configuration information to make up for the missed disabled event.

In one embodiment data region is implemented as a queue so that data previously placed in data region from previous callbacks may be retrieved. For example suppose the comparison of generation IDs indicates that two callbacks were missed by managed code then the managed code may walk down the queue to retrieve data from the previous two callbacks.

Embodiments of the invention provide methods for delivering callbacks into secure application areas of managed code from native code. For example in order to improve the security of managed code running inside Microsoft SQL Server the ability to directly call into application domains from anonymous threads is restricted. Embodiments described herein provide for the ability of callbacks to be delivered to the managed code environment without violating security policies of a secure application area such as an application domain. The managed code environment controls a one way communication with the native code environment. Calls may be made out of a secure application area to register events and to retrieve callback data but callback data is not pushed into the managed code environment.

Various operations of embodiments of the present invention are described herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment of the invention.

The above description of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the embodiments to the precise forms disclosed. While specific embodiments and examples of the invention are described herein for illustrative purposes various equivalent modifications are possible as those skilled in the relevant art will recognize in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification. Rather the following claims are to be construed in accordance with established doctrines of claim interpretation.

