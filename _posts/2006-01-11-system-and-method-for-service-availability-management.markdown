---

title: System and method for service availability management
abstract: A service framework uses importance ranking information in making call decisions and/or wait-time decisions in connection with service requests. Each of the service requests has an importance ranking which reflects the importance of the information provided by the service to a task being performed. The health of a service may be controlled by permitting fewer (or more) service requests to be made to the service when the service is less (or more) healthy. The likelihood of a service request being made to the service may depend on the importance ranking of the service request. When waiting for a response, a determination whether to continue waiting may be made based on the likelihood that the service has failed and based on the importance of the information to the task being performed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07904759&OS=07904759&RS=07904759
owner: Amazon Technologies, Inc.
number: 07904759
owner_city: Reno
owner_country: US
publication_date: 20060111
---
Data processing systems often comprise service frameworks in which program processes send service requests to services and the services subsequently reply with responses. For example a process may request certain data from a service and the service may respond with the requested data. In some situations program processes may make many service requests in parallel and wait for responses from each of multiple different services.

Various types of events may occur within a service framework that may lead to a degraded performance mode. A degraded performance mode may involve a situation in which a service is merely troubled a situation in which the service has failed or a situation in which some other problem exists. For example a service may become overloaded causing intermittent or slow responses may become completely inoperative may become unreachable due to network problems and so on. In the event of a failure mode the process may slow to a standstill as it continues to wait for the response from the service. Typically it may not be known whether the service has failed or whether it is merely slow in returning a response. At some point a decision needs to be made as to how long the process should wait for the response from the service.

Accordingly a problem that has been encountered in the context of service frameworks is to provide a mechanism for program processes to decide how long to wait for a response from a service in situations where the service may have entered a failure mode or other degraded performance mode. Also oftentimes services enter a failure mode as a result of becoming overloaded. Accordingly another problem that has been encountered is to provide a mechanism that avoids services becoming overloaded. It will be appreciated that while the teachings herein describe certain features and advantages that may be achieved the teachings herein may be used to implement systems and methods that do not necessarily have any of these features or advantages but rather have other features and advantages.

One embodiment of the invention relates to a data processing method for use in a service framework. The method comprises receiving first and second assessments of a service. The first assessment comprises an assessment of a relative state of health of the service and the second assessment comprises an assessment of a relative importance of the service to a task being performed. The method further comprises mediating access to the service according to the first and second assessments.

Another embodiment of the invention relates to a data processing method for use in a service framework. The method comprises sending a service request to a computer implemented service and waiting for a response from the service. A determination whether to continue waiting for the response is made based on the likelihood that the service has failed and based on the importance of the information to a task being performed.

Another embodiment of the invention relates to a data processing method for use in a service framework. The method comprises controlling the health of a service including monitoring the health of the service permitting fewer service requests to be made to the service when the service is less healthy and permitting more service requests to be made to the service when the service is more healthy. Each of the service requests has an importance ranking which reflects the importance of the information provided by the service to a task being performed. During the controlling step the service requests with a higher importance ranking are more likely to be made to the service and the service requests with a lower importance ranking are less likely to be made to the service.

Another embodiment of the invention relates to a data processing method for use in a service framework comprising a plurality of computer implemented services. The method comprises causing the services to operate at or near a maximum service request processing capacity of the services. The causing step includes controlling a flow of service requests to the services including for each service monitoring the health of the service permitting fewer service requests to be made to the service when the service is less healthy and permitting more service requests to be made to the service when the service is more healthy.

Referring to a data processing system is shown which includes a program process a plurality of services and a service availability manager . The process comprises program components which make service requests to the services . The services respond with responses such as responses containing requested data. As shown in program components may make many service requests to many services such that the process is waiting for many responses at the same time.

The data processing system maybe implemented in the context of a service framework in a distributed computing environment. Although only a single process and a small number of services are shown it will be appreciated that the system may comprise many program processes and services in addition to those shown. Herein to facilitate explanation the term process is used to refer to program logic that makes a service request and the term service is used to refer to program logic that responds to the service request. As will be appreciated however services may also make requests to other services as shown in . Accordingly program logic that is considered a service in some contexts may be considered a process in other contexts and vice versa.

The process and the services are in communication with the service availability manager . The service availability manager is configured to manage the interaction of the processes with the services including determining when processes should stop waiting for responses from services determining when service requests should not be sent to services e.g. because the service is in a degraded performance mode and otherwise managing situations in which one of the services has entered a degraded performance mode e.g. when a service becomes inoperative overloaded unreachable and so on all on a case by case basis.

Referring now to in an exemplary embodiment the service availability manager comprises call decision logic wait time decision logic and configuration information . The call decision logic is configured to determine whether a service request should be permitted to be made to a service based on the level of importance of the service request and based on the health of the service to whom the service request is directed. The wait time decision logic is configured to decide when a process should stop waiting for a response to be received from a service .

The configuration information is used to configure the call decision logic and the wait time decision logic . In an exemplary embodiment the call decision logic and the wait time decision logic may be configured differently e.g. different algorithms and or parameters thereof for each service and for each different program component within each different process that sends service requests to a particular service . For example when one program component sends a service request to a particular service the configuration information that is used may be different than when another program component sends a service request to the same service . The configuration information may also be configurable as a function of other parameters. For example if the same process is used in the context of different users e.g. different customers the configuration information may further be different for each different user. In another exemplary embodiment in the context of a process that is used to construct web pages for publication to visitors of a website the configuration information may be different for each different page of the website. The configuration information may also be dynamically determined e.g. based on visitor feedback based on system optimization algorithms and so on.

Referring now to the configuration information is shown in greater detail. The configuration information is shown to include importance ranking information call decision algorithm parameter information and wait time algorithm parameter information .

The importance ranking information represents how critical the service request is to the program component that is making the service request. The importance ranking information may be manually specified during creation maintenance of the program components may be system specified based on system optimization algorithms or may be determined in another manner.

Different service requests may have different levels of importance. For example some data may be considered optional in nature. That is the process may produce useful results without the optional data. Further data that is considered optional in some contexts may be considered critical in other contexts depending on the desired output that is desired to be produced in each case. For example in the context of the operation of a website such as an interactive commerce website information concerning a visitor to the website may be considered optional when displaying a welcome page to the visitor but may be considered critical when displaying a checkout page to be used in connection with taking an order from the visitor even though the same service request may be used for both. In the context of a welcome page if the welcome screen is to be displayed within a predetermined period of time it may be desirable to forego the optional data in order to permit the page to be displayed in time to meet the deadline. On the other hand in the context of the checkout page it may be desirable to continue waiting in order to obtain the information needed for the checkout page.

In an exemplary embodiment a binary ranking scheme is used to rank importance e.g. critical non critical . Thus if a particular piece of information is considered optional to the task being performed by a particular program component that information may be designated as non critical. In another exemplary embodiment a continuous ranking scheme may be used. For example the importance ranking may be assigned a value anywhere between zero and one so that there are an infinite number of options e.g. the importance ranking may be specified with a floating point value .

The importance ranking information provides an intuitive mechanism for specifying the value of the data provided by one service relative to the value of the data provided by other services in the context of a particular task being performed by a particular program component. In the context of a system in which multiple service requests may be made in parallel the parameter of interest in some instances may not be the amount of time a service request takes to complete but rather how long the framework should wait for its completion if the service is not responding. For example if the process is already waiting for more important information then it may be desirable for the process to continue waiting for less important information even though the service that is providing the less critical information is taking longer than expected. On the other hand if the process is only waiting for other optional information it may be desirable to stop waiting for the response in order to permit the process to complete its task in less time. Likewise if a deadline for completing a task is about to expire it may be desirable for the process to stop waiting for optional information so that it can produce its result prior to expiration of the deadline.

The call decision algorithm parameter information may be used to configure the call decision logic so that the call decision logic may be configured differently depending on which service is being called and depending on which program component is calling the service . The information may be used to specify the decision algorithm to be used by the call decision logic the parameters e.g. coefficients to be used by a generic call decision algorithm implemented by the call decision logic or a combination thereof e.g. a selection of one of a number of generic algorithms along with parameters for the selected algorithm . Thus the call decision logic may be customized for each different service request by a given program component .

Likewise the wait time decision algorithm parameter information may be used to configure the wait time decision logic so that the wait time decision logic may be configured differently depending on which service is being called and depending on which program component is calling the service . Again the information may be used to specify the decision algorithm and or the parameters e.g. coefficients to be used by the call decision logic .

Referring now to a flowchart showing operation of the call decision logic is shown. As previously indicated the call decision logic is configured to determine whether a service request should be permitted to be made to a service .

At step the health of the service is determined. The health of the service may be determined in a variety of manners and taking into account any available information including statistical information contextual information manually provided information and so on. In an exemplary embodiment the health of the service is determined based on historical statistics from communications with the service . For example the health of the service may be determined by measuring the response time of the service and comparing the response time against historical values. For example the response time of the service may be measured over a relatively short preceding time period and over a relatively long preceding time period. The ratio of the two measurements may then be taken to yield a value indicating the health of the service . Thus if the ratio is close to one the service may be assumed to be operating at normal health. On the other hand if the service is responding much slower now than usual the ratio will be smaller indicating that the service is less healthy. Each measurement may be made for example by using an exponentially decaying mean latency computation for each time period.

In another exemplary embodiment the health of the service may be determined based on whether the service has not responded to a predetermined number of recent service requests. For example if the service has not responded to the five most recent service requests then the service may be assumed to be not healthy. In another exemplary embodiment the health may be determined based on a message from the service indicating that the service is not healthy. For example the service may compute its own health and provide its health measurement to the availability manager . Thus the health may be determined by examining service side information or client process side information. As another example the service may be configured to respond to a request asking the service about the status of its health. For example if a service request has not recently been made to a particular service such that response time measurements are no longer up to date a service request may be sent to the service inquiring as to the health of the service . The service may then respond with an indication whether it is healthy.

In another exemplary embodiment the health of the service may be determined based on manually provided information. For example a system operator may manually provide an indication that a service appears to be in poor health. As another example a system operator may manually provide information indicating that a service is to be taken offline during a predetermined time period for system maintenance. The health of the service may also be determined based on information obtained from an external system e.g. such as a computer system configured to periodically assess the health of one or more of the services .

In another exemplary embodiment the health of the service may be determined based on the health of related services or hardware components. For example if a hardware component hosts several other services and each of the other services is in poor health then the poor health of the other services may be used as a predictor of the health of the service under consideration. As another example if ten hardware components e.g. servers are located in one data center and services associated with nine of the hardware components are determined to be in poor health then that may be used as an indication that a service hosted by the tenth hardware component may also be in poor health. In another exemplary embodiment a statistic collection algorithm may be employed to determine the health of the service based on whatever statistics are available. For example any unusual performance metric that is noticed by a process or hardware component e.g. server concerning a service may be reported and used to assess the health of the service . Algorithms may be dynamically implemented which are configured to utilize the information noticed by the process or hardware component.

The algorithm used to determine health may be different for each program component and for each service and may be included as part of the configuration information . In another exemplary embodiment multiple algorithms are used to compute health and the performance of each algorithm is scored to determine which health algorithm provides the best results over time. The algorithm that scores the highest is then used until another algorithm is introduced which scores higher.

As previously noted the system may be implemented in a distributed computing environment. In such an arrangement it may be desirable for each hardware component e.g. each server to compute a health value for a given service . This allows performance information for a given service to be shared by all program components executing on a given hardware component. A single program component may not always have enough performance information for a service to compute a reliable health value for the service . At the same time this allows each of the hardware components to compute a health value for the service independently of the health values computed for the same service by other hardware components. Because slow or non existent responses from services may sometimes be caused by client process side hardware problems different hardware components may perceive the health of a given service differently than other hardware components. This allows specific problems that are perceived at one hardware component but not others to be taken into account in the health computation. In another exemplary embodiment a single health value is computed for some or all hardware components i.e. to encapsulate the health of a group of hardware components in one health value . It may be desirable to use this arrangement where each hardware component does not send service requests to a given service frequently enough to have reliable health information for the service but where in the aggregate the hardware components do have reliable health information.

At step an importance ranking threshold is determined. Referring now also to an exemplary mechanism for determining the importance ranking threshold is shown. shows a feedback control loop that is used to maintain the health of a service at an optimal level. The feedback control loop receives a health setpoint which is compared with the actual health of the service . A transfer function then determines the importance threshold as a function of the difference between the health setpoint and the actual health of the service . For example if the actual health of the service is relatively high and close to the health setpoint then the importance threshold may be relatively low. As a result the service receives service requests of both higher and lower importance. On the other hand if the actual health of the service is relatively low and not close to the health setpoint then the importance threshold may be set at a higher value. As a result the service may only receive service requests of higher importance.

Referring again to at step a decision is made whether to permit a service request to the service based on whether the health is above or below the importance threshold. If the importance ranking is below the importance ranking threshold then the service request is not permitted step . On the other hand if the importance ranking is above the importance ranking threshold then the service request is permitted step . The decreased loading on the service permits the health of the service to improve and permits service request processing throughput to increase.

In other exemplary embodiments the call decision logic may operate in another manner. For example a particular process or hardware component may be given a quota for accessing a service e.g. one hundred service requests per second . The call decision logic may then operate to ensure that the process or hardware component allocates its quota first to critical service requests and only thereafter then to non critical service requests. In such an embodiment the quota may be determined in advance or it may be determined dynamically by the service based on its own assessment of its health e.g. the service may adjust the quota downward when its health deteriorates . The service may also be configured to send a message indicating when the process or hardware component has exceeded its quota. Alternatively the fact that the service is not responding to service requests when the quota is exceeded may be used by the service as an indication that the process or hardware component may be in poor health causing the importance threshold to increase and thereby fewer service requests to be made.

Thus in the arrangement of if there is statistical evidence that a service is in trouble then less critical service requests may not be sent to the service . The decision whether or not to permit a service request to be made to the service impacts loading of the service . If a service is already overloaded the decision not to permit the service request protects the service from taking on additional load which may cause the service to fail. Thus the arrangement of protects the service by avoiding putting additional loading on the service when the service is not fully healthy. In steady state the service operates at maximum capacity. If it starts taking on too much load the response times deteriorate and the health decreases resulting in fewer service requests being made. Thus the negative feedback causes reduced loading and causes the service to return to a more optimum health condition. In steady state this arrangement controls the flow of service requests so as to cause the services and hardware components to process service requests at maximum capacity. Additionally the decision whether or not to permit a service request to be made to the service impacts whether resources are allocated trying to communicate with a service that has failed.

Referring now also to graphs of the performance characteristics of the arrangement of are shown. In a binary critical non critical importance ranking scheme is assumed to be employed. Accordingly the transfer function is non linear and selects one of two thresholds depending on the health of the service .

Curve represents the health of the service . Above a health level h the service is considered to be healthy and it operates in a green mode of operation . Curve represents the number of service requests that are permitted to be made to the service based on the importance ranking relative to the health of the service . In this mode of operation both critical and non critical service requests are permitted to be made to the service . As a result of the normal operational health the number of service requests that are permitted to be made to the service is at a maximum.

When the health of the service drops below the health level h the service is considered to be less healthy and it operates in an orange mode of operation . In the orange mode of operation all critical service requests are permitted but non critical service requests are not permitted. The probability that a given service request will be permitted thus depends on the level of importance of the service request. The service is thereby protected from overload but it is still permitted to provide responses to critical service requests and critical functionality is preserved.

The orange mode of operation also facilitates protection of a service when the service starts to become overloaded. That is when a service becomes overloaded and program components begin retrying service requests to the service there may be a tendency for the service to receive more load when it starts slowing down. In the orange mode of operation when the health of the service starts deteriorating the number of retries is managed such that only the more critical retries are permitted. The reduction in permitted service requests may cause the health of the service to improve due to the negative feedback discussed above in connection with . The critical service requests also continue to generate data relating to communications with the service . Such data may be used as historical statistics in the health algorithms described above in connection with step to detect that the health of the service has improved. The service may then for example return to the green mode of operation.

On the other hand if the health of the service drops below the health level h the service is considered to be unhealthy and it operates in a red mode of operation . In the red mode of operation the service may be experiencing significant trouble e.g. it has failed or it is significantly overloaded and is about to fail . Accordingly no service requests are permitted to be made to the service . If the service has failed in an exemplary embodiment rather than not permitting any service requests a program component is selected to make periodic test service requests to the service until a connection with the service is reestablished. The test service requests may be used to generate data relating to communications with the service . Such data may be used as historical statistics in the health algorithms described above in connection with step .

It may also be desirable to implement a hysteresis in the arrangement of . For example some hardware components may remain in one mode of operation longer than others such that a service gradually shifts from one mode of operation to another. Such hysteresis may be implemented for example by configuring the program components to use slightly different algorithms to implement the health computation.

In a continuous e.g. floating point value importance ranking scheme is assumed to be employed. Accordingly the transfer function may take a more linear form and the number of service requests curve that are permitted to reach the service may gradually increase or decrease as the health of the service improves or deteriorates respectively. In the arrangement of rather than just three modes of operation the service may have a potentially infinite number of modes of operation in accordance with the number of different potential values for the importance ranking .

The arrangement of and A B may also be used to protect services to address what is sometimes referred to as the cold cache problem in the context of restart operations. For example after a service has failed and then enters a start up mode a certain amount of time may be required for the service to become fully operational. When the service enters the start up mode the health of the service may be considered to be poor e.g. because it is not responding to service requests . As the service comes back on line there may be a tendency to send many service requests to the service at once given that the service has been off line. Such an initial rush of service requests may create the potential for the service to fail due to overloading. The arrangement described above protects the service because the health of the service is initially poor. As a result the service may start slowly responding to only a limited number of service requests and then ramp up as the health of the service improves. Also during this period the service starts by responding to the most critical service requests and then gradually responds to less critical requests as it comes fully on line. In another exemplary embodiment e.g. where a service is not called very often it may be desirable for the service to be considered healthy until information is received to the contrary. In such an arrangement the service would be considered healthy on start up.

Referring again to the wait time algorithm parameter information includes resource allocation time RAT configuration information and failure expectation time FET configuration information which are used by the service availability manager to calculate a resource allocation time and a failure expectation time respectively. The resource allocation time is configured to address the situation in which a service request may complete but so slowly that simply waiting for the response may prevent the process from producing its result within a desired time period cause the cost of waiting to exceed the value of the results from the service or even slow the process down to such a degree that it cannot fulfill its critical purposes. The failure expectation time is configured to address the situation in which a service request may never complete. Thus the use of a resource allocation time and failure expectation time allows these two separate scenarios to be addressed separately.

Referring now to also a flowchart showing operation of wait time decision logic is shown. At step the failure expectation time is calculated. In an exemplary embodiment the failure expectation time operates such that if i a request was sent to a service ii no response has been received and iii the failure expectation time has been exceeded then that means the service has probably failed and the process should stop waiting for a response. In an exemplary embodiment the failure expectation is calculated as follows FET max successful response n sigma where n sigma is n times the standard deviation of the latency of the service and max successful response is the maximum observed latency of a successful service request.

At step the resource allocation time is calculated. In an exemplary embodiment the resource allocation time operates such that if the requested information is non critical then the process should stop waiting for a response in time to finish generating the page without the optional information prior to expiration of the task deadline. If the information is critical then the requestor waits longer. In an exemplary embodiment the resource allocation time is calculated as follows RAT if serviceCallImportance Critical then critical upper bound else min 2 sigma time remaining before task deadline . In this example if the importance of the service request is critical then the process waits until a critical upper bound is reached. The critical upper bound may be a value corresponding to the maximum amount of time it is desired to wait for a response critical service requests. The critical upper bound may be configured to expire for example just before the page timeout expires. If the importance of the service request is non critical then the process waits twice as long as it would expect to wait for a response but if the deadline for completing the task is about to expire then the process stops waiting. As will be appreciated the deadline for completing the task may be a firm deadline or may simply be a performance goal that may be missed.

At step it is determined which of the failure expectation time and the resource allocation time is smaller. The wait time is set equal to the lesser of the failure expectation time and the resource allocation time. Based on this determination the process then waits for the wait time to expire. Once it is determined that the wait time has expired step then the process stops waiting for a response to the service request. Again as noted above the algorithm may be different for each different program component and for each different service .

As previously indicated in an exemplary embodiment the process may make many service requests to many services such that the process is waiting for many responses at the same time. In such situations in an exemplary embodiment step may be performed using the longest wait time of all of the critical service requests. Thus for example the wait time for each of the critical service requests may be determined in steps and then the longest wait time of all of the service requests may be determined and used in step . As long as the process is waiting for a critical service request it may continue waiting for non critical service requests as well until a determination is made to abandon the critical service request and all other service requests . On the other hand if there is no critical information then the wait time may be determined to be zero. The task may then be completed without the optional information. Other approaches may be used as well.

Referring now to another example showing operation of the system of is shown. is similar to except that it is presented in the context of an example of a process that is configured to construct web pages for a website. Also in the service availability manager is not shown for simplicity. show exemplary web pages produced by the system of in different scenarios.

The process includes various program components that send service requests to services to obtain information to populate fields of a web page template . Often a given web page may have some central purpose and may have some information which is considered critical and some information which is considered optional. The information that is critical and the information that is optional depends on the purpose of the web page. In the fields include a field in which the requested information is critical and the services include a service which is accessed to provide the critical information. For the remainder of the fields the requested information has been designated has optional. Again in the services may be accessed in parallel.

The process may have a deadline for completing the web page. For example once the process receives the request for a web page it may have 1500 ms to construct the web page for publication to the visitor. During this time the services are accessed and information received from the services is used to populate the fields . Again the deadline may be a firm deadline or merely a performance goal.

Referring now to in operation after the request to generate the web page has been received by the process it is determined whether to send service requests to the services step . The decision whether to send the service requests may be made in accordance with the discussion above in connection with A and B. For example if one of the services is not healthy a decision may be made not to send the service request to the service in order to protect the service. In an exemplary embodiment decision logic may be included to select an alternate service to access to obtain substitute information for the information that was to be provided by an unhealthy service . In another exemplary embodiment decision logic may be included to select alternate content to display. For example with reference to if the service that provides the information to populate Field is unhealthy then Field may be populated with information from an alternate service which provides information that is different than the information requested from the healthy service e.g. to use one website to substitute for another website feature.

The process then sends service requests to the services for information to populate the fields . The information from the service has been designated as critical and therefore the response time of the service is of particular interest. As previously indicated in an exemplary embodiment the wait time calculations for the non critical service request may be subordinated to the wait time calculation for the critical service request. The failure expectation for the critical service request is then calculated step . If the wait time decision logic is configured in the manner discussed above in connection with then the wait time is set equal to the failure expectation time step . This is because the resource allocation time is set to infinity if the service request is critical and therefore is not less than the failure expectation time step .

Next either a response to the critical service request is received prior to the expiration of the wait time or the wait time expires and no response to the critical service request has been received steps . If a response is received then a determination may be made whether to continue waiting for the non critical service requests step . For example if the service responds with the requested information in advance of the deadline for completing the web page a decision may be made to forego the other non critical information and publish the web page ahead of schedule e.g. to make the website faster . Alternatively a decision may be made to wait until the expiration of the deadline for completing the web page before foregoing the non critical information. In an exemplary embodiment this decision is made on a service request by service request basis in the wait time algorithm parameter information for each service request. In another exemplary embodiment this decision may be made on a web page by web page basis by part of the program logic of the process . If the failure expectation time of the critical service request is reached after the expiration of the deadline for completing construction of the web page and if a response to a critical service request is received after the deadline then the process may continue to wait for the results of the non critical service requests during this time period even though the individual wait times for these service requests have expired e.g. when the page deadline expired . After any additional information is obtained from non critical service requests the web page is published at step .

If the wait time of the critical service request expires before a response is received then the non critical service requests may be abandoned as well e.g. if there is little or no value to the web page without the critical information and an error may be returned step . In another exemplary embodiment the non critical service requests may be given until the expiration of their own individual wait times to return their responses e.g. if there is still value to the web page without the critical information . Again this may be configured on a web page by web page basis.

In the service that provides the information used to populate field is assumed to be in a degraded performance mode. In the context of the visitor s identity is assumed to be useful e.g. to generate the custom welcome message but not critical e.g. as compared to for use in generating a checkout page . Accordingly the service request is not permitted to be made to the service and therefore as shown in a generic welcome message is provided that is not customized to the visitor. There is thus a graceful degradation of the service which frees it from having to respond to service requests that are not considered important so that it can continue to respond to service requests that are considered important.

In the example of a binary importance ranking scheme is utilized. If a continuous e.g. floating point value importance ranking scheme is utilized the process of may be modified. For example instead of making decisions based on whether critical information has been received decisions may be made based on the aggregate importance of the information received. For example if the aggregate importance of the information that has been received falls below a threshold an error may be returned at step . Also the wait time may be calculated for example as a weighted average of the wait times of the individual service requests i.e. in accordance with the relative importance of the service requests .

In an exemplary embodiment the fields are rendered e.g. by generating HTML in an order which is determined based on the location of the field on the web page. In another exemplary embodiment the fields are rendered in an order which is dynamically determined. For example in an exemplary embodiment the fields may be rendered in an order which is dynamically determined based on which responses have been received from the services and correspondingly which fields have had the requisite data collected such that the particular field may be rendered. For example in the arrangement of and the system may be configured to track which program components transmit service requests to which services in connection with collecting the data needed to populate the fields . This information may then be used to perform a dependency analysis to determine for each of the fields which responses need to be received in order to have the data to needed render each field . Based on this analysis the fields may then be rendered in an order that is determined based on the order in which responses are received. For example the program process may determine whether to begin working on rendering a particular field based on whether the complete set of data needed to render the field is available. This allows the web page to be generated more quickly. As the program process is waiting to receive a response from one or more of the services in connection with certain fields it can in parallel begin work on rendering certain other fields for which the requisite data has already been received. In another exemplary embodiment the fields may be rendered in an order which is dynamically determined based on the amount of time required to render the different fields . For example the process used to render some of the fields may involve multiple service requests e.g. by using the results of one service request to make another service request. In such instances it is desirable to begin the rendering of such fields first because such fields will require the most time to complete e.g. as compared to fields where only a service request is required . Thus the rendering of fields that require more time to render may be initiated before the rendering of fields that require less time to render. Again although described in the context of generating a web page it will be appreciated that this arrangement may also be used in other contexts where the program process is configured to perform some other task besides generating a web page.

In an exemplary embodiment a retry mechanism may be implemented which takes into account whether a service request is considered critical. That is if a service request is considered critical but returns an error then another service request may be sent to the service . On the other hand if a service request is non critical then another service request is not sent to the service . This provides a second opportunity to obtain critical information but avoids overburdening potentially unhealthy services with requests for information that is non critical.

In another embodiment metrics may be maintained concerning the performance of a visit to a website. For example if multiple errors are returned to a visitor during a visit one or more of the settings of the system may be modified to increase the likelihood of pages being returned without errors in order to prevent the visitor from becoming frustrated and leaving the website.

As will be appreciated load balancing and request routing techniques may be used in which each service is implemented on multiple hardware components. That is each service may appear to be hosted on a single hardware component from the perspective of the process but in fact the service is hosted on multiple hardware components endpoints . For example service requests may be sent by client processes to a virtual IP address which maps to multiple endpoints and load balancers may be used which distribute the service requests amongst the multiple endpoints. In such a scenario service health may be monitored for each of the endpoints individually or for the group of endpoints in the aggregate. As will be appreciated a tradeoff may exist in the benefits achieved by the more fine tuned health management and the increased overhead that results from the more fine tuned health management.

As will be appreciated the system described herein may be used both in connection with local processes and remote processes. In the context of a remote process a service request may be received from a remote process by way of a network such as the Internet. For example the services may be offered as web services that are accessible to the remote process through an application programming interface API across the Internet. Such service requests may be made by third parties for example to assist in the construction of their own web pages e.g. by obtaining information from the services and using the information to populate externally generated web pages . Thus for example in the program process and one or more of the services may be remote with at least one of the services e.g. service being local. In such an embodiment the health of the service may be controlled as described herein even if other aspects of the web page generation e.g. wait time decisions are under third party control. The remote processes may also make service requests for other reasons apart from generating web pages for example in situations where the remote system is not used to implement a web site. In the context of third party service requests it may be desirable to assign a quota of service requests e.g. the external client is permitted to make one hundred service requests per second as described above. Such an arrangement may be used to protect the service in situations where the external client is susceptible to not following predictable patterns of behavior.

The invention is described above with reference to drawings. These drawings illustrate certain details of specific embodiments that implement the systems and methods and programs of the present invention. However describing the invention with drawings should not be construed as imposing on the invention any limitations that may be present in the drawings. The present invention contemplates methods systems and program products on any machine readable media for accomplishing its operations. The embodiments of the present invention may be implemented using an existing computer processor or by a special purpose computer processor incorporated for this or another purpose or by a hardwired system.

As noted above embodiments within the scope of the present invention include program products comprising machine readable media having machine executable instructions or data structures stored thereon. Such machine readable media can be any available media which can be accessed by a general purpose or special purpose computer or other machine with a processor. By way of example such machine readable media can comprise RAM ROM EPROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to store desired program code in the form of machine executable instructions or data structures and which can be accessed by a general purpose or special purpose computer or other machine with a processor. When information is transferred or provided over a network or another communications connection either hardwired wireless or a combination of hardwired or wireless to a machine the machine properly views the connection as a machine readable medium. Thus any such a connection is properly termed a machine readable medium. Combinations of the above are also included within the scope of machine readable media. Machine executable instructions comprise for example instructions and data which cause a general purpose computer special purpose computer or special purpose processing machines to perform a certain function or group of functions.

Embodiments of the invention are described in the general context of method steps which may be implemented in one embodiment by a program product including machine executable instructions such as program code for example in the form of program modules executed by machines in networked environments. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Machine executable instructions associated data structures and program modules represent examples of program code for executing steps of the methods disclosed herein. The particular sequence of such executable instructions or associated data structures represent examples of corresponding acts for implementing the functions described in such steps.

Embodiments of the present invention may be practiced in a networked environment using logical connections to one or more remote computers having processors. Logical connections may include a local area network LAN and a wide area network WAN that are presented here by way of example and not limitation. Such networking environments are commonplace in office wide or enterprise wide computer networks intranets and the Internet and may use a wide variety of different communication protocols. Those skilled in the art will appreciate that such network computing environments will typically encompass many types of computer system configurations including personal computers hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs servers minicomputers mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by local and remote processing devices that are linked either by hardwired links wireless links or by a combination of hardwired or wireless links through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

An exemplary system for implementing the overall system or portions of the invention might include a general purpose computing device in the form of a computer including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit. The system memory may include read only memory ROM and random access memory RAM . The computer may also include a magnetic hard disk drive for reading from and writing to a magnetic hard disk a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. The drives and their associated machine readable media provide nonvolatile storage of machine executable instructions data structures program modules and other data for the computer.

It should be noted that although the flowcharts provided herein show a specific order of method steps it is understood that the order of these steps may differ from what is depicted. Also two or more steps may be performed concurrently or with partial concurrence. Such variation will depend on the software and hardware systems chosen and on designer choice. It is understood that all such variations are within the scope of the invention. Likewise software and web implementations of the present invention could be accomplished with standard programming techniques with rule based logic and other logic to accomplish the various database searching steps correlation steps comparison steps and decision steps. It should also be noted that the word component as used herein and in the claims is intended to encompass implementations using one or more lines of software code and or hardware implementations and or equipment for receiving manual inputs.

The foregoing description of embodiments of the invention have been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed and modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. The embodiments were chosen and described in order to explain the principals of the invention and its practical application to enable one skilled in the art to utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated.

