---

title: Memory arrangement for message processing by a plurality of threads
abstract: Various approaches for preparing a system for multi-thread processing of messages are disclosed. In one approach, respective portions of a message accessed by a plurality of threads are determined from a high-level language programming specification of the threads. A plurality of input elements are generated and respectively coupled to the plurality of threads. Each input element is configured to select from the message received by the input element the portion of the message accessed by the respective thread and provide each selected portion to the respective thread. A plurality of output elements are generated and configured with storage for data output by a respective thread. From a definition of an output message, a concentrator element is generated and is configured to read data from the output elements and assemble the data into an output message according to the definition of the output message.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07653895&OS=07653895&RS=07653895
owner: XILINX, Inc.
number: 07653895
owner_city: San Jose
owner_country: US
publication_date: 20060120
---
A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention generally relates to a memory arrangement for message processing by a plurality of threads.

Programmable logic devices PLDs exist as a well known type of integrated circuit IC that may be programmed by a user to perform specified logic functions. There are different types of programmable logic devices such as programmable logic arrays PLAs and complex programmable logic devices CPLDs . One type of programmable logic device known as a field programmable gate array FPGA is very popular because of a superior combination of capacity flexibility time to market and cost.

An FPGA typically includes an array of configurable logic blocks CLBs surrounded by a ring of programmable input output blocks IOBs . The CLBs and IOBs are interconnected by a programmable interconnect structure. The CLBs IOBs and interconnect structure are typically programmed by loading a stream of configuration data known as a bitstream into internal configuration memory cells that define how the CLBs IOBs and interconnect structure are configured. Additionally an FPGA may include embedded memory such as block random access memories BRAMs one or more microprocessors sometimes referred to as embedded cores and digital clock managers DMs . The combination of components on an FPGA may be used for system level integration sometimes referred to as system on a chip SOC .

Historically FGPAs have not been employed in network processing applications. Rather network devices such as routers employ dedicated special purpose components for processing packets that propagate through the network. Conventionally network devices employ network processors or application specific integrated circuits ASICs to provide the desirable packet processing network processing functions. Such processor or ASIC based architectures however are static in nature providing a fixed amount of resources for packet processing network processing functions. In network processors for example whole packets are stored in memory and multiple processing elements contend for access to the memory and interconnect resources. Furthermore some of the processing elements may access the same fields of a packet and do so multiple times thereby further increasing contention for resources. Accordingly there exists a need in the art for more flexible message processing architectures.

The invention provides various approaches for preparing a system for multi thread processing of messages. In one approach respective portions of a message accessed by a plurality of threads are determined from a high level language programming specification of the threads. A plurality of input elements are generated and respectively coupled to the plurality of threads and coupled to receive the message. Each input element is configured to select from the message received by the input element the portion of the message accessed by the respective thread and provide each selected portion to the respective thread. A plurality of output elements are generated and configured with storage for data output by a respective thread. From a definition of an output message a concentrator element is generated and is configured to read data from the output elements and assemble the data into an output message according to the definition of the output message.

In another embodiment and apparatus is provided for preparing a system for multi thread processing of messages. The apparatus includes means for determining from a high level language programming specification of a plurality of threads respective portions of a message accessed by the threads means for generating a plurality of input elements respectively coupled to the plurality of threads and coupled to receive the message wherein each input element is configured to select from the message received by the input element the portion of the message accessed by the respective thread and provide each selected portion to the respective thread means for generating a plurality of output elements respectively coupled to the plurality of threads wherein each output element is configured with storage for data output by the respective thread and means for generating from a definition of an output message a concentrator element coupled to the plurality of output elements and configured to read data from the output elements and assemble the data into an output message according to the definition of the output message.

In yet another embodiment a processor readable medium is configured with processor executable instructions for preparing a system for multi thread processing of messages.

It will be appreciated that various other embodiments are set forth in the Detailed Description and Claims which follow.

One or more aspects of the invention are related to a configurable and programmable micro architecture for implementing message processing MP systems soft platform architecture . As used herein the term message encompasses packets cells frames data units and like type blocks of information known in the art that may be passed over a communication channel. A message processing system is a system or subsystem for processing messages e.g. a packet processing system or a network processing system . The soft platform architecture is message centric to match the nature of MP systems. That is the processing components of the MP system go to the messages as opposed to the messages coming to the processing components.

A MP system may be implemented using a plurality of threads and a broadcast channel. Each of the threads processes a respective portion of a multi word message and the broadcast channel is used to transmit the message to the threads. One of the threads receives an input message and writes data from the message to the broadcast channel. This thread may be referred to as the broadcaster thread. The broadcast channel receives as input one word at a time and outputs two words at a time. The broadcast channel indicates which words of the message are present on the channel by outputting a message relative offset of the first transmitted word of the two word pair. A receiver thread may read data from the broadcast channel when desired words of the message are present on the channel as indicated by the offset provided by the channel.

Briefly stated a designer specifies attributes for an MP system such as structural and behavioral attributes for processing components and memory components. For example the designer may employ a set of descriptions or primitives that parametrically define the MP system attributes. The primitives provide an abstract mechanism for defining the MP system. A design tool embodying the soft platform architecture may include a programming interface for generating a logical description or logical view of an MP system based on the designer specified attributes.

Notably the logical view includes logical components of the soft platform architecture configured in accordance with the designer specified MP system. In particular the soft platform architecture includes a memory model component and a multithreading component. A physical view of the MP system may then be generated based on the logical view. The physical view includes physical components of an integrated circuit architecture that implement the logical components of the soft platform architecture. The physical view may then be processed to generate configuration data for the integrated circuit to realize the designer specified MP system e.g. a configuration bitstream for a PLD or mask data for an ASIC . Thus the soft platform architecture provides a mechanism by which a designer may design an MP system in an abstract fashion without knowledge of the particular physical configuration of the integrated circuit.

One or more aspects of the invention are described with respect to a programmable architecture for implementing a message processing system using an FPGA. While the invention is described with specific reference to an FPGA those skilled in the art will appreciate that other types of programmable devices including programmable logic devices and partially programmable devices may be used such as complex programmable logic devices CPLDs . In addition other types of mask programmable devices may be used such as application specific integrated circuits ASICs . Those skilled in the art will appreciate that if an ASIC is employed rather than a PLD then mask data is generated in place of a configuration bitstream.

The FPGA illustratively comprises programmable logic circuits or blocks illustratively shown as CLBs IOBs and programmable interconnect also referred to as programmable logic as well as configuration memory for determining the functionality of the FPGA . The FPGA may also include one or more embedded processor blocks as well as various dedicated internal logic circuits illustratively shown as blocks of random access memory BRAM configuration logic digital clock management DCM blocks and input output I O transceiver circuitry . Those skilled in the art will appreciate that the FPGA may include other types of logic blocks and circuits in addition to those described herein. Note that the illustrated arrangement is merely a simplified example of one possible arrangement and other arrangements are possible and will be known to those of skill in the art.

As is well known in the art the IOBs the CLBs the programmable interconnect and other programmable resources may be configured to perform a variety of functions. Notably the CLBs are programmably connectable to each other and to the IOBs via the programmable interconnect . Each of the CLBs may include one or more slices and programmable interconnect circuitry not shown . Each CLB slice may in turn include various circuits such as flip flops function generators e.g. a look up tables LUTs logic gates memory and like type well known circuits. The IOBs are configured to provide input to and receive output from the CLBs .

Configuration information for the CLBs the IOBs and the programmable interconnect is stored in the configuration memory . The configuration memory may include static random access memory SRAM cells. The configuration logic provides an interface to and controls configuration of the configuration memory . A configuration bitstream provided from the program memory may be coupled to the configuration logic through a configuration port . The configuration process of FPGA is also well known in the art.

The I O transceiver circuitry may be configured for communication over any of a variety of media such as wired wireless and photonic whether analog or digital. The I O transceiver circuitry may comprise gigabit or multi gigabit transceivers MGTs . The DCM blocks provide well known clock management circuits for managing clock signals within the FPGA such as delay lock loop DLL circuits and multiply divide de skew clock circuits.

The processor block comprises a microprocessor core as well as associated control logic. Notably such a microprocessor core may include embedded hardware or embedded firmware or a combination thereof for a hard or soft microprocessor. A soft microprocessor may be implemented using the programmable logic of the FPGA e.g. CLBs IOBs . For example a MicroBlaze soft microprocessor available from Xilinx of San Jose Calif. may be employed. A hard microprocessor may be implemented using an IBM Power PC Intel Pentium AMD Athlon or like type processor core known in the art.

The processor block is coupled to the programmable logic of the FPGA in a well known manner. For purposes of clarity by example the FPGA is illustrated with 12 CLBs 16 IOBs 4 BRAMs 4 DCMs and one processor block. Those skilled in the art will appreciate that actual FPGAs may include one or more of such components in any number of different ratios and different arrangements. For example the FPGA may be selected from the Virtex II Pro family of products commercially available from Xilinx of San Jose Calif.

The FPGA circuit design may be interface centric in that the circuit design is driven by the behavior at the system interfaces as opposed to the processor centric model where the circuit design is driven by the behavior of an embedded processor. The interface centric circuit design model matches well with the message centric style of the soft platform architecture. Placement and usage of interfaces memories and their interconnections dominate the allocation of FPGA architecture features and then allocation of functional elements e.g. programmable logic embedded processors for the process components follow as a derivative.

More specifically the input section is coupled to one or more input devices and a database storing an application programming interface API API database . The API database includes a set of primitives associated with structural and behavioral attributes of the soft platform architecture. Thus the API provides a programming interface for the soft platform architecture. An exemplary embodiment of a programming interface for a soft platform architecture is described below in the section entitled PROGRAMMING INTERFACE. Using the input devices a designer may interact with the input section to produce specification data for an MP system or subsystem if the MP circuit is part of a larger system hereinafter referred to as an MP system .

In one embodiment a designer may use the primitives in the API database directly to produce the MP system specification data for the soft platform architecture. In another embodiment a designer may design the MP system using alternate constructions provided by the input section . That is the input section may comprise a design entry tool specific to the MP domain. Examples of such MP specific design entry tools include Click available from The Massachusetts Institute of Technology Rave available from Cloudshield of Sunnyvale Calif. and SDL a telecom standard from ITU T . The input section may then map the MP system specified using the alternate constructions onto the primitives in the API database for the soft platform architecture. Thus the input section may provide a different level of abstraction than that provided by the soft platform architecture.

In one embodiment of the invention the MP system specification data may comprise program code for programmatically interacting with the soft platform section . The program code may be callable by an external design tool of the input section . In another embodiment the MP system specification data may comprise interpretive descriptions e.g. descriptions in a textual or binary format that the soft platform section may interpret e.g. an XML format . In either embodiment the MP system specification is used to configure the soft platform architecture.

The soft platform section is coupled to the input section for receiving the MP system specification data. The soft platform section is also coupled to a database storing the features or attributes of the soft platform architecture soft platform database and a database storing features or attributes of the architecture of the FPGA FPGA database .

The soft platform section includes a first portion for generating a logical description or logical view of an MP system in accordance with the MP system specification. The logical view is defined in terms of the logical components of the soft platform architecture stored in the soft platform database . The soft platform section includes a second portion for generating a physical view of the MP system. Notably using information in the FPGA database the soft platform section maps the logical view of the MP system defined in terms of the soft platform architecture onto the architecture of the FPGA . The soft platform section provides FPGA design data as output which represents a physical view of the MP system in terms of the architecture of the FPGA . Details of the soft platform architecture are described below with respect to .

The FPGA design tools section is coupled to the soft platform section for receiving the FPGA design data. The FPGA design data may comprise a physical description of the MP system specified by the designer in terms of the components and features of the FPGA . For example in one embodiment the FPGA design data may comprise a hardware description language HDL representation of the MP system design e.g. Very high speed integrated circuit description language VHDL or Verilog . The FPGA design tools section processes the FPGA design data to produce configuration bitstream data. For example the FPGA design tools section may comprise various well known FPGA design tools such as a synthesis tool a map place route tool and like type tools known in the art. The FPGA design tools section provides configuration bitstream data as output which may be loaded into the FGPA .

At step a logical view of the MP system is generated in accordance with the MP system specification. As described above the logical view of the MP system is defined in terms of a soft platform architecture. The logical components of the soft platform architecture are configured in accordance with the MP system specification to generate the logical view of the MP system. The term logical components refers to both the structural and behavioral attributes of the soft platform architecture described in more detail below.

At step the logical view of the MP system is mapped onto an FPGA architecture to produce FPGA design data. That is the logical components comprising the logical view are linked to physical components of an FPGA and optionally other devices connected to the FPGA e.g. external memories . In one embodiment of the invention the FPGA design data comprises an HDL representation of the MP system design. As described above the FPGA design data provides a physical view of the specified MP system in terms of the architecture of the FPGA. That is FPGA design data corresponds to the physical implementation of the logical view of the MP system on an FPGA device.

At step the FPGA system design is processed to produce configuration bitstream data. For example if the FPGA system design comprises an HDL representation of the MP system design the FPGA system design may be synthesized mapped placed and routed in a well known manner to produce bitstream data for configuring an FPGA. At step the configuration bitstream data is loaded into an FPGA to realize the MP system specified at step . The process ends at step .

The soft platform architecture includes a programming control interface and a debug test monitor interface . The programming control interface conveys the data for configuring the programmable portions of the soft platform architecture . The programming control information conveyed via the programming control interface comprises the structural and behavioral information related to the MIS component the process component and the SSS component . An exemplary embodiment of a programming interface to the soft platform architecture is described below in the section entitled PROGRAMMING INTERFACE. The debug test monitor interface may be used during the design and implementation of an MP system defined in terms of the soft platform architecture . The interfaces and are illustrative as there may be a single shared interface or more than two interfaces.

The MIS component is the logical storage point for all messages currently within the system implemented using the soft platform architecture . The MIS component includes an interface to the enclosing environment allowing for the input and output of messages. For example the soft platform architecture may be configured to produce an internet protocol IP packet router. The MIS component may be configured to store all IP packets currently in flight through the router. The interface may be one or more ports by which the router is connected to a physical network.

The MIS component may be physically implemented using a centralized memory device a plurality of distributed memory devices or a combination thereof. In addition the types sizes and interconnections of the physical memory elements as well as the interface to such physical memory elements are programmable through configuration of the MIS component . An exemplary embodiment of a logical memory configuration that may be used as the MIS component is described below in the section entitled MEMORY MODEL. 

The process component comprises one or more processes that may be classified as fine grain operations processes FOPs coarse grain operations processes COPs or perimeter interface processes PIPs . In addition the process component includes an inter process synchronization component . The FOPs COPs and PIPs operate on messages stored within the MIS component . The term process as used herein denotes a concurrent agent for operating on information stored within the MIS component . The term thread is used to denote an instance of a process.

Each single execution of a process within the process component is associated with a message stored in the MIS component through a message context . A process in the process component may be physically implemented directly in programmable logic of an FPGA or in a soft or hard embedded processor of an FPGA. In one embodiment of the invention the message context may be implemented using a data counter DC component . The DC component points to the current position in the current message being operated on by a particular process in the process component . As the process executes the DC component may be updated either automatically to advance to the next position in a message or by execution of programmed data jumps. In essence the process moves over the message. The DC component may be physically implemented using a memory element within the FPGA capable of storing an address associated with the location of a message in the memory of the MIS component . Depending on the memory organization of the MIS component the DC component may be a register a BRAM or an external RAM.

The processes of the process component include a common interface. The inter process communication component may utilize the common interface to allow interaction between processes of the process component . Such interactions may include for example creating or destroying a process or passing data to another process. The inter process communication component provides for a control flow in the processing of a message. At a microscopic level the inter process communication component is capable of providing a control flow within a single process s execution. At a macroscopic level the inter process communication component is capable of providing a control flow from one process s execution to another process s execution. An exemplary embodiment of a multithread model that may be used as the inter process communication component is described below in the section entitled MULTITHREAD MODEL. 

A FOP is the basic programmable unit for message processing. A FOP performs a sequence of steps on a message stored within the MIS component . At each step a set of concurrent operations are performed. A FOP may be associated with a DC component . After each step the DC component may be incremented or a data jump operation performed such that the FOP accesses a new portion of the message. The steps as well as the operations performed during each step may be programmable static or partially programmable and partially static in their definition. Examples of operations include inspecting a field e.g. a 16 bit header field of a message or performing simple arithmetic e.g. adding one to a 16 bit header field on a message.

A FOP may be implemented within an FPGA using programmable logic. For example a FOP may be implemented as a finite state machine FSM configured within the programmable logic of the FPGA. Alternatively a FOP may be implemented on an embedded processor within an FPGA. For example a FOP may be implemented as an operating system thread executed by the embedded processor. The physical implementation of a FOP may be programmable static or partially programmable and partially static in its definition.

A COP is used to incorporate a function block to perform a message processing operation. A function block may comprise a circuit or subsystem defined outside the context of the soft platform architecture . For example the function block may comprise a reusable intellectual property IP core for an FPGA. A COP provides a programmable adapter between the interface of the function block and the common interface of the process component . A COP may be started stopped or interrupted by another process of the process component .

A COP may be defined statically and be in existence permanently. Alternatively a COP may be created and destroyed dynamically to allow dynamic reconfiguration of the function blocks associated therewith. For example a COP may be used to incorporate a function block for compression or encryption of all or part of a message stored in the MIS component . A COP may be associated with a DC component which points to the beginning of the message in the MIS component to be processed by the COP .

A PIP is concerned with enabling the movement of a message to and from soft platform architecture . In one embodiment of the invention a PIP may be used to incorporate a function block similar to a COP . The function block associated with a PIP may comprise a circuit or subsystem defined outside the context of the soft platform architecture that is specifically geared to perform I O functions. In another embodiment of the invention a PIP may be implemented as a FSM in programmable logic of the FPGA.

For example a PIP may be used to receive or transmit successive words of a message over an interface using a protocol defined for the interface. For example a PIP may act as a smart adapter for the Xilinx LocalLink interface to a networking core or the interface to a Gigabit MAC core. A PIP may also communicate with other system components implemented within the FPGA.

The SSS component may be used to store state information associated with the processes of the process component . For example the SSS component may be used to store a message context for a FOP . The SSS component may be physically implemented using a centralized memory device a plurality of distributed memory devices or a combination thereof.

In particular the input section is coupled to a database that stores an API associated with the memory model referred to herein as the memory interconnection description language MIDL library . The MIDL library comprises a set of primitives for defining structural and behavioral attributes of the memory model. Thus the MIDL library provides a programming interface for the memory model. A designer may interact with the input section to produce specification data for a memory subsystem. The designer may work directly with the MIDL library or may work indirectly with the MIDL library through an alternative design tool defined within the input section . The memory subsystem specification data may be programmatic or may be interpretive e.g. XML . An example of an MIDL specification for a 32 bit wide memory constructed from two 16 bit wide memories which are in turn mapped to physical BRAM in an FPGA is shown in Appendix A.

The memory model section is coupled to the input section for receiving the memory model specification. The memory model section is also coupled to a database that stores the features or attributes of the memory model memory model database and a database that stores the memory attributes of an FPGA and external memories associated therewith FPGA memory database . The memory model section includes a first portion for generating a logical view of a memory subsystem in accordance with the memory subsystem specification. The logical view is defined in terms of the logical components of the memory model stored in the memory model database .

The memory model section may include an analysis optimization portion for analyzing and optimizing the logical view of the memory subsystem in accordance with constraint data provided by a designer. The memory model section further includes a second portion for generating a physical view of the memory system based on the logical view. Notably using information in the FPGA memory database the memory model section maps the logical view of the memory subsystem onto the physical memory components associated with an FPGA. The memory model section provides FPGA design data as output.

The memory model is characterized by a memory architecture and a memory interconnection architecture. The memory architecture pertains to the size type and topology of one or more memory circuits comprising the memory element . The memory interconnection architecture pertains to the type bus width e.g. number of wires and topology of interconnection e.g. crossbar of the one or more memory circuits comprising the memory element . In general with respect to the memory model the term interface imparts knowledge related to the protocols that must be adhered to for the particular interaction whereas the term architecture imparts knowledge related to the critical path that particular data follows within the memory model .

The memory and interconnection architectures of the memory model may be defined by the physical location of the memory circuits used to implement the model as well as the logical configuration of the interface to such memory circuits. For example the memory may be physically centralized i.e. a single physical memory circuit or several memory circuits may be physically distributed. The memory circuit s used to implement the memory model may be disposed within the FPGA e.g. any combination of on chip BRAMs LUT based RAMs and shift registers disposed external to the FPGA e.g. external SDRAMs DDR SDRAMs and RDRAMs or a combination thereof. In addition the interface to such memory circuit s may be logically centralized e.g. a unified programming interface or logically distributed e.g. multiple logical interfaces .

In light of the various physical and logical configurations for the memory and interconnection architectures various logical schemes for storing messages may be implemented using the memory model . In one embodiment all messages may be stored within a single memory e.g. a queue of messages in a memory uniform message storage . Alternatively different messages may be allocated over different memories interleaved message storage . In yet another alternative each message may be physically allocated over different memories striped message storage . In another embodiment each message may be logically allocated over different memories separated message storage .

At step a logical view of the memory subsystem is generated in accordance with the memory subsystem specification. The logical view is defined in terms of the memory model . That is the logical components of the memory model are configured in accordance with the memory subsystem specification to generate a logical view of the memory subsystem.

At step the memory subsystem may be analyzed and optimized in accordance with predefined constraint and test data. The constraint data may include constraints on memory access time and interconnect resources. The test data may include one or more test memory access patterns. In one embodiment of the invention an analysis model based on memory access time and interconnect resources is employed.

Returning to at step the logical view of the memory subsystem is mapped onto an FPGA architecture to produce FPGA design data. That is the logical components comprising the logical view are linked to physical memory components of an FPGA and optionally other memory devices connected to the FPGA. The FPGA design data provides a physical view of the specified memory subsystem in terms of the memory architecture of the FPGA. That is FPGA design data corresponds to the physical implementation of the logical view of the memory subsystem defined using the MIDL. In one embodiment of the invention the FPGA design data comprises an HDL representation of the MP system design.

At step the FPGA design data may be combined with other FPGA design data to define a system. For example the memory subsystem may be incorporated into an MP system designed as described above in the section entitled SOFT PLATFORM. That is the memory subsystem may be the implementation of the MIS component of the soft platform architecture used to implement an MP system.

At step the combined FPGA design data is processed to produce configuration bitstream data. For example if the combined FPGA design data comprises an HDL representation the FPGA design data may be synthesized mapped placed and routed in a well known manner to produce bitstream data for configuring an FPGA. At step the configuration bitstream data is loaded into an FPGA. The process ends at step .

In particular the input section is coupled to a database that stores a library of multithreading primitives multithread primitive database . The multithread primitive database stores a set of primitives for defining structural and behavioral attributes of the multithread model. Thus the multithread primitive database provides a programming interface for the multithread model. Notably the multithread primitive database includes primitives for starting a thread stopping a thread suspending a thread as well as synchronization of such starting stopping and suspending among threads. In addition primitives are provided for indicating status information for individual threads such as completion or suspension among other threads. Furthermore primitives may be provided for allowing data communication among threads.

A designer may interact with the input section to produce specification data for a multithreading system. The designer may work directly with the multithread primitive database or may work indirectly with the multithread primitive database through an alternative design tool defined within the input section . The multithreading system specification data may be programmatic or may be interpretive e.g. XML .

The multithread model section is coupled to the input section for receiving the multithreading system specification data. The multithread model section is also coupled to a database that stores the features or attributes of the multithread model multithread model database and a database that stores the physical attributes of an FPGA FPGA database . The multithread model section includes a first section for generating a logical view of the multithreading system in accordance with the multithreading system specification. The logical view is defined in terms of the logical components of the multithread model stored in the multithread database . The multithread model section includes a second portion for generating a physical view of the multithreading system based on the logical view. Notably using information in the FPGA database the multithread model section maps the logical view of the multithreading system onto the physical components associated with an FPGA. The multithread model section provides FPGA design data as output.

Notably the thread model may be physically implemented in programmable logic of an FPGA as a synchronous FSM. That is a clock drives the state machine s transitions and within each state of the state machine operations are performed on operands producing outputs. In another embodiment the thread model may be implemented using a microcontroller embedded within an FPGA. In yet another embodiment the thread model may be implemented using a hard or soft microprocessor embedded within an FPGA.

The thread includes control logic for processing data and producing control state data and operation state data . The control state data captures the state of the thread in terms of inter thread communication e.g. the thread is finished or suspended . The operation state data captures the internal state of the thread which is defined in accordance with the operation of the control logic .

In one embodiment of the invention the thread includes an IDLE control state that corresponds to the thread not currently carrying out any operation. During the IDLE control state the isFinished terminal is asserted to indicate that the thread is not doing any work. If the start terminal is asserted the thread moves out of the IDLE control state and performs the various operations that the thread is configured to perform. The isFinished terminal is no longer asserted to indicate that the thread is in operation. Asserting the stop terminal returns the thread to the IDLE control state terminating all operations. Asserting the suspend terminal causes the thread to remain in its current operation state regardless of how many clock cycles occur on the clock terminal . The suspend terminal may be used during debugging or testing through an external agent. The isSuspended terminal is asserted while the thread is suspended.

The operation state data depends on the operational configuration of the control logic of the thread in accordance with specification data provided by a designer. That is the control logic of the thread is configured to execute a series of steps where one or more operations are performed at each step. In one embodiment the thread may be designed to have one or more designated terminal operation states that cause the thread to enter the IDLE control state and assert the isFinished terminal . Alternatively there may be no such designated terminal control states in which case the thread is controlled externally by asserting the stop signal.

The thread has thus far been described with respect to an external agent that asserts the start stop and suspend terminals. The external agent may be another thread thus allowing threads to control other threads. In order to enable one thread to write or read the signals of another thread the multithread model employs an interconnection topology and an addressing mechanism. That is a plurality of threads are interconnected for communication amongst themselves and a thread may associate the address of another thread with its collection of input and output signals.

In one embodiment of the invention the output bus of a thread model comprises a start control bus a stop control bus a suspend control bus and a status bus . The width of each of the start control bus and the stop control bus is N i.e. the number of thread models in the multithread model . The width of the suspend control bus may be N 1 if self suspension of a thread is not defined. The status bus may comprise M status signals e.g. isFinished and isSuspended signals and thus the width of the status bus is M. The input bus of a thread model comprises a start terminal a stop terminal and a suspend terminal .

Each of the thread models may generate a control signal for each of the other thread models e.g. thread model produces control signals for thread models through through operation of control logic depending on the particular application. Thus if there are eight thread models in the multithread model then each thread model will produce eight start signals eight stop signals and seven suspend signals in accordance with the control logic . For each of the thread models start signal and one stop signal is connected in a self loop which allows a thread model to start and stop itself. The interconnection component facilitates the connection between the output bus of a given thread model and the input buses of each of the other thread models.

A message broadcast on message channel may be processed in parallel by threads and . A message is presented on message channel by a broadcast component not shown for example. The broadcast component transmits on the message channel data words from the message along with addresses that indicate the message relative position of the data. Each of the input elements is configured to extract from the broadcasted data that data needed by the coupled thread. For each input element the definition of the message format and the data required by the associated thread are used to configure the function of the input element to capture the required part s of the message.

The threads and perform their respective application specific processing on the parts of the message provided by the input elements. An example application is an implementation for remote procedure calls RPC in which a first thread performs Ethernet protocol processing a second thread performs Internet Protocol IP protocol processing a third thread performs User Datagram Protocol UDP processing and a fourth thread performs RPC processing. The output data from the threads is provided to output elements and and the output elements provide temporary storage for the data which is read and assembled by concentrator . The concentrator assembles the data in the proper order as defined by application requirements and transmits the message on message channel . Message channels and may be any implementation suitable communications channel.

Control signals not shown are application dependent. For example there may be control signals from the input elements to the respective threads control signals between the threads and control signals from the threads to the concentrator.

The input elements may use registers local to the threads to store the input data. In another embodiment on chip BRAM or off chip RAM dedicated to each input element may be used for storing message data. RAM storage permits storage of large amounts of data. In another embodiment RAM integrated with an embedded processor may be used to store the required message data. Depending on application requirements and implementation restrictions various combinations of registers RAM or processor memory may be used. Dedicated message storage for each of the input elements removes the need for the threads to arbitrate for access to message data and allows the threads to process the respective subsets of the message in parallel.

The output elements and may also be implemented using local registers BRAM RAM or processor RAM as described above for the input elements. Each of the threads writes to the storage in the output element its portion of data required for a complete output message. The concentrator reads from the output elements the data required for an output message and packs the data according to the definition of the message format.

The particular approach selected for storage of input data and output data may be affected by the selected implementation for the threads. For example if a thread is implemented in configurable logic of an FPGA BRAM may be the suitable choice for storage of input and output data. A processor based implementation of a thread may indicate that processor registers or processor RAM are desirable for storage of the input and output data.

For some messages there may be constant values in the message header. Since the values are constant there is no need for these values to be written to and occupy storage space of the output elements. Thus in one embodiment the concentrator is configured to merge the constant values with data read from the output elements into the outgoing message. This removes the need for storing an entire input message for the threads since the constant values are handled by the concentrator.

Some words of the output message may be affected by multiple threads. For example checksums may be performed over multiple words of headers for some applications. Since checksums may be updated rather than recalculated from scratch the incoming checksum for a message header may be modified by the threads. Thus depending on the application some inter thread communication may be required to maintain coherency between the field s of the message updated by the various threads.

In various embodiments of the invention the input elements output elements and concentrator are automatically generated based on high level programmatic specification of the threads. For example in a C language specification of a thread any variable that appears on the right side of an assignment statement or in the conditional test of a loop is a required input to the thread. Similarly any variable that appears on the left side of an assignment statement is an output. Local variables that preserve state between runs of the thread are also identifiable from the semantics of the program code.

In an example application such as processing of network messages the inputs and outputs are the fields in the message e.g. an IP address . Since the format for these messages is well defined the positions of the fields in the input message and the positions for data in an output message are identifiable from the message definition. Thus from the source code specification of the thread and the definition of the message format the input elements output elements and concentrator may be automatically generated.

The message channel includes signals lines and for indicating a message relative address line of data present on the data line and for indicating the start of a message line .

The instances of block represent the message as broadcast to the input elements on the data line. The complete message is shown in block for purposes of showing that the different input elements may select different subsets of data from the message. Those skilled in the art will recognize that in most applications the complete message would not be present at one time at the data input port of the input element even though the complete message is illustrated.

Each of the input elements implements logic that captures from a message on the message channel the subset of data required by the coupled thread. The logic is responsive to the address on line and the start signal on line . For example input element selects from the message the subset of data indicated by brackets and . The address on the address line indicates to the input element when the message data indicated by the brackets is present on the data line. Input elements and show the selection and storage of different subsets of data from the message. The storage for the selected subset of message data e.g. is readable by the coupled thread.

In some applications a portion of the output message may be a direct copy or simple translation of a portion of the input message. In one embodiment the output element is coupled to the input element line and the output element copies translates one or more data values from the input message to a storage cell in the output element. Whether the value is copied or translated may be determined from the source code specification of the thread. The position of the copied translated value in the output storage block may be determined from the definition of the output message format.

Depending on the application data may be transmitted between threads and one or more of the threads may drive control signals to one or more others of the threads. Thread for example is shown both as receiving data and a control signal another thread and providing data and a control signal to another thread.

The read logic reads data from the storage blocks of the output elements in the order designated by the application specific definition of the output message. The data is provided to the merge shift output logic in the designated order. The merge shift output logic combines data read from the storage blocks and with any constant values determined from the thread specification. In addition since the data from the output elements may not be in the correct bit location for the outgoing word data values may need to be shifted. For example suppose the outgoing word should be the 32 bit word A B C D where A B C and D are all 8 bits. If each of the threads outputs a 32 bit word thread 1 produces A thread 2 produces B and so on the 32 bit word output from thread 1 is 000A the 32 bit word output from thread 2 is 000B and so on. The relevant parts of the read words will need shifting by known amounts to produce the required outgoing word ABCD. The message data collectively illustrated as block is output on the message channel .

The locations of the required portions of the message may be determined from a specification of the message format step . The message specification may be provided as input to the process or may be hard coded as part of an executable program for generating the system.

For each thread an input element is generated based on the required portion s of the message and the address es of the required portion s step . The generated input thread includes storage for the required portion s of the message and logic for reading the required portion s from the message channel and storing the data in the input element s storage. The specification of the input element may be in a format suitable for the target implementation. For example if an FPGA is targeted for hosting an input element the specification may be in a hardware description language HDL . The specification of the input element may be further processed using the appropriate tools to obtain a configuration bitstream or executable code to realize an implementation of the input element.

An output element is also automatically generated based on a thread specification. From the thread specification the parts of the output message provided by the thread are determined step . As described above variables on the left side of assignment statements may be part of the output message. The process may recognize that for one or more parts of the output message the value in the output message is a copy or a straightforward translation of a value stored in the input element.

An output element is generated for each thread using the identified parts of the output message provided by the thread and any copies or translations of input values step . The output element includes storage for the data output by the thread along with storage for one or more values that are copies or simple translations of values from the input element. Example simple translations include incrementing and decrementing by a fixed value. The output element is also generated to include logic for reading translating any values copied or translated from the input element. As with the input element the generating of the output element may entail generating a specification of the output element in an implementation suitable format followed by further processing to obtain a realization of the implementation.

The concentrator may also be automatically generated from the thread specification and the specification of the output message. Any constants output by the thread are determined step . The constant values may be hard coded into the specification of the concentrator. The specification of the output message indicates the order in which data values in the output elements and the constant values are to be assembled for the output message. With the identified constants and data ordering of the output message the concentrator can be generated step . The concentrator reads data from the output elements in the required order merges constant values as appropriate and performs any required data shifting.

In one embodiment the thread specification and the specifications of the input message and output message may be input as data files to a tool that performs the processing described above. The tool may be implemented in software and perform the process steps without manual intervention.

The code in Example 2 below illustrates a programmatic specification of a system from which an example input element may be automatically generated.

From this code an automated processor based method may recognize that there are 5 threads Ethernet IP UDP RPC and ICMP. Thus 5 input elements are identified.

With the 5 identified threads the function of the concentrator may be determined from the following Table 1 generated from the system specification 

The definition of respective output elements for the different threads may also be determined from the programmatic specification of the system. For example in the system set forth in the code of Example 2 above the outputs produced by each thread are designated by the prime notation for example IP.DST ADDR . The concentrator is configured to read each of these outputs in the order specified by the particular protocol being handled and to interleave constants or fields from the incoming packet for fields which are not affected by the thread.

Each thread at an application appointed time begins processing the portion of the message selected and stored by the respectively coupled input element step . The processing performed on the data by the threads may be performed in parallel with application specific control between the threads as may be needed. While the threads are processing and if there is any data from the input element to be copied translated to the output element that data is copied step .

Data for an output message is written by each thread to the storage provided by an output element step . The concentrator reads data from the output elements and assembles and output message from the data along with any constants step .

In another embodiment the message definition is in the form of a data structure specification in a high level programming language and individual versions of the data structure are created for use with each of the different threads. Each version of the data structure contains only those variables accessed by the thread for which the version was created. Thus each thread may be compiled with only those part s of the data structure that are needed thereby avoiding unnecessary allocation of memory for unused parts of the data structure.

An example message definition is for a network packet. The data structure describes a generic packet and the fields of the structure define the fields in the packet. For example the fields in an IP packet include the IP source address the IP destination address version header length a checksum application data and other protocol specific information.

The process proceeds by determining for each thread those variables of a data structure that are accessed by the thread step . The code in Example 3 shows an example data structure used by each of a plurality of threads.

The example data structure may be shared by the threads by way of a header file specified in the source code of each of the threads. The source code of each thread may be processed to identify the variable s of the data structure referenced by thread and the variable s of the data structure not referenced by the thread. For example ds may be a pointer to the example data structure with the source code for thread A having the reference if 3 . . . the source code for thread B having the reference if 3 . . . and the source code for thread C having the reference if 3 . . . Assuming that thread A references neither ds y nor ds z thread B references neither ds x nor ds z and thread C references neither ds x nor ds y then the specification of the data structure for a thread may be changed to include only the variables referenced by that thread. The process creates for each thread a version of the data structure having only those variables accessed by the thread step and each version of the data structure may be written to a respective header file to be included in the source code for the thread step .

Those skilled in the art will recognize that the example data structure and example references to the data structure by threads A B and C are simplified for purposes of illustration. An actual application data structure would likely have one or more of the variables that are referenced by multiple threads and each of multiple threads may reference multiple variables in the data structure.

In one embodiment of the invention the set of primitives comprises FOP primitives COP primitives PIP primitives signal grouping primitives inter process communication primitives memory element primitives run time primitives implementation metric primitives and debugging primitives . Each of the aforementioned primitives is discussed in detail below.

The FOP primitives provide a coding environment targeting multiple threads that operate in parallel. The FOP primitives include instruction set primitives and physical implementation primitives . The instruction set primitives are used to program the threads. That is the instruction set primitives provide a mechanism for establishing an instruction set of a thread where the instruction set itself is programmable. Thus a designer may modify an instruction set for a thread as desired e.g. providing a domain specific set of instructions . The physical implementation primitives are used to define the physical implementation of a given thread. For example a thread may be implemented in programmable logic of an FPGA or in a hard or soft microprocessor or using a microcontroller.

In one embodiment each thread is implemented as a custom FSM in programmable logic of an FPGA. An instruction set is defined for the FSM thread where each instruction has a dedicated implementation. There is no additional support required for unused operations in the instruction set and multiple instructions may be executed simultaneously.

The COP primitives are used to include a function block into the design. In one embodiment the COP primitives comprise include type primitives for specifying a particular function block to include within the design.

The PIP primitives may comprise instruction set primitives and physical implementation primitives . The instruction set primitives are used to define an instruction set for a thread in a similar manner to the FOP primitives described above. Unlike the FOP primitives however the instruction set primitives may be used to define certain system instructions. The system instructions are used to communicate with input output interface logic blocks that communication with another system within the FPGA or external thereto . For example an interface logic block may be a gigabit Ethernet MAC core. The instruction set primitives provide support for different communication protocols to read write data over various interfaces. For example one type of interface may be completely streaming with data arriving at every clock cycle. Another type of interface may have flow control where there may be a pause in the data stream.

The physical implementation primitives define the physical implementation of the PIP e.g. FSM microprocessor . The PIP primitives may also comprise include type primitives for specifying the inclusion of the interface function block. Each interface block may have multiple ports or groups of signals associated therewith. One group of signals contains the connectivity to the external environment. The others connect to one or more PIP threads. For example an interface block may have a set of signals that form a receive port and another set of signals that form a transmit port. In this case the signals may be grouped together such that each port is assigned to a different PIP thread.

The signal grouping primitives are used to define signal groups. Grouping of signals may occur in various contexts such as when connecting an interface block to a PIP thread as described above or when connecting to a memory element. In such cases the programming information for an element such as a FOP thread states that the FOP thread is connected to another element.

The inter process communication primitives provide support for synchronization and data communication between threads. Some basic aspects of the mechanism such as support for starting stopping and suspending processes may be built into the soft platform architecture. Thread synchronization and data communication however may be completely specified by a designer. In one embodiment connections are explicitly specified between processes. Alternatively required connections may be inferred from the operations defined for a particular group of processes. For example an operation to start another process may have the form of START process or an operation to pass a data value to another process may have the form of PASS data destination process . With such an operation a connection may be inferred without a designer explicitly defining the connection.

The memory element primitives are used to define the various types sizes and interconnections of memory elements. The memory element primitives may include the MIDL primitives discussed above in the section entitled MEMORY MODEL for specifying the logical view of a memory subsystem.

The run time primitives may be used to apply run time reconfiguration. Run time reconfiguration involves the modification of a circuit implemented within an FPGA at run time. Dynamic reconfiguration for an FPGA is well known in the art. For example the run time primitives may be used to migrate functionality between programmable logic and an embedded processor. Initially some functionality is implemented in programmable logic with other functionality implemented using an embedded microprocessor. Implicitly the programmable logic implementation exhibits higher performance than the processor implementation. Functionality may be offloaded to the processor to save area within the programmable logic. During execution statistics may be taken to give feedback on the chosen partition. A reconfiguration controller determines a new partition and reconfigures the FPGA. An exemplary decision condition would be based on the frequency of events. More frequency events may thus be handled in programmable logic with less frequency events handled by the embedded processor.

The implementation metric primitives may be used to define the requirements of the system. For example the implementation metric primitives may be used to establish performance requirements that must be met. The implementation metric primitives may be used to create constraints files e.g. timing constraint files that can be used by FPGA design tools e.g. map place route tools . The implementation metric primitives may also provide low level optimizations e.g. clock frequency requirements throughput latency requirements as well as high level optimizations e.g. optimize for area throughput latency power and the like .

The debugging primitives may be used to provide debugging capabilities. The debugging primitives may be used to capture simulated data associated with the soft platform architecture. For example instead of presenting signal waveforms to the designer the debugging primitives allow for data presentation in a more abstracted form. The debugging primitives also provide lower level functions through the use of tags or commands that cause the circuitry to be modified and operate in a debug mode.

One or more aspects of the invention include design tools for designing MP systems memory systems and multithreading systems. Such design tools may be implemented using a computer. is a block diagram depicting an exemplary embodiment of a computer suitable for implementing processes methods and design tool sections described herein. The computer includes a central processing unit CPU a memory various support circuits and an I O interface . The CPU may be any type of microprocessor known in the art. The support circuits for the CPU include conventional cache power supplies clock circuits data registers I O interfaces and the like. The I O interface may be directly coupled to the memory or coupled through the CPU . The I O interface may be coupled to various input devices and output devices such as a conventional keyboard mouse printer display and the like.

The memory may store all or portions of one or more programs and or data to implement the processes methods and design tool sections described herein. Although one or more aspects of the invention are disclosed as being implemented as a computer executing a software program those skilled in the art will appreciate that the invention may be implemented in hardware software or a combination of hardware and software. Such implementations may include a number of processors independently executing various programs and dedicated hardware such as ASICs.

The computer may be programmed with an operating system which may be OS 2 Java Virtual Machine Linux Solaris Unix Windows Windows95 Windows98 Windows NT and Windows2000 WindowsME and WindowsXP among other known platforms. At least a portion of an operating system may be disposed in the memory . The memory may include one or more of the following random access memory read only memory magneto resistive read write memory optical read write memory cache memory magnetic read write memory and the like as well as signal bearing media as described below.

An aspect of the invention is implemented as a program product for use with a computer system. Program s of the program product defines functions of embodiments and can be contained on a variety of storage media which include but are not limited to i information permanently stored on non writable storage media e.g. read only memory devices within a computer such as CD ROM or DVD ROM disks readable by a CD ROM drive or a DVD drive or ii alterable information stored on writable storage media e.g. floppy disks within a diskette drive or hard disk drive or read writable CD or read writable DVD .

