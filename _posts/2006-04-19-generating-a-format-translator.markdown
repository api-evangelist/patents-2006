---

title: Generating a format translator
abstract: Generating code is disclosed. A specification of one or more translation patterns is received. The one or more translation patterns are used to generate at least a portion of code associated with a translator. Using the one or more translation patterns to generate at least a portion of code associated with the translator results in the translator being configured to create a target object model. Creating the target object model includes populating one or more elements of the target object model in a processing order at least in part associated with an order of elements in the one or more translation patterns.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07774746&OS=07774746&RS=07774746
owner: Apple, Inc.
number: 07774746
owner_city: Cupertino
owner_country: US
publication_date: 20060419
---
Often electronic content data do not consistently adhere to one standard on format organization and use in consistent software. For example each individual content data creator may choose to save electronic content data in various formats including a variety of text formats document formats spread sheet formats presentation formats visual graphic formats e.g. chart graph map drawing image formats audio formats multimedia e.g. video formats formats and database formats. This heterogeneous nature of the electronic content data can pose challenges when the various content need to be converted to a different format. Existing translation solutions typically require that heterogeneous content be converted into a common format. Translation from format A to format B is done in two steps an import from format A to the common format followed by an export from the common format to format B. This allows all possible mappings between N number of formats with 2N number of converters rather than N N number of converters that would be needed without a common format. However this common format method is inefficient requiring two conversions steps rather than one. Many standard tools for conversion to the common format operate at inconsistent semantic levels or encode an inappropriate semantic level potentially causing information needed to perform desired content management and or electronic publishing functions for example to be lost. As new file formats are created the current solutions are difficult to adapt to rapidly advancing software technology. Therefore there exists a need for a better way to convert electronic content.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer readable medium such as a computer readable storage medium or a computer network wherein program instructions are sent over optical or electronic communication links. In this specification these implementations or any other form that the invention may take may be referred to as techniques. A component such as a processor or a memory described as being configured to perform a task includes both a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. In general the order of the steps of disclosed processes may be altered within the scope of the invention.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

Specifying a format translation pattern and providing a mechanism for automatically generating translator code based at least in part on a collection of one or more such patterns is disclosed. In some embodiments the format translation pattern includes a way to represent one or more sets of similar features from different source content formats. In some embodiments the format translation pattern represents a common way of translating data structures without an assumption that those data structures represent similar features. The pattern includes a parameterization template for representation of the features as well as representation of the translations between corresponding features. In some embodiments a meta language such as XML Extensible Markup Language is used to represent the features and or the translation parameterization. In some embodiments a code generator takes a parameterized description of a feature of one or more content formats as input and outputs code that translates implements that feature. In some embodiments the pattern is one of a plurality of patterns.

As used herein format is defined as any information representation or schema. This may include schemas for streams database tables object models trees graphs and or other base data structures. A translator between formats is defined as any process that takes information in a source format as input and produces corresponding information in another target format as output. Parsers mappers and serializers are regarded as instances of translators and are defined as follows A parser translates from a stream based format into an object model a mapper converts between object models and a serializer translates from an object model to a stream based format. In some embodiments translators can be connected in sequence to make other translators. For example a stream to stream file format translator is created by connecting a parser with any number of successive mappers connected to a serializer.

In some embodiments the steps to create content conversion software include i analysis of the source content format ii creation of a parser iii mapping analysis iv creation of one or more mappers and v implementation of a serializer to the target format. For example in creating the parser a suitable collection of translation patterns is selected and their parameters are filled in using a language developed for the purpose of describing translator instances. The language includes constructs to specify how to query binary streams applicable to binary source files as well as other categories of source format such as text or XML. A parser generator reads in this translator specification and creates source code for a parser. That parser is compiled to object code. By applying the parser to a source content an in memory tree representation of the source content is created. This tree can be shown to a software developer with a tree view in an IDE Integrated Development Environment or serialized for example as XML for purposes of testing and further developing a parser. In some embodiments a rapid file format analysis tool that allows a user to discover the source format schema is used in an iterative process at each step a single modification to the translator specification is suggested by the user a new parser is generated a series of test files are parsed and the results are shown in a tree view or dumped as XML for inspection. The source and target of a mapper are both object models that can be similarly represented as trees in an IDE or as XML and it is possible to create a rapid mapping analysis tool that generates the mapper translator. Specifying a mapper also involves choosing a suitable collection of translation patterns and filling them in. The Queries used by a mapper are queries into an object model. If XML or another common meta language is used to represent both source and target of the mapper then mappers can be rapidly prototyped as translations of that meta language. For example XSLT Extensible Stylesheet Language Transformations can be used to prototype mappers when the source and target format are represented as XML.

At a format converter is generated. In some embodiments generating the format converter includes generating and connecting together one or more of the following a parser translator a mapper translator and a serializer translator. In some embodiments serialization is not performed by a separate translator but by serialization methods on the target objects of the mapper translator. In some embodiments one or more of the translators are specified using a common language such as an XML grammar designed to describe translator components and how they are connected together. For example data is communicated between translators using queries on intermediate object models. These intermediate object models can be described using a common meta language such as XML and the queries can be described using a common language such as XPath. In some embodiments one or more of the translators comprises a previously generated translator and or a component of another format converter. In some embodiments an input of at least one of the translators is the source content. At the format converter is used to perform the desired format conversion. In some embodiments more than one format converter is used to perform the desired format conversion. In some embodiments output of the desired format conversion is at least in part used in performing a desired processing. In some embodiments the format of the output is associated with an open standard and can be used to style view search augment edit or otherwise process the output. For example in some embodiments the output is in a SVG Scalable Vector Graphics format.

At one or more mapper translators are generated. In some embodiments a mapper translator translates at least a portion of content in one object model to another object model. In some embodiments by using a common API Application Programming Interface to access the object models and or using a common query language together with query compilers that turn this into to source code to accesses disparate APIs translator re use is maximized. In some embodiments generating the mapper translator includes using a parameterization specification associated with how to interpret one or more translation patterns to generate code for compilation interpretation as the mapper translator. At a serializer translator is generated. In some embodiments the serializer translator translates an object model of content to a stream based format such as a format associated with a saved file. For example in some embodiments an in memory representation of converted content is translated to a format associated with a file on a storage media. In some embodiments generating the serializer translator includes using a parameterization specification associated with how to interpret one or more translation patterns to generate code for compilation interpretation as the serializer translator. At one or more of the generated translators are connected together. In some embodiments connecting two translators together includes ensuring that they have been specified in such a way as to act on the same intermediate object models and linking all the code fragments that were generated from their individual pattern instances. By connecting the translators together a format converter is generated. In some embodiments the connections between the translators are optimized to create an efficient converter.

In some embodiments one or more translators are generated in parallel. For example generation of a translator is dependent on data associated with another translator and the dependent data is exchanged as the translators are generated. In some embodiments generation of one or more of the parser translator the mapper translator and the serializer translator is optional. For example when importing opening a file the serializer translator is not generated and when exporting saving content already in memory a parser translator is not generated. In some embodiments one or more pre generated translators are used e.g. if available and applicable.

At a function query constant tree is determined. Specifying an instance of a translator pattern requires a combination of three basic operations placing data obtaining data and manipulating data. For example an XML tag in a translation pattern for specifying each of these operations includes in some embodiments tag indicating constants for placing data tag indicating queries for obtaining data from the source content and identifying functions for manipulating data. Each individual parameter in the object model for a translation pattern can be filled in with a constant a query or a function. Within a function arguments can be filled in with a constant a query or another function. In some embodiments by filling in the translation patterns a function query constant tree is generated with interior nodes that are functions and leaf nodes that are queries or constants. In some embodiments the translation pattern is associated with a translation schema. The following is an example of the translation schema. The translation.xsd XML schema below encodes a parameterized object model for translation patterns as well as the function query constant trees that are used to specify instances.

At a translator is generated at least in part by using the function query constant tree. In some embodiments the tree is used at least in part to generate code that can be compiled interpreted to generate a translator.

In some embodiments a parser is generated in . For example an instantiated parser is associated with a tree of target objects under class membership. The children of a given object are among its member objects. The object model is defined by associating together a collection of parsing patterns. In some embodiments the association includes setting href attributes on elements of files adhering to the translation.xsd schema. Each target object implements a parse interface including a method to read itself. The code to do this is determined by the function query constant trees assigned to the pattern object model s parameters. A binary file format parser uses the binQueryType of element to specify file access. For example the binQueryType content model includes elements used to specify byte ranges. elements can contain other elements so that the final data query can be arrived at via a process of refinement in which ranges sub ranges and sub sub ranges identified. The binQueryType content model allows an optional element. If present this means that the query is to be performed on the stream output of the function identified by the element rather than on the source file stream. That function can be a member function of a parser target object and its inputs can be specified as file stream read operations and or further function calls. The implications for data flow are that parts of the file stream can be processed in stages each intermediate stage being another stream. The formalism and code generator are capable of handling these intermediate streams in the same manner as the original file stream. This is useful when the source format has any of the following features structured storage such as OLE DocFile or RIFF Resource Interchange File Format compression such as Huffman Lempel Ziv Welch arithmetic coding run length coding discrete cosine transform or fractal encoding such as Base64 UUencode BinHex Quoted Printable or yEnc Encryption such as RSA Diffie Hellman DES Blowfish IDEA or RC4 embedded formats and or proprietary obfuscation algorithms.

In some embodiments binary queries can access arrays of data just as XPath queries can. In particular multiple sibling elements are interpreted as an array of values. Furthermore an optional child of the element can be used to access repetitive byte sequences as arrays. This element specifies the maximum number of times to repeat the range specification the end of the stream or sub stream might be reached first. Often the data is something that must be read from file rather than a constant. The same is true of other elements used to express binary queries namely and . For this reason all four elements can have separate function query constant trees descending from them they all have type inputType . nodes can have children. Thus binQueryType elements have the unique feature that further elements can be descendants to any depth and there are many ways in which this can occur.

In some embodiments each element has and children to delimit the start and end of a byte sequence or bit sequence that is to be read and these delimiter elements can be interspersed with any number of elements to indicate ranges that are skipped over not read. and elements are all of type delimiterType and allows specification of a stream position by any of the following kinds of operations in the following order 

In some embodiments a mapper translator is generated in . In some embodiments the source of the mapper translator is output of a parser translator and the output is queried with the xpathQueryType of element. In some embodiments even though the queries of in memory objects and not serialized XML the xpathQueryType is used to specify the queries since it is convenient to describe object queries in terms of queries on the prescribed XML serialization of the objects even the serialization is not performed. The xpathQueryType of element has a required xpath attribute that encodes its data as a standard XPath. The XPath is interpreted as acting on the source object model where objects are interpreted as nodes and member objects are interpreted as child nodes. The context for the XPath is set by the code generated from the mapper pattern starting with a context node assignable to each mapper pattern object. XPath expressions that return node sets are normally turned into code that returns arrays as defined in the target language of the code generator.

In some embodiments a serializer translator is generated in . In some embodiments the serializer is implemented via an interface implemented by each of the objects in the mapper target format. This is optimized so that each mapper target object serializes itself as soon as all its information has been read in from the parser s target object tree. In some embodiments serialization is used for test purposes during development. For example the parser and mapper target objects implement the serialization interface in debug builds. Control flow usually begins at the root of the mapper target object tree. In the case of a translator that serializes its output control begins with a call to the root object s write member function. As with other objects in the target object tree this will trigger calls into the parser target object tree to access its member data which will be written out interspersed with calls to the write functions of child objects which are created as needed . When parser target objects are queried they will read their data in create any other objects on which they depend if not already created and query any other objects on which they depend. Generally dependence happens along lines of ancestry.

In some embodiments generating the translator includes generating code that can be compiled to the translator. In some embodiments the code is C code. The code generator uses XML written in the grammar of translation.xsd and performs a templating function derived by the input XML. In some embodiments XSLT is used to produce the C code. In some embodiments a translator consists of general code infrastructure into which specific generated code components plug in. The general code takes the form of a set of libraries that are statically linked and is needed to look after things like setting context variables managing input and output streams and managing information that permits streaming progressive rendering and memory use optimizations. The specific code components plug in by inheriting from library base classes and implementing library interfaces. These interfaces include handlers for the various parsing mapping and serializing tasks and they provide access to runtime variables affecting the specific code. In some embodiments there exists default code generators associated with master XSLT files that are imported into each individual pattern s XSLT file and whose individual code generating templates can be overridden. The default code generators generate C classes and member variables with naming and membership corresponding to the translation pattern s object model and they will provide a generic treatment for function query constant trees. Pattern specific overrides can for example create a target object model different from the pattern object model and can add member functions specific to each object. In some embodiments parser pattern overrides tend to leave the default target object model code generation in place but will change other things whereas mapper pattern overrides tend to replace the default with code generation for target objects that is unique to each pattern. This reflects the assertion that a parser s job is to faithfully construct an in memory object representation of the input information without fundamentally changing or re interpreting that information whereas a mapper s job is to apply whatever re interpretation is necessary to optimally map to target format constructs.

At the generated translator is verified. In some embodiments verifying the translator includes translating a test file and examining the output. In some embodiments examining the output includes presenting the output and or a representation thereof to a user and receiving feedback from the user. If the output is not entirely valid one or more translations patterns and or parameters are modified e.g. as specified or otherwise indicated by a user and the translator is regenerated with the modifications. In some embodiments regenerating the translator with modifications includes repeating as applicable. The verification and regeneration is performed until the translator is valid. In some embodiments the verification and modification is at least in part performed using a graphical interface tool. In some embodiments the verification is optional.

An object oriented library is the implementation of a collection of classes. Classes have properties and methods. The properties may be primitive objects such as integers or characters instances of other objects in the collection or collections of objects. Specific details vary based on programming language constructs support for reflection which permits run time inspection of arbitrary classes and or supported dispatch mechanisms. In some embodiments automated access to computer documents is often provided through an object oriented software library whose classes and methods provide access to everything in the document. The interface exposed by this library is the Application Programming Interface API . In some embodiments the API is fully abstract projecting all the information that is required by the consuming application but not providing any additional information. For example for a format that links together blocks of characters the API might simply provide access to the characters in order without exposing the linking mechanism at all. Such abstraction mechanisms are pervasive because they are crucial to the management of complexity in the development of real world software.

As used herein an abstraction is a projection or function from one domain to another. An API implements a projection of the binary data in a document to the data types it provides . In some embodiments the projected view is associated with a tree structure. In some embodiments document APIs are used for purposes such as mapping one format to another providing searching and indexing capabilities and or rendering the elements visually. Real world document API can be complex and developing software that uses them can be time consuming and costly. A document query includes extracting specific kinds of data from a content e.g. document using the API. In some embodiments the time it takes to develop software that uses the API can be reduced by using a language that specifies one or more queries for automatically generating program code.

For our purposes we define an element to be an object with a name and a possibly empty set of attributes. An attribute is an object with a name and a value that is a primitive object such as an integer a real number a character or a string. A tree is a set of elements E together with a partial ordering 

In some embodiments schemas are defined by providing a set of element names a set of attributes for each element and various constraints of the possible descendants of each element. Trees can support linked and cyclic structures through the use of reference attributes. In an object oriented programming language such as C trees are commonly implemented using a Composite pattern. Each element type is defined by a class with a common base class. The base class provides a container for the children. The element s attributes are defined by properties of the class. This implementation allows trees to be constructed and traversed from the root to a specific element. Implementations of trees do not always provide a means of traversing down the tree or to a sibling node these trees grow from the root downwards . A reference is an expression that uniquely identifies an element in a tree. There are various possible ways to express references. For example a finite sequence of numbers assuming directed trees can be used where an empty sequence designates the root of the tree otherwise the first number designates the child of the root the second number the index of its child. The number 1 designates a parent. Using this language a reference to any node in a tree from a given node can be specified.

In some embodiments a query takes a tree and returns data. A query can return one or more of the following a primitive value an element from the tree and an ordered set of elements. A query is an expression that defines an attribute element or set of elements for a given tree given a specific element the starting position of the query . References augmented by a period . and a name for attributes and special operators such as descendants and ancestors can be used to define a query language. In the XML query language XPath these operators are called axis specifiers. A filter may be added to a query where a filter is a predicate that can determine whether or not to include a node or attribute in the query result. A step is a triplet where a is an axis specifier n is a node test and F is a possibly empty set of filter tests. A query is a pair where a is either absolute or relative and S is a sequence of steps. Intuitively absolute queries start from the root of a tree while relative queries start from some given position in the tree. The notation P.t is used to indicate a query made up of a sequence P of steps and a single step t. P is called the prefix of the query. The example above is not dependant on any particular realization of a tree based or xml based query language. The XPath language is a widely used example of a query language and all queries as defined here can be expressed using XPath syntax.

In some embodiments the code generated by a given translation pattern executes in an order unique to that pattern. Normally this means that the document order of the elements in the pattern s parameterized object model is the order in which these parameters are read in and each element of the target object model is created as soon as all the information needed to produce it has been read in. When information is available for creating multiple output objects simultaneously the output objects are created in output object model document order. When serialization of the output object model is needed or desired the elements are serialized in a separate thread in document order up to the last element whose existence name and attributes are known to be complete. This method ensures that information is streamed out as soon as possible which permits the progressive display of information by an application during the translation process.

The following is an example of the order of execution of code associated with one element s specification Its function query constant tree is traversed in document order. When a is encountered the specified constant is just instantiated and assigned in memory. When a is encountered the corresponding function is called in a function library linked to the generated code. When a is encountered that query is executed according to the methods described later in this document.

Some objects in the parameterized object model for a given pattern have parameters and others do not. The ones without parameters are represented by a reference to another pattern instance or the same pattern instance as in the following example 

In some embodiments an efficient method is used to create and serialize target objects. The base class for each target object in the target object tree has a state variable that takes one of the following values for example as an enumeration in C 

In some embodiments target objects can be re used. In some embodiments functions given in function query constant trees can be methods on objects in the target object model. If data computed by one generated code fragment is needed by another generated code fragment then the first code fragment can store it in the target object tree and the second code fragment can access the data there. This avoids unnecessary re computing of results. Even if the re used data is just an intermediate result and is not to be serialized it can be stored in the target object tree with serialization methods that do nothing. Another option is to create custom objects just for the purpose of storing intermediate results and to access their methods in pattern instances. When accessing target objects in this manner the writable state is used to determine whether the object s name and attributes can be accessed and the completeness state is used to determine whether an object s children can be accessed. The generated code can do lazy querying of the source document only actually implementing the queries that are used to fill out the target objects when the information is needed.

In some embodiments output content is written as a stream. The states can be used to determine how much of the tree can be safely serialized without backtracking in the output stream even though the tree could be built in memory in any order. The serializable portion can be efficiently updated just by checking the states of neighboring elements rather than having to traverse the whole tree every time there is a change. When generated code determines that a notWritable element s name and attributes are ready to be written out it calls a writable method that does the following If the previous element in document order is complete or disposable and lastWritable written or lastWritten or if there is no previous element because the current element is the root then the current element is changed to lastWritable and if the previous element was lastWritable it is changed to writable otherwise the current element is changed to writable. Furthermore when generated code determines that an incomplete element is now complete it calls a complete method that changes the state to complete and if that element is also lastWritable written or lastWritten then iterates forward in document order and calls writable on each element until encountering the first element that is not writable. This has the effect of moving the lastWritable position forward as far as it can go. A separate thread can actually do the writing at any time from the lastWritten element to the lastWritable element when one exists or a write method can be called every time the state of an element changes to lastWritable. The write method writes an element s start tag and attributes after closing any needed end tags then changes the element s state to written unless the element before it in document order is lastWritten in which case it changes the element s state to lastWritten and the previous element s state to written. 

In some embodiments memory can be opportunistically purged. In some embodiments target elements are marked as disposable when they have been written and they are no longer going to be accessed. In the case of a memory exception or internally imposed limit any subtrees that are entirely disposable can be deleted to free up memory.

In some embodiments standards for code included in the generated source codes includes one or more of the following standards 

In some embodiments a special variable called currentNode is assumed to be a reference to a node in a tree. In some embodiments a collection of variables called attributeValueT is set to the result of an attribute query where T is the type of the attribute value. In some embodiments given a query and the schema the compiler can determine the kind of query where the kind can be attribute element or sequence of elements. If Q is a query we write kind Q to indicate the kind of the query.

In some embodiments a query is a sequence of steps each step is a triplet and the query s kind can be determined. For example queries can be written as P.s where P is a possibly empty sequence of steps and s is a step. In some embodiments the generated code can be fully determined by the schema and the coding standards.

The generic query compiler has a class for every possible node test. These classes all inherit from a base class that provides a standard compileQuery method. The compiler starts by examining the step . Using a factory an instance of the class corresponding to n is created. Its compileQuery method is then called passing the entire query. In some embodiments this method allows the subclass method to by pass the normal code generation pattern if necessary.

A standard way to implement the compiler is to provide a class with generic methods for each of the cases described below. For example a method of this class is 

The following is an example of compiling element node tests. When the node test is a simple element name there are three code patterns one for each kind of query. In the case where the kind is not sequence the query specifies a single value accessed from a single element in the source tree. Prefix of the query must be of kind element. Whenever code is generated for an element the variable currentNode will be set to the appropriate node. The following is an example of the three code patterns.

Kind sequence In this case instead of returning all the elements that satisfy the node test the compiler creates an iterator. The kind of the prefix also determines the output code pattern. If kind P element then the generated code obtains an iterator for the node test using

The constructor and nextElement can be overwritten to take advantage of the existence of a specific iterator method in the parent object that provides an iterator for children with the given name. There are slightly different patterns for kind P sequence and kind P element. Thus the generated iterator for a node test whose element name is Elt will be 

The following is an example of compiling code for filters. A step that contains a sequence of filters is of kind sequence. An iterator is generated for each filter. There are two types of filters a literal index a positive integer and an expression. The code generated for expressions is a copy of the filter except that any embedded query is compiled first. In the special case of node .attr the generated expression is currentNode getAttr . The iterator for a filter F where EXPRESSION F indicates the expression corresponding to the filter is 

In some embodiments there exists an object identified as document with a method named root that returns the root element of the document. For the example query 

Although it is always possible to compile code for arbitrary queries the compiler may constrain the queries allowed to avoid generating inefficient code. For example if the API does not provide a getParent operator then queries such as

In some embodiments a real world API has partial compliance to the coding standards implied by the assumption stated above. A general method for extending the code generator described above so that it can generate code that works for any document API is disclosed. The document schema is independent of any particular coding standard. The purpose of the schema is to provide developers with a uniform and consistent view of the data in documents. This can be thought of as a virtual API for the document. The actual API may be designed with particular design criteria that are not directly compatible with the schema. Examples include attributes that can be inferred but are not provided directly which we call synthetic attributes mechanisms for navigating through the document which do not follow the straight forward tree traversal methods implied by the schema and performance requirements satisfied either by providing methods and classes that are not part of the schema or by placing constraints on API calls. Traditionally it was up to developers to determine from the API documentation and perhaps by trial and error how to use the API to effect particular queries. The query compiler represents an encapsulation of this knowledge in a useful form.

In some embodiments the generic code generator uses a distinct class for each node test and the code generation methods for each node test are independent. The code generator is presented with the entire query before the query prefix is used to generate code. The code generator for a particular node test can control the overall code pattern. For example the code generator for a particular element E could even use a pattern different from the prefix P that it is given. These two points allow the code generator to emit code patterns that vary widely from the generic patterns. The following are examples.

Access to text Conceptually a body of text can be considered to be the value of an attribute of an element. In practise text is usually treated differently mainly because the size of text objects may be large. The node test in XPath for text is text . The generic compiler generates elt getText but the document specific compiler will generate code which is consistent with the API s requirement for accessing text.

Synthetic Attributes A synthetic attribute is defined in the API documentation as an attribute that is not present but whose value can be computed. An example arises from a common pattern in the PowerPoint schema where the siblings of an element are grouped using a marker element. For example all the text for a presentation is stored in a section of the document whose element is called slideListWithText . For each slide in the presentation there is a sequence of elements in the children of slideListWithText such as

Streaming Access Generally there are two models for accessing documents which we will call the DOM approach and the Streaming approach. In the DOM approach the API provides a method or small collection of methods that effectively builds an entire tree structure for the document in internal memory. Once this call returns the program need make no further access to an external memory device when accessing parts of the document. It is generally a property of this model that the time taken to access to any property of the document is only dependent on the properties height in the tree. For example it takes the same time to access the first and last child of the root of the tree. 

In the Streaming approach the API provides methods for accessing the document one part at a time. In some instances the order in which the parts are delivered corresponds to the order in which they appear in the documents external file. However even if the order in which the parts are delivered is different from the file layout a streaming interface can be prefereable to a DOM interface because it requires less memory than a DOM approach. This is especially important in processing large documents. Complex APIs may permit both streaming and DOM approaches but overall design considerations might determine which approach is used. We will illustrate the generality of the query compiler with an another example from Microsoft s PowerPoint. Consider the XPATH expression

The iterator relies on a design pattern in the API the so called reader works by looking for the next object in the document from its current location that corresponds to the type of argument it is passed. The methods seek and read are similar the difference is that seek does not populate its argument it simply positions the internal read position of the reader. Node that the API uses polymorphism rather than introspection to implement the read methods. In other words there is a family of read methods one for every object type. This allows the API s implementation to optimize access on an element by element basis. 

In this example because the factory method created a PptTextObject each call to the reader s read method will return the next text object. The compiler can make use of the knowledge that although the text elements are children of the second occurrence of slideListWithText no descendants of the first instance have an element named text. In other words the compiler methods can produce code that takes advantage of specific information that may not be part of the schema. Note further that the only use made of the Prefix in this case is to check that it is valid. No code is generated for the Prefix.

Aggregated Schemas Many real world document formats are an amalgamation of distinct schemas. Furthermore it is even possible that the coding standards differ for distinct parts of the schema. The implication of this is that access to elements is not uniform usually dealt with by developers using if tests in their code. However our invention solves this problem by permitting the code of each iterator to overide the generic iterator code. For example consider an XPath query like

As an example consider Escher a schema used for representing graphical objects that is used in the entire family of Microsoft Office products. The Schemas for the individual formats Excel Word Powerpoint differ substantially but they all permit the embedding of Escher objects. The way that Escher is actually used differs in each case so it is not possible to generate generic Escher code that works with all three formats. On the other hand any library that provides a Microsoft Office API will provide a section that works with Escher that is likely to be common. The implication for developers is that access to children of an element in a document tree will differ for Escher elements and other elements. Our code generator accommodates these differences through the use of iterators as discussed above.

In some embodiments XML can be used to describe various aspects of the methods described here. For example schemas can be described using XML XML Schemas . Instances of documents can be expressed using XML. A document API can be used to create a tool that maps any document to its XML form where the XML form is valid with respect to the schema. Developers can examine document structures as if they were XML documents simplifying their task of deriving XPath expressions for query parameters. In some embodiments one or more of the approaches described above offer at least two advantages. First an approach described above is general and can create target objects whose structure is significantly different than the source. Although this can be done with XSLT in some cases the XSLT programs become very complex in these situations. Second an approach described above is more efficient because translators are compiled rather than interpreted. The step of mapping to XML is not actually performed since the compiled queries use the API directly and the code for extracting data from the source document is compiled. Since XSLT output is an XML file there may be an additional step required to create a binary target file whereas an approach described above permits such files to be created optimally.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

