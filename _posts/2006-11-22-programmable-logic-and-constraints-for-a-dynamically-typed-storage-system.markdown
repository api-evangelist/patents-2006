---

title: Programmable logic and constraints for a dynamically typed storage system
abstract: Embodiments define a set of rules such that a type designer can express as part of a type's definition whether the type has extended the logic and/or constraints of its ancestral types in such a way that applications written against that ancestral type will continue to function correctly. Nonconformity can also be indicated and an embodiment can enforce limitations on a set of operations that can be performed on such instances when treated as their ancestral types. Applications can use standard interfaces to discover from embodiments whether such limitations can be in force for a particular instance and provide a user experience that accounts for those limitations. Embodiments can also provide mechanisms to enable type designers to limit a degree of extensibility for both types and/or Items.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07801926&OS=07801926&RS=07801926
owner: Microsoft Corporation
number: 07801926
owner_city: Redmond
owner_country: US
publication_date: 20061122
---
This application is related to co pending and co assigned U.S. applications VERSION TOLERANT SERIALIZATION filed on Mar. 31 2005 and assigned Ser. No. 11 094 923 DATA MODEL AND SCHEMA EVOLUTION filed on May 13 2005 and assigned Ser. No. 11 128 893 and SCHEMA GRAMMAR AND COMPILATION filed on Jul. 20 2005 and assigned Ser. No. 11 185 155 which claims priority to provisional application entitled SCHEMA GRAMMAR AND COMPILATION filed Feb. 28 2005 and assigned Ser. No. 60 657 521. The above noted applications are incorporated herein by reference.

In a dynamically typed storage system a shared data store e.g. database provides common backing for a varied collection of applications. A unit of storage is an item formed by a collection of smaller units called entities with one Entity acting as a core or central Entity. Each Entity is associated with a physical type and a whole Item expresses a logical type based on the superposition of all contributing physical types but strongly biased by the type of its core Entity. Applications are implemented in terms of either the physical and or logical types and perform a set of operations on the instances of those types including but not limited to reading updating and complex instance specific operations e.g. Verbs Methods etc. .

Types both physical and logical form a hierarchical structure such that one type is said to derive from another. An instance of a subtype may be treated as and operated on as if it were any of its ancestral types. Subtypes may extend but not alter the data definition logic or constraints of its ancestral types. In addition supplementary Entity instances may be composed with existing Items and are said to extend or augment the data of that instance. The logical type of that instance so extended can similarly be treated as or operated on as if it were the logical type without such extensions.

The data in the storage system is shared and operated on by all applications such that no application owns a specific piece of data or controls the ability of other applications to use or extend that data subject to security and policy. Physical types may be introduced to the system at any time that extend existing types and the definer of a type is a distinct agent from the applications that use that type though in practice applications will likely act to introduce types they intend to use if they are not already available . Because types may be introduced at any time no application can be expected to implement the appropriate logic for all types whose instances it may encounter.

Thus it is desirable to obtain a dynamically typed storage system such that the system can allow type designers to express the logic and constraints necessary to ensure the consistency of a type s instances both at the Entity and Item level. It should also allow the most interactive use of instances while disallowing operations that would violate the consistency of its type. Applications should also be allowed to be written without implementing or executing the logic of types unknown at the time of development. It is also desirable to allow the type system to continue to be extended with new types both physical and logical without adversely impacting existing applications ability to execute in a predictable manner.

A framework in which object types can be defined along with logic and constraints is provided. This allows embodiments to define a set of rules such that a type designer can express as part of the type s definition whether the type has extended the logic and or constraints of its ancestral types in such a way that applications written against that ancestral type will continue to function correctly. In the event that a type extends in a manner that does not conform to the logic implemented by its ancestral types a type can so indicate and an embodiment can enforce limitations on a set of operations that can be performed on such instances when treated as their ancestral types.

Applications however can use standard interfaces to discover from embodiments whether such limitations can be in force for a particular instance and provide a user experience that accounts for those limitations e.g. a read only mode or grayed UI etc. . Furthermore embodiments can provide mechanisms to enable type designers to limit a degree of extensibility for both types through subtyping and or Items through composition of supplementary Entities thus ensuring that the full rich experience of existing applications need not be encumbered by over extension.

The above presents a simplified summary of the subject matter in order to provide a basic understanding of some aspects of subject matter embodiments. This summary is not an extensive overview of the subject matter. It is not intended to identify key critical elements of the embodiments or to delineate the scope of the subject matter. Its sole purpose is to present some concepts of the subject matter in a simplified form as a prelude to the more detailed description that is presented later.

To the accomplishment of the foregoing and related ends certain illustrative aspects of embodiments are described herein in connection with the following description and the annexed drawings. These aspects are indicative however of but a few of the various ways in which the principles of the subject matter may be employed and the subject matter is intended to include all such aspects and their equivalents. Other advantages and novel features of the subject matter may become apparent from the following detailed description when considered in conjunction with the drawings.

The subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the subject matter. It may be evident however that subject matter embodiments may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the embodiments.

As used in this application the term component is intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a computer component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Embodiments herein provide a framework in which object types can be defined along with logic and or constraints. This allows a set of rules utilized by a type designer to define whether a type has extended the logic or constraints of its ancestral types. This allows continued function of applications written against that ancestral type. A type can also indicate that it no longer conforms to logic implemented by its ancestral types and embodiments can then impose limitations on a set of operations that may be performed on such instances when treated as their ancestral types. Embodiments can also provide mechanisms that allow type designers to limit the degree of extensibility for both types and Items to ensure that existing applications are not hampered by over extension of an object type.

Embodiments can indicate the manner in which types show their compatibility with their supertypes both at an Entity level trust relationships between physical types and or at an Item level structural composition definition and enforcement . Embodiments can also utilize partial materialization metadata at an instance level coupled with type specific metadata on compatibility to make operational decisions at run time e.g. IsWritable see infra along with algorithms for enforcement of those decisions e.g. SaveChanges see infra . Embodiments can also have the ability to define both application based logic e.g. IsValid see infra and system based logic e.g. Policy see infra and or to define both data definition e.g. NotValidated Properties see infra and operations Platform Verbs that cannot be extended. This allows the most interactive use of object type instances without violating the consistency of types.

Dynamically typed storage systems or object persistent systems such as for example Microsoft s WinFS typically have a type system as a core component that allows software developers to define a conceptual type so they can produce a type called car for example which might have properties such as for example a manufacturer model year maximum speed etc. Once a type is defined the system is provisioned to store instances of that type. Subsequent software developers can create subtypes such as for example four wheel drive car sports car etc. that are known as derived types. Applications that expect a type called car may not act appropriately when they encounter a subtype called sports car. This impacts reliability and predictability of the software.

The extended type system allows type designers the ability to control for example how derivations and also future versions of types can change. Thus application developers have more explicit control and types are under more explicit control over how versioning and subtyping influence how their applications run. In one embodiment of the extended type system for example a set of augmentations to a schema grammar which utilizes extensible markup language XML allows a developer to augment the XML to control these type constraint characteristics. Run time logic is then created by the extended type system such that when applications attempt to interact with instances of these type classes the interactions are constrained by declarations that were previously introduced into the XML.

An extended type system which resides with an object persistent system is shown in . The extended type system employs an extended type component that accepts type constraints from a software developer and a type change from a software application and determines if a type persistent modification can be provided. The extended type component utilizes a run time logic component that receives type constraints and creates run time logic based on those type constraints. The extended type component also utilizes a limitation enforcement component that enforces the run time logic and the constraints for a given type. When a change to a type definition passes the run time logic and or constraints the type definition change can be saved as the type persistent modification . The extended type component also utilizes an ancestral association component that receives type changes and determines if the associated type is treated as an ancestral type. Under those conditions the ancestral association component interacts with the limitation enforcement component to enforce any logic and or constraints regarding that type.

Often a client server relationship exists between a dynamically typed storage system and a user or application. illustrates client server interactions for an extended type system. Thus functionality for the extended type system can reside on a client and or a server . The server in this example provides interaction capabilities with both the client and storage for the dynamically typed storage system. The client side logic for the extended type system can receive a requested data object type and apply constraints and or logic indicated by the server side logic of the extended type system for that particular data object type. The server side logic on the server reads the data object type from the storage when requested by the client . Indicators representative of structure and or trust relationships and the like described in detail infra can also be stored along with the data object type. These indicators are typically set by type designers during software development of a core or super type. Thus the client side logic can interpret these indicators and determine if a software application running on the client can augment the data object type. If so a modified data object type can be sent to the server from the client for saving to the storage . The server side logic can then apply additional logic regarding constraints and or logic policy if necessary to determine if the modified data object type can be persistently stored in the storage . The logic and or constraints are atomically applied and thus any failure prohibits writability. If successful the modified data object type is then written to storage . Determination of the logic and constraints are described in greater detail infra.

It should be noted that a storage system utilized herein can have any appropriate structure including 1 2 or 3 tier or even n tier systems where n is an integer from one to infinity. A first tier can be multi tiered as well. For illustration purposes a 2 tier system is assumed which can be modeling an n tier system such that the second tier of the system is meant to encompass other tiers except a client tier. When system based logic is referred to no distinction is made as to which of these backend tiers that logical is implemented in.

A dynamically typed storage system data model and schema language typically define a type system and its associated storage such that types can be introduced dynamically at any time. Multiple applications can be implemented against these types utilizing different subsets of those types known to the system. Applications are written against code implementing the client side logic for a type. Different versions of a type can exist at different times but the system only knows about a single version at a time and subsequent versions are additive only evolutions of previous versions. Subtypes of existing types can be created at any time. Subtypes are additive relative to their ancestral types and an application can be written against an ancestral type when dealing with an instance.

An application programming interface API can provide a set of services allowing applications to communicate with a storage system. The API provides services for example such as reading a database automatic materialization update tracking and or saving of changes and the like. The API provides hooks for logic and policy injection and enforcement the nature of which can be augmented see infra .

Embodiments provided herein allow a dynamically typed storage system schema language such as for example the WinFS schema language to be extended such that each type has two additional Boolean attributes TrustsPreviousVersions and TrustsSuperType. These attributes indicate whether the type s logic and or constraints are compatible with its previous versions and or supertype respectively such that an instance of this type partially materialized cannot be edited in any manner such that it violates this type s logic or constraints. A type declares its trust only to its immediate supertype. When partial materialization fails to materialize multiple subtypes in the instance type hierarchy each type s trust declaration is examined in turn and the instance s trust level is defined as the Boolean summation of these calculations.

Each type has an additional optional multi valued attribute StructuralCompositions listing by name the set of compositions that can be used to form an Item with this type as the core Entity. These compositions are considered structural. Only those Entities in the Item Entity graph connected to a core Entity by an unbroken chain of structural compositions can be considered for consistency. This enables logic and constraint aspects to span multiple Entities where more than one type is involved. Limiting consistency to structural compositions allows type designers to protect application stability and predictability from over extension. Type designers can provide a set of structural compositions that provide a balance between the immediate needs of the application and extensibility without opening types up to unfettered extensibility that can render existing application experiences unmaintainable given the logic enforcement policy described infra.

Each composition has an additional Boolean attribute CanBeStructural indicating its applicability for membership in a type s StructuralCompositions set. Only those compositions with a value of True for this attribute can appear in the StructuralCompositions set of a type. This opt in model for compositions allows applications to create Entities explicitly attached to Items for open data extensibility without impacting other applications experiences. An Entity attached to an Item by a non structural composition can never cause a degraded experience in an application that lacks the logic for that Entity since that Entity will never be considered for consistency. Marking a composition as CanBeStructural False ensures that no type places that composition in its StructuralCompositions set and infringes the open extensibility intension of the composition designer.

Each property on a type has an additional Boolean attribute NotValidated indicating whether that attribute can participate in logic or constraints. Properties marked as NotValidated True never play a role in the consistency of an Item. Application experiences designed over NotValidated True properties can never be degraded regardless of what the most derived type of the instance is or the set of logic available to the application. Since NotValidated True properties don t participate in the consistency of an Item they are always safe to update regardless of whether consistency can be evaluated.

Embodiments provided herein allow a dynamically typed storage system API such as for example WinFS API s to extend change tracking and update systems such that all entities read from a storage system can be subject to partial materialization and a BitBucket can be populated for all non materialized data. Metadata can also be available for all types in the system regardless of what subset of types an application contains logic implementation for. This metadata can indicate a set of new annotations detailed in the schema language changes supra. Update parameters such as for example WinFS s SaveChanges can now perform the following additional steps while enumerating a set of changed Entities for persistence 

For each changed entity IsValid is called on Entities participating in a structural closure of an Item to which the Entity belongs. If the Entity is not structural relative to the Item to which it belongs the closure is defined to include the Entity itself and nothing else. If the Entity is structural relative to the Item the closure is defined as the set of Entities reachable from the core Entity via structural compositions. The set of Entities in the closure is determined by the true Metadata. Objects in the closure that are not already loaded are loaded immediately and IsWritable is called on them. No logic including IsValid for types not materialized is run by the application. Determination of whether it is safe to execute only the logic of the materialized types is determined by IsWritable above. IsValid is a non virtual method that succeeds if and only if the Entity in its post change state meets the consistency requirements of the type on which it was implemented. Though IsValid is non virtual it can have overloaded implementations at one or more types in the type hierarchy. Each implementation is called in turn and no type can prevent its super or sub types implementation from being run. The order in which all overloads of IsValid for a given instance are executed is not defined herein as different implementations can choose different orders. For example WinFS implements an order such that ancestral types IsValid is executed before subtypes. IsValid cannot make additional modifications to an instance but only gives an assessment of the correctness of the current set of modifications. If consistency is not met an exception occurs and the update fails.

Method execution for type method can be extended such that instance methods not marked as Platform Verbs before executing call IsWritable on the Entity. This ensures that the appropriate version of the method particularly in the case of virtual methods is available in the application for execution. The body of the method can additionally call IsWritable on other Entities if broader guarantees of materialization are required such as Item level writability . Instance methods marked as Platform Verbs execute immediately and their modifications can be written to the storage system without being subject to locally available logic. These methods are still subject to storage system based logic Policy . An example of a Platform Verb might be the Delete method. No particular application can override or alter the behavior of the Delete method on a type by type basis but it can still be subject to system wide policy implemented in the storage system.

In view of the exemplary systems shown and described above methodologies that may be implemented in accordance with the embodiments will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the embodiments are not limited by the order of the blocks as some blocks may in accordance with an embodiment occur in different orders and or concurrently with other blocks from that shown and described herein. Moreover not all illustrated blocks may be required to implement the methodologies in accordance with the embodiments.

The embodiments may be described in the general context of computer executable instructions such as program modules executed by one or more components. Generally program modules include routines programs objects data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various instances of the embodiments.

In a flow diagram of a method of extending types of a dynamically typed storage system in accordance with an aspect of an embodiment is shown. The method starts by determining whether a type has extended logic and or constraints of its ancestral types . The determination can include both client and server side logic and can also utilize indicators set by software developers for a core or super type. Limitations on a set of operations that can be performed on an instance of the type are then enforced when the type is treated as their ancestral type and has extended logic and or constraints ending the flow . The limitations can include strictly constraints or logic. The run time logic is generally derived from constraints associated with an ancestral type.

Turning to a flow diagram of a method of extending a schema language for a dynamically typed storage system in accordance with an aspect of an embodiment is illustrated. In one example embodiment the foregoing can be implemented utilizing extensible markup language XML and the like. The method starts by employing at least one Boolean attribute to indicate whether a type s logic and or constraints are compatible with its previous versions and or supertypes . For example as noted supra TrustsPrevious Versions and TrustsSuperType Boolean indicators can be utilized. With these attributes an instance of this type partially materialized cannot be edited in any manner such that it violates this type s logic or constraints. A type declares its trust only to its immediate supertype. When partial materialization fails to materialize multiple subtypes in the instance type hierarchy each type s trust declaration is examined in turn and the instance s trust level is defined as the Boolean summation of these calculations.

At least one multi valued attribute is utilized to indicate a set of structural compositions that can be employed to form an item with the type as a core entity . Only those Entities in an Item Entity graph connected to a core Entity by an unbroken chain of structural compositions can be considered for consistency. This enables logic and constraints to span multiple Entities where more than one type is involved. Limiting consistency to structural compositions allows type designers to protect application stability and predictability from over extension. Type designers can provide a set of structural compositions that provide a balance between the immediate needs of the application and extensibility without opening types up to unfettered extensibility.

At least one Boolean attribute is employed to indicate applicability for membership in a type s set of structural compositions . Only those compositions with a value of True for this attribute can appear in the StructuralCompositions set of a type. This opt in model for compositions allows applications to create Entities explicitly attached to Items for open data extensibility without impacting other applications experiences. An Entity attached to an Item by a non structural composition can never cause a degraded experience in an application that lacks the logic for that Entity since that Entity will never be considered for consistency. Marking a composition as for example CanBeStructural False ensures that no type places that composition in its StructuralCompositions set and infringes the open extensibility intension of the composition designer.

At least one Boolean attribute is utilized to indicate whether a property on a type can participate in logic and or constraints ending the flow . For example properties marked as NotValidated True never play a role in the consistency of an Item. Application experiences designed over NotValidated True properties can never be degraded regardless of what the most derived type of the instance is or the set of logic available to the application. Since NotValidated True properties don t participate in the consistency of an Item they are always safe to update regardless of whether consistency can be evaluated.

Looking at a flow diagram of a method of extending a change tracking and update system application programming interface API for a dynamically typed storage system in accordance with an aspect of an embodiment is depicted. The method starts by reading entities from a data object storage system subject to partial materialization and populating a BitBucket with all non materialized data . Metadata availability for all types in a system is ensured regardless of what subset of types an application contains logic and or operations for . The metadata indicates a set of new annotations. Changes are saved while enumerating each changed entity for persistence ending the flow . Details on saving the changes are provided supra and infra.

In a flow diagram of a method of saving type changes for a dynamically typed storage system in accordance with an aspect of an embodiment is shown. The method starts by writing a change to a storage system if all changes to an entity are to NotValidated properties . For each changed entity if all of the changes to an Entity are to NotValidated properties the change proceeds and the changes are written to the storage system with no further action. An update for a set of entities is failed when a type in a BitBucket does not indicate a trust relationship with an actual materialized type . For example for each changed entity IsWritable can be called. IsWritable is a non virtual method that examines the Entity s BitBucket and optionally any BitBuckets for nested complex types within the Entity and cross references the non materialized types in the BitBucket with the Metadata for those types. If any type in the BitBucket does not indicate transitively in some cases a trust relationship with the actual materialized type then update for the Entity fails and an exception is thrown

Correctness of a current set of modifications is assessed utilizing IsValid . For example for each changed entity IsValid can be called on Entities participating in a structural closure of an Item to which an Entity belongs. If the Entity is not structural relative to the Item to which it belongs the closure is defined to include the Entity itself and nothing else. If the Entity is structural relative to the Item the closure is defined as the set of Entities reachable from the core Entity via structural compositions. The set of Entities in the closure is determined by the true Metadata. Objects in the closure that are not already loaded are loaded immediately and IsWritable is called on them. No logic including IsValid for types not materialized is ever run by the application. IsValid is a non virtual method that succeeds if and only if the Entity in its post change state meets the consistency requirements of the type on which it was implemented. Though IsValid is non virtual it may have overloaded implementations at one or more types in the type hierarchy. Each implementation can be called in turn and no type can prevent its super or sub types implementation from being run. IsValid cannot make additional modifications to the instance but only gives an assessment of the correctness of the current set of modifications. If consistency is not met an exception occurs and the update fails.

Each entity whose changes are written to the storage system is evaluated utilizing storage system based logic applicable to an entity . For example this logic may apply to both types materialized by the application and types not materialized by the application because the storage system is always aware of the total set of types in the system. Storage operations on a set of entities are atomically allowed or disallowed based on any failure of IsWritable IsValid or policy of any entity ending the flow . For example any failure by the IsWritable or IsValid methods or Policy of any Entity in the set or its closures prevents changes from being committed for all Entities in the set.

Referring to a flow diagram of a method of extending method execution for a type method for a dynamically typed storage system in accordance with an aspect of an embodiment is depicted. The method starts by calling IsWritable on an entity when instance methods are not indicated as Platform Verbs . This ensures that the appropriate version of a method particularly in the case of virtual methods is available in an application for execution. The body of the method can additionally call IsWritable on other Entities if broader guarantees of materialization are required such as Item level writability . Modifications to a storage system of instance methods indicated as Platform Verbs are immediately executed ending the flow . Instance methods marked as Platform Verbs execute immediately and their modifications are written to a storage system without being subject to locally available logic. These methods are still subject to storage system based logic Policy .

In order to provide additional context for implementing various aspects of the embodiments and the following discussion is intended to provide a brief general description of a suitable computing environment in which the various aspects of the embodiments can be performed. While the embodiments have been described above in the general context of computer executable instructions of a computer program that runs on a local computer and or remote computer those skilled in the art will recognize that the embodiments can also be performed in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations including single processor or multi processor computer systems minicomputers mainframe computers as well as personal computers hand held computing devices microprocessor based and or programmable consumer electronics and the like each of which can operatively communicate with one or more associated devices. The illustrated aspects of the embodiments can also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the embodiments can be practiced on stand alone computers. In a distributed computing environment program modules can be located in local and or remote memory storage devices.

With reference to an exemplary system environment for performing the various aspects of the embodiments include a conventional computer including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The processing unit can be any commercially available or proprietary processor. In addition the processing unit can be implemented as multi processor formed of more than one processor such as can be connected in parallel.

The system bus can be any of several types of bus structure including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of conventional bus architectures such as PCI VESA Microchannel ISA and EISA to name a few. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer such as during start up is stored in ROM .

The computer also can include for example a hard disk drive a magnetic disk drive e.g. to read from or write to a removable disk and an optical disk drive e.g. for reading from or writing to a CD ROM disk or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of data data structures computer executable instructions etc. for the computer . Although the description of computer readable media above refers to a hard disk a removable magnetic disk and a CD it should be appreciated by those skilled in the art that other types of media which are readable by a computer such as magnetic cassettes flash memory digital video disks Bernoulli cartridges and the like can also be used in the exemplary operating environment and further that any such media can contain computer executable instructions for performing the methods of the embodiments.

A number of program modules can be stored in the drives and RAM including an operating system one or more application programs other program modules and program data . The operating system can be any suitable operating system or combination of operating systems. By way of example the application programs and program modules can include a data type extension scheme in accordance with an aspect of an embodiment.

A user can enter commands and information into the computer through one or more user input devices such as a keyboard and a pointing device e.g. a mouse . Other input devices not shown can include a microphone a joystick a game pad a satellite dish a wireless remote a scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but can be connected by other interfaces such as a parallel port a game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor the computer can include other peripheral output devices not shown such as speakers printers etc.

It is to be appreciated that the computer can operate in a networked environment using logical connections to one or more remote computers . The remote computer can be a workstation a server computer a router a peer device or other common network node and typically includes many or all of the elements described relative to the computer although for purposes of brevity only a memory storage device is illustrated in . The logical connections depicted in can include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment for example the computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem e.g. telephone DSL cable etc. or is connected to a communications server on the LAN or has other means for establishing communications over the WAN such as the Internet. The modem which can be internal or external relative to the computer is connected to the system bus via the serial port interface . In a networked environment program modules including application programs and or program data can be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means e.g. wired or wireless of establishing a communications link between the computers and can be used when carrying out an aspect of an embodiment.

In accordance with the practices of persons skilled in the art of computer programming the embodiments have been described with reference to acts and symbolic representations of operations that are performed by a computer such as the computer or remote computer unless otherwise indicated. Such acts and operations are sometimes referred to as being computer executed. It will be appreciated that the acts and symbolically represented operations include the manipulation by the processing unit of electrical signals representing data bits which causes a resulting transformation or reduction of the electrical signal representation and the maintenance of data bits at memory locations in the memory system including the system memory hard drive floppy disks CD ROM and remote memory to thereby reconfigure or otherwise alter the computer system s operation as well as other processing of signals. The memory locations where such data bits are maintained are physical locations that have particular electrical magnetic or optical properties corresponding to the data bits.

It is to be appreciated that the systems and or methods of the embodiments can be utilized in an object type extension facilitating computer components and non computer related components alike. Further those skilled in the art will recognize that the systems and or methods of the embodiments are employable in a vast array of electronic related technologies including but not limited to computers servers and or handheld electronic devices and the like.

What has been described above includes examples of the embodiments. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the embodiments but one of ordinary skill in the art may recognize that many further combinations and permutations of the embodiments are possible. Accordingly the subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

