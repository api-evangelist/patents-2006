---

title: Extending hierarchical synchronization scopes to non-hierarchical scenarios
abstract: Extending hierarchical synchronization (sync) scopes to non-hierarchical scenarios may involve a method for synchronizing differently organized data stores comprising mapping different physical organizations to similar logical organizations and utilizing an organization-based synchronization algorithm to synchronize the differently organized stores. Also, the uniqueness constraints of the organizations may be preserved as well as the parent-child ordering constraints of the organizations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07577691&OS=07577691&RS=07577691
owner: Microsoft Corporation
number: 07577691
owner_city: Redmond
owner_country: US
publication_date: 20060802
---
This invention is related to the following commonly assigned patent applications the entirety of which are hereby incorporated by reference U.S. patent application Ser. No. 10 631 591 filed Jul. 31 2003 entitled Systems and Methods for Replicating Data Stores and U.S. patent application Ser. No. 10 692 508 filed Oct. 24 2003 entitled Systems and Methods for Providing Relational and Hierarchical Synchronization Services for Units of Information Manageable by a Hardware Software Interface System. 

A portion of the disclosure if this patent may contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document of the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever. The following notice shall apply to this document Copyright 2006 Microsoft Corp.

Storage platforms increasingly are providing an improved ability to organize search and share all types of data in a computer system. These storage platforms extend and broaden the data platform beyond traditional file systems and database systems and are designed to be the store for all types of data. One example of such a storage platform is Microsoft Windows Future Storage or Microsoft Windows File System WinFS . Data stored within such a storage platform is often shared replicated and stored in different physical and logical locations among many users individuals and applications and thus may require a certain level of synchronization for the data to appear consistent.

WinFS Synchronization WinFS Sync described in U.S. patent application Ser. No. 10 692 508 filed Oct. 24 2003 entitled Systems and Methods for Providing Relational and Hierarchical Synchronization Services for Units of Information Manageable by a Hardware Software Interface System and other synchronization solutions for hierarchical stores define synchronization scopes the data to be synchronized to be portions of the hierarchy e.g. a folder tree . Many scenarios exist in which such synchronization scopes are inadequate. For example this may be the case where moving an item into a folder in order to make it sync is too much of a burden or where an item must be in two independent synchronization scopes. A common example is wanting to share a picture with someone without moving this picture out of the folder it is in. However supporting non hierarchical sync scopes in hierarchical stores such as WinFS or most file systems in a multi master environment is very difficult.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

In consideration of the above identified shortcomings of the art extending hierarchical synchronization sync scopes to non hierarchical scenarios is provided. For several embodiments a method for synchronizing differently organized data stores comprises mapping different physical organizations to similar logical organizations and utilizing an organization based synchronization algorithm to synchronize the differently organized stores. Also the uniqueness constraints of the organizations may be preserved as well as the parent child ordering constraints of the organizations.

Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the invention. Certain well known details often associated with computing and software technology are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the invention. Further those of ordinary skill in the relevant art will understand that they can practice other embodiments of the invention without one or more of the details described below. Finally while various methods are described with reference to steps and sequences in the following disclosure the description as such is for providing a clear implementation of embodiments of the invention and the steps and sequences of steps should not be taken as required to practice this invention.

Referring to shown is a block diagram representing an exemplary computing device suitable for use in conjunction with implementing the processes described above. For example the computer executable instructions that carry out the processes and methods for extending hierarchical synchronization sync scopes to non hierarchical scenarios may reside and or be executed in such a computing environment as shown in . The computing system environment is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing environment be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment . For example a computer game console may also include those items such as those described. below for use in conjunction with implementing the processes described above.

Aspects of the invention are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Aspects of the invention may be implemented in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Aspects of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

An exemplary system for implementing aspects of the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus the Peripheral Component Interconnect PCI bus also known as Mezzanine bus as well as its successor the PCI Express standard.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through an non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as an insecure or secure video interface . An exemplary secure video standard would be the High Definition Multimedia Interface HDMI standard. In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through a output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the processes described in connection with the invention e.g. through the use of an API reusable controls or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

Although exemplary embodiments may refer to utilizing aspects of the invention in the context of one or more stand alone computer systems the invention is not so limited but rather may be implemented in connection with any computing environment such as a network or distributed computing environment. Still further aspects of the invention may be implemented in or across a plurality of processing chips or devices and storage may similarly be effected across a plurality of devices. Such devices might include personal computers network servers handheld devices supercomputers or computers integrated into other systems such as automobiles and airplanes.

In light of the diverse computing environments that may be built according to the general framework provided in the systems and methods provided herein cannot be construed as limited in any way to a particular computing architecture. Instead the invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

Referring next to shown is an exemplary networked computing environment in which many computerized processes may be implemented to perform the processes described above. For example parallel computing may be part of such a networked environment with various clients on the network of using and or implementing processes that extend hierarchical synchronization sync scopes to non hierarchical scenarios. One of ordinary skill in the art can appreciate that networks can connect any computer or other client or server device or in a distributed computing environment. In this regard any computer system or environment having any number of processing memory or storage units and any number of applications and processes occurring simultaneously is considered suitable for use in connection with the systems and methods provided.

Distributed computing provides sharing of computer resources and services by exchange between computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for files. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may implicate the processes described herein.

This network may itself comprise other computing entities that provide services to the system of and may itself represent multiple interconnected networks. In accordance with an aspect of the invention each entity and may contain discrete functional program modules that might make use of an API or other object software firmware and or hardware to request services of one or more of the other entities and .

It can also be appreciated that an object such as may be hosted on another computing device . Thus although the physical environment depicted may show the connected devices as computers such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs televisions MP players etc. software objects such as interfaces COM objects and the like.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems may be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks. Any such infrastructures whether coupled to the Internet or not may be used in conjunction with the systems and methods provided.

A network infrastructure may enable a host of network topologies such as client server peer to peer or hybrid architectures. The client is a member of a class or group that uses the services of another class or group to which it is not related. In computing a client is a process i.e. roughly a set of instructions or tasks that requests a service provided by another program. The client process utilizes the requested service without having to know any working details about the other program or the service itself. In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the example of any entity and can be considered a client a server or both depending on the circumstances.

A server is typically though not necessarily a remote computer system accessible over a remote or local network such as the Internet. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server. Any software objects may be distributed across multiple computing devices or objects.

Client s and server s communicate with one another utilizing the functionality provided by protocol layer s . For example HyperText Transfer Protocol HTTP is a common protocol that is used in conjunction with the World Wide Web WWW or the Web. Typically a computer network address such as an Internet Protocol IP address or other reference such as a Universal Resource Locator URL can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium e.g. client s and server s may be coupled to one another via TCP IP connection s for high capacity communication.

In light of the diverse computing environments that may be built according to the general framework provided in and the further diversification that can occur in computing in a network environment such as that of the systems and methods provided herein cannot be construed as limited in any way to a particular computing architecture or operating system. Instead the invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

Although the concepts ideas features and implementations described herein are described in an exemplary fashion with respect to how they are implemented in a file system called Microsoft Windows Future Storage or Microsoft Windows File System WinFS and the Microsoft Windows Vista operating system formerly code named Longhorn implementations in and applicability to other operating and file systems are contemplated entirely possible and apparent to those skilled in the art based on the exemplary descriptions provided herein.

In an increasingly distributed digital world individuals and workgroups often store information and data in a variety of different devices and locations. This has fueled the development of data synchronization services that can keep the information in these separate often disparate data stores synchronized at all times with minimal user intervention.

The synchronization platform described herein which is part of the rich storage platform a.k.a. WinFS described in U.S. patent application Ser. No. 10 692 508 filed Oct. 24 2003 entitled Systems and Methods for Providing Relational and Hierarchical Synchronization Services for Units of Information Manageable by a Hardware Software Interface System the entirety of which is hereby incorporated by reference addresses three main objectives 

Herein below are some further refined definitions and key concepts relevant to later discussions herein 

Sync Replica Most applications are only interested in tracking enumerating and synchronizing changes for a given subset of items within the WinFS store. The set of items that take part in a synchronization operation is termed as a Synchronization Replica. A Replica is defined in terms of items contained within a given WinFS containment hierarchy usually rooted at a Folder item . All synchronization services are carried out within the context of a given replica. WinFS Sync provides a mechanism to define manage and cleanup replicas. Every replica has a GUID identifier that uniquely identifies it within a given WinFS store.

Sync Partner A sync partner is defined as an entity capable of affecting changes on WinFS items extensions and relationships. Thus every WinFS store can be termed as a sync partner. When synchronizing with a non WinFS store the external data source EDS is also termed as a sync partner. Every partner has a GUID identifier that uniquely identifies it.

Sync Community A synchronization community is defined as a collection of replicas that are kept in sync by means of peer to peer synchronization operations. These replicas may all be in the same WinFS store different WinFS stores or even manifest themselves as virtual replicas on non WinFS stores. WinFS sync does not prescribe or mandate any specific topology for the community especially if the only sync operations in the community are through the WinFS Sync service WinFS adapter . Synchronization adapters defined below may introduce their own topology restrictions.

Change Tracking Change Units and Versions Every WinFS store tracks changes to all local WinFS Items Extensions and Relationships. Changes are tracked at the level of change unit granularity defined in the schema. The top level fields of any Item Extension and Relationship type can be sub divided by the schema designer into change units with the smallest granularity being one top level field. For change tracking purposes every change unit is assigned a Version where a version is a pair of sync partner id and a version number the version number is a partner specific monotonically increasing number . Versions are updated as changes happen in the store locally or as they are obtained from other replicas.

Sync Knowledge Knowledge represents the state of a given sync replica at any time i.e. it encapsulates meta data about all the changes a given replica is aware of either local or from other replicas. WinFS sync maintains and updates knowledge for sync replicas across sync operations. Important thing to note is that the Knowledge representation allows it to be interpreted with respect to the entire community and not just relative to the particular replica where the Knowledge is stored.

Sync Adapters A synchronization adapter is a managed code application that accesses WinFS Sync services through the Sync Runtime API and enables synchronization of WinFS data to an EDS. Depending on the requirements of the scenario it s up to the adapter developer as to which subset of WinFS data and what WinFS data types to synchronize. The adapter is responsible for communication with the EDS transforming WinFS schemas to and from EDS supported schemas and defining and managing its own configuration and metadata.

Synchronization services may comprise among other services two foundational services change enumeration and change application.

Change Enumeration allows sync adapters to easily enumerate the changes that have occurred to a Replica since the last time synchronization with this partner was attempted based on the change tracking data maintained by the synchronization service.

As discussed earlier herein change application allows Sync Adapters to apply changes received from their EDS to the local storage platform since the adapters are expected to transform the changes to the storage platform schema.

A Synchronization Replica defines the set of items that take part in a synchronization operation. Part of the Replica configuration is a WinFS containment hierarchy which is a single folder tree.

The fact that all data synchronized in the community is represented as a single folder tree presents two problems to users 

1 Items have to be physically moved if they are to be added to a sync community. This is sometimes problematic as the user may have an interest in keeping the item path the same as before. They would like the item synchronized but they do not want existing applications to break.

2 Since no item can be in two folders it is difficult to share overlapping sets of items with different people. In other words sync communities cannot overlap. They can only be fully contained in each other.

One example scenario may stem from a requirement to build a one way publication application for pictures. In this model a user can select an arbitrary set of pictures from his WinFS and have them be published to one or more users. Those users will be able to execute a one way receive sync against the publication periodically thus keeping an off line cache of all of the shared pictures. The key problems for the application are that a user may want to share the same picture with multiple other users each user being a separate sync community the user also cannot move the pictures from the folder where they reside to the folder used for the sync replica.

Referring next to shown is a block diagram illustrating this example scenario wherein two sync communities are created by a user. Two sync communities are created by a user where the contents for each community are individual items contributed to the community and therefore left in their original location. The same item can be contributed to multiple communities.

In the example provided in there are three pictures in the Pictures folder which is not synchronized for user Mark . In the folder for the sync application the user has configured two sync communities one with Jin and one with Yunxin . The user wants to share Pic and Pic with Yunxin and Pic and Pic with Jin . Folders and are created for each user and sync replicas and created for each user. The desired pictures are then contributed to each replica thereby extending the hierarchical sync scope. On computer B user Jin has created folder to receive the synchronized pictures with an associated sync replica . When synchronized with replica on computer A Pic and Pic are created as if they were in the hierarchical sync scope on computer A. On computer C user Yunxin has created folder to receive the synchronized pictures with an associated sync replica . When synchronized with replica on computer A Pic and Pic are created as if they were in the hierarchical sync scope on computer A.

Extending hierarchical synchronization sync scopes to non hierarchical scenarios may for example comprise the following features 

For configuration API s are provided to allow items to be contributed to a replica s sync scope and un contributed from a replica s sync scope. If there are multiple replica s then the contribution un contribution is made to each replica where the item is to be synced. This is a sync specific concept. The contributed item can be a generic container or a compound item but cannot be an embedded item. The namespace name of the contributed item is used on a remote replica. A container is specified for each contributed item which is used to determine the location of the item on a remote replica. It is possible to update the contribution container after the initial contribution. The list of contributed items for a Replica are available from each Replica object.

For WinFS WinFS sync changes are enumerated from the contributed item except the container. If a generic container is contributed all items in or under the container will be synced. The term the contributed item herein refers to only the generic container that is contributed in this case not the items in or under it. The contributed item is applied on a remote replica in the location specified by the contribution configuration. All changes made on a remote replica including deletes are synced back to the contributed item.

For sync with an external store change enumeration will return the contributed item including its item id and namespace name but with the container specified by the contribution configuration. For change application the contributed item will be required materialized and updated. No changes would be required to an adapter for this as the item id of the contributed item was returned by change enumeration. For a container id change it is made by the adapter to the contributed item but sync change application detects those changes and update the contribution configuration.

For conflict management conflict detection and system resolution is performed on the contributed item including the namespace name.

The following methods are added to the Replica class. The changes made using the new methods will not be applied until the SaveChanges method is called.

rootItem is the root item of the contributed item. It can be a generic container such as a folder or an individual compound item.

targetContainer is the generic container where the contributed item will be placed on a remote replica. The target container can be under the replica root or could be under another contributed container nested contributions.

Allowing nested contributions appears unnecessary however they are allowed in the present design example because the situation could still occur due to moves on a remote replica. The root of one contribution could be moved under another container that was contributed.

The existing contribution will effectively override the WinFS container hierarchy specified by the new contribution. The existing contribution will therefore remain with the same container on a remote replica even though it has a different container in the new contributed hierarchy.

rootItem is already in the replica under the replica root or already contributed. Already contributed could either mean that the item had been specifically contributed or is a child item of a contributed container.

An item with the namespace name of rootItem already exists in targetContainer either a real item or a contributed item.

The RemoveContribution method takes the local storage key of the contributed item and removes it from the contribution configuration. The storage key can be obtained from the contributed item itself if it still exists and is accessible or can be obtained from the ReplicaContribution object.

On the next sync this will be enumerated as a move out. This method will fail with ArgumentException if 

rootItemLocalKey is the storage key for an entity other than an item. This method will fail with InvalidOperationException if 

An item with the namespace name of rootItem already exists in targetContainer either a real item or a contributed item.

Obtain the set of contributions made to this replica. A snapshot of the contributions will be taken with the set of ReplicaContribution objects being instantiated when the call is made.

Obtain the set of contributions made to this replica but filtered to the specified container. A snapshot of the contributions will be taken with the set of ReplicaContribution objects being instantiated when the call is made.

AddContribution operation All items that have been contributed since the last sync with this partner are treated as move ins.

RemoveContribution operation The result of the operation depends on whether or not the contribution root is under the replica root or another contribution root that is being synced see later for cases for contributed items not being synced . If not all the contributed items will be treated as move outs. If yes the operation will be handled by sync as a move of the contribution root to its current container.

Target Container Operations Deletions move outs and un contributions of target containers may have side effects. Local deletions of target containers of any contributions will result in those contributions being removed. This will be done in a sync session automatically. Remote deletions of target containers will not result in un contributions until the container deletion is change enumerated during a sync to a third replica. Contributed items under any contribution root whose target container has been moved out will be handled as move outs. The contribution i.e. their configurations will remain but the contributed items will no longer be synced. A special kind of target container moveout may happen when the target container is moved under one of its contributed items that is a generic container . Contributed items under any contribution roots whose target containers have been un contributed will be handled as move outs. The contributions i.e. their configurations will remain but they will no longer be synced.

The sync behaviors regarding to deletions is inconsistent with that of move outs and un contribution as described above.

Contribution Root Deletion Deletion of contribution root will be synced as a regular deletion. It will not result in un contribution. However when the resurrection of the item by conflict handling in sync will result in un contribution.

Move Operations Moves of items that are not contribution roots across contribution roots and the replica root will result in regular move at remote replicas unless the move results in the target container of a contribution to be under the contribution root in which case the contributed items will be treated as move outs. Move of a contribution root will be synced as a no op move i.e. an item moved to somewhere and then moved back to the target container .

Change enumeration including preprocessing When changes are enumerated whether for purposes of WinFS to WinFS Synchronization or by an adapter the following occurs 

The contribution root item will be enumerated with its Container being replaced by that specified in the contribution configuration.

A link from the contributed item will dangle if the target item is not in the replica scope folder hierarchy or contributed .

A link from an item in the sync scope to a contributed item or any of its children will be enumerated.

A local item could be created created copied existing item renamed etc. that collides with the namespace name of a contributed item. WinFS will not detect this condition. Change enumeration will also not detect this condition it will be left to change application to handle the name collision that WinFS will detect on the remote replica.

If a contributed item container or compound item is moved under the replica root then the contribution configuration will still be enumerated instead of the WinFS hierarchy. Referring next to shown is a block diagram illustrating an example scenario wherein item I A is initially contained by folder F and contributed to folder F . When synced I therefore has container F on a remote replica .

If I is moved to F with a WinFS move not a contribution move then on the next sync there is no change enumerated there is still valid contribution configuration of I to F and that will take precedence in change enumeration over the fact that I is now contained by F in the WinFS namespace. This means that contribution could be used to change the layout on remote replicas but this is not expected to be a common scenario.

The main principle is that if the contribution configuration is valid valid contributed item and valid contribution container then the contribution will always be respected by sync change enumeration.

At the contributing replica a remote deletion of a contributed item will result in deletion of the contribution item and any children in the case of a generic container and un contribution.

Specific Name Collision Scenarios There are a couple of scenarios very specific to item contribution that will be described and the behavior defined.

Local Name Collision An item in the contribution container is created or an existing item renamed so it has the same name as a contributed item. The local operation that causes the collision would be allowed as the contribution is not known by the WinFS data model WinFS Sync has to deal with this scenario.

The collision will be detected during change application on a remote replica. The WinFS Update API will throw an exception due to the name collision. This will be handled by the sync runtime by renaming one of the items. The rename will be a local change and synced back just as a conflict resolution.

An alternative is to treat this as a new kind of conflict and allow system or deferred rename. This would be a completely different kind of conflict as both the changes came one source. Adding a new type of conflict would be confusing for the user and have a large impact. However this scenario should also be rare. The chances of this happening are reduced by the fact that a name collision check is performed when items are contributed.

Remote Rename Name Collision In this case a remote rename made to an item that was contributed. The rename is synced back to the replica with the contribution but the rename collides with another item in the container of the contributed item. There is therefore a name collision with an item outside of the sync scope.

The collision will be detected during change application by the sync runtime and an automatic rename of the contributed item item in the sync scope performed. This should be a rare scenario and therefore an acceptable solution.

In general conflict detection and resolution involving contributed items is the same as with items in the replica tree. All change units will be taken from the contributed item except the container id of the contribution.

Conflicts involving moves are supported as with a non contributed item but special handling will probably be required to deal with the fact that the container for a contributed item is not stored with the contributed item. The following provides a description of how conflicts may be handled in certain situations.

Update Update Conflicts An interesting case is a move conflict. The target container is updated on the replica with the contribution and the contributed item is moved on a remote replica.

Name Uniqueness Conflicts A name uniqueness conflict for a contributed item will be treated the same as for a non contributed item except for the scenarios described previously.

Update Delete conflict handling In the main there will be no differences in the handling of these conflicts between contributed and non contributed items including move updates. Exceptions to this are as follows 

A contributed item is deleted locally and updated remotely with the conflict policy set so that remote wins. The contributed item root will be resurrected but as a non contributed item in the container specified by the remote replica probably the contribution container .

An item has been contributed locally but the contribution folder has been deleted remotely. The conflict will be raised and handled normally as local new child and remote parent deletion.

Conflict Enumeration The conflict enumeration API will allow the locally conflicting contributed item to be returned. The container id will be set to that specified by the contribution configuration.

Adapter Services. A fundamental principal is that an adapter writer should not have to explicitly cater for both regular and contributed items so in the main adapter code can be written with no knowledge of item contribution.

Change Enumeration Change enumeration will basically return the contributed item. For a contributed item the contribution container is returned instead of the container indicated by the contributed item. For a contribution root item the ContainerLocalKey property from the ItemChange class will be set to the key from the contribution configuration rather than the contribution root item.

Change Application The adapter will use the id mapping service or its own mapping to fetch the item id of the contributed item. It can then instantiate that item and set the properties it does not need to be aware that the item was contributed. The adapter could set the container id a move and the sync runtime change applier will need to update the contribution configuration. Once the changes are saved for the contributed item the item will be refreshed so that the container id represents the value truly associated with the item and not that for the contribution configuration. This could be odd behavior because the value just set for the container will be replaced after the item changes were saved. It does mean the item is valid and consistent in case further changes are made.

Referring next to shown is a block diagram illustrating an example scenario for providing a summary of example synchronization behaviors. These example synchronization behaviors are provided in the chart below and correspond to the diagram shown in 

Sync initiation Initiating synchronization against a Replica that contains contributions is done in the same way as described above except the item domain of the connection must be high enough to include all contribution roots. In other words connecting to the root of the replica will result in an error.

Filtered Sync Interaction Item id s for any of the contributed items can be specified e.g. for root items or any child items .

Ghosted Sync Interaction Ghosted sync will work for contributed items. A ghosted item can be contributed. No special behavior or checks are performed. It may seem desirable to not allow this as it is a cross community case and the synced ghosted item may not be possible to un ghost. However one can not protect against this as a complete item that was contributed could be ghosted at a later time.

Overall extending hierarchical sync scopes to non hierarchical scenarios provides the ability to tie non hierarchical pieces of data to a hierarchical scope in a way that supports the scenarios but does not break the multi master nature of replication. It accomplishes this by allowing the physical hierarchical representations of data on different replicas to be distinct customized for the needs of that node and synchronizing the logical views of the data which are computed from the physical representation and are kept in sync. These logical views are hierarchical thus allowing the full force of hierarchical sync algorithms to be brought to bear on supporting non hierarchical sync scopes in hierarchical stores.

The various systems methods and techniques described herein may be implemented with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computer will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

The methods and apparatus of the present invention may also be embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer a video recorder or the like the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates to perform the indexing functionality of the present invention.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating there from. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific hardware software interface systems are herein contemplated especially as the number of wireless networked devices continues to proliferate. Therefore the present invention should not be limited to any single embodiment but rather construed in breadth and scope in accordance with the appended claims.

Finally the disclosed embodiments described herein may be adapted for use in other processor architectures computer based systems or system virtualizations and such embodiments are expressly anticipated by the disclosures made herein and thus the present invention should not be limited to specific embodiments described herein but instead construed most broadly.

