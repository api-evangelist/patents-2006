---

title: Method and system for determining application availability
abstract: A method and system for determining an availability of an application. Pairs of processes utilized by the application are determined. Each pair includes consumer and provider processes. For each pair, a diagnostic transaction is initiated by the pair's consumer process, utilizes an application programming interface (API) to open a connection between the consumer process and provider process and to request access to a resource managed by the provider process. Any communication between a pair's consumer and provider processes uses the same API. The diagnostic transaction is completed by receiving or not receiving, at the consumer process, a response from the pair's provider process where the response provides the requested access. Receipt of the response designates the provider process as available to the application, whereas non-receipt of the response designates the provider process as unavailable. If responses are received for all diagnostic transactions, the application is available.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07587453&OS=07587453&RS=07587453
owner: International Business Machines Corporation
number: 07587453
owner_city: Armonk
owner_country: US
publication_date: 20060105
---
The present invention relates to a method and system for determining the availability of applications and in particular to a technique for determining the availability of applications in a multi tier environment having redundant clusters of servers within each tier and for isolating faults to the software processes impacting availability.

Two conventional techniques exist to solve the problem of identifying in complex applications running over a number of nodes or tiers and involving redundant clusters of nodes within the same tier that a failure has occurred the software process or hardware device responsible for the failure and the application transactions impacted by the failure.

The first conventional technique involves component monitors that monitor software processes or hardware devices at an individual component level. For example commercial component monitors are available for WebSphere Application Server WAS e.g. Introscope and Tivoli Monitoring for Web Infrastructure and WebSphere MQSeries MQ e.g. Tivoli Monitoring for Business Integration and Omegamon for MQ . WAS WebSphere MQSeries Tivoli Monitoring for Business Integration and Omegamon for MQ are available from International Business Machines Corporation of Armonk N.Y. Introscope is available from Wily Technology Inc. of Brisbane Calif. In cases such as a UNIX server running on the Lightweight Directory Access Protocol LDAP customized component monitors are developed. Component monitors provide performance information about software components and detect some classes of software errors however when a software hang occurs these monitors provide a false positive i.e. the application is not available but a failure is not detected . Further component monitors provide inadequate or no information regarding which application transactions are impacted as a result of a failure.

The second conventional technique involves executing a series of synthetic transactions against a real production system to see whether the transactions produce a response that corresponds to a valid known state. This synthetic transaction technique suffers from a number of problems. First synthetic transactions are not appropriate for all business applications e.g. updating a bank balance . Second once a failure is detected by the synthetic transaction technique it is not easy to determine which node or software process is responsible for the failure. Third when load balancing technologies direct transactions it is difficult for the synthetic transaction technique to direct synthetic transactions to specific nodes to provide complete coverage of an infrastructure. Fourth every distinct application architecture needs to have a synthetic transaction defined for it. Finally because of all of the above running synthetic transactions creates a substantial load.

In first embodiments the present invention provides a method of determining an availability of an application in a computing environment comprising 

determining a plurality of pairs of processes utilized by the application wherein each pair includes a first process designated as a consumer process and a second process designated as a provider process wherein the consumer process accesses a resource provided by the provider process 

initiating by one process CP designated as the consumer process and included in a pair of the plurality of pairs a diagnostic transaction between the CP and another process PP designated as the provider process and included in the pair 

wherein the diagnostic transaction utilizes an application programming interface API of a plurality of APIs to open a connection between the CP and the PP and to request an access to a resource managed by the PP the API utilized by the CP and the PP to perform any communication therebetween 

completing the diagnostic transaction via receiving at the CP a response from the PP providing the access or via not receiving the response at the CP 

designating the PP as available to the application in response to the completing via the receiving the response or as unavailable to the application in response to the completing via the not receiving the response 

repeating the initiating the completing and the designating until each pair of the plurality of pairs is utilized by the initiating the completing and the designating and

determining an availability of the application based on no process of the plurality of pairs being designated unavailable via the designating.

In second embodiments the present invention provides a system for determining an availability of an application in a computing environment comprising 

means for determining a plurality of pairs of processes utilized by the application wherein each pair includes a first process designated as a consumer process and a second process designated as a provider process wherein the consumer process accesses a resource provided by the provider process 

means for initiating by one process CP designated as the consumer process and included in a pair of the plurality of pairs a diagnostic transaction between the CP and another process PP designated as the provider process and included in the pair 

wherein the diagnostic transaction utilizes an application programming interface API of a plurality of APIs to open a connection between the CP and the PP and to request an access to a resource managed by the PP the API utilized by the CP and the PP to perform any communication therebetween 

means for completing the diagnostic transaction via receiving at the CP a response from the PP providing the access or via not receiving the response at the CP 

means for designating the PP as available to the application in response to the completing via the receiving the response or as unavailable to the application in response to the completing via the not receiving the response 

means for repeating the initiating the completing and the designating until each pair of the plurality of pairs is utilized by the initiating the completing and the designating and

means for determining an availability of the application based on no process of the plurality of pairs being designated unavailable via the designating.

In third embodiments the present invention provides a computer program product comprising a computer usable medium including computer usable program code for determining an availability of an application in a computing environment the computer program product including 

computer usable code for determining a plurality of pairs of processes utilized by the application wherein each pair includes a first process designated as a consumer process and a second process designated as a provider process wherein the consumer process accesses a resource provided by the provider process 

computer usable code for initiating by one process CP designated as the consumer process and included in a pair of the plurality of pairs a diagnostic transaction between the CP and another process PP designated as the provider process and included in the pair 

wherein the diagnostic transaction utilizes an application programming interface API of a plurality of APIs to open a connection between the CP and the PP and to request an access to a resource managed by the PP the API utilized by the CP and the PP to perform any communication therebetween 

computer usable code for completing the diagnostic transaction via receiving at the CP a response from the PP providing the access or via not receiving the response at the CP 

computer usable code for designating the PP as available to the application in response to the completing via the receiving the response or as unavailable to the application in response to the completing via the not receiving the response 

computer usable code for repeating the initiating the completing and the designating until each pair of the plurality of pairs is utilized by the initiating the completing and the designating and

computer usable code for determining an availability of the application based on no process of the plurality of pairs being designated unavailable via the designating.

In fourth embodiments the present invention provides a method for deploying computing infrastructure comprising integrating computer readable code into a computing system wherein the code in combination with the computing system is capable of performing a process of determining an availability of an application in a computing environment the process comprising 

determining a plurality of pairs of processes utilized by the application wherein each pair includes a first process designated as a consumer process and a second process designated as a provider process wherein the consumer process accesses a resource provided by the provider process 

initiating by one process CP designated as the consumer process and included in a pair of the plurality of pairs a diagnostic transaction between the CP and another process PP designated as the provider process and included in the pair 

wherein the diagnostic transaction utilizes an application programming interface API of a plurality of APIs to open a connection between the CP and the PP and to request an access to a resource managed by the PP the API utilized by the CP and the PP to perform any communication therebetween 

completing the diagnostic transaction via receiving at the CP a response from the PP providing the access or via not receiving the response at the CP 

designating the PP as available to the application in response to the completing via the receiving the response or as unavailable to the application in response to the completing via the not receiving the response 

repeating the initiating the completing and the designating until each pair of the plurality of pairs is utilized by the initiating the completing and the designating and

determining an availability of the application based on no process of the plurality of pairs being designated unavailable via the designating.

Advantageously the availability determination technique described herein provides an accurate and reliable diagnostic test to determine the availability of a software process utilized by an application. Further the present invention provides a general technique for accurately and automatically diagnosing end to end availability of any customer defined application transaction while avoiding indications of false positives. Since the technique described herein is lightweight it can be executed more frequently than conventional synthetic transaction schemes. Still further the present invention is capable of automatically isolating an application s failure to an individual software process. Yet further the diagnostic tests described herein can be directed to specific nodes even if the computing environment employs redundancy.

The present invention provides an automated approach to diagnosing the availability of applications by detecting that an application failure has occurred and detecting an individual process utilized by one or more applications that is responsible for the failure. Further the technique disclosed herein identifies applications that are impacted by a failed process and re routes workload away from the failed process in operational environments where alternate paths are available. The aforementioned functions are a pre requisite to an autonomic i.e. self healing approach for recovering from application failure.

Process communicates with process which resides in server . Process also communicates with process which resides in server . Further process communicates with process residing in server . Processes and are components of the application whose architecture is depicted in .

Communications between processes in include for example one process i.e. a consumer process requesting access to one or more resources managed by another process i.e. a provider process . When multiple processes exist in one server e.g. processes in server a multitasking operating system not shown provides the appearance of simultaneous execution of the processes by switching between their executions on a central processing unit not shown .

Each of the processes of includes one or more components. For example process includes driver component which communicates with test component residing in process . Driver component initiates a diagnostic transaction that tests the connection between process and process thereby determining the availability of process and facilitating determining whether a failure has occurred in the application being monitored. The diagnostic transaction is described in more detail below see e.g. .

Driver component is instantiated by a sensor and returns the result of the diagnostic transaction to sensor . Sensor is instantiated by an autonomic manager and returns the result of the diagnostic transaction to autonomic manager . Autonomic manager resides on a management server not shown . Autonomic manager provides functions that facilitate the ability of computing system to automatically identify a failure related to a process or server and automatically take actions a.k.a. self healing actions in response to the failure to maintain effective functioning of the system. Examples of functions performed by autonomic manager include 1 maintaining a topology of each application being monitored for availability 2 maintaining a consolidated view of the set of connections between processes that need to be monitored 3 analyzing the impact of a process or server failure on the availability of an application 4 preventing additional workload from being sent to a failed process or server and 5 initiating recovery and restart actions in response to a process or server failure.

The management server that includes autonomic manager may be configured to be highly available and therefore may be capable of running on clustered servers not shown and be capable of running across multiple data centers. Such a clustered configuration is typically part of or feeds events into an organization s central management console. Further the clustered server configuration is enhanced so that each of the servers in the cluster monitors the other servers in the cluster to ensure that the autonomic manager instances do not fail. A central management console is for example Tivoli Enterprise Console which is available from International Business Machines Corporation.

Although not shown in driver components and test components are included in other pairs of processes so that the connection between the processes of each pair can be tested. For example a driver component not shown in process and a test component not shown in process utilize a diagnostic transaction to test the connection between processes and . Further server and server each include a sensor not shown that communicates with each server s respective one or more driver components. Like sensor the sensors in server and communicate with autonomic manager . Although not shown each sensor including sensor communicates with the one or more test components residing in the server that includes the sensor e.g. to instantiate the test components .

The present invention contemplates other configurations of servers in system . For instance one or more servers of types already in system and or of types not represented in can be added to system e.g. system can include multiple application servers . Further any server in can be replaced with another type of server. Still further system is not limited to servers and may include one or more nodes that are servers and or one or more nodes that are non server devices. Non server devices include for example firewalls load balancing switches i.e. application content switches cryptographic coprocessors intrusion detection appliances and web caching devices. As used herein a node is defined as a physical device attached to a network or another device e.g. a cryptographic coprocessor is attached to a server PCI bus and is therefore not directly network accessible . If system includes non server devices a diagnostic transaction can test the connection between non server devices or between a server and a non server device using the techniques described below.

System can be extended to include architectures of multiple applications whose processes reside on the nodes of system . The availability technique described below can determine which of the multiple applications are impacted by a failure of a process. Moreover an application included in system may be a single or multi tiered application and redundancy of one or more nodes may be built into system .

Process pair includes consumer process P and provider process P. Process requests resources from process via API or application level protocol I. Hereinafter it is to be understood that a reference to an API refers to an API or an application level protocol. Consumer process includes a driver component and provider process includes a test component . A first set of other application components is included in consumer process and a second set of other application components is included in provider process . First set includes components C C . . . C which correspond in a one to one manner with components C C . . . C which are included in second set . Each component of first set accesses services of its corresponding component in second set via I. Driver component is an infrastructure component embedded in process that is used to drive the connection between Pand Pusing I. Driving a connection between processes is discussed below relative to .

An application topology can be represented as a set of triplets P I P where Pis a consumer process included in the processes P. . . P Pis a provider process included in the processes P. . . P Iis the API utilized in any communication between Pand P 1 i j n and i j. The subscript in Iis unbounded because a theoretically infinite number of APIs can be in use between Pand P. For practical purposes an environment may have hundreds to thousands of APIs in use. If it is assumed that 1 each process pair has only one API in use between the processes of the pair which is usually the case and 2 there are no loops i.e. i

The set of triplets P I P can be converted into a directed graph where Pand Prepresent vertices of the directed graph and the Ivalues represent the edges of the graph.

As one example application topology information determined in step is collected by an Application Response Measurement ARM API. ARM is a standard provided by The Open Group of Reading United Kingdom. The ARM API is implemented by products such as Tivoli Monitoring for Transaction Performance TMTP and Enterprise Workload Manager EWLM which are available from International Business Machines Corporation. In the case of EWLM the ARM API is implemented in underlying middleware products such as HTTP Server WebSphere Application Server DB2 and MQSeries which are available from International Business Machines Corporation.

System see can be included in a distributed computing environment. In this case a calling hierarchy is also determined in step by for example the ARM API. A calling hierarchy of an application is a sequence in which methods are invoked by the application. In one example a calling hierarchy is restricted to operationally significant methods which are methods that invoke APIs involving external processes. For instance in a Java environment running under WebSphere Application Server WAS the calling hierarchy would include calls to an MQSeries process external to WAS wherein the calls utilize a Java Message Service JMS API. WAS is software that manages e business applications and MQSeries is software that provides message queuing services.

The ARM API builds the calling hierarchy by the use of correlators. Each method call passes a parent correlator to the application. The application also receives a child correlator in a response to the method call. A call tree generated using the parent and child correlators includes the calling hierarchy and the timing of the method calls.

As one example an ARM Management Agent not shown residing in server see passes ARM information including correlators to sensor see . Sensor see sends first of a kind FOAK application configurations to autonomic manager see . A FOAK configuration is an application topology that is being detected by a sensor for the first time. A sensor can identify a configuration as a FOAK configuration by comparing the configuration to the sensor s maintained knowledge of the topology of applications relative to the node on which the sensor resides. FOAK configurations include 1 an application that is newly detected by a sensor because a node is newly added to an existing cluster or because the application is newly identified by the present invention as an application to be monitored and 2 a process or a communication with an existing process that is newly added to an application.

Sending only FOAK configurations from the sensors to the autonomic manager ensures that massive amounts of data are not transmitted to the autonomic manager as a result of every transaction that reports its topology. Further the automatic identification and transmission of FOAK configurations advantageously avoids the need for error prone manually defined application topologies.

If inquiry step determines that an additional one or more other applications included in system are to be monitored for availability and have topologies that have not yet been determined by step then the process repeats starting at step to determine the topology of one of the additional applications. If step determines that no applications remain to be processed by step then the application availability process continues with step .

Although not shown on steps and are performed on a continual basis in parallel with polling activities which are described in subsequent steps starting at step . In other words a FOAK topology can be detected at any time during the process of and in response to that detection the FOAK topology is propagated to autonomic manager see which re executes steps and .

In step the one or more application topologies determined in step or the directed graphs representing the application topologies are each converted to an adjacency matrix that includes rows and columns corresponding to the provider processes and consumer processes respectively. A value of a first pre defined set of values e.g. a non zero value appears in an adjacency matrix at row i and column j to indicate a particular API that is used in a communication between the j th consumer process and the i th provider process. Hereinafter a value of the first pre defined set is referred to as a non zero value. A value of a second pre defined set of values e.g. a zero value in the adjacency matrix indicates that no communication is occurring between the consumer process and provider process indicated by the column and row associated with the value. Hereinafter a value in the second pre defined set is referred to as a zero value.

Step also forms a union of all the adjacency matrices generated from the application topologies of step . The non zero values of the union of the adjacency matrices indicate the set of processes that are to be monitored. Adjacency matrices are described below relative to and a union of adjacency matrices is depicted in .

Periodic polling of connections between processes is initialized and periodic polling begins in step . Autonomic manager see instantiates sensors e.g. sensor of residing in nodes of system see e.g. servers of FIG. A and notifies each sensor of the APIs to be utilized for the monitoring of the node on which the sensor resides. Each sensor instantiates one or more driver components e.g. driver component of and one or more test components e.g. test component of which reside in the node on which the sensor resides.

Each driver component e.g. driver component of of a consumer process initiates a diagnostic transaction that utilizes a distinct API of the plurality of APIs to test a connection between the consumer process and a provider process invoked by the consumer process. As used herein testing a connection between a consumer process and a provider process is equivalent to testing the availability of the provider process. The test of the connection includes 1 opening a connection between the consumer process and the provider process and 2 requesting access to one or more resources managed by the provider process. The aforementioned actions 1 and 2 utilize the same API that an application being monitored uses for any of the application s transactions between the consumer process and the provider process.

The diagnostic transaction is directed to a test component e.g. test component of included in the provider process. The test component includes all the resources necessary to execute the code from the driver component and provide a response. If the provider process is available the test component s response to the driver component provides the requested access to the one or more resources and validates the functionality of the provider process. If the provider process is unavailable the driver component receives no response from the test component.

In certain aspects a diagnostic transaction mimics other non diagnostic transactions of an application being monitored which allows the present invention to monitor any arbitrary customer defined transaction while avoiding the costly setup of synthetic transactions. Differences however do exist between diagnostic and non diagnostic transactions. Diagnostic transaction functionality that is not shared by non diagnostic transactions include a detecting a failure isolated to particular software process and reporting that failure to the aforementioned sensor and autonomic manager which analyze the failure and initiate corrective action s b distinguishing an unavailable process from other factors that may cause a failed transaction e.g. faulty application code user error etc. c ascertaining while coupled with correlation of events over time or from other client processes whether there is an application failure or not and d isolating failure to a single process without initially determining whether the failure is caused by faulty business logic. Function d is a distinguishing feature of diagnostic transactions because business logic is absent from diagnostic transactions and present in non diagnostic transactions.

The availability of any arbitrary customer defined application transaction can be determined by executing a diagnostic transaction for each of the connections utilized by the application. Moreover to test the availability of multiple applications the process of executes a single diagnostic transaction for each communication connection between processes of every process pair. For example if application X utilizes the connection between process P and process P via API I and application Y utilizes the same P to P connection via API I the P to P connection needs to be tested with a diagnostic transaction only once to facilitate determining the availability of both applications X and Y.

The following pseudo code is an example of an initiation of a diagnostic transaction by a consumer process. The diagnostic transaction tests the establishment of a connection between the consumer process and a relational database via the JDBC API.

In one embodiment a driver component of a consumer process being monitored includes 1 a driver manager that returns results from the connection tests of step to a sensor residing in the same node that includes the consumer process and 2 one or more driver routines one routine for each of the distinct APIs associated with the connections to be tested. Further a test component included in a provider process being monitored includes 1 the resources necessary to validate the functionality of the provider process and 2 a test manager that initializes the resources and which is in communication with a sensor residing in the same node that includes the provider process.

The test component contents vary according to the particular provider process on which it resides. For example if the provider process is a relational database process e.g. DB2 the test component may contain tables stored procedures or other database objects. As another example if the provider process is a message queue e.g. WebSphere MQ which is available from International Business Machines Corporation the test component may contain queue managers queues and transmission agents.

After the test of a connection e.g. the connection between driver component and test component of the driver component reports the result of the test i.e. whether the connection is available to the associated sensor e.g. sensor of . As used herein the availability of the connection is equivalent to the availability of the provider process that includes the test component utilized by the test. The sensor returns the test result to autonomic manager see . Each time a connection is tested a status adjacency matrix is updated to indicate that a connection is available or unavailable based on the test.

The testing of a connection described herein is also known as driving the connection or pinging the connection at an application level. Being a ping at an application level the test for availability described herein involves monitoring a provider process by invoking the public methods of the provider process i.e. the API utilized in communications with the provider process to verify that the provider process is functioning in the manner expected by the consumer of its services i.e. the consumer process . The connection between the consumer and provider processes in an application level ping does not require a network e.g. the consumer and provider process pair being monitored can be located on the same server .

It should be noted that an application level ping differs from a network level ping e.g. Internet Control Message Protocol ICMP . The provider process associated with a network level ping must be capable of supporting TCP IP and must be listening on a nominated TCP IP port. An application level ping does not have these restrictions and thus is capable of detecting faults on any process running on a node rather than only processes that are listening on TCP IP ports.

Inquiry step determines if a process has experienced a failure based on the availability diagnosis of step . If all processes utilized by applications are functioning properly i.e. are available based on the connection tests of step then no failure of an application is detected by autonomic manager see and the process repeats the polling of connections at step . If one or more tests of connections determine that one or more processes are unavailable to their respective application s then a failure affecting one or more applications is determined by autonomic manager see and the process continues with step .

Step determines the one or more applications impacted by the failure identified in step . The union of adjacency matrices formed in step is compared to the one or more processes identified as failed processes in step to determine which applications need to utilize the failed process es . The one or more applications that need to utilize the failed process es are identified as the application s impacted by the identified failure s . The determination of the impacted applications is performed by autonomic manager see .

Step determines if the applications determined in step are available. The step determination of availability is equivalent to a determination of availability of an information technology IT service. An IT service is an application whose availability is determined by the performance standards of an end user without regard to the number of tiers used by the application or the amount of redundancy employed. An IT service includes computer programs distributed across multiple systems processes and threads. The process of the present invention determines that an application is available only if an end user s performance standards also determine that the corresponding IT service is available. An application is available if step detected no failures in the processes utilized by the application.

If step determines that the applications determined by step are available then the process repeats starting at step i.e. periodic polling continues . Otherwise corrective action is taken in step to address the unavailability of the application s . If one or more applications are unavailable step can for example take a failed server offline prevent work associated with an application being monitored from being sent to a failed process start a new software process to provide a workaround for the failed process provision a new server to run the failed server or failed process or restart a failed process if the failure is determined to be transient i.e. restartable .

Step can also respond to unavailability determined in step by re routing workload associated with the impacted application s determined in step away from the one or more processes identified as failed processes in step . The re routing decisions are automatically made by autonomic manager see and are implemented by mechanisms e.g. effectors residing on nodes of system see . For example if redundancy were built into system of so that a clone of application server was part of the system an effector residing on reverse proxy server see is notified about the transactions that use a failed process of application server see . The effector modifies software on server see to direct all HTTP requests requiring the failed process to the clone not shown in of application server . Re routing workload away from the failed process prevents additional transactions from failing.

Furthermore performance modeling can determine if one or more applications are unavailable due to insufficient capacity in system see . In this case step can for instance add servers to the system to increase capacity.

When a diagnostic transaction determines that a connection Dto Tusing Iis functioning correctly the response returned by Tto Dis 1 otherwise 0 is returned. All diagnostic transactions must return a 1 for the application to be available. That is all the diagnostic transaction results are ANDed together to determine end to end availability of an application.

An adjacency matrix includes zero elements and non zero elements corresponding to the rows of provider processes of an application A and the columns of consumer processes of application A. A non zero element Irepresents the API that is used in communications including diagnostic transactions between the consumer process and provider process indicated by the column and row respectively that correspond to the non zero element. For example in adjacency matrix the element at the intersection of row Pand column Pis I which indicates that the API Iis used by any communication between the consumer process Pand the provider process P. A zero element in adjacency matrix indicates that application A does not include communications between the processes indicated by the corresponding row and column. For instance in adjacency matrix the zero at the intersection of row Pand column Pindicates that consumer process Pdoes not request any resources from provider process P.

It should be noted that a single driver component test component pair can be used in different applications while using a different API for each application or the same APIs in each application. For example both include driver component Dinitiating a diagnostic transaction that requests one or more resources managed by test component T. The API used with Dand Tin is Iwhile in the API is I.

Similar to when a diagnostic transaction of determines that a connection Dto Tusing Iis functioning correctly the response returned by Tto Dis 1 otherwise 0 is returned. All diagnostic transactions must return a 1 for application A to be available. If any of the diagnostic transactions return a 0 then application A is unavailable. That is all the diagnostic transaction results are ANDed together to determine end to end availability of an application.

Application A is deployed on reverse proxy server application server database server and a SAP server which is a financial package available from SAP AG of Walldorf Germany. Server includes process e.g. IBM HTTP Server server includes process e.g. WebSphere Application Server server includes processes and e.g. a CICS and DB2 for z OS process respectively and server includes processes and e.g. a SAP and DB2 process respectively . Process pairs in architecture are described above relative to and or . Architecture illustrates that process fails and is unavailable to the applications that utilize process .

An application is impacted by a failed process if a non zero element in the application s original adjacency matrix becomes a zero element in the application s adjacency matrix which has been updated after the failed process has been detected. is an update of the adjacency matrix of reflecting a process failure in accordance with embodiments of the present invention. Updated adjacency matrix illustrates that the failure of has an impact on the application of . The circled 0 element at row P column P indicates that a diagnostic transaction returned a failed condition for provider process P i.e. the failed process shown on . The circled 0 is a change from the original adjacency matrix see for the first application of which includes a non zero i.e. I element at the same Prow and Pcolumn. Because of this change from Ito 0 adjacency matrix indicates that the first application is impacted by the failure in process see . Moreover since process Pis unavailable any non zero element in the consumer process Pcolumn indicates another process utilized by the application that is unreachable due to the failure detected and shown in . For example since the circled Iappears in the Pcolumn of matrix the row corresponding to the circled I i.e. P indicates that process Pis unreachable through failed process P.

Although not shown an updated adjacency matrix for the second application of based on the failure of is exactly the same as the second application s original adjacency matrix see thereby indicating that the second application is not impacted by failed process see . That is the updated adjacency matrix indicates that all connections required by the second application are still available after the failure of process see .

When an application includes a set of redundant processes an OR operation is performed on the results returned from the diagnostic transactions associated with the set of redundant processes to determine availability within the set of redundant processes. In terms of adjacency matrices adjusted based on failed processes the OR operation is performed on the rows a.k.a. row operands of the adjusted adjacency matrix corresponding to the set of redundant processes and another OR operation is performed on the columns a.k.a. column operands of the adjusted adjacency matrix corresponding to the set of redundant processes. If the row based OR operation results in a zero value at a column where a non zero value had been located in the original adjacency matrix then a process is designated as unavailable and the application is determined to be not available. In contrast if the row based OR operation results in a non zero value corresponding to each of the non zero values in the row operands of the original adjacency matrix then the required application transactions can be routed via a redundant process instead of the failed process and the set of redundant processes is available. Similar availability diagnoses are made if the column based OR operation results in a zero value or in non zero values as described above.

As one example a row based OR operation is applied to redundant processes Pand Pin . Based on the failure of process Pin the Prow of adjacency matrix is adjusted to be all zeros. The adjusted Prow is ORed with the P row of adjacency matrix which results in 0 10 0 0 0 10 0 0 This result includes non zero Ivalues that are in the same columns as each of the non zero values included in row Pof the original adjacency matrix . A similar result with a non zero Ivalue is obtained with a column based OR operation between Pand P. Thus the set of redundant processes Pand Pis available even though process Phas failed.

As another example the row based OR operation is applied to redundant processes Pand Pin . Based on the failure of process P the Prow of adjacency matrix is adjusted to all zero values. The adjusted Prow is ORed with the Prow of adjacency matrix to obtain 0 0 0 0 0 0 10 0 0 Since the zero in the Pcolumn i.e. the second column in the result of the OR operation corresponds to a non zero value in the Pcolumn of the original adjacency matrix the process Pis designated as unavailable because it can no longer connect to the Pprocess. Code Examples

The following code example implements a diagnostic transaction utilized in step of . The code returns a failure i.e. unavailable or success i.e. available determination for a software process. An input XML file not shown identifies the LDAP services that are processed by the following code.

The following code examples implement the generation of initial application topologies using adjacency matrices and the determination of applications impacted by a failed process.

I O interface comprises any system for exchanging information to or from an external source. I O devices comprise any known type of external device including a display monitor keyboard mouse printer speakers handheld device printer facsimile etc. Bus provides a communication link between each of the components in computing unit and may comprise any type of transmission link including electrical optical wireless etc.

I O interface also allows computing unit to store and retrieve information e.g. program instructions or data from an auxiliary storage device such as a non volatile storage device e.g. a CD ROM drive which receives a CD ROM disk not shown . Computing unit can store and retrieve information from other auxiliary storage devices not shown which can include a direct access storage device DASD e.g. hard disk or floppy diskette a magneto optical disk drive a tape drive or a wireless communication device.

Memory includes computer program code comprising an application that includes logic for determining application availability. Further memory may include other systems not shown in such as an operating system e.g. Linux that runs on CPU and provides control of various components within and or connected to computing unit .

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with computing unit or any instruction execution system to provide and facilitate the capabilities of the present invention. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette RAM ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A computing system suitable for storing and or executing program code include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Furthermore the present invention discloses a method for deploying or integrating computing infrastructure comprising integrating computer readable code into computer system wherein the code in combination with computer system is capable of optimally scheduling an activity managed by a web application. The disclosed method for deploying or integrating computing infrastructure with the capabilities described herein can be offered as a service on a subscription service.

The flow diagrams depicted herein are provided by way of example. There may be variations to these diagrams or the steps or operations described herein without departing from the spirit of the invention. For instance in certain cases the steps may be performed in differing order or steps may be added deleted or modified. All of these variations are considered a part of the present invention as recited in the appended claims.

While embodiments of the present invention have been described herein for purposes of illustration many modifications and changes will become apparent to those skilled in the art. Accordingly the appended claims are intended to encompass all such modifications and changes as fall within the true spirit and scope of this invention.

