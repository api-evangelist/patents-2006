---

title: Qualitatively annotated code
abstract: Data associated with at least one module of code may be annotated in such a manner as to provide guidance regarding usage of the module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07987456&OS=07987456&RS=07987456
owner: Microsoft Corporation
number: 07987456
owner_city: Redmond
owner_country: US
publication_date: 20060124
---
Applications programs functions and other assemblages of programmable and executable code are typically written for third party i.e. customer usage. Therefore effective code is written in such a manner that third party usage scenarios are enabled and meet third party expectations.

As applications programs functions and other assemblages of programmable and executable code are modularized data associated with at least one such module of code may be annotated so as to provide qualitative guidance regarding usage of the module.

Tools systems and methodologies for producing annotated code and using the annotations to provide guidance regarding the usage of the code are described herein. Further the description pertaining to annotating at least portions of code and using the annotations may relate to tools systems processes instructions techniques and routines that may be utilized to inform customers of an intended use of portions of code. That is by annotating at least portions of code with a persona or classification that is indicative of a e.g. functional intent of the respective portions of code customers may be empowered to write a highly efficient application program function or other assemblage of programmable and executable code that is not likely to break or crash. Further still such tools systems and processes may be implemented in one or more devices or nodes in a network environment.

 Module as described herein may refer to separate entities such as methods classes DLLs dynamic link libraries frameworks etc. that may utilize common physical and or logical resources.

Client device may represent at least one of a variety of known computing devices including a desktop personal computer PC workstation mainframe computer Internet appliance set top box or gaming console that is able to implement example technologies for at least one of producing and utilizing qualitatively annotated code . Client device may further represent at least one device that is capable of being associated with network by a wired and or wireless link including a mobile i.e. cellular telephone personal digital assistant PDA laptop computer etc. Further still client device may represent the client devices described above in various quantities and or combinations thereof. Other device may also be embodied by any of the above examples of client device .

Server device may represent any device that is capable of providing any of a variety of data and or functionality to client device or other device in accordance with at least one implementation for at least one of producing and utilizing qualitatively annotated code . The data may be publicly available or alternatively restricted e.g. restricted to only certain users or only if an appropriate subscription or licensing fee is paid. Server device may be at least one of a network server an application server a blade server or any combination thereof. Typically server device may represent any device that may be a content source and client device may represent any device that may receive such content either via network or in an off line manner. However according to the example implementations described herein client device and server device may interchangeably be a sending node or a receiving node in network environment . Other device may also be embodied by any of the above examples of server device .

 Other device may represent any further device that is capable of developing and or utilizing qualitatively annotated code according to one or more of the example technologies described herein. That is other device may represent a device that is capable of annotating at least a portion of code with a persona or classification that is indicative of e.g. a functional intent of the respective portions of code and or provide a customer with guidance regarding the usage of the portion of code based on the assigned persona. Thus other device may be a computing or processing device having at least one of an operating system an interpreter converter compiler or runtime execution environment implemented thereon. These examples are not intended to be limiting in any way and therefore should not be construed in that manner.

Network may represent any of a variety of conventional network topologies and types which may include wired and or wireless networks. Network may further utilize any of a variety of conventional network protocols including public and or proprietary protocols. Network may include for example the Internet as well at least portions of one or more local area networks also referred to individually as a LAN such as an 802.11 system or on a larger scale a wide area network i.e. WAN or a personal area network i.e. PAN such as Bluetooth.

Computer architecture in at least one of devices and has typically defined computing platforms in terms of hardware and software. Software for computing devices has been categorized into groups based on function which may include a hardware abstraction layer alternatively referred to as a HAL an operating system alternatively referred to as OS and applications.

A runtime execution environment may reside between an OS and an application program function or other assemblage of code. The runtime execution environment may serve as a space in which the application program function or other assemblage of code may execute specific tasks on any one or more of processing devices and . More particularly a runtime execution environment may enhance the reliability of the execution of an application program function or other assemblage of code on a growing range of processing devices and including servers desktop computers laptop computers and mobile processing communication devices by providing a layer of abstraction and services for an application running on such devices and by further providing the application with capabilities including memory management and configuration thereof.

A runtime execution environment may serve as at least one of a programming and an execution platform. As a programming platform a runtime execution environment may compile one or more targeted applications programs functions or other assemblages of code which may be written in one of multiple computing languages into an intermediate language hereafter IL or bytecode. IL is typically independent of the platform and the central processing unit hereafter CPU executes IL. In fact IL is a higher level language than many CPU machine languages.

As an execution platform a runtime execution environment may interpret compiled IL into native machine instructions. A runtime execution environment may utilize either an interpreter or a compiler e.g. just in time alternatively JIT compiler to execute such instructions. Regardless the native machine instructions may then be directly executed by the CPU. Since IL is CPU independent IL may execute on any CPU platform as long as the OS running on that CPU platform hosts an appropriate runtime execution environment.

Alternatively at least portions of applications programs functions or other assemblages of code may be precompiled and installed as a native image file in the runtime execution environment thus circumventing CPU consumption required for JIT compilation. Effectively the precompiled portions are software components that are distributed in an IL format e.g. assemblies methods or types rather than in a native platform execution format. A source of such precompiled IL may be disposed in either of a non managed execution environment or a separate implementation of a runtime execution environment on a same or separate one of devices and . The source may deploy the precompiled IL during or before install time for the application program method function or other assemblage of programmable and executable code to which the precompiled IL corresponds.

Regardless examples of runtime environments in which technologies for producing and or utilizing qualitatively annotated code may be implemented include Visual Basic runtime environment Java Virtual Machine runtime environment that is used to run e.g. Java routines or Common Language Runtime CLR to compile e.g. Microsoft .NET applications into machine language before executing a calling routine. However this listing of runtime environments provides examples only. The example technologies described herein are not limited to just these managed execution environments. More particularly the example implementations are not just limited to managed execution environments for one or more examples may be implemented within testing environments and or unmanaged execution environments.

An application program function or other assemblage of code compiled into IL may be referred to as managed code and that is why a runtime execution environment may be alternatively referred to as a managed execution environment. It is noted that code that does not utilize a runtime execution environment to execute may be referred to as a native code application.

According to at least one example implementation runtime execution environment may facilitate execution of managed code for a computing device platform. Managed code may be considered to be part of a core set of application development technologies and may further be regarded as an application program function or other assemblage of programmable and executable code that is compiled or loaded for execution in runtime execution environment to provide a corresponding service to the computing device platform. In addition runtime execution environment may translate managed code at an interpretive level into instructions that may be proxied and then executed by a processor. Alternatively managed code may be executed via an interpreter or a compiler or a form of a compiler designed to run at install time as a native image. A framework for runtime execution environment also provides class libraries which may be regarded as software building blocks for managed applications.

Runtime execution environment may provide at least partial functionality that may otherwise be expected from a kernel which may or may not be lacking from a computing device platform depending upon resource constraints for a particular one of devices and see . Thus at least one example of runtime execution environment may implement the following input output hereafter I O routine management compiling memory management and service routine management. Thus runtime execution environment may include I O component compiler at least one memory management component service routine management component and execution component . These components which are to be described in further detail below are provided as examples which are not intended to be limiting to any particular implementation of runtime execution environment and no such inference should be made. Thus the components may be implemented in examples of runtime execution environment in various combinations and configurations thereof.

I O component of runtime execution environment may provide at least one of synchronous or asynchronous access to physical resources e.g. processor and peripherals and logical resources e.g. drivers or physical resources partitioned in a particular manner associated with the computing device platform. More particularly I O component may provide runtime execution environment with robust system throughput and further streamline performance of an application program function or other assemblage of programmable and executable code from which an I O request originates.

Compiler may refer to a component within runtime execution environment that may interpret compiled IL into native machine instructions for execution in runtime execution environment . Further in accordance with at least one alternative implementation of technologies for developing and utilizing qualitatively annotated code compiler may dynamically instrument for profiling recording purposes for various purposes the behavior of modules of code associated with an application program function or other assemblage of programmable and executable code. The modules of code may or may not be loaded into runtime execution environment . If the modules of code are loaded into runtime execution environment the profiling may include recording or otherwise tracking interaction between the respective modules of code and one or more components of runtime execution environment . Such interaction between a respective module of code and a particular component of runtime execution environment includes the receiving and transmitting of data parameters and state. The profiling may be performed without touching or affecting an executable portion of the code modules and may be performed at compile time initial runtime or at any time thereafter relative to execution of an executable portion of the execution paths.

Loader may refer to an assembly manager that may be invoked to locate and read assemblies as needed. Loader may be disposed in execution environment although at least one implementation of an unmanaged execution environment i.e. OS may include loader therein. Loader may garner precompiled IL during deployment or install time for loading into runtime execution environment . Thus according to at least one alternative implementation of runtime execution environment loader may effectively serve as an entry point for precompiled IL into runtime execution environment .

Memory management component may be referred to as a garbage collector which implements garbage collection. Garbage collection may be regarded as a robust feature of managed code execution environments by which an object is automatically freed i.e. de allocated if upon a sweep or scan of a memory heap an object is determined to no longer be used by an application program function or other assemblage of code. Further functions implemented by memory management component may include managing one or more contiguous blocks of finite volatile RAM i.e. memory heap storage or a set of contiguous blocks of memory amongst the tasks running on the computing device platform allocating memory to at least one application program function or other assemblage of programmable and executable code running on the computing device platform freeing at least portions of memory on request by at least one of the applications programs functions or other assemblages of code and preventing any of the applications programs functions or other assemblages of code from intrusively accessing memory space that has been allocated to any of the other applications programs functions or other assemblages of code.

Service routine manager may be included as at least a portion of an application support layer to provide services functionality for physical and logical resources associated with the computing device platform. Example technologies e.g. tools methodologies and systems for developing and or utilizing qualitatively annotated code may be managed by service routine manager . That is such technologies may be implemented either singularly or in combination together by compiler as referenced above service routine manager or some other component of runtime execution environment in accordance with various alternative implementations of such technologies. Such contribution by service routine manager may be made without touching or affecting an executable portion of the modules of code at compile time initial runtime or at any time thereafter relative to execution of an executable portion of the code modules.

Execution component may enable execution of managed code for the computing device platform. More particularly with regard to implementation of technologies for developing and or utilizing qualitatively annotated code execution component may serve as an exemplary component within runtime execution environment that may implement one or more of the tools systems and processes for annotating and or interpreting an annotation for one or more code modules at compile time initial runtime or at any time thereafter during execution of an executable portion of the code modules.

Further qualitatively annotated code may be managed code that is compiled by or pre compiled for runtime execution environment . Regardless potential performance related failures for respective modules of the code may be foreseen if not clearly anticipated and therefore circumvented to a desirable extent.

To that end qualitatively annotated code may provide generalized guidance that is robust. That is by providing qualitative guidance as opposed to quantitative guidance whereby strict rules corresponding to a respective module of code must be modified along with any revisions to the code the persona or classification corresponding to qualitatively annotated code may tolerate changes to the code and therefore serve as prescriptive guidance rather than prohibitive guidance.

Further still the general guidance provided by the respective personae or classifications assigned to respective modules of qualitatively annotated code may indicative the preferred methods that may be called by code behaviors that code may invoke the dependencies that code may have or even indicate a prescribed degree of complexity based on e.g. a complexity parameter such as cyclomatic complexity. Of course such guidance is provided as examples only to illustrate the broad range of programming factors that may be influenced by a persona or classification assigned to qualitatively annotated code .

Regardless in the following description various operations will be described as being performed by components associated with code annotating tool . The operations that are described with respect to any particular one of these components may be carried out by the component itself in combination with other components associated with the tool or by the particular component in cooperation with one or more components of runtime execution environment see . In addition the operations of each of the component of code annotating tool may be executed by a processor or processors and implemented as hardware firmware or software either singularly or in various combinations together.

Example implementations of code annotating tool may be implemented in an off line manner separate from any of the components of runtime execution environment . However at least one implementation of code annotating tool may be incorporated with any of a portion of compiler service routine manager or some other component of runtime execution environment either singularly or in combination together. In such an implementation code annotating tool may be executed or processed by execution component .

Module may refer to one or more modules of executable instructions corresponding to an application program function or other assemblage of code being executable in accordance with e.g. execution component in runtime execution environment . More particularly module may refer to an entity such as methods classes DLLs dynamic link libraries frameworks etc.

Code may refer to an application programming interface alternatively referred to as an API hereafter that is associated with module . More particularly API may be regarded as one or more methods or routines that are exposed by a class and used by an application program method function or other assemblage of code to direct the performance of procedures by runtime execution environment or even an operating system.

Code annotating tool may refer to a multi functional tool that may be capable of facilitating the annotation of modules of code corresponding to an application program function or other assemblage of code in accordance with an appropriate persona or classification facilitating the monitoring recording and or profiling activity of such a module of code in accordance with at least one of a functional intent of the respective module or an assigned persona or classification and providing guidance regarding usage of the module of code in accordance with at least one of an intent of the module of code or a persona or classification assigned to the module of code.

Analyzer which may be disposed within or otherwise functionally associated with code annotating tool may be regarded as a component that is capable of associating an appropriate annotation or classification with a module of code based on characteristics including but not limited to a functional intent of the module of code. An analyzer may further be capable of reading an annotation associated with a module of code corresponding to an application program function or other assemblage of code and is still further capable of communicating the content of such annotation to a user either singularly or in combination with another component of code annotating tool .

Module may refer to a module of executable instructions corresponding to an application program function or other assemblage of code being executable in accordance with e.g. execution component in runtime execution environment . More particularly module may refer to an entity such as methods classes DLLs dynamic link libraries frameworks etc. that includes code and an associated annotation .

Annotation may refer to a text file that is associated with code . In particular annotation may be a text file e.g. XML listing a persona or classification that has been assigned to code by code annotating tool or annotation may be a text file that articulates e.g. functional characteristics or intent of code . Annotation is associated with code and therefore may be received into and compiled by runtime execution environment attached to code as part of module . Alternatively annotation though associated with code may be pre compiled and thus received into runtime execution environment separate from code . For example annotation may be received into runtime execution environment on line via network see from a developer or administrator for executable code or annotation may be received into runtime execution environment in an off line manner e.g. via a transportable computer readable medium from either of the aforementioned developer or administrator.

As stated above annotation may list a persona or classification that has been assigned to code . Such persona or classification may provide data indicative of a functional intent of code e.g. API method or routine . That is the data may indicate one or more contexts in which the use of code may be appropriate. Further in order to qualitatively inform a customer of an intended use of code for superior code generation or exceptional code profiling the personae or classifications associated by analyzer are typically related to each other with regard to the analyzed characteristics and the personae or classifications are typically regarded as approximations that provide reliable guidance but also permit for exceptions and or creativity.

Examples of a persona or classification assigned to code may include as illustrative examples only inner loop code throughput code interactive code and startup code. The nomenclature for such personae is provided only as an example. The personae or classifications may be assigned any of a variety of names though it may be preferable to assign a name that is indicative of a functional intent or other functional characteristic of code for the respective persona or classification.

An inner loop code persona may indicate that code is likely to be called in a bigger loop by a client application program function or other assemblage of code as part of a bigger algorithm. More particularly inner loop code may be regarded as code that is inner most to a corresponding application program function or other assemblage of code. Examples of which include comparison functions hashing functions low level formatting functions etc. For such code memory allocation may be discouraged. Annotation associated with inner loop code may advise that such code may be called by code that is assigned any of the example code personae classifications described below e.g. throughput interactive and startup .

A throughput code persona may indicate that code is likely to be used in a batch process or service process such as on a webpage. More particularly throughput code may be regarded as code for which temporary objects may be created and therefore some memory allocation may be permitted. Such code may be typically implemented by a webpage or business logic and an intention of such code is to execute regardless of the cost in resources e.g. memory . An example of guidance for throughput code is that throughput code is not functionally compatible with inner loop code and therefore may not be called by inner loop code. Therefore annotation associated with throughput code may advise against or even prohibit calling code that has been assigned the inner loop persona or classification.

An interactive code persona may indicate that code is likely to be used by part of an application program function or other assemblage of code that is driven by interactive events. More particularly interactive code may be regarded as code for which modes may change suddenly and an intention of such code is to use as few resources e.g. memory as possible during execution thereof. An example of guidance for interactive code is that interactive code may call inner loop code. Therefore annotation associated with interactive code may advocate calling code that has been assigned the inner loop persona or classification. A further example may include interactive code calling throughput code but this is an unlikely scenario since interactive code is intended to be frugal with regard to resources used and throughput code is intended to persist regardless of the cost in resources. Therefore annotation associated with interactive code may further discourage calling code that has been assigned the throughput code persona or classification.

A startup code persona may indicate that code is likely to appear on a startup path for a corresponding application program function or other assemblage of code. More particularly startup code may be regarded as code that is sensitive to dependencies and input output IO . Annotation associated with startup code may discourage or deny calls from code that has been assigned another persona or classification.

Accordingly when programming an application program function or other assemblage of programmable executable code that includes a call to code annotation may provide a programming customer with guidance that includes but is not necessarily limited to interactive guidance diagnostic i.e. profiler guidance code generating guidance code maintenance guidance and inference guidance. All of these categories of guidance described above may be implemented by analyzer based on e.g. a known functional intent of code . These example categories of guidance are described below.

Interactive programming guidance may provide an indication of the functional compatibility of code with a more recently called implementation of code which may or may not be e.g. an API method or routine to which another persona or classification has been assigned. Alternatively interactive programming guidance may provide a programming rule that warns of potential programming violations for the persona or classification assigned to code relative to the aforementioned more recently called implementation of code .

Diagnostic i.e. profiler guidance may provide reports pertaining to measured programming events for code and or the persona or classification that has been assigned to code . More particularly based on a record of programming events pertaining to code and or the persona or classification to which code has been assigned diagnostic profiler guidance may provide a statistical analysis and or recommendation regarding the usage of code . The analysis and or recommendation may even include a measurement of programming events pertaining to code against previously recommended guidance. The record of programming events may be generated by e.g. analyzer and the programming events may include but are in no way limited to functions by which code has been previously called and a number of times that code has been called for a particular application program function or other assemblage of code etc.

Code generating guidance may provide programming guidance for a compiler e.g. compiler see . For example code generating guidance may provide a likely indication of a functional intent of code and therefore the compiler may compile code in such a manner to exploit the characteristics of compiled code . More particularly code generating guidance articulated by annotation may indicate that a functional intent of interactive code is to use as few resources as possible and therefore the compiler may be guided to compile code in a compact manner to reduce space used thereby. Alternatively code generating guidance may indicate that a functional intent of inner loop code is to not have memory allocated thereto and therefore the compiler may be guided to compiler in a manner to optimize for speed. These scenarios are provided as examples only and should not be construed as limiting in any manner.

Code maintenance guidance may provide programming guidance that provides one or more rationale for the persona or classification that has been assigned to code . Such guidance may further provide an explanation of a persona or classification that may be assigned to code if at least a portion of code was to be changed. Thus code maintenance guidance may in part guide a transition from code assigned a particular persona or classification to code assigned to another persona or classification.

Inference guidance may provide when code annotating tool is utilized as part of a static analysis tool a retroactive annotation for code . That is for an application program function or other assemblage of programmable executable code that has already been compiled analyzer may retroactively assign a persona or classification for code . Thus an analysis of code as well as functions that have called code and functions that have been called by code may be provided to a customer.

In the following description various operations will be described as being performed by components associated with either of runtime execution environment see or code annotating tool see although the reference numbers in may differ from those of the prior figures. The operations that are described with respect to any particular one of these components may be carried out by the component itself in combination with other components associated with the tool or by the particular component in cooperation with one or more components of runtime execution environment . In addition the operations of each of the component of code annotating tool may be executed by a processor or processors and implemented as hardware firmware or software either singularly or in various combinations together.

Block may refer to a catalytic action that is taken or about to be taken that may affect a module of code such as an API method or routine. Such catalytic action may include the module of code being called by another module of code.

Data module therefore may refer to one or more modules of executable instructions corresponding to an application program function or other assemblage of code being executable in accordance with e.g. execution component in runtime execution environment . More particularly data module may refer to an entity such as methods classes DLLs dynamic link libraries frameworks etc.

Code may refer to an API method or routine that is associated with data module . More particularly code may be exposed by a class and used by an application program method function or other assemblage of programmable and executable code to direct the performance of procedures by runtime execution environment or even an operating system.

Analyzer may refer to a component that is capable of associating an appropriate annotation or classification with a module of code based on characteristics including but not limited to a functional intent of the module of code. Analyzer may be associated with a more comprehensive tool for developing and or utilizing annotated code or alternatively may even be implemented as a component e.g. compiler of runtime execution environment .

Regardless having received code incorporated within or separate from data module analyzer may implement a predetermined algorithm for determining a functional intent or other functional characteristics of code to thereby associate a persona or classification with code . Basing the persona or classification of code on a functional intent thereof is described as an example only.

Annotated guidance may refer to a text file that is associated with code . In particular annotation may be a text file e.g. XML listing a persona or classification that has been assigned to code by code annotating tool . Alternatively annotated guidance may be presented to a customer as part of a user interface in the form of for example a dialog box or drop down menu that articulates the rule or guidance associated with code color coded fonts e.g. green for acceptable yellow for caution and red for prohibited .

Block may refer to a catalytic action that is taken or about to be taken that may affect a module of code such as an API method or routine. Such catalytic action may include the module of code being compiled or being submitted to be compiled.

Data module similar to data module may refer to one or more modules of executable instructions such as methods classes DLLs dynamic link libraries frameworks etc.

Annotation may refer to a text file that is associated with code in the form of e.g. a text file e.g. XML to list a persona or classification that has been assigned to code based on a functional intent or other specified functional characteristic of code . More particularly according to this second example of data flow code has already been annotated by either of a manual process or an automated process as described herein.

Analyzer may refer to a component that is capable of reading annotation associated with code . Thus as part of runtime execution environment analyzer may provide annotated guidance for compiler see so that code may be compiled in order to be functionally compatible with the functional intent articulated in annotation .

A third example implementation of data flow relates to a manual or automatic code profiler or diagnostic tool.

Block may refer to a catalytic action that is taken or about to be taken that may affect a module of code such as an API method or routine. In the context of a code profiler such catalytic action may include previously compiled code being submitted to a profiling tool for analysis or any other form of examination or study.

Data module may refer to one or more modules of executable instructions such as methods classes DLLs dynamic link libraries frameworks etc.

Analyzer may refer to a component that is capable of reading code that has already been compiled and is capable of deciphering a functional intent or other designated functional characteristic of code based on established criteria. Thus analyzer may be further capable of associating an appropriate persona or classification with code .

Annotated guidance may refer to a text file that is associated with code that articulates the persona or classification that has been assigned to code by analyzer . Additionally annotated guidance may articulate a rule or other form of programming guidance corresponding to the particular persona or classification. Annotated guidance may be presented to a customer as part of a user interface in the form of for example a dialog box or drop down menu that articulates the rule or guidance associated with code color coded fonts e.g. green for acceptable yellow for caution and red for prohibited .

By the description above pertaining to a persona or classification may be assigned to one or more modules of code to provide qualitative programming guidance in either a managed execution environment or an unmanaged execution environment. However the example implementations described herein are not limited to just the environment of the components of an execution path as in or the process of . Technologies e.g. tools methodologies and systems associated with qualitatively annotated code see may be implemented by various combinations of the components described with reference to .

Further the computer environment for any of the examples and implementations described above may include a computing device having for example one or more processors or processing units a system memory and a system bus to couple various system components.

The computing device may include a variety of computer readable media including both volatile and non volatile media removable and non removable media. The system memory may include computer readable media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM or flash RAM. It is appreciated that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes or other magnetic storage devices flash memory cards CD ROM digital versatile disks DVD or other optical storage random access memories RAM read only memories ROM electric erasable programmable read only memory EEPROM and the like can also be utilized to implement the example computing system and environment.

Reference has been made throughout this specification to an example alternative examples at least one example an implementation or an example implementation meaning that a particular described feature structure or characteristic is included in at least one implementation of the present invention. Thus usage of such phrases may refer to more than just one implementation. Furthermore the described features structures or characteristics may be combined in any suitable manner in one or more implementations.

One skilled in the relevant art may recognize however that code module initialization may be implemented without one or more of the specific details or with other methods resources materials etc. In other instances well known structures resources or operations have not been shown or described in detail merely to avoid obscuring aspects of the invention.

While example implementations and applications of the code module initialization have been illustrated and described it is to be understood that the invention is not limited to the precise configuration and resources described above. Various modifications changes and variations apparent to those skilled in the art may be made in the arrangement operation and details of the methods and systems of the present invention disclosed herein without departing from the scope of the invention as both described above and claimed below.

