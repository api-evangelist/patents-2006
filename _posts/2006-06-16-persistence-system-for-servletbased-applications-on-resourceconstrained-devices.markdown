---

title: Persistence system for servlet-based applications on resource-constrained devices
abstract: A persistence management system facilitates porting servlet-based applications, such as Web applications, to an extremely mobile/nomadic system such as a resource-constrained device platform, e.g., a smart card, where sessions on a card acceptance device are intermittent by nature. Persistence management system (i) minimizes the startup time, and (ii) restores applications in a consistent state. The persistent management system supports: a) selective persistence of servlet model objects: both container-managed objects and application-managed objects; b) optional persistence of threads; and c) optional persistence of connection objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07900200&OS=07900200&RS=07900200
owner: Oracle America, Inc.
number: 07900200
owner_city: Redwood City
owner_country: US
publication_date: 20060616
---
The present invention relates generally to resource constrained devices such as smart cards and more particularly to implementing servlet based applications on resource constrained devices.

Java Card technology enables programs written in the Java programming language and utilizing applets to be run on smart cards and other small resource constrained devices. Java Card and Java are trademarks of Sun Microsystems Inc. of Santa Clara Calif. Developers can build and test programs using standard software development tools and environments then convert the programs into a form that can be installed onto a Java Card technology enabled device. Java Card implementations support persistence of applet data across sessions where a session extends from insertion of the resource constrained device into a card acceptance device CAD until removal of the resource constrained device from the CAD.

Herein the applet data is for applet applications i.e. applications servicing requests over the ISO7816 APDU protocol. Applet applications include at least one applet.

While persistent memory is typically implemented with EEPROM Electrical Erasable Programmable Read Only Memory and volatile non persistent memory is implemented with RAM Random Access Memory transient that is non persistent objects may still be allocated in EEPROM when there is shortage of RAM memory. Typically the amount of RAM even on a high end resource constrained device is small e.g. 16 to 32 Kbytes.

Java Card implementations also support isolation of application execution contexts. Isolation means that a Java Card application cannot access data or code of an application in another context unless the other application explicitly provides an interface for access. Context isolation is enforced by Java Card firewalls. Applications can provide interfaces for other applications to access in the form of Shareable Interface Objects which allow secure access across the application firewalls.

Application software for the Java Card platform was limited to implementing the Java Card applet application model. Typically the Java Servlet based application model used on server machines has not been implemented directly on resource constrained device such as smart cards because as explained more completely below resource constrained devices do not include the resources found on server machines.

A servlet is a Java technology based Web component managed by a container. Servlets are Java classes that are run by a Java technology enabled Web server. A servlet container contains and manages servlets through their lifecycle. Servlets interact with Web clients via a request response paradigm implemented by the servlet container. While not limited to it a servlet container typically supports HTTP and HTTPS HTTP over SSL or TLS as a protocol for requests and responses. A servlet container may provide additional services to the applications being run by the servlet container.

Web applications are collections of servlets and other components and resources bundled along with a deployment descriptor to be deployed into a servlet container. The application deployment descriptor conveys the elements and configuration information of an application between the different actors during the application lifecycle namely application developers application assemblers and deployers or in the context of Java Card technology smart card issuers. To any Web application corresponds a context named a servlet context. A servlet context defines a servlet s view of the Web application within which the servlet is running.

The Hypertext Transfer Protocol HTTP is by design a stateless protocol. To build effective Web applications it is imperative that requests from a particular client be associated with each other in what is called a session. Session tracking can be performed in a servlet based application via instances of interface HttpSession.

Unfortunately a smart card or other resource constrained device does not include a disk drive or large amounts of random access memory. Consequently the servlet model that depends on secondary storage on disk drives and large amounts of memory on a server cannot be implemented directly in a smart card.

Servlet based applications were originally intended to run on server machines which are intended to be always on and which benefit from reliability availability and serviceability features so that downtime is avoided or limited. Unlike these server machines when a new CAD session starts that is the resource constrained device has been inserted in a CAD the platform is reset and the volatile memory is cleared. Thus the content of the volatile memory is lost across CAD sessions. Only the persistent memory content is retained across CAD sessions.

The servlet model which was originally designed for server side applications does not account for an environment where the system can be brought down at any time. Re initializing the servlet based applications upon each platform reset would induce a performance penalty which is not compatible with smart card use. On the other hand indiscriminately persisting all objects of a servlet based application is not desirable since such persistence may imply additional cleanup to resume from a clean state. Moreover storing session data in persistent memory may have a performance impact during application operations depending on the frequency of updates. Unfortunately these factors inhibit the utilization of the servlet model to implement web based applications on a resource constrained device.

In one embodiment a persistent management system on a resource constrained device ensures the persistence across card acceptance device sessions card insertions in and tears from the card acceptance device of the state of a servlet based application deployed on the resource constrained device in accordance with the lifecycle of such application. The startup time including the restoration in a consistent state of a servlet based application is greatly accelerated. Additionally developers of servlet based applications do not have to handle thread persistence in any particular card specific way when compared to regular server hosted servlet based applications . Without thread persistence a developer would have to explicitly handle platform reset restart of an application and would have to recreate and restart threads.

In one embodiment upon starting execution of an application on a resource constrained device a logical persistence root object is created for all objects associated with the application. The objects are instantiations of at least one object orientated class. The persistent management system stores each object of the objects reachable from the logical persistence root in a persistent memory in the resource constrained device. Each object stored in the persistent memory is persistent across sessions until the application is unloaded. A session is started on insertion of the resource constrained device in a card acceptance device and the session is terminated upon removal of the resource constrained device from the card acceptance device.

In one embodiment the logical persistence root comprises a servlet context and the application is a servlet based application. The objects stored in the persistent memory include any one of or any combination of a filter an event listener and a load on start up servlet.

The method also includes storing a second object referenced from a first object stored in the persistent memory in the persistent memory. The first object is reachable from the logical persistence root. Thus the second object is indirectly referenced from the logical root of persistence.

The method stores objects not reachable from the logical persistent root in a non persistent memory in the resource constrained device. The non persistent memory is reset upon the start of the session.

To further enhance the performance of the application on the resource constrained device an object is used from a pool of objects. The pool of objects can be implemented in either the non persistent memory or the persistent memory. To avoid leaks of data in one embodiment the use of the pool of objects is limited to servlets of a same application.

To permit servlets in the application to spawn threads while minimizing the work required of the developer in restarting the threads when a session is stopped and restarted the method also includes automatically restarting a thread upon start of another session different from the session.

Hence in one embodiment a resource constrained device includes a persistent memory having stored therein a logical root of persistence a non persistent memory and a persistent management system. The persistent management system moves an object from the non persistent memory to the persistent memory when the object is referenced either directly or indirectly from the logical root of persistence. Also a pool of objects is stored in either or both of the non persistent memory and the persistent memory.

The resource constrained device also includes a facility for automatically restarting a thread upon start of a new session for the resource constrained device. A new session is started on insertion of the resource constrained device in a card acceptance device and the new session is terminated upon removal of the resource constrained device from the card acceptance device

A computer product having embedded therein computer readable instructions for a persistence management system wherein upon execution of the computer readable instructions on a resource constrained device generates a method comprising 

In the drawings and the following detailed description elements with the same reference numeral are the same or equivalents elements. Also the first digit of the reference numeral indicates the figure in which the corresponding element first appears.

As used in the following detailed description an interface is a named collection of method definitions and defines a protocol of behavior that can be implemented by any class in the class hierarchy. An interface defines a set of methods but does not implement them.

As used in the following detailed description the term network includes local area networks wide area networks the Internet cable television systems telephone systems wireless telecommunications systems fiber optic networks ATM networks frame relay networks satellite communications systems and the like. Such networks are well known in the art and consequently are not further described herein.

As used in the following detailed description resource constrained devices include devices having limited resources and or limited resource capacity. Resources include processors and memory. One example of a resource constrained device is a smart card sometimes referred to as a card having limited processing capacity and limited memory resources. One example of a smart card is a secure portable device such as a Java Card technology enabled device or the like. Java Card technology is described in Chen Z. Java Card Technology for Smart Cards Architecture and Programmer s Guide Boston Addison Wesley 2000.

As used in the following detailed description remote devices are computer devices and other devices with a processor and memory other than the particular resource constrained device capable of direct and or indirect interaction with the resource constrained device.

As used in the following detailed description a resource constrained device may support a multi application environment i.e. multiple applications coexist on the resource constrained device. One example of a multi application environment is a Java Card Runtime Environment JCRE . The JCRE is a computing environment or platform from Sun Microsystems that can run applications developed using the Java programming language and sets of development tools. The JCRE includes one or more JCRE contexts.

As used in the following detailed description a JCRE context is a system context that manages card resources processor memory I O interfaces and other system resources. Application containers execute in a JCRE context.

As used in the following detailed description a container manages application contexts and application lifecycle.

As used in the following detailed description an application context includes one or more executing applications.

As used in the following detailed description an application includes for example web applications e.g. applications servicing requests over the HTTP protocol.

As used in the following detailed description a servlet is a program that when executed generates dynamic content and interacts with off card web clients using a request response paradigm. Servlets can also interact with other on card applications. Servlets execute on a computer device such as a resource constrained device.

As used in the following detailed description an applet is a program that when executed interacts with off card APDU clients using a request response paradigm. Applets can also interact with other on card applications executing on a computer device such as a resource constrained device.

As used in the following detailed description an object is an instantiation of an object oriented computer program language entity such as a class.

As used in the following detailed description a card acceptance device is any device or connection for interfacing a resource constrained device with another device. Examples of card acceptance devices include but are not limited to devices in the prior art referred to as card acceptance device a USB interface that directly connects the resource constrained device to the terminal phone or desktop contactless readers called proximity coupling devices PCD which use a RF interface to connect to a resource constrained device and other interfaces such as MMC multi media card and NFC near field communication for connecting a resource constrained device to another device.

Despite the restraints imposed by a resource constrained device in one embodiment a persistence management system facilitates porting servlet based applications such as Web application to an extremely mobile nomadic system such as a resource constrained device platform e.g. a smart card where sessions on card acceptance device CAD are intermittent by nature. Persistence management system overcomes the problems of serviceability imposed by the frequent starting and stopping of CAD sessions sometimes called sessions while i minimizing the startup time and ii restoring applications in a consistent state. Additionally persistence management system makes this as transparent as possible to the developers of servlet based applications and maintains a consistent programming experience across platforms enterprise application servers and smart cards .

In one embodiment of this invention servlet based applications are implemented on resource constrained device and appear to both the programmer and the user to function in a matter equivalent to prior art based servlet applications on a normal server. Persistence management system for servlet based applications e.g. web applications installed deployed on resource constrained device ensures persistence across CAD sessions insertions in and tears from a card acceptance device of the state of servlet based applications deployed on a servlet container embedded on resource constrained device in accordance with the lifecycle of such applications to optimize serviceability.

As explained more completely below persistence management system differentiates what needs to be persistent from what needs not be to eliminate unnecessary re initialization or cleanup and achieve optimal readiness. Additionally persistence management system alleviates if not eliminates the need for the developer of such a servlet based application to account in any special way other than the one intended for card insertions in and tears from card acceptance device .

Prior to considering persistence management system in further detail one example of an implementation of Web applications on a resource constrained device that includes an embodiment of persistence management system is considered. In a multi application environment Java Card Runtime Environment JCRE is providing a JCRE context which is a system context that manages one or more containers e.g. servlet container which are executing on resource constrained device .

Servlet container further includes two web applications and that are each executing in a different firewall secured application context i.e. firewall secured application context and respectively. Web application includes a plurality of servlets e.g. servlets and while web application also includes a plurality of servlets e.g. servlets and . Firewall secured application context and are examples of servlet application execution contexts.

JCRE context may also include an inter application communication service that is executing on resource constrained device and other services. To avoid detracting from the description of this invention such services are not considered in further detail.

Isolation of application execution contexts and means that an application e.g. web application executing in one context cannot access objects of another application executing in another context e.g. web application unless the other application explicitly provides an interface for access. Isolation is typically enforced via firewalls at the application context level. In this embodiment firewalls permit access between applications only via controlled interfaces.

In this example interfaces for access across a firewall include Shareable Interface Objects which enable bypass of the firewall. Using a sharable interface object an application in one context can access an object of an application in another context while maintaining appropriate levels of security.

When executing web application for example servlet container may create instantiate container managed objects that is objects created by servlet container as per its operating principles. Web application may create instantiate application managed objects that is objects created by the application according to its business process. Container managed objects include instances of servlets filters and event listeners provided by the application developer as well as response request and event objects created when an HTTP request needs to be serviced or when a particular condition needs to be handled. All these objects container managed objects and application managed objects may be selectively maintained in persistent memory by persistence management system .

In one embodiment objects are maintained in persistent memory of resource constrained device according to the reachability of the objects from their application root objects which act as logical roots of persistence sometimes called logical persistence roots. All container managed objects and all application managed objects maintained in persistent memory should be reachable from these root objects. In servlet based applications servlet context object s e.g. one for each of contexts and define the servlets view of the Web application and ultimately of the container within which the servlets are running. There is only one instance of the servlet context associated with each Web application deployed into a container.

Therefore servlet context in this embodiment is designated as a persistence root for application managed objects and container managed objects pertaining to the application. Accordingly in this embodiment any application managed objects and any container managed objects reachable through servlet context are stored in persistent memory of resource constrained device . Servlet container also designates in this embodiment the web application s configured Event Listener s Filter s and load on startup servlet s as persistence root objects. But these persistence root objects are directly or indirectly via internal fields or helper method access reachable from the servlet context as shown in . Servlet context is therefore selected as the logical persistent root of the application.

Container managed objects are objects created by the container as per its operating principles and pertaining to a particular application such as the servlet context the filters the event listeners the servlets the sessions and the HTTP requests and responses. After a servlet container is instantiated and stored in persistent memory servlet context is one of the first objects instantiated in persistent memory when an application is being started up.

Typically at start up any filters associated with servlet container are also instantiated and stored in persistent memory . Filters are referenced either directly or indirectly through servlet context and may also be reachable via servlet context . As is known to those of skill in the art a filter or a filter chain is used in preprocessing or postprocessing information to subsequently provide appropriate information to a HTTP request object or to subsequently transform information from a HTTP response object respectively.

Also typically at start up any event listeners associated with the web application being started are instantiated and stored in persistent memory . Event listeners are referenced either directly or indirectly through servlet context and may also be reachable via servlet context . In addition to the standard event listeners supported by the servlet container to handle HTTP servlet related conditions one other embodiment of event listeners suitable for use with this invention is described in copending commonly assigned and commonly filed U.S. patent application Ser. No. 11 454 318 entitled A GENERIC EVENT NOTIFICATION SERVICE FOR RESOURCE CONSTRAINED DEVICES of Thierry Violleau Tanjore S. Ravishankar Sebastian Hans and Matthew R. Hill now U.S. Pat. No. 7 711 783 issued on May 4 2010 which is incorporated herein by reference in its entirety.

Also at startup any load on startup servlets are instantiated and stored in persistent memory . Load on startup servlets also are referenced either directly or indirectly through servlet context and may also be reachable via servlet context .

Subsequent to start up a container managed object or application managed object may be instantiated in non persistent memory . However if a reference to that object is made from any one of the objects stored in persistent memory that object is moved from non persistent memory to persistent memory . In this embodiment if objects in non persistent memory are reachable from an object in persistent memory those objects or object are moved from non persistent memory to persistent memory . In this embodiment the transfer of objects is always from non persistent memory to persistent memory as shown by arrow and not in the opposite direction.

Thus in this embodiment the following objects are maintained in persistent memory until the servlet based application associated with the objects is unloaded 

Note that starting and stopping a CAD session is not unloading the application. When a CAD session is stopped these objects in persistent memory are maintained and available when another CAD session is started. Thus the behavior seen by the developer and the user is equivalent to behavior on a normal server.

Load on demand servlets are created by container and are only maintained in non persistent memory at the longest until the CAD session ends. Load on demand servlets are created and initialized when there is a request to be serviced. References to load on demand servlets may be kept while there are requests to service or until container decides according to some other policy to destroy them or until the end of the CAD session.

HTTP sessions are created when new client application card interaction sessions are started and are only maintained in non persistent memory at the longest until the CAD session ends. References to HTTP sessions are maintained until HTTP sessions time out or until the end of the CAD session.

HTTP request and response objects are created when new requests need to be serviced and are maintained in non persistent memory while the requests are being serviced or until the end of the CAD session.

Event objects not shown are created in non persistent memory to encapsulate specific conditions that need to be handled. Event objects are maintained while the events are being handled or until the end of the CAD session.

In create logical root operation container in persistent memory creates the logical root of persistence object in persistence memory . In the embodiment of the logical root of persistence as explained above is servlet context for the application being started. Operation transfers processing to filter check operation .

Filter check operation determines whether at least one filter needs to be created. If at least one filter needs to be created for the application being started check operation transfers to create filters operation that in turn creates filters which includes at least one filter in persistence memory . Operation upon completion transfers to event listener check operation . If at least one filter is not needed check operation transfers directly to event listener check operation .

Event listener check operation determines whether at least one event listener needs to be created. If at least one event listener needs to be created for the application being started check operation transfers to create event listeners operation that in turn creates event listeners which includes at least one event listener in persistence memory . Operation upon completion transfers to load on start up servlets check operation . If at least one event listener is not needed check operation transfers directly to load on start up servlets check operation .

Load on start up servlets check operation determines whether at least one load on start up servlet needs to be created. If at least one load on start up servlet needs to be created for the application being started check operation transfers to create load on start up servlets operation that in turn creates load on start up servlets which includes at least one load on start up servlet in persistence memory . Operation upon completion transfers to container managed object check operation . If at least one load on start up servlet is not needed check operation transfers directly to container managed object check operation .

Container managed object check operation determines whether a current object being processed in non persistent memory is a container managed object and if the current object is a container managed object reachable check operation determines whether the current object is reachable from servlet context . If the current object is reachable from servlet context the current object is moved from non persistent memory to persistent memory in move to persistent memory operation . Note that the reachability may be from servlet context to an object that in turn references the object in non persistent memory and does not have to be directly from servlet context .

Herein when it is stated that an object is created in persistent memory it should not be interpreted as requiring creation of the object directly in persistent memory . Rather it should be interpreted as at the end of the creation process the object is resident in persistent memory . For example an object could be created in non persistent memory and then moved to persistent memory in the creation process.

Also the sequential sequence of operations presented in a process flow diagram are for convenience of explanation and should not be interpreted as limiting the invention to the sequential sequence. In view of this disclosure one of skill in the art can implement process in a resource constrained device based upon the capabilities provided by that platform to provide the desired performance and results.

All application managed objects that need to be persistent must be referenced directly or indirectly by servlet context which acts as the logical root of persistence as described above. These application managed objects may include not only business objects helper objects etc. that the application creates but also any object that is returned from a call to container and which is not by default persistent such objects could be stub objects returned by container to access a container service such as an event notification service. One embodiment of an event notification service is described in copending commonly assigned and commonly filed U.S. patent application Ser. No. 11 454 318 entitled A GENERIC EVENT NOTIFICATION SERVICE FOR RESOURCE CONSTRAINED DEVICES of Thierry Violleau Tanjore S. Ravishankar Sebastian Hans and Matthew R. Hill now U.S. Pat. No. 7 711 783 issued on May 4 2010 which was incorporated herein by reference in its entirety previously.

Since the persistence is by reachability applications objects to be persistent cannot only be directly stored in servlet context thru context attribute name value pairs but also thru any other persistent container managed object such as in the member fields of a load on startup servlet an event listener or filter. Thus operations to in process are also applicable to application managed objects.

Since session objects are not persistent application managed objects stored as session attribute name value pairs are not persistent.

In some situations it may be desired to reference an object in non persistent memory by an object in persistent memory but it is not desired to move the object in non persistent memory into persistent memory. For these cases a reified object reference sometimes called a transient reference object is available.

For example assume that load on startup servlet created a servlet custom object in non persistent memory . Next load on start up servlet stores object in servlet context and so servlet custom object is moved to persistent memory by persistent management system .

Servlet custom object needs to reference an object in non persistent memory e.g. HTTP request object . However it is not desired to move HTTP request object to persistent memory which would be done if servlet custom object referenced HTTP request object directly. Instead servlet custom object stores a reference to a reified object reference and the reference to HTTP request object is in reified object reference . Reified object reference is defined and managed so that any internal reference in reified object reference does not force the referenced object into persistent memory . Further the internal reference in reified object reference is valid only during a session. Upon a start of a new session the reference to reified object reference is still valid since the reified object reference itself is reachable and therefore in persistent memory but the internal references in reified object reference are invalid until specifically initialized.

Some of the container managed objects mentioned above are both very short lived and frequently created such as HTTP requests HTTP responses and events. On resource constrained devices such as device with limited resources the resulting memory allocation and garbage collection required by these very short lived and frequently created objects may be the cause of performance problems.

To alleviate the performance issues associated with memory allocation and garbage collection in one embodiment reusable object pools e.g. pool of reusable HTTP request and response objects are created in non persistent memory . Assuming that the HTTP request and HTTP response use objects in reusable object pool when a servlet needs a pair of the objects the objects are allocated from pool used and then returned to pool when not in use anymore. A HTTP request object for example is allocated from pool re initialized and populated with the incoming HTTP request data then passed to the service method and immediately and safely put back in pool after the service method has returned.

While the use of objects from a pool obviates the issues associated with repeated allocation and garbage collection extreme care must be taken to avoid leaking thru these objects data between unrelated applications. These objects should not only be cleared before being reused but also an application should be prevented from keeping any reference to these reusable objects after their standard lifecycle e.g. a reference to a HTTP request object after the request has been serviced to avoid applications unlawfully gaining access to data when these objects are reused in a different context. The firewall could typically be in charge of preventing an application from keeping a reference to such objects.

However if an object in persistent memory points to an object from one of the pools the pooled object is moved into persistent memory. This complicates re use of that pooled object. In one embodiment if this occurs the pooled object in persistent memory is discarded from the pool. To avoid this problem the reified object reference discussed above could be used by objects in persistent memory when using an object from a pool so that the object from the pool is not moved into persistent memory .

A container wide object reuse policy could put undesired additional burden on the firewall. Another more effective solution is to limit the scope of reuse of such pooled objects to the application itself i.e. reuse of the objects in a pool is limited to servlets of the same application. Since the reuse would happen within the same isolation context references to these objects do not need to be protected by the firewall. This approach limits reuse of objects in pools within the same isolation context.

Some of the container managed objects mentioned above are by default short lived also referred to as transient. A particular implementation may nevertheless implement reusable object pools in persistent memory and reuse these otherwise transient objects across CAD sessions hence reducing memory allocation and garbage collection. Note that this can be extended to all transient container managed objects but it takes its full value with short lived objects such as events requests and responses. Nevertheless as already mentioned because of the write performance of persistence memory such as EEPROM reusing persistent objects to avoid creating new objects each time may also have performance degradation instead of gain depending on the frequency of updates. Therefore an implementor should very carefully evaluate implementing application wide reusable object pools in non persistent memory such as RAM and implementing application wide reusable object pools in persistent memory such as EEPROM.

In some embodiments servlet based applications are allowed to spawn new application threads which may stay alive for the application lifetime i.e. until the application is unloaded. When a normal server goes down a developer used to developing servlet based web applications on server platforms typically expects the application to be restarted from scratch. In an environment such as smart cards or other resource constrained devices applications may be interrupted at anytime when cards are torn from their card acceptance devices and all the threads created by the applications are then interrupted.

For performance and serviceability reasons applications are not restarted from scratch on a smart card and relevant application state is maintained in persistent memory to eliminate unnecessary re initialization or cleanup and achieve optimal readiness. Upon platform reset the servlet based application must therefore resume the threads in a way consistent with the application s state.

On a smart card platform threads cannot be safely resumed from their point of execution at the interruption time. The threads must be restarted. Thus in one embodiment the application developer must keep track of all such threads and must instantiate and start new threads for each new session.

To alleviate if not eliminate the need for the developer to account for such situations in another embodiment thread persistence is provided. Without this thread persistence as noted above a developer would have to explicitly handle platform reset restart of an application and would have to recreate and restart threads manually . The downside to this is not only inconvenience but also potential incorrect behavior or security problems if the developer makes a mistake.

Persistence of objects is discriminately extended to java.lang.Thread objects so that such threads can be restarted automatically upon restart of the application i.e. platform reset . In this embodiment thread objects are like any other object persistent by reachability i.e. threads are reachable via servlet context and so are stored in persistent memory . However execution stacks associated with threads respectively are not persistent. In this embodiment a persistent thread a thread object that is reachable from servlet context is by default automatically restarted at the beginning of method run of the persistent thread.

This default behavior i.e. automatic restart may be configured either globally for all persistent threads via the deployment descriptor or on a per thread basis via an application programming interface API . Default persistent thread restart can be configured in the deployment descriptor. A developer can specify globally if the developer intends threads to be automatically restarted or not. For example 

A developer can also use an API to alter the default behavior for a particular thread. If a persistent thread is not set to be restarted automatically the application has to explicitly restart the thread by calling a method start .

Since a persistent thread may be automatically restarted in method run that is as if calling method start threads must be aware that the threads are restarted so that the threads can discriminate between i initialization that needs to be done once when initially created and ii initialization that must be done each time when restarted e.g. reset of resources . In one embodiment a flag maintained by thread is used to determine which initialization is required. Flag is also persistent. Thread sets flag the first time thread runs after completing its initialization and tests if flag is already set afterward.

Note that restarting a thread may additionally entail not only resetting the stack of the thread which typically is kept in volatile memory but also resetting the state of the thread.

While the previous embodiment minimizes the effort required by a developer to restart threads for each new session that embodiment is a change of the java.lang.Thread behavior. An alternative embodiment provides a facility e.g. a factory to submit tasks that need to run in separate threads and that may be restarted automatically upon platform reset. These tasks implement interface java.lang.Runnable and the facility transparently creates threads to execute them. This facility is in charge of spawning new threads to resume the tasks upon a platform reset if these tasks have been declared as restartable e.g. 

In this embodiment pseudo persistence of threads is provided with the help of a restartable thread factory which re establishes threads from scratch upon platform reset when needed. Facility is included in persistent management system in one embodiment.

Resource constrained device may also support additional facilities derived from the Connected Limited Device Configuration CLDC and Mobile Information Device Profile MIDP platform such as thread and additional beyond the sole APDU protocol input output I O for both inbound and outbound connections. The Generic Connection Framework GCF provides a simplified mechanism for applications to use various types of I O protocols in resource constrained environments. I O is performed by means of connections obtained through a factory class. Connections are dynamically created based on URIs.

Because of nomadic and intermittent nature of operation of resource constrained device connections are typically session objects. A connection to an external entity cannot be expected to span across sessions.

GCF connection objects that is instances of classes implementing interface javax.microedition.Connection which are reachable from the logical persistence root e.g. servlet context are persistent. However after a platform reset such GCF connection objects are in a closed state. Method calls on these GCF connection objects throw exceptions IOException if method close has been previously called.

Note that as for threads pseudo persistence of connections could be provided with the help of a restartable connection factory which could re establish connections from scratch upon platform reset when needed. Restartable connection factory is included in persistent management system in one embodiment.

Herein GCF connection objects are used as an example of connection objects that optionally are restarted upon initiation of a session. In view of this disclosure those of skill in the art optionally can implement connection objects for I O protocols of interest which are stored in persistent memory and which are restarted upon initiation of a session.

Also in the above embodiment a web application and a servlet context were used as a example of an embodiment for selectively moving and or creating objects in persistent memory that were reachable from the servlet context. In view of this disclosure those of skill in the art can define a logic root of persistence for applications other than web applications and for those applications selectively move objects into persistent memory based upon whether the objects are reachable through the logical root of persistence. For example APDU based applications and other type of applications can utilize the selective use of persistent memory for objects associated with the applications and the containers in which the applications execute.

In the above description various features have been considered individually. However this was for clarity only and was not intended to limit the invention to application of the various features individually. Those of skill in the art appreciate that the features may be used individually or in any desired combination to achieve the desired functionality and performance on a particular resource constrained device platform.

Those skilled in the art readily recognize that in this embodiment the various embodiment mentioned before in connection with persistent management system are performed by executing computer program instructions on a processor not shown of resource constrained device . In one embodiment a storage medium not shown has thereon installed computer readable program code for system and execution of the computer readable program code causes the processor of resource constrained device to perform the various functions explained above.

Herein a computer program product comprises a medium configured to store computer readable code for any one of or any combination of persistent management system creation and use of object pools thread auto restart facility and restartable connection facility or in which computer readable code for any one of or any combination of persistent management system creation and use of object pools thread auto restart facility and restartable connection facility is stored. Some examples of non transitory computer program products are DVD discs CD ROM discs ROM cards floppy discs magnetic tapes computer hard drives servers on a network.

Another embodiment of the present invention also relates to a method for using resource constrained device for carrying out the functions of any one of or any combination of persistent management system creation and use of object pools thread auto restart facility and restartable connection facility . Still another embodiment of the present invention relates to a computer system with a storage medium on which a computer program for carrying out the functions of any one of or any combination of persistent management system creation and use of object pools thread auto restart facility and restartable connection facility is stored.

