---

title: Security assertion revocation
abstract: Security assertion revocation enables a revocation granularity in a security scheme down to the level of individual assertions. In an example implementation, a security token includes multiple respective assertions that are associated with multiple respective assertion identifiers. More specifically, each individual assertion is associated with at least one individual assertion identifier.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08095969&OS=08095969&RS=08095969
owner: Microsoft Corporation
number: 08095969
owner_city: Redmond
owner_country: US
publication_date: 20060908
---
Computers and other electronic devices are pervasive in the professional and personal lives of people. In professional settings people exchange and share confidential information during project collaborations. In personal settings people engage in electronic commerce and the transmission of private information. In these and many other instances electronic security is deemed to be important.

Electronic security paradigms can keep professional information confidential and personal information private. Electronic security paradigms may involve some level of encryption and or protection against malware such as viruses worms and spyware. Both encryption of information and protection from malware have historically received significant attention especially in the last few years.

However controlling access to information is an equally important aspect of securing the safety of electronic information. This is particularly true for scenarios in which benefits are derived from the sharing and or transferring of electronic information. In such scenarios certain people are to be granted access while others are to be excluded.

Access control has been a common feature of shared computers and application servers since the early time shared systems. There are a number of different approaches that have been used to control access to information. They share a common foundation in combining authentication of the entity requesting access to some resource with a mechanism of authorizing the allowed access. Authentication mechanisms include passwords Kerberos and x.509 certificates. Their purpose is to allow a resource controlling entity to positively identify the requesting entity or information about the entity that it requires.

Authorization examples include access control lists ACLs and policy based mechanisms such as the eXtensible Access Control Markup Language XACML or the PrivilEge and Role Management Infrastructure PERMIS . These mechanisms define what entities may access a given resource such as files in a file system hardware devices database information and so forth. They perform this authorization by providing a mapping between authenticated information about a requestor and the allowed access to a resource.

As computer systems have become more universally connected over large networks such as the Internet these mechanisms have proven to be somewhat limited and inflexible in dealing with evolving access control requirements. Systems of geographically dispersed users and computer resources including those that span multiple administrative domains in particular present a number of challenges that are poorly addressed by currently deployed technology.

Security assertion revocation enables a revocation granularity in a security scheme down to the level of individual assertions. In an example implementation a security token includes multiple respective assertions that are associated with multiple respective assertion identifiers. More specifically each individual assertion is associated with at least one individual assertion identifier.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure API arrangement protocol etc. implementations are described herein.

In a described implementation security scheme can be overlaid and or integrated with one or more devices which can be comprised of hardware software firmware some combination thereof and so forth. As illustrated d devices with d being some integer are interconnected over one or more networks . More specifically device device device . . . device are capable of communicating over network .

Each device may be any device that is capable of implementing at least a part of security scheme . Examples of such devices include but are not limited to computers e.g. a client computer a server computer a personal computer a workstation a desktop a laptop a palm top etc. game machines e.g. a console a portable game device etc. set top boxes televisions consumer electronics e.g. DVD player recorders camcorders digital video recorders DVRs etc. personal digital assistants PDAs mobile phones portable media players some combination thereof and so forth. An example electronic device is described herein below with particular reference to .

Network may be formed from any one or more networks that are linked together and or overlaid on top of each other. Examples of networks include but are not limited to an internet a telephone network an Ethernet a local area network LAN a wide area network WAN a cable network a fibre network a digital subscriber line DSL network a cellular network a Wi Fi network a WiMAX network a virtual private network VPN some combination thereof and so forth. Network may include multiple domains one or more grid networks and so forth. Each of these networks or combination of networks may be operating in accordance with any networking standard.

As illustrated device corresponds to a user that is interacting with it. Device corresponds to a service that is executing on it. Device is associated with a resource . Resource may be part of device or separate from device .

User service and a machine such as any given device form a non exhaustive list of example entities. Entities from time to time may wish to access resource . Security scheme ensures that entities that are properly authenticated and authorized are permitted to access resource while other entities are prevented from accessing resource .

As illustrated device A includes two security related components a security token and an application . Security token includes one or more assertions . Device B includes five security related components an authorization context a resource guard an audit log an authorization engine and a security policy . Security policy includes a trust and authorization policy an authorization query table and an audit policy .

Each device may be configured differently and still be capable of implementing all or a part of security scheme . For example device A may have multiple security tokens and or applications . As another example device B may not include an audit log or an audit policy . Other configurations are also possible.

In a described implementation authority issues security token having assertions to entity . Assertions are described herein below including in the section entitled Security Policy Assertion Language Example Characteristics . Entity is therefore associated with security token . In operation entity wishes to use application to access resource by virtue of security token .

Resource guard receives requests to access resource and effectively manages the authentication and authorization process with the other security related components of device B . Trust and authorization policy as its name implies includes policies directed to trusting entities and authorizing actions within security environment . Trust and authorization policy may include for example security policy assertions not explicitly shown in . Authorization query table maps requested actions such as access requests to an appropriate authorization query. Audit policy delineates audit responsibilities and audit tasks related to implementing security scheme in security environment .

Authorization context collects assertions from security token which is are used to authenticate the requesting entity and security policy assertions from trust and authorization policy . These collected assertions in authorization context form an assertion context. Hence authorization context may include other information in addition to the various assertions.

The assertion context from authorization context and an authorization query from authorization query table are provided to authorization engine . Using the assertion context and the authorization query authorization engine makes an authorization decision. Resource guard responds to the access request based on the authorization decision. Audit log contains audit information such as for example identification of the requested resource and or the algorithmic evaluation logic performed by authorization engine .

In a described implementation entity authenticates itself to resource guard with a token security token . Resource guard forwards the token assertions to authorization context . These token assertions are assertions of of security token . Security policy provides the authorization query table to resource guard . The authorization query table derives from authorization query table module . The authorization query table sent to resource guard may be confined to the portion or portions directly related to the current access request.

Policy assertions are extracted from trust and authorization policy by security policy . The policy assertions may include both trust related assertions and authorization related assertions. Security policy forwards the policy assertions to authorization context . Authorization context combines the token assertions and the policy assertions into an assertion context. The assertion context is provided from authorization context to authorization engine as indicated by the encircled A .

An authorization query is ascertained from the authorization query table. Resource guard provides the authorization query auth. query to authorization engine . Authorization engine uses the authorization query and the assertion context in an evaluation algorithm to produce an authorization decision. The authorization decision auth. dcn. is returned to resource guard . Whether entity is granted access to resource by resource guard is dependent on the authorization decision. If the authorization decision is affirmative then access is granted. If on the other hand the authorization decision issued by authorization engine is negative then resource guard does not grant entity access to resource .

The authorization process can also be audited using semantics that are complementary to the authorization process. The auditing may entail monitoring of the authorization process and or the storage of any intermediate and or final products of e.g. the evaluation algorithm logically performed by authorization engine . To that end security policy provides to authorization engine an audit policy from audit policy . At least when auditing is requested an audit record having audit information may be forwarded from authorization engine to audit log . Alternatively audit information may be routed to audit log via resource guard for example as part of the authorization decision or separately.

Generally a device may represent any computer or processing capable device such as a client or server device a workstation or other general computer device a PDA a mobile phone a gaming platform an entertainment device one of the devices listed above with reference to some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media include processor executable instructions .

In a described implementation of device I O interfaces may include i a network interface for communicating across network ii a display device interface for displaying information on a display screen iii one or more man machine interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Printing device interfaces may similarly be included as part of I O interfaces . Examples of iii man machine interfaces include those that communicate by wire or wirelessly to man machine interface devices e.g. a keyboard a remote a mouse or other graphical pointing device etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device .

Thus realizations for security related implementations may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects components metadata and definitions thereof data structures application programming interfaces APIs schema etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

Processor s may be implemented using any applicable processing capable technology. Media may be any available media that is included as part of and or accessible by device . It includes volatile and non volatile media removable and non removable media and storage and transmission media e.g. wireless or wired communication channels . For example media may include an array of disks flash memory optical media for longer term mass storage of processor executable instructions random access memory RAM for shorter term storing of instructions that are currently being executed link s on network for transmitting communications e.g. security related data and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein including those actions that are illustrated in the various flow diagrams. By way of example only processor executable instructions may include a security token at least one of its assertions an authorization context module a resource guard an audit log an authorization engine a security policy e.g. a trust and authorization policy an authorization query table and or an audit policy etc. some combination thereof and so forth. Although not explicitly shown in processor executable instructions may also include an application and or a resource .

This section describes example characteristics of an implementation of a security policy assertion language SecPAL . The SecPAL implementation of this section is described in a relatively informal manner and by way of example only. It has an ability to address a wide spectrum of security policy and security token obligations involved in creating an end to end solution. These security policy and security token obligations include by way of example but not limitation describing explicit trust relationships expressing security token issuance policies providing security tokens containing identities attributes capabilities and or delegation policies expressing resource authorization and delegation policies and so forth.

In a described implementation SecPAL is a declarative logic based language for expressing security in a flexible and tractable manner. It can be comprehensive and it can provide a uniform mechanism for expressing trust relationships authorization policies delegation policies identity and attribute assertions capability assertions revocations audit requirements and so forth. This uniformity provides tangible benefits in terms of making the security scheme understandable and analyzable. The uniform mechanism also improves security assurance by allowing one to avoid or at least significantly curtail the need for semantic translation and reconciliation between disparate security technologies.

A SecPAL implementation may include any of the following example features 1 SecPAL can be relatively easy to understand. It may use a definitional syntax that allows its assertions to be read as English language sentences. Also its grammar may be restrictive such that it requires users to understand only a few subject verb object e.g. subject verb phrase constructs with cleanly defined semantics. Finally the algorithm for evaluating the deducible facts based on a collection of assertions may rely on a small number of relatively simple rules.

 2 SecPAL can leverage industry standard infrastructure in its implementation to ease its adoption and integration into existing systems. For example an extensible markup language XML syntax may be used that is a straightforward mapping from the formal model. This enables use of standard parsers and syntactic correctness validation tools. It also allows use of the W3C XML Digital Signature and Encryption standards for integrity proof of origin and confidentiality.

 3 SecPAL may enable distributed policy management by supporting distributed policy authoring and composition. This allows flexible adaptation to different operational models governing where policies or portions of policies are authored based on assigned administrative duties. Use of standard approaches to digitally signing and encrypting policy objects allow for their secure distribution. 4 SecPAL enables an efficient and safe evaluation. Simple syntactic checks on the inputs are sufficient to ensure evaluations will terminate and produce correct answers.

 5 SecPAL can provide a complete solution for access control requirements supporting required policies authorization decisions auditing and a public key infrastructure PKI for identity management. In contrast most other approaches only manage to focus on and address one subset of the spectrum of security issues. 6 SecPAL may be sufficiently expressive for a number of purposes including but not limited to handling the security issues for Grid environments and other types of distributed systems. Extensibility is enabled in ways that maintain the language semantics and evaluation properties while allowing adaptation to the needs of specific systems.

As illustrated at the top row of assertion format an example assertion at a broad level includes a principal portion a says portion and a claim portion . Textually the broad level of assertion format may be represented by principal says claim.

At the next row of assertion format claim portion is separated into example constituent parts. Hence an example claim portion includes a fact portion an if portion n conditional factportions . . . n and a c portion . The subscript n represents some integer value. As indicated by legend c portion represents a constraint portion. Although only a single constraint is illustrated c portion may actually represent multiple constraints e.g. c . . . c . The set of conditional fact portions . . . n and constraints . . . m on the right hand side of if portion may be termed the antecedent.

Textually claim portion may be represented by fact if fact . . . fact c. Hence the overall assertion format may be represented textually as follows principal says fact if fact . . . fact c. However an assertion may be as simple as principal says fact. In this abbreviated three part version of an assertion the conditional portion that starts with if portion and extends to c portion is omitted.

Each fact portion may also be further subdivided into its constituent parts. Example constituent parts are an e portion and a verb phrase portion . As indicated by legend e portion represents an expression portion. Textually a fact portion may be represented by e verbphrase.

Each e or expression portion may take on one of two example options. These two example expression options are a constant and a variable . Principals may fall under constants and or variables .

Each verb phrase portion may also take on one of three example options These three example verb phrase options are a predicate portion followed by one or more eportions . . . n a can assert portion followed by a fact portion and an alias portion followed by an expression portion . Textually these three verb phrase options may be represented by predicate e. . . e can assertfact and alias e respectively. The integer n may take different values for facts . . . n and expressions . . . n .

Generally SecPAL statements are in the form of assertions made by a security principal. Security principals are typically identified by cryptographic keys so that they can be authenticated across system boundaries. In their simplest form an assertion states that the principal believes a fact is valid e.g. as represented by a claim that includes a fact portion . They may also state a fact is valid if one or more other facts are valid and some set of conditions are satisfied e.g. as represented by a claim that extends from a fact portion to an if portion to conditional fact portions . . . n to a c portion . There may also be conditional facts . . . n without any constraints and or constraints without any conditional facts . . . n .

In a described implementation facts are statements about a principal. Four example types of fact statements are described here in this section. First a fact can state that a principal has the right to exercise an action s on a resource with an action verb . Example action verbs include but are not limited to call send read list execute write modify append delete install own and so forth. Resources may be identified by universal resource indicators URIs or any other approach.

Second a fact can express the binding between a principal identifier and one or more attribute s using the possess verb. Example attributes include but are not limited to email name common name group name role title account name domain name server service DNS name internet protocol IP address device name application name organization name service name account identification identifier ID and so forth. An example third type of fact is that two principal identifiers can be defined to represent the same principal using the alias verb.

 Qualifiers or fact qualifiers may be included as part of any of the above three fact types. Qualifiers enable an assertor to indicate environmental parameters e.g. time principal location etc. that it believes should hold if the fact is to be considered valid. Such statements may be cleanly separated between the assertor and a relying party s validity checks based on these qualifier values.

An example fourth type of fact is defined by the can assert verb. This can assert verb provides a flexible and powerful mechanism for expressing trust relationships and delegations. For example it allows one principal A to state its willingness to believe certain types of facts asserted by a second principal B . For instance given the assertions A says B can assert fact0 and B says fact0 it can be concluded that A believes fact0 to be valid and therefore it can be deduced that A says fact0 .

Such trust and delegation assertions may be i unbounded and transitive to permit downstream delegation or ii bounded to preclude downstream delegation. Although qualifiers can be applied to can assert type facts omitting support for qualifiers to these can assert type facts can significantly simplify the semantics and evaluation safety properties of a given security scheme.

In a described implementation concrete facts can be stated or policy expressions may be written using variables. The variables are typed and may either be unrestricted e.g. allowed to match any concrete value of the correct type or restricted e.g. required to match a subset of concrete values based on a specified pattern .

Security authorization decisions are based on an evaluation algorithm e.g. that may be conducted at authorization engine of an authorization query against a collection of assertions e.g. an assertion context from applicable security policies e.g. a security policy and security tokens e.g. one or more security tokens . Authorization queries are logical expressions which may become quite complex that combine facts and or conditions. These logical expressions may include for example AND OR and or NOT logical operations on facts either with or without attendant conditions and or constraints.

This approach to authorization queries provides a flexible mechanism for defining what must be known and valid before a given action is authorized. Query templates e.g. from authorization query table form a part of the overall security scheme and allow the appropriate authorization query to be declaratively stated for different types of access requests and other operations actions.

Especially in distributed computing environments effective revocation mechanisms can be beneficial. In distributed systems there may be no central authority that can effectively respond to changes such as an employee leaving a company login credentials being compromised long term identity cryptographic keys being compromised and so forth. Even when such a central authority exists it is typically very costly and time consuming to identify all security policies that authorize actions based on a credential e.g. a security token a certificate some combination thereof etc. that should no longer be accepted. When such events occur it is important to be able to block the use of existing credentials for a wide variety of purposes in a timely fashion. An approach to achieving this is the dissemination of revocation information to each of the widely deployed systems that might possibly rely on such questionable credentials.

Existing mechanisms for dealing with the revocation of security information are limiting in several ways. For example many systems e.g. Kerberos and SAML fail to even define how revocation is to be handled. Instead organizations relying on these technologies commonly require relatively short lived credentials e.g. an expiration period of 8 to 24 hours is common . When a security critical action occurs that affects the use of such credentials organizations rely on the credentials expiring rather than having to do a revocation. This approach avoids the need for revocation but at the cost of a substantial window of vulnerability .

Where the cost of acquiring credentials is high as is common with x.509 certificates one of several standardized revocation mechanisms is used. These mechanisms include Certificate Revocation Lists CRLs and On Line Certificate Status Protocol OCSP messages. CRLs contain information about known revoked x.509 certificates at a particular time. OCSP messages allow one to ask about the status of a specific x.509 certificate.

However these existing mechanisms are very coarse grained and only operate at the level of complete certificates. They do not include any mechanism for revoking only a subset of the information in such a certificate. This coarseness results in several practical problems access may have to be denied in far more places than necessary re certifications using new tokens and keys must be performed far more frequently than necessary and or trust relationships are broadly negated and must be re negotiated using new tokens and keys.

In contrast certain implementations as described herein enable a fine grained revocation mechanism. This fine grained revocation mechanism allows individual security assertions to be revoked by the assertor or their delegate.

In a described implementation each assertion is associated with at least one assertion identifier . Assertion identifier may be integrated with its associated assertion may be coupled to its associated assertion or otherwise associated with its assertion . Specifically assertion is associated with assertion identifier assertion is associated with assertion identifier . . . assertion is associated with assertion identifier .

As is described further herein below an assertion identifier enables its associated assertion to be independently revoked separately from the remaining assertions of a given security token . As is also described herein below multiple assertions including all assertions of a given security token may be revoked using a single identification value for assertion identifiers . In other words each assertion identifier may be given a unique identification value or an identification value that is shared across one or more other assertion identifiers . Unique identification values may be generated using very large random numbers using a counter mechanism in conjunction with an STS identifier and so forth. In practice such a unique identification value may comprise a globally unique identifier GUID .

Security token identifier if present also enables the entire security token to be revoked with a single identification value. If so utilized the identification value of security token identifier can be relied on to revoke all assertions of security token .

Security token digital signature if present is a digital signature for security token . Thus security token digital signature may be considered a single digital signature across all assertions of security token . Alternatively a single digital signature may cover or be applied across multiple but not all assertions of a given security token . Security token digital signature serves to provide authentication and or integrity confirmation for data that it has signed.

In a described implementation having multiple assertion identifiers being associated with a single assertion provides additional revocation options. For example assertion identifier may have a unique identification value and assertion identifier may have an identification value that is common across three other assertions not shown in . In this example referencing the unique identification value of assertion identifier in a revocation statement revokes assertion only. However referencing the common identification value that is included as assertion identifier in a revocation statement revokes assertion and the other three assertions that are associated with the same assertion identifier identification value.

In these manners revocation may be enabled and enforced at the granularity of assertions . Additional explanations and logical examples are provided below.

In a described implementation a fine grained revocation semantic that operates at the granularity of an individual security assertion is defined. It should be understood that security assertion revocation as described herein is generally applicable to assertions that adhere to any given format. However by way of example only the assertion format described in the preceding section is used to illuminate certain aspects of security assertion revocation as described herein.

Thus as described above an example general form of a security assertion is principal says claim where claim may be a fact or a conditioned fact e.g. fact if fact . . . fact . . . fact c . . . c . In the examples that follow principal is represented generically by A for assertor.

From a revocation perspective such an example assertion may therefore be represented by A says claim ID value. In this sense the associated ID parameter may be part of the asserted fact. Multiple values forming a set of values may be identifiers that are assigned to the assertion.

An assertion may be revoked using another assertion of the form A says A revoke ID value. In other words A revoke ID value may be a fact expression in accordance with a general security assertion language. Multiple values may also be set equal to ID in the revocation assertion.

Revocation may also be realized using conditional revocations. An assertion of the following form is an example of a conditional revocation A says A revokes ID value if constraints. Such conditional revocations add significant flexibility. For instance time limits or other environmental parameters restrictions may be applied. An example of a conditional revocation that has a time constraint is 

The value of the ID parameter is assigned by the Assertor A and it is encoded as a parameter within the fact expression. If A wants the ability to revoke individual assertions this value is set to be unique across all assertions made by A. This uniqueness may be computed in several ways. Examples include but are not limited to using an incremental counter generating a large random number and so forth. Conversely A may choose to assign the same ID value to multiple assertions. By repeatedly using the same ID revocation value A can revoke multiple related assertions using a single revocation assertion and ID value.

This formulation enables A to selectively revoke any assertion A made previously in a manner that is independent from how a particular assertion was originally encoded in security token s and or policy s . This provides fine grained control over what is being revoked and its resulting overall impact on the operation of a system including a distributed system.

Generally any assertor is permitted to revoke a prior assertion that it made. An assertor may also delegate the right to revoke its assertions to other principals using the delegation policy features of a security policy assertion language for example. Thus A can allow B to issue revocation information on its behalf by asserting the following example A says B can assert A revoke i. B can therefore then assert the following B says A revoke ID value. When A s delegation assertion is logically combined with B s revocation assertion on A s behalf one may logically conclude that A wishes to revoke the assertion s with ID value.

Revocation assertions can be flexibly communicated using the same or similar language mechanisms in which security tokens and policies are expressed. Revocation assertions may also be interpreted using the same infrastructure. Thus in addition to enabling the revocation scheme to have a fine granularity down to the level of an assertion example described implementations reduce if not eliminate a need for special encoding and processing infrastructure to handle revocations.

Thus an example described revocation mechanism operates at the granularity of individual assertions instead of whole tokens with multiple assertions being capable of being encoded into a single token. However as described herein above especially with reference to implementations of the revocation mechanism can also simultaneously revoke multiple assertions.

This capability is further described by way of the following three examples. The ID based assertion revocation mechanism allows one to efficiently revoke i a single assertion or ii multiple related assertions within a single security token or across multiple security tokens. Each assertion may be assigned and associated with a set of two or more identification values as indicated in .

With the ID values of the first example it enables one to revoke the individual assertions using the unique IDs 1 or 3 or 5. Additionally it enables one to revoke all three assertions at once using a single revocation statement referencing a single assertion identifier ID 2.

For a second example this ID based revocation mechanism also allows one to encode K of N requirements or assertion dependencies by assigning a carefully planned set of identifiers to IDs. For example if an asserter wishes to have K of N semantics equal to 2 of 3 it can be encoded as follows in this second example 

With the ID values of the second example any two of the three assertions above may be revoked in a single revocation assertion using a single identification value. For instance the first two assertions may be revoked using A revoke ID 2. Similarly the last two assertions may be revoked using A revoke ID 3. Also the first and last assertions may be revoked using A revoke ID 1.

For a third example assume the reason B can write Bar was issued depended on B can read Foo . If so the former assertion can be forced to be revoked whenever the latter assertion is revoked. This third example may be implemented as 

Whenever a revocation assertion in which ID 1 is issued to revoke the first assertion the second assertion is also automatically revoked. This feature leverages the assertion granularity of the revocation mechanism to enable dependent assertions to be dependently revoked automatically.

At block a first assertion with an associated first assertion identifier is generated. For example assertion that is associated with assertion identifier may be generated by an asserter.

At block a second assertion with an associated second assertion identifier is generated. For example assertion that is associated with assertion identifier may be generated by the asserter.

At block the first assertion and the second assertion are combined into a security token. For example assertion and assertion may be combined into security token . The combining action s may be performed at device A or at STS authority .

At block the security token is digitally signed. For example security token digital signature may be created and applied to security token by STS authority . The digital signature of security token digital signature serves to cover e.g. to authenticate and possibly to guarantee integrity for both assertion and assertion . The digital signature may also serve to sign other assertions and or other parts of security token including up to the entirety of the security related data of security token .

At block multiple assertions are acquired from a single security token. By way of example the multiple assertions may be acquired by extracting them from a single security token. Alternatively an assertion context having multiple assertions from a single security token may be accepted. For instance an assertion context having multiple assertions from a single security token may be accepted from an authorization context . The assertion context may also include other assertions e.g. from a security policy .

At block respective assertion identifiers that are associated with respective ones of the multiple assertions are compared to a set of revoked assertion identifiers. For example resource guard or authorization engine may compare assertion identifiers which are associated with assertions to the assertion identifiers in a set of revoked assertion identifiers.

At block it is determined if there are any assertion identifier or identifiers that match a revoked assertion identifier. If not then at block the assertions of the assertion context are applied to an evaluation algorithm. For example assertions of the assertion context may be applied to an evaluation algorithm part of authorization engine .

If on the other hand it is determined at block that there is at least one assertion identifier associated with an assertion from the assertion context that matches a revoked assertion identifier then at block the assertion s associated with the matching and therefore revoked assertion identifier is are rejected. For example if assertion identifier of matches a revoked assertion identifier then the associated assertion may be rejected.

Rejected assertions are excluded from any evaluation algorithm. From an alternative perspective the revocation analysis and possible assertion rejection may be an initial or early phase of the evaluation algorithm prior to the logical analysis of an authorization query. At block any remaining valid assertions are applied to the evaluation algorithm to determine if an authorization query may still be logically satisfied without the deducible facts of the rejected assertion s .

Assertion revocation may also be described from a relatively rigorous logical perspective. In a described logical implementation of security assertion revocation an assertion is a revocation assertion if it is of the form 

Given an assertion context AC and a set of revocation assertions ACwhere AC AC the assertions revoked by ACare removed from AC before an authorization query is evaluated. The filtered assertion context is defined by 

ACmay also include conditional revocations which are described herein above. The revocation of assertions may also be accomplished by an evaluation of queries parameterized by assertion identifiers using a separate set of assertions. In other words there is an evaluation and querying against the assertions in the disjoint set AC. If this set contains conditional revocation assertions one can query for which revocation facts are valid in a given context. Only those revocations facts that are currently valid are then applied when filtering the assertions in AC using the filtering process defined above.

The condition that AC and ACare disjoint implies that revocation assertions cannot be revoked at least not within the rules of the security language . When revocation assertions are allowed to revoke each other the same problems and semantic ambiguities that result from negated body predicates in logic programming arise with the use of even one revoked revocation assertion. Although such problems can be otherwise formally surmounted e.g. by only allowing stratifiable revocation sets by computing the well founded model etc. these approaches are likely not sufficiently straightforward to please users in a practical environment.

The devices actions aspects features functions procedures modules data structures protocols components etc. of are illustrated in diagrams that are divided into multiple blocks. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses APIs protocols arrangements etc. for security assertion revocation.

Although systems media devices methods procedures apparatuses mechanisms schemes approaches processes arrangements and other implementations have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

