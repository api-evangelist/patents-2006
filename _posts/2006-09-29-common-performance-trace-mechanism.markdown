---

title: Common performance trace mechanism
abstract: A method for providing a mechanism for generating a common format for trace data is disclosed. In one embodiment, the method includes generating trace data at a plurality of providers, the trace data including a first trace data having a first format and a second trace data having a second format, receiving the trace data at a database via a common interface, storing the trace data at the database in compliance with a common format, and providing access to the trace data stored at the database via a user interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07941789&OS=07941789&RS=07941789
owner: SAP AG
number: 07941789
owner_city: Walldorf
owner_country: DE
publication_date: 20060929
---
Embodiments of the invention generally relate to the field of tracing. More particularly the embodiments of the invention relate to providing a common performance trace mechanism.

As application development projects are growing larger tracing is becoming increasingly important. Tracing can be a very useful tool used primarily by software developers to isolate problems for example by tracking execution of program code. For example when developing an application developers trace the execution of methods or functions within certain modules to identify problems and or to determine if the program code may be improved. If a particular method takes an inordinate amount of time to complete the developer may determine the reasons why and or change the program code to operate more efficiently.

Trace tools are proprietary application programs which use different techniques to trace the execution flows for an executing program. One technique referred to as event based profiling tracks particular sequences of instructions by recording application generated events as they occur. By way of example a trace tool may record each entry into and each exit from a module subroutine function method or system component within a trace file e.g. a time stamped entry may be recorded within the trace file for each such event . Trace events may also be sent to a console or other output destination.

Conventional trace tools however are limited with tracing data from various systems i.e. when dealing with tracing data of various structures. For example conventional trace tools do not provide for integration of various trace files of different structures relating to different corresponding systems. This often leads to at best delay in reading of errors as the data has to be manually read and at worst misreading of errors or even loss of trace data. Tracing is particularly cumbersome when a development project involves a great number of systems applications components modules developers and or multiple interfaces and services.

According to one embodiment a method for providing a mechanism for generating a common format for trace data is disclosed. The method includes generating trace data at a plurality of providers the trace data including a first trace data having a first format and a second trace data having a second format receiving the trace data at a database via a common interface storing the trace data at the database in compliance with a common format and providing access to the trace data stored at the database via a user interface.

Other embodiments are also disclosed. Further the above attributes may be implemented using a computer program a system or an apparatus or any combination thereof. These and other details of one or more embodiments of the present invention are set forth in the accompanying drawings and in the description below.

As used herein references to one or more embodiments are understood as describing a particular feature structure or characteristic included in at least one implementation of the invention. Thus phrases such as in one embodiment or in an alternate embodiment appearing herein describe various embodiments and implementations of the invention and do not necessarily all refer to the same embodiment. However they are also not necessarily mutually exclusive. Descriptions of certain details and implementations follow including a description of the figures which may depict some or all of the embodiments described below as well as discussing other potential embodiments or implementations of the inventive concepts presented herein.

In one embodiment CPT architecture provides a mechanism for persisting and analyzing performance traces from various monitored systems . A performance trace refers to a special trace type that deals with performance issues of applications and program codes such as like call durations call stacks memory consumption amount of transferred data and the like. CPT architecture may consist of common data format trace data providers central analysis services generic reports and the like. CPT architecture further provides a library that provides one or more APIs e.g. CPT API to give access to CPT files and database . A CPT API refers to an interface that allows for generation and persistence of performance trace data which complies with the CPT format that is provided via CAS and stored at CPT database and manages various CPT processes as discussed elsewhere in this document. In one embodiment a trace correlator is employed at CAS . A trace correlator includes an object that is used to analyze trace records which are obtained from different software components physical locations e.g. hosts and at different times. A trace correlator helps define a semantic group which is useful to understand how various traces belong together. Also distributed statistics may be used that refer to a minimum performance trace which continuously runs with a running system such as monitored systems . It may be aggregated offline to statistical aggregates and analyzed with respect to performance accounting hardware sizing system usage profiles and the like.

CAS is in communication with client . CAS includes Mbean server that is registered with CAS . Further display application or user interface UI e.g. WebDynPro Runtime is employed. In one embodiment a program code is instrumented that creates trace data supplier to write performance trace data via CPT API to database . Trace model that is in communication with Mbean server and database allows accessing of trace data at database via UI by providing a merged trace data received from multiple monitored systems via corresponding trace data importers located at central data provisioning . Trace model also provides for filtering and aggregation of trace data. To allow for proper access and analysis of trace data originating from multiple sources the trace data is converted into a common format or structure e.g. CPT format CPT structure etc. and provided to the user via client further via UI .

Various modules and components are employed at monitored systems to facilitate tracing and for collection processing and exporting of trace data. For example J2EE monitored system includes trace file storage and server node which includes trace data supplier model provider writer API and Mbean server . In one embodiment model provider is implemented as MBean registered to the local system MBean server and allows the accessing of trace data from CAS . Trace file storage is referred to as a CPT file that serves as a temporary storage for trace data at monitored system . Trace data supplier is a source of trace data while write API provides a CPT API for trace data writing and serves as a CPT tracer.

ABAP monitored system include a Computer Center Management System CCMS agent that allows CCMS to access trace data for the local ABAP system . The trace data is provided to CCMS agent via trace file provider and stored at trace file storage and received using work process . The trace data is retrieved from ABAP monitored system and exported to CAS by performing RFC calls to CCMS via CCMS agent . The trace data is imported at CAS via ABAP CCMS importer and then stored at database . In one embodiment a number of systems can be monitored and trace data from such systems may be provided to CAS so that it can then be converted into and provided as a common CPT structure trace data for access and analysis by client . For example a third party monitored system is illustrated that includes various third party compatible functional modules and components to collect trace data and provide it to CAS . Such modules may include a third party trace data writer a third party agent and a third party trace storage to perform their respective functions as with modules and components at other monitored systems . Further a third party importer at CAS is employed to import trace data from the third party monitored system .

In one embodiment CPT architecture provides a CPT format and correlation. The CPT format is CIM compliant and provides a common format to perform traces to 1 define the type of data that is needed to analyze performance and or functional problems 2 allow for common central storage of trace data at database which provides a common mechanism for persistence management and analysis and 3 provide for correlation. Correlation allows for grouping e.g. correlating of trace records that belong to a single logical transaction by introducing a correlation which is an abstract object. CPT architecture further provides for selective and centralized switch of tracing data for involved components and traces types and structures. In one embodiment the CPT reports of trace data may be implemented using UI application framework such as the WebDynpro framework. The trace data is stored at database using trace model implemented as Mbean and registered with Mbean server of CAS . Trace model provides trace data both as race trace records and aggregated data.

In one embodiment a user activity triggers requests that are processed by various components at monitored systems and CAS . For example a web request from client is sent to a J2EE application server associated with J2EE monitored system . Similarly a request may be sent to other system such as ABAP system and any other third party system . Components at various systems produce different traces appropriate for analyzing several functional and performance problems. Abstract correlator objects are introduced to allow end to end analysis of applications and user activities that are processed by components running at various systems . Such correlator objects provide for combining performance and trace data from different origins such as different system 2 serializing the trace data over a network and transferring the trace data to CAS via the metadata of various communication protocols and 3 providing the trace data via a common structure to provide performance activities of applications program codes and user activities that are being monitored and analyzed.

CPT API enables the currently existing functionalities in tracing e.g. SQLTrace . Such functionalities include 1 reading trace data in an appropriate format for the corresponding application e.g. OpenSQLMonitors application 2 writing a trace record together with metrics is an atomic operation 3 allowing the writing of trace data to a non database storage and allowing the writing of trace data at server startup. Objects associated with CPT API that are used for direct instrumentation of a trace data provider include 1 a factory object e.g. CPTFactory that is responsible for generating CPT provider objects via configuration 2 a provider object e.g. CPTProvider which is used by the instrumented code to provide a lookup action and metric definition objects that are defined in the configuration thus identifying a single trace data provider 3 a record object e.g. CPTRecord that is used as a main entity to be persisted via CPT API . Record objects contain performance information for measured action.

Each trace record that is received from various providers e.g. monitored systems is then configured to a common structure e.g. CPT structure and is stored at database . A CPT trace record may contain any number of metrics. Such metrics are valued from the instrumented code at data providers e.g. monitored systems and are assigned to the CPT trace record by calling a particular API method such as an API addMetric method. If necessary a CPT trace record may be extended. CPT configuration may be separated in two parts static configuration and dynamic online configuration. The two configurations may be regarded as two different use cases. A static configuration file may be part of CPT API and used for such initialization of CPT API so it can be directly used by the data providers by having the static configuration contain default CPT writer settings. Static configuration is also used to predefine certain objects such as application layers system layers and database layers etc. Also the static configuration defines certain general metric definitions such as elapsed time central processing unit CPU time and memory allocation that are relevant for various types of performance traces. A dynamic configuration file is part of the component that provides performance trace data. The dynamic configuration file may contain provider specific configurations like actions and metric definitions.

In one embodiment CPT API is initialized by a J2EE engine service where the currently existing performance trace service is to be extended with various functionalities. The performance trace service provides various correlators such as a measurement correlator that is regarded as the main correlator and is used to group up trace records belonging to a certain measurement or trace. The measurement correlator is referred to as the parent correlator to other correlators that are additionally provided. Another correlator includes a J2EE Engine runtime info correlator that contains information about the corresponding J2EE Engine user session application. The origin of CPT trace records is at a monitored system such as at a node of a J2EE server associated with a J2EE system. To achieve a writing performance trace at server startup a default correlator is employed for each virtual machine VM . Default correlators may not contain any data relating to the monitored system. Further for each trace data provider or monitored system a default layer may be defined. The default layer is then automatically assigned to CPT trace records belonging to the corresponding trace data provider.

In one embodiment trace data from J2EE and ABAP systems is imported at CAS via various module and components such as a CPT API and importers e.g. CPT importer import module etc. . CPT importer is used to import data from J2EE monitored system and place it at database . The files having the trace data are first saved at file system before being imported into database . Import module may be used to import trace data from ABAP monitored system and from any other system such as the third party monitored system of and place it at database . For each ABAP trace a reader class may be generated to be used to form an importer API of the CPT library. ABAP system is in communication with trace manager via RFC connecter API . RFC connecter API serves as a proxy of RFC function modules and creates a general framework for connection to ABAP system . In addition to having and communicating with an ABAP system a CCMS system may also be added to CAS .

CAS further includes configuration module that contains methods for starting and stopping various trace activities and for keeping general information e.g. name start data end data filters etc. about such activities. Configuration module is in communication with configuration storage where configuration data is stored. When a HyerText Transfer Protocol HTTP proxy is used on the client side several XML files are generated as a result of that. These files are then uploaded to CAS and with the help of a file e.g. responses.trc file that is generated by an HTTP service. Such HTTP analysis are generated and imported to CAS via HTTP analysis module . Once trace activities are stopped and trace data form such activities are collected from monitored systems and imported into database the trace data may then be kept at analysis storage and analyzed by analysis module .

At decision block a determination is made as to whether the trace activity is to be deleted. If for any reason e.g. incorrect application being traced tracing data is correct etc. the trace activity at any given system is to be deleted at processing block it is deleted and the process ends at termination block . This is can be accomplished by the user via the UI. In case of multiple trace activities it is contemplated that one or more trace activities may be deleted while still performing one or more other trace activities. If the trace activity is not to be deleted the processing continues with collecting of trace data at the monitored system at processing block . When multiple trace activities are performed at multiple monitored systems the trace data collected from each of those monitored systems may be of format and structure. For example J2EE traces may be different in structure from ABAP traces. At processing block the trace data is imported to a central database that provides a common structure of all trace data. The trace data having different structures is imported and converted into a common structure for the user to access and analyze at the central CPT database. This import may be performed via a number of CPT APIs importers import modules temporary storages and other modules and components. The process ends at processing block .

In the illustrated embodiment the database storage of trace data is shown as having various modules records etc. For example a CPT compatible trace data format or structure contains a stream of six files such as 1 file origins 2 file metrics 3 file correlators 4 file metadata 5 file record correlator and 6 file records. Each of the elements illustrated here are contained in one or more such streams of files. For example CPT metric definition which contains unique identification may be contained in file metrics but repeated in file origins. CPT origin includes a node from where a record e.g. CPT record originates. CPT origin is found in file metadata and when combined with the unique identification from CPT metric definition provides a global identification for the record . CPT module provides the name of the logical unit e.g. class name corresponding to the record originated. CPT module is contained in file metadata. CPT action which is in communication with CPT module provides the name e.g. method name of a module subsection which measures execution time.

CPT thread provides a unique identification of the thread executing the module. CPT thread is located in file metadata. CPT provider is a provider of the record and is contained in file metadata. Examples of trace data handled by a CPT provider include SATrace SQLTrace APPTrace etc. The providers for example may include SATrace SQLTrace APPTrace etc. Based on the provider name the visualizer can use plug ins for additional processing. CPT record includes the record that is originated provided and used and is associated with other elements . CPT record resides in file records. CPT record may also include a parent identification which may be used when there is a nesting of trace records and may contain the identification of the parent record.

CPT metric is located at file metrics. CPT metric represents metrics having a set of name value pairs giving additional information about a call. For example CPT metric can describe a method call parameters or in case of a database call some database related values may be provided. These properties can be parsed by the visualizer to a provider specific plug in or merely can be used as a more detailed description of the record . Trace data structure further includes correlators such as CPT record correlator that resides at file record correlator CPT correlator that resides at file origins and CPT correlator definition that resides at file metadata. These correlators provide a value that defines and provides to which measurement or trace the record belongs. For each measurement a separate correlator may be defined.

Once the non compatible or unusual data is fixed or if not such trace data is found the trace data collected is then imported from multiple systems at a database that is central to a central administration system that is compatible with CPT at processing block . As it is discussed elsewhere in this document compatible trace data may be imported directed so the database via a CPT API while the importing of other trace data e.g. non compatible data may include the use of additional modules and components such as an import module a trace data conversion module etc. Such trace data is then merged and stored at the database at processing block . At processing block access to the trace data stored at the database is provided to the user via the client and the UI.

In one embodiment each component plays a role in correlation in providing various traces that are appropriate for analyzing various functional and performance problems. Abstract correlator objects may be introduced to allow an end to end analysis of user activities that are processed by many components running on different hosts. In one embodiment correlator objects are used for combining performance and trace data from different origins and representing user activities and containing information about it. Correlator objects are serialized over a network and transferred via metadata of communication protocols.

In one embodiment the start stop traces module is associated with IS transaction service and CPT model provider for IS transaction trace module and further with CPT trace file storage . CPT model provider for IS transaction trace module employs an API to trace its data to CPT files. CPT model provider provides methods for transferring CPT files to the central administration system using JMX streaming via JMX interfaces . Correlator manager provides a module that is responsible for the creation of correlators for trace records.

In one embodiment to perform various embodiments of the present invention a server or node e.g. J2EE server is employed which supports Enterprise Java Bean EJB components and EJB containers at the business layer and Servlets and Java Server Pages JSP at the presentation layer . A virtual machine VM including a Java virtual machine JVM may be employed to host the server or server node. It is understood that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments Java based environments such as a J2EE environment or environments defined by other releases of the Java standard other environments e.g. a .NET environment a Windows NT environment each provided by Microsoft Corporation and the like.

Processes taught by the discussion above may be performed with program code such as machine executable instructions which can cause a machine such as a virtual machine a general purpose processor disposed on a semiconductor chip a special purpose processor disposed on a semiconductor chip etc. to perform certain functions. Alternatively these functions may be performed by specific hardware components that contain hardwired logic for performing the functions or by any combination of programmed computer components and custom hardware components.

One or more modules within or associated with an enhanced configuration architecture such as common performance trace architecture of and its sub architectures and systems e.g. central administration system APIs e.g. CPT API and its modules models components and other elements may include hardware software and a combination thereof. In a case where a module includes software the software data instructions and or configuration may be provided via an article of manufacture by a machine electronic device hardware. An article of manufacture may include a machine accessible readable medium having content to provide instructions data etc. The content may result in an electronic device for example a filer a disk or a disk controller as described herein performing various operations or executions described. A machine accessible medium includes any mechanism that provides i.e. stores and or transmits information content in a form accessible by a machine e.g. computing device electronic device electronic system subsystem etc. . For example a machine accessible medium includes recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. as well as electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc. The machine accessible medium may further include an electronic device having code loaded on a storage that may be executed when the electronic device is in operation. Thus delivering an electronic device with such code may be understood as providing the article of manufacture with such content described above. Furthermore storing code on a database or other memory location and offering the code for download over a communication medium via a propagated signal may be understood as providing the article of manufacture with such content described above. The code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

Client systems may execute multiple application or application interfaces. Each instance or application or application interface may constitute a user session. Each user session may generate one or more requests to be processed by server . The requests may include instructions or code to be executed on a runtime system such as VM on server and its components and modules as described throughout this document.

In addition to what is described herein various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

