---

title: System and method for generating business process test elements
abstract: Systems and methods are provided for generating business process test elements for automated testing of business process application configurations. A business process application executes business processes, which are typically automated operations involving users and information systems, and are typically specific to a type of business. A business process test is a set of instructions for invoking a business process. The test invokes one or more test elements, which are building blocks that codify interactions with business processes. Each element includes a description of the input data accepted by an associated transaction or screen of the business process. The element can receive input from a user or simulated user via an input interface of the application, and can invoke the associated business process with the input. The element is generated based upon metadata information retrieved from the business process application. The element provides input to and retrieves output from the application for the associated business process. The element refers to fields of the business process transactions or screens by names associated with the fields. The names may be internal application names, which are independent of a particular language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08056057&OS=08056057&RS=08056057
owner: SAP AG
number: 08056057
owner_city: Walldorf
owner_country: DE
publication_date: 20060828
---
This application is a Continuation in part of Application Ser. No. 11 251 281 filed Oct. 13 2005 the contents of which are expressly incorporated herein by reference in their entirety.

The invention relates generally to testing of software and more specifically to systems and methods for automated testing of software that executes business processes.

Business process application software allows for the definition and execution of business processes in a computer system. Examples of business processes include updating customer information receiving and fulfilling orders synchronizing customer information stored on multiple computer systems and generating a price quote. Business processes are often associated with data descriptions and transformation rules for accessing individual data items such as a customer name or a unit price. A business process specifies a sequence of activities to be performed in a specified order and may specify conditional and repeated execution of activities. Business process application software can execute a business process prompting for or retrieving input data as needed and produce results or effects such as output data or execution of database transactions. A business process application configuration includes a set of business processes and associated data including data descriptions and transformation descriptions which specify how to execute one or more particular business processes using general purpose business process application software such as SAP or Siebel . Configuration information is typically represented as data stored in disk files or in an online repository depending on the particular business process application software. The business process software can load the configuration information including the business process and subsequently execute the business processes. For example a shipping company may have a business process application configuration including a computer system running SAP software with a ShipmentReceived business process which is to be executed when a shipping container arrives at a transit hub. The ShipmentReceived business process updates an inventory database of shipping container locations and invokes another computer system to route the shipping container to its destination. The shipping company may have a second business process application configuration consisting of another computer system running Siebel software with a ConfirmOrder business process which is to be executed when an order has been processed. The ConfirmOrder business process which is invoked by an order processing system retrieves the customer s e mail address from Siebel and sends an e mail notice to the customer describing the order.

It is desirable to be able to automatically test the execution of a business process application configuration by a business process application for correctness. Testing a software program involves interacting with the program in a test environment and verifying that the program operates correctly based on the program s behavior in response to input supplied during the interaction. The interaction may be manual testing performed by a human or automated testing performed by a test program. Automated testing is desirable because human effort is not necessary to perform the testing so automated testing can be less expensive and more consistent than manual testing once the tests have been developed. However substantial time and effort may still be involved in creating the tests which are typically computer programs that will perform the automated testing. Test automation systems which are typically computer programs have been developed to reduce the time and effort involved in creating automated tests.

Co pending U.S. patent application Ser. No. 11 251 281 System And Method For Testing Business Process Configurations B. Larab et al. discloses systems and methods for testing business process configurations in which the testing is based upon complex test elements which interact with specific screens or transactions of a specific application e.g. SAP or Siebel to provide input data and read output data from the application. A complex test element includes a parameter list which describes the names and types of input and output parameters that are expected and produced respectively by the transaction and a list of elements to be invoked to perform the transaction. The complex test element passes values received from the user for the input parameters to the transaction when the test is executed and passes values produced by the transaction back to the testing system so that the user can verify that the test s output is correct or perform an action based upon the test s output. The test elements can be used as building blocks to create automated tests. For example a user may select a test element associated with a specific Purchase Order transaction add the element to a test and provide input data for the element. The test automation system can then execute a test of the Purchase Order transaction using the element and input data. Multiple test elements can be strung together in a sequence to create tests of multiple features e.g. multiple transactions and test elements that perform conditional branching can be used to create tests that execute certain elements conditionally or repeatedly. An element that performs an application specific action such as a transaction is created by combining simpler elements that perform actions such as setting or getting a value of a text field or selection box in an application user interface. For example an element that performs a Purchase Order transaction could be created by combining elements that set the values of each field of the Purchase Order transaction in a user interface. If the Purchase Order transaction includes input fields for an item name and quantity the Purchase Order element would be able to indicate to a user of the testing system that an item name and a quantity are expected as input parameters to the transaction. The Purchase Order element would also be able to invoke field setting elements that set the item name and quantity input fields to parameter values provided by a user of the test automation system.

Test elements can be created manually by a user interacting with the testing system. To create a new test element for a transaction the user first perceives the format of the input data i.e. the names and types of the input fields of the transaction. Then the user may add field setting elements to the new test element to set values of the transaction s input fields. The user may also add field getting elements to retrieve output values produced by the transaction. The test element can then be used by the testing system to invoke the transaction. For example a user could create a Purchase Order test element by first looking at the Purchase Order transaction screen or documentation to determine that the purchase order transaction s input includes an item name and a quantity. The user would then create an empty complex element and add field setting elements for the item name and quantity fields to the empty complex element. The Purchase Order test element could then be included in business process tests to invoke the Purchase Order transaction.

This manual process of creating test elements can be resource intensive and error prone because it depends on a human user. A human user may make mistakes or omissions in creating the test elements and the time taken by a human user to create test elements for an application may be substantial and costly. An application may have hundreds or thousands of possible transaction screens or types in which case the expense and possibility of error may be substantial.

One way to automate the test creation process is to introduce a recording feature in which the test system records the user s actions when a transaction screen is filled in. However this approach sometimes can lead to difficulties such as tests being overly dependent upon details of the application screens or the version of the application as described in the above referenced patent application Ser. No. 11 251 281.

Furthermore the manual process of creating a test element generally produces test elements that are dependent on the particular language version e.g. English or Japanese of the application because the descriptive text associated with each field on the application screen is used to identify the field in the test elements. If the descriptive text changes for example as a result of switching from an English language version of the application to a Japanese language version then the test element will become inoperable. The descriptive text may also change for other reasons e.g. if the application vendor changes the text in a new version of the application.

Because of the resource intensive error prone and language dependent nature of the manual process for generating test elements it would be desirable to be able to automatically generate test elements.

In general in a first aspect the invention features in a business process test environment a method of generating a business process test element for testing a business process transaction provided by a business process application. The method comprises acquiring a description of a transaction field from a component of the business process application wherein the description comprises a name and a type of the field generating an instruction for setting a field value associated with the field to an input value wherein the input value is acquired by the instruction when the instruction is executed and wherein the instruction is based upon the name and the type.

Embodiments of the invention may include one or more of the following features. Acquiring a field description may comprise extracting a user interface object from an application screen wherein the user interface object corresponds to the transaction field and determining the name and the type based upon the user interface field. The user interface object may comprise a text box list box drop down check box radio box or a combination thereof. Acquiring a field description may comprise retrieving metadata associated with the business process application wherein the metadata describes the transaction and determining the name and the type based upon the metadata. Generating instructions may comprise acquiring a display label from the description of the transaction field wherein the display label is associated with a user interface object that corresponds to the transaction field establishing an association in an object definition list between the name and the display label wherein generating an instruction comprises generating an instruction for providing the input value to the user interface object wherein the display label identifies the user interface object. A data file or a spreadsheet may provide the input value. Generating an instruction may further comprise generating an instruction for retrieving a current value of the transaction field.

The method of generating a business process test element may further comprise importing the business process test element into a business process test environment to make the test element available for invocation by business process tests. The method of generating a business process test element may further comprise updating a spreadsheet to reference the transaction field by linking a spreadsheet cell to the transaction field

In general in a second aspect the invention features a method of loading test elements into a business process test environment the test elements for invoking business process application transactions. The method of loading test elements comprises extracting metadata from a business process application wherein the metadata describes at least one business process transaction generating at least one business process test element for setting a value associated with at least one field of the at least one business process transaction and importing the business process test element into the business process test environment to make the test element available for use in business process tests.

Embodiments of the invention may include one or more of the following features. The method of loading test elements may further comprise invoking a programmatic interface of the business process application to retrieve the metadata from a database associated with the business process application. Extracting metadata may comprise invoking a programmatic interface to identify user interface features on a transaction screen of the business process application wherein the screen comprises a user interface input feature that corresponds to the transaction field and determining a name and a type of the at least one field. Converting may comprise retrieving from the metadata description at least one label associated with the at least one field generating a script wherein generating a script comprises generating computer program instructions for selecting at least one user interface feature associated with the at least one field wherein selecting is based upon the at least one label and generating computer program instructions for setting the value associated with the at least one user interface feature to a new value and storing the computer program instructions in association with the at least one business process test element.

The method of generating test elements may further comprise generating an object definition list that associates at least one name of the at least one field with at least one label of the at least one field and importing the object definition list into the business process test environment. Importing the business process test element may further comprise invoking a programmatic interface of the business process test environment to store the element in a database associated with the business process test environment.

In general in a third aspect the invention features a system for generating a business process test element for testing a business process transaction in a business process test tool. The system comprises a field acquirer to acquire a description of a transaction field from a component of the business process application wherein the description comprises a name and a type of the field and an instruction generator to generate an instruction for setting a field value associated with the field to an input value wherein the input value is acquired by the instruction when the instruction is executed and wherein the instruction is based upon the name and the type.

In general in a fourth aspect the invention features a computer program product comprising program code for generating a business process test element for testing a business process transaction provided by a business process application. The computer program product comprises program code operable to acquire a description of a transaction field from a component of the business process application wherein the description comprises a name and a type of the field and program code operable to generate an instruction for setting a field value associated with the field to an input value wherein the input value is acquired by the instruction when the instruction is executed and wherein the instruction is based upon the name and the type.

In general in a fifth aspect the invention features a computer program product comprising program code for loading test elements into a business process test environment the test elements for invoking business process application transactions. The computer program product comprises program code operable to extract metadata from a business process application wherein the metadata describes at least one business process transaction program code operable to generate at least one business process test element for setting a value associated with at least one field of the at least one business process transaction and program code operable to import the business process test element into the business process test environment to make the test element available for use in business process tests.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of particular applications and their requirements. Various modifications to the preferred embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the invention. Moreover in the following description numerous details are set forth for the purpose of explanation. However one of ordinary skill in the art will realize that the invention might be practiced without the use of these specific details. In other instances well known structures and devices are shown in block diagram form in order not to obscure the description of the invention with unnecessary detail. Thus the present invention is not intended to be limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The test elements represent particular features e.g. particular transactions of the business process application and can invoke those features automatically when included in a business process test . The test elements may be generated by an element generator as described below. The test elements enable the business process test environment to programmatically invoke features of a business process application by interacting with the application s user interface thereby simulating a user s interaction with the business process application and enabling automated testing of the business process application via the application s user interface. In some cases testing via the user interface is employed especially where no programmatic application programming interface is provided by the application. Furthermore testing via the user interface allows for verification of the proper operation of the user interface and underlying application features presented to users. Efficient generation of tests for user interfaces and underlying application features as described herein contributes to efficient development of automated tests. Once automated tests have been developed such tests are significantly more efficient and reliable than tests performed manually by human testers.

The development environment interacts with the user and receives commands from the user for creating a business process test . A user may create a business process test to test particular features of a business process application. In one aspect the user creates the test by selecting test elements that correspond to the features to be tested. For example the user may select a complex element that invokes a Create Sales Order transaction and a complex element that invokes a Create Purchase Order transaction. A separate test element is ordinarily generated for each user interface feature because each feature may have different properties e.g. different types of associated data values different input parameters and the like. The test elements may be stored in a single data file in multiple data files or in other data formats. The test may also include instructions for verifying that the results returned by the application e.g. the output values of a transaction are correct.

The test ordinarily includes a list of element calls . Each entry in the list of element calls is an element call which may include parameters that provide input values for the element call . The element call invokes a particular feature of the business process application and passes the parameters as part of the invocation. The element call may include at least one code statement for invoking the particular feature. The code statement may be for example a statement in a programming language such as VBScript or the like. The element call may also invoke computer program code that is stored in a test library to perform more generalized operations such as sending a data value to the application or retrieving an output value from the application. In one aspect the business process test i.e. the particular sequence of element calls is processed by a test assembler which combines the business process test with other components such as the test library to produce a test script . The test script may be executed by a test executive . The test executivel may provide user interface features that allow the user to interact with the executing test.

The user may create at least one business process test by selecting individual elements from a set of test elements . The user interface e.g. a graphical user interface displays visual representations of the business process test and the list of elements . The user interface allows a user to select elements from a list of test elements thereby adding the selected elements to the business process test . The action of selecting elements can involve for example dragging and dropping graphical representations of selected elements from the list of test elements to a graphical representation of the list of element calls thereby creating an element call in the list of element calls where the element call is able to invoke i.e. call the selected element when the test script is executed as described below. For example an element that performs a Create Sales Order transaction could be selected from the list of test elements and a corresponding element call would be added to the list of element calls each time the Create Sales Order element is selected. The list of element calls may include i.e. contain or refer to at least one element call . The element call and an optional element call N are shown in to illustrate that the list of element calls may include more than one element call. The presence of the element call N is meant to indicate that the list of element calls includes N element calls which may be numbered 1 through N.

The test elements include two types of elements simple elements and complex elements which are invoked by business process tests to test a business process application. The simple elements elements may invoke the business process application to perform actions such as submitting a transaction selecting a transaction or entering an input value. The complex elements can invoke the simple elements and can also invoke other complex elements . A business process test can invoke both complex elements and simple elements .

Each element call in the list of element calls may be a call to any element in the list of test elements . The diagonal lines show that the element call may call a complex element M and the element call N may call a complex element for example. The diagonal lines illustrate two possible associations. Any other association of element calls to elements is possible i.e. any element call in the list of element calls can call any element in the test elements .

One or more of the complex elements can be created manually i.e. by the user performing a series of interactions with the user interface or created automatically by the element generator . The simple elements which include at least one simple element typically invoke associated computer program code functions and therefore are typically created by programmers. The complex elements include in one aspect invocations of other elements. A complex element can be created by a user. The user creates the complex element by defining a list of other complex or simple elements to invoke i.e. call. In one aspect that list defines the behavior of the complex element .

The complex elements may be a set or a list or similar data structure which contains or refers to at least one complex element . The complex element and a complex element M are shown in to illustrate that the complex elements may include more than one complex element. The presence of the complex element M is meant to indicate that the complex elements include M elements which may be numbered 1 through M.

Each complex element includes formal parameters which accept data values from business process tests. A formal parameter may be for example a sold to party name or a purchase order number. The term actual parameter is used herein to refer to a value such as a number or a string of text characters which is associated with a test element call and is passed to a test element when the test element is invoked. The term formal parameter is used herein to refer to a variable which is associated with a test element has an associated name and can receive values of actual parameters from a test element call when the test element is invoked.

Each element call can provide actual parameters for formal parameters . The simple elements may be a set or a list or similar data structure which contains or refers to at least one simple element .

At least one of the test elements is generated by the element generator . Some of the test elements may be generated manually by the user or by a human programmer not shown using information about the business process application s interface for a particular interaction or transaction. Each of the test elements typically transfers data to and from the business process application. The data to be transferred to the business process application may be provided when the element call is created or modified in which case the data is provided by the user or by the element generator . The data to be transferred can also be provided when the script is executed in which case the data may be taken from for example a spreadsheet application. Each element may retrieve output data from the business process application such as error status or data generated by the transaction. Examples of test elements include a Create Sales Order element which can create a sales order transaction and set the input fields of the sales order transaction to specific values or to values provided when the script is executed. The Create Sales Order element may also verify that the sales order was successfully created by checking the output of the application.

The test assembler converts the business process test into the test script . The test script can perform i.e. execute the business process test by invoking a business process application as described below. The test script includes computer program code in a programming language similar to Visual Basic and can be stored in a file for later use or for use by other testing systems.

Referring to as previously stated a user may provide values for the actual parameters of an element call . The values will be passed to the formal parameters of the test element when the business process test is executed.

Referring again to the example test elements include a Press Enter test element which generates a key press event that simulates a user pressing the Enter key and test elements for filling in field values in a Create Sales Order transaction such as an Initial Screen test element and an Overview test element which fill in values for an Initial Screen and an Overview screen respectively of the Create Sales Order transaction.

The example element calls include in order a VA Initial Screen element call which has a associated actual parameters and is configured to invoke a VA Initial Screen test element a Press Enter element call which has an associated actual parameter and is configured to invoke the Press Enter test element a VA Overview element call which has an associated actual parameters and is configured to invoke the VA Overview test element and a Press Enter element call which has an associated actual parameter and is configured to invoke the Press Enter test element .

Two exemplary element generators are described herein. The first exemplary element generator is user interface based and extracts information from the application s user interface about the fields of the application s user interface to generate a test element for a particular transaction shown on an application screen. The second exemplary element generator is metadata based and uses metadata to generate a test element for a particular transaction. The metadata is a computer readable description of an interface. In one aspect the metadata is a set of field descriptions that includes a field name type and field properties for each field in a transaction for interacting with a business process application. The metadata is typically stored in a database associated with the application. Both approaches produce similar results i.e. one element per transaction screen where the element does not include buttons or menus. The choice of which approach to use may depend on the user s environment and security settings. If both approaches are available the metadata based approach will take precedence because the metadata based approach can more easily be provided as a batch i.e. non interactive process and will therefore be more suitable for generating a large number of test elements. An application such as SAP may have for example 16 000 possible transactions in which case the metadata based element generator can be used to generate automated test elements for the 16 000 transactions. After the test elements have been generated a user may further modify the test elements as desired.

The extraction may be performed by a user interface UI scanner which is for example a script in a test system. The test system may be for example QuickTest Professional from Mercury Interactive Corporation of Mountain View Calif. The automation tool may be provided by the test system. In one aspect the UI scanner is computer program code to be executed by the automation tool . The UI scanner identifies and extracts user interface objects i.e. data fields from the current application screen e.g. SAP screen stores information about the extracted objects in an object dictionary and makes the extracted objects available to an element generator . The extracted objects correspond to the features to be tested for the current application screen. In one example a single screen typically corresponds to a type of transaction so the automation tool extracts the objects to be used for testing a single type of transaction provided by the application .

The information describing the feature to be tested may also be extracted from an application metadata database by an automated element extractor which is in one aspect a computer program having a command line user interface a graphical user interface or both. The automated element extractor includes a database DB extractor . The DB extractor may be for example a script which includes computer program code implemented in a language such as VBScript JavaScript Java or the like. In one aspect the DB extractor identifies and extracts metadata that describes fields of application transactions application database stores information about the extracted objects in the object dictionary and makes the extracted objects available to an element generator . The DB extractor may generate information for multiple transaction screens of a business process application e.g. SAP Siebel or the like.

The user ordinarily chooses whether to use the single screen user interface method of the automation tool which is suitable for interactive use or the metadata based automated element extractor which can process multiple screens and is more suitable for batch invocation. The metadata based extractor is also suitable for interactive use when incorporated into a user interface.

The application database contains descriptions of features such as transactions that are provided by the application . The database may contain a set of records where each record describes a type of transaction. The records may be stored in a file such as a tab delimited file or in a relational database in some other persistent storage format or may be retrieved directly from the application via for example a network interface. Each record may include descriptive data such as a transaction name a screen number and a set of field descriptions which describe the fields i.e. objects which are the input and output of the transaction. Each field description typically includes a name an application specific name a type which may describe how a value can be provided for the field an enabled flag which indicates whether the field is enabled and a required flag which indicates whether the field is required.

The object dictionary stores a description of each transaction of the application . The descriptions are extracted by the automation tool or by the automated element extractor from the metadata stored in the application database and include copies of the transaction and field descriptions described above. In one aspect the object dictionary is represented in a standard and easily accessible data format such as Extensible Markup Language XML . The object dictionary decouples the application and application database from subsequent entities in the process flow of such as the element generator . That is the object dictionary enables subsequent entities in the process flow of to be independent of the application . Entities such as the element generator do not rely on the availability of the application i.e. can be implemented and executed without communicating with invoking or accessing the application or the application database .

According to an embodiment of the invention the object dictionary is represented as a set of Extensible Markup Language XML documents. Each XML document describes an application transaction such as a Create RFQ transaction in an SAP application named ME41 that creates a Request for Quote RFQ . The XML document that represents the ME41 transaction includes a TCODE element that contains the transaction type and one or more SCREEN elements that contain descriptions of one or more screens of the transaction. Each SCREEN element contains a NAME element that contains the screen name and one or more OBJECT elements that contain descriptions of the objects i.e. fields of the screen. Each OBJECT element contains a NAME element an APP NAME element which contains an application specific name of the object an OBJECT TYPE element which contains the name of a user interface component for providing a value for the field a COMPONENT TYPE element contains stores the type of the component an ENABLED element which contains a flag indicating whether the field is enabled i.e. available for input or output and a required field which contains a flag indicating whether the field is required. An example XML document is shown below 

Object properties may be associated with each object to be tested. These object properties may be for example field names alternate field names field types a visible flag an enabled flag and the like. The example object dictionary entry shown above includes elements that represent properties which are NAME APP NAME OBJECT TYPE COMPONENT TYPE ENABLED and REQUIRED These object properties are stored by the UI scanner or the DB extractor in the object dictionary for use by an element generator .

In one example each object corresponding to a data field in a transaction screen is associated with a field name which is an internal name of the object and is independent of locale and a user interface UI name which is displayed by the user interface and is local specific. The field name and the user interface name of each object are stored in the object dictionary as properties of that object as can be seen in the XML example shown above. The APP NAME element corresponds to the field name and the NAME element corresponds to the user interface name. In that example the locale specific name may be derived from the NAME element by a localization module.

According to one embodiment of the invention the automated element extractor produces raw data which is a representation of the objects extracted by the DB extractor . The raw data is converted to a format such as XML and stored in the object dictionary a raw data parser .

In one aspect the element generator acquires objects describing a feature such as a transaction screen from the object dictionary . The element generator converts the objects which may be for example XML documents to corresponding local elements . The element generator generates instructions for the local elements by for example generating an instruction for interacting with i.e. setting and getting the value of each screen field in the transaction screen

The local elements are implementations of the test elements of The local elements provide a programmatic interface for invoking the particular features of the business process application thereby enabling automated testing of the business process application . In one aspect the local elements interact with the user interface of the business process application by simulating user input to the application and converting output data values displayed by the application to objects or variables in a programming language interface.

According to an embodiment of the invention each of the local elements includes computer program code that may accept one or more parameter values as input. The parameters may be received from invoking program code such as a business process test. The local element invokes a feature of the application passing the parameter values to the application as part of the invocation. In one aspect the local element sets user interface fields of a transaction screen of the application to corresponding parameter values.

An example of local element code for setting a field of the Create RFQ transaction type is shown below 

This local element code is implemented as a script in the VBScript programming language. The element code may be stored in temporary or permanent storage such as memory a file or a database. This element code first executes a shared file that contains computer program code statements for initializing the element. Then the element script retrieves a value of a parameter named RFQ type and invokes a Set Text subroutine to set the value of a field named RFQ type to the value of the parameter. Note that the local element is generated by the element generator using the information in the object dictionary . The getVal and Set Text subroutine calls in the element are generated for each OBJECT element i.e. field described in the object dictionary . The element generator typically generates the following two statements for each OBJECT element that can contain text values 

Set Text sets the value of a text field. Similar statements may be generated for setting OBJECT elements that can contain other types of values such as Boolean flags values chosen from a menu and the like by invoking an appropriate Set method in the text.

A business process application test environment may receive the input parameter values to be passed to the test element directly from the user or from a spreadsheet data file data base network service or other data source. The test environment typically uses a description of the names of the parameters of a transaction to determine the number and names of input parameters to be supplied to a transaction. This description of transaction parameters is part of the local elements and is generated by the element generator . The description may include a list of input parameter names and a list of output parameter names and may be stored as a file that is read by the business process test environment. For example if a transaction screen contains a single field named RFQ type then the following parameter description file would be generated 

A set of test elements for interacting with substantially every feature of a business process application may be generated as described above. A set of such statements for a particular transaction type s screen may be stored as a file associated with that screen. A set of such files one for each screen may be associated with the particular transaction type. The element generator is therefore able to generate local elements for interacting with substantially every feature e.g. transaction type of the business process application . The local elements can be used by business process tests to test any desired set of features of the application for which elements have been defined. The local elements may be imported into a business process test environment before use as described below.

An element import component imports the local element into a business process test environment to make the test elements available for invocation by business process tests. The import component may have a graphical user interface for importing multiple elements. The import component may also have a command line interface for importing single elements.

Computer readable code for implementing the business process test environment of the object extraction process of the test element generation process of and test element import process of can be stored in the storage memory and used to control the CPU . Moreover a data structure representing the business process test and the test elements of can be stored in the storage memory . The computer program instructions can cause the CPU to generate the test elements of and to import the test elements into the test development environment for use by the business process test .

If block determines that there are no more objects in the list of objects block saves the object dictionary e.g. as an XML format disk file and block invokes the element generator to convert the objects in the object dictionary to test elements.

The extraction process of is typically executed by a user or a developer of a test system when support for testing a particular type of transaction is to be added to the test system which can occur for example when new transactions or a new application becomes available. The extraction process need not be executed every time a test is run although there is no restriction on the frequency of execution of the extraction process.

Block generates element code i.e. instructions of the test element for interacting with the particular field. Block may for example generates VBScript code lines and add the code lines to a file. The code lines are generated in the format val getVal Parameter val

The first line retrieves a value for the field from the input parameters of the test element. The FieldLabel portion of the first line is different for each field the other portions of the line remain constant although a method other than getval may be used for types that do not support getVal.

The second line sets the application field referred to by FieldLabel to the value retrieved in the first line. SetMethod is a method such as Set Text which is selected by block based upon the type of the field. The type of the field is specified by the COMPONENT TYPE element of the object dictionary entry for the field. Set Text is generated if the field is a text field. Set methods for other types of fields such as list boxes or check boxes may also be generated as specified by the COMPONENT TYPE. FieldLabel is the user interface name of the field which is specified by the object s NAME element in the object dictionary. The parameter val is a parameter name that refers to an input parameter of the test element. The parameter name val is generated for most field types although multiple parameter names e.g. val1 val2 could be generated for set methods that accept multiple parameters.

The flowchart continues at block by determining if there are more objects in the list of objects. If so the next object is processed by block and so that code is generated for each object on the screen. If not a local element i.e. a test element for the screen that was just processed is generated i.e. written to a file or other storage device at block . Next block determines if there are more screens in the screen list. If so the next screen is processed by repeating blocks . Otherwise the flowchart ends.

The flowchart begins at block by connecting to the element repository. Block determines if an upload type specified as an input parameter is Multiple or Single. Single indicates that a single element is to be uploaded i.e. imported and Multiple indicates that multiple elements are to be uploaded. If the upload type is multiple a list of elements to be imported is acquired e.g. as an input parameter at block . In either case at least one XML element from the object repository of is provided to the import process as input. Block begins the process of creating new repository elements and adding them to the repository by first creating a new empty element which is typically represented as an object in a programming language. Block adds the properties of an XML element e.g. the values of the NAME APP NAME OBJECT TYPE COMPONENT TYPE ENABLED and REQUIRED sub elements to the new repository element. Block adds the element code lines generated at block of to the repository element. Block determines if the input of the import process contains more XML elements. If so block gets the next element and repeats the process of adding the element to the repository in blocks . If block determines that the input contains no more XML elements then block disconnects from the repository and the flowchart ends.

The above description is exemplary only and it will be apparent to those of ordinary skill in the art that numerous modifications and variations are possible. For example various exemplary methods and systems described herein may be used alone or in combination with various other computer and computer peripheral systems and methods. Additionally particular examples have been discussed and how these examples are thought to address certain disadvantages in related art. This discussion is not meant however to restrict the various examples to methods and or systems that actually address or solve the disadvantages.

