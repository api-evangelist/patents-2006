---

title: Method and system of accessing display window memory
abstract: A method and system of accessing display window memory. At least some of the illustrative embodiments are methods comprising abstracting display window memory by way of a first software object, accessing the display window memory by routines of a graphics library executed on a first processor (the accessing by way of the first software object), and displaying a window on a display screen, contents of the window selected at least in part by the routines of the graphics library.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782675&OS=08782675&RS=08782675
owner: Texas Instruments Incorporated
number: 08782675
owner_city: Dallas
owner_country: US
publication_date: 20061117
---
The present application claims priority to EP Application No. 06291613.5 filed on Oct. 13 2006 hereby incorporated herein by reference.

Java is a programming language that at the source code level is similar to object oriented programming languages such as C . Java language source code is compiled into an intermediate representation being a plurality bytecodes that define specific tasks. In some implementations the bytecodes are further compiled to machine language for a particular processor. In order to speed the execution of Java language programs some processors are specifically designed to execute some of the Java bytecodes directly. Many times a processor that directly executes Java bytecodes is paired with a general purpose processor so as to accelerate Java program execution.

In systems where processors are paired the processor that directly executes Java bytecodes relies on calls to library routines executed on the second processor to perform graphics functions. The calls to library routines executed on the second processor are referred to as calls to native library routines through a Java Native Interface JNI . In order for the native library routines to operate parameters are passed between the processors by way of the main memory. However active data locations are stored in each processor s data cache and the corresponding main memory locations may not reflect the latest parameter values. In order for the parameters to reside in the main memory when a native library routine is invoked thus requires the calling processor to flush its data cache. Likewise the processor that executes the native library routine may evict data from its data cache in order to obtain the parameters. The evicted data is later re loaded when the native library routines completes their tasks Because of the data cache flush and eviction mechanism to exchange parameters calling native library routines from the processor directly executing Java bytecodes results in slow system performance regarding graphics operations.

The problems noted above are solved in large part by a method and system of accessing display window memory. At least some of the illustrative embodiments are methods comprising abstracting display window memory by way of a first software object accessing the display window memory by routines of a graphics library executed on a first processor the accessing by way of the first software object and displaying a window on a display screen contents of the window selected at least in part by the routines of the graphics library.

Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate various companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function. In the following discussion and in the claims the terms including and comprising are used in an open ended fashion and thus should be interpreted to mean including but not limited to . . . . Also the term couple or couples is intended to mean either an indirect or direct connection. Thus if a first device couples to a second device that connection may be through a direct connection or through an indirect connection via other devices and connections.

The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred the embodiments disclosed should not be interpreted or otherwise used as limiting the scope of the disclosure unless otherwise specified. In addition one skilled in the art will understand that the following description has broad application and the discussion of any embodiment is meant only to be exemplary of that embodiment and not intended to intimate that the scope of the disclosure including the claims is limited to that embodiment.

Optional processor may be referred to as a Micro Processor Unit MPU . System may also comprise memory coupled to both the JSM and MPU and thus accessible by both processors. A portion of the memory may be shared by both processors and if desired other portions of the memory may be designated as private to one processor or the other. The memory may be further coupled to a display .

System also comprises a Java virtual machine JVM . The JVM may comprise the Application Programming Interface implementation API and a Java Virtual Processor JVP discussed more below . The API implementation comprises a resource manager and a configuration . The resource manager manages resource sharing between multiple threads and or applications running on the system . The configuration provides applications with an API which API is used to access base functionalities of the system.

The JVP may comprise a combination of software and hardware. The software may comprise a compiler and a JSM Execution Kernel JEK . The JEK comprises software that is executable within the JSM such as a class loader bytecode verifier garbage collector and firmware to interpret the bytecodes that are not directly executed on the JSM processor . Thus the hardware of the JVP may comprise the JSM . The JVP provides a layer of abstraction between the API and a physical hardware platform e.g. JSM that executes Java bytecodes. Other components may be present as well.

Java language source code is converted or compiled to a series of bytecodes with each individual one of the bytecodes referred to as an opcode. Bytecodes may be provided to the JEK possibly compiled by compiler and provided to the JSM . When appropriate the JVP may direct some method execution to the MPU .

In addition to executing at least some of the software to perform the JVM functionality and executing compiled Java bytecodes the MPU also may execute other software programs like an operating system O S which performs various functions such as system memory management system task management that schedules the software aspects of the JVM and most or all other native tasks running on the system and at least partial management of the display .

Considering first the windows used by the Java application there may be an active window and a non active window . In order to display the contents of the active window the contents of the active window may be copied to a display frame buffer . Alternatively a display driver may formulate the display pattern by reading directly from the active window in memory . Likewise for the application executed on the MPU there may be an active window and a non active window . In order to display the contents of the active window the contents of the active window may be copied to a display frame buffer . Alternatively a display driver may formulate the display pattern by reading directly from the active window in memory .

Periodically the active and non active status of each window is switched or flipped such that updates to each window may be displayed if the window is visible on the display . In order to identify the active and non active windows each set of windows has a pointer and which contains an indication of the active window such as a starting address in memory of the active window. The window manager programs and flip their respective active and non active windows by changing the pointer values.

In the related art Java applications do not have graphics libraries e.g. line draw set colors executable on the JSM . Rather in the related art Java applications make calls to graphic library routines executable on the illustrative MPU native library routines through what is known as Java Native Interfaces JNIs . Native library routines called through JNIs thus make modifications to the various windows for the Java applications. In order for the native library routines to operate parameters are passed between the processors by way of the memory . However active data locations are stored in each processor s data cache and the corresponding memory locations may not reflect the latest parameter values. In order for the parameters to reside in the memory when a native library routine is invoked thus requires the calling processor to flush its data cache e.g. data cache . Likewise the processor that executes the native library routine may evict data from its data cache e.g. data cache in order to obtain the parameters. The evicted data is later re loaded when the native library routines complete their tasks. Because of the data cache flush and eviction mechanism to exchange parameters calling native library routines from the processor directly executing Java bytecodes results in slow system performance regarding graphics operations.

In accordance with embodiments of the invention a Java graphics library is provided. The Java graphics library comprises graphics routines that are executable by the JSM e.g. the graphics routines comprise Java bytecodes or instructions from another instruction set executable by the JSM . In order for the routines of the Java graphics library to reach and modify the window memory the Java application alone or in combination with the JEK create a Java object which provides access to the window memory for the Java application and or routines of the Java graphics library . In this way most if not all calls to a graphics routine may be executed on the JSM side without the need to use a JNI to reach native graphic library routines and the corresponding cache flush to ensure proper exchange of parameters. Further the Java application alone or in combination with the JEK create a second object which provides access to the pointer . Thus the window manager may flip the active and non active windows by appropriately adjusting the pointer .

Inasmuch as the two applications and may be modifying the contents of windows displayed on the same display device some coordination between the window manager program executed on the JSM and the window manager program executed on the MPU may be desirable. For example each time the Java application creates a new window the windows manager program executed on the MPU may be informed such that the program can control placement and whether the new window is in the foreground or background. Likewise each time the Java application moves an existing window or re sizes an existing window the window manager program may be informed such that appropriate action is taken. The notification between the window manager program and the window manager program may take many forms for example a JNI call from the window manager program .

From the description provided herein those skilled in the art are readily able to combine software created as described with appropriate general purpose or a special purpose computer hardware to create a computer system and or computer subcomponents embodying aspects of the invention to create a computer system and or computer subcomponents for carrying out the method embodiments of the invention and or to create a computer readable medium storing a software program to implement method aspects of the various embodiments. Moreover the embodiments of the illustrative methods could be implemented together in a single program with various subroutines or split up into two or more programs executed on the processor.

While various embodiments of the invention have been shown and described modifications thereof can be made by one skilled in the art without departing from the spirit and teachings of the invention. The embodiments described herein are illustrative only and are not intended to be limiting. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

