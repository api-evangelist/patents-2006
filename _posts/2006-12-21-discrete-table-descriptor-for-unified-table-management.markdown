---

title: Discrete table descriptor for unified table management
abstract: A table descriptor is associated with a table and referenced to provide access to the table. The table descriptor includes a first portion identifying information about the table and a second portion identifying one or more locations of the table in memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07710972&OS=07710972&RS=07710972
owner: Intel Corporation
number: 07710972
owner_city: Santa Clara
owner_country: US
publication_date: 20061221
---
This disclosure relates generally to table management and in particular but not exclusively relates to a table descriptor for lookup table management.

Modem packet switching networks are used to carry a variety of different types of information for a wide variety of users and applications. As the use of packet based networks and the diversity of applications to be supported is increasing support for advanced networking services such as Service Level Agreement SLA monitoring traffic engineering security billing and the like to name a few is becoming a requirement.

One technique for implementing these advanced network services is to classify packets transported within the network into flows and assign actions to be taken on the packets based on the flow assignment. Based on the flow assignment the network may ensure all packets of this flow receive the appropriate priority and reserve the necessary bandwidth along the path to the destination. The criteria for classification into flows may be diverse it may include information from the header of a packet some part of the packet payload or other information such as the ingress or egress interface associated with the packet. This criteria for classification is specified in the form of classification rules. Any packet matching the criteria specified in a classification rule will be classified into the same flow.

In conventional network processor unit NPU the diverse set of classification rules may be stored in a number of lookup tables. These lookup tables are indexed into by the classification engine to determine the flow to which an incoming packet should be assigned. Since packet classification is executed in real time at line rates these lookup tables are often maintained in expensive high speed low latency memory e.g. SRAM which is a finite and valuable resource.

Lookup tables may also be used to implement other functionality within a NPU such as Internet Protocol IP forwarding to route a packet from its source to its destination. EP forwarding is a layer three operation that uses IP addresses to make forwarding decisions. The NPU indexes into a routing table stored in a lookup table using the destination IP address within the packet or datagram as the index key. The IP forwarding decision chooses the next hop IP address as well as an output port of the router through which the next hop may be reached. Conceptually a routing table contains an entry for each possible destination along with a next hop used to reach the destination.

Conventional lookup tables are established by pre allocating a contiguous block of memory and populating the memory with entries of the lookup table. The amount of memory pre allocated is generally determined based on an estimate of the maximum foreseeable number of entries. Even if only a fraction of the maximum number of entries is actually used the entire block of pre allocated memory remains reserved resulting in wasteful consumption of a valuable resource.

Since each lookup table in an NPU may be designed for a unique purpose e.g. classification IP forwarding database access etc. each lookup table can have a unique format and its own set of management access functions also referred to as application program interfaces APIs developed by the table designer. Although the various APIs for the lookup tables may execute the same or similar table functions each lookup table has its own set of APIs due to non unified formats of the various lookup tables. These redundant APIs are stored in memory and consume valuable memory resources as well.

Embodiments of a system and method for a discrete table descriptor are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the techniques described herein can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring certain aspects.

Reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of the phrases in one embodiment or in an embodiment in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Classifying packets into flows can aid hardware and or software of network nodes to implement a number of advanced network services including service level agreement SLA monitoring traffic engineering security billing tracking quality of service QoS generating and maintaining statistical data and the like. Forwarding packets also referred to as Internet Packet IP forwarding effectuates routing packets from their source node to their destination node. Both of these tasks classification and IP forwarding may be implemented with reference to one or more lookup tables.

Receive block is the initial stage that reads packets from network via a MAC or framer or from a switch fabric. Receive block temporarily stores packets into a receive buffer. Often times packets are segmented prior to transmission over network into packet segments. Since packets typically are processed as a complete packet and not segments re assembly block reassembles the packet segments stores them into memory e.g. DRAM and generates a packet descriptor for local processing. Classify block is the stage where packets are inspected to determine the action to be taken on the packet by assigning packets to flows. Classification may be executed by inspecting subfields of packet e.g. source address field destination address field destination port field source port field protocol field etc. and using the values of these fields as an index key into classification tables e.g. lookup tables to retrieve a corresponding rule to apply to packet e.g. quality of service to apply etc . After packets are classified forwarding block may inspect the destination address to determine the next hop and corresponding output port through which packets should be forwarded. In one embodiment forwarding block may use the destination address as an index key into routing tables e.g. lookup tables to retrieve a corresponding next hop and output port. Flow manager may execute a variety of functions on packets dependent upon the flow to which each packet was assigned by classify block . For example flow manager may perform metering and statistics functions congestion management and the like.

During the receive processing stages a packet is reassembled from several smaller segments classified then forwarded. Assuming it passes through the metering and congesting avoidance stages without being dropped the packet is ready for transmit stage processing. Queue manager organizes e.g. enqueues packets into queues according to a transmit schedule generated by TX scheduler . When a queued packet is ready for transmission according to the transmit schedule queue manager dequeues the packet and provides the packet descriptor to TX block . TX block uses the packet descriptor to retrieve buffered packets from memory and transmit them out of network node .

As previously mentioned one or both of classify block and forwarding block may refer to lookup tables to perform their respective functions. In one embodiment table APIs provide a unified and shared point of access to lookup tables . Tables APIs publish a unified set of functions that may be shared by classify block forwarding block or other entities to access lookup tables . For example some of these unified functions may include a seek find or lookup function a create function a modify function or a delete function. Other more specialized functions may be generated for point to point flows connection orientated flows and the like.

In order to provide access to a variety of lookup tables having a possible variety of sizes formats and locations in memory table APIs refer to DTDs . In one embodiment each lookup table has an associated DTD to describe format size location and other information about itself. Accordingly in one embodiment there is a one to one relationship between lookup tables and DTDs . DTDs provide table APIs with the information to tailor the unified functions to accommodate the differences between lookup tables .

In one embodiment table APIs are software functions that may be part of a modularized table management library. This library would provide the user with functionality to operate on different kinds of tables e.g. lookup tables through similar looking unified interfaces. With the help of DTDs the table management library can be integrated into an operating system or a firmware subsystem running on a control processor of a network processor or other hardware system. With the functionality provided by table APIs and DTDs rather than having dedicated table management functions for each lookup table whose functions can be more or less similar in a network processing environment lookup tables can be used as parameters to these universal table management functions and generic operations e.g. lookup classify modify add delete etc. can be performed on lookup tables by interpreting DTDs for each lookup table . Besides providing management functions for lookup tables table APIs may provide interfaces to manage and interpret DTDs as well.

Conventionally since lookup tables may be designed by different developers for a variety of different purposes the developers of lookup tables would also develop a unique set of functions tailored specifically for accessing each lookup table. However not only does developing multiple unshared access functions for lookup tables incur redundant development costs but the memory footprint consumed by these independent functions is wasteful.

Table manager manages DTDs and lookup tables . For example when classify block or forwarding block modifies one of lookup tables table manager may update its corresponding DTD to ensure the modification is reflected in the corresponding DTD . When a new lookup table is created table manager is responsible for automatically creating a new corresponding DTD . Similarly if one of lookup tables is deleted table manager is responsible for deleting its corresponding DTD . In one embodiment tables APIs are incorporated within table manager and classify block forwarding block or other entities access lookup tables via the APIs published from table manager itself. In this case one of the important functions implemented by table manager would be publishing the lookup function for finding entries within lookup tables to a variety of client processes wishing to access lookup tables .

Although embodiments of the present invention are described primarily in relation to classification and forwarding as they related to network processing it should be appreciated that implementation of DTDs for accessing tables in different contexts and environments are contemplated. For example tables may be used for accessing databases and therefore DTDs may be generated for unified access to database tables.

As illustrated routing table A includes four fields to i.e. destination address address mask next hop address interface number and may include any number of entries i.e. entries through N with values populated in each of the fields to . Routing table A is only one example of an IPv4 routing table. It should be appreciate that other routing tables e.g. IPv6 routing table may include more or less fields containing the same or different data with different byte sizes for each field. As previously mentioned forwarding block may index into routing table A to determine the next hop and output interface port number to forward packets to their destinations. For example forwarding block may parse the destination address field of packets and use this value to index into routing table A.

Classification table B illustrates an example 5 tuple classification table for IPv4. The typical quintuple or 5 tuple classification process is performed on TCP IP packets using the IP source address IP destination address TCP source port number TCP destination port number and the protocol ID extracted from packets . Values for these packet fields may be extracted from packets and used to index into classification table B to determine what flow e.g. field a packet belongs too. Of course it should be appreciated that classification table B is merely intended for illustration and that other classification tables having different formats fields sizes and numbers of entries may be used for classification purposes.

The illustrated embodiment of DTD includes the following descriptor fields a table identifier ID field a number of fields field one or more field size fields a number of distributions field a number of partitions field one or more memory type fields one or more start address fields one or more number of entries fields and zero or more number of partitions fields . The descriptor fields can be further logically broken into two portions portion A and portion B. Portion A includes information describing the format of a lookup table while portion B includes information describing the location or locations of the lookup table and its number of entries.

Descriptor field includes information to identify and reference the corresponding lookup table of DTD e.g. one of lookup tables . Descriptor field includes information to identify the number of table fields in the corresponding lookup table. For example routing table A includes four table fields while classification table B includes six table fields. Descriptor fields each describe the size e.g. number of bits or bytes of a corresponding table field. Accordingly if descriptor field identifies that the lookup table contains four table fields then column will include four descriptor fields each identifying the respective size of each table field.

Descriptor field includes information to identify the number of memory types over which the lookup table is distributed. In this context the term memory type is used to connote a distinct memory unit. For example dynamic random access memory DRAM is one memory type while synchronous DRAM SDRAM is another memory type. Descriptor field includes information to identify whether the lookup table is stored in multiple discontinuous memory partitions within a single memory type and in some cases discloses the actual number of discontinuous memory partitions. Accordingly descriptor fields and enable DTD to track portions or entries of a single lookup table that are distributed across multiple different memory types and even discontinuously stored in multiple partitions within a single memory type. This is illustrated in where lookup table fragments of a single lookup table are illustrated as being simultaneously stored in DRAM SRAM persistent storage and scratch memory .

Descriptor fields identify the actual memory types themselves in which the lookup table is distributed. In one embodiment if descriptor field identifies only one distribution then column will only include one descriptor field identifying the single memory type. The number of descriptor fields present in column corresponds to the number of distributions identified in descriptor field . Descriptor fields list the start address of each contiguous portion of the lookup table in the one or more memory types. Accordingly if descriptor field identifies multiple discontinuous partitions for the lookup table while descriptor identifies that the lookup table is located in only a single memory then column will list one start address for each memory partition identified in descriptor field . Descriptor fields list the number of table entries extending from each start address listed in column .

Finally descriptor fields listed in column are present in a special scenario and otherwise not included in DTD . In the special scenario where descriptor field identifies multiple distributions and descriptor field identifies multiple partitions then additional descriptor fields illustrated in column are added to DTD . Descriptor fields identify the number of discontinuous memory partitions within each memory type identified in descriptor fields of column . Accordingly for each memory type listed in column there will be a corresponding number of partitions listed in column .

In a process block a table is generated e.g. one of lookup tables and populated with entries. The table maybe created and the various entries stored in a single memory type as one contiguous block of memory in a single memory type but located in multiple discontinuous memory partitions of the single memory type distributed across multiple memory types but stored as a single contiguous memory partition within each memory type or distributed across multiple memory types and stored in multiple discontinuously memory partitions of one or more of the memory types. Accordingly embodiments of the invention provide flexibility in where and how the entries of a single table are stored.

In a process block a new DTD is created and associated with the new table. The DTD is associated with the newly created table by populating descriptor field column with a table ID identifying the newly created table. In a process block the number of table fields within the newly created table is written into descriptor field column . Referring to as examples if DTD corresponded to routing table A then descriptor field would be populated with a value indicating four table fields. If DTD corresponded to classification table B then descriptor field would be populated with a value indicating six table fields.

In a process block descriptor fields column are populated with values indicating the size of each table field of the newly created table. Accordingly if descriptor field identifies four table fields then there will be four descriptor fields each identifying the size of a corresponding table field. The values populated into descriptor fields may identify the size of the corresponding table field in bits bytes words long words or some other incremental value.

In a process block descriptor field column is populated with a value identifying the number of distributions for the table. As discussed above DTD enables a single lookup table to be distributed across multiple different memory types e.g. SRAM DRAM flash hard disk etc. . For example if a single table were partially stored in SRAM and partially stored in DRAM then descriptor field would be populated with a value indicating two distributions.

In a process block descriptor field column is populated with a value identifying whether the table is currently stored in a single partition or multiple partitions. In some scenarios described in detail below the value populated in descriptor not only identifies whether the table is stored in multiple partitions but also identifies the number of partitions over which the table is spread.

As illustrated in the embodiment of process the values populated into descriptor fields and can lead to four alternatives. Alternative A includes a table that is neither distributed nor partitioned. In other words the table is located in a single memory type within a single contiguous partition of memory. Alternative A is identified by of distributions of partitions 1 1 . In a process block see the single memory type in which the table is located is identified in descriptor field column . Since alternative A only includes one memory type only a single descriptor field is populated in column . In a process block the start address of the table is identified in descriptor field column . Since alternative A only include one partition only a single descriptor field is populated in column . In a process block the number of entries in the table is identified in descriptor field . Again since alternative A only includes one partition only a single descriptor field is populated with a number of entries value in column .

Alternative B includes a table that is not distributed over multiple memory types but is located in multiple discontinuous partitions within a single memory type. Alternative B is identified by of distributions of partitions 1 1 . In alternative B descriptor field column identifies the number of partitions in which entries of the table are stored. Accordingly the number of descriptor fields and in columns and respectively will equal the number of partitions identified in descriptor field . In a process block the single memory type in which the table is located is identified in descriptor field column . In a process block the start address of each portion of the table located in a different memory partition identified in descriptor field is identified in corresponding descriptor fields of column . In a process block the number of entries in each table portion is identified in descriptor fields column . Accordingly there is one descriptor field listing a number of entries for each start address identified in descriptor fields . In alternative B there is a one to one correspondence between descriptor fields in column and descriptor fields in column .

Alternative C includes a table that is distributed over multiple memory types but is located in only a single contiguous partition within each memory type. Alternative C is identified by of distributions of partitions 1 1 . In alternative C descriptor field column identifies the number of distributions or memory types over which the table is distributed. Accordingly the number of descriptor fields in column will equal the number of distributions identified in descriptor field . In a process block each of the memory types over which the table is distributed is identified in descriptor fields column . In a process block the start address of each distribution of the table located in a different memory type is identified in corresponding descriptor fields of column . In a process block the number of entries in each table distribution is identified in descriptor fields column . Again in alternative C there is a one to one correspondence between descriptor fields in column and descriptor fields in column .

Alternative D is a special case which includes a table that is distributed over multiple memory types and includes one or more distributions having multiple discontinuous memory partitions. In the special case of alternative D the number of partitions identified in descriptor field column need not identify the actual total number of partition for the table though it can . Rather it can simply list a value greater than one. In alternative D the value listed in descriptor field may merely be used to interpret and identify existence of the special case of alternative D . Alternative D is identified by of distributions of partitions 1 1 . In alternative D additional descriptor fields column are used.

In a process block each of the memory types over which the table is distributed is identified in descriptor fields column . In a process block the number of partitions within each memory type identified in column are listed in corresponding descriptor fields . In one embodiment of alternative D there is a one to one correspondence between descriptor fields column and descriptor fields column . Accordingly a particular memory type identified in column may only store a single contiguous memory partition in which case a corresponding descriptor field column will list only one partition. However other memory types identified in column may include multiple discontinuous memory partitions in which case corresponding descriptor fields column will list the number of memory partitions for each memory type.

In a process block the start address of each partition of the table identified in descriptor fields column is identified in a corresponding descriptor field column . Accordingly if the descriptor field labeled partitions identifies three partitions within the memory type identified in descriptor field labeled mem type then column would include three descriptor fields e.g. start addr start addr and start addr each listing a start address for a respective memory partition. Similarly if descriptor field labeled partitions identifies two partitions within the memory type identified in descriptor field labeled mem type then column would include two additional descriptor fields e.g. start addr and start addr each listing a start address for a respective memory partition.

In a process block the number of table entries currently stored in each partition having an associated start address identified in column is identified in descriptor fields column . Again in alternative D there is a one to one correspondence between descriptor fields in column and descriptor fields in column . illustrates a table that summarizes possible values within the descriptor fields of DTD and their respective interpretations according to one embodiment of the invention.

Once the various descriptor fields of DTD are populated DTD can be referenced to gain access to a distributed and partitioned lookup table. Furthermore as entries are added deleted or modified DTD may be updated by table manager to reflect the changes allocated new memory release unused memory or otherwise.

The components of NPU interoperate as follows. Multi interconnect may include multiple independent internal buses for interconnecting the various subcomponents of NPU . Microengines are multithreaded and provide the parallel processing power to process packets at line rates. In one embodiment a different one of microengines may be assigned to execute each of the processing stages illustrated in . Control processor managers the control plane of NPU where it processes exception packets executes chip configuration and control manages routing tables e.g. routing table A and runs signaling stacks. Control processor may also perform various data plane tasks such as terminating TCP IP setting up network address translation establishing IP Security IPSec connections or the like. In one embodiment control processor is responsible for executing table manager to create update or modify DTDs .

MSF interface connects to multi interconnect and provides the primary interface for transferring packets in out of NPU . MSF interface may include one or more interfaces e.g. industry standard interfaces such as UTOPIA SPI 3 SPI 4.2 or the like to connect to network e.g. local area network wide area network Internet etc. . MSF interface may also include one or more interfaces e.g. SPI CSIX or the like for coupling to a switch fabric . Since MSF interface is located between the primary packet processing engines microengiens and network and switch fabric MSF interface may include memory to buffer inbound and outbound packets .

SRAM controller couples multi interconnect to SRAM . SRAM controller provides a high speed low latency connection to SRAM . SRAM may typically be used for storing lookup tables DTDs buffer descriptors free buffer lists and the like. DRAM controller couples multi interconnect to DRAM . Since DRAM is typically less expensive and lower speed than SRAM DRAM may be used as the bulk storage for buffering packets while their descriptors are processed by microengines . DRAM may also be used to store routing tables and flow descriptors. I O controller may couple multi interconnect to a variety of external devices media such as a persistent storage device e.g. flash memory disk drive network drive etc. . In one embodiment I O controller is a peripheral component interconnect PCI interface.

The illustrated embodiment of SHaC unit includes scratch memory a hash unit and CSRs . In one embodiment scratch memory contains 16 kbytes of memory often used for microengine to microengine communication and local data storage. Hash unit may execute 48 bit 64 bit or 128 bit hash calculations to support hash table lookup functions. In one embodiment CSRs include the bulk of the chip wide control and status registers for NPU .

As illustrated a lookup table e.g. one of lookup tables A or B may be split up into fragments which are stored in one or more memories including SRAM DRAM persistent storage scratch memory or otherwise. Furthermore lookup table fragments may be stored in one or more discontinuous memory partitions within a single memory device. The corresponding DTD may be stored in a single memory device e.g. SRAM where it may be referenced by table APIs table manager classify block forwarding block or other entities to gain access to the distributed and partitioned fragments of the lookup table.

DTD provides a single reference point in memory to determine the format and location of its corresponding lookup table. DTD also enables flexibility not only to store its corresponding lookup table in anyone of the memories listed above but also to distribute a single lookup table across multiple memory types e.g. SRAM DRAM persistent storage scratch memory etc. . Furthermore since DTD supports the addition of memory partitions to a lookup table a minimum base amount of memory can be pre allocated to a lookup table and then subsequent memory partitions added to the lookup table as entries are added to the lookup table and additional memory consumed. Since DTD includes a mechanism to describe the locations of discontinuous memory partitions the additional memory fragments added to the lookup table need not be contiguous with the initial pre allocated memory. This ability to allocate and release memory for lookup tables on an as needed basis enables a memory management technique reducing the need to wastefully pre allocate large blocks of memory which may or may not be used.

As entries are added deleted or modified within the lookup table its corresponding DTD can be updated in real time to reflect the changes. If lookup table fragments are moved from one memory type to another during operation of NPU their movements can be tracked simply by updating DTD in real time. This ability to track the movement of lookup table fragments from one memory type to another enables a sort of high speed caching mechanism where the most commonly access entries within a table are kept in higher speed bandwidth lower latency memories e.g. SRAM or scratch memory while the less frequently accessed entries of the lookup table are pushed out to the slower speed higher latency memories e.g. DRAM persistent storage .

The processes explained above are described in terms of computer software and hardware. The techniques described may constitute machine executable instructions embodied within a machine e.g. computer readable medium that when executed by a machine will cause the machine to perform the operations described. Additionally the processes may be embodied within hardware such as an application specific integrated circuit ASIC or the like.

A machine accessible medium includes any mechanism that provides i.e. stores and or transmits information in a form accessible by a machine e.g. a computer network device personal digital assistant manufacturing tool any device with a set of one or more processors etc. . For example a machine accessible medium includes recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. .

The above description of illustrated embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various modifications are possible within the scope of the invention as those skilled in the relevant art will recognize.

These modifications can be made to the invention in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification. Rather the scope of the invention is to be determined entirely by the following claims which are to be construed in accordance with established doctrines of claim interpretation.

