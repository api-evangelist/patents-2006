---

title: Interface for sensor query and control
abstract: Systems and methods are presented that enable a higher-level software application to query and control a sensor through a generic interface. In one embodiment, a system includes a controller, and interface, and a set of sensor driver modules. The interface receives a command from the controller and sends it to the driver modules. The interface includes a client, a server, and a network. The server includes two interfaces: a client interface to communicate with the client and a driver interface to communicate with the driver modules. The server also includes two buffers: a command queue and a reply queue. The command queue stores commands received from the controller (via the client). The reply queue stores replies received from the driver modules.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08355804&OS=08355804&RS=08355804
owner: Honda Motor Co., Ltd.
number: 08355804
owner_city: Tokyo
owner_country: JP
publication_date: 20060915
---
This application claims priority from the following U.S. provisional patent application which is hereby incorporated by reference Ser. No. 60 717 682 filed on Sep. 15 2005 entitled SensorTalk. 

The present invention relates to enabling a higher level software application to query and control a sensor through a generic interface.

A sensor is generally queried and controlled directly via its device driver. For example an application uses a device driver in order to query and control a sensor. Sensor device drivers have many disadvantages. Consider a sensor that is designed to communicate with a computer via a particular input output device such as a portable computer PC card. In order for an application on the computer to query or control the sensor the application must execute in an operating system that supports the PC card. Also communication with a sensor driver is often limited to one device at a time which prevents multiple devices from querying or controlling a sensor simultaneously. Finally a sensor driver often supports a fixed set of sampling rates e.g. rates for obtaining data from the sensor which prevents obtaining data at other rates.

What is needed is a generic interface that enables a higher level software application to query and control a sensor.

Systems and methods are presented that enable a higher level software application to query and control a sensor through a generic interface. In one embodiment a system includes a controller an interface and a set of sensor driver modules. The controller is used to query and control the sensor via the interface. The interface uses the sensor driver modules to directly query or control the sensor. The sensor can be either a physical entity or a virtual entity.

In one embodiment the interface communicates with the controller using a first application programming interface API and with the driver modules using a second API. The interface receives a command from the controller and sends it to the driver modules. Commands include sensor commands and system commands.

In one embodiment the interface includes a client a server and a network. The server includes two interfaces a client interface to communicate with the client and a driver interface to communicate with the driver modules. The server also includes two buffers a command queue and a reply queue. The command queue stores commands received from the controller via the client . The reply queue stores replies received from the driver modules.

In one embodiment the interface can operate in either of two command modes direct and continuous. In direct mode the client sends commands to the server in blocking mode. In continuous mode the client sends commands to the server in non blocking mode. In streaming mode which is a particular type of continuous mode one command received from a client can cause a server to periodically instruct the sensor to execute the command. In batch mode which is another particular type of continuous mode a server uses buffering to enable a sensor to achieve higher rates of data processing.

In one embodiment a system includes multiple controllers. In this embodiment the interface includes multiple clients. In another embodiment a system includes multiple sets of driver modules. In this embodiment the interface includes multiple servers. In yet another embodiment a system includes multiple interfaces. In this embodiment a first interface communicates with a composite sensor which in turn includes a second interface .

In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention can be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to avoid obscuring the invention.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment.

Some portions of the detailed descriptions that follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to an apparatus for performing the operations herein. This apparatus is specially constructed for the required purposes or it comprises a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program is stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems are used with programs in accordance with the teachings herein or more specialized apparatus are constructed to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

In one embodiment the controller comprises a software application used to query and or control a sensor. The controller communicates with the sensor not shown via the interface . Signals sent from the controller to the interface include for example commands to be executed by the sensor. Signals sent from the interface to the controller include for example the sensor s replies to commands that it has received. In one embodiment signals sent between the controller and the interface comply with an application programming interface API that is provided by the interface .

In one embodiment the set of sensor driver modules comprises a set of software drivers and or libraries that can be used to directly query or control a sensor not shown . Signals sent from the interface to the set of sensor driver modules include for example commands to be executed by the sensor. The commands sent are determined based on the commands received from the controller . Signals sent from the set of sensor driver modules to the interface include for example the sensor s replies to commands that it has received. In one embodiment signals sent between the interface and the set of sensor driver modules comply with a second API that is provided by the set of sensor driver modules .

The sensor that is queried or controlled by the set of sensor driver modules can be either a physical entity or a virtual i.e. simulated entity. Physical entities are tangible. Virtual entities can include software models that represent sensors.

The first API between the controller and the interface provides a way for a controller to query and control a sensor. The API includes both commands which are sent from the controller to the interface and replies which are sent from the interface to the controller . In one embodiment the API is independent of both the hardware and software of the controller . Thus the API can be used with many different controllers .

In one embodiment a sensor s state which includes its configuration and or data that it has sensed is represented by one or parameters. One exemplary parameter of a sensor is what type of data it reports e.g. image data force data sound data and temperature data . Another exemplary parameter is how often the sensor senses data i.e. its sampling rate or fundamental frequency . Yet another exemplary parameter is the format in which the sensor reports data. For example a temperature sensor could report temperature in degrees Fahrenheit degrees Celsius or degrees Kelvin. An image sensor could report data as a bitmap file .bmp a JPEG file .jpg or a GIF file .gif .

A particular parameter may or may not be configurable by a user. For example the type of data reported by a sensor is usually built in to the sensor and cannot be changed. As another example the format in which the sensor reports data is usually not built in to the sensor and can be changed. Note that while the actual data reported by the sensor might be configurable setting this data could defeat the purpose of sensing the data in the first place.

In one embodiment the first API includes a system portion and a sensor portion. The system portion of the API is sensor independent. This means that the system portion is compatible across various sensors at both a software and hardware level. In one embodiment the system portion comprises various commands and replies regarding system status. The commands include for example setTransmissionMode e.g. direct or continuous getDescription described below setPeriodicPublishing described below subscribe and release. The replies include for example status signals and error signals such as current transmission mode client identifier failed subscription and failed release. In one embodiment all system commands are the same length. In another embodiment all system replies are the same length.

The sensor portion of the API is sensor dependent. This means that the sensor portion can change based on which sensor is being used. For example the commands that a sensor can execute and the replies that a sensor can generate can differ based on which sensor is being used.

In one embodiment the sensor portion of the API generally comprises a set of rudimentary commands over the sensor s parameters. These commands can theoretically be used in conjunction with any parameter of any sensor. In one embodiment the commands include Read Set SetDefault Reset SetFactoryDefault FactoryReset Lock and Unlock. The Read command queries and returns the current value of a parameter. The Set command sets the value of a parameter to a specified value if the parameter s value can be modified . The SetDefault command sets a parameter s default value. The Reset command sets the value of a parameter to its default value. The SetFactoryDefault command sets a parameter s factory default value. The FactoryReset command sets the value of a parameter to its factory default value. The Lock command prevents the value of a parameter from being changed. The Unlock command allows the value of a parameter to be changed. In one embodiment each of these rudimentary commands generates a rudimentary reply when the command is executed by a sensor.

The specific commands available in the sensor portion of the API differ based on the sensor that is being used. In one embodiment the sensor portion of the API assigns these specific commands to the rudimentary commands provided by the system. For example if a force plate sensor is being used the sensor portion of the API might include the commands SetShearForceSensitivity and ReadShearForceSensitivity. SetShearForceSensitivity might be a specific implementation of the rudimentary command Set while ReadShearForceSensitivity might be a specific implementation of the rudimentary command Read. In one embodiment a sensor registers each of its parameters with the system and the system assigns each parameter a unique identifier. This unique identifier is then used in conjunction with a rudimentary command in order to customize the rudimentary command to affect that particular parameter. In one embodiment sensor commands can vary in length. In another embodiment sensor replies can vary in length.

In one embodiment the specific replies generated in the sensor portion of the API differ based on the sensor that is being used. In one embodiment the sensor portion of the API assigns these specific replies to the rudimentary replies provided by the system.

In one embodiment specific information about a sensor s capabilities is present in the first API e.g. based on which sensor commands and sensor replies are supported by the API . Since differences between sensors can affect the overall API they can also affect the controller . In one embodiment there exists a machine readable description of a sensor and its parameters. In this embodiment a controller can parse the description to learn about the sensor portion of the first API. In this way the controller can determine which features are available from the sensor and how to invoke them. In one embodiment the description includes one or more characteristics for each parameter such as the parameter s name whether it can be changed configured its units of measure its default value its factory default value and its range of possible values. In one embodiment the controller obtains the machine readable description by using the command getDescription which obtains the description from the set of sensor driver modules .

In one embodiment the controller sends a command or set of commands to the interface in blocking mode. In this embodiment the controller waits to receive a reply signal or multiple reply signals one for each command from the interface before it issues the next command or set of commands . In other words after the controller has sent a command or set of commands to the interface the controller s execution stops and resumes only when the controller receives an acknowledgement or multiple acknowledgements one for each command from the interface . In particular the controller does not send a new command or set of commands to the interface until it has received an acknowledgment regarding the previous command or multiple acknowledgements regarding the previous commands . This acknowledgement can indicate for example that the interface has received the command s that the interface has successfully begun executing the command s or that the interface has finished executing the command s . Thus we have the following series of events The controller issues a command or set of commands to the interface the controller receives an acknowledgement or multiple acknowledgements one for each command from the interface and only then does the controller issue a second command or set of commands to the interface .

In another embodiment the controller sends a command or set of commands to the interface in non blocking mode. In this embodiment after the controller has sent a command or set of commands to the interface the controller s execution continues even though it has not received an acknowledgement or multiple acknowledgements one for each command from the interface .

In one embodiment the interface executes a received command as soon as possible. In another embodiment a command includes a starting time that indicates when the command should be executed. In one embodiment a starting time is absolute such as 13 10 30 which represents 1 10 pm and 30 seconds. In another embodiment a starting time is relative and reflects the reverse priority of the command. For example a first command with a starting time of 40 will be executed after a second command with a starting time of 20 even if the first command was received before the second command.

In one embodiment the starting time represents the number of seconds or milliseconds to wait until executing the command. If the starting time is zero or negative or not provided then the command is executed as soon as possible. In one embodiment commands with the same priority are executed in their arrival order. In one embodiment the starting time is provided as an argument to the command.

Sensor Commands As described above a sensor command is used to determine or modify a sensor s state such as its configuration or sensed data. Different types of sensors can have different types of parameters each of which may or may not be configurable. In one embodiment the Read command specifies one or more variables e.g. sensor parameters for which status information should be returned. In another embodiment the Read command returns the entire set of sensor status information e.g. for all sensor parameters and for the sensed data .

System Commands As described above a system command is used to query or control system status. In one embodiment system status includes communication mode. Communication mode which can be either direct or continuous is described below.

In one embodiment the client and the server comprise software applications running on top of operating systems. Any programming or scripting language can be used to write the software applications such as C Java and Perl. Any operating system can be used such as Linux Mac OS from Apple Computer Inc. of Cupertino Calif. and Windows from Microsoft Corp. of Redmond Wash. In one embodiment the client and the server use different programming languages different software applications and or different operating systems. In order to preserve compatibility across operating systems in one embodiment the client and or the server are implemented using software libraries that can be ported to various hardware and software platforms. In particular proprietary software tools and libraries are not used.

In one example a sensor is a force plate such as the Type 9286AA force plate sold by Kistler Instrument Corporation of Amherst N.Y. An exemplary sensor driver is defined by deriving from an abstract base class HSensorTalkDriver. The driver implements its functionality in the form of functions either free functions or class methods that perform operations on parameters that represent the state of the sensor. The Appendix includes a description of the sensor s parameters.

The operations commands supported by the driver are registered and other initialization is performed by overriding the HSensorTalkDriver Start method. In one embodiment the initialization sequence is as follows 1 Registration of parameters. 2 Registration of parameter operation methods commands . 3 Initialization of the sensor. 4 Other driver initialization e.g. starting a sampling thread .

The server includes two interfaces a client interface and a driver interface and two buffers a command queue and a reply queue . The client interface enables the server to receive signals from and send signals to the client via the network . The driver interface enables the server to receive signals from and send signals to the set of sensor driver modules .

The network comprises any type of communication mechanism. If the client and the server are co located e.g. software applications running on the same machine the network can include local communication mechanisms such as shared memory. If the client and server are not co located the network can include remote communication mechanisms such as communications protocols running on top of wired or wireless connections. The communications protocols can include for example the Transmission Control Protocol Internet Protocol TCP IP suite the User Datagram Protocol UDP or the Data Distribution Service for Real time Systems Specification from Object Management Group Inc. of Needham Mass.

The communication mechanism regardless of its type supports a communication protocol. The communication protocol supports four command modes which will be described below. In one embodiment the communication protocol is based on network packages each of which includes a header portion and a payload portion. In this embodiment the client and server communicate by sending packages to each other via the network .

In a package sent from the server to the client the payload portion includes one or more replies where a reply is either a status signal or an error signal. In one embodiment each time a reply is placed in the reply queue the server creates a package containing that reply and sends the package to the client via the client interface . In another embodiment the server creates and sends packages periodically for example after a particular period of time has elapsed if any replies have been placed in the reply queue or after a particular number of replies have been placed in the reply queue .

In a package sent from the client to the server the payload portion includes one or more commands. The header portion is of a fixed length and includes the size of the payload.

The data in a package can be of any format such as binary plain text e.g. XML etc. In one embodiment the data is plain text that is parsed by the client and the server . In another embodiment the data is in binary format and the client and the server convert values within a payload to integers floats chars characters and or other integral types. In yet another embodiment values within a payload are stored in network byte order format to address byte ordering differences among little endian and big endian processors.

The network has various characteristics such as latency and bandwidth that will vary based on the communication mechanisms used. For example the network s latency will probably increase as the distance between the client and the server increases. Since the interface is a black box from the controller s perspective the controller works the same way regardless of the connection characteristics. This modularity is achieved by operating the interface in various communication modes which will be explained below. Thus the network is versatile enough to enable both remote and local sensor query and control.

Returning to the server the client interface reads packages received from the client . The one or more commands in each package payload are parsed. Then the commands are executed by the driver interface by sending signals to the sensor driver modules .

The commands are not necessarily executed in the order that they arrived. Instead they are stored in a command queue and scheduled for execution according to their starting times as described above.

If a sensor generates a reply signal in response to a command the reply signal is transmitted to the driver interface via the set of sensor driver modules . The reply signals are sent by the client interface to the client . The replies are not necessarily sent to the client in the order that they arrived. Instead they are stored in a reply queue . In one embodiment the replies in the reply queue are scheduled for transmission according to their insertion times into the queue.

The interface can operate in either of two communication modes direct or continuous. Before these modes are described consider how a signal generally flows through the interface . illustrates a how a signal flows through the elements shown in according to one embodiment of the invention. illustrates the following steps 1 The client sends a package containing a set of one or more commands to the server via the network . 2 The client interface receives the commands. 3 The commands are placed in the command queue . 4 The driver interface accesses a command from the command queue . 5 The driver interface sends a signal to the set of sensor driver modules . 6 The sensor driver modules cause the sensor to execute the command. 7 The sensor generates a reply signal which is sent to the driver modules . 8 The driver interface receives the reply signal from the driver modules . 9 The reply signal is placed in the reply queue . 10 The client interface accesses the reply signal from the reply queue . 11 The client interface sends the reply signal to the client via the network .

In direct mode the client sends packages to the server in blocking mode. In other words after the client has sent a package to the server containing a set of one or more commands step 1 the client s execution stops and resumes only when the client receives acknowledgements from the server for all of the commands in the package sent in step 11 . In particular the client does not send a new package to the server until it has received acknowledgments regarding all of the commands in the previous package. An acknowledgement can indicate for example that the server has received the command that the server has successfully begun executing the command or that the server has finished executing the command. Thus we have the following series of events The client issues a first set of one or more commands to the server the client receives acknowledgements from the server regarding all of the commands in the first set and only then does the client issue a second set of commands to the server . Note that in direct mode if the network is slow during step 1 step 11 or both this will increase the amount of time between each command set issuance by the client .

In one embodiment in direct mode once a connection has been established between the client and the server the client and the server synchronize their clocks. Then the client starts accepting signals e.g. API function calls from the controller to query or control the sensor. When an API function call is received the client creates a network package that includes one or more commands to be executed by the sensor. Each command is tagged with a unique identifier and the package is sent to the server via the network . The client s execution halts inside the API function call until the client receives from the server acknowledgements regarding all of the commands in the sent package. In one embodiment a time out mechanism is present so that an API function call can return even if the server crashes or the network breaks down.

The server receives the network package from the client . The client interface parses the package payload and places the one or more commands into the command queue . Commands with starting times of zero or a negative number will be executed before commands with positive starting times as described above. Thus in direct mode the transmission and execution of these types of commands follows a hand shake model.

In direct mode if the client s clock and the server s clock have been synchronized the server generally executes the command when its clock is equal to the command s starting time. However if the clocks have not been synchronized the server does not execute the command at this time. Instead the server determines the time offset between its clock and the client s clock and executes the command when its clock is equal to the sum of the time offset and the command s starting time.

Sometimes the server can fall behind in executing commands. In one embodiment the server does not execute a particular command even if the server s clock has reached the appropriate time unless commands that were supposed to precede the particular command have already been executed. For example the driver interface verifies that the starting time of the command with the highest priority has passed with respect to the server clock.

In continuous mode the client sends packages to the server in non blocking mode. In other words after the client has sent a package to the server the client s execution continues even though it has not received an acknowledgement from the server .

In blocking mode the client waits to receive the one or more reply signals sent in step 11 before it issues the next command or set of commands. Thus replies to all the commands in one package will arrive at the client prior to replies to commands in a subsequent package. In other words if the client issues a first package with a single command and then after receiving a reply a second package with a new command it will always receive the reply to the first command before receiving the reply to the second command. In non blocking mode the client does not wait to receive the reply signal before it issues the next command. Thus replies will not necessarily arrive at the client in the same order that the associated commands were issued. In other words if the client issues a first command and then a second command it might receive a reply to the second command and then a reply to the first command.

There can be many reasons why the replies arrive in a different order. One reason is that the commands might have different priorities so that they are executed in a different order by the server specifically the driver interface . Another reason is that the commands might require different amounts of time in order to generate a reply.

In one embodiment in order to handle replies received out of order the client includes a reply cache not shown that stores replies received from the server . The reply cache can include for example a dictionary data structure or a binary search tree such as a red black tree . For a dictionary the element keys are the original commands for which the server generated a reply. In one embodiment an element key is the unique identifier that was tagged to the command by the client . The client can periodically query the reply cache to determine whether the reply to a particular command has been received. In one embodiment the dictionary data structure is implemented as a hash map such as the hash multi map described in the C Standard Template Library part of the C Standard Library a standard managed by the International Organization for Standardization ISO and the International Electrotechnical Commission IEC .

In streaming mode which is a particular type of continuous mode one command received from a client can cause a server to periodically instruct the set of sensor driver modules to re execute the same command e.g. via the setPeriodicPublishing operation . In one embodiment the server accomplishes this via a specialized query command that is re inserted into the command queue after it has been removed in order to be read and executed . For example a client transmits in streaming mode a query command for a sensor s output i.e. sensed data and an associated publishing rate. The publishing rate specifies how often the server should instruct the set of sensor driver modules via the driver interface to execute the query command. The server inserts into the command queue a query command regarding the sensor s data. After the server has removed the query command from the queue in order to read it and instruct the set of sensor driver modules a copy of the query command is created and reinserted into the command queue with a priority that has been increased by an amount inversely proportional to the publishing rate. Thus the query command regenerates itself for future execution by the driver interface . The regeneration process stops once the server has received a client request to cancel the streaming.

Recall that one exemplary parameter of a sensor is how often the sensor senses data e.g. once per second or after every 10 samples called a fundamental frequency . Although a sensor might support multiple fundamental frequencies some of the higher frequencies might be possible only if the sensor processes data off line. In one embodiment the server signals the sensor driver module to use buffering to enable a higher fundamental frequency for a sensor that has limited data processing capabilities or low bandwidth communication to the server . In this embodiment called batch mode a sensor generates data at a high frequency but the data is first stored in a local memory the batch . This data is then read by the server and transmitted to the client according to the desired publishing rate.

Batch mode which is another particular type of continuous mode will also be described below in conjunction with composite sensors.

Multiple controllers The interface described above with respect to can also be used in a system where multiple controllers query and or control one sensor. illustrates a block diagram of a system for enabling multiple higher level software applications to query and control a sensor through a generic interface according to one embodiment of the invention. The system includes three controllers A B C an interface and a set of sensor driver modules . The system in is similar to the system in except that the system in includes multiple controllers instead of just one. Although the illustrated embodiment shows three controllers any number of controllers can be used.

The controllers A B C in are similar to the controller in . In one embodiment a controller is a software application used to query and control a sensor. In one embodiment each controller runs on a different piece of hardware. In another embodiment multiple controllers run on the same piece of hardware.

The interface in includes three clients A B C a server and a network . The interface in is similar to the interface in except that the interface in includes three clients instead of just one. Although the illustrated embodiment shows three clients any number of clients can be used. In one embodiment the number of clients in the interface is equal to the number of controllers in the system .

When a system includes multiple controllers the controllers can potentially interfere with each other s operation. For example one controller A can issue a control command to the sensor to sample data at one rate while another controller B can simultaneously issue a control command to the sensor to sample data at a different rate. In one embodiment in order to prevent interference between controllers a locking mechanism is used to control access to a sensor by various controllers .

Note that in general interference occurs only when multiple controllers are issuing control commands that seek to simultaneously affect the same sensor and sensor parameter . As discussed above control commands can change a sensor s state and include sensor commands and system commands that set system status while query commands cannot change a sensor s state and include sensor commands and system commands that query system status. Interference generally does not occur when 1 the commands are query commands 2 the commands do not seek to affect the sensor simultaneously or 3 the commands do not seek to affect the same sensor or sensor parameter .

Multiple sets of drivers The interface described above with respect to can also be used in a system where one controller queries and or controls multiple sets of sensor drivers . illustrates a block diagram of a system for enabling a higher level software application to query and control multiple sets of sensor drivers through a generic interface according to one embodiment of the invention. The system includes a controller an interface and three sets of sensor driver modules A B C. The system in is similar to the system in except that the system in includes multiple sets of sensor driver modules instead of just one. Although the illustrated embodiment shows three sets of sensor driver modules any number of sets of sensor driver modules can be used.

The illustrated embodiment can be used for example to query and or control a modular sensor. A modular sensor is a sensor that is made of other sensors. One example of a modular sensor is a device that can sense both temperature and humidity. Another example is a device that includes two image sensors such as cameras . This second example will be discussed further below.

The interface in includes one client three servers A B C and a network . The interface in is similar to the interface in except that the interface in includes three servers instead of just one. Although the illustrated embodiment shows three servers any number of servers can be used. In one embodiment the number of servers in the interface is equal to the number of sets of sensor driver modules in the system .

The sets of sensor driver modules in are similar to the set of sensor driver modules in . In one embodiment each set of sensor driver modules in is configured to query and or control a different sensor or a different sensor of a modular sensor . For example one set of sensor driver modules queries or controls an image sensor while another set of sensor driver modules queries or controls a force sensor.

Note that the functionalities of a modular sensor can be greater than the sum of its parts. That is a modular sensor can have additional functionalities above and beyond the functionalities of each of its component sensors. For example consider a modular sensor that includes two image sensors each of which can generate a two dimensional 2D image. Individually each image sensor can generate a 2D image of a scene. Together however they can generate a stereo image of the scene assuming of course that they are pointed in the same direction . Specifically the outputs of the two 2D sensors can be combined to generate a stereo image. Another example of a modular sensor includes one image sensor that can generate a two dimensional 2D image and one image sensor that can determine depth.

In order to use the system of to obtain a stereo image or other composite data the controller needs to coordinate the multiple sets of sensor driver modules . The controller might also need to perform some calculations using data obtained from the sensors. The interface described above with respect to can also be used to create a composite sensor that hides this complexity from the controller by simulating the existence of a single sensor that generates the composite data.

One example of a composite sensor includes multiple image sensors each of which generates a 2D image. The composite sensor uses the 2D images to determine the visual hull of an object and makes this data available as sensor data. A visual hull of an object is the largest volume in which the object can reside that produces the same silhouette as the object itself for all views outside the object. An image sensor s view of an object is a silhouette that sweeps out a cone in three dimensional space. The visual hull of the object is the intersection of several silhouette cones of the object. The silhouette cones represent different views of the object as seen from different locations. The visual hull of an object is guaranteed by definition to fully enclose the object.

Techniques for generating visual hulls include volume intersection and shape from silhouette. In one embodiment for each 2D image one silhouette image is determined. Any of several methods can be used to determine the silhouette image such as background subtraction motion detection and use of depth information. Silhouette cones are determined based on the silhouette images. The intersection of the silhouette cones represents the visual hull. Visual hulls and methods of generating them are known to those of ordinary skill in the art and are further described in The Visual Hull Concept for Silhouette Based Image Understanding by A. Laurentini IEEE Transactions on Pattern Analysis and Machine Intelligence 16 2 February 1994 which is hereby incorporated by reference.

A composite sensor consumes data produced by the sensors that it contains. Ideally the composite sensor and the contained sensors would have the same fundamental frequency rate of data throughput . For example a visual hull sensor would have the same fundamental frequency as the image sensors that it contains. Unfortunately the fundamental frequency of a composite sensor is almost always lower than the fundamental frequency of a sensor within the composite sensor due to computation delay.

Note that the visual hull composite sensor described above performs various computations. For example the composite sensor determines a silhouette image for each 2D image generated by an image sensor. The composite sensor also determines silhouette cones based on the silhouette images and intersects these cones to determine the visual hull. This computation especially the cone intersection can take a significant amount of time. Although each image sensor within a visual hull composite sensor might be able to generate 100 2D images per second 100 Hz the fundamental frequency of the composite sensor might be only 10 visual hulls per second 10 Hz .

In one embodiment batch mode is used to implement a higher fundamental frequency for a composite sensor with limited data processing capabilities. For example a sensor within the composite sensor generates data at its fundamental frequency. This data is used by the internal controller A to perform various calculations and generate composite data at the composite sensor s fundamental frequency which will be lower than the internal sensor s fundamental frequency if the composite sensor s data processing capabilities are limited.

In batch mode the external interface B signals the set of sensor driver modules D to process a data batch. In one embodiment the internal controller A buffers the data from the internal sensors before it uses this data to generate composite data. Once the batch of composite data has been generated it is transmitted to the external interface B at the desired publishing rate which is higher than the composite sensor s fundamental frequency under continuous mode operation. For example the desired publishing rate can be equal to the internal sensor s fundamental frequency. Thus in batch mode there is a time delay between when a sensor within a composite sensor reports its data and when the composite sensor reports its composite data. However the external controller B will see a data rate equal to the internal sensor s fundamental frequency rather than the slower composite sensor s rate.

Recall that a composite sensor hides complexity from a controller by simulating the existence of a single sensor that generates composite data. The composite sensors described above used multiple sensors. A different type of composite sensor uses a sensor and a motor. For example consider a telescope which is a sensor with various capabilities. If the telescope is connected to a base that can be mechanically positioned the telescope can be moved by issuing commands to its mechanical base which gives the telescope additional capabilities. In one embodiment a composite sensor is used to represent the telescope with its additional capabilities enabled the by movable base. Another example of a composite sensor is a document camera e.g. a camera located above a table that points downwards at the table in order to capture documents on the table that is connected to a base that can be mechanically positioned in order to view different areas of a table and documents located therein.

The motion interface enables the controller A to control a motor via a set of motion driver modules similar to how the interface A enables the controller A to query and control a sensor via a set of sensor driver modules A. The motion interface and the set of motion driver modules are further described in the following U.S. utility patent application which is hereby incorporated by reference Ser. No. 11 296 174 filed on Dec. 6 2005 entitled Interface for Robot Motion Control. In that patent application the interface represents the motion interface and the set of robot driver modules represents the set of motion driver modules .

Returning to of the present application the API of the interface B enables the controller B to issue commands for composite sensor data while shielding the controller B from the complexity of the set of sensor driver modules A and the set of motion driver modules . In this way one controller B can issue a command for composite data and the other controller A can generate the composite data by using the set of sensor driver modules A and the set of motion driver modules and possibly performing additional computation. In this embodiment the controller B queries and controls the composite sensor via the interface B and the set of sensor driver modules B.

Note that while and described various systems that included multiple controllers multiple sets of sensor driver modules a first type of composite sensor and a second type of composite sensor respectively these systems can be combined to form additional types of systems. For example an additional controller can be added to the system of or the system of . As another example an additional set of sensor driver modules can be added to the system of or the system of .

Although the invention has been described in considerable detail with reference to certain embodiments thereof other embodiments are possible as will be understood to those skilled in the art.

 14 Mx top Force plate moment about top plate surface x axis Mx Fy SensorAxisOffset z0 in Newton meters Nm 

 15 My top Force plate moment about top plate surface y axis My Fx SensorAxisOffset z0 in Newton meters Nm 

 16 Mz Force plate moment about z axis SensorAxisOffset x Fx12 Fx34 SensorAxisOffset y Fy14 Fx23 in Newton meters Nm 

