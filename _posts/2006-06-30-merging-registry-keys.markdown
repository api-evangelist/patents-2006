---

title: Merging registry keys
abstract: Two or more separate physical Registry directories are presented as a single (virtual) Registry directory to an application running in a controlled execution environment called a silo. All of the operations normally available to be performed on the Registry directory can be performed on the merge directory, however, the operating system controls the level of access to the keys in the merge directory. The operating system provides the merged view of the Registry directories by a Registry filter driver. The Registry filter model provides a single callback with a notification code indicating the reason the callback was called. The types of notifications which trigger the special processing include: enumeration of a key, enumeration of the value of a key, query a key, close a key, delete a key, create or open a key or rename a key.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08245035&OS=08245035&RS=08245035
owner: Microsoft Corporation
number: 08245035
owner_city: Redmond
owner_country: US
publication_date: 20060630
---
The Registry is a central hierarchical database used in some operating systems including Microsoft WINDOWS 9x WINDOWS CE WINDOWS NT WINDOWS 2000 and WINDOWS XP. The Registry is used to store information required to configure the system for one or more users applications and hardware devices. The Registry includes information that WINDOWS continually references during operation such as profiles for each user the applications installed on the computer the types of documents that each application can create property sheet settings for folders and application icons what hardware exists on the system the ports that are being used and so on. At times it may be desirable to present a logical view of a registry key that is made up of two or more physical keys.

Two or more groups of separate physical Registry keys are presented as a single virtual Registry directory to an application running in a controlled execution environment called a silo. All of the operations normally available to be performed on the Registry directory can be performed on the merge Registry however the operating system controls the level of access to the keys in the merge Registry. The operating system provides the merged view of the Registry keys by a Registry filter driver or other kernel level operating system code. The Registry filter model provides a single callback with a notification code indicating the reason the callback was called. The callback handler may be implemented as a large switch statement with code to handle various notifications. The types of notifications which trigger the special processing include enumeration of children keys sub keys enumeration of the value of a key query a key query a value set a value on a key modify security on a key load a key close a key create or open a key delete a key or rename a key.

At times it may be desirable to present a logical view of a registry key that is made up of two or more physical keys. For example it might be desirable to provide a merge between an existing registry key and a new empty key. New registry keys and values created by the process would go into the initially empty key but all the state from the existing registry would be visible to the process. This allows a process to store its private changes in a separate key and not modify a shared public portion of the registry. Typically however current known operating systems provide all processes with the same view of the Registry keys.

In many systems limited points of containment in the system exist at the operating system process level and at the machine boundary of the operating system itself but in between these levels security controls such as Access Control Lists ACLs and privileges associated with the identity of the user running the application are used to control process access to files and directories. There are a number of drawbacks associated with this model. Because access to system resources is associated with the identity of the user running the application rather than with the application itself the application may have access to files and directories that the application does not need as demonstrated by the example above. Because multiple applications may be able to modify the same file incompatibility between applications can result. Security problems may also arise as one application may maliciously or accidentally interfere with the operation of another application. There are a number of other well known problems as well.

An intra operating system isolation containment mechanism called herein a silo provides for the grouping and isolation of processes running on a single computer using a single instance of the operating system. A single instance of the operating system divides the processing space for the system into multiple side by side and or nested execution environments silos enabling the controlled sharing of some Registry keys and restriction of access to other keys. The operating system controls Registry key sharing and access by creating different views of the Registry for each silo. The view appears to processes running in the silo to be a single directory which is the union of two or more sets of contributing keys. That is the keys available to an application depend on which silo the application is running in and the Registry that an application running in a silo sees is created by apparently merging two or more sets of keys. The single OS image serving the computer or computer system thus provides a different view of the Registry so as to control which process group of processes application or group of applications can use which keys and whether the application can read or read and write keys. Access to keys and the degree of access to keys is therefore directly associated with or based on the silo that the process application group of processes or group of applications is placed in and is not determined by user privileges.

Merge directory support for the Registry may be implemented via a Registry filter driver or other kernel level operating system code. The Registry filter model provides in some embodiments a single callback with a notification code indicating the reason the callback was called. The callback handler thus in some embodiments is a large switch statement with code to handle various notifications. Notifications receiving special processing include enumeration of Registry key enumeration of the value of a Registry key query information concerning a Registry key query a value set a value on a key modify security on a key load a key close key create key and rename key. A create key notification is received when a caller wants to create or open a registry key. The driver examines the name of the key being accessed and determines if special handling is required. If the process issuing the request is not in a silo no special processing is required. If the process issuing the request is in a silo the merge key metadata for the silo issuing the request is retrieved. If the key name being accessed is within a merge key special processing is performed. If the key exists in the private location silo specific Registry keys the private location is used when forwarding the request. If the key does not exist in the private location the public location is examined for the key. If the key exists in the public location global Registry keys the public location is used when forwarding the request. If the key does not exist in the public or private location information is returned so that either an error can be returned i.e. an error indicating failure to open a key which does not exist or the key can be created. If the key name being accessed is not within a merge key no special processing is performed. If special handling was performed metadata is associated with the key.

If metadata were associated with a request during a create key operation and the request to open the key was successful the metadata is attached to the key. When a key is closed any metadata associated with the key is deleted. When a client application tries to enumerate the sub key values for an open key a special handler is invoked. Any metadata associated with the key is retrieved. If metadata is found and the metadata indicates that the key is a merge key the contents of the list of keys which exist in each of the contributing keys is returned to the caller.

The registry API for querying keys in some embodiments is implemented by passing in an index and returning the result. For a given index the contents of the contributing keys are considered what should be returned for that index is determined and is returned. The current location in each of the contributing directories during the enumeration is tracked and the appropriate next value is returned each time. That is all the results from one contributing key are returned. Results for subsequent keys are returned if the same key name has not already been enumerated. If the caller looks at an index below the current index the internally cached index s are reset and processing is restarted. Sub keys in a key or values in a key can be enumerated. Sub keys or values are returned to the caller as requested. If a request is received requesting the name of a key the silo relative name rather than the physical name of the key in the registry is returned. Thus if a request to retrieve key information is received the information is retrieved and the requested information is updated so that it matches the information the caller expects. For example suppose a name of a key is requested. The name of the key is retrieved and the name that is sent back to the caller is updated so that it matches the name the caller used to open the key keeping the illusion that all of the contents of the contributing keys are in the same merge key. If a key is being renamed the new name or new location is validated based on the merge directory view exposed to the application. Thus if the user wants to move the key to a new location the new location is updated based on the silo s view of the namespace.

Although not required the invention can be implemented via an application programming interface API for use by a developer and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . A graphics interface such as Northbridge may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU or host processing unit and assumes responsibility for accelerated graphics port AGP communications. One or more graphics processing units GPUs may communicate with graphics interface . In this regard GPUs generally include on chip memory storage such as register storage and GPUs communicate with a video memory . GPUs however are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

One of ordinary skill in the art can appreciate that a computer or other client device can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

The operating system monitors registry access requests made by a process running in a silo. Multiple silos may exist on the computer or in the computer system at the same time. Multiple processes may execute within each silo. A single operating system image creates the silos and creates and monitors all the processes in all the silos. A silo specific view of a registry key is created by the operating system by an apparent merging of two or more physical backing stores registry keys together into what appears to the silo to be a single key. That is two or more separate registry keys may be exposed to a silo and the processes running within the silo as a single key. One or more of the physical backing stores may be used to build a portion of the silo specific view for one or more of the silos.

A silo may be used to create an isolated execution environment so that resources associated with one silo are available to processes running within that silo but are not accessible to other silos running on the computer or on other computers in the computer system or computer network. For example if silo were an isolated execution environment a resource not shown available to process running in silo would be unavailable to a process such as process running in a second silo silo . A second process running in silo such as process would however have access to that resource. Similarly a resource available to processes and would be unavailable to processes and running in silo .

Alternatively in accordance with embodiments of the invention a silo may be used to create a semi isolated or controlled execution environment in which some resources are shared and some resources are not shared or in which some portions of a resource are shared and other portions of the resource are not shared. One such contemplated resource is the Registry. For example in silo one or more processes such as process and may be running and have access to a Registry. In some embodiments of the invention the Registry is a virtual merged directory of keys wherein the virtual merge Registry although appearing to processes and as a single physical directory is actually a virtual view of the union of two or more sets of Registry keys created by the operating system using callbacks to perform special processing for certain types of operations under certain circumstances. The view created by the operating system may comprise the union of the public keys of the Registry and private or local to the silo keys merged together to create the virtual merge Registry. In some embodiments of the invention duplicate keys are collapsed with the values of the private keys being used when there is a duplicate key. For example one of the keys in the public Registry is registry machine software. The key may for example be a location where an application can write machine global state. It is desirable to allow an application running in a silo to write its own state in its own copy of registry machine software i.e. registry machine silo0000software but to enable the silo to share the state in the public version of registry machine software. In this way the silo is able to see any changes made in the external system but can make its own changes or write new keys which will only exist in its private location and thus will not affect the system external to the silo. Hence the Registry keys registry machine software and registry machine silo0000software are merged. The silo will see a key called registry machine software but its contents will be the combination of the physical registry machine software and registry machine silo0000software. Thus the merge Registry created by the operating system in some embodiments of the invention includes the value of the global keys while a private unshared portion of the key is associated with a particular silo e.g. with silo and may represent for example local or private keys for applications running in that silo. For example in a virtual merge key associated with silo includes a shareable portion derived from the value of the global key and an unshareable private portion derived from the value of a local key e.g. a private unshared key associated with silo . A virtual merge Registry associated with silo includes a shareable portion derived from the value of a global key and an unshareable portion derived from the value of a local key e.g. a private unshared key associated with silo . In some embodiments of the invention the shareable portion of the key is read only while the private unshared portion of the key is read write although it will be appreciated that the contemplated invention is not so limited. That is the private portion of the virtual merge Registry keys may be read only or read write or may include portions which are read only or read write. Similarly the shareable portion of the virtual merge Registry keys may be read only or read write or may include portions which are only read only or read write. Moreover it will be appreciated that the invention as contemplated is not limited to merging two values or two sets of keys. Any number of keys n keys may be merged to create the virtual merge Registry. The virtual merge Registry in some embodiments of the invention is not persisted on permanent storage or created per se in memory but is dynamically deduced by the operating system as required by monitoring Registry key access requests and performing special processing associated with the type of access request as described more fully below.

Thus it will be appreciated that as more than one silo may exist on a computer or in a computer system at one time more than one view of the Registry may also exist at one time that is there is a one to one correspondence between silo and virtual merge Registry but any number of silos and merge views may exist at any one time on a particular computer or computer system. Moreover a portion of each key in the virtual merge Registry may include a shareable portion which may or may not be the same for all silos in the computer system and may or may not be identical to physical backing Registry . In some embodiments of the invention all of the applications or processes running within all the silos in the system share a single shareable portion of the silo s merge Registry which may or may not exist on the particular computer on which the silo is running. Moreover the physical directory which backs a shareable or unshareable portion of the merge Registry may exist on removable media such as a removable disk CD ROM USB key etc. Similarly the physical backing Registry may reside on a remote system. The same is true for the private or unshareable portion of the keys of the merge Registry and its backing store.

In some embodiments of the invention the mechanism in the operating system which creates the merged view of the Registry e.g. merged keys and is a filter driver which is able to insert itself into the code paths of operations by registering callbacks. In some embodiments of the invention the callbacks registered for include RegNtPreCreateKeyEx Ex RegNtPostCreateKeyEx Ex RegNtPreQueryKey RegNtPreEnumerateKey RegNtPreEnumerateValueKey RegNtPreRenameKey and RegNtPreKeyHandleClose although it will be appreciated that other callbacks may be registered. In some embodiments of the invention the operations for which special processing e.g. via callbacks is performed are enumeration open create rename and close operations for Registry keys. For example an enumeration operation may be associated with RegNtPreEnumerateKey and RegNtPreEnumerateValueKey callbacks open and create with RegNtPreCreateKeyEx Ex RegNtPostCreateKeyEx Ex close with a RegNtPreKeyHandleClose callback and rename with a RegNtPreRenameKey callback. In some embodiments when a Registry key access request is sent from a process the operating system monitors the request via the callbacks and if the operation is one of those for which special processing is to occur performs the special processing. For example in operating system may monitor Registry key access requests such as request initiated by process in silo and perform special processing to create virtual merge Registry from private keys associated with silo and public keys . The portions of the keys in virtual merge Registry deriving from private keys are represented by virtual private keys and the portions of virtual merge Registry deriving from public keys are represented by virtual public keys

Each of the contributing backing store keys may be associated with a rank e.g. in private backing store keys are associated with rank public keys backing store are associated with rank . Rank in some embodiments is used as a tie breaker when required. For example if a key access e.g. open enumerate etc. is requested and the indicated value exists in two sets of keys under the same name the rank of the contributing set may be used to determine which value is exposed to the requester that is the value of the key in the set of keys having the highest rank is exposed to the requester as for example the writable portion of the key . Similarly if a given name is a key in one contributing directory and the same name is a sub directory in another contributing set of keys the entry in the set having the highest rank is exposed to the requestor in some embodiments.

For example a Registry key enumeration in some embodiments is the union of all the keys from all the contributing sets of keys. If the same name exists in more than one of the contributing sets the rank of each of the contributing sets is used to determine which set s version of the value should be exposed. When creating a key if the key does not already exist in any of the contributing sets it will be created in the set with the highest rank. When renaming a key each of the contributing sets of keys is queried to determine that the new name is not already in use and if it is not then the key will be renamed to the new name.

For example at the operating system may determine that the key access request is an operation that opens or creates a key . is a flow diagram of the processing that may then occur. When an open or create request is sent to a volume on which a merge Registry exists a create callback e.g. RegNtPreCreateKeyEx Ex is invoked which enables a filter driver of the operating system to examine the request to determine if special processing is required. When an open or create operation is invoked an absolute path name or a path name relative to an existing open key is provided. When a relative open is used name parsing begins at the registry node referenced by the relative handle. In the case of an absolute open the 10 Manager of the operating system parses the name the object manager resolves a portion of the name that leads to a device object and passes the unresolved balance of the name the portion that has not yet been resolved back to the I O Manager along with a pointer to the device object it located. Special processing is required when the portion of the key referred to is the silo view instead of the global portion. As used herein performing an operation using the silo view means that the name of the key is interpreted within the context of the silo s virtual merged Registry instead of within the context of the normal system file system directory.

At if the open is an absolute open not a relative open and the caller is in a silo processing continues at . In some embodiments of the invention the operating system determines if the open or create key is a relative or an absolute open create by looking at several fields in the access request. If the access request includes only a key name and the thread originating the request does not belong to a process running in a silo the request is considered to be an absolute open. The information stored in the request can be used to retrieve metadata associated with the key .

Thus at the name of the key being accessed is examined within the context of the silo. A new key object is created using the silo view whenever the key referenced in the request was originally opened within a silo. Because all access requests to the key object are filtered two or more backing objects may be accessed to provide the silo view. The key is also opened using the silo view whenever a relative open instead of an absolute open is used. In some embodiments of the invention if a field in the request representing an existing open key is not null the request is considered to be a relative request. If at the caller is not in a silo or if the original key was not opened in a silo then processing proceeds as normal . If the request uses an absolute name that is names the key is explicitly referenced using a path name and the open key field of the request is null the operating system determines if the process initiating the request the caller is in a silo or not. In some embodiments of the invention the operating system determines if the caller is in a silo by determining if the thread originating the access request is in a silo. Alternatively in some embodiments the operating system may determine if the caller is in a silo by examining the access request which may be tagged with a silo identifier if the request originated from a caller in a silo. If the caller is in a silo the key is opened using the silo view and the private value is returned.

Thus if the key referenced in the request was not originally opened in a silo or if the request is an absolute open and the caller is not in a silo processing continues at . At if the operation is to be processed using the silo view the name of the key in the request is examined and is interpreted within the context of the silo. In some embodiments of the invention a silo is provided a view of the registry having the same hierarchy as the underlying machine that is the silo s view appears to have the same hierarchy as the infrastructure or system silo . For example if registry machine software exists in the infrastructure registry machine software is exposed within the silo. This may be done so that applications which expect this hierarchy will find it. However the files that back the hierarchy may be changed so that registry machine software within the silo is actually a merge of the physical registry machine software and registry machine silo000software the silo specific registry . Normal error processing occurs. That is if for example in an open operation the key identified by the name in the access request is searched for but is not found in any of the target keys an error message is returned. If a sub key is found in an appropriate key an open key is returned to the caller. Metadata may be attached before it is returned to the caller for a successful open or create. If the key is not found the key is created or an error message is returned. At the merge Registry key metadata for the silo is retrieved. At if the requested name is not found in the merge Registry processing proceeds as normal . For example an error message may be returned stating that the key is not found. At if the requested name is found in the merge Registry view information is returned so that it can be determined whether the named key is to be created or opened . In some operating systems the create operation can be used both to open and to create keys. If the requested operation is an open key at i.e. the request is attempting to access an existing key the operating system checks the private contributing key first by determining if the key exists in the private unshareable portion of the merge Registry. At if the operating system determines that the key does not exist in the private portion of the virtual merge Registry the public portion of the merge Registry is examined. If the key does not exist in the public portion of the merge Registry an error message is returned. If the key is found in the merge Registry the open key is returned. If at it is determined that the key is to be created i.e. the request is a create key request at the operating system checks the public location to make sure that the key does not already exist in the public portion of the merge Registry. If it does an error results. If it does not the key is created in the private portion of the merge Registry metadata is associated with the key and the created key is returned to the caller along with the metadata.

In some embodiments of the invention the metadata will be attached to the open key during RegNtPrePostCreate.

Referring again to there are several different types of enumeration requests. If the operating system detects an enumeration request for the children of a key a list of keys are returned. At if the operating system detects an enumerate key operation at first the operating system determines if there is metadata associated with the key . In some embodiments of the invention the operating system determines whether the Registry is merge view from the metadata. In either case if the Registry is a merge view the results of both keys merged together is returned . If the Registry is not a merge view normal processing is performed. If the operation is a request for the value of a key the values of the keys are returned . Global and private values for the key are merged.

If the operation is a query such as a request for the name or other information about the key the physical name of the key is retrieved at and the name is updated if necessary to reflect the proper name for the requester. In some instances if a request for the name of a key is received or a request for other information about a key is received the silo relative name rather than the global name of the key is returned.

If the operation encountered is a rename key the operating system must ensure that the new name the name to which the key is going to be renamed which is a silo relative name is translated into a global name before the underlying file system sees it so that the file system renames the key properly. If at the operation is determined to be a close the RegNtPreKeyHandleClose callback is invoked. At any metadata associated with the key being closed is deleted. It will be appreciated that one or more of the above listed actions may be optional or skipped and that the actions may proceed in a sequence other than that depicted in .

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects of the present invention e.g. through the use of a data processing API or the like are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. Therefore the present invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

