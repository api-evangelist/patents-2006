---

title: Systems and methods of reverse lookup
abstract: One embodiment includes a process for reverse lookups using a map structure and a structure being referenced by the map structure that comprises receiving a structure that comprises a reference to the structure and a reverse lookup hint; locating one or more entries in a map structure that correspond to the reverse lookup hint; and identifying at least one matching entry in the map structure that corresponds to the structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07590652&OS=07590652&RS=07590652
owner: Isilon Systems, Inc.
number: 07590652
owner_city: Seattle
owner_country: US
publication_date: 20060818
---
The increase in the amount of data stored on digital computing systems has resulted in complex storage systems with data often distributed over multiple physical nodes or storage devices. One method for organizing data has been to store them in files. These files are then grouped into directories with some directories including other directories and or files. Typically files and directories are assigned unique identifiers within the file system. In most systems files and directories are arranged in order to optimize the lookup of a unique identifier given the particular path or name of the file or directory such as for a downward lookup .

Examples of mapping structures used to organize files and directories in this manner include B trees B trees Patricia tries red black trees and flat file directories. However these types of systems often make the lookup of the path in response to the unique identifier computationally expensive because an examination of many more nodes is required in order to identify the desired file or directory such as for a reverse lookup .

Because of the foregoing challenges and limitations there is a need to provide a more efficient manner in which to perform a reverse lookup in a map data structure.

The embodiments disclosed herein generally relate to performing a reverse lookup in a map data structure.

In one embodiment a process for reverse lookups between a map structure and a structure being referenced by the map structure comprises receiving a structure that includes a reference to the structure and a reverse lookup hint locating one or more entries in a map structure that correspond to the reverse lookup hint and identifying at least one matching entry in the map structure that corresponds to the structure.

In another embodiment a method for reverse lookups between a map structure and a structure being referenced by the map structure comprises storing in a map structure at least one reference to a structure and a name associated with the structure and storing in the structure the at least one reference and a reverse lookup hint to locate the reference in the map structure.

In yet another embodiment a data structure for reverse lookups comprises a reference to a data structure and a reverse lookup hint to locate one or more entries in a map structure that correspond to the data structure the one or more entries including the reference to the data structure and a name corresponding to the data structure.

In a further embodiment a distributed file system configured to perform reverse lookups between a map structure and a structure being referenced by the map structure comprising an at least one storage device configured to store data. The data comprises a map structure which comprises a reference to a structure and at least one name associated with the structure and the structure which comprises the reference and a reverse lookup hint that is used to locate the reference to the structure in the map structure.

For purposes of summarizing this invention certain aspects advantages and novel features of the invention have been described herein. It is to be understood that not necessarily all such advantages may be achieved in accordance with any particular embodiment of the invention. Thus the invention may be embodied or carried out in a manner that achieves or optimizes one advantage or group of advantages as taught herein without necessarily achieving other advantages as may be taught or suggested herein.

Systems methods processes and data structures which represent one embodiment of an example application of the invention will now be described with reference to the drawings. Variations to the systems methods processes and data structures which represent other embodiments will also be described.

For purposes of illustration some embodiments will be described in the context of a distributed file system. Embodiments of a distributed file system suitable for accommodating reverse lookup requests are disclosed in U.S. patent application Ser. No. 10 007 003 titled SYSTEMS AND METHODS FOR PROVIDING A DISTRIBUTED FILE SYSTEM UTILIZING METADATA TO TRACK INFORMATION ABOUT DATA STORED THROUGHOUT THE SYSTEM filed Nov. 9 2001 which claims priority to Application No. 60 309 803 filed Aug. 3 2001 U.S. patent application Ser. No. 10 281 467 entitled SYSTEMS AND METHODS FOR PROVIDING A DISTRIBUTED FILE SYSTEM INCORPORATING A VIRTUAL HOT SPARE filed Oct. 25 2002 and U.S. patent application Ser. No. 10 714 326 entitled SYSTEMS AND METHODS FOR RESTRIPING FILES IN A DISTRIBUTED FILE SYSTEM filed Nov. 14 2003 which claims priority to Application No. 60 426 464 filed Nov. 14 2002 all of which are hereby incorporated by reference herein in their entirety.

In one embodiment of a distributed file system metadata structures also referred to as inodes are used to monitor and manipulate the files and directories within the system. An inode is a data structure that describes a file or directory and may be stored in a variety of locations including on disk and or in memory. The inode in memory may include a copy of the on disk data plus additional data used by the system including fields associated with the data structure.

Some of the figures and descriptions relate to an embodiment of the invention wherein the environment is that of a distributed file system. The present invention is not limited by the type of environment in which the systems methods structures and processes are used however and may be used in other environments such as for example other file systems other distributed systems the Internet the World Wide Web a private network for a hospital a broadcast network for a government agency an internal network of a corporate enterprise an Internet a local area network a wide area network a wired network a wireless network and so forth. It is also recognized that in other embodiments the systems methods structures and processes may be implemented as a single module and or implemented in conjunction with a variety of other modules and the like.

In one embodiment a user or client device is connected to a distributed file system comprised of one or more physical nodes for example storage devices . The data on each of the physical nodes are arranged according to inodes which store metadata about files and directories within the file system. Typically when a client device desires to access a specific file stored on the distributed file system the client device requests the file by its name or some other mutable identifier. Then the system performs a downward lookup in order to identify the inode that corresponds to the file.

As used herein a file is a collection of data stored in one unit under an inode or filename. A directory similar to a file is a collection of data stored in one unit under an inode or directory name. A directory however is a specialized collection of data regarding elements in a file system. In one embodiment a file system is organized in a tree like structure. Directories are organized like the branches of trees. Directories may begin with a root directory and or may include other branching directories. Files resemble the leaves or the fruit of the tree. Files typically do not include other elements in the file system such as files and directories. In other words files do not typically branch. Although in the illustrated embodiment an inode represents either a file or a directory in other embodiments an inode may include metadata for other elements in a distributed file system in other distributed systems in other file systems or other systems.

Some client devices may dispatch a listener that awaits event notifications on a particular inode. In one embodiment event notifications may be generated and received according to the systems and methods disclosed in U.S. patent application Ser. No. 11 396 282 titled SYSTEMS AND METHODS FOR NOTIFYING LISTENERS OF EVENTS and is hereby incorporated by reference in its entirety. For example the client may be a directory management application. When the directory management application opens a window on a particular directory it instantiates a listener on that directory. When another application such as a word processor creates a new file in that directory the event system notifies the listening application which updates the window to show the new file.

When an event notification system receives a notification on a particular inode it returns the unique identifier that corresponds to the inode. Thus in order to communicate the name or global path to a user or client application a reverse lookup is needed. It is also recognized that the need for a name associated with an inode may arise in a variety of other contexts.

The embodiments disclosed herein may be implemented on a file system that includes directories represented by a map data structure where each map data structure may include billions of entries. In some implementations the systems and methods structures and processes for a reverse lookup disclosed herein may dramatically reduce the time required to identify the name associated with files and directories and thereby improve overall system efficiency.

In a distributed file system comprises various physical nodes that communicate over a communication medium . In one embodiment the communication medium is the World Wide Web. In other embodiments as described above the distributed file system may be comprised of a direct hard wired connection between the physical nodes or any combination of communication types.

In the embodiment depicted the physical nodes are either interfaces such as a personal computer a mainframe terminal or a client application or data storage systems . It will be appreciated by one with ordinary skill in the art that the distributed file system may comprise one or a plurality of interfaces and one or a plurality of data storage systems. In some embodiments the interfaces may comprise data storage systems such as for example data storage systems and .

As used herein the word module refers to logic embodied in hardware or firmware or to a collection of software instructions possibly having entry and exit points written in a programming language such as for example C or C . A software module may be compiled and linked into an executable program installed in a dynamic link library or may be written in an interpreted programming language such as for example BASIC Perl or Python. It will be appreciated that software modules may be callable from other modules or from themselves and or may be invoked in response to detected events or interrupts. Software instructions may be embedded in firmware such as an EPROM. It will be further appreciated that hardware modules may be comprised of connected logic units such as gates and flip flops and or may be comprised of programmable units such as programmable gate arrays or processors. The modules described herein are preferably implemented as software modules but may be represented in hardware or firmware. Moreover although in some embodiments a module may be separately compiled in other embodiments a module may represent a subset of instructions of a separately compiled program and may not have an interface available to other logical program units.

In one embodiment the directory module assigns to each link between inodes a key. The key serves as a unique identifier within a particular directory map structure. When the processor receives an event notification related to an inode the processor communicates the relevant inode identifier or LIN to the reverse lookup module . The reverse lookup module accesses the storage device in order to efficiently perform the reverse lookup operation in the particular directory map structure and return the name associated with the link s to the inode.

The data structures stored in the storage devices correspond to by way of example only the inode arrangement depicted in . For each inode in the distributed file system metadata for the inodes are stored on at least one storage device . For example storage device stores metadata for inodes one three and five storage device stores metadata for inodes two four and six and storage device stores metadata for inodes seven eight and nine .

The data storage devices also store a mapping data structure for every inode that corresponds to a directory in the distributed file system . In the embodiments described herein the mapping structure is implemented using a B tree structure. It will be appreciated by one of ordinary skill in the art however that other data structures may be used such as for example B trees Patricia tries red black trees and flat file directories. In the depicted embodiment the number of B tree blocks stored for each directory inode depend on the number of links stored in the B tree and the height of the B tree depends upon the number of B tree blocks. For example as shown in and A C one block is stored in storage device for inode one because inode one stores two links and thus has a single level B tree three blocks are stored in storage device for inode two because inode two stores four links and has a two level B tree and three blocks are stored in storage device for inode three because inode three stores four links and thus has a two level B tree .

Data structures are collections of associated data elements such as a group or set of variables or parameters. In one embodiment a structure may be implemented as a C language struct. One skilled in the art will appreciate that many suitable data structures may be used.

While illustrates one embodiment of a reverse lookup operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as a value reference and or stored in an accessible memory location.

In one embodiment the data storage systems may run on a variety of computer systems such as for example a computer a server a smart storage unit a mobile telephone a handheld device an embedded device and so forth. In one embodiment the computer may be a general purpose computer using one or more microprocessors such as for example a Pentium processor a Pentium II processor a Pentium Pro processor a Pentium IV processor a Pentium D processor a Pentium Core processor an xx86 processor an 8051 processor a MIPS processor a Power PC processor a SPARC processor an Alpha processor and so forth. The computer may run a variety of operating systems that perform standard operating system functions such opening reading writing and closing a file. It is recognized that other operating systems may be used such as for example Microsoft Windows 3.X Microsoft Windows 98 Microsoft Windows 2000 Microsoft Windows NT Microsoft Windows CE Microsoft Windows ME Microsoft Windows XP Palm Pilot OS Apple MacOS Disk Operating System DOS UNIX IRIX Solaris SunOS FreeBSD Linux or IBM OS 2 operating systems.

Referring to the method for creating the key starts by receiving an identifier or name associated with a particular file or directory . Then a hash function is applied to the identifier so as to generate a hash value that is hereinafter referred to as the hint . In one embodiment the hash function is a MOD function applied to the sum of the ASCII values that correspond to the letters comprising the identifier. A mod function determines the hash value by first dividing the input by a fixed divisor and then assigning to the hash value the remainder. A mathematical representation of a MOD function is shown below Hash Value REM Hash Input Divisor 

For example if the number is used as the Divisor the following table illustrates an example of Hash Values that correspond to the following Hash Inputs 

As shown there is not a one to one correspondence between each Hash Value and each Hash Input. In other words more than one file or directory name may hash to the same Hash Value. The use of a hash function to provide the hint is advantageous. In particular it is preferable for a distributed file systems to store a key that comprises the hint rather than the name of a file or directory because the key is smaller than a filename and is of a fixed size. Additionally in other embodiments the hash function may use a different divisor such as 3 87 859 or 7 877. In yet other embodiments the hash function may be the same as or similar to those disclosed in Knuth D. The Art Of Computer Programming Vol. 3 Sorting and Searching Chap. 6.4 Addison Wesley 1973 which is hereby incorporated by reference in its entirety herein. In further embodiments the hint may be created using another function known to one with ordinary skill in the art of hash based data structures.

After the hint is created the method creates a key with a default number of zero . In the embodiment depicted in the key is represented by a binary number. In that embodiment the most significant bits are populated by the hint and the remaining least significant bits are populated by the sequence number . In this embodiment the key is represented by an eleven bit binary value. The hint is represented by a four bit binary value and the sequence number is represented by a seven bit binary value. Thus in step the key is initially created with the sequence number 0000000. 

In other embodiments the key hint and sequence number may be represented by more or fewer binary bits be represented by hexadecimal digits ASCII characters and so forth. In yet other embodiments the key may additionally be comprised of values other than and or in addition to those that correspond to the hint and sequence number. For ease of reference a specific key value will be referred to herein using the following convention Hint Sequence Number .

In step a lookup operation is performed to determine if another link from the parent has been assigned the same key as the one created in step . If no links have the same key as the one created in step the method returns the key in step before ending .

However if another link in the parent directory has the same key as the one created in step the sequence number is incremented in step . After incrementing the sequence number step is repeated to determine if another link in the parent directory has the new key . If one exists the sequence number is incremented until the key assigned to the link is a unique key within the parent directory .

For example suppose Files A B C and D are created in the recited order and are the first files created in a given directory. Also suppose that the links to Files A D correspond to Hash Values 2 6 2 and 2 respectively. For the link to File A the key is 2 0 because the Hash Value is 2 and no other files exist on the system with the same key. For the link to File B the key is 6 0 because the Hash Value is 6 and no other files exist on the system with the same key. For the link to File C the key will begin as 2 0 because the Hash Value is 2 and the sequence number is initialized to zero. However because the link to File A has the same key the sequence number will be incremented. Consequently the key assigned to the link to File C will be 2 1 because no other links from the parent directory have the same key. For the link to File D the key will begin as 2 0 because the Hash Value is 2 and the sequence number is initialized to zero. However because the link to File A has the same key the sequence number will be incremented such that the key is 2 1 . The system will then increment the sequence number again because the link to File C has the same key. Therefore the key 2 2 is assigned to the link to File D.

While illustrates one embodiment of a method for creating a key it is recognized that other embodiments may be used. For example in other embodiments a count can be stored for each potential hash value which tracks the number of links to files directories that have the same hash value such that a lookup of the count is performed. In another embodiment the key and or identifier may be stored in a memory location accessible by other modules such that the key does not have to be returned.

It is recognized that in other embodiments the key may be created without the use of a hash function. In yet other embodiments keys may be assigned without the use of a sequence number.

Inode one is the top most directory in the system and in the embodiment of a file system is referred to as the root directory. Inode one has two child inodes inodes two and three and six grandchild inodes inodes four through nine . Inode one will be referred to as the parent of inodes two and three and the grandparent of inodes four through nine .

As a parent inode inode one references its children. In the depicted example it references inode two via pointer and references inode three via pointer . The name associated with the link to inode two docs is noted alongside pointer . Also indicated is the reverse lookup hint associated with and derived from the name of the link to inode two . Accordingly the global path for inode two is docs . In one embodiment the metadata for an inode includes information about each of the inode s parent s . For example the metadata stores a Parent Count that indicates the LINs of each parent of the inode and the number of links to each parent. In some embodiments this information may include the inode s full path name s however storing and updating this information can be time consuming. Thus in some embodiments the inodes store information such as for example a reverse lookup hint that allows the system to determining the inode s path name s .

As used herein a reverse lookup hint is associated with each name of or synonymously each link to an inode. As described above the hint may be the hash value of the name of the corresponding file or directory. Thus there is a hint and a reverse lookup hint for each existing link to an inode. In some embodiments the reverse lookup hint may be one of the hints the hint plus a portion of the sequence number a portion of the hint the hint and the sequence number the key or an arbitrarily assigned value.

A reverse lookup hint is used to narrow the search range during reverse lookup operations. In one embodiment the reverse lookup hint refers to the hint associated with the first created link to an inode. That is if the link that corresponds to the reverse lookup hint is later destroyed the reverse lookup hint stored in the inode s metadata structure will nonetheless remain unchanged. In other embodiments however the reverse lookup hint may change in response to destroyed or newly created links. In yet other embodiments inodes may store reverse lookup hints associated with the last created link to the inode every link to the inode a subset of every link to the inode every parent of the inode or only some of the parents of the inode.

As indicated above inode two has three children. Pointers and point to each of the child inodes. Because the children of inode two are files they do not have any children. Thus they may also be referred to as leaf inodes.

In the embodiment depicted in directory inodes may only be singly linked to only one parent inode but leaf inodes may be multiply linked to one or more parent inodes. For example inode four is multiply linked to inode two . That is inode two has two pointers that point to inode four . Additionally inode three is also a parent of inode four via pointer . Consequently inode four has three names in the distributed file system hello.txt world.txt and file.txt . Accordingly inode four also has three global paths docs hello.txt docs world.txt and temp file.txt .

In another embodiment leaf inodes may only be linked from a single parent inode. In other embodiments a directory inode may be multiply linked from its parent inodes. In yet other embodiments directories may be linked from more than one parent inode and or files may have child inodes.

Additionally inode three points to inode seven via pointer . As indicated by the dashed line inode three initially pointed to inode seven via pointer . However that link was destroyed. In the illustrated embodiment the reverse lookup hint assigned to an inode corresponds to the first created link to that inode. Accordingly because the link to inode seven via pointer was created before the link indicated by pointer the reverse lookup hint for inode seven remains . As used herein when the reverse lookup hint to an inode does not correspond to an existing link to that inode it is referred to as a stale hint. In other embodiments the distributed file system updates the reverse lookup hint every time a link is destroyed so as to eliminate stale hints.

The metadata structure comprises a plurality of fields that include information about the inode. For example fields in inode may include but are not limited to the mode the LIN an array of parents each indicating the number of links from that parent referred to as the Parent Count and the reverse lookup hint .

The LIN field or Logical Inode Number field refers to a unique identifier for the file or directory. It uniquely refers to the on disk data structures for the file or directory. For inode one the LIN is 1. As used herein inodes are referred to using their LIN.

The Parent Count field refers to the parents of the inode and the number of links that is counts from each parent. For example inode one has no parents because it is the root directory. Accordingly a null value is stored in the Parent Count field. In other embodiments a zero value or another value may be stored in the Parent Count field of the root inode .

However inode four has two parents inodes two and three and is multiply linked from parent inode two . Therefore the value stored in the Parent Count field of metadata structure is 2 2 3 1 . The value stored in Parent Count field indicates that inode four has two links from parent inode two and one link from parent inode three . It will be recognized by one with skill in the art that the Parent Count value may be stored in any number of ways such as for example a binary representation a linked list or an array.

Also for inode seven the value stored in the Parent Count field of metadata structure is 3 1 . The value stored in Parent Count field indicates that only one link exists between inode three and inode seven . In other words the Parent Count field reflects that the link associated with pointer was destroyed.

The reverse lookup hint field refers to the hint used by the reverse lookup operation to identify the name associated with a particular inode. For exemplary inode one a null value is stored in the reverse lookup hint field because inode one is the root directory. In other embodiments the reverse lookup hint may be a zero or a value representative of the root directory. For the other inodes the reverse lookup hint corresponds to the hint associated with the first created link to the inode.

For example the value stored in the reverse lookup hint field for inode four is because the link indicated by pointer was created before the links indicated by pointers and . Additionally the value stored in the reverse lookup hint field for inode seven is because it is a stale hint corresponding to the first created and subsequently destroyed link indicated by pointer . As stated above because the depicted embodiment does not update the reverse lookup hint in response to destroyed links the reverse lookup hint remains even though the hint associated with the only existing link is . Though updating the hint in response to destroyed links is computationally expensive some embodiments may do so.

If the user wishes to return only one name for the current entry in decision block the reverse lookup operation calls in block subprocess Determine Name for Single Count which will be described in more detail below. Subprocess Determine Name for Single Count returns one name associated with a link to the current entry. Next in decision block the reverse lookup operation queries the user or client application as to whether the global path for the link to the current entry is desired.

However if the global path is desired the reverse lookup operation calls subprocess Determine Global Path in block. . Subprocess Determine Global Path is described in more detail below. After returning the global path the reverse lookup operation ends .

If however in block all names associated with the current entry are desired the reverse lookup operation performs a for loop for each parent in the Parent Count of the current entry . For each parent the reverse lookup operation determines in decision block whether the particular parent has more than one count. If the parent has more than one count the reverse lookup operation calls subprocess Determine Name for Multiple Counts in block . Determine Name for Multiple Counts returns the name for each link between the current entry and the particular parent of the current entry. However if the parent has only one count the reverse lookup operation calls subprocess Determine Name for Single Count in block . As stated above Determine Name for Single Count returns the name of the single link between the current entry and the parent of the current entry. After the names for every link to every parent have been returned the for loop ends

Next in decision block the user or client application is queried as to whether the global path s of the link s to the current entry is desired.

However if the global path is desired the reverse lookup operation calls subprocess Determine Global Path . After the global path of every name of the current entry has been returned by subprocess the reverse lookup operation ends .

It will be appreciated by one with skill in the art that the invention disclosed herein is not limited to the sequence of steps depicted in or the other flowcharts. In other embodiments the operation may be performed as a singular operation without calling subprocesses. In other embodiments the inputs and outputs of the operation are passed as values references and or stored in accessible memory locations.

In block the reverse lookup hint determines a range of entries that could include the current entry. In the illustrated embodiment the initial range of entries is based on the reverse lookup hint and spans the following set of keys Reverse Lookup Hint 0 Reverse Lookup Hint 1 0 . That is in one embodiment the range of entries includes all keys with the reverse lookup hint. Thus when the reverse lookup hint is not a stale hint or a hint for a link to another parent the current entry will be found in the initial range of entries. Using a reverse lookup hint rather than searching every entry in the B tree may reduce the amount of time needed to identify a matching entry.

In embodiments where the reverse lookup hint is the hint the initial range will include entries with keys that vary only by sequence number. In other embodiments variations in the relationship between the hint and the reverse lookup hint may affect the range of entries. For example if the reverse lookup hint represents only a portion of the hint the range will be wider. However if the reverse lookup hint represents the hint plus a portion of the sequence number the range will be narrower.

After the range is determined the subprocess determines whether an entry in the range of entries has the same LIN as the current entry . If an entry in the range has a matching LIN the subprocess returns the LIN of the currently examined parent of the matching entry that is the current parent and the name or identifier associated with the matching entry . In other embodiments only the name of the matching entry or the LIN is returned. In yet other embodiments other information associated with the link to the matching entry may be returned.

However if in decision block no entry in the range has a LIN that matches the current entry the range of entries is expanded to include all possible entries in the B tree structure for the parent inode . That is the range of entries becomes 0 inf. . Then the operation in block is performed in order to find a matching entry within the new range. If found subprocess returns the LIN of the current parent and the name of the matching entry .

In some embodiments though unexpected if the subprocess is unable to identify a matching entry amongst all of the entries in the B tree structure the subprocess indicates that the Parent Count field includes erroneous information for example by returning Error In Parent Count before ending . It is recognized that not all possible error conditions have been discussed with regard to the determine name for a single count process and the other processes described herein. However a person with ordinary skill in the art would be able to contemplate and account for these other possible error conditions.

While illustrates one embodiment of a reverse lookup operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In block the subprocess initiates a for loop for every entry in the B tree structure associated with the current parent. In other words every entry in the parent directory is considered. For every entry the subprocess determines whether the LIN of the entry matches the LIN of the current entry . If the entry is a matching entry the subprocess gets and returns the name of the entry and then increments COUNT CTR . If COUNT CTR is not equal to COUNT TOTAL then subprocess considers the next entry in the for loop and determines if the next entry is a matching entry . The subprocess returns the name of all matching entries and increments COUNT CTR accordingly. Thus when COUNT CTR is equal to COUNT TOTAL the for loop breaks . Then the subprocess gets and returns the LIN of the current parent before ending .

However though unexpected if the for loop considers every entry in the B tree structure before COUNT CTR is equal to COUNT TOTAL the for loop ends . Then the subprocess indicates that there is erroneous information stored in the Parent Count field of the metadata structure. In the illustrated embodiment the subprocess will return Error in Parent Count . Then the subprocess gets and returns the LIN of the current parent before ending . It is recognized that not all possible error conditions have been discussed with regard to the determine name for multiple counts process and the other processes described herein. However a person with ordinary skill in the art would be able to contemplate and account for these other possible error conditions.

While illustrates one embodiment of a reverse lookup operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

If in decision block of a user or client application wishes to return the global path s of the current entry the reverse lookup operation of calls the subprocess Determine Global Path . illustrates one embodiment of a flowchart of operations for a subprocess of the reverse lookup operation directed to returning the global path s of link s to an inode. The subprocess begins by initiating a for loop for every name returned by the reverse lookup operation . For every name the subprocess prepends the particular global path with the returned name using slashes as path separators . Then if the parent of the current entry is the root the subprocess returns the particular global path .

However if the parent of the current entry is not the root the parent of the current entry is designated the current entry and the subprocess Determine Name for Single Count is called in block . In the illustrated embodiment every inode associated with a directory has only one link from one parent inode. Therefore Determine Name for Single Count is suitable for determining the name associated with the parents of directory inodes. In other embodiments directory inodes may have multiple links to a parent inode or links to more than one parent inode. For these embodiments one of ordinary skill in the art will recognize that the subprocess illustrated in may be modified to recursively or iteratively call either Determine Name for Single Count or Determine Name for Multiple Counts for each link to a parent inode.

After subprocess Determine Name for Single Count executes the subprocess prepends the returned name to the particular global path and determines whether the parent of the current entry is the root . If it is the particular global path is returned . However if it is not the subprocess iteratively determines the name of every successive parent inode in the particular global path until it reaches an inode whose parent is the root .

After the subprocess returns the global path for the first returned name the subprocess similarly returns the global path for every returned name. After the global path of all names have been returned the for loop and subprocess end .

While illustrates one embodiment of a reverse lookup operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location

Referring to there are many examples for returning the name or identifier associated with a particular inode. In particular the examples include but are not limited to a hint collisions b multiply linked files and c stale hints. Though other examples may exist examples of the preceding special cases are described below with reference to the Figures.

Inode five in demonstrates the case of a hint collision. Referring to the reverse lookup operation for returning the name associated with the link to inode five begins by querying the client application as to whether it wants only one or all names associated with the link to inode five . Supposing that the client application desires only one name associated with the link to inode five the reverse lookup operation calls subprocess Determine Name For Single Count .

Referring to subprocess receives the metadata for inode five . From the metadata the subprocess gets the reverse lookup hint and LIN of inode five . In the LIN field indicates that the LIN is 5 and the Reverse Lookup Hint field indicates that the Reverse Lookup Hint is 27. Therefore in block subprocess designates the range of entries to include 27 0 28 0 . In other words as written the range of entries includes all entries with a key indicating that the hint is 27 but not key 28 0 .

Next the subprocess examines the two entries that is the two entries with a hint collision within the specified range entries corresponding to links to inodes four and five . It determines that an entry within the range has a LIN that matches the LIN for inode five . Accordingly subprocess returns the LIN of the current parent and the name of the matching entry. Therefore subprocess returns the following 

After subprocess finishes executing in block of the reverse lookup operation queries the client application as to whether the global path of inode five is desired. Supposing the client application desires the global path of inode five the reverse lookup operation determines the global path for each returned name by calling subprocess Determine Global Path in step .

Referring to the reverse lookup operation begins and performs a set of operations on every returned name using a for loop . However in this example the operations in the for loop are executed only once because there is only one returned name.

First the subprocess prepends the name saved.txt to the global path . Then the subprocess determines that the parent of inode five is not the root . Next the parent inode of inode five inode two becomes the current entry .

In block the subprocess calls subprocess Determine Name for Single Count using inode two as the current entry. Determine Name for Single Count using reverse lookup hint 4 LIN 2 and a Parent Count 1 1 determines from the B tree structure depicted in that the name of the link to inode two is docs. 

Next the subprocess prepends docs to the global path and determines that the parent of inode two is the root . Accordingly subprocess returns the global path. Therefore subprocess returns the following 

Inode four in demonstrates an example of multiply linked files. Referring to the reverse lookup operation begins by querying the client application as to whether only one name or all names associated with inode four are desired. Supposing that all names for inode four are desired the reverse lookup operation executes a for loop for each parent in the Parent Count field of . In particular the Parent Count field for inode four includes the value 2 2 3 1 . Thus the operations in for loop will execute two times once for parent inode two and once for parent inode three .

For inode three the reverse look up operation determines that the parent has only one count and will execute the subprocess Determine Name for Single Count using the reverse lookup hint 27 from the Reverse Lookup Hint field of . First subprocess will determine whether a matching entry exists within the range of entries spanning key values 27 0 28 0 . Referring to the B tree structure for parent inode three in no matching entries exist within the range. Consequently subprocess expands the range of entries to include all of the entries in the B tree structure for inode three and repeats the operation in block .

Then the subprocess determines that entry is a matching entry because LIN 4 is equal to the LIN for inode four . Accordingly subprocess returns the name of the matching entry and the LIN of the current parent . Therefore subprocess returns the following 

Next the for loop of examines the next parent inode two in the Parent Count field . Because parent inode two is multiply linked to the current entry the reverse lookup operation calls subprocess Determine Name for Multiple Counts in block .

 Determine Name for Multiple Counts assigns to COUNT TOTAL the value 2 because parent inode two has two links to inode four . Next the subprocess searches all of the entries in the B tree structure for inode two and determines that the entries corresponding to keys 12 0 and 27 0 are matching entries . Therefore for each matching entry the subprocess returns the name of the matching entry and increments the counter . Because the counter has been incremented twice COUNT CTR is equal to COUNT TOTAL and the for loop breaks .

Next in step the subprocess gets and returns the LIN of the current parent . Therefore subprocess returns the following 

Returning to supposing the client application desires to return the global path for each returned name in decision block the reverse lookup operation will call the subprocess Determine Global Path in block . As described above Determine Global Path returns the global path for every returned name . Accordingly subprocess returns the following 

Inode seven in demonstrates an example of a stale hint. As described previously in reference to inode seven was initially linked to parent inode three via pointer . As a result the reverse lookup hint in the Reverse Lookup Hint field for inode seven corresponds to old.txt. That is the reverse lookup hint is a stale hint.

Referring to when the reverse lookup operation begins the operation will first query the client application as to whether one or all names associated with the links to inode seven are desired. Supposing that only one name is desired the reverse lookup operation will call subprocess Determine Name for Single Count in step .

Referring to the subprocess will retrieve the metadata for inode seven and subsequently obtain the reverse lookup hint 34 and LIN 7 for the current entry. Accordingly the range of entries will initially include keys within the range 34 0 35 0 .

In decision block the subprocess will determine whether there is a matching entry within the range that has the same LIN as the current entry. As shown in no entries have a LIN equal to 7. Consequently in step the range of entries is expanded to include all entries in the B tree structure that corresponds to parent inode three . Next the subprocess will process the operation of decision block with the new range. indicates that of the four entries in the B tree structure entry is a matching entry.

Next the subprocess will return the LIN of the parent inode and the name of the matching entry . Therefore subprocess returns the following 

Subprocess will then end and supposing the client application does not desire the global path the reverse lookup operation also ends .

While certain embodiments of the invention have been described these embodiments have been presented by way of example only and are not intended to limit the scope of the present invention. Accordingly the breadth and scope of the present invention should be defined in accordance with the following claims and their equivalents.

By way of example the following alternatives are also contemplated. Although the data structures described herein have been directed to a distributed file system some embodiments of the invention may be used in a single file system. The reverse lookup may also be implemented in systems that do not include file systems such as for example in memory lookup tables and databases. Additionally or alternatively in the embodiments that comprise a historical flat file directory the offset of the directory entry may be used as the reverse lookup hint. Further directories structured according to Patricia tries and hash tables may also be used. Additionally it is recognized that the reverse lookup hint may represent only a portion of the key when an ordered mapping structure such as for example a B tree implementation is used. In contrast the reverse lookup hint may represent the entire key when a non ordered mapping structure such as for example a hash table implementation is used. The inherent properties of these structures present data values that may be used as reverse lookup hints. Alternatively one of ordinary skill in the art will appreciate that the reverse lookup hint need not be explicitly used by the search data structure rather the reverse lookup hint may be present as a side effect of the organization scheme used.

The above mentioned alternatives are examples of other embodiments and they do not limit the scope of the invention. It is recognized that a variety of data structures with various fields and data sets may be used. In addition other embodiments of the flow charts may be used.

