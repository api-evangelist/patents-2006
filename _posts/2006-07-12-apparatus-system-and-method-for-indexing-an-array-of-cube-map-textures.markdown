---

title: Apparatus, system, and method for indexing an array of cube map textures
abstract: A graphics system supports arrays of cube map textures. In one implementation, a cube map texture is utilized as an index into a set of cube map textures. The set of cube map textures may further be arranged into an atlas of two-dimensional textures.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07884830&OS=07884830&RS=07884830
owner: Nvidia Corporation
number: 07884830
owner_city: Santa Clara
owner_country: US
publication_date: 20060712
---
The present invention is generally directed towards the use of cube map textures to store directional data. More particularly the present invention is directed towards the utilization of arrays of cube map textures.

Cube map texturing is a form of texture mapping for graphics processing that utilizes a three dimensional directional vector as an index into a texture that is a six faced cube. As illustrated in the six faces and of the cube are stored as a set of six two dimensional textures. Cube map texturing is for example described in the OpenGL Graphics System Specification Version 2.0 Appendix F the contents of which are hereby incorporated by reference.

Referring to in the OpenGL implementation of cube map texturing a three dimensional direction vector emanating from the center of a cube is used to select one of the cube map faces. The intersection point of three dimensional vector with cube is used to identify a cube face. Additionally the intersection point is used to identify texture coordinates on the cube face to fetch a texture value.

Cube map textures are useful for storing directional data because of the nature in which the cube map is indexed by a directional vector . As one example bi directional reflectance distribution function BRDF data is often stored in cube maps so that the view and light directions can be used to index the function using a simple texture lookup.

One limitation of conventional cube map texturing is that the current generation of graphics processing hardware and application programming interfaces APIs does not support arrays of cube map textures. For example the DirectX 10.0 API does not support arrays of cube map textures. As a consequence conventional cube map texturing cannot be directly used to access different instances of cube map textures. One consequence of this limitation is that conventional cube map texturing techniques do not directly support utilizing cube map texturing to provide directional data with different attributes for a collection of different objects rendered at the same time.

In light of the above described problems the apparatus system and method of the present invention was developed.

A graphics system stores an array of cube map textures. The array of cube map textures corresponds to a set of cube map textures have different instances of cube map textures. An index is formed into the array of cube map textures. The index permits a graphics processor to access a selected cube map texture based on a vector input an instance index of cube map textures. In one implementation the index includes a cube map texture in which face address information and position offset information are mapped onto the cube map texture to form an address cube map for accessing the array of cube map textures.

In one embodiment a graphics processor is configured to determine a texture value from a set of cube map textures. The graphics processor selects texture coordinate values based on an input three dimensional vector and an instance index identifying a selected cube map texture the set of cube map textures including at least two different cube map textures with each cube map texture having six faces. In one implementation the set of cube map textures is indexed by another cube map texture utilized as an address cube map.

A graphics memory such as a video RAM memory stores a cube map atlas containing texture data for a set of cube map textures. The set of cube map textures is stored as sub textures within a two dimensional texture. That is cube map atlas stores texture information corresponding to an array of cube map textures. Graphics memory also includes a face address cube map index which is described below in more detail to obtain address information and perform a mapping into texture values within cube map atlas .

Pixel shader includes a cube map atlas access module to access cube map textures within cube map atlas based on directional vectors and instance index information specifying an instance of a cube map texture. The directional vectors and instance index information may be received by pixel shader from other components.

Cube map atlas is organized as a two dimensional texture map in which each individual cube map texture cube map is organized as sub textures within the larger two dimensional texture map. To facilitate indexing the different cube map textures cube maps are preferably arranged in rows and the faces arranged in columns . The cube map atlas thus has a cumulative height and width. The total width of the cube map atlas is 6 face width and the total height is N face height where N is the number of different instances of cube map textures supported face width is the width of the cube face e.g. 32 face height is the height of the cube face e.g. 32 and is a multiplication operation. For example an atlas of four cube map textures each with 32 32 faces is stored in a 192 128 two dimensional texture map.

Since the cube map atlas is arranged as a two dimensional texture map the coordinates within a particular cube map may be referenced by x y coordinates of the two dimensional texture map. However note that cube map atlas has faces with common face numbers aligned in columns and common cube map instance numbers aligned in rows. Consequently texture coordinates may also be referenced by face number instance number and an x y coordinate offset. For example the texture coordinate in the x direction textcoord x may be calculated as the distance corresponding to the total number of whole faces traversed in the x direction from an origin plus an x offset in the destination face i.e. textcoord x f face width x offset where f is a face index e.g. 0 1 2 3 4 5 for face faces and face width is the width of a face e.g. 32 units and x offset is an offset within one face. Similarly the texture coordinates in the y direction text coord y may be calculated as the distance corresponding to the total number of whole faces traversed from an origin plus a y offset i.e. text coord y index face height y offset where index is a cube map instance index face height is the face height and y offset is the y offset.

In one embodiment the faces of the face address cube map contain 32 bit floating point red green blue RGB texels. The value of each texel is s t f where s and t are the s t coordinates horizontal vertical of the corresponding pixel in the cube map atlas and f is the face index. So for example the value of the texel at coordinates x y in face of a cube map with 32 32 faces will be 3 32 x y 96 x y . Thus the cube map texels satisfy the formula r g b f face width s t f where f is the face index s t f is the value of the texel. In one embodiment the vertical coordinate is unmodified. This is so that the same face address cube map can be used for all cube maps stored in the atlas. The coordinates returned from a face address cube map lookup need only have n face height added to the t coordinate where n is a positive integer depending on the instance number. Note that the value off is not necessary to store in the B value of each texel but it can be useful in some computations to know which face the value came from.

Face address cube map index permits a cube map texture operation to be used to identify the column number face number and position within a face in the cube map atlas based on an input directional vector. Additional information on the instance number row number may then be used to identify unique texture coordinates within one cube map texture. As an illustrative example referring again to directional vector intersects face . This limits a search in the cube map atlas to the column for face . If the graphics hardware does not support texture interpolation the face address cube map must have the same resolution as the faces of the cube map atlas since this permits a direct mapping between the x y offset indicated by intersection point and the texture coordinates on an individual face of the cube map atlas. On graphics hardware which supports texture interpolation this direct mapping is unnecessary instead the resolution of the face address cube map can be reduced and the missing values can be computed via texture interpolation.

Exemplary Cg fragment program code for using the cube map atlas and face address cube map is as follows 

where dir corresponds to a directional vector the addresses are floating point addresses and the code performs a sequence of steps similar to that illustrated in to use a face address cube map addresscubemap and direction vector dir as an index into the cube map atlas.

One benefit of the present invention is that it permits a common pixel shader to access an array of cube map textures storing different instances of directional data. This permits for example a common pixel shader to calculate directional data for different instances such as different instances of objects or materials. For example a set of cube map textures may be pre computed by a CPU or GPU and stored in video RAM. The set of cube map textures includes one cube map texture for each object or material for which directional data of a selected type might need to be computed. A corresponding face address cube map would also be pre computed and stored in the graphics memory. Since conventional graphics hardware and APIs do not presently support arrays of cube map textures the present invention permits arrays of cube map textures to be utilized in new applications.

One application of the present invention is to store bi directional reflectance distribution function BRDF data for two or more different materials. In this example each material has its own cube map texture within the cube map atlas to store BRDF data. A material index could be used to look up reflectance data for different materials.

Another application of the present invention is to store height information for use in rigid body simulations. Rigid body simulations are a class of simulations in which rigid objects obey Newtonian mechanics that govern how the particles move and collide. As illustrated in rigid bodies and may comprise three dimensional objects having arbitrary shapes. Each rigid body has its own centroid and and directional vector and .

As illustrated in the height of an object may be mapped and stored as a height. In particular a three dimensional object may be described along a directional vector from its centroid by a height.

As illustrated in in one embodiment an individual cube map texture stores a height map providing topographical information on how the height of the object i.e. distance from a centroid varies and which may for example identify regions of constant height in analogy to a contour map. The height of the object along a particular direction may then be checked by examining the height stored in the height map at a selected input directional vector . Note that since the present invention supports arrays of cube maps that height maps for objects having different shapes may be supported. Consequently in a rigid body simulation each object may have its own height map stored as one row of a cube map atlas. Height information may then be accessed for each object by selecting a directional vector and instance number i.e. object number and applying the previously described indexing techniques to access height information for the selected object along a selected direction.

As illustrated in in one embodiment an individual cube map texture stores a height map providing topographical information on how the height of the object i.e. distance from a centroid varies and which may for example identify regions of constant height in analogy to a contour map. The height of the object along a particular direction may then be checked by examining the height stored in the height map at a selected input directional vector . Note that since the present invention supports arrays of cube maps that height maps for objects having different shapes may be supported. Consequently in a rigid body simulation each object may have its own height map stored as one row or a cube map atlas. Height information may then be accessed for each object by selecting a directional vector and instance number i.e. object number and applying the previously described indexing techniques to access height information for the selected object along a selected direction.

An embodiment of the present invention relates to a computer storage product with a computer readable medium having computer code thereon for performing various computer implemented operations. The media and computer code may be those specially designed and constructed for the purposes of the present invention or they may be of the kind well known and available to those having skill in the computer software arts. Examples of computer readable media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs and holographic devices magneto optical media such as floptical disks and hardware devices that are specially configured to store and execute program code such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer code include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hardwired circuitry in place of or in combination with machine executable software instructions.

The foregoing description for purposes of explanation used specific nomenclature to provide a thorough understanding of the invention. However it will be apparent to one skilled in the art that specific details are not required in order to practice the invention. Thus the foregoing descriptions of specific embodiments of the invention are presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed obviously many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications they thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the following claims and their equivalents define the scope of the invention.

