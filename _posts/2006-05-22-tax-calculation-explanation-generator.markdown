---

title: Tax calculation explanation generator
abstract: A method for explaining a form that includes receiving input code, wherein the input code is associated with the form, processing the input code to create an explanation dynamically associated with the form, and outputting the explanation into a natural language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08082144&OS=08082144&RS=08082144
owner: Intuit Inc.
number: 08082144
owner_city: Mountain View
owner_country: US
publication_date: 20060522
---
The typical computer system includes at least one processor and a memory device. Executing on the computer system are various types of applications such as operating system applications and user level applications. Certain user level applications such as spreadsheets databases web pages and tax applications are designed around the concept of forms. A form corresponds to any type of document html page spreadsheets etc. in which functionality is achieved through a combination of fields and calculations. A field in a form stores a data value which may be supplied by the user or other outside resource or calculated using an equation. A user generated field is a field whose data value is entered by the user or outside resource. A calculated field is a field in which the data value is obtained from evaluating an equation typically deriving the data value from other user generated fields and or calculated fields. Note that it is possible for a field to be both user generated and calculated.

Before forms can be populated with data the set of fields and their equations must be specified in the design of the form. This design specification may be represented using a declarative programming language. The equations may include mathematical expressions function calls conditional expressions etc. For example if the equation for the field is the sum of the previous three fields e.g. field1 field2 field3 then associated with the field is typically an equation representing the summation e.g. field4 field1 field2 field3 or field4 sum field1 field2 field3 . The equations may be entered by the user e.g. a user of a spreadsheet application or by a programmer e.g. a programmer of a spreadsheet application .

Often the interdependencies in a form are complicated. Specifically the interdependencies between fields and the equations used in different fields are often not intuitive to programmers or users. This may be especially the case in a declarative specification where there is no explicit flow of control that decides which order the equations are evaluated. Accordingly in order to understand a form and how the values of the fields within a form are generated programmers often rely on long static diagrams that are produced by individuals who design the application. The static diagram describes a theoretical control flow of the application. Specifically the actual control flow may be different from the design if an error is in the application or if the programmer makes a change without updating the design. One method for a programmer to understand a form is to have the code translated from program code into a natural language. A translation corresponds to a word per function conversion from code into a natural language. For example the expression x y z b translates into the statement x equals y added to z added to b. Such translation allows a programmer to easily read complicated fields in a form in a familiar language.

In contrast to programmers who use static diagrams users e.g. users of a spreadsheet application rely on static explanations that are produced by individuals writing the help files. The help files correspond to a snapshot of the description of the form at the time the form is created. The explanation found in the help files is static in nature. Specifically the help file does not automatically change when the source code of an application is modified. Similarly the explanations found in the help file remain static even when the forms that the help files are explaining are dynamic. When modifications are made to the form and a new version of the application is produced each affected portion of a help file must be updated to ensure the help files are consistent with the form.

In general in one aspect the invention relates to a method for explaining a form that includes receiving input code wherein the input code is associated with the form processing the input code to create an explanation dynamically associated with the form and outputting the explanation into a natural language.

In general in one aspect the invention relates to a system for explaining a form that includes a form that includes input code and a framework configured to obtain input code from the form process the input code to create an explanation dynamically associated with the form and output the explanation into a natural language.

In general in one aspect the invention relates to a computer usable medium having computer readable program code embodied therein for causing a computer system to receive input code wherein the input code is associated with a form process the input code to create an explanation and output the explanation into a natural language.

Other aspects of the invention will be apparent from the following description and the appended claims.

Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.

In the following detailed description of embodiments of the invention numerous specific details are set forth in order to provide a more thorough understanding of the invention. However it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail to avoid unnecessarily complicating the description.

Further in the following description of embodiments of the invention terms such as such as trees stacks lists nodes and other terms associated with data structures are discussed. Those skilled in the art will appreciate however that the aforementioned terms are used to represent the properties of the corresponding data structure such as a vector array linked memory references stack etc. For example the term stack corresponds to any data structure such as an array stack linked list etc. in which a property of the structure is set so that the last element added to the stack is the first element removed from the stack. Accordingly as shown in the above example the actual data structures used for a particular term may vary.

In general embodiments of the invention provide a method and apparatus for creating natural language explanations from input code. Specifically in one or more embodiments of the invention the input code describing the equations associated with the form fields is converted into a natural language explanation that a user may understand. A natural language explanation is not only a translation but also a transformation of the input code. Specifically when a simple translation of the input code is not sufficient a natural language explanation may include different words and different ordering of the words from a translation. Further a natural language explanation may include more or fewer words and may add or remove content in order to clarify the meaning for the user. More specifically whereas a translation is a simple change on a word for word basis a natural language explanation may correspond to a metamorphosis of the content of the original input code into a format that is intuitive for a user.

For example a translation of the expression x f1 f2 f3 f4 corresponds to Add the value of f1 to f2. Add the value of f3 to the result. Add the value of f4 to the result. Put the result into x. In contrast a natural language explanation of the above expression may correspond to Add the values of f1 f2 f3 and f4. Put the result into x. in accordance with one or more embodiments of the invention. Thus as shown in the example an explanation may provide more intuitive and helpful information to the user.

A user corresponds to any individual that desires a natural language explanation . For example a user may correspond to a user of the form a programmer of the form a help file specialist etc.

A form corresponds to any type of document html page spreadsheets etc. in which functionality is achieved through a combination of fields and calculations. A field in a form stores a data value which may be supplied by the user or other outside resource or calculated using an equation. Those skilled in the art will appreciate that a field may correspond to such data entry containers as a field in an html form a cell in a spreadsheet etc. A user generated field is a field whose data value is entered by the user or outside resource. A calculated field is a field in which the data value is obtained from evaluating an equation typically deriving the data value from other user generated fields and or calculated fields. Note that it is possible for a field to be both user generated and calculated.

A natural language explanation corresponds to a description of the form in a natural language. Specifically the natural language explanation includes the interdependencies between the fields of a form in a natural language. The natural language may correspond to any language that is understandable by humans. For example the natural language may correspond to French English Greek Arabic Chinese sign language etc. in a visual kinesthetic or auditory output. Further the natural language explanation may correspond to any format of output. For example the natural language explanation may include textual descriptions flow diagrams or any other type of output that would explain the calculations of a form .

In one or more embodiments of the invention the user is operatively connected to a framework . The framework corresponds to a component that includes functionality to receive as input the form or portion thereof and produce the natural language explanation . In one or more embodiments of the invention the framework includes or is operatively connected to a user interface not shown . The user interface for the framework may correspond to a box within the form a dynamic indicator e.g. a virtual pointer that a user clicks on or a separate application from the form and the framework . In one or more embodiments of the invention the user interface includes functionality to receive input from the user specifying the specific fields in the form in which the user is interested. Specifically the user interface includes functionality to obtain input code from the form . The input code corresponds to program code written in a programming language that describes one or more fields. The input code and framework are described in detail in .

A nested equation has an equation e.g. operator and parameter s as a parameter. One type of operator is an assignment operator. An assignment operator assigns a parameter to a field name. For example in the assignment field1 3 field1 and 3 are parameters of the assignment operator . Accordingly assigns the value 3 to field1. Those skilled in the art will appreciate that the input code may be written in virtually any programming language.

Further each equation for a field may have another field as a parameter for the equation. Specifically a dependent field may depend on one or more precedent fields. Accordingly before the equation for the dependent field can be calculated the equations for the precedent fields must be calculated. Those skilled in the art will appreciate that the precedent field may simultaneously be a dependent field and depend on other precedent fields.

Continuing with from the programming perspective the natural language explanation may be outputted to the screen file a bubble within an application etc. In one or more embodiments of the invention the natural language output is divided according to fields and steps. Specifically in such embodiments a marker e.g. numeric marker auditory signal visual indicator etc. may exist before each field.

Further in one or more embodiments of the invention each individual step of the natural language explanation may be included in sentence form. Specifically the natural language output has a separation of each of the nested equations described above into individual steps.

Thus in one or more embodiments of the invention the expression field1 3 x is changed to a two step equation i.e. in step add and x. In step put the results into field1 . The natural language explanation may include either the references to the fields and or data already entered in the fields. Specifically when a field is dependent on a precedent field then the natural language output includes the data already entered in the precedent field or simply the reference to the precedent field.

As shown in a framework for converting the input code into natural language explanation includes a compiler an analyzer a topological sorter and a natural language generator . Each of these components is described below.

The compiler corresponds to an application that includes functionality to parse input code and obtain an abstract syntax tree AST . An abstract syntax tree AST as used herein may correspond to any type of compiled tree structure e.g. a parse tree abstract syntax tree as understood and used by one skilled in the art etc. . Further an abstract syntax tree is composed of compiled tree structure nodes hereinafter referred to as AST nodes . In one or more embodiments of the invention the compiler corresponds to a compiler from a third party vendor. Specifically the compiler may also include functionality to translate the input code written in a programming language into machine code designed to execute on a particular computer system i.e. with a particular processor operating system etc. . Accordingly the abstract syntax tree may correspond to a by product of the compilation of the input code .

Further the compiler is also operatively connected to a dependency tree . Specifically the compiler may include the functionality to create a dependency tree or may be operatively connected to an intermediate processing engine that includes functionality to create a dependency tree . A dependency tree represents the field dependencies. A dependency tree includes one or more dependency nodes not shown . Specifically dependency nodes in the dependency tree identify a field in accordance with one or more embodiments of the invention. When a dependent field in the input code has one or more precedent fields as parameters in the equation defining the dependent field then the precedent fields are children of the dependent field in the dependency tree . For example consider the case when field1 3 field2 and field2 sum a b c . In the example field1 is dependent on precedent field2. Accordingly a dependency node in the dependency tree representing field1 has a child dependency node in the dependency tree that represents field2 in accordance with one or more embodiments of the invention.

Those skilled in the art will appreciate that the dependency tree may correspond to a graph structure that has for n field references more than n 1 connections. Specifically a field may be simultaneously dependent on another field in two different manners. For example field1 may be dependent on field2 and field3 and both field2 and field3 may be dependent on field4. In such a scenario a partially ordering exists on the dependency tree.

Further those skilled in the art will appreciate that the dependency tree may not be completely connected. Specifically a graphical structure representing the dependency tree may correspond to a forest or a disconnected graph. For example if all of the input code includes field1 field2 and field3 and field1 is dependent on field2 and field3 is neither a dependent nor precedent field then field1 and field2 are connected in a single graphical structure and field3 forms a separate graphical structure in accordance with one or more embodiments of the invention. Alternatively those skilled in the art will appreciate that the two graphical structures in the aforementioned example may be linked in an arbitrary manner.

Continuing with an analyzer corresponds to an application that includes functionality to convert the abstract syntax tree into a explain tree described below . The analyzer is operatively connected to a mapping rule repository and a reduction rule repository .

The mapping rule repository corresponds to a storage unit e.g. a table database listing etc. . The mapping rule repository includes rules for mapping each operator and parameter into a classification of a type of object. For example in one or more embodiments of the invention the operators maps to arithmetic objects. As another example an AST node describing a field e.g. field2 may have an entry in the mapping rule repository that specifies a field name maps to a DSfieldRef object.

The reduction rule repository corresponds to a storage unit that includes rules for recognizing the parameters of an object. Specifically the reduction rule repository includes information regarding which objects are parameters of other objects. For example in one embodiment of the invention the if statement maps to a selector object in the mapping rule repository . The reduction rule repository may include the rule that the selector object has parameters of one predicate object and two expression objects in accordance with one or more embodiments of the invention.

Continuing with an explain tree corresponds to a tree composed of explain nodes and the relationship between the explain nodes. An explain node in the explain tree corresponds to an object mapped from the AST nodes in the abstract syntax tree . Accordingly two explain nodes may be related in the explain tree if the corresponding AST nodes are related in the abstract syntax tree . In one or more embodiments of the invention the explain tree is dynamic. Specifically further transformations may be applied to explain sub trees. In one or more embodiments of the invention a transformation of the sub tree may correspond to collapsing the sub tree into a member variables creating a single explain node with the information from the sub tree as the member variables. Accordingly a member variable of an explain node in the explain tree may correspond to one or more explain nodes a value or another attribute of the object mapped from the AST node. In one or more embodiments of the invention a explain tree is considered reduced when the explain nodes in the explain tree corresponds to only assignment objects.

A topological sorter is operatively connected to the dependency tree . The topological sorter corresponds to an application that includes functionality to arrange the explain nodes in the explain tree into an ordered output list. Specifically the topological sorter includes functionality to arrange the explain nodes in a manner that is not only arithmetically correct but is also intuitive to the user. More specifically in one embodiment of the invention each dependent field is near and after the precedent field s of the dependent field. For example if field1 is dependent on field2 and field3 and field2 is dependent on field4 and field5 then in one or more embodiments of the invention the ordered output list may correspond to the sorted output list field4 field5 field2 field3 field1 . Those skilled in the art will appreciate that different sequences are intuitive to different users.

Operatively connected to the topological sorter is a natural language generator . The natural language generator includes functionality to translate the sorted output list of explain nodes into natural language output described above .

A natural language template repository is associated with the natural language generator . The natural language template repository is a storage unit for templates. Specifically for each explain node with member variables there is at least one template that specifies how the explain node converts into at least one natural language sentence in accordance with one or more embodiments of the invention. More specifically in one or more embodiments of the invention each explain node with certain object types as member variables has a template.

Those skilled in the art will appreciate that while shows the compiler as part of the framework the compiler may be outside of the framework . Specifically the input code may be already processed by the compiler before sent to the framework in accordance with one or more embodiments of the invention.

After the input code is received the input code is processed to create the explanation dynamically associated with the form Step . Processing the input code creates the natural language explanation for the input code. A method of processing the input code to create the natural language explanation is described below in in accordance with one or more embodiments of the invention.

Next explanation is outputted in a natural language Step . Specifically in one or more embodiments of the invention the explanation is outputted in a natural language and format that is requested by the user. The explanation may be outputted to a file screen speaker system multimedia system etc. Further in one or more embodiments of the invention the explanation may include data that a user has previously entered or data that can be calculated.

After the input code is obtained the input code is parsed to obtain an abstract syntax tree Step . Parsing the input code into the abstract syntax tree may be performed by a compiler using virtually any method known in the art. Those skilled in the art will appreciate that rather than creating the abstract syntax tree the abstract syntax tree may be a by product of a third party compiler. In either scenario the abstract syntax tree is obtained.

Once the abstract syntax tree is obtained the abstract syntax tree is analyzed to create a dependency tree Step . Creating the dependency tree can be performed for example by identifying the nodes that have an assignment operator in the abstract syntax tree. For each assignment node the field name that is the object of the assignment operator becomes a newly created dependency node in the abstract syntax tree. Field name s that correspond to parameters of the assignment operator become parents of the newly created node in accordance with one or more embodiments of the invention.

In one or more embodiments to the invention in addition to the dependency tree an explain tree is created using the abstract syntax tree Step . Those skilled in the art will appreciate that the explain tree may be created before during or after the dependency tree is created. In one or more embodiments of the invention the explain tree is created by applying the mapping rules to the syntax nodes in the abstract syntax tree to create explain nodes and reducing the newly created explain nodes. shows a flowchart of a method for creating an explain tree in accordance with one or more embodiments of the invention.

As shown in the first AST node is obtained Step . The first node is typically a leaf node from the abstract syntax tree. Specifically in accordance with one or more embodiments of the invention creating the dependency tree from the abstract syntax tree is performed by performing a post order traversal of the abstract syntax tree. In a post order traversal the children AST nodes are visited before the parent AST nodes. Further in one embodiment of the invention the order of visiting the children AST nodes may be determined by the order of the children AST nodes in the input code. For example if the equation is 3 5 then the AST node representing 3 is visited. Next the AST node for 5 is visited. Finally the AST node for is visited. Those skilled in the art will appreciate that other traversals of the abstract syntax tree are also possible. Specifically with modifications to algorithm virtually any traversal of the abstract syntax tree may be used.

Continuing with after obtaining the first AST node the first AST node is set to be the current AST node Step . The current AST node is then marked as visited Step . Marking an AST node as visited may be performed by changing the value of a Boolean variable associated with the AST node. Next a determination is made whether a mapping rule is found for the current AST node Step . Determining whether a mapping rule is found may be performed by searching the mapping rule repository for the type of the AST node. Searching the mapping rule repository may be performed for example by a simple lookup in a table performing a hash operation on the type of AST node or other means known in the art. If a mapping rule does not exist for the current AST node then in one or more embodiments of the invention the current AST node is ignored and a determination is made whether another unvisited AST node exists Step .

Alternatively if a mapping rule is found for the current AST node then an explain node of the type specified by the mapping rule is created Step . Specifically an object of the type specified in the mapping rule is instantiated with the data in the AST node as a member variable. For example in one or more embodiments of the invention if field1 is the current AST node then an object of type DSfieldref is created with member variable field1 . By maintaining the member variable classification of AST nodes may be performed without loss of information.

After creating an explain node using the mapping rules the created explain node is added to a processing stack Step . Specifically in one or more embodiments of the invention the explain node is added to the top of the processing stack.

Next a determination is made whether a reduction rule is found for the explain node Step . Determining whether a reduction rule is found for the explain node may be performed by a lookup in the reduction rule repository for the explain node. If a reduction rule is not found for the explain node then a determination is made whether another unvisited AST node exists Step .

Alternatively if a reduction rule is found for the current explain node then a determination is made whether subsequent nodes in the processing stack of the current explain node match the reduction rule Step . Specifically the explain node s underneath the current explain node is examined to determine whether the node matches the reduction rule. More specifically the explain nodes that match the reduction rule can only be contiguous on the stack in accordance with one or more embodiments of the invention. If the subsequent nodes of the current explain node do not match the reduction rule then a determination is made whether another unvisited AST node exists Step .

Alternatively if the subsequent nodes match the reduction rule then a set is created by removing the current explain node and the subsequent explain nodes that match the reduction rule from the processing stack Step . In particular the set includes the removed explain nodes. Next a new explain node is created from the set Step . Specifically the removed subsequent explain nodes are set as member variables of the current explain node.

After resetting the children explain nodes a determination is made whether another unvisited node exists in the abstract syntax tree Step . Determining whether another unvisited node exists may be performed by determining whether the current node is the root of the abstract syntax tree. If the current node is the root of the abstract syntax tree then all nodes have been visited in accordance with one or more embodiments of the invention.

Accordingly the processing stack is outputted to create the explain tree Step . In one or more embodiments of the invention outputting the processing stack may be performed by iteratively removing each explain node from the processing stack and adding the removed explain node to the end of the explain tree. In one or more embodiments of the invention the outputted explain tree corresponds to a list of explain nodes corresponding to assignment objects. In particular the reduction rules reduce the explain nodes to assignment nodes in accordance with one or more embodiments of the invention.

Alternatively if the current node is not the root of the abstract syntax tree then the current AST node has a parent. Because the abstract syntax tree is traversed with a post order traversal the parent AST node of the current AST node is unvisited in accordance with one or more embodiments of the invention. Thus a determination is made whether the parent AST node of the current AST node has any unvisited children. If the parent AST node has unvisited children then one of the unvisited children is set as the current AST node Step . Alternatively if all children of the parent node are visited then the parent AST node is set as the current AST node Step . After setting an AST node as the current AST node the current AST node is mark as visited Step . When all nodes are visited then the explain tree is complete.

Those skilled in the art will appreciate that while describes a stack implementation for transforming the AST nodes into explain nodes other implementations may also be used. For example rather than adding explain nodes to the processing stack the explain nodes may be added to the top of the explain tree directly.

In the tree implementation reduction rules are applied to subtrees of the explain tree to determine whether the subtrees may be transformed into a representation more suitable for natural language translation. If the children match the reduction rule then the children explain nodes are added as member variables to the current explain node. The children of the children explain nodes are then set as children of the current explain node.

Returning to after creating the explain tree the explain nodes in the explain tree are sorted into an intuitive sequence using the dependency tree to create a sorted output list Step . shows a flowchart of a method for performing a topological sort of explain nodes in the explain tree in accordance with one or more embodiments of the invention.

As shown in initially a leaf list of explain nodes that do not have precedents in the dependency tree are created Step . One method for creating the leaf list is to determine which nodes in the dependency tree do not have children. The leaf list may be created by traversing the dependency tree. When a dependency node is determined to not have children then the explain node in the explain tree that corresponds to the field reference is added to the leaf list.

Continuing with the leaf list is sorted by field name Step . Specifically as previously discussed the reduction rule has removed non assignment explain nodes and set the non assignment explain nodes as member variables of the assignment explain nodes. Therefore the explain tree has only assignment explain nodes in accordance with one or more embodiments of the invention. Accordingly the leaf list may be sorted by the member variable specifying the field name corresponding to the assignment operator.

After sorting the leaf list by field name an empty intermediate stack and empty sorted list is created Step . Next the first explain node from the leaf list is obtained Step . Then the first explain node is added e.g. pushed to the intermediate stack Step . After adding the first explain node to the stack a determination is made whether the intermediate stack is empty Step .

If the stack is not empty then the first explain node is removed e.g. popped from the intermediate stack and set as the current explain node Step . Next a determination is made whether the current explain node depends on a precedent explain nodes not sequenced Step . Determining whether the current explain node depends on at least one precedent explain node not yet sequenced may be performed by traversing the dependency tree and determining whether all dependency nodes that are children of the dependency node with the field name of the current explain node are marked as sequenced. If the current explain node does not depend on any precedent explain node not yet sequenced then the current explain node is added to the end of the sorted list Step .

Next the current explain node is marked as sequenced Step . In one or more embodiments of the invention the dependency node that field name corresponds to the current explain node is marked as sequenced. Marking an explain node may be performed by changing a Boolean variable associated with the explain node or dependency node to true .

After marking the current explain node as sequenced a dependent list of explain nodes is generated Step . The dependent list of explain node corresponds to the list of explain nodes that are dependent on the current explain node. The dependent list of explain nodes may be obtained by aggregating the field names of all direct and indirect dependents of the current explain node. The field name may then be used to obtain the explain nodes from the explain tree.

After obtaining the dependent list the dependent list is sorted by the field name Step . Specifically the member variables corresponding to the field name are used to sort the dependency list.

Alternatively the order of the dependency nodes may be maintained. For example the explain node that corresponds to the dependency node at the root of the tree may be in the front of the dependent list while the explain node s that is directly dependent on the current explain node is added to the end of the list.

Next the set of explain nodes are added to the intermediate stack while maintaining the order specified in the tree Step . For example the first explain node in the dependency list is added to the intermediate stack first and the last explain node in the dependency list is added to the intermediate stack last in accordance with one or more embodiments of the invention.

After adding the dependency list to the intermediate stack a determination is made whether the stack is empty Step . The stack is typically empty when the current explain node is the root of the tree.

If the stack is not empty then the method continues with the removing the next explain node from the stack and setting the next explain node as the current explain node Step . Alternatively if the stack is empty then a determination is made whether the leaf list is empty Step . If the leaf list is not empty then more un sequenced leaf explain nodes exist. Accordingly the next explain node is obtained from the leaf list Step . After obtaining the next explain node from the list the next explain node is added to the stack Step .

Alternatively if the list is empty then all of the explain nodes in the dependency tree are sequenced into a sorted list.

Those skilled in the art will appreciate that while describes one method for sorting the explain nodes other methods are also possible. Specifically a different sorting algorithm may be used. The actual sorting algorithm that is used may be based on the type of ordered output list that is intuitive to the type of user. For example if the type of user is a programmer then an ordering that is intuitive may be based on the order of the equations as stated in the design of the form. Specifically in the programmer example explain nodes are near the explain nodes on which they are dependent. Alternatively if the type of user is an application user then the ordering that is intuitive may be based on the order of the field names as they are presented visually to the user. Specifically in the application user example the order may correspond to field1 field2 field3 etc.

Returning to after the sorted list is created then a natural language explanation is generated for each explain node in the sorted list and the natural language explanation is outputted Step . show a flowchart of a method for generating natural language explanation of explain nodes in accordance with one or more embodiments of the invention. Specifically shows the steps of traversing the sorted list in accordance with one or more embodiments of the invention.

Initially the first explain node is obtained from the sorted list Step . Next a marker is outputted Step . The marker indicates that the equation s specified after the marker is for a specific field. Those skilled in the art will appreciate that outputting the marker is optional.

Next the explain node is processed using the steps described in . shows a method for processing an explain node to generate a natural language explanation in accordance with one or more embodiments of the invention. For the purposes of the current explain node corresponds to the explain node currently being processed.

Initially a template for the natural language explanation of the current explain node is obtained Step . The template may be obtained for example by accessing the natural language repository. In one or more embodiments of the invention the natural language repository has a single template that matches the explain node with the member variables of the explain node.

After obtaining the template the member variables of the current explain node are determined using the template and the current explain node Step . The member variables are the member variables of the current explain node. Next a determination is made whether any of the member variables correspond to an explain node Step . Specifically a determination is made whether the current explain node has nested explain nodes as member variables.

If the current explain node does have explain nodes as member variables then the explain nodes that are member variables of the current explain node are recursively processed using the steps of Step . Specifically each nested explain node is processed in order recursively using . Those skilled in the art will appreciate that while shows a recursive algorithm for processing an explain node an iterative algorithm may also be used.

Once the member variables corresponding to explain nodes are processed or if no member variables exist that correspond to explain nodes then the natural language explanation of the current explain node is generated and outputted using the template Step . Specifically the template specifies the filler words and the member variables specify the variable data to apply between the filler words in accordance with one or more embodiments of the invention.

Returning to once the natural language explanation is generated for the explain node in the sorted list then a determination is made whether the sorted list is empty Step . If the sorted list is not empty then the next explain node is obtained from the sorted output list Step . Alternatively if the sorted output list is empty then the natural language explanation is generated for all explain nodes.

Those skilled in the art will appreciate that the natural language explanation may be outputted by adding the natural language explanation to a file printer display etc. Further outputting the natural language explanation may be performed during or after generating the natural language explanation.

Those skilled in the art will appreciate that innumerable methods exist for implementing the natural language translation in accordance with one or more embodiments of the invention. Specifically the aforementioned methods may be modified to improve performance using optimization principles known in the art.

In the following example consider the scenario in which a user is expecting a refund when filing for taxes. Specifically the user is using an application for the applicable tax forms. After finishing filing out the form the field with the amount of the refund shows that the user owes money rather than receiving a refund. Further a particular calculated field in the Internal Revenue Service Form 1040 does not show the value that the user would expect. Accordingly the user wants to determine how the particular calculated field is determined. Specifically the user may want to know which values and calculations on the values are in other fields that affect the particular field in which the user is interested.

Accordingly the user submits a request with the particular field in the example. The input code is obtained and a dependency tree that includes the particular fields and the precedent fields of the dependent field is created in accordance with one or more embodiments of the invention. Next the abstract syntax tree is created for the fields listed in the dependency tree.

After creating the abstract syntax tree the explain tree is created. At this stage the particular field and each precedent fields are represented as explain nodes with nested explain nodes in accordance with one or more embodiments of the invention.

Continuing with the example the explain nodes are then sorted according to a user preference to create a sorted list. Because the user is interested in determining which calculations are relevant the sorted list for the user is ordered in which each field found in the sorted list is near the precedent fields upon which it depends.

Once the sorted list of explain nodes is obtained natural language explanation is generated for each explain node. After the natural language explanation is generated field names are replaced with the values entered in the fields with the corresponding field names in accordance with one or more embodiments of the invention. The natural language explanation is then outputted for the user to view.

After reviewing the explanation the user realizes that certain field values can be legally changed to produce a higher tax benefit. After changing the values the user is satisfied because the user can now receive a refund.

The invention may be implemented on virtually any type of computer regardless of the platform being used. For example as shown in a computer system includes a processor associated memory a storage device and numerous other elements and functionalities typical of today s computers not shown . The computer may also include input means such as a keyboard and a mouse and output means such as a monitor . The computer system is connected to a local area network LAN or a wide area network e.g. the Internet not shown via a network interface connection not shown . Those skilled in the art will appreciate that these input and output means may take other forms.

Further those skilled in the art will appreciate that one or more elements of the aforementioned computer system may be located at a remote location and connected to the other elements over a network. Further the invention may be implemented on a distributed system having a plurality of nodes where each portion of the invention e.g. compiler analyzer input code natural language translator etc. may be located on a different node within the distributed system. In one embodiment of the invention the node corresponds to a computer system. Alternatively the node may correspond to a processor with associated physical memory. The node may alternatively correspond to a processor with shared memory and or resources. Further software instructions to perform embodiments of the invention may be stored on a computer readable medium such as a compact disc CD a diskette a tape a file or any other computer readable storage device.

Embodiments of the invention provide a method for creating a natural language explanation from a form. Specifically by providing the natural language in a form more understandable than a simple translation users are able to better understand a form. Moreover users and programmers of official documents are able to visualize and understand in an intuitive manner how different fields are dependent on other fields. Further embodiments of the invention add information not inherent in the input code. More specifically by using a natural language template embodiments of the invention add information that allows the natural language to be more readable to the user.

Furthermore embodiments of the invention provide a mechanism whereby users are able to visualize which precedent fields have not been entered. Specifically when a user accesses a dependent field and a precedent field s of the dependent field has not been entered with data the user is able to see that the precedent field s has not been entered with data. Also users are able to see how changes made in precedent fields affect the dependent fields. Specifically by including both field references and data already inputted in the output users are able to better understand the dependencies in the fields.

While the invention has been described with respect to a limited number of embodiments those skilled in the art having benefit of this disclosure will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly the scope of the invention should be limited only by the attached claims.

