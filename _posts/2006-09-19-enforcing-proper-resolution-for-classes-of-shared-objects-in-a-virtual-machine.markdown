---

title: Enforcing proper resolution for classes of shared objects in a virtual machine
abstract: Disclosed techniques ensure that isolates that are attached to a shared object region will see appropriate class states. In response to an isolate's attempt to instantiate, in such a region, an object that is an instance of a particular class, a bootstrap class' identity is added to that region's bootstrap class list. In response to an isolate's attempt to attach to the region, each class that is both (a) in the region's associated bootstrap class list, and (b) not yet initialized for that isolate, is initialized for that isolate. Thus, those bootstrap classes are seen by that isolate as being in the “initialized” state. In response to an isolate's addition of a particular bootstrap class to the region's list of dependent bootstrap classes, the particular bootstrap class is initialized for each of the isolates attached to the region and for which the bootstrap class is not initialized yet.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07945920&OS=07945920&RS=07945920
owner: Oracle America, Inc.
number: 07945920
owner_city: Redwoood City
owner_country: US
publication_date: 20060919
---
The present application is related to U.S. patent application Ser. No. 11 482 603 which is titled SHARING DATA AMONG ISOLATED APPLICATIONS which was filed on Jul. 6 2006 and which is incorporated by reference herein.

U.S. patent application Ser. No. 11 482 603 describes how isolated JAVA applications isolates can share objects with each other by creating such objects within a memory area that all of those isolates can access. Such a memory area is referred to as a shared object region. As described in the foregoing application after one isolate has created an object within a shared object region other isolates which already may be attached to the shared object region or which may later attach to the shared object region may access that object within the shared object region. Those other isolates also may create objects within the shared object region. Objects created in the shared object region may persist even after the isolate that created those objects terminates.

In the JAVA environment described in the foregoing application all objects that are contained in a shared object region are instances of classes that are defined either by a a shared class loader that is dedicated exclusively to that shared object region or b the bootstrap class loader. Each isolate has its own bootstrap class loader but each bootstrap class loader exhibits the same behavior with respect to a class type definition. All classes that are defined by the shared class loader are subclasses immediate or non immediate of at least one class that is defined by the bootstrap class loader. This is because according to the JAVA programming language all classes are part of a class hierarchy. The Object class sits at the apex of this class hierarchy all other classes are subclasses immediate or non immediate of the Object class. The Object class is one of the classes that are defined by the bootstrap class loader.

At any given time during the execution of a JAVA program each class to which that program refers may be in any one of several different states. For example a class may be in the loaded state the linked state the initializing state or the initialized state. Typically a class will proceed from one state to another e.g. from the loaded state to the linked state to the initializing state to the initialized state during the execution of the program that uses the class. If separate isolates that are attached to the same shared object region see the class of a particular object that is stored in that region as being in different states at the same time then one or more of those isolates may function improperly. For example if a particular shared object region contains an object that is an instance of an employee class and if one isolate that is attached to that region sees the employee class as being in the initialized state at a particular instance in time and if another isolate that is attached to that region sees the employee class as being in the loaded state at the particular instance in time then one or both of those isolates may function improperly. Further the class that sees the employee class as being in the loaded state will violate the specifications of the JAVA programming language since the specifications state that a class must be initialized before instances of it may be created.

One purpose of an embodiment of the invention is to enforce that classes that are defined by bootstrap class loader i.e. bootstrap classes upon which a shared object region depends have the same state in all isolates that are attached to the shared object region.

Techniques disclosed herein ensure that at any instance in time in which a shared object region contains one or more objects that are instances of a particular class separate isolates that are attached to that region will see the particular class as being in the same state. For example if a shared object region contains one or more objects that are instances of the ArrayList class defined by the bootstrap class loader then techniques disclosed herein ensure that each isolate that attaches to or already is attached to the region will see the ArrayList class as being in the same state e.g. initialized .

According to one technique for each shared object region a list of all of the isolates that currently are attached to that region is maintained. Further for each shared object region a list of classes that are defined by bootstrap class loaders and used in the shared object region is maintained. This list is called the list of dependent classes of the shared object region. The list of dependent classes of a shared object region is updated with bootstrap classes that are used in the population of objects in the shared object region. The list of dependent classes keeps track of both the name and initialization state of the dependent bootstrap classes. According to one technique whenever an isolate attaches to a shared object region that region s list of dependent classes is passed to the isolate so that the isolate can bring the classes indicated therein to the state appropriate for use of the shared object region.

According to one technique a shared object region becomes dependent on a bootstrap class when one of following event occurs i direct loading execution of code in the context of the shared object region that may cause loading of a bootstrap class ii direct initialization execution of code in the context of the shared object region that may cause direct initialization of a bootstrap classes iii indirect loading loading of a class defined by the shared class loader that may cause the loading of a bootstrap class and iv indirect initialization initialization of a class defined by the shared class loader that may cause the initialization of a bootstrap class. Whenever one of these events occurs the dependent bootstrap class is added to the list of dependent bootstrap classes of a shared object region if it is not already in it and its state is recorded.

According to one technique threads of an isolate comprise a field that indicates whether they are executing in the context of a shared object region and which one. The field is null if the thread doesn t execute in the context of a shared object region and holds the identity of the shared object region otherwise. Threads enter and exit the context of a shared object region using a well defined application programming interface API that appropriately updates the field that indicates the execution context of the thread.

Direct initialization of a class that is defined by a bootstrap class loader may result whenever any one of a certain set of bytecodes is executed in the context of a shared object region. For example in the JAVA programming language execution of the getstatic putstatic new and invokestatic bytecodes results in the initialization of the class whose name is indicated as an operand to the bytecode. According to one technique whenever any of these bytecodes is executed in the context of a shared object region which can be determined by examining the field of the current thread that indicates the thread s execution context and the class indicated in the operand is defined by a bootstrap class loader and is not in the list of dependent classes the class is added to the list of dependent classes of the shared object region. There is no need to add the superclass of the bootstrap class to the list of dependent class.

Indirect initialization of a bootstrap class may result from the initialization of a class defined by the shared class loader of a shared object region. By specification of the JAVA virtual machine initialization of a class requires that its superclass be initialized. Thus only bootstrap classes that are immediate superclasses of a class defined by the shared object regions need to be recorded in the list of dependent classes of the shared object region. According to one technique upon initialization of a class defined by a shared class loader the superclass of the class is added to the list of dependent classes of the shared object region if the superclass is defined by a bootstrap loader and is not already in the list of dependent classes. If the superclass is already in the list but the recorded state is not the initialized state then the list is updated with the new state of the superclass.

Indirect loading of a bootstrap class may result from the loading of class by a shared class loader. By specification of the JAVA virtual machine loading of a class requires that its superclass is loaded first. Thus only bootstrap classes that are immediate superclasses of a class defined by the shared class loader of the shared object region need to be recorded in the list of dependent classes of the shared object region. According to one technique upon the loading of a class defined by a shared class loader the superclass of the class is added to the list of dependent classes of the shared object region if the superclass is defined by a bootstrap loader and is not already in the list of dependent classes. If the superclass is already in the list then there is no need to update the recorded state since the superclass must be already in the loaded state if it is in the list.

Direct loading of a bootstrap class may result from the explicit loading of a class by the execution of code using reflexive capabilities of the JAVA programming language in the context of a shared object region. For example each of the following statements may cause the direct loading of the bootstrap class ArrayList 

According to one technique whenever such statements are executed from within the context of a shared object region the class whose reference is obtained reflexively is added to the list of dependent classes of the shared object region if the class is defined by a bootstrap loader and is not already in the list of dependent classes.

According to one technique when the list of dependent classes of a shared object region is updated due to any of the four events discussed above all isolates that currently are attached to the shared object region must verify that the bootstrap class added to the list is in the state recorded in the list. According to one technique isolates for which this is not the case must bring the bootstrap class to the appropriate state first by loading the class if it isn t already loaded and then by performing the necessary operations to bring the bootstrap class to the appropriate state for instance by initializing the class if the required state is the initialized state .

Isolates already load and initialize many bootstrap classes at program startup that is before handing control to the entry point of a program. Therefore a first simple optional optimization described herein is to ignore these startup classes. Specifically in one embodiment of the invention classes defined at startup are not entered in the list of dependent classes. Further because many commonly used bootstrap classes are likely to be loaded before applications attach to a shared object region the techniques described herein often will merely verify that a class has been loaded by a particular isolate. Moreover in multi tasking virtual machines with transparent sharing of the runtime representation of classes the runtime representation of a particular bootstrap class loaded by at least one isolate is already available in memory and available for sharing with any isolates. Thus subsequent loading of that class by other isolates might only comprise creating the task dependent part of the runtime representation and avoid the much more expensive steps of locating on the file system the class file that contains the binary definition of the class its parsing verifying checking of class loading constraints construction into a shared runtime representation from the class file and updating of the various bookkeeping data structures that are maintained by the JVM.

According to one embodiment of the invention classes above the lowest occurring bootstrap class in the class dependency chain do not need to be stored in the region s list of dependent bootstrap classes because loading the lowest occurring bootstrap class in any isolate causes that isolate to load the remainder of the classes from which the lowest occurring bootstrap class inherits.

For example a shared class loader defined class S2 might inherit from another shared class loader defined class S1 S1 might inherit from a bootstrap class B2 and B2 might inherit from another bootstrap class B1. Under these circumstances if a region s shared class loader s loading of S2 requires the loading of B2 then only B2 needs to be recorded in the region s bootstrap class list.

Techniques disclosed herein ensure that an appropriate bootstrap class is initialized in all isolates that currently are attached to a shared object region before those isolates are allowed to see the class. In one embodiment of the invention the loading and initialization of new classes is atomic with respect to shared class loading and explicit execution of any of the bytecodes discussed above.

Thus techniques described herein ensure that whenever a particular isolate uses an object that is contained in a shared object region the particular isolate s bootstrap class loader already has loaded and initialized all of the bootstrap classes that the object s class needs.

According to a technique described herein in response to an isolate s attempt to initialize a particular class while executing in the context of a shared object region an identity of a bootstrap class loader defined class bootstrap class is added to a list of dependent bootstrap classes that is associated specifically with that shared object region and no other shared object region . The bootstrap class whose identity is added to the region s associated bootstrap class list is either the particular class if the particular class is a bootstrap class or a superclass immediate or non immediate of the particular class that is both a a bootstrap class and b an immediate superclass of a shared class loader defined non bootstrap class. Each shared object region s list of dependent bootstrap classes indicates a summary of the bootstrap classes that need to be in the same state in all the isolates that are attached to that region. The summary is a subset of all the bootstrap classes that need to be in the same state in all the isolates that are attached to that region. The entire set can be inferred from the inheritance relationships between bootstrap classes.

According to one technique described herein in response to an isolate s attempt to attach to a shared object region each of the bootstrap classes that is both a in the region s associated list of dependent bootstrap classes and b not yet for that isolate in the state recorded in that list is first loaded for that isolate and brought to the appropriate state. Thus the set of bootstrap classes that are summarized by the list of dependent bootstrap classes of the region are in the same state in that isolate as well as all other isolate attached to the shared object region.

According to one technique described herein in response to an isolate s addition of a bootstrap class to the list of dependent bootstrap classes of a shared object region the bootstrap class is automatically brought into the same state for each of the other isolates that currently are attached to that region. Thus the bootstrap class is seen by all of the isolates that are currently attached to the region as being in the same state.

These and other techniques according to embodiments of the invention are described in greater detail below.

The system comprises a multi tasking Java Virtual Machine JVM and multiple isolates A N that concurrently execute in the context of and with the assistance of JVM . Each of isolates A N is a separate program also called a task . Thus the illustrated system may be called a multi tasking system. Each of isolates A N is associated with a private memory area also called a heap that no other isolate is permitted to access. In isolate A is associated with private memory area A isolate B is associated with private memory area B and so on.

The system further comprises multiple shared object regions A N although embodiments of the invention may involve as few as one such shared object region. Each shared object region is a separate memory area in which isolates may instantiate new objects and access existing objects even objects that were instantiated by other isolates.

According to one embodiment of the invention in order for an isolate to either instantiate a new object in a shared object region or access an existing object in that shared object region the isolate first needs to attach to that shared object region. Multiple isolates may be attached concurrently to a particular shared object region and a particular isolate may be attached concurrently to multiple shared object regions. In one embodiment of the invention each of shared object regions A N is associated with a separate one of attached isolate lists A N. Each of attached isolate lists A N indicates the identities of the isolates that currently are attached to the shared object region that corresponds to that attached isolate list. Each of attached isolate lists A N may be stored within the corresponding one of shared object regions A N to which that attached isolate list corresponds.

According to one embodiment of the invention in order to keep track of which bootstrap class loader defined classes bootstrap classes are being used by a shared object region and in what state these bootstrap classes need to be for an isolate that attaches to the shared object region so that the isolate can see those classes as being in the same state as all of the other isolates that are attached to that shared object region each of shared object regions A N is associated with a separate list of dependent bootstrap classes lists A N . Each one of lists A N indicates the identities of a subset of the bootstrap classes used by their associated shared object region and on which an operation may need to be performed for each isolate that attaches to the corresponding shared object region if those bootstrap classes have not yet for that isolate been placed in the appropriate state e.g. loaded or initialized .

Examples of techniques that operate upon and make use of the components of the system of are described below.

Referring first to in block an isolate s execution of a bytecode traps to the JVM to initialize a particular class. In block a determination is made as to whether the isolate s thread is currently executing in the context of a shared object region. In one embodiment of the invention an isolate cannot execute in the context of a shared object region until that isolate has expressly entered that specific context through a defined process as described in U.S. patent application Ser. No. 11 482 603. According to one embodiment of the invention the defined process to enter the context of a shared object region includes setting in a field of a descriptor of the current thread an identifier of the shared object region. Performing a determination of whether a thread executes in the context of a shared object region comprises testing whether the field of the descriptor of the current thread is null. If it isn t then the thread is executing in the context of a shared object region. If the isolate s thread is currently executing in the context of the shared object region then control passes to block . Otherwise control passes to block .

In block a determination is made as to whether the particular class is a bootstrap class that is whether the particular class is defined by a bootstrap class loader. The bootstrap class loader is a built in class loader with no first class representation and is typically represented with a null reference. Thus the determination of whether a class is a bootstrap class can be made by testing whether the value of a field in the runtime representation of a class that holds a class loader reference is null. If the particular class is a bootstrap class then control passes to block . Otherwise control passes to block .

In block directly dependent bootstrap class initialization is performed on the particular class. This initialization is described in greater detail with respect to blocks of . In this case the particular class is a directly dependent bootstrap class which is a bootstrap class that will be added to the list of dependent bootstrap classes for a shared object region if that bootstrap class is not already in that list. The superclasses of the directly dependent bootstrap class are not added to the list although those superclasses may enter the list as directly dependent bootstrap classes from other class initializations. Control passes to block .

Alternatively in block shared class initialization is performed on the particular class. This initialization is described in greater detail with respect to blocks of . In this case the initialization is performed by a special recursive process that identifies the superclass of the class that is a directly dependent bootstrap class of the shared object region. Control then passes to block .

Alternatively in block standard initialization is performed on the particular class. This initialization is described in greater detail with respect to blocks of . In this case initialization of the particular class is not initiated from the context of a shared object region. Control then passes to block .

In the description below the subject class is initially the particular class discussed above. Referring to in block standard initialization described with reference to of the subject class superclass if any is performed for the isolate in a recursive manner with the subject class superclass as the subject class . In one embodiment of the invention initialization of the subject class for the isolate requires the subject class superclasses to be initialized first. Because this is a recursive process it means that initialization of the subject class requires that all of the superclasses both immediate and non immediate of the subject class will be completed for the isolate. For each class that is a superclass immediate or non immediate of the subject class initialization of the immediate superclass of that class if any is completed before the initialization of that class is completed.

In block static initializers of the subject class are executed for the isolate if the subject class contains static initializer code. Execution of this code may trigger the technique described in relative to one or more other classes to which the code might refer.

In block the subject class s state is set to the initialized state for the isolate. Thus initialization of the subject class for the isolate is completed.

In the description below the subject class is initially the particular class discussed above. Referring to in block standard initialization described with reference to of subject class superclass if any is performed for the isolate in a recursive manner with the subject class superclass as the subject class . In block static initializers of the subject class are executed for the isolate if the subject class contains static initializer code. Execution of this code may trigger the technique described in relative to one or more other classes to which the code might refer.

In block a determination is made as to whether the subject class is already in the list of dependent bootstrap classes for the shared object region in whose context the isolate s thread is currently executing. If the subject class is already in the list then control passes to block . Otherwise control passes to block .

In block the subject class is added to the list of dependent bootstrap classes for the shared object region in whose context the isolate s thread is currently executing. A record is made that the initialized state is required. Control passes to block .

In block the subject class is initialized for all other isolates that are in the attached isolate list of the shared object region in whose context the isolate s thread is currently executing. Control passes to block .

In block the subject class state is set to the initialized state for the isolate. Thus initialization of the subject class for the isolate is completed.

Alternatively in block a determination is made as to whether the subject class s recorded state is the initialized state. This state is recorded in the list of dependent bootstrap classes of the shared object region in whose context the isolate s thread is currently executing. If this state is the initialized state then control passes to block . Otherwise control passes to block .

In the description below the subject class is initially the particular class discussed above. Referring to in block a determination is made as to whether the subject class superclass if any is a bootstrap class. If the subject class superclass is a bootstrap class then control passes to block . Otherwise control passes to block .

In block shared class initialization described with reference to is performed on the subject class superclass if any in a recursive manner with the subject s class superclass as the subject class . Control then passes to block .

Alternatively in block directly dependent bootstrap class initialization described with reference to is performed on the subject class superclass if any in a recursive manner with the subject class superclass as the subject class . Control then passes to block .

As a result of the technique described above with reference to B C and D each shared object region is associated with a separate list of dependent bootstrap classes that is associated specifically with that shared object region and not with any other shared object region . The list of dependent bootstrap classes that is associated with a particular shared object region indicates at any instance in time a subset of all the bootstrap classes that need to be in a particular state before an isolate that attaches to the shared object region can execute code in the context of the shared object region. The entire set of classes that needs to be set to a particular state e.g. loaded initialized etc. can be inferred from the inheritance relationships of the bootstrap classes whose identities is recorded in the list. The fact that a class may already be in the required state for one isolate does not imply that the class also is in the same state for any other isolate.

In block an isolate attempts to attach to a shared object region. An example process by which an isolate may attach to a shared object region is described in U.S. patent application Ser. No. 11 482 603. The shared object region may already contain objects that other isolates instantiated in the shared object region. The classes of some or all of these objects might not yet have been initialized relative to the isolate.

In block in response to the isolate s attempt to attach to the shared object region all of the bootstrap classes that have not yet been initialized for the isolate are selected from the bootstrap class list that is associated specifically with the shared object region as described above. Thus in one embodiment of the invention only the bootstrap classes that need to be initialized for the isolate in order for the isolate to access the objects contained in the shared object region are selected. In one embodiment of the invention bootstrap classes that already have been initialized for the isolate are not selected from the list.

In block each of the selected bootstrap classes selected in block is initialized for the isolate. All superclasses immediate and non immediate of the selected bootstrap classes that have not yet been initialized for the isolate also are initialized for the isolate in a recursive manner such that for each particular class that is a superclass immediate or non immediate of a selected bootstrap class initialization of the immediate superclass of the particular class if any is completed before the initialization of the particular class is completed. Initialization of the selected bootstrap classes and their superclasses may involve the execution of static initializer code contained within those classes. The statuses of the selected bootstrap classes and their just initialized superclasses are set to the initialized state relative to the isolate.

In block the isolate is attached to the shared object region. In one embodiment of the invention the JVM adds the isolate s identity to a list of isolates that currently are attached to the shared object region. Each shared object region may be associated with a separate list of isolates that currently are attached to that shared object region. When an isolate detaches from a shared object region the JVM may remove that isolate s identity from the list of isolates that currently are attached to that shared object region. As already described the list of isolates that currently are attached to a shared object region may be used to initialize a particular class for all of the isolates that currently are attached to a shared object region in response to the initialization of the particular class for any isolate that currently is attached to that shared object region.

As is discussed above with reference to when a particular isolate attempts to attach to a shared object region certain bootstrap classes that were not yet initialized for the particular isolate may be initialized for the particular isolate so that the particular isolate can access in the shared object region objects that are instances of either those bootstrap classes or subclasses of those bootstrap classes. This technique suffices for objects that were created in the shared object region by other isolates prior to the time that the particular isolate attached to the shared object region. However sometimes one isolate may create a new object in a shared object region after other isolates already are attached to the shared object region. Under such circumstances the other isolates might not be able to access the new object until the class of the new object and or superclasses of that class have become initialized for those other isolates.

In block an isolate that currently is attached to a shared object region and executes in the context of the shared object region adds a bootstrap class to the list of dependent bootstrap class of the shared object region with the requirement that the class must be initialized. At this point the bootstrap class is required to be initialized successfully for all other isolates that currently are attached to the shared object region as described below.

In block following the addition of the bootstrap class to the list of dependent bootstrap class to the shared object region for each particular isolate of the other isolates that currently are attached to the shared object region the currently attached isolates a determination is made as to whether the bootstrap class already has been initialized for that particular isolate. For example the JVM may make this determination based on a the list of isolates that currently are attached to the shared object region and b the JVM maintained state of the isolate private representation of the bootstrap class for each such isolate.

In block for each particular isolate of the other currently attached isolates for which the bootstrap class has not yet been initialized the bootstrap class is initialized for that particular isolate. More specifically the JVM may instruct each such isolate to initialize the bootstrap class for that isolate. All superclasses immediate and non immediate of the bootstrap class that have not yet been initialized for the particular isolate also are initialized for the particular isolate in a recursive manner such that for each particular class that is a superclass immediate or non immediate of the bootstrap class initialization of the immediate superclass of the particular class if any is completed before the initialization of the particular class is completed. Initialization of the bootstrap class and superclasses may involve the execution of static initializer code contained within those classes. The statuses of the bootstrap class and just initialized superclasses are set to the initialized state relative to the particular isolate.

In block the isolate that initially added the bootstrap class to the list of dependent bootstrap class of the shared object region receives from each of the other isolates that was instructed to initialize the bootstrap class as described with reference to block an indication of success or failure to initialize the bootstrap class for that other isolate.

In block a determination is made as to whether all of the indications received from the other isolates in block were indications of successful initialization. If all of these indications were indications of successful initialization then control passes to block . Otherwise control passes to block .

In block the state of the bootstrap class relative to the isolate that initially added the bootstrap class to the list of dependent bootstrap class of the shared object region is set to initialized. Thus initialization of the bootstrap class for the isolate that initially added the bootstrap class to the list of dependent bootstrap class of the shared object region is completed.

Alternatively in block the state of the bootstrap class relative to the isolate that initially added the bootstrap class to the list of dependent bootstrap class of the shared object region is set to initialization error. 

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

In computer system bus may be any mechanism and or medium that enables information data etc. to be exchanged between the various components. For example bus may be a set of conductors that carries electrical signals. Bus may also be a medium that enables signals to be capacitively exchanged between one or more of the components. Bus may further be a network connection that connects one or more of the components. Overall any mechanism and or medium that enables information data etc. to be exchanged between the various components may be used as bus .

Bus may also be a combination of these mechanisms media. For example processor may communicate with main memory via a network connection. In this case the bus would be the network connection. Further processor may communicate with display via a set of conductors. In this instance the bus would be the set of conductors. Thus depending upon how the various components communicate with each other bus may take on different forms. Bus as shown in functionally represents all of the mechanisms and or media that enable information data etc. to be exchanged between the various components.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable medium as used herein refers to any medium that participates in providing data that causes a machine to operation in a specific fashion. In an embodiment implemented using computer system various machine readable media are involved for example in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and tangible media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus .

Common forms of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and

EPROM a FLASH EPROM any other memory chip or cartridge or any other medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the worldwide packet data communication network now commonly referred to as the Internet .

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

Processor may execute the received code as the code is received and or stored in storage device or other non volatile storage for later execution.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

