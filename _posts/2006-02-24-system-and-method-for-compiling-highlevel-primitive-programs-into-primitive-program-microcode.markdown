---

title: System and method for compiling high-level primitive programs into primitive program micro-code
abstract: Systems and methods for compiling high-level primitive programs are used to generate primitive program micro-code for execution by a primitive processor. A compiler is configured to produce micro-code for a specific target primitive processor based on the target primitive processor's capabilities. The compiler supports features of the high-level primitive program by providing conversions for different applications programming interface conventions, determining output primitive types, initializing attribute arrays based on primitive input profile modifiers, and determining vertex set lengths from specified primitive input types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08006236&OS=08006236&RS=08006236
owner: NVIDIA Corporation
number: 08006236
owner_city: Santa Clara
owner_country: US
publication_date: 20060224
---
Embodiments of the present invention generally relate to compiling high level primitive programs into primitive program micro code and more specifically to compiling the high level primitive program for execution by a target primitive processor.

Recently programmable primitive processors have been developed necessitating the development of compilers to produce primitive program micro code for execution by the programmable primitive processors. Conventional primitive processors include fixed function units that may be configured for example to produce particular primitive types but are not programmable. The capabilities of different programmable primitive processors may vary and a program written for one processor may not run on another processor without modification.

Accordingly it is desirable to compile primitive programs written in a high level language into executable micro code optimized for a particular programmable primitive processor.

The current invention involves new systems and methods for compiling high level primitive programs to generate primitive program micro code. A compiler may be configured to produce micro code for a specific target primitive processor based on the target primitive processor s capabilities. The compiler also supports features of the high level primitive program by providing conversions for different applications programming interface conventions determining output primitive types initializing attribute arrays based on primitive input profile modifiers and determining vertex set lengths from specified primitive input types. Therefore the high level primitive program may expressly control a particular primitive processor and the micro code will be optimized for execution by the particular primitive processor improving performance and portability of the high level primitive program.

Various embodiments of the invention include a programmable graphics processor configured to perform multi threaded processing of graphics data.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

One embodiment of the invention includes a computer readable medium storing instructions for causing a processor to compile a high level primitive program to produce primitive program micro code. The steps may include obtaining target platform information applying a transformation to the high level primitive program to produce a transformed primitive program optimized for execution by a primitive processor specified uy the target platform information and converting the transformed primitive program into the primitive program micro code for execution by the primitive processor.

A high level primitive program is designed to operate on assembled primitives e.g. triangles lines points and the like. Primitive programs may be used to perform a variety of geometry operations including clipping primitive subdivision shadow volume generation cube map rendering cylindrical texture wrapping curve interpolation spline interpolation and the like. A compiler is used to convert a high level primitive program into the micro code optimized for execution by a particular primitive processor. Therefore the compiler supports the features of the high level primitive program and may be configured to optimize and convert the high level primitive program into micro code for one or more target primitive processors. illustrates a flow diagram of an exemplary method of compiling a high level primitive program into primitive program micro code in accordance with one or more aspects of the present invention.

In step the compiler receives primitive program source code expressed in a high level language. In step the compiler receives target information that may specify a particular primitive processor and or a particular applications programming interface API e.g. Microsoft s DirectX Open Graphics Library OpenGL or the like. In step the compiler compiles the primitive program source code based on the target information. In step the compiler outputs primitive program micro code optimized based on the target information.

Primitive program source code is processed by a parser using techniques known to those skilled in the art to produce a parsed primitive program. The parsed primitive program is processed by one or more transformers that perform optimizations on the parsed primitive program based on a target platform to produce a transformed primitive program. Target platform may specify a particular primitive processor and or a particular API that will be used to execute micro code . The transformed primitive program is received by a micro code generator that converts the transformed primitive program into micro code for execution on the particular target platform that corresponds to target platform . In some embodiments of the present invention primitive program compiler produces optimized translations of primitive program source code in other high level hardware shading languages such as HLSL high level shader language and GLSL OpenGL s shader language .

In conventional graphics processing systems vertex programs and fragment programs are used to process vertices and fragments respectively. The corresponding processing units that execute the vertex and fragment programs are programmable while primitive processing is performed using dedicated configurable processing units. Although the configuration of the dedicated processing units may be changed the operations are limited to the set of computations provided by the dedicated processing units. More recently graphics processing systems include programmable primitive processing units that execute primitive programs. In addition to the functionality provided by the configurable processing units the primitive programs may be used to perform more complex or more efficient primitive processing. Primitive programs operate in a graphics processing pipeline subsequent to vertex programs and initial primitive assembly and prior to clipping perspective division rasterization and fragment programs. Unlike vertex programs that output a vertex for each input vertex or fragment programs that output zero or one fragment for each input fragment primitive programs output zero or more primitives for a set of input vertices.

Vertex processing typically performed by a vertex program generates a stream of post transformed vertices. A compiled primitive program represented by micro code operates on an assembled primitive e.g. triangle line or point defined by the stream of post transformed vertices. illustrates a point input primitive defined by a vertex in accordance with one or more aspects of the present invention. illustrates a line segment input primitive defined by a vertex and vertex in accordance with one or more aspects of the present invention. illustrates a line with adjacency input primitive defined by vertex vertex and adjacency vertices and in accordance with one or more aspects of the present invention.

A primitive processor executes the primitive program represented by micro code on each assembled input primitive. Several primitives may be processed in parallel and each primitive program instance may be executed independently i.e. without communication between the primitive program instances. Each primitive program instance has access to all the transformed vertex attributes output by the upstream vertex processing. Each primitive program instance receives primitive specific input parameters and common uniform parameters. Because each primitive program instance is executed independently many primitive program instances can execute in parallel for high performance.

Execution of a primitive program instance produces an ordered stream of zero or more output primitives. Output primitive types include points line segments and triangles. The output primitive type may be specified by the primitive program or may be inferred from the input primitive type. Each output primitive is assembled from an appropriate number of vertices that include per vertex attributes such as clip space position and per vertex texture coordinates. These output attributes are used by clipping and interpolation during rasterization. Some primitive programs may perform clipping in which case cupped positions are output. When a primitive program is not present unmodified vertex attributes for each primitive are passed through to clipping and rasterization.

Primitive programs include a geometry profile entry function that returns void and indicates the type of input primitive that the geometry program expects. A primitive profile modifier portion of the entry function specifies the primitive input or output type. TABLE I includes examples of several primitive input profile modifiers and their expected inputs.

A primitive program for a point input primitive expects a scalar or one element array of input variables. A primitive program for a line input primitive expects a two element array of input variables. The first element is the start vertex and the second element is the end vertex. A primitive program for a line adjacency input primitive expects a four element array of input variables. The first element is the pre adjacent vertex the second element is the start vertex the second element is the end vertex and the fourth element is the post adjacent vertex. For example in vertex and vertex may be the first and fourth elements.

A primitive program for a triangle input primitive expects three element array of input variables. The first element is the first vertex the second element is the second vertex and the third element is the third last vertex. A primitive program for a triangle adjacency input primitive expects six element array of input variables. The first element is the first vertex of a triangle the second element is the adjacent vertex to the first and second vertex of the triangle the third element is the second vertex of the triangle the fourth element is the adjacent vertex to the second and third vertex of the triangle and the fifth element is the third last vertex of the triangle and the sixth element is the adjacent vertex to the third and first vertex of the triangle. For example in vertices and are the first second and third vertices of the triangle and vertices and respectively are the adjacency vertices second fourth and sixth elements .

The type of a primitive program point line line adjacency triangle adjacency or other primitive type can be determined by a compiler based on the primitive input profile modifier specified by the primitive program.

Each type of OpenGL primitive batch supported by glBegin corresponds to a different primitive input profile modifier. For example GL POINTS corresponds to the point primitive input profile modifier. GL LINES GL LINE STRIP and GL LINE LOOP correspond to the line primitive input profile modifier. GL TRIANGLES GL TRIANGLE STRIP GL TRIANGLE FAN GL QUADS GL QUAD STRIP and GL POLYGON correspond to the triangle primitive input profile modifier. GL LINES ADJACENCY NV and GL LINE STRIP ADJACENCY NV correspond to the line adjacency primitive input profile modifier. GL TRIANGLES ADJACENCY NV and GL TRIANGLE STRIP ADJACENCY NV correspond to the triangle adjacency primitive input profile modifier. Other rendering APIs may specify the primitive type for a batch of primitives differently.

A primitive program s entry function should be declared using a profile identifier that is a primitive input profile modifier. For example a TRIANGLE profile modifier may be used to specify the input primitive type for a primitive program s entry function simple as shown in TABLE 2.

Vertex domain outputs are inputs to the primitive domain. Therefore the vertex domain output semantics are primitive domain input semantics. The primitive domain input semantics are also the primitive domain output semantics. Specifically POSITION is a clip space position that is typically represented in floating point format. COLORn is a primary n 0 and secondary n 1 color front facing color if two sided color assignment enabled that is typically represented in a floating point format. BCOLn is a back facing primary n 0 and secondary n 1 color that is typically represented in a floating point format. TEXCOORDn is a texture coordinate set n that is typically represented in a floating point format. FOG is a fog coordinate that is typically represented in a floating point format. CLPn is a clip coordinate n that is typically represented in a floating point format. PSIZ is a point size that is typically represented in a floating point format. Additional semantics may be specified for some embodiments of the present invention.

Primitive program entry functions do not have output variables. Unlike vertex and fragment programs that generate results based on output parameters primitive programs output vertices using emitVertex functions. Vertex programs output a vertex for each input vertex. Fragment programs output zero or one fragment for each input fragment. In contrast primitive programs output zero or more primitives for a set of input vertices. The vertex set lengths are inferred by primitive program compiler based on the specified primitive input profile modifier. The stream of vertices received by a primitive program is separated into the vertex sets and each vertex set includes the number of input vertices that correspond to the expected inputs for each primitive input profile modifier shown in TABLE 1.

The output primitive type may be inferred by primitive program compiler from the input primitive type. For example the output primitive type is point when the input primitive type is point. The output primitive type is line when the input primitive type is line or line adjacency. The output primitive type is triangle when the input primitive type is triangle or triangle adjacency. Alternatively the output primitive type may be specified using a primitive output profile modifier.

The vertices emitted by a primitive program can form points line strips or triangle strips. A single primitive program emits only one of the output primitive types e.g. point line or triangle. A primitive output profile modifier may be specified that is applied to the primitive program s entry function. In particular a primitive output profile modifier may be specified in order to output a different type of primitive than is specified by the primitive input profile modifier. Primitive output profile modifiers are specified as POINT OUT LINE OUT and TRIANGLE OUT. The point output profile modifier emits vertices that are assembled to render points. The line output profile modifier emits vertices that are assembled to render line strips. The triangle output profile modifier emits vertices that are assembled to render triangle strips.

Each primitive program has a primitive output type that is determined based only on the primitive output profile modifier for the primitive program s entry function. Primitive program compiler may generate a warning if a primitive program calls a function having a primitive output profile modifier that does not match that of the primitive program s entry function.

A primitive program receives a stream of vertices and associated attributes e.g. color normal vector texture coordinates position or the like as input. The primitive program may also receive uniform parameter constants that are used to process the vertices based on their usage in the program. The associated attributes are specified as an array that is sized by primitive program compiler based on the number of vertices in the input primitive type. For example a triangle primitive type has three arrays of attributes one attribute array per vertex. The attribute array element values are initialized to the values of each corresponding vertex sent to the geometry program when each program instance is executed. Using structures of attribute arrays is preferred to using arrays of attribute structures since the attribute structures are fixed. The attribute arrays of the present invention may be defined to have more or fewer attributes.

 AttribArray as shown in TABLE 2 is a predefined template used to declare input variables for the array of attributes accepted by a primitive program and it is unique to geometry profiles. Because the attribute arrays are unsized they can be used in helper functions that are called by different primitive programs with varying input primitive types. As shown in TABLE 2 position acts like an array with as many elements as the primitive profile modifier mandates. This is 3 for the TRIANGLE input primitive type because a triangle primitive is assembled from 3 vertices. The semantics for the variable applies to every element of the array. Therefore elements of the position attribute array position 0 position 1 and position 2 all use the POSITION semantic.

As with any array elements of attribute arrays may be accessed using the operator. The .length accessor for a primitive profile array declared with AttribArray may be used to determine how many elements are included in the attribute array. For example in the simple function shown in TABLE 2 position.length would evaluate to 3 because the profile modifier is TRIANGLE. As shown in TABLE 3 arrays are allowed to use AttribArray .

In this example texcoord 0 0 texcoord 1 0 and texcoord 2 0 all have the TEXCOORD0 semantic while texcoord 2 1 texcoord 1 3 have the TEXCOORD1 and TEXCOORD3 semantics respectively.

The AttribArray usage can be used for typedefs and variable definitions other than in the primitive program entry function as shown in TABLE 4.

AttribArray array declarations may be used in local variables or in non entry functions such as the helper function shown in TABLE 6. The perspectiveDivideAll helper function may be used generically by primitive program entry functions with differing input primitive profile modifiers and the attribute arrays will be sized accordingly based on the primitive input profile modifier provided for each primitive program entry function.

Primitive programs write a set of output variables with associated vertex semantics and then emit a vertex. The emitted vertex is formed by the current state of the output variable at emit time. A primitive program may emit zero or more vertices. In some embodiments of the present invention the primitive processor may impose a limit on the number of vertices that are emitted for a primitive program. In other embodiments of the present invention primitive program compiler may infer the upper bound for the maximum vertex count based on a primitive processor imposed limit or a programmer specified limit. Some primitive programs may be too complex for primitive program compiler to determine the upper bound due to branching or data dependent program behavior. For those primitive programs a predetermined default upper bound may be used.

Limiting the number of vertices emitted may facilitate efficient parallel execution of the primitive program using a multi threaded primitive processor. In particular because hardware resources such as registers may be allocated based on the number of vertices or attributes it may be advantageous for the hardware to allocate the resources based on a predetermined limit. A lower limit may permit more primitive program instances to run in parallel resulting in higher performance compared with using a higher limit. In some embodiments of the present invention a limit may also be applied to the number of vertex attributes that are emitted for a primitive program.

When the primitive program s output type is POINT OUT every emitVertex call emits a point. When the primitive program s output type is LINE OUT the first emitVertex call in a primitive program or first emitVertex since a restartStrip call begins the assembly of a new line strip. Every second and subsequent emitVertex until the next restartStrip assembles a line segment from the current vertex and the immediately previous vertex. When the primitive program s output type is TRIANGLE OUT the first and second emitVertex call in the primitive program or the first and second emitVertex call since a restartStrip call initiates assembly of a new triangle strip. Every subsequent emitVertex until the next restartStrip assembles a triangle from the current vertex and the two preceding vertices.

During execution of a primitive program when emitVertex is called a vertex is generated based on the current values of the output variables. An arbitrary number of parameters attributes can be passed to emitVertex and used to generate the vertex. The semantics of the passed parameters map the parameter values to hardware resources. For example the parameters foo and bar shown in TABLE 8 result in a vertex having a position of foo and a color of bar.

Parameters with unspecified or unrecognized semantics may be assigned to hardware resources based on the parameter order. Because foo and bar have recognized semantics changing the order of the parameters i.e. emitVertex bar foo provides the same result as the emitVertex usage shown in TABLE 8.

A function restartStrip is used to restart strips of output primitives from a primitive program. restartStrip is used to terminate the current line or triangle strip and start another line or triangle strip originating at the next vertex. restartStrip is a no op function for a primitive program specifying POINT OUT primitive output. Primitive program compiler maintains the ordering of the output vertices including maintaining ordering for strips generated using the restartStrip function. Transformations by the compiler must preserve the ordering of executed emitVertex and restartStrip operations.

Primitive programs may be configured to output per vertex attributes that are smooth shaded typically perspective correct interpolated and per primitive attributes that are flat shaded. However different provoking vertex conventions are used by different APIs for specifying flat shaded attributes for a primitive. Microsoft s Direct3D provides per primitive attributes for constant interpolation what OpenGL calls flat shading with the first vertex of each assembled primitive i.e. the first vertex is the provoking vertex. APIs that use the OpenGL convention provide the per primitive attributes for flat shading with the last vertex of each assembled primitive i.e. the last vertex is the provoking vertex. To permit programmers to write primitive programs independent of the 3D API s provoking vertex convention for flat shaded attributes a flatAttrib routine is used to specify flat shaded attributes. Primitive program compiler compiles the flatAttrib routine based on target platform to support varying API conventions for specifying flat shaded attributes.

TABLE 10 shows an example of how the flatAttrib routine may be used within a primitive program to provide API independence. A first triangle stored in buffer 0 consists of positions 0 1 and 2 and is flat shaded red. A second triangle stored in buffer 1 consists of positions 1 2 and 0 and is flat shaded green.

The VIEWPORT INDEX and BUFFER INDEX output semantics are provided for vertices output by a primitive program. VIEWPORT INDEX may range from 0 through 15 and is used for flat attributes. BUFFER INDEX may range from 0 through 7 and is also used for flat attributes.

The present invention provides many benefits for primitive programming. In particular the primitive programs may be written independent of particular D APIs and or particular primitive processors. When provided with target platform primitive program compiler will produce micro code that is optimized for execution by target platform . The input primitive type may be used to determine an output primitive type vertex set lengths and attribute array sizes. The triangle primitive program shown in TABLE 11A illustrates several of these features.

The triangle program passthru passes a triangle with its position and texture coordinate set 0 unmodified but forces the color to a uniform flat color. In particular note that the parameters provided to AttribArray are sized based on the input primitive type triangle . The output primitive type is inferred to be the same as the input primitive type. The for loop iterates based on the length of the POSITION array and is therefore also determined by the input primitive type. Finally the flat shaded attribute is output independent of a provoking vertex convention.

The triangle primitive program shown in TABLE 11A may be compiled to produce micro code shown in TABLE 11B excluding the comments indicated by s. Notice that primitive program compiler determines position.length is 3 based on the input primitive profile modifier being TRIANGLE and unrolls the loop for better performance. Primitive program compiler also determines the PRIMITIVE OUT TRIANGLE STRIP based on the TRIANGLE input primitive profile modifier. Primitive program compiler determines that VERTICES OUT is 3 based on the loop.

The flatAttrib flatColor call results in a MOV to result.color for the last vertex before the third EMIT because primitive program compiler is configured to use the provoking vertex convention for OpenGL. For Direct3D the MOV to result.color would be right before the first EMIT.

When compiling the code shown in TABLE 11A primitive program compiler can determine that exactly 3 vertices will be output. In more complex examples this determination may be more difficult or even beyond the compiler s capability to determine in such cases the compiler must make a conservative determination. For example when i

In step primitive program compiler determines the input primitive type specified by the primitive input profile modifier for the primitive program entry function. In step primitive program compiler determines if the primitive output type is specified by a primitive output profile modifier and if so then primitive program compiler proceeds directly to step . Otherwise in step primitive program compiler determines that the output primitive type is the same as the input primitive type.

In step primitive program compiler determines if flat attributes are specified and if not primitive program compiler proceeds directly to step . Otherwise primitive program compiler determines if the target platform API is specified as Direct3D D3D and if so in step the leading vertex of each assembled primitive will provide the flat attribute values. Otherwise the target platform API uses the OpenGL convention and in step the last referred to as provoking in OpenGL vertex of each assembled primitive will provide the flat attribute values. Primitive program compiler provides the flat attribute convention information for the target platform API in micro code for use during execution of the primitive program. The compiler must also transform the compiler so that the output of flat attributes is deferred until the proper emitVertex call.

In step primitive program compiler generates micro code for execution by target platform . Micro code includes the information provided by the translation shown in e.g. input primitive type output primitive type maximum limits for vertices and or attributes and the provoking vertex convention.

In step the primitive program instance executes micro code to produce emitted vertices. In step the emitted vertices and strip restarts are collected by the primitive program instance. In step zero or more output primitives are assembled from the emitted vertices and output to complete execution of the primitive program instance. In step the assembled primitives may be rasterized using techniques known to those skilled in the art to produce fragments.

In step the primitive program instance reads the vertex attributes parameters and or any temporary registers specified as operands by the primitive program instruction. In step the primitive program instance executes the instruction by performing the operation specified by the instruction. In step results of the operations are stored in temporary registers specified as destination operands in the instruction. In step the primitive program instance determines if another primitive program instruction should be executed and if so returns to step . Otherwise the primitive program instance proceeds to step to collect the emitted vertices.

The primitive program shown in TABLE 12 is an example of a primitive program that may be used to perform Hermite curve interpolation. The primitive program shown in TABLE 12 may be compiled to produce micro code for execution by a primitive processor.

The primitive program shown in TABLE 13 is an example of a primitive program that may be used to perform Catmull Rom spline interpolation. This primitive program receives 4 points as input and interpolates a section of a line between the second and third point. This primitive program uses the LINE ADJ primitive input profile modifier. Like the primitive program shown in TABLE 12 this primitive program may also be compiled to produce micro code for execution by a primitive processor.

Primitive programs may be used to perform a variety of geometry operations including clipping primitive subdivision shadow volume generation cube map rendering cylindrical texture wrapping and the like. A primitive program may be used to compute the area of each primitive and subdivide primitive s whose area exceeds a threshold value to improve the rendered image quality. Similarly a primitive program may compute a value that is a function of the area such as the sign or twice the area. A primitive program may also be used to compute a facet normal of each assembled primitive. The facet normals may be used to determine when to use flat shading and to perform other shading computations.

A graphics device driver driver interfaces between processes executed by host processor such as application programs and a programmable graphics processor translating program instructions as needed for execution by graphics processor . Driver also uses commands to configure sub units within graphics processor . Specifically driver may program registers within graphics processor based on application programming interface API imposed limits for nesting levels that specify a maximum stack depth for use during multi threaded processing.

Host computer communicates with graphics subsystem via system interface and a graphics interface within a graphics processor . Data received at graphics interface can be passed to a front end or written to a local memory through memory controller . Graphics processor uses graphics memory to store graphics data and program instructions where graphics data is any data that is input to or output from components within the graphics processor. Graphics memory can include portions of host memory local memory register files coupled to the components within graphics processor and the like.

Graphics processor includes among other components front end that receives commands from host computer via graphics interface . Front end interprets and formats the commands and outputs the formatted commands and data to an IDX Index Processor . Some of the formatted commands are used by programmable graphics processing pipeline to initiate processing of data by providing the location of program instructions or graphics data stored in memory. IDX programmable graphics processing pipeline and a raster operations unit each include an interface to memory controller through which program instructions and data can be read from memory e.g. any combination of local memory and host memory .

IDX optionally reads processed data e.g. data written by raster operations unit from memory and outputs the data processed data and formatted commands to programmable graphics processing pipeline . Programmable graphics processing pipeline and raster operations unit each contain one or more programmable processing units to perform a variety of specialized functions. Some of these functions are table lookup scalar and vector addition multiplication division coordinate system mapping calculation of vector normals tessellation calculation of derivatives interpolation and the like. Programmable graphics processing pipeline and raster operations unit are each optionally configured such that data processing operations are performed in multiple passes through those units or in multiple passes within programmable graphics processing pipeline . Programmable graphics processing pipeline and raster operations unit also each include a write interface to memory controller through which data can be written to memory.

In a typical implementation programmable graphics processing pipeline performs geometry computations rasterization and pixel computations. Therefore programmable graphics processing pipeline is programmed to operate on surface primitive vertex fragment pixel sample or any other data. For simplicity the remainder of this description will use the term samples to refer to graphics data such as surfaces primitives vertices pixels fragments or the like.

Samples output by programmable graphics processing pipeline are passed to raster operations unit which optionally performs near and far plane clipping and raster operations such as stencil z test and the like and saves the results or the samples output by programmable graphics processing pipeline in local memory . When the data received by graphics subsystem has been completely processed by graphics processor an output of graphics subsystem is provided using an output controller . Output controller is optionally configured to deliver data to a display device network electronic control system other computing system other graphics subsystem or the like. Alternatively data is output to a film recording device or written to a peripheral device e.g. disk drive tape compact disk or the like.

Samples such as surfaces primitives or the like are received from IDX by programmable graphics processing pipeline and stored in a vertex input buffer including a register file FIFO first in first out cache or the like not shown . The samples are broadcast to execution pipelines four of which are shown in . Each execution pipeline includes at least one multi threaded processing unit to be described further herein. The samples output by vertex input buffer can be processed by any one of the execution pipelines . A sample is accepted by an execution pipeline when a processing thread within the execution pipeline is available to process the sample. Each execution pipeline signals to vertex input buffer when a sample can be accepted or when a sample cannot be accepted. In one embodiment of the present invention programmable graphics processing pipeline includes a single execution pipeline containing one multi threaded processing unit. In other embodiments of the present invention programmable graphics processing pipeline includes a plurality of execution pipelines .

Execution pipelines may receive first samples such as higher order surface data and tessellate the first samples to generate second samples such as vertices. Execution pipelines may be configured to transform the second samples from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. Each execution pipeline may communicate with texture unit using a read interface not shown in to read program instructions and graphics data such as texture maps from local memory or host memory via memory controller and a texture cache . Texture cache is used to improve memory read performance by reducing read latency. In one embodiment of the present invention texture cache is omitted. In another embodiment of the present invention a texture unit is included in each execution pipeline . Alternatively each execution pipeline has a dedicated instruction read interface to read program instructions from local memory or host memory via memory controller .

Execution pipelines output processed samples such as vertices that are stored in a vertex output buffer including a register file FIFO cache or the like not shown . Processed vertices output by vertex output buffer are received by execution pipelines . Execution pipelines execute a primitive program to process the vertices and produce primitives. The primitives are output to a primitive output buffer . A raster unit receives the primitive from primitive output buffer and performs scan conversion on samples such as vertices and outputs samples such as fragments to a pixel input buffer . Alternatively raster unit resamples processed vertices and outputs additional vertices to pixel input buffer .

Pixel input buffer outputs the samples to each execution pipeline . Samples such as pixels and fragments output by pixel input buffer are each processed by only one of the execution pipelines . Pixel input buffer determines which one of the execution pipelines to output each sample to depending on an output pixel position e.g. x y associated with each sample. In this manner each sample is output to the execution pipeline designated to process samples associated with the output pixel position. In an alternate embodiment of the present invention each sample output by pixel input buffer is processed by one of any available execution pipelines .

Each execution pipeline signals to pixel input buffer when a sample can be accepted or when a sample cannot be accepted. Program instructions configure programmable computation units PCUs within an execution pipeline to perform operations such as tessellation perspective correction texture mapping shading blending and the like. Processed samples are output from each execution pipeline to a pixel output buffer . Pixel output buffer optionally stores the processed samples in a register file FIFO cache or the like not shown . The processed samples are output from pixel output buffer to raster operations unit .

One characteristic of the system disclosed in is that it may be configured to embody a SIMD single instruction multiple data architecture where a thread is assigned to each sample processed in the one or more execution pipelines . Therefore a single program may be used to process several sets of samples. Persons skilled in the art will appreciate that any system configured to perform the method steps of B A or B or their equivalents is within the scope of the present invention.

Primitive programs may be used to perform a variety of geometry operations including clipping primitive subdivision shadow volume generation cube map rendering cylindrical texture wrapping curve interpolation spline interpolation and the like. Primitive program compiler may be configured to compile a primitive program and produce micro code for a specific target primitive processor based on the target primitive processor s capabilities. Primitive program compiler also supports features of the high level primitive program by providing conversions for different API conventions determining output primitive types initializing attribute arrays based on primitive input profile modifiers and determining vertex set lengths from specified primitive input types. Therefore the high level primitive program may be written independent of a particular primitive processor or API and micro code will be optimized for execution by the particular primitive processor.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. The listing of steps in method claims do not imply performing the steps in any particular order unless explicitly stated in the claim.

