---

title: Method for detecting race conditions involving heap memory access
abstract: A method for detecting race conditions involving heap memory access including a plurality of threads being tracked. At runtime a plurality of APIs utilized to create and destroy thread synchronization objects are intercepted, and each synchronization object created via the APIs is tracked. A bit field is created that contains a unique bit for each synchronization object. Heap memory allocations and deallocations are intercepted and tracked. The heap memory access is intercepted, and at that time, the ID of the accessing thread is compared with the last thread ID associated with that memory block when it was last accessed. If the thread IDs do not match, then the current thread synchronization object bit field is compared with the last synchronization object bit field associated with thread memory block. Provided the bit fields are different, a race condition warning is reported that is displayable to the user having the call chains.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07992146&OS=07992146&RS=07992146
owner: International Business Machines Corporation
number: 07992146
owner_city: Armonk
owner_country: US
publication_date: 20061122
---
IBM is a registered trademark of International Business Machines Corporation Armonk N.Y. U.S.A. Other names used herein may be registered trademarks trademarks or product names of International Business Machines Corporation or other companies.

This invention relates in general to computer application programs and more particularly to race conditions in multithreaded computer application programs.

The most common and troublesome race conditions in multithreaded applications typically involve objects in heap memory. Most other types of data are less subject to race conditions than heap memory for example stacks are generally thread specific data sections of loaded modules are read only and memory mapped data is typically shared with other processes and thus requires process level synchronization more commonly than thread level synchronization.

The problems associated with heap memory are applicable to various platforms including Windows Unix and other operating systems as well as C Java and other programming languages.

Thus there is a need for a low overhead method that detects and reports race conditions involving heap memory access.

The shortcomings of the prior art are overcome and additional advantages are provided through the provision of a method for detecting race conditions involving heap memory access. The method includes tracking a plurality of threads as the plurality of threads are created and terminated. The method further includes intercepting a plurality of application programming interfaces APIs utilized to create and destroy thread synchronization objects. The method further includes tracking each synchronization object that is created via the APIs. The method further includes intercepting the thread synchronization APIs. The method further includes creating a bit field that contains a unique bit for each synchronization object that is at least one of i used and ii has been used. The method further includes intercepting and tracking heap memory allocations and deallocations. Subsequently the method proceeds by intercepting heap memory access. The method further includes comparing the ID of the accessing thread with the last thread ID associated with that memory block when the last thread was last accessed occurs provided at least one of the following occurs i the thread IDs do not match ii if the block is presently being written and iii if at the last access time the block was written. Afterwards the method includes comparing the current thread synchronization object bit field with the last synchronization object bit field associated with that memory block provided the bit fields are different. Next the method includes recording the current thread call chain if there are no bits in common. The method concludes by reporting a race condition warning that is displayable to the user having the call chains associated with the current and previous accesses to the memory block.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

As a result of the summarized invention technically we have achieved a low overhead solution for a method for detecting race conditions involving heap memory access.

The detailed description explains an exemplary embodiment of the invention together with advantages and features by way of example with reference to the drawings.

Disclosed is a method of detecting race conditions in multithreaded application programs. The method may be implemented as part of a runtime analysis tool in which the application program is instrumented and profiled. The method may also be embodied as a standalone tool. The method yields a warning message as an output to the user whenever two threads contend for access to heap memory.

The disclosed method is intended to provide race condition detection in a tool that has minimal overhead is easy to use and applicable to a majority of users. In order to meet these thresholds assumptions regarding how threads access memory are made. One assumption is that a given thread will generally update a heap memory object as a complete object and more particularly an allocated block is not usually broken down into parts that are modified individually by different threads. Another assumption is that application programmers tend to minimize the number of thread synchronization objects than an application will use at any one time. As such a memory block may be associated with a set of synchronization objects in a relatively small amount of space as compared with the space required to associate the set of synchronization objects with some other less limited set of objects. Another assumption is that sequential access to a memory block before and after a memory write is the most relevant subject when analyzing race conditions at runtime. If a first thread writes to a block and then a second thread reads from it this is a more interesting situation to analyze than what happens when a third thread reads from that same block some time later.

The disclosed method may be applied to other types of memory besides heap memory when the operating system provides a means of determining the locations and extents of the relevant ranges of memory to which the method is to be applied. For example a mechanism for performing the method in conjunction with the Windows operating system is described in further detail herein.

Referring to a low overhead method for detecting race conditions involving heap memory access is shown. Starting at step a plurality of threads are tracked as the threads are created and terminated for example DllMain is the starting routine in a thread that may be tracked as it is created and terminated.

At step a plurality of application programming interfaces APIs utilized to create and destroy thread synchronization objects are intercepted for example InitializeCriticalSection and DeleteCriticalSection are Windows APIs utilized to create and destroy thread synchronization objects that may be wrapped. At runtime the existing synchronization objects for the intercepted APIs are tracked in a list and the list entry for each object is associated with a bit in a globally recognized bit field in which there is one unique bit for each tracked synchronization object.

At step each synchronization object that is created by way of these APIs is tracked. Then at step the thread synchronization APIs are intercepted such as EnterCriticalSection and LeaveCriticalSection which are Windows thread synchronization APIs that may be intercepted. Furthermore for the intercepted thread synchronization APIs the synchronization objects held by each thread at any time frame are tracked. Also a list entry for each thread holding the synchronization object is tracked. This tracking encompasses usage of a data structure T having fields T and T the field T is utilized to identify at least one of i the thread ID and ii the handle the field T is utilized to identify an instance of the synchronization object bit field where a bit is set for each synchronization object currently owned by that thread.

At step a bit field containing a unique bit for each synchronization object that is used or has been used during the process is created. Then at step heap memory allocations and deallocations are intercepted. Furthermore a list entry for each allocated heap memory block is tracked. This heap block tracking encompasses usage of a data structure B having the fields B B and B. The field B is utilized to identify at least one of i a thread ID ii a handle and iii a tracking structure for example B may be initialized to the tracking structure T representing the thread that allocated that memory block. The field B is utilized to identify a thread synchronization object bit field which may be initialized to a copy of the allocating thread s synchronization object bit field at the moment of the block s allocation. The field B is utilized to identify a flag for indicating at least one of i whether the block was last read and ii whether the block was last written. The flag is initialized to read in order to prevent invalid reporting if a different thread initializes the block s contents.

At step the heap memory access is intercepted for reads and writes. At step it is determined if a memory access has occurred. When a memory access occurs the ID of the accessing thread is compared with the last thread ID associated with that memory block when the last thread was last accessed in step . This comparison takes place when at least one of the following occurs i the thread IDs do not match and ii if the block is presently being written and iii if at the last access time the block was written.

At step the determination of whether the bit fields are different takes place. If the bit fields are different the current thread synchronization object bit field is compared with the last synchronization object bit field associated with that memory block at step .

At step the current thread call chain is recorded if there are not bits in common. Then at step a race condition warning that is displayable to the user with the call chain is reported.

Afterwards field B of the tracking structure for the memory block is updated. Then the current thread bit field T is copied to the bit field location for that block B . Subsequently field B of the block tracking structure is updated.

A pointer is stored to one of the following i the current thread ID and ii the tracking structure T referenced by the block tracking structure B . Then field B of the block tracking structure is updated.

The block is indicated as either one of i read and ii written. Afterwards a filtering mechanism is provided for race condition warnings with a filter per call chain such that the user may hide particular outputs.

The disclosed invention may be utilized to detect race conditions involving non heap objects such as virtual memory pages. The invention may be extended to detect race conditions involving pages of memory mapped data and stack memory by discovering and tracking all committed pages of memory periodically by walking through the virtual address space. For example on Windows this could be done by making a series of VirtualQuery calls. For each page of committed memory the method could track a structure similar to the memory block tracking structure previously described in this disclosure. In this structure fields P P and P are utilized. Field P represents at least one of i a thread ID ii a handle and iii a thread tracking structure T . For example the thread tracking structure T previously described may be initialized to the tracking structure representing the first thread found to access that page. Field P represents a thread synchronization object but field which may be initialized to a copy of the accessing thread s synchronization object bit field at the moment the page was first accessed. Field P is utilized as a flag for indicating whether the block was last read or written initialized to the type of access performed by that thread . Last but not least the memory mapped and stack memory access reads and writes are intercepted and as previously described the race condition warnings are reported.

Referring to a set of functions that may be utilized together in an exemplary embodiment of the method disclosed in are shown. One skilled in the art should know that the functions described herein may be implemented within a software runtime analysis tool in which a software application is instrumented and run. In the exemplary embodiment for example the various functions described herein may be implemented as part of a tool that analyzes a software program under test.

Referring to at step the program under test is running. Then at step the heap memory allocation is detected via a hook that has been inserted during the instrumentation phase prior to the run. Subsequently at step the allocated block in a list of block tracking structures B is tracked. At step verification for any synchronization objects currently engaged by the thread according to bit field T for the thread takes place. Provided there is a synchronization object currently engaged by the thread the contents of bit field T for the current thread are copied into bit field B for the newly allocated block at step . At step field B is set for this block to indicate that no memory writes to this block have occurred. Control is returned to the program under test which continues to run operate at step .

Referring to at step the program under test is running. Then at step the heap memory write operation is detected via a hook that has been inserted during the instrumentation phase prior to the run. Subsequently at step verification that the last access of this memory block was a write access according to field B for the block being written takes place. At step verification that the current thread performed the previous write access according to field B for the block being written takes place. At step verification that any synchronization objects currently engaged by this thread according to bit field T for this thread takes place. Then at step verification of bits in common between bit field T for the current thread and bit field B for the block being written takes place. At step field B is set for the block being written to indicate that the current thread has written to it. At step a call chain for the current thread is recorded provided no synchronization objects were currently engaged by this thread and provided that no bits are in common between bit field T and bit field B. Then at step verification that the call chain has not been filtered to prevent a potential race condition display takes place. At step the potential race condition including the recorded call chain is reported. Control is returned to the program under test which continues to run as noted by step .

Referring to the program under test is running at step . At step synchronization object creation is detected via a wrapper for a thread synchronization object creation API. Subsequently at step the synchronization object is tracked in a list of tracked synchronization objects. At step a bit is added to the count of bits that shall be used in the bit fields that represent the set of tracked synchronization objects and this new bit is tracked as the bit to be associated with this new synchronization object. Control is returned to the program under test which continues to run at step .

Referring to the program under test is running at step . At step the synchronization object engagement is detected via a wrapper for a thread synchronization API. Then at step the bit associated with this synchronization object in the bit field associated with the current thread T is set. The program continues to run at step .

Referring to the program under test runs at step . At step thread creation is detected via a hook that has been inserted during the instrumentation phase prior to the run. At runtime at step the thread is tracked in a list of thread tracking structures T . At step the program continues to run.

Referring to the program under test is running at step . Then at step synchronization object disengagement is detected via a wrapper for a thread synchronization API. At step the bit associated with this synchronization object in the bit field associated with the current thread T is reset. At step the program continues to run.

While the preferred embodiment to the invention has been described it will be understood that those skilled in the art both now and in the future may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.

