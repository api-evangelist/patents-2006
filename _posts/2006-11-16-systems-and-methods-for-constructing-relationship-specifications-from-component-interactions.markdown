---

title: Systems and methods for constructing relationship specifications from component interactions
abstract: Techniques for automatically creating at least one relationship specification are provided. For example, one computer-implemented technique includes observing at least one interaction between two or more components of at least one distributed computing system, consolidating the at least one interaction into at least one interaction pattern, and using the at least one interaction pattern to create at least one relationship specification, wherein the at least one relationship specification is useable for managing the at least one distributed computing system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08037471&OS=08037471&RS=08037471
owner: International Business Machines Corporation
number: 08037471
owner_city: Armonk
owner_country: US
publication_date: 20061116
---
The present invention relates to distributed computing systems and more particularly to systems and methods for constructing relationship specifications from component interactions.

Implementing changes for hardware software network and storage systems in large scale electronic business e Business environments remains burdensome to customers. Rolling out changes such as installing and uninstalling upgrading or configuring systems can take weeks partly because the complex interdependencies between applications and their supporting services are not made explicit. Therefore human involvement and expertise is required.

Solving this change management problem automatically is advantageous in addressing the increasing complexity of computing systems. The number of relationships of a single computing resource for example a software component a network component a storage system range from 10 to 100. The number of computing resource instance relationships in large scale enterprise systems is often between 1 000 000 and 1 000 000 000. Given that a change to one or more computing resources may entail additional changes on a multitude of other computing resources it is evident that minimizing the need for human involvement in the change management process would be advantageous.

Change management is a process that offers many automation challenges. The organizational frameworks behind existing change management processes tend to be ill defined and highly variable in detail and formality. This makes it difficult to identify tasks for automation or to reuse standardized automation across environments within or between information technology IT organizations for example this is a particular problem for corporate mergers . Additionally effective change management requires a great deal of accurate information on technical constraints such as dependencies between IT services the components that implement them and the infrastructure supporting them. This information is rarely documented formally or kept up to date therefore hindering change assessment and change impact prediction.

Existing approaches involving service providers and enterprise IT departments require setting up staging areas where changes are repeatedly tested to expose their potential impacts and adjusted accordingly before they can be safely deployed into production environments. Building staging environments is done manually in a step by step fashion and is documented in textual documents termed build sheets or run books that are written in a natural language. Build sheets and run books are used to construct the production system which is typically significantly larger than the staging system. This textual human readable representation however restricts the usage and execution of build sheets and run books to humans only. In particular neither build sheets nor run books can be executed by an automated software deployment and provisioning system.

In addition existing approaches such as Integrated Development Environments IDE do not capture dependency information. Instead existing approaches capture the containment hierarchy of a single individual software system that is being implemented without taking into account the existence of other software systems with which the software system under development needs to interact.

Existing approaches in the area of dependency management fall into 3 categories. The first category of approaches requires user input that is the manual entry of dependencies. An existing approach in this category is U.S. patent application Ser. No. 09 835 528 entitled Method and Apparatus for identifying Software Components using Object Relationships and Object usages in Use Cases filed Apr. 17 2001. This approach includes obtaining object dependency and object usages information from a user. Another existing approach in this first category is U.S. patent application Ser. No. 09 750 305 entitled System and Method for managing Dependencies in a component based System filed Dec. 29 2000. This approach includes defining a resource that is part of an entity recording a resource specifier for the resource and recording resource dependency relationships definitions for the resource.

The second category of dependency management approaches requires access to the source code of all the components of an application in order to derive dependencies. An existing approach in this category is U.S. patent application Ser. No. 09 865 300 entitled System and Method for the Manipulation of Software filed May 24 2001. This approach includes analyzing a body of source code and deriving a set of components from the software architecture inherent in the body of source code. Another existing approach in this second category is U.S. patent application Ser. No. 09 839 644 entitled Methods and Systems for identifying Dependencies between object oriented Elements filed Apr. 20 2001. This approach includes allowing a developer to simultaneously view a graphical and a textual display of source code.

The third category of dependency management approaches requires the presence of appropriate management instrumentation that surfaces dependency information. An existing approach in this category is U.S. patent application Ser. No. 10 055 426 entitled Method and Apparatus for Distributed Systems Management filed Jan. 23 2002. This approach includes providing a first agent monitoring a first managed device. Another existing approach in this third category is U.S. patent application Ser. No. 10 021 535 entitled Methods and Apparatus for managing Components in an IT System filed Dec. 21 2001. This approach includes discovery of components carried out using fingerprints of components which can include key elements of the component that exist in a full model of all of the elements of the component.

Existing approaches in the area of software development include U.S. Pat. No. 4 751 635 which includes a host computer extracting information from each of the support system databases to obtain data indicative of development activity for various phases of the life cycle of the software system. Another existing approach in this area is U.S. Pat. No. 5 960 196 which includes a metric collector that provides a list of available metrics related to software development tests and loads building for the user s selection.

Existing approaches in the area of maintenance include U.S. Pat. No. 5 493 682 which includes assembling executable systems from defined component parts such as source code files and object code files.

Existing approaches in the area of software packaging include U.S. Pat. No. 5 835 777 which includes combining listed files the needed resources and any related installation materials.

Existing approaches in the area of electronic software distribution of whole program packages include U.S. Pat. No. 6 009 525 which includes software products being wrapped by their publishers in a straightforward secure manner but in such a way as to allow for the addition of information by downstream distribution channel partners for example distributors and merchants resellers . Another existing approach in this area is U.S. Pat. No. 5 721 824 which includes installation of each dominant or primary package and installation of the dependent or secondary packages dependent on that dominant package.

Existing approaches in the area of updates and or corrections and or fixes and or patches include U.S. Pat. No. 5 999 740 which includes accessing a remote file server to obtain a release file containing a list of software applications available from the remote server and comparing the release file with the registration file to determine which of the installed applications have upgrades available. Another existing approach in this area is U.S. Pat. No. 5 805 891 which includes determining whether the software maintenance module requires test and submitting the module to test if required.

Existing approaches in the area of determining conflicts in existing software and or hardware configurations include U.S. Pat. No. 5 867 714 which includes communications circuitry that from time to time automatically transmits at least part of the current hardware and software configuration data of the computer system to a remote data source capable of identifying inherent conflicts in the hardware and software configuration.

The existing change management approaches rely on detailed static or design information source code or management instrumentation.

It would thus be desirable to overcome these and other limitations in existing change management approaches.

Principles of the present invention provide techniques for constructing relationship specifications from component interactions.

For example in one aspect of the invention a computer implemented technique for automatically creating at least one relationship specification includes the following steps. At least one interaction between two or more components of at least one distributed computing system is observed. The at least one interaction is consolidated into at least one interaction pattern. The at least one interaction pattern is used to create at least one relationship specification wherein the at least one relationship specification is useable for managing the at least one distributed computing system.

In another aspect of the invention a computer implemented technique includes the following steps. At least one task relationship and at least one corresponding relationship constraint of at least one computing system are determined. The at least one task relationships is consolidated with the at least one corresponding relationship constraint. The at least one consolidated task relationship and relationship constraint are used to generate at least one deployment descriptor. The at least one deployment descriptor is stored wherein the at least one deployment descriptor is useable for subsequent reuse and processing in managing the at least one distributed computing system

In contrast to the above mentioned limitations in existing approaches principles of the invention overcome such shortcomings by for example being able to generating deployment descriptors even if no reliable dependency information is present.

One or more embodiments of the invention may provide one or more beneficial technical effects such as for example eliminating the requirement that the distributed system provide management instrumentation. Furthermore one or more embodiments of the invention may provide one or more beneficial technical effects such as for example eliminating the need for available source code.

These and other objects features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof which is to be read in connection with the accompanying drawings.

One or more embodiments of the present invention relates to distributed computing systems and more particularly to systems and methods for automatically constructing deployment descriptors. Deployment descriptors are machine readable relationship specifications.

One or more embodiments of the present invention generate dependency relationship information itself by observing one or more interactions among the components of a distributed computing system. In a preferred embodiment of the invention observing one or more interactions occurs at run time. One or more embodiments of the present invention are able to generate deployment descriptors even if no reliable dependency information is initially present. Consequently a distributed system neither has to provide management instrumentation nor is there a need for the availability of source code.

One or more embodiments of the present invention include executing the techniques described herein with already packaged software products.

One or more embodiments of the present invention in contrast includes distributed composed applications that are aggregated from multiple already packaged individual software systems for which no source code is available. One or more embodiments of the present invention construct deployment descriptors for such composed applications termed composed application deployment descriptors CADD by observing the interactions among the components of computing systems. CADDs in an exemplary embodiment are machine readable relationship specifications and serve as input to an automated software deployment and provisioning system in order to coordinate and orchestrate the aggregated installation configuration and maintenance for an end to end composed application that spans a variety of products technologies and application code for example in support information technology IT service management .

In one or more embodiments of the present invention constructing CADDs includes reverse engineering the blueprint of a composed application at run time. Additionally the dependencies between the shrink wrapped individual applications that were aggregated are identified. One or more embodiments of the invention allow an administrator to identify the dependencies either for the distributed computing system as a whole or for selected parts thereof. One or more embodiments of the invention also annotate CADDs with precedence and location constraints and express the identified dependencies in a machine readable format as CADDs. Additionally one or more embodiments of the present invention store the identified CADDs persistently for subsequent reuse and also allow the retrieval of CADDs to automatically build composed application by loading them and executing them by an automated deployment or provisioning system.

Economies of scale may be accomplished because the knowledge gleaned from a smaller scale system can be reused for the construction of a production system that is typically at least a magnitude larger than the staging system. In addition persistently storing the constructed deployment descriptors in a deployment descriptor library allows for their reuse whenever similar computing systems need to be built in the future.

The identification and tracking of relationships between the components of distributed computing systems is advantageous for automated change management. For example software components rely on a variety of supporting components. Consequently applying a change to one component affects other components that is components have dependencies on other components. Dependencies exist between components on a single system and also between the components on multiple systems and organizational domains.

As used herein dependents refer to components that depend on others and antecedents refer to components on which other components depend.

A component often plays the role of both dependent and antecedent for example a component providing a name service is required by many applications and services but is depending itself on the proper functioning of other components such as the operating system and the network protocols and infrastructure thus leading to a dependency hierarchy that can be modeled as a directed graph.

Furthermore dependency relationships are transitive that is the dependent of a given component requires in addition to the component itself the component s antecedent or antecedents as well. Dependencies exist between various components of a distributed system such as for example end user services system services applications networking infrastructure components and their logical and physical components.

In contrast to the existing approaches one or more embodiments of the present invention generate deployment descriptors from observing and capturing the interactions or transactions occurring in a running system and subsequently condensing them into interaction patterns. Furthermore one or more embodiments of the present invention transform one or more captured component interactions into deployment descriptors whose elements representing the building blocks of a composed application may be linked by temporal ordering also referred to as precedence and location constraints. Examples of such constraints are The change management operation for component X must finish before the change management operation for component Y can begin the change management operation for component X cannot start until the change management operation for component Y does the change management operation for component X cannot finish before the change management operation for component Y does and the change management operation for component X cannot finish until the change management operation for component Y starts. Constraints apply to various types of change tasks such as for example install uninstall configure start and stop.

One or more embodiments of the invention include a system that automatically captures one or more component interactions and their subsequent automated processing into CADDs. CADDs provide dependency information that facilitates an automated provisioning system in determining the order in which changes need to be carried out to transition one or more computing systems from a workable state into another workable state. The output of one or more embodiments of the invention can be consumed and modified by for example automated provisioning systems for data centers or by enterprise software distribution and configuration tools. Furthermore one or more embodiments of the present invention are able to store computed CADDs for subsequent reuse by storing them in a deployment descriptor library.

One having skill in the relevant art will recognize that modifications in the way dependencies are obtained as well as the representation of dependencies may be made without departing from the spirit and scope of the present invention. By way of example and not limitation additional sources of dependency information such as for example relationship registries may be available. As used herein a CADD refers to a machine readable relationship specification. Information stored within a CADD is specific to a given combination of components and may be decoupled from the computing systems and their characteristics for example computer processing unit CPU speed random access memory RAM free and or available disk space .

One purpose of the deployment descriptor generator disclosed herein is to construct reusable deployment descriptors for various change management operations from component interactions. A deployment descriptor may contain for example information about the change management operation that needs to be carried out for example install update configure and or uninstall . Also a deployment descriptor may contain for example information about the roles and names of the components of a composed application as well as the location constraints that may exist between the building blocks of a composed application such as for example co location that is a component must be present on the same system as another component or ex location that is a component must not be present on the same system as another component . Additionally a deployment descriptor may contain for example information about the precedence constraints that may exist between the building blocks of a composed application such as for example X must be installed before Y. 

In one or more embodiments of the present invention a deployment descriptor may contain in addition to the aforementioned exemplary data information that relates to the specific hardware characteristics of a computing system such as CPU speed RAM or total and or available disk space or names and internet protocol IP addresses of computing systems. However one having skill in the relevant art will recognize that modifications in the types of data contained within deployment descriptors as well as their representation may be made without departing from the spirit and scope of the present invention.

One or more embodiments of the present invention add architectural elements to a change management system that enable such a system to initiate a change trigger the acquisition of dependency relationship information along with location constraints identify interaction patterns and their subsequent automated processing the patterns into deployment descriptors. It should be noted that the applicability of one or more embodiments of the invention is not confined to the problem area of software provisioning and maintenance. One or more embodiments of the invention also can be used for other changes as they occur either during the configuration or reconfiguration of computing and software systems.

Given the above realizations made in accordance with one or more embodiments of the present invention and general features associated therewith the remainder of the detailed description will provide an illustrative explanation of techniques for implementing such realizations and features in the context of .

Each ADD contains elements that represent the logical units of deployment that aggregate elements corresponding to the physical deployment units. More specifically each individually packaged software product is represented by a separate ADD whereas the logical and physical components that belong to the same product are further described within the product s ADD. In the example of application server the highest level elements are the web server the application server core for example web and Enterprise JavaBeans EJB containers and the embedded messaging component which are further broken down into the various fine grained software components. As all of them make up the application server product their descriptions are contained in the application server s ADD see also .

The set of deployment descriptors one CADD five ADDs for the composed application and the underlying middleware stack reflect the structure depicted in . One can see that a set of deployment descriptors represents a directed graph. While dependencies between the elements within an ADD describe a software containment hierarchy CADDs provide additional dependency types. For example whenever a component referenced within a CADD depends on another element belonging to a different product and therefore is specified in an ADD the latter is referenced in the CADD. For example the CADD of the overall composed application defines by way of the HasComponents relationship that the J2EE application data component is a part of the overall composed application.

The uses relationship specifies that the database server is accessed by the database client . Such dependencies which apply to a multi system scenario and therefore do not exist in the existing single system installers approaches provide a way of augmenting dependencies with meta information that facilitates a change management system to take the proper decisions. Each dependency type needs to be handled differently by a change management system. CADDs provide the necessary metadata.

In a preferred embodiment the system for generating deployment descriptors including at least an interaction observer as illustrated in an interaction pattern detector as illustrated in and a deployment descriptor generator as illustrated in is implemented as a background server process also referred to as a daemon that is listening for incoming requests. If a request for constructing a deployment descriptor is received in step from for example an administrator the deployment descriptor generator is invoked in step .

Input parameters are extracted from the request in step . Examples of such parameters may include but are not limited to whether a deployment descriptor for the entire distributed computing system is requested or whether the request applies only to parts of the overall system. Additional examples of input parameters may include the name of the component or components to which the change applies the system names and the change management operation.

The component interactions of the staging system are recorded in step by way of invoking the interaction observer which monitors observes and captures all transactions that the staging system is executing. The recorded component interactions are submitted to the interaction pattern detector which extracts one or more patterns from the data stream in step thereby significantly reducing the volume of data and identifying the characteristic data flow structure throughout the observed system. The identified interaction patterns are sent in step to the deployment descriptor generator a purpose of which may be for example to transform the interaction pattern or patterns into a dependency model in step and determine task relationships and relationship constraints for example finish to finish FF finish to start FS start to finish SF and start to start SS in step . Also the deployment descriptor generator may perform task consolidation to construct the deployment descriptor in step in a machine readable format such as an extensible markup language XML based language.

Additionally the deployment descriptor may be stored in step in a deployment descriptor library as illustrated in for subsequent reuse. Once the deployment descriptor for a given request has been generated and stored the system may in one or more embodiments of the invention proceed back to step to await further requests. A preferred embodiment of the invention allows the construction of deployment descriptor for both install type scenarios for example change management operations such as install deploy start and update and uninstall type scenarios for example change management operations such as uninstall undeploy stop and undo from the same set of interaction patterns. Also in a preferred embodiment of the invention the techniques may be invoked concurrently in order to service multiple requests at once.

An exemplary element may include an interaction observer . An interaction observer is contained in the same hosting environments for example operating system Servlet Enterprise JavaBeans EJB container as the distributed components and it tracks the invocation of operations on other components over time. In two invocations and at different points in time visualized by the solid and dashed arrows of component A lead to an invocation of component B which results in further interactions with component C component D which leads to an interaction with component E .

Another exemplary element may include an interaction pattern detector . An interaction pattern detector inputs the tracking data generated by the interaction observer . In the two invocations of component A and solid and dashed arrows respectively lead to further invocations with components B C D and E . However since the invocation pattern is identical the interaction pattern detector consolidates these interactions into a single interaction pattern.

Yet another exemplary element may include a deployment descriptor generator . A deployment descriptor generator inputs the data of the interaction pattern detector and constructs a deployment descriptor which may for example have the structure of a directed graph. Also the deployment descriptor generator takes into account both the component containment hierarchy as well as the different change management operations by annotating the relationship constraints in a deployment descriptor either for every single change management operation and or change management pattern. Consequently newly constructed nodes in the dependency graph include the name of the component and are tagged with the type of change management operation.

For purposes of completeness one or more embodiments of the present invention may also include an administrator .

Also another exemplary element may include a deployment descriptor library . A deployment descriptor library is a repository for storing newly constructed deployment descriptors for subsequent reuse and processing.

In a preferred embodiment a pattern extraction algorithm identifies interactions that have a causal relationship. There are many methods in the existing approaches to detect a causal relationship. In a preferred embodiment we consider two interactions related by causality if the first interaction causes an event on a system in the same thread as a second interaction on the same system. There are other methods to establish causality such as for example the propagation of an explicit correlation identifier.

As used herein transaction refers to a set of all interactions related by causality. As used herein the term transaction is used in a different way than what is sometimes defined in the context of databases or atomic actions. By way of example a transaction may include a sequence of messages and invocations initiated by an action such as for example booting up a machine. A transaction typically passes through one or more components and may branch off. Therefore the structure of a transaction may be a tree. One or more embodiments of the invention process a set of transactions as trees and categorize them into groups or subsets.

One skilled in the relevant art will appreciate that it is possible to use similar algorithms to extract patterns from a large amount of interactions recorded by the interaction observer . An exemplary result of a pattern extraction is illustrated on the right side of .

By way of example depicts that computing system X plays the role of a web application server and hosts a number of components described below. The electronic enterprise e enterprise application which may for example be implemented by a total of 14 servlets. Servlets may include for example BuyRequest buyreq AdministratorConfiguration admcnf AdministratorRequest admreq BestSellers bestsell BuyConfirmation buyconf CustomerRegistration custreg home NewProducts newprod ProductDetails proddet SearchResults srchres ShoppingCart shopcart SearchRequest srchreq OrderInquiry orderinq and OrderDisplay ordrdisp . As illustrated in the example of each servlet corresponds to a possible transaction on a website. For example the specific example website used in is a bookseller s web storefront but one or more embodiments of the present invention could be used with any other web application. By way of example some of the servlets may encapsulate the business logic of the application.

The servlet container may be implemented for example by IBM WebSphere Application Server WAS servlet container. The operating system OS may be for example Linux version 7.2.

Computing system Y plays the role of a database server and can host a variety of components as described below. In one embodiment of the present invention the components may include ten database tables. Database tables may include for example credit card transaction table cc xacts ShoppingCartLineItem shop cart L ShoppingCart shop cart author item customer country address OrderLineItem order line and orders . Database tables may for example hold the data accessed by the servlets.

In one or more embodiments of the present invention the database tables reside within a database implemented for example by IBM DB2 Universal Database UDB version 8.1 and also within an operating system OS such as for example IBM Advanced Interactive Executive AIX version 5.1.

A request may be submitted for example by an administrator to the deployment descriptor generator specifying that two servlets BestSellers bestsell and OrderDisplay ordrdisp need to be installed on Host System X . This is one example of building a deployment descriptor for a partial system as only a subset of the overall distributed system considered for the construction of the deployment descriptor.

In one or more embodiments of the invention it may be assumed that the operating system is already present on host system X . In addition it may be assumed that operating system is already present on host system Y . Also in one or more embodiments of the invention it is assumed that the change management system is subject to an operational policy stating that a servlet container must be installed on a different system than a database that is ex location constraint .

The invocation of the deployment descriptor generator for a request yields one or more dependencies. By way of example various dependencies are depicted in by dashed lines. For example as illustrated in the bestsell servlet depends only on the servlet container on host system X . This dependency is illustrated by the arrow labeled . The ordrdisp servlet in contrast depends on both the servlet container on host system X as well as on the credit card transaction table CC XACTS on host system Y . The former dependency is illustrated by the arrow labeled and the latter dependency is illustrated by the arrow labeled . Consequently in the exemplary depiction of it would be advantageous to create a CADD for the following components by taking into account that they need to be installed on two or more systems bestsell servlet ordrdisp servlet servlet container CC XACTS table and database .

We now turn to which is a diagram illustrating task relationships and relationship constraints according to an embodiment of the present invention. In one or more embodiments of the invention a dependency model is needed in a granularity that specifies the one or more components required by each individual component. As such information is often not directly available the deployment descriptor generator generates this information as described below. The deployment descriptor generator invokes the interaction observer as well as the interaction pattern detector . The deployment descriptor generator also transforms the obtained interaction pattern into a dependency graph and also transforms the obtained interaction pattern into a CADD.

Different change management operations require different traversals through the dependency model. By way of example and not limitation a request for a new installation of a component leads the deployment descriptor generator to determine which components must already be present before a new component can be installed. On the other hand for example a request for an update or an uninstall of a component will result in determining the components that will either be impacted by the change or which need to be removed first to preserve the integrity of the system. by way of example illustrates the precedence and location constraints for an install type change management operation as in this example it is assumed that an installation has been requested. Different task relationships are generated for uninstall type task relationships if the administrator requests the construction of an uninstallation.

By way of another example if an installation change management operation needs to be carried out the consideration of the results of the relationship traversal carried out by the deployment descriptor generator yields that the tasks described below are subject to relationship constraints.

One having skill in the art will recognize that modifications in the way the task relationships are structured the way in which order the antecedents and dependents appear therein as well as the way in which they are represented may be made without departing from the spirit and scope of the present invention. In particular the fields antecedent change management operation precedence constraint dependent and location constraint may be written as a data structure corresponding to a quintuple or 5 tuple.

In one or more embodiments of the invention the deployment descriptor generator observes rules as described below.

For purposes of completeness rows and may include the ordrdisp Servlet component and the bestsell Servlet component respectively.

By following the above rules the deployment descriptor generator is able to consolidate the component relationships depicted in into a composed application deployment descriptor.

Without loss of generality we note that similar logic can be applied to UNINSTALL type operations. In addition one or more embodiments of the present invention are capable of producing a deployment descriptor for a set of change management operations for example install start stop uninstall configure etc. in order to address the construction of a CADD that accounts for the full lifecycle of all involved components. One having skill in the art will recognize that modifications in the way the CADD is structured and in which order antecedents and dependents appear in it as well as their representation may be made without departing from the spirit and scope of the present invention. For example a semantically identical representation of row is to name the dependent first in column to change the precedence constraint to after in column and insert the antecedent in column . In addition a precedence constraint may be in the form of FF SS SF or FS instead of using the more conversational before used for illustrative purposes in .

We now turn to which is a flow diagram illustrating techniques for constructing a deployment descriptor according to an embodiment of the present invention. In one or more embodiments of the invention the algorithm begins at step and includes additional steps as described below. Upon receipt of a new request the deployment descriptor generator extracts the relevant parameters from the request in step . Examples of a parameter may include whether the construction of a deployment descriptor for the entire distributed computing system is requested or whether the request applies only to parts of the overall system. Additional exemplary parameters may include the name of the component or components that need to be changed the computing system names and the change management operation or operations.

In one or more embodiments of the present invention an administrator can specify a list of one or more change management operations in the request so that the generated CADD includes relationship specifications that account for the full lifecycle for example install uninstall start stop etc. of all components that are aggregated into a composed application.

The interaction pattern is obtained from the interaction pattern detector in step and transformed into a dependency model in step . Different procedures are applied according to the type of change management operation specified in the request submitted by the administrator. For example a request may specify an install change management operation in step an uninstall change management operation in step or a configure change management operation in step . One skilled in the relevant art will recognize that modifications and extensions of the change management operations may be made without departing from the spirit and scope of the invention.

In the example of a request specifying an install change management operation in step the deployment descriptor generator would perform a recursive drill down operation on the dependency model in step . A list of components to be installed would be returned as well.

In the example of a request may specify an uninstall change management operation in step the deployment descriptor generator would perform a recursive drill up operation on the dependency model in step to retrieve a list of components that would be impacted by the update change management operation.

In the example of a request may specify a configure change management operation in step the deployment descriptor generator would perform a recursive drill up operation on the dependency model in step to retrieve a list of components that would be impacted by the configure change management operation.

Depending on what change management operation is specified in the request the deployment descriptor generator would also create the task relationships as well as the relationship constraints in step from the data contained in the dependency model. The deployment descriptor generator also annotates the component relationships with precedence and locations constraints in step as well as generating a deployment descriptor in step . The deployment descriptor is persistently stored in the deployment descriptor library in step and returned to the administrator for further processing.

Also the deployment descriptor generator may verify whether one or more new requests have arrived in step for which the procedure needs to be repeated. If a new request has arrived one or more embodiments of the invention will retrieve a new request in step and transition via step to step . If a new request has not arrived one or more embodiments of the present invention will end at step .

In one or more embodiments of the present invention the dependency model contains a list of component 5 tuples. The overall list of 5 tuples is referred to herein as a candidate list. In one or more embodiments of the invention it is assumed that every 5 tuple contains first the antecedent and then the dependent component each prefixed with the name of the change management operation the administrator has specified in the request. Every 5 tuple includes the antecedent the change management operation the precedence constraint for example FS SS SF and FF the dependent and a location constraint. One skilled in the art will recognize that modifications and extensions to the way the dependency graph is represented may be made without departing from the spirit and scope of the invention.

As illustrated in one or more embodiments of the invention determine if the list of candidates is empty that is no 5 tuples are present in step . If the list of candidates contains one or more 5 tuples a 5 tuple is selected from the candidate list in step . No assumptions are being made with respect to the order of the 5 tuples in the candidate list. Also the 5 tuple selection can happen in any order since the candidate list is essentially an unordered set of 5 tuples.

One or more embodiments of the present invention also determine if the 5 tuple is empty that is no elements are present in step . If the 5 tuple is empty the 5 tuple is removed from the candidate list in step . If the 5 tuple is not empty the algorithm selects an antecedent from the 5 tuple and proceeds with determining if the antecedent already exists in the CADD in step . If the antecedent does not exist in the CADD the antecedent is inserted into the CADD under the scope of the composed application in step . One or more embodiments of the invention also determine if the dependent from the 5 tuple already exists within the scope of the antecedent in step .

If the dependent does not exist within the scope of the antecedent the algorithm creates an entry for the dependent within the scope of the antecedent in step and subsequently proceeds with determining if the change management operation already exists within the scope of the antecedent and dependent in step . If change management operation does not already exist within the scope of the antecedent and dependent the change management operation is accordingly inserted in the CADD in step . Then the algorithm checks for a duplicate or inconsistent entry for the location constraint by determining if a location constraint already exists within the scope of the antecedent the dependent and the change management operation in step .

From the existence of a location constraint alone in the appropriate scope the algorithm can safely assume that either a duplicate or inconsistent entry is present and proceeds directly with removing the already created parts of the new entry in step and subsequently removes the 5 tuple altogether from the candidate list in step . If however no location constraint is present in the CADD the algorithm proceeds to step and inserts the location constraint in the CADD. Then the algorithm carries out its last check in step by verifying if for a given entry the precedence constraints are identical. If the precedence constraints are identical an inconsistent entry is detected which yields the algorithm to proceed to step which removes the new entry from the CADD. Otherwise the algorithm proceeds to step and inserts the new precedence constraint into the CADD before continuing at step with the removal of the already processed 5 tuple from the candidate list.

In one or more embodiments of the invention the algorithm proceeds to step and determines if the procedure needs to be repeated for one or more additional 5 tuples contained in the candidate list. If however no more 5 tuples remain for processing that is the list of candidates is empty the completed deployment descriptor is stored in the deployment descriptor library in step . The algorithm ends at step .

The following table depicts examples of deployment descriptor generator application programming interfaces APIs . The table includes base APIs that can generate send and request receipt of partial orders of change management tasks for a given service and host name. Those skilled in the art will appreciate that the APIs can use one or more parameters either shown not shown or in any combination thereof to identify characteristics as for example specified in the Functional Description used by the APIs.

Specifically the constructDeploymentDescriptorForInstall parameters API builds the deployment descriptor for the install change management operation based on a recursive drill down and carried out by the dependency service. The constructDeploymentDescriptorForUpdate parameters API builds the deployment descriptor for the update change management operation by invoking a recursive drill up on the dependency service. That is it retrieves all the dependents of a given component for example the components in the dependency hierarchy that are likely to be affected by an update change management operation . The constructDeploymentDescriptorForUninstall parameters API builds the deployment descriptor for the uninstall change management operation. The constructDeploymentDescriptorForRollback parameters API builds the deployment descriptor for the rollback change management operation which is the opposite operation of update and restores the previously updated version of a component. The constructDeploymentDescriptorForInitialConfigure parameters API builds the deployment descriptor for the initial configure change management operation which applies basic configuration settings to a component which are needed to install it in the first place. The constructDeploymentDescriptorForConfigure parameters API builds the deployment descriptor for the configure change management operation which applies advanced configuration settings to a component so that it can be customized.

One or more embodiments of the present invention may also include associating the at least one relationship specification with at least one component. In one or more embodiments of the present invention associating the at least one relationship specification with at least one component may include inserting a relationship specification into for example a software package associating the relationship specification with a newly created service and shipping the relationship specification on a compact disc CD with a hardware component. The step of creating at least one relationship specification may also include creating at least one relationship specification for consumption of at least one of software installers and service provisioning systems.

In one or more embodiments of the present invention the step of consolidating the at least one interaction into at least one interaction pattern includes taking into account a component containment hierarchy and at least one relationship between the two or more components. A component containment hierarchy and at least one relationship between the two or more components may be expressed for example as at least one of a manifest file and a deployment descriptor. Also in one or more embodiments of the invention a component containment hierarchy and at least one relationship between the two or more components are stored in a global system configuration repository that addresses at least one of the following one or more different packaged software products one or more services one or more software components one or more service components and one or more computing systems. Additionally components for example software products or services middleware hardware etc. may be located on the same system or located on different systems.

In one or more embodiments of the present invention the techniques may include the steps including the at least one relationship specification in at least one of an installable package and or media in the form of at least one deployment descriptor a local repository as a relationship model and a global repository as a relationship model. Also in one or more embodiments of the present invention the deployment descriptors are the means by which dependencies are expressed and may contain both containment hierarchy and relationships. The deployment descriptors may for example be associated with one or more components and provide meta information about the components such as for example dependencies identification version info etc. Additionally the deployment descriptors may for example be consumed by installers and or provisioning systems to enable it to carry out prerequisite and or compatibility validity checks whenever a request for change is submitted. Also once the software is deployed and or installed the topology of the installed application is persisted in for example a global or local system configuration repository along with predefined information on how to uninstall the entire system. In one or more embodiments of the invention this information is in the generated deployment descriptor as well. In a preferred embodiment of the invention the relationship specification may either be included on an installation media CD in the form of a deployment descriptor or in a local global repository as an object and or relationship model.

Also one or more embodiments of the invention may be performed within an integrated development environment IDE or may also be performed within a hosting environment. Additionally in one or more embodiments of the present invention the at least one relationship specification comprises at least one of a name of at least one component and a 5 tuple comprising one or more fields representing one or more of an antecedent a change management operation a precedence constraint a dependent and a location constraint

In one or more embodiments of the invention the at least one deployment descriptor is stored in a deployment descriptor library.

A variety of techniques utilizing dedicated hardware general purpose processors firmware software or a combination of the foregoing may be employed to implement one or more embodiments of the present invention. One or more embodiments of the invention can be implemented in the form of a computer product including a computer useable medium with computer useable program code for performing the method steps indicated. Furthermore one or more embodiments of the invention can be implemented in the form of an apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps.

One implementation of the present invention makes substantial use of software running on a general purpose computer or workstation. With reference to such an implementation might employ for example a processor a memory and an input and or output interface formed for example by a display and a keyboard . The term processor as used herein is intended to include any processing device such as for example one that includes a CPU central processing unit and or other forms of processing circuitry. Further the term processor may refer to more than one individual processor. The term memory is intended to include memory associated with a processor or CPU such as for example RAM random access memory ROM read only memory a fixed memory device for example hard drive a removable memory device for example diskette a flash memory and the like. In addition the phrase input and or output interface as used herein is intended to include for example one or more mechanisms for inputting data to the processing unit for example mouse and one or more mechanisms for providing results associated with the processing unit for example printer . The processor memory and input and or output interface such as display and keyboard can be interconnected for example via bus as part of a data processing unit . Suitable interconnections for example via bus can also be provided to a network interface such as a network card which can be provided to interface with a computer network and to a media interface such as a diskette or CD ROM drive which can be provided to interface with media .

Accordingly computer software including instructions or code for performing the methodologies of the invention as described herein may be stored in one or more of the associated memory devices for example ROM fixed or removable memory and when ready to be utilized loaded in part or in whole for example into RAM and executed by a CPU. Such software could include but is not limited to firmware resident software microcode and the like.

Furthermore the invention can take the form of a computer program product accessible from a computer useable or computer readable medium for example media providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer useable or computer readable medium can be any apparatus for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory for example memory magnetic tape a removable computer diskette for example media a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read and or write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code is retrieved from bulk storage during execution.

Input and or output or I O devices including but not limited to keyboards displays pointing devices and the like can be coupled to the system either directly such as via bus or through intervening I O controllers omitted for clarity .

Network adapters such as network interface may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

In any case it should be understood that the components illustrated herein may be implemented in various forms of hardware software or combinations thereof for example application specific integrated circuit s ASICS functional circuitry one or more appropriately programmed general purpose digital computers with associated memory and the like. Given the teachings of the invention provided herein one of ordinary skill in the related art will be able to contemplate other implementations of the components of the invention.

Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings it is to be understood that the invention is not limited to those precise embodiments and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention.

