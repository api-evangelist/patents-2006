---

title: Method and apparatus for indexing, searching and displaying data
abstract: A computer research tool for indexing, searching and displaying data is disclosed. Specifically, a computer research tool for performing computerized research of data including textual objects in a database or a network and for providing a user interface that significantly enhances data presentation is described. Textual objects and other data in a database or network is indexed by creating a numerical representation of the data. The indexing technique called proximity indexing generates a quick-reference of the relations, patterns and similarity found among the data in the database. Proximity indexing indexes the data by using statistical techniques and empirically developed algorithms.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07840524&OS=07840524&RS=07840524
owner: Software Rights Archive LLC
number: 07840524
owner_city: Marshall
owner_country: US
publication_date: 20060417
---
This is a divisional of U.S. patent application Ser. No. 09 854 577 filed May 15 2001 which is a divisional of U.S. patent application Ser. No. 09 071 120 filed May 4 1998 now U.S. Pat. No. 6 233 571 issued May 15 2001 which is a divisional of U.S. patent application Ser. No. 08 649 304 filed May 17 1996 now U.S. Pat. No. 5 832 494 issued Nov. 3 1998 which is a CIP of U.S. patent application Ser. No. 08 076 658 filed Jun. 14 1993 now U.S. Pat. No. 5 544 352 issued Aug. 6 1996 which is incorporated herein by reference in its entirety.

This invention pertains to computerized research tools. More particularly it relates to computerized research on databases. Specifically the invention indexes data searches data and graphically displays search results with a user interface.

Our society is in the information age. Computers maintaining databases of information have become an everyday part of our lives. The ability to efficiently perform computer research has become increasingly more important. Recent efforts in the art of computer research have been aimed at reducing the time required to accomplish research. Computer research on non textual objects is very limited. Current computer search programs use a text by text analysis procedure Boolean Search to scan a database and retrieve items from a database. The user must input a string of text and the computer evaluates this string of text. Then the computer retrieves items from the database that match the string of text. The two popular systems for computerized searching of data used in the legal profession are Westlaw a service sold by West Publishing Company 50 W. Kellogg Blvd. P.O. Box 64526 St. Paul Minn. 55164 0526 and Lexis a service sold by Mead Data Central P.O. Box 933 Dayton Ohio 45401.

However Boolean searches of textual material are not very efficient. Boolean searches only retrieve exactly what the computer interprets the attorney to have requested. If the attorney does not phrase his or her request in the exact manner in which the database represents the textual object the Boolean search will not retrieve the desired textual object. Therefore the researcher may effectively by denied access to significant textual objects that may be crucial to the project on which the researcher is working. A second problem encountered with Boolean searches is that the search retrieves a significant amount of irrelevant textual objects. It should be noted that in the context of research a textual object could be any type of written material. The term textual object is used to stress the fact that the present invention applies to all types of databases. The only requirement that a textual object must satisfy in order to be selected by a Boolean search program is that part of the textual object match the particular request of the researcher. Since the researcher cannot possibly know all of the groupings of text within all the textual objects in the database the researcher is unable to phrase his request to only retrieve the textual objects that are relevant.

Aside from the inefficiency of Boolean searches the present systems for computerized searching of data are inadequate to serve the needs of a researcher for several other reasons. Even if one assumes that all the textual objects retrieved from a Boolean search are relevant the listing of the textual objects as done by any currently available systems does not convey some important and necessary information to the researcher. The researcher does not know which textual objects are the most significant i.e. which textual object is referred to the most by another textual object or which textual objects are considered essential precedent i.e. which textual objects describe an important doctrine .

In the legal research field both Westlaw and Lexis have a Shepardizing feature that enables the researcher to view a list of textual objects that mention a particular textual object. The shepardizing feature does not indicate how many times a listed textual object mentions the particular textual object. Although the shepardizing feature uses letter codes to indicate the importance of a listed textual object e.g. an f beside a listed textual object indicates that the legal rule contained in particular textual object was followed in the listed textual object data on whether a listed textual object followed the rule of a particular textual object is entered manually by employees of Shepard s McGraw Hill Inc. Div. of McGraw Hill Book Co. 420 N. Cascade Ave. Colorado Springs Colo. 80901 toll free 1 800 525 2474. Such a process is subjective and is prone to error.

Another legal research system that is available is the Westlaw key number system. The Westlaw key number system has problems similar to the shepardizing feature on the Lexis and Westlaw systems. The video displays of both the West and Lexis systems are difficult to use. The simple text displays of these systems do not provide a researcher with all the information that is available in the database.

Computerized research tools for legal opinions and related documents are probably the most sophisticated computer research tools available and therefore form the background for this invention. However the same or similar computer research tools are used in many other areas. For example computer research tools are used for locating prior art for a patent application. The same problems of inefficiency discussed above exist for computer research tools in many areas of our society.

What is needed is a system for computerized searching of data that is faster than the available systems of research.

What is needed is a system for computerized searching of data that enables researchers to research in a manner in which they are familiar.

What is needed is a computerized research tool that will reorganize re index or reformat the data into a more efficient format for searching.

What is needed is a system for computerized searching of data that will significantly reduce the number of irrelevant textual objects it retrieves.

What is needed is a system for computerized searching of data that easily enables the researcher to classify the object according to his or her own judgment.

What is needed is a system for computerized searching of data that provides a visual representation of lead objects and lines of objects permitting a broad overview of the shape of the relevant landscape. 

What is needed is a system for computerized searching of data that provides an easily grasped picture or map of vast amounts of discrete information permitting researchers to zero in on the most relevant material.

What is needed is a system for computer searching of data that provides a high degree of virtual orientation and tracking the vital sense of where one has been and where one is going and that prevent researchers from becoming confused while assimilating a large amount of research materials.

Accordingly there is an unanswered need for a user friendly computerized research tool. There is a need for research technology that emulates human methods of research. There is a need in the marketplace for a more efficient and intelligent computerized research tool.

This invention is a system for computerized searching of data. Specifically the present invention significantly aids a researcher in performing computerized research on a database or a network. The invention simplifies the research task by improving upon methods of searching for data including textual objects and by implementing a user interface that significantly enhances the presentation of the data.

The invention can be used with an existing database by indexing the data and creating a numerical representation of the data. This indexing technique called proximity indexing generates a quick reference of the relations patterns and similarity found among the data in the database. Using this proximity index an efficient search for pools of data having a particular relation pattern or characteristic can be effectuated. This relationship can then be graphically displayed.

There are three main components to the invention a data indexing applications program a Computer Search Program for Data Represented by Matrices CSPDM and a user interface. Each component may be used individually. Various indexing application programs CSPDMs and user interface programs can be used in combination to achieve the desired results. The data indexing program indexes data into a more useful format. The CSPDM provides efficient computer search methods. The preferred CSPDM includes multiple search subroutines. The user interface provides a user friendly method of interacting with the indexing and CSPDM programs. The preferred user interface program allows for easy entry of commands and visual display of data via a graphical user interface.

The method which the invention uses to index textual objects in a database is called Proximity Indexing. This method can also be used to index objects located on a network. The application of this method to network domains is discussed in greater detail later in this specification. Proximity Indexing is a method of preparing data in a database for subsequent searching by advanced data searching programs. Proximity Indexing indexes the data by using statistical techniques and empirically developed algorithms. The resulting search by an advanced data searching program of the Proximity Indexed data is significantly more efficient and accurate than a simple Boolean search.

The Proximity Indexing Application Program indexes or represents the database in a more useful format to enable the Computer Search Program for Data Represented by Matrices CSPDM to efficiently search the database. The Proximity Indexing Application Program may include one or more of the following subroutines an Extractor a Patterner and a Weaver. The Proximity Indexing Application Program indexes or represents data in a locally located database or remotely located database. The database can contain any type of data including text alphanumerics or graphical information.

In one embodiment the database is located remotely from the Computer Processor and contains some data in the form of textual objects. The Proximity Indexing Application Program indexes the textual objects by determining how each full textual object e.g. whole judicial opinion statute etc. relates to every other full textual object by using empirical data and statistical techniques. Once each full textual object is related to each other full textual object the Proximity Indexing Application Program compares each paragraph of each full textual object with every other full textual object as described above. The Proximity Indexing Application Program then clusters related contiguous paragraphs into sections. Subsequently the Proximity Indexing Application Program indexes each section and the CSPDM evaluates the indexed sections to determine which sections to retrieve from the database. Such organization and classification of all of the textual objects in the database before any given search commences significantly limits the irrelevant textual objects that the CSPDM program retrieves during the subsequent search and allows retrieval of material based on its degree of relevancy.

In a preferred embodiment the Proximity Indexing Application Program includes a link generation subroutine wherein direct and indirect relationships between or among data is used to generate a representation of the data. Generally direct and indirect relationships in the database are identified as links and placed in a table.

Again this method of computerized research can be used for nearly any database including those containing non textual material graphical material newspapers material data on personal identification data concerning police records etc.

The remaining two programs in the present invention are the CSPDM and the GUI Program. The CSPDM has seven subroutines that each search for different pools of objects. The GUI Program also has seven subroutines. Each CSPDM subroutine performs a different type of search. Each of the subroutines of the GUI uses the results of the corresponding subroutine of the CSPDM to create the proper display on the display.

After the Proximity Indexing Application Program indexes a database the CSPDM application program is used to search the indexed database. For example the CSPDM program can either be located in memory that is remote from the Computer Processor or local to the Computer Processor. In addition the CSPDM program can either be remote or local in relation to the database.

The subroutines of the CSPDM utilize the coefficients and other data created by the Proximity Indexing Application Program to facilitate its search. However if the researcher does not have the particular object citation available the researcher can perform a Boolean search to retrieve and organize a pool of objects. Alternatively the researcher can subsequently search for related objects by using the Pool Similarity Subroutine the Pool Paradigm Subroutine the Pool Importance Subroutine or the Pool Paradigm Similarity Subroutine as defined below.

If the researcher already has the citation of a particular object available the researcher can search for related objects by utilizing the Cases In Subroutine Cases After Subroutine or Similar Cases Subroutine. The Cases In Subroutine retrieves all of the objects from the database to which a selected object refers. In addition the subroutine determines the number of times the selected object refers to each retrieved object and other characteristics of each object including its importance and degree of relatedness to the selected object.

The Cases After Subroutine retrieves all of the objects from the database that refer to the selected object. Also the subroutine determines the number of times each retrieved object refers to the selected object and other characteristics of each object including its importance and degree of relatedness to the particular object to which it refers.

The Similar Cases Subroutine determines the degree of similarity between the retrieved objects and the selected object. Similarity may be defined in the context of legal cases as the extent to which the two objects lie in the same lines of precedent or discuss the same legal topic or concept. Numerous other relationships may be used to define similarity.

In addition for a textual object if the researcher does not know of a particular textual object on which to base his or her search the researcher may execute a Boolean word search. After a standard Boolean word search has been run the researcher may run the Pool Similarity Subroutine to retrieve information containing the degree of similarity between each textual object in the pool and a particular textual object selected by the user. Similarly the Pool Importance Subroutine can be used to determine the degree of importance i.e. whether a judicial opinion is a Supreme Court opinion or a District Court opinion and other characteristics of each textual object retrieved using the Boolean word search.

The Pool Paradigm Subroutine calculates the geographic center in vector space of the pool of textual objects retrieved by the Boolean word search or other pool generating method. It then orders the retrieved textual objects by their degree of similarity to that center or paradigm. The researcher can then evaluate this typical textual object and utilize it to help him or her find other relevant textual objects. In addition the researcher can scan through neighboring typical textual objects to evaluate legal subjects that are closely related to the subject of the researcher s search.

The Pool Paradigm Similarity Subroutine similarly creates a paradigm textual object from the retrieved textual objects. However the subroutine calculates the similarity of all textual objects in the database to the paradigm textual object in addition to the similarity of the retrieved textual objects to the paradigm textual object.

After the CSPDM has retrieved the desired objects the Graphical User Interface GUI Program may be used to display the results of the search on the display. In one embodiment the GUI is a user interface program. The GUI Program contains three main subroutines Cases In Display Subroutine CIDS Cases After Display Subroutine CADS and Similar Cases Display Subroutine SCDS . The main subroutines receive information from the corresponding subroutines Cases In Cases After and Similar Cases of the CSPDM. The GUI Program also contains four secondary subroutines Pool Similarity Display Subroutine PSDS Pool Paradigm Display Subroutine PPDS Pool Importance Display Subroutine PIDS and the Pool Paradigm Similarity Subroutine PPSDS . The secondary subroutines also receive information from the corresponding subroutines Pool Similarity Subroutine Pool Paradigm Subroutine Pool Importance Subroutine and the Pool Paradigm Similarity Subroutine of the CSPDM.

The CIDS subroutine receives information gathered from the Cases In Subroutine of the CSPDM. The CIDS subroutine displays user friendly active boxes and windows on the display which represent the textual objects retrieved from the database represented in Euclidean space. It can also use the boxes to represent objects retrieved from a network. Various active box formats and arranging of information within the boxes may be utilized. The display depicts the appropriate location of textual objects in Euclidean space on a coordinate means. An algorithm may be used to determine the appropriate location of the boxes. The coordinate means may have one or more axis. In one embodiment the horizontal axis of the coordinate means may represent the time of textual object creation the vertical axis could represent a weighted combination of the number of sections in which that particular retrieved text is cited or discussed its degree of importance and its degree of similarity to the host textual object and the depth axis Z axis represents the existence of data and length of the textual data or object.

The invention can also alter the background color of the window itself to communicate additional information graphically to the user. For example if the horizontal axis represented time then the invention could display the portion of the window containing objects occurring previous to the search object in one color and the portion containing the objects occurring after in another. Thus the researcher can understand at a glance the relative position of his search target in relation to all the other objects related to it.

CIDS also enables the researcher to open up various active boxes on the display by entering a command into the computer processor with the input means. After entering the proper command the active box transforms into a window displaying additional information about the selected textual object. These windows can be moved about the display and stacked on top or placed beside each other via the input means to facilitate viewing of multiple windows of information simultaneously. In one embodiment the windows are automatically arranged by the computer system. Since the number of textual objects retrieved in a single search may exceed the amount which could be displayed simultaneously the GUI Program enables the researcher to zoom in or zoom out to different scales of measurement on both the horizontal and vertical axis.

The CADS receives information gathered by the Cases After Subroutine of the CSPDM. The CADS creates a display similar to the CIDS display. However the active boxes representing the retrieved textual objects indicate which textual objects in the database refer to a selected textual object as opposed to which textual objects a selected textual object refers.

The SCDS receives information gathered by the Similar Cases Subroutine of the CSPDM. The SCDS causes a similar display on the display as the CIDS and the CADS except that the vertical axis indicates the degree of similarity between the retrieved textual objects and the selected textual object.

The GUI Program contains four secondary subroutines Pool Search Display Subroutine PSDS Pool Paradigm Display Subroutine PPDS Pool Importance Display Subroutine PIDS and the Pool Paradigm Similarity Display Subroutine PPSDS . The PSDS receives the results gathered by the Pool Search Subroutine of the CSPDM. The PPDS receives the results gathered by the Pool Paradigm Subroutine of the CSPDM. The PIDS receives the results gathered by the Pool Importance Subroutine of the CSPDM. The PPSDS receives the results gathered by the Pool Paradigm Similarity Subroutine of the CSPDM. The results of the PSDS PPDS PIDS and PPSDS are then displayed in a user friendly graphical manner similar to the results of the CIDS CADS and SCDS. A researcher can access the PSDS PIDS PSDS or PPSDS from any of the three main or four secondary subroutines of the GUI to gather information corresponding to the active boxes that represent the pool of textual objects retrieved by the corresponding subroutine of the CSPDM.

By using the graphical display the researcher can view immediately a visual representation of trends in the data for example trends developing in the law and current and past legal doctrines . In addition the researcher can immediately identify important data or important precedent and which object serving as the precedent is most important to the project on which the researcher is working. This visual representation is a vast improvement over the current computerized research tools. Furthermore the researcher using the present invention does not have to rely on the interpretation of another person to categorize different textual objects because the researcher can immediately visualize the legal trends and categories of law. In addition new topic areas can be recognized without direct human intervention. The current research programs require a researcher to view objects in a database or to read through the actual text of a number of objects in order to determine which objects are important interrelated or most closely related to the topic at hand and which ones are not.

It is an object of this invention to create an efficient and intelligent system for computerized searching of data that is faster than available systems of research.

It is an object of the invention to integrate the system of computerized searching into the techniques to which researchers are already accustomed.

It is an object of the invention to utilize statistical techniques along with empirically generated algorithms to reorganize re index and reformat data in a database into a more efficient model for searching.

It is an object of the invention to utilize statistical techniques along with empirically generated methods to increase the efficiency of a computerized research tool.

It is an object of the invention to create a system of computerized searching of data that significantly reduces the number of irrelevant objects retrieved.

It is an object of this invention to create a user friendly interface for computer search tools which can convey a significant amount of information quickly.

It is an object of the invention to enable the researcher to easily and immediately classify retrieved database objects according to the researcher s own judgment.

It is an object of the invention to provide a visual representation of lead objects and lines of objects permitting a broad overview of the shape of the relevant landscape. 

It is an object of the invention to provide an easily grasped picture or map of vast amounts of discrete information permitting researchers to zero in on the most relevant material.

It is an object of the invention to provide a high degree of virtual orientation and tracking that enables a researcher to keep track of exactly what information the researcher has already researched and what information the researcher needs to research.

These and other objects and advantages of the invention will become obvious to those skilled in the art upon review of the description of a preferred embodiment and the appended drawings and claims.

The Computer Processor can be a processor that is typically found in Macintosh computers IBM computers portable PCs clones of such PC computers e.g. Dell computers any other type of PC or a processor in a more advanced or more primitive computing device. Parallel processing techniques may also be utilized with this invention.

The database is connected to the Computer Processor and can be any device which will hold data. For example the database can consist of any type of magnetic or optical storing device for a computer. The database can be located either remotely from the Computer Processor or locally to the Computer Processor . The preferred embodiment shows a database located remotely from the Computer Processor that communicates with the personal computer via modem or leased line. In this manner the database is capable of supporting multiple remote computer processors . The preferred connection between the database and the Computer Processor is a network type connection over a leased line. It is obvious to one skilled in the art that the database and the Computer Processor may be electronically connected in a variety of ways. In the preferred embodiment the database provides the large storage capacity necessary to maintain the many records of textual objects.

The input means is connected to the Computer Processor . The user enters input commands into the Computer Processor through the input means. The input means could consist of a keyboard a mouse or both working in tandem. Alternatively the input means could comprise any device used to transfer information or commands from the user to the Computer Processor .

The display is connected to the Computer Processor and operates to display information to the user. The display could consist of a computer monitor television LCD LED or any other means to convey information to the user.

The Random Access Memory RAM is also connected to the Computer Processor . The software system for computerized searching of data may reside in the RAM which can be accessed by the Computer Processor to retrieve information from the software routines. A Read Only Memory ROM Erasable Programmable Read Only Memory EPROM disk drives or any other magnetic storage device could be used in place of the RAM . Furthermore the RAM may be located within the structure of the Computer Processor or external to the structure.

The hardware system for computerized searching of data shown in supports any one or any combination of the software programs contained in the software system for computerized searching of data. The software system for the computerized searching of data comprises one or more of the following programs the Proximity Indexing Application Program the Computer Search Program for Data Represented by Matrices CSPDM and the Graphical User Interface GUI Program. The Proximity Indexing Application Program could reside in RAM or in separate memory connected to the database . The Computer Processor or a separate computer processor attached to the database could execute the Proximity Indexing Application Program . In the preferred embodiment the Proximity Indexing Application Program resides in separate memory that is accessible to the database and a separate computer processor attached to the database executes the Proximity Indexing Application Program .

The CSPDM could reside in the RAM connected to the Computer Processor or in the separate memory connected to the database . In the preferred embodiment the CSPDM is located in the RAM connected to the Computer Processor . This is also the preferred embodiment for the application of this method to network searching. For network application a separate database storing information to be analyzed is remodeling connected to the computer processor . The CSPDM may use the display to depict input screens for user entry of information.

The GUI Program could likewise reside in the RAM connected to the Computer Processor or in separate memory connected to the database . In the preferred embodiment the GUI Program is located in the RAM connected to the Computer Processor . The GUI Program also communicates with the display to enhance the manner in which the display depicts information.

After the Proximity Indexing Application Program indexes the database the CSPDM application program can adequately search the database . The CSPDM program searches the database for objects according to instructions that the user enters into the Computer Processor via the input means. The CSPDM then retrieves the requested objects. The CSPDM either relays the objects and other information to the GUI program in order for the GUI program to display this information on the display or the CSPDM sends display commands directly to the Computer Processor for display of this information. However in the preferred embodiment the CSPDM relays the objects and other commands to the GUI Program . The CSPDM is described in more detail in .

After the CSPDM has retrieved the objects the Graphical User Interface GUI Program which is a user interface program causes the results of the search to be depicted on the display . The GUI Program enhances the display of the results of the search conducted by the CSPDM . The GUI Program its method and operation can be applied to other computer systems besides a system for computerized searching of data. The GUI Program is described in more detail in .

A node is any entity that can be represented by a box on a display such as a GUI . A node might be for example an object in a database a portion of an object in a database a document a section of a document a World Wide Web page or an idea or concept such as a topic name. A node need not represent any physical entity such as an actual document. It is preferred that a node have links specifically it is preferred that a node have links to other nodes for example source links a source link is a link or influence links an influence link is a link . A node can represent any idea or concept that has links to other ideas or concepts. For example two nodes can exist such as a node called Modern Architecture not shown and a node called Classical Architecture not shown and the links would show that Classical Architecture is a source for Modern Architecture and that Modem Architecture is influenced by Classical Architecture. In this example a source link and an influence link would exist between the two nodes . Many times links represent inverse relationships such as source links and influence links and one type of link may be derived or generated from analysis of another link. 

More specifically in the preferred embodiment the software defines a node as something that has a unique node identification a node type a node subtype and an associated date or plot date . Node types or subtypes may have names or identifications title descriptors and external attributes. A node may have a corresponding numerical representation assigned a vector a matrix or a table. In the preferred embodiment a table format is used for the nodes.

Referring to F and G a link is another name or identification for a relationship between two nodes . The relationship may be semantical non semantical stated implied direct indirect actual statistical and or theoretical. A link can be represented by a vector or an entry on a table and contain information for example a from node identification ID a to node ID a link type and a weight . A group of links may be represented by a series of vectors or entries in a table a link table. Link subtypes may be used named and assigned comments.

In addition to better integrate the GUI and the data representation visual styles may be assigned for example to nodes links link types and link subtypes to assist in the visual displays .

In the preferred embodiment three types of links are used source links influence links and duster links . Source links generally link a first node to second node that represents information or documentation specifically cited or referred to by the first node . Influence links are generally the inverse of a source link . The relationships represented by these links may be explicit or implied.

Links and nodes may be manually entered by a user or automatically generated by a computer . It is preferred that cluster links be generated automatically by a processor. A cluster link is a relationship between two nodes for example two nodes both directly linked to the same intermediate nodes may be indirectly linked through many paths and therefore have a cluster link between them. The cluster links may be determined using the specific or general methods described later for finding relationships in a database . However the preferred method is through using a Proximity Indexing Application Program.

 Proximity indexing is a method of indexing that uses statistical techniques and empirically generated algorithms to organize and categorize data stored in databases or on a network. The Proximity Indexing Application Program applies the Proximity indexing method to a database . One embodiment of the present invention uses the Proximity Indexing Application Program to Proximity index textual objects used for legal research by indexing objects based on their degree of relatedness in terms of precedent and topic to one another.

Applying the method to legal research the Proximity indexing system treats any discrete text as a textual object. Textual objects may contain citations which are explicit references to other textual objects. Any legal textual object may have a number of different designations of labels. For example 392 U.S. 1 102 S.Ct 415 58 U.S.L.W. 1103 etc. may all refer to the same textual object.

Cases are full textual objects that are not subsets of other textual objects. Subjects of a full textual object include words phrases paragraphs or portions of other full textual objects that are referred to in a certain full textual object. The system does not treat textual objects as subsets of themselves. 

Every case or full textual object is assigned a counting number name designated by a letter of the alphabet in this description corresponding to its chronological order in the database . Obviously textual objects may contain citations only to textual objects that precede them. In other words for full textual objects if B cites A i.e. A is an element of B or the set B contains the name A textual object A came before B or symbolically A

Textual objects other than full textual objects may be subsets of full textual objects and of each other. For example a section page or paragraph of text taken from a longer text may be treated as a textual object. Phrases and words are treated as a special kind of textual object where Q w 0. Sections pages and paragraphs are generally subsets of only one full textual object and may be organized chronologically under the numerical name of that full textual object. For purposes of chronology phrases and words are treated as textual objects that precede every full textual object and can generally be treated as members of a set with name 0 or be assigned arbitrary negative numbers.

Any two textual objects may be related to each other through a myriad of patterns. Empirical research demonstrates that eighteen patterns capture most of the useful relational information in a cross referenced database . A list of these eighteen patterns in order of importance follows Given that 

 For a discussion on probability theory and statistics see Wilkinson Leland SYSTAT The System for Statistics Evanston Ill. SYSTAT Inc. 1989 incorporated herein by reference. Some patterns occur only between two full textual objects and others between any two textual objects this distinction is explained below. Semantical patterning is only run on patterns number one and number two shown above

For purposes of explaining how patterns are used to generate the Proximity Index only the two simplest patterns are illustrated.

The simplest Pattern is B cites A. See . In the notation developed this can be diagramed a b c A d e f B g h i where the letters designate textual objects in chronological order the most recent being on the right arrows above the text designate citations to A or B and arrows below the text designate all other citations. The next simplest pattern between A and B Pattern is B cites c and A cites c which can also be expressed as there exists c such that c is an element of A intersect B . See Appendix . This can be diagramed a b c A d e f B g h i. For every textual object c from 0 to A 1 the existence of Pattern on A and B is signified by 1 its absence by 0. This function is represented as P AB c 1 or P AB c 0. The complete results of P AB and P AB can be represented by an A 1 citation vector designated .

The functions of some Patterns require an n 1 matrix a pattern vector. Therefore it is simplest to conceive of every Pattern function generating an n 1 vector for every ordered pair of full textual objects in the database with missing arrays filled in by 0s. Pattern Vectors can be created for Pattern through Pattern by just using the relationships among textual object A and the other textual objects in the database and among textual object B and the other textual objects in the database . Pattern Vectors for Patterns through can only be created if the relationship of every textual object to every other textual object is known. In other words Pattern Vectors for Patterns through can be created from only the rows A and B to the Citation Matrix but Pattern Vectors for Patterns through can only be created from the whole Citation Matrix. total textual objects c theoretical maximum textual objects c TMax total textual objects c actual maximum textual objects c AMax frequency of object c per year f and the derivative of the frequency f .

For Pattern the total number of possible textual objects c subject to analysis i.e. TMax is A 1 one only for the years at issue which are those up to the year in which A occurred. However a relationship may remain open that is it may require recalculation of f x and f x as each new textual object is added to the database for a total of n cases subject to analysis .

The numerical factors for all eighteen patterns are assigned various weights in a weighing algorithm used to generate a scalar F A B . The function F generates a scalar derived from a weighted combination of the factors from all eighteen patterns. The patterns are of course also weighted by importance allowing Supreme Court full textual objects to impose more influence on the final scalar than District Court full textual objects for example. The weighing of the more than 100 factors is determined by empirical research to give results closest to what an expert human researcher would achieve. The weighing will vary depending upon the type of material that is being compared and the type of data in the database . See Thurstone. The Vectors of Mind Chicago Ill. University of Chicago Press 1935 for a description of factor loading and manipulating empirical data incorporated herein by reference. In a commercial Proximity Indexer it will be possible to reset the algorithm to suit various types of databases.

A scalar F A B is generated for every ordered pair of full cases in the database from F 1 2 to F n 1 n . F z z is defined as equal to 0.

The full results of F A B are arranged in an n n matrix designated . Note that F B A is defined as equal to F A B and arrays that remain empty are designated by 0. For every possible pairing of cases A B a Euclidean distance D A B is calculated by subtracting the Bth row of Matrix from the Ath row of Matrix . In other words 1 1 2 2 . . . .

A function designated D A B generates a scalar for every ordered pair A B and hence for every ordered pair of textual objects A B in the database . The calculations D A B for every ordered pair from D 1 1 to D n n are then arranged in an n n proximity matrix . Every column vector in represents the relationship between a given case A and every other case in the database . Comparing the column vectors from column A representing textual object A and column B representing textual object B allows one to identify their comparative positions in n dimensional vector space and generate a coefficient of similarity S A B from 0 100 which is more precise and sophisticated than F A B or D A B alone. A similarity subroutine can run directly on F A B . However the real power of the Proximity Matrix is that it allows one to identify groups or clusters of interrelated cases.

Through factor loading algorithms the relationships represented by for n cases can be re represented in a vector space containing fewer than n orthogonal vectors. This knowledge can be reflected in S A B .

The Proximity Indexing Application Prograrn is an application program that applies the above techniques and algorithms to index and format data to be searched by the CSPDM .

The following description of and elaborates on this general procedure by describing specific subroutines of a Proximity Indexing Application Program . The following is a step by step description of the operation of the Proximity Indexing Application Program .

4. Create Opinion Citation Vectors . By comparing each full textual object in the data base to every other full textual object in the data base that occurred earlier in time.

5. Combine Opinion Citation Vectors to create the bottom left half portion of the n n Opinion citation matrix.

6. Create a mirror image of the bottom left half portion of the Opinion citation matrix in the top right half portion of the same matrix to complete the matrix. In this manner only n 2 comparisons need to be conducted. The other of the comparisons are eliminated.

7. Create the p n Paragraph Citation Vectors by comparing each paragraph to each full textual object that occurred at an earlier time. This will require n 2 p searches.

8. Create a Paragraph Citation Matrix by combining Paragraph Citation Vectors to create the bottom left half portion of the matrix.

9. Complete the creation of the Paragraph Citation Matrix by copying a mirror image of the bottom left half portion of the matrix into the top right half portion of the matrix.

11. Assign identification numbers to the core English words . In the preferred embodiment 50 000 English words are used and they are assigned for identification the numbers from 50 000 to 1.

12. Create a Boolean Index Matrix with respect to the core English words by searching the database for the particular word and assigning the paragraph number of each location of the particular word to each particular word. This procedure is described in greater detail in .

The Opinion Patterner Subroutine performs three primary functions Pattern analysis on matrices calculation of the numerical factors and weighing the numerical factors to reach resultant numbers.

13. Process the Opinion Citation Matrix through each of the pattern algorithms described above and in for each ordered pair of full textual objects to create opinion pattern vectors for each pattern and for each pair of full textual objects. The pattern algorithms determine relationships which exist between the ordered pair of textual objects. The first four pattern algorithms can be run utilizing just the Opinion Citation Vector for the two subject full textual objects. Each pattern algorithm produces a opinion pattern vector as a result. The fifth through eighteenth pattern algorithms require the whole Opinion Citation Matrix to be run through the Opinion Patterner Subroutine .

14. Calculate total hits citation for each pattern algorithm. This can be done by taking the resultant opinion pattern vector OPV and multiplying it by the transposed opinion pattern vector OPV to obtain a scalar number representing the total hits.

15. Calculate the theoretical maximum number of hits. For example in the second pattern the theoretical maximum is all of the full textual objects that occur prior in time to case A A 1 .

16. Calculate the actual maximum number of hits. For example in the second pattern the actual maximum possible number of hits is the lesser of the number of citations in full textual object Q A or full textual object Q B .

18. Calculate the derivative of the total change in hits per year. This is the rate of change in total hits per year and is labeled f A B .

21. Calculate a weighted number F A B which represents the relationship between full textual object A and full textual object B. The weighted number is calculated using the four raw data numbers two ratios and one derivative calculated above in steps 14 through 20 for each of the 18 patterns. The weighing algorithm uses empirical data or loading factors to calculate the resulting weighted number.

22. The Opinion Patterner Subroutine sequence for the Opinion Citation Matrix is repeated n 1 times to compare each of the ordered pairs of full textual objects. Therefore during the process the program repeats steps 13 through 21 n 1 times.

23. Compile the Opinion Pattern Matrix by entering the appropriate resulting numbers from the weighing algorithm into the appropriate cell locations to form an n n Opinion Pattern Matrix.

The Opinion Weaver Subroutine shown in performs two primary tasks calculation of the Opinion Proximity Matrix and calculation of the Opinion Similarity Matrix. The Opinion Proximity Matrix D is generated by calculating the Euclidean Distance between each row A and B of the Opinion Pattern Matrix D A B for each cell DC A B . The Opinion Similarity Matrix is generated by calculating the similarity coefficient from 0 to 100 between each row A and B of the Opinion Proximity Matrix S A B in each cell SC A B in matrix S.

24. Calculate the n n Opinion Proximity Matrix. To calculate D A B the program takes the absolute Euclidian distance between column A and column B of the n n Opinion Pattern Matrix. The formula for calculating such a distance is the square root of the sum of the squares of the distances between the columns in each dimension or 1 1 2 2 . . . The Opinion Proximity Matrix created will be an n n matrix. The smaller the numbers in the Opinion Proximity Matrix the closer the relationship between full textual object A and full textual object B.

25. Create n n Opinion Similarity Matrix. To calculate the Opinion Similarity Matrix each scalar number in the Opinion Proximity Matrix is processed through a coefficient of similarity subroutine which assigns it a number between 0 and 100. By taking the coefficient of similarity the program is able to eliminate full textual objects which have Euclidian distances that are great. For example a Euclidean distance that is very large and is run through the coefficient of similarity would result in a very low coefficient of similarity. Euclidean distances resulting in similarities below four are eliminated in the preferred embodiment .

27. Run each ordered pair of rows of the p n Paragraph Citation Matrix for an individual full textual object i through the pattern algorithms number one and two and determine the resultant Paragraph Pattern Vector.

28. Calculate the various numerical factors AMax TMax etc. by evaluating the values in the Paragraph Pattern Vector.

29. Run the Paragraph Pattern Vector and the numerical factors through the weighing algorithm to determine the appropriate value for each cell of the c n Partial Paragraph Pattern Matrix where cis the number of paragraphs in full textual object i.

30. Repeat steps 27 through 29 for each full textual object i where i 1 to n to create the p n Paragraph Pattern Matrix.

31. Calculate the Euclidean distance of each ordered pair of rows of either the p n Paragraph Citation Matrix or the p n Paragraph Pattern Matrix for a single full textual object i.

32. Place the resultant Euclidean distance values in the appropriate cell of the c cParagraph Proximity Matrix where cis the number of paragraphs in full textual object i where 0

33. Repeat steps 31 through 32 n times in order to calculate n different Paragraph Proximity Matrices one for each full textual object i .

34. The Section Comparison Subroutine clusters all p paragraphs in the database into sections. Then the sections are compared and indexed in the database . This procedure is described in greater detail in .

35. For each full textual object i the Sectioner Geographical Subroutine uses the corresponding c cParagraph Proximity Matrix and a contiguity factor for each paragraph to determine which paragraphs may be clustered into sections. Sections are made up of continuous paragraphs that are combined based upon weighing their Euclidean distances and contiguity.

36. Repeat step 35 for all n full textual objects until all p paragraphs are grouped into q sections.

37. The Sectioner Topical Subroutine provides additional assistance to the Sectioner Geographical Subroutine by considering the factor of topical references to determine the q sections.

38. For the total number of discrete references z to each full textual object in a particular full textual object a z z Citation Proximity Matrix is formed by comparing the Euclidean distances between each reference to a full textual object contained in each paragraph and calculating the topical weight given to each paragraph.

39. The Section Extractor Subroutine numbers each section created by the Sectioner Geographical Subroutine and Sectioner Topical Subroutine Subroutines from 1 to q.

40. The Sectioner Extractor Subroutine creates a q q Section Citation Matrix by determining which sections refer to every other section.

41. The S tion Patterner Subroutine then calculates Section Pattern Vectors corresponding to each row of the q q Section Citation Matrix using the 18 pattern algorithms.

43. The weighing algorithm evaluates the numerical factors and the Section Pattern Vectors and determines the values for each cell of the q q Section Pattern Matrix.

44. The Section Weaver Subroutine calculates the Euclidean distances between each row of the q q Section Pattern Matrix and creates a q q Section Proximity Matrix.

45. The Section Weaver Subroutine then creates a q q Section Similarity Matrix with coefficients 0 to 100 using the values of the Section Proximity Matrix and empirical data and factor loading.

46. As described in steps 10 and 11 the Initial Extractor Subroutine initializes a set of core English words and assigns each word a number. The preferred embodiment uses 50 000 discrete core English words and assigns each discrete core English word a number from 50 000 to 1.

47. The Initial Extractor Subroutine then converts the core English words into a p w matrix. The number of columns w represents the number of discrete core English words in the database and the number of rows p represents the number of paragraphs in the database .

48. The Initial Extractor Subroutine fills the p w matrix by inserting a 1 in the matrix cell where a certain paragraph contains a certain word.

49. The Pool Patterner Subroutine creates two pattern algorithm vectors for only the first two patterns and determines values for the total number of hits the theoretical maximum number of hits the actual maximum number of hits the total number of hits per year and the derivative of the total number of hits per year.

50. The weighing algorithm of the Pool Patterner Subroutine uses empirical data and factor loading to determine values to enter into a p w Paragraph Word Pattern Matrix.

51. The Pool Weaver Subroutine creates a p w Paragraph Word Pattern Matrix by filling the appropriate cell of the Matrix with the appropriate value calculated by the weighing algorithm.

52. The Pool Patterner Subroutine creates a p w Paragraph Word Proximity Matrix taking the Euclidean distance between the rows of the Paragraph Word Pattern Matrix.

53. The Pool Sectioner Subroutine evaluates the Euclidean distances in the Paragraph Word Proximity Matrix and the contiguity factor of each paragraph to duster the paragraphs p into a group of v sections and create a v w Preliminary Cluster Word Matrix.

54. The Section Extractor Subroutine numbers each section chronologically and creates a v v Section Word Citation Matrix.

55. The Section Patterner Subroutine evaluates the v v Section Word Citation Matrix to create two word pattern vectors for only the first two patterns algorithms described above and shown in and determines numerical factors for the total number of hits the theoretical maximum number of hits the actual maximum number of hits the total number of hits per year and the derivative of the total number of hits per year.

56. The Weighing algorithm uses empirical data and factor loading to weigh the numerical factors created from the word pattern vectors and uses the numerical factors and the word pattern vectors to determine values to enter into a v v Section Word Pattern Matrix.

57. The Section Weaver Subroutine creates a v v Section Word Proximity Matrix by taking the Euclidean distance between the rows of the Section Word Pattern Matrix and placing the appropriate Euclidean distance value in the appropriate cell of the Section Word Proximity Matrix.

58. The Section Weaver Subroutine create a v v Section Word Similarity Matrix by evaluating the Euclidean distances from the Section Word Proximity Matrix and empirical data and calculating the similarity coefficient for each ordered pair of sections and places the value in the appropriate cell of the Section Word Similarity Matrix.

59. The Pool Searches of the CSPDM evaluate the Section Word Similarity Matrix as well as other matrices to determine whether or not to retrieve a full textual object.

The following describes a preferred cluster link generator which implements a specific type of patterner or clustering system for use alone or in conjunction with other proximity indexing subroutines and prior to searching. The cluster link generator analyzes a set of numerical representations of a database and generates a second set of numerical representations of the database . This second set is stored in the RAM. This second set of numerical data can represent indirect direct or direct and indirect relationships in the database . Preferably the second set of numerical representations accounts for indirect relationships in the database . It is preferred that the first and second set of numerical data be in a table format and that the first set represent direct relationships or links and the second set represent duster links .

Referring to the cluster link generation algorithm analyzes links to generate a set of cluster links . More specifically the cluster link generation algorithm generates a set of cluster links by analyzing direct and or indirect links between nodes or between objects in a database and generates a set of cluster links . The set of duster links is generated based upon direct and indirect paths or links existing in the database .

In the preferred embodiment the cluster link generator analyzes direct links for example source links and influence links . These direct links may be represented by a table or series of vectors. The generator then locates indirect paths between nodes or objects in a database . The indirect paths are preferably made up of direct links . The cluster link generator then generates a set of cluster links based upon both the direct links and on the indirect paths. The cluster links may be represented by a table or a series of vectors. Another embodiment of this invention uses candidate cluster links to provide a more efficient search. Candidate cluster links are the set of all possible cluster links between a search node and a target node . In this embodiment only a subset of the candidate cluster links the actual cluster links which meet a certain criteria are used to locate nodes for display.

Consider a set of nodes N. . . Nconnected by a sequence of direct links whose weights are given by W. . . W as shown in .

Node Nis reachable from Nthrough a path of length that is N N node Nis reachable through a path of length N N N and so on.

Each path provides some evidence that the start node N and destination node N N or N are related to some extent. The strength of the implied relationship depends on the length of the path and on the weights of the individual direct links along that path.

The weight of each implied link C. . . C is a function of the weight of the path to the previous node and the weight of the last link.

The individual functions F . . . F describe how to combine the weights of the direct links to determine the weight of an implied link. Selecting appropriate functions is the key to making cluster link generation work well. A preferred definition of FN is as follows min where Dis a damping factor that decreases rapidly as N increases.

The cluster link algorithm determines the set of all paths P from a given node Nthat have a length less than or equal to a given length L. Each path is rated using the method described above. The paths are then grouped by destination node the candidate cluster link C N N between Nand a given destination node Nhas a weight equal to the sum of the weights of all paths Pleading to N.

The set of all candidate cluster links is then sorted by weight . A subset of the candidate links is chosen as actual cluster links . The number of cluster links chosen may vary depending on the number of direct links from N and on the total number of candidate cluster links available to choose from.

Performance considerations and efficiency are more important than for small databases. For large databases finding the set of all paths P from a given node Nthat have a length less than or equal to a given length L may be impractical since the number of unique paths may number in the tens of millions.

One embodiment of this invention uses candidate cluster links to provide a more efficient search. Candidate cluster links are the set of all possible cluster links between a search node and a target node. In this embodiment only a subset of the candidate cluster links the actual cluster links which meet a specified criteria are used to identify nodes for display .

Clearly it is not necessary to examine millions of paths when the goal is to select the top or strongest duster links for each N for example the top to cluster links . The great majority of paths have an insignificant effect on the final results. What is needed is an implementation of the cluster link algorithm where the total number of paths examined is bounded independent of the size of the database without a loss in effectiveness. To this end we have an implementation of the algorithm such that a cluster link is defined recursively.

We define C N N the order L cluster link from Nto N as the cluster link between Nand N considering only paths of length less than or equal to L. Then we can derive C N N from C N N and C N N .

The assumption is that most of the paths P N N of length L or greater from Nto Nwill not have a significant impact on cluster link generation. Therefore we an use a set of candidate cluster links C N N as a summary of that path information for the purpose of determining C N N . This assumption has a significant impact on the performance of the algorithm in this implementation since the search space is significantly reduced at each step. The computer processing cost of generating cluster links is bounded by the size of the candidate cluster link sets generated at the intermediate steps rather than by the total number of relevant paths in the database .

The size of the candidate cluster link set generated at each intermediate step affects the speed of the algorithm in this implementation. If too many candidate cluster links are generated at each intermediate step the algorithm is too slow. On the other hand if too few candidate cluster links are generated and too many paths are pruned then C N N is no longer an accurate summary of P N N .

Finally since the weights of the individual candidate cluster links in C N N are generally much greater than the weights of the individual paths in P N N the damping factors Dused to derive the combined weights at each step must be decreased accordingly in this implementation.

The specifics for the basic algorithm of this implementation for determining the set of order N cluster links from a given start node N are shown in . The general algorithm works for any value of N greater than zero. If N 1 the set of candidate cluster links generated is simple. The processing cost of determining the candidate cluster links increases with N. In practice N 3 appears to yield the best results.

The algorithm starts by initializing the candidate cluster link set and creating a loop for i 0 to N . The algorithm then performs a series of steps for each path P . First it selects the destination node as the node to analyze and retrieves the set of direct links L from the selected node to any other node in the database N. Second for each direct link L the algorithm performs a series of steps 

The algorithm creates a new path P of length i 1 consisting of the path P plus the direct link L from the selected node to the node N. The algorithm then determines the combined weight . WCfrom WC the weight of the path P and W the weight of Link L using the following preferred formula min 2064.

Following these computations the algorithm decides whether there already is a path in the cluster link from Nto N. If there is a not already a path the algorithm adds P to C. If there already is a path the algorithm adds WCto the weight of the existing path in C. These steps are then repeated as necessary.

Once the candidate cluster link set has been generated deriving the actual cluster links is a simple matter of selecting or choosing the T top rated candidate links and eliminating the rest. In practice the following formula has yielded good results min constant 4 where d is the number of direct links from N. Setting the constant equal to twenty has yielded good results. More than T cluster links may be generated if there are ties in the ratings. After each iteration the candidate cluster link set Cmay be pruned so that it contains only the top candidate cluster links for example the top .

After CSPDM subroutine has executed a particular search the CSPDM retrieves the appropriate data from the database analyzes the data and sends the data to the GUI Program in order for the GUI Program to display the results of the search on the display .

3. The Cases In Subroutine examines the n n Opinion Citation Matrix and other matrices created by the Proximity Indexing Application Program and retrieves the textual objects to which the selected textual object refers data relating to the number of times the selected textual object refers to the retrieved textual objects data relating to the importance of each textual object and other relevant data.

6. The Cases After Subroutine examines the n n Opinion Citation. Matrix and other matrices created by the Proximity Indexing Application Program and retrieves the textual objects that refer to the selected textual object data relating to the number of times the retrieved textual objects refer to the selected textual object data relating to the importance of each textual object and other relevant data.

9. The Similar Cases Subroutine examines the q q Section Similarity Matrix and other matrices created by the Proximity Indexing Application Program and retrieves the textual objects that are similar to the selected textual object data relating to the degree of similarity between the selected textual object and the retrieved textual objects data relating to the importance of each textual object and other relevant data. In order to be retrieved a textual object must have a similarity coefficient with respect to the selected textual object of at least a minimum value. The preferred embodiment sets the minimum similarity coefficient of four percent 4 .

11. The researcher must then select a single full textual object to which in compare the pool of full textual objects. It should be noted that the researcher can select the single textual object from the selected pool of textual objects or the researcher can select a textual object from outside of the pool .

12. The Pool Similarity Subroutine examines the n n Opinion Similarity Matrix and other matrices and values created by the Proximity Indexing Application Program for the selected full textual object and the pool of full textual objects.

13. The Pool Similarity Subroutine determines the degree of similarity of other full textual objects in the pool to the selected full textual object .

15. The Pool Paradigm Subroutine examines the n n Opinion Proximity Matrix the n n Opinion Similarity Matrix and other matrices and values created by the Proximity Indexing Application Program for the pool of full textual objects .

16. The Pool Paradigm Subroutine determines the Paradigm full textual object by calculating the mean of the Euclidean distances of all the textual objects in the pool .

17. The Pool Paradigm Subroutine determines the similarity of the other full textual objects in the pool to the Paradigm full textual object .

19. The Pool Importance Subroutine examines the n n Opinion Citation Matrix the n n Opinion Similarity Matrix numerical factors and other matrices and values created by the Proximity Indexing Application Program for the pool of full textual objects .

20. The Pool Importance Subroutine then ranks the importance of each of the full textual objects in the pool .

21. The researcher must select a pool of k full textual objects where k equals the number of full textual objects in the pool .

22. For each of the k full textual objects the Pool Paradigm Similarity Subroutine selects a n 1 vector from the corresponding column of the n n.

23. The Pool Paradigm Similarity Subroutine creates an n k matrix by grouping the n 1 vector representing each of the k full textual objects beside each other.

24. The Pool Paradigm Similarity Subroutine calculates the mean of each row of the n k matrix and enters the mean in the corresponding row of an n 1 Paradigm Proximity Vector .

25. The Pool Paradigm Similarity Subroutine combines the n 1 Paradigm Proximity Vector with the n n Opinion Proximity Matrix to create an n 1 n 1 Paradigm Proximity Matrix .

26. From the n 1 n 1 Paradigm Proximity Matrix the Pool Paradigm Similarity Subroutine evaluates the Euclidian distances and empirical data to create an n 1 n 1 Paradigm Similarity Matrix .

27. The Pool Paradigm Similarity Subroutine searches the row in the n 1 n 1 Paradigm Similarity Matrix that corresponds to the Paradigm full textual object and retrieves the full textual objects that have a maximum degree of similarity with the Paradigm full textual object .

28. The researcher must select a pool of k full textual objects where k equals the number of full textual objects in the pool .

29. For each of the k full textual objects the Pool Paradigm Similarity Subroutine selects an n 1 vector from the corresponding column of the n n.

30. The Pool Paradigm Similarity Subroutine creates an n k matrix by grouping the n 1 vector for each of the k full textual objects beside each other.

31. The Pool Paradigm Similarity Subroutine calculates the mean of each row of the n k matrix and enters the mean in the corresponding row of an n 1 Paradigm Pattern Vector PF .

32. The Pool Paradigm Similarity Subroutine combines the n 1 Paradigm Pattern Vector PF with the n n Opinion Pattern Matrix to create a n 1 n 1 Paradigm Pattern Matrix .

33. From the n 1 n 1 Paradigm Pattern Matrix the Pool Paradigm Similarity Subroutine evaluates the Euclidean distances between the rows of the Paradigm Pattern Matrix and creates an n 1 n 1 Paradigm Proximity Matrix .

34. From the n 1 n 1 Proximity Matrix the Pool Paradigm Similarity Subroutine evaluates the Euclidean distances between the rows of the n n 1 Paradigm Proximity Matrix and empirical data to create an n 1 n 1 Paradigm Similarity Matrix .

35. The Pool Paradigm Similarity Subroutine searches the row in the n 1 n 1 Paradigm Similarity Matrix that corresponds to the Paradigm full textual object and retrieves the full textual objects that have a minimum degree of similarity with the Paradigm full textual object .

The above Proximity Indexing Application Program and CSPDM have a number of different applications and versions. Three of the most useful applications are described below.

The first type of Proximity Indexing Application Programs is for use on very large databases. The matrices generated by this type of Proximity Indexer are attached to the database along with certain clustering information so that the database can be searched and accessed using the Cases In Subroutine Cases After Subroutine Cases Similarity Subroutine Pool Similarity Subroutine Pool Paradigm Subroutine Pool Importance Subroutine and Pool Paradigm Similarity Subroutine of the CSPDM .

The second type of Proximity Indexing Application Program is a Proximity Indexer that law firms businesses government agencies etc. can use to Proximity Index their own documents in their own databases . The researcher can navigate through the small business s preexisting database using the Cases In Subroutine Cases After Subroutine Cases Similarity Subroutine Pool Similarity Subroutine Pool Paradigm Subroutine Pool Importance Subroutine and Pool Paradigm Similarity Subroutine of the CSPDM . In addition this type of Proximity Indexer Application Program will be designed to be compatible with the commercial third party databases which are Proximity Indexed using the first type of program. In other words the researcher in a small business may weave in house documents into a commercial database provided by a third party so that searches in the large database will automatically bring up any relevant in house documents and vice versa.

The third type of Proximity Indexing Application Program involves the capacity to do Proximity indexing of shapes. Each image or diagram will be treated as a textual object. The various matrix coefficients can be generated purely from topological analysis of the object itself or from accompanying textual information about the object or from a weighted combination of the two. The text is analyzed using the Proximity Indexing Application Program as explained above. Shapes are analyzed according to a coordinate mapping procedure similar to that used in Optical Character Recognition OCR . The numerical maps resulting from scanning the images are treated as textual objects that can be compared through an analogous weighing algorithm to generate a proximity matrix for every ordered pair of textual objects in the database . A similarity matrix can then be generated for each ordered pair and the results organized analogous to a database totally comprised of actual text.

This third type of Proximity indexing applications program can provide Proximity Indexed organization access to many different types of objects. For example it can be used to search patent diagrams or compare line drawings of known pottery to a newly discovered archeological find. It can be used to scan through and compare police composite drawings while simultaneously scanning for similar partial descriptions of suspects. It can be used to locate diagrams of molecular structures appraise furniture by comparing a new item to a database of past sales identify biological specimens etc. etc.

The Tear Off Window feature is illustrated in by the Tear Off Window for V. 930 F.2d 63 D.C. Cir. 1991 . The four Tear Off Window active boxes displayed on the Tear Off Window 1 open up the full text of to the first paragraph that cites 2 run any of the three searches namely Cases In Subroutine Cases After Subroutine or Cases Similar Subroutine for itself the default is to run the same type of search namely Cases After Subroutine again 3 hide the execute search window and 4 bring the Terry Execute Search window to the foreground respectively. The weight numeral indicates the number of paragraphs in that discusses or refers to in this textual object in this example there is only one .

The Cases After screen for a given Textual object B displays a Textual Object Active Box representing every subsequent textual object in the database that refers explicitly to Textual object B. The analysis starts with the same pool of material as a Shepards list for Textual object B. As well as some additional material not gathered by Shepards. However the Cases After screen conveys a wealth of information not conveyed by a Shepards list.

The horizontal axis may represent time importance or any other means of measurement to rank the textual objects. The Shepards list itself contains no information as to when a case was decided. The vertical axis similarly may represent any means of measurement to rank the textual objects. In the preferred embodiment the vertical axis represents the degree to which the subsequent Textual object C relied upon the original Textual object B. The display makes it obvious when a textual object has received extensive discussion in another textual object or provides key precedent for a subsequent textual object or merely mentions the earlier textual object in passing. It also provides guidance as to possible gradations in between extensive or merely citing.

The shape of the overall pattern of active boxes on the Cases After screen provides a rich lode of information to be investigated. For example a dip in citation frequency immediately after a particular textual object suggests that the particular textual object while not formally overruling Textual object B has largely superseded it. A sudden surge in citation frequency after a particular Supreme Court case may indicate that the Supreme Court has picked up and adopted the doctrine first enunciated in Textual object B. The researcher can instantly determine if the holding of Textual object B has been adopted in some circuits but not in others if Textual object B is losing strength as a source of controlling precedent etc. None of this information is now available to lawyers in graphical or any other form.

As with the Cases In screen every Textual Object Active Box on the Cases After screen is active and includes a Tear Off Window that may be moved by dragging on the tear off window with a mouse and that tear off window becomes a text Tear Off Window visible even when one moves on to other searches and other screens. Thus one may tear off for later examination every relevant citation to Textual object B or even for a group of textual objects. The text tear off windows tile that is they can be stacked on top of one another to take up less room. There is also a Select All feature not shown that creates a file containing the citations of every textual object retrieved in a given search.

In Cases After screen mode clicking on the expanded view button of the text tear off window opens the text of the subsequent Textual object C to the first place where Textual object B is cited. A paragraph window displays a paragraph selection box indicating what paragraph in Textual object C the researcher is reading and a total paragraph box indication how many paragraphs Textual object C contains in total. The user can view paragraphs sequentially simply by scrolling through them or see any paragraph immediately by typing its number in the paragraph selection box . Clicking on a Next paragraph active box immediately takes the researcher to the next paragraph in Textual object C where Textual object B is mentioned. Traditional Shepardizing allows the researcher to explore the subsequent application of a doctrine in a range of different factual situations situations that help to define the outer contours of the applicability of a rule. Combining the expanded view button functions and Next Paragraph active box functions allows the researcher to study how Textual object B has been used in all subsequent textual objects in a fraction of the time the same task currently requires with available searching methods.

Perhaps the most fundamental form of legal research is Shepardizing. A researcher starts with a textual object known to be relevant Textual object B and locates the Shepards for that textual object. The Shepards is a list of every subsequent textual object that explicitly refers to Textual object B. The researcher then looks at every single textual object on the list. Shepardizing is often painstaking work. Many subsequent references are made in passing and have almost no legal significance. Although Shepards includes some codes next to its long lists of citations such as f for followed and o for overruled the experience of most lawyers is that such letters cannot be relied upon. For example the researcher may be citing Textual object B for a different holding than that recognized by the anonymous Shepards reader interpreting Textual object B differently or interpreting the subsequent textual object differently. However for really thorough research checking a Shepards type of list is essential. The researcher must make absolutely sure that any textual object cited as legal authority in a brief for instance has not been superseded by later changes in the law.

Very often textual objects located on the Shepards list for Textual object B refer back to other important textual objects some of which may predate Textual object B all of which may be Shepard ized in turn. This zig zag method of research is widely recognized as the only way to be sure that one has considered the full line of textual objects developing and interpreting a doctrine. The real power of the Cases After screen emerges when it is used in conjunction with the Cases In screens and Similarity screens . Using the preferred embodiment the researcher may engage in the same kind of careful zig zag study of a legal doctrine in a much more efficient manner.

For example consider the following hypothetical search. The researcher reads Textual object B and makes a list of every Supreme Court textual object it substantially relies upon perhaps six textual objects. The researcher then Shepardizes Textual object B and reads each of those textual objects in order to find other Supreme Court textual objects that they relied upon perhaps eight. One then Shepardizes those fourteen Supreme Court decisions in order to find any Court of Appeals cases in a selected circuit within the last three years on the same basic topic. This process would take at least an hour even using Shepards through an on line service. The same search can be performed with the present invention using the Cases In screens and Cases After screens in under five minutes.

In order to perform the same search a researcher can pull up both the Cases In screens and Cases After screens for Textual object B simultaneously. The researcher can then tear off all of the Supreme Court Cases on both lists run Cases After Subroutine searches on every Supreme Court Case mentioned on either list then examine the Cases In screens for all of the Supreme Court cases produced by these searches. The researcher can locate every recent Court of Appeals case from a selected circuit mentioned in any of those Supreme Court cases. Use of the Similarity screen as well allows the researcher to find the pool of relevant Court of Appeals full textual objects even faster.

The number 34 in the lower left corner of the total paragraph box indicates that Barry has a total of 34 paragraphs in the cite v. . Dragging the small squares to the left and below the text allow the researcher to move within a paragraph and from paragraph to paragraph in the text of respectively. The empty space below the text would contain the text of any footnote in paragraph 15. The compress window active box now closes the window and replaces it with the corresponding active textual object box .

A highlighted Textual Object Active Box can be created by clicking on it as has been done with v. 851 F.2d 595 D.C. Cir. 1988 . The number 212 in the case number box indicates that citations to two hundred twelve distinct texts appear in . Fewer are visible because the textual object active boxes tile on top of one another the Zoom feature is used to focus on a smaller area of the screen and ultimately resolves down to a day by day level making all the textual object active boxes visible.

The unique Cases In screen provides a schematic representation of the precedent from which Textual object A is built. The Cases In screen contains a textual object active box representing every textual object which is relied upon or even mentioned in Textual object A. Any citation in textual object A to a textual object that possesses potential persuasive authority whether a statute constitutional provision treatise scholarly article Rule of Procedure etc. is treated as a textual object. The textual object active boxes are color coded to indicate the court or other source of each textual object. Supreme Court cases are red Court of Appeals cases are green District Court cases are blue and statutes are purple for example. Each Textual Object Active Box contains the full official citation of its textual object. Clicking on any Textual Object Active Box immediately pulls up a larger window known as a tear off window also containing the full citation to the textual object Tear Off Window Citation its date its circuit and its weight numeral to the textual object being analyzed. The user may then drag the Tear Off Window free of the Textual Object Active Box and release it.

This creates a text Tear Off Window that remains visible until the researcher chooses to close it no matter how many subsequent screens the researcher examines. The text Tear Off Window can be moved anywhere by dragging it with the mouse . The text Tear Off Window contains small text active boxes allowing the researcher to access or pull up the full text of the textual object it represents with a single click of the mouse . This feature also allows the researcher to run Cases In Subroutine Cases After Subroutine and Cases Similar Subroutine searches on the textual object. See below for a description of the Similarity screen .

The organization of the boxes on the screen including their position on the horizontal axis and vertical axis represents the real intelligence behind the Cases In screen . The horizontal axis in the preferred embodiment represents time with the left margin corresponding to the present i.e. the date when the search is run. The right margin represents the date of decision of the earliest textual object cited in Textual object A. Certain special materials such as treatises updated annually and the U.S. Constitution are located in a column to the left of the margin. 

The vertical axis in the preferred embodiment represents the degree to which Textual object A relied upon each particular textual object it contains. For example if the Cases In screen is run on a district court case Textual object A which happens to be a stop and search textual object that mainly relies upon v. 392 U.S. 1 1968 will be at the top of the screen with all other textual object active boxes appearing far below. The researcher can thus access the text of directly without ever reading the text of Textual object A. Of course the full text of Textual object A is also instantly available if desired. If the researcher wants to see where came from the researchers can instantly by clicking on a text active box within the text Tear Off Window run the Cases In Subroutine for and so on. There is no limit to the number of levels or generations the researchers may explore using this technique. It is therefore possible assuming a sufficient database to find in a matter of seconds without having to read through layers of texts the possibly long forgotten eighteenth century precursors to a modem doctrine.

The Cases In screen creates an instant visual summary or blueprint of a textual object. The blueprint can help a researcher make a preliminary judgment about whether a particular textual object is worth closer examination. Viewing the Cases In screens for a group of textual objects allows a researcher to recognize whether there are precedents common to that group. The blueprint tells the researcher whether Textual object A is primarily a statutory construction case a textual object that relies on local Court of Appeals cases without Supreme Court support a textual object relying on precedent outside the circuit as persuasive authority etc.

The initial Cases In screen presents every citation within a given textual object. In a textual object with an unusually large number of citations the screen will be crowded with textual object active boxes . The GUI therefore contains a zoom feature that allows the researcher to expand any small portion of the screen. To get back to the big picture the researcher simply selects the Fit in Window menu item or else selects the zoom out feature. The same zoom zoom out and Fit in Window functions are present in the Cases After screen and Similarity screen as well.

The routine that calculates degree to which Textual object A relies upon the cited textual object clearly ranks major textual objects at the top textual objects mentioned only in passing at the bottom and textual objects of potentially greater relevance in between via display the appropriate textual object active boxes in the appropriate place. In addition the routine can recognize when a highly relevant textual object is mentioned only in passing and give a higher weight to that textual object than it would otherwise receive in the ranking procedure.

The intelligence behind the entire GUI is driven by the knowledge that the lawyers do not want the computer to do legal analysis or make judgments for them but simply guide them through the great mass of irrelevant material to those texts where lawyerly analysis of a problem begins.

The Cases In screen is designed with practical legal research in mind. It is common in legal research to locate a lower court textual object on the correct topic call it local Textual object A. However the researcher desired to find the most persuasive authority available. The aim of this type of research is to find the lead textual object or textual objects on a particular topic. The researcher ultimately desires the first textual object most famous textual object and most recent textual objects of the Supreme Court or state Supreme Court in state law issues that stand for the same principle. Lead textual objects also occur at the intermediate and trial court level. 

The standard way to find lead textual objects is to read through the text of a local Textual object A until one finds references to higher court textual objects then look up each of those higher court textual objects in turn. The researcher then reads the text of those textual objects until the researcher determines the textual objects they have in common the textual objects that appear many times. Very often the lower court textual object from which the researcher started is of no real value in and of itself it may well be from a different local jurisdiction and the researcher reads through it only to find citations within it. Since the GUI quickly locates and schematically diagrams the textual objects this process is accelerated dramatically using the GUI.

The Similarity screen for a given Textual object C is organized like the Cases In screen and Cases After screen with the same color coded textual object active boxes representing textual objects and time on the horizontal axis . However the vertical axis represents the degree to which the represented textual object is related to Textual object C. The system is built on the principle that legal doctrines tend to emerge out of lines of textual objects developing a legal principle. Lines of textual objects contain lead textual objects that establish basic rules and subsequent textual objects that do not establish new rules but apply and re interpret the pre existing rules in various circumstances. Some lead textual objects invent new doctrines while others modify or redirect the law based on earlier precedent.

The routine that operates behind the Similarity screen determines which line or lines of textual objects that Textual object C can be grouped. The routine then ranks the textual objects in that line depending on how closely they are related to Textual object C. For example a typical similarity search starting with a Court of Appeals case in a certain circuit Textual object D will find the Supreme Court and Court of Appeals cases that have established the principles followed in Textual object D. The Supreme Court and Court of Appeals case will appear as textual object active boxes whether or not they are cited in Textual object D. Furthermore the Similar Cases Subroutine search will find the textual objects decided subsequent to Textual object D that have applied and possibly modified those principles whether or not those textual objects cite Textual object D.

Similarity searches allow a researcher to find textual objects on the same topic that do not share common phrases and might be overlooked by a Boolean word search. Similarity searches also allow researchers who only have an obscure district court case to tap in to the lead textual objects in any area. By organizing all case law in conceptual space the Similarity screens allow one to locate emerging topics that have not been formally recognized by those assigning key numbers or otherwise manually classifying textual objects or even by the authors of the textual objects themselves.

The shape of a Similarity Screen may convey a great deal of information about a particular legal concept. For example the screen conveys to the researcher whether a certain concept which is essentially novel is supported by Supreme Court case law. Or is an old doctrine that has been recently applied in a new context. The system as a whole gives lawyers the ability to assess what textual objects are available on their topic and to zero in on the textual objects that are most useful. The researcher has the ability to track down every subsequent reference to any particular textual objects by utilizing multiple Cases After searches identifying core precedents through Cases In searches and by running new Similarity searches to obtain any textual objects that emerge in closely related topic areas. The Similarity algorithm is more aggressive then the others since it contains built in judgments as to what relatedness means. It also judges what is no longer sufficient to display on the screen. The bottom edge of the screen represents a minimum degree of similarity below which the connections are too tenuous to be worth pursuing. In the commercial product this minimum level can be reset at the preference of the user.

The researcher can also identify the type of search to be performed on the selected textual object by selecting the appropriate search in the Analysis box.

Once the researcher has inputed all the appropriate values the researcher executes the search by activating the execute search button.

Referring generally to the PSDS PPDS PIDS and PPSDS of the GUI Program also create similar displays to the CIDS CADS and SCDS subroutines. The only major difference between the screens created by the three textual object display subroutines and the four pool display subroutines is the information contained in the Execute Search window and the options available in the analysis box.

The options in the analysis box enable a researcher to select a textual object outside the pool of textual objects and compare how the selected textual object relates to the pool of textual objects by selecting to the Pool Similarity Subroutine the Pool Paradigm Subroutine or Pool Importance Subroutine of the CSPDM .

The PSDS creates a Pool Similarity Screen . The vertical axis ranks the similarity of the objects in a pool of textual objects with respect to a selected textual object. All of the other aspects of this display are similar to the Similar Cases Screen.

PPDS creates a Pool Paradigm Screen. The vertical axis ranks the similarity of the pool of textual objects on the screen with respect to the paradigm textual object. The paradigm textual object is calculated by averaging the mean of all the Euclidean distances of the pool of textual objects on the screen. All of the other aspects of this display are similar to the Similar Cases Screen.

The PIDS creates a Pool Importance Screen. The vertical axis ranks the importance of the pool of textual objects on the screen. All other aspects of the PIDS display are similar to the Cases In Screen and Cases After Screen .

The PPSDS creates a Pool Paradigm Similarity Screen . The vertical axis represents the similarity of all textual objects in the database to the paradigm textual object created by a selected pool of textual objects. All other aspects of the PPSDS display are similar to Similar Cases Screen .

Before displaying the text boxes representing result nodes on the screen to the user the graphical user interface program optimally organizes and arranges the location of boxes on the X and Y axis. In the preferred embodiment the GUI Program uses a layout of boxes algorithm to optimally place boxes within a window.

Referring to generally a layout algorithm plots text boxes on a cartesian axis as determined by their X and Y values . The algorithm compares the locations of boxes within a display window to determine if there are any overlapping boxes . In order to perform this comparison the preferred algorithm initializes a first loop for i 0 to N and chooses boxto begin the comparison. The algorithm next creates a second loop for j 1 to N and chooses boxto compare with box. For both loops N is the number of result nodes obtained. Performing Ncomparisons provides the optimal number of comparisons needed to determine the existence of any overlaps. If the boxes are a known size certain steps may be eliminated from the method.

More particularly a preferred algorithm compares the X and Y values of.a first and second box to determine if the boxes are occupying the same Cartesian space . This comparison is accomplished by identifying the X and Y coordinate pairs of the corners of the two boxes and then choosing one of the coordinate pairs of a corner of the second box to be compared. The X value of that pair is compared to the X values of all of the coordinate pairs of the corners of the first box . If the X value of the chosen coordinate pair is a value less than all of the first box corner X values or a value greater than all of the first box corner X values then the algorithm compares the Y value of the chosen pair to all of the first box corner Y values. If the Y value of the chosen pair is either a value less than all of the first box corner Y values or a value greater than all of the first box corner Y values of the first box then the algorithm determines that the boxes do not overlap. The algorithm adds 1 to counter j and then repeats the routine. The routine is repeated until j reaches N and then 1 is added to the i value and the entire process is repeated again. This particular method ensures that every box is compared with every other box .

If during the comparison of the X values the algorithm finds that the X value of the chosen pair is greater than one of the first box corner X values but is less than one of the first box corner X values then the algorithm determines that the boxes overlap. If during the comparison of the Y values the algorithm finds that the Y value of the chosen pair is greater than one of the first box corner Y values but is less than one of the first box corner Y values then the algorithm determines that the boxes overlap.

If the preferred algorithm has determined that two boxes overlap then the algorithm moves one of the boxes . Preferably this is accomplished by adjusting the Y values of the second box by increasing or adding a predetermined value to its Y values. The algorithm performs the above comparison routine again to see if there is an overlap. If there is an overlap it moves the box again. Preferably it adjusts the second box s Y value again and compares again. If there is no overlap then the algorithm adds 1 to the j counter and repeats the comparison routine with another box until Ncomparisons have been completed.

When the preferred layout algorithm has ensured that no boxes overlaps the algorithm determines whether the results of the search will fit on one screen . The algorithm compares the Y values of each of the boxes with the highest Y value represented on a single screen display. If the Y value of one or more boxes exceeds the highest Y value represented on the screen display then the preferred algorithm increases the length of the X axis and rescales the Y axis to match e.g. doubling the length of the X axis . The algorithm again compares the Y values of each of the boxes to the highest Y value on the screen to determine if the search results will fit on one screen . If they will not then the algorithm adjusts the X axis again and compares the Y values again until the search results fit on one screen.

Once the search results fit on one screen the algorithm replots all of the boxes to their coordinate positions and then performs the overlap comparison check again to see if any boxes are overlapping. If boxes are overlapping the algorithm performs its adjustment step and the axis resizing step until the window displays all of the result nodes on a single screen without any of the boxes overlapping.

At the option of the user the algorithm can allow the display to scroll off the screen in the Y direction or the X direction without resizing the axes. This option enhances the information content of the map by keeping the scale of the axes small.

The preferred algorithm can perform this routine by adjusting the X axis the Y axis or both axes. The algorithm has the additional capability of graphically breaking an axis if one or a few result nodes are so far away graphically from the main body of result nodes that representing the far away result nodes would unnecessarily encumber the graphical display of the main nodes. This graphical break may be represented by a squiggly line at the break point in the axis. Using this axis break allows all of the result nodes to be displayed on one window and still maximizes the informational content that the relative spacing on the X or Y axis provides for the result nodes which are positioned closer together.

Various other specific methods of optimally organizing and locating boxes on a graphical computer display may be used with the GUI Program .

In the preferred embodiment the graphical user interface maximizes the types and quantity of information about particular boxes nodes objects in the database that can be displayed without visually overloading the user. The preferred embodiments ergonomically and efficiently represent complex data sets. Each embodiment must strike a balance between that which is technically and intellectually possible to be displayed on a screen and that which can be visually understood and comprehended by the typical user of the database on a screen . This method can also be used to display objects retrieved from a network but it is not the preferred method at the present time.

An important feature of the invention is its use of a three dimensional box to communicate information to the user in addition to the information provided by the location of the box in the X and Y coordinates. Referring to in the preferred embodiment a three coordinate view or map is displayed on a two dimensional CRT screen. The variables represented by the X Y and Z coordinate planes may be interchanged from one coordinate to another. In other words the X Y or Z coordinate plane may represent for example the variable time. For use of the Z coordinate it is preferred that a six sided box be used and appear to be floating at its appropriate location in the Z direction. More importantly the invention also can use the depth of the box size of the box in the Z direction to convey additional information to the user in addition to the information provided by the location of the box in the X Y Z coordinate .

First using box depth a bit of binary information is passed along to the user by the fact that the box has no depth little or nominal depth or the box has a significant depth in the Z direction. In the preferred embodiment this binary piece of information informs the user of whether or not there is available hidden data associated with that box . For example a box or node which represents an object in the database may have associated graphics maps menus or text which is not shown. If the box is shown on the screen as having a significant depth then additional data associated with that box is available for viewing by the user. If the box has nominal or no depth then there is no additional data available to the user.

In addition to the binary information of whether or not additional data is available to the user in the preferred embodiment the magnitude of the depth of the box corresponds to the amount of additional or hidden data available to the user. For example if the box represents an object in the database which has an extensive amount of associated data the magnitude of the depth of the box would be large in comparison to other boxes on the same screen. In this manner a box which represents for example a textual object of great length would have a larger depth than a box representing a textual object with little or no text associated with that object in the data base. In this manner important information is visually passed to the user easily and on the same screen on which other information about the database is being presented.

Also in advanced embodiments the depth of a box or the fact that a box has depth may be used to represent to the user that the box enables the user to tie in or access another application program menu extension and or another database . In this way active boxes with depth can allow a user great flexibility to move around within the database or within associated database or even to access other applications. This can be particularly useful when the underlying data supporting a node or box is not located locally at the user s location and requires the user to access communication links or a second database in order to obtain the underlying data. With this invention the user is able to access the underlying data from the graphical user interface screen.

Also in advanced embodiments an axis may represent a variable such as cost data associated with a node or the cost of accessing the underlying data. In one example if the data is available only through a separate application which may impose a cost the box s depth would increase in proportion to that cost. Or if the application itself imposes a cost for accessing data then the depth of each box would represent the cost of accessing that box s data.

In summary the depth of a box provides two types of information. First binary type information regarding the presence of additional data or information or lack thereof and second based on the relative measure of the depth of the box the amount or size of the underlying data or information which is available and associated with that box . Thus a box can be activated and brought to life so that there is an extension that points to either data or another entity independent of the original database which assist the GUI user.

Additional information concerning the database is presented by this invention by the intelligent use of comments. Comments attached to the textual object boxes provide the user with easy access to vital information contained in the database. shows the various information types which can be added to the database . For example shows that links are assigned weights that nodes are assigned node identifications IDs and plot dates creation date or the like that link sub types can be assigned names comment descriptors comment display orders comment place holders and always display comment commands that node sub types can be assigned names and title descriptors that node types can also be assigned names as well as extra attributes in an extra attributes table that link types can be assigned names and icon files for icon graphics and various visual styles can be assigned to nodes and links . In addition to those items specifically described various attributes can be assigned to links nodes and link sub types and node sub types . The various additional information which is stored in the database can be shown on maps or on menus when using the database . These identifications can be used as part of the searching algorithms discussed previously.

A unique feature of the graphical user interface program is its ability to optimally space the information within displayed objects. More particularly the GUI program arranges text and graphics within boxes or the like on a computer display screen. The preferred GUI Program achieves this by using a box spacing algorithm as shown in . A preferred box spacing algorithm is described below.

The boxes used by the preferred GUI Program generally include different types of information or data such as box titles textual information and graphical information within the box as discussed previously. The information types may be assigned to nodes node sub types links or link sub types . Preferably the GUI defines and or selects points in the box to serve as anchor points for each type of information. For example the GUI may designate a point near the upper right hand corner of a box as the anchor point for the graphical information the lower left hand corner as the anchor for the textual information and the upper left hand corner as the anchor point for the box title. In the preferred embodiment the algorithm finds an arrangement which keeps the size of the boxes as small as possible while preventing overlaps between the different types of information.

Also the preferred embodiment adjusts the positioning of the information or data within the box to make the box aesthetically pleasing. Preferably the anchor points are moved or adjusted to arrange or rearrange the content within the box.

Referring to generally the box spacing algorithm plots the information types at their designated anchor points and determines whether the plotted information fits within the default box size . If necessary the box is resized . Following the algorithm checks for any overlap of information types within the box and adjusts the location of anchor points if necessary.

The overlap checking function performed by the preferred box spacing algorithm is similar to the overlap checking function performed by the preferred layout algorithm discussed above. Various tolerances or thresholds may be set to ensure that the information or data within the box not only does not overlap but is sufficiently spaced so that it can be easily understood by a user. If the information overlaps the anchor points are moved and or the boxes are reshaped. Finally the processed boxes are displayed .

More particularly to perform the function of arranging anchor points and reshaping boxes the preferred box spacing algorithm initializes a loop for i 0 to N where N is the number of information types to be displayed on the box chooses information typeand then initialize a second loop for j 1 to N and chooses information typeto compare to information type.

The preferred algorithm plots the first information type on the box at its designated anchor point. The algorithm plots the information beginning at the anchor point and fills out horizontally or vertically from there until the information is plotted. After plotting the algorithm determines if the information fits within a normal or default box size . If the box is too small the algorithm may adjust the box dimensions horizontally or vertically to accommodate the size of the information.

The algorithm then plots the second type information in the box . After this information is plotted the algorithm determines X and Y values of the first information type using the left and lower edges of the main box as coordinate axes and compares them with the X and Y values of the second information type. The box spacing algorithm performs this function in the same manner as the layout algorithm performs its comparison function.

If there is an overlap then the algorithm preferably attempts to adjust the location of anchor points to eliminate overlap. If this is not possible the algorithm adjusts the size of the box by a set value in either the X or Y direction. The algorithm re plots the information types at their anchor points. Preferably the anchor points generally remain in the same relative position in the box but as the box increases in size the anchor points are in an absolute sense farther away from each other. After adjustments the algorithm runs the comparison routine again to determine if the two information types overlap or are aesthetically displeasing. A box may be aesthetically displeasing if the data within the box is not evenly or symmetrically distributed or if data is too close.

If the information types are appropriately spaced within the box the algorithm adds 1 to the j counter and compares the first information type to the j 1 information type. The algorithm continues to compare information types until the first information type has been compared with all of the information types in the box . Then the algorithm routine returns to the i loop adds 1 to i and then compares the second information type to the other information types until the second has been compared to all of the information types. If the algorithm ever finds an overlap the algorithm adjusts the location of the anchor points and or the size of the box as described earlier to fit in all of the information. Once the algorithm has compared the information types found no overlap and found that the information fits within the box it displays the box . In this way the graphical user interface program ensures that the information types displayed by the boxes do not overlap and are aesthetically pleasing while keeping the size of the box to a minimum.

Many box spacing algorithms may be used with the GUI . Many variations of the described algorithm are possible which will perform the function of spacing text and or graphics within a circumscribed space on a display . In the preferred embodiment as shown in comments are used extensively on graphical displays to assist the user in understanding the data and relationships of the data the user is viewing. In this manner a great deal of information about a node or a link can be placed in or around a graphical box display for the node . With this information a user has a better understanding of the relationship between data and the database and the graphical box represents more than just a location in the X Y and or Z coordinate plane.

The comment descriptor shown on allows comments to be assigned to a particular link sub type and for these comments to be displayed on the node box of a linked node . It is preferred that this comment descriptor assigned to a link sub type be placed on the to node of the link . Some examples of possible comment descriptors are overruled by criticizes distinguishes. When a node box is displayed these comment descriptors may be shown in any portion of the node box . In a preferred embodiment the node box is subdivided into three parts 1 a title place holder part 2 a graphics place holder part and 3 an indicator part.

To specify the specific place within the node box that the comment will be displayed a comment place holder which is a more specific type of the anchor point discussed previously. In the preferred embodiment a comment place holder may specify three different place holder areas title area indicator area or graphics area in the node box in which the comment is to be displayed. Various other place holder options within or in the vicinity of a box are possible.

Also using the commands available through the comment display order or the always display comment commands the user or designer of the database may specify when particular comments will or will not be displayed and in what position the comments will be displayed. In the preferred embodiment the always display comment is used to make a comment always available or globally available at any time it is relevant. In other words the comment will be displayed whenever the to node box is drawn on any map. It is preferred that this global comment be used whenever a comment is so important that it should be shown whenever relevant.

The comment display order specifies the order or preference in which to display multiple comments in one comment place holder . In the preferred embodiment a number in the range of zero 0 to two hundred fifty five 255 is assigned as the priority of any specific comment . Wherein zero 0 signifies that the comment has high priority and should be displayed at the top of the title or indicator place holder or on the left in the graphics place holder while a value of two hundred fifty five 255 means that the comment has very low priority and should be located at the bottom of the title or indicator place holder or on the right in the graphics place holder.

The always display comment can be simply a binary value of zero 0 or one 1 wherein if the value is zero 0 the comment is only displayed on the to node when a link of the specified link type is represented on a map and the from node is also on the map. A one 1 means that the comment is displayed on the to node at all times whether or not the from node appears on the map.

Comments may be active or inactive. Active comments provide another means for a user to navigate in the database in a customized and flexible manner. Active comments allow a user to jump or to access a menu a map or an extension by selecting the comment . The active comments may also allow a user to jump into a particular object in the database . In the preferred embodiment comments which are always displayed or are global comments are preferably active comments. Comments which are assigned low priorities and or are not global are preferably not active comments . Referring to the comment may be an icon or graphics such as the red flag shown in the node boxes .

Coloring shading texture and background can be useful and very effective tools for visually passing information to a user. Shading texture or coloring can be used both within boxes on the screen and in the background area of the maps or screen displays. The coloring or background inside a box can represent a particular data type. In one embodiment the user chooses a color to assign to all the distinct data types used in the database . When the user subsequent uses the invention the invention will display those data types in the color chosen by the user. For example in a medical database where boxes represent patients patients admitted through an emergency room can be assigned a different color box than patients admitted through a normal process or patients that survive a procedure may have a different color box than patients who die. This allows a user to see at a glance what type of data he or she is looking at. Changing the color between boxes is particularly useful and is discussed in further detail later.

Some of the preferred uses for passing additional information through the background are changing the background type of a map at a particular point on the X Y or Z coordinate. A specific example would be changing the background coloring on a map at a particular point on an axis where that point on the axis represents an average a median or an important date. Another example is creating a background coloring band between two points on the same axis representing an acceptable or ideal range for a variable. Either the computer or the user can choose what value to change the background type around. The background can change on more than one axis creating panels or areas within a map or screen.

Finally for purposes of consistency within a particular application of the graphical user interface the coloring of the background of maps of the same type are preferably the same or similar. For example source maps showing the source for a particular searched object may all have yellow background while influence maps which show objects that have been influenced from an identified object may all have a blue background for the map. In this way background coloring and texture can play an important role in visually providing information to the user on a map or screen with the present invention.

In order to present the most aesthetically pleasing display or output the preferred GUI Program chooses an optimal bit map or swatch to create a graphical display. In particular the GUI determines the color resolution and style supported by a display output from a printing device or any other computer output. The GUI Program preferably accomplishes this by categorizing general types of displays and output devices and assigning bit maps or swatches for use with those general types. These general types may include types of printing devices such as color printers laser printers inkjet printers dot matrix printers and types of displays such as black and white monitors and color monitors with differing resolution capabilities. This feature of the GUI chooses the optimal bit maps or swatches to use as fill in on boxes and the like used in the graphical display.

To achieve this capability the GUI Program preferably uses an algorithm to determine what type of display or printer or other output device is being used by the user. The algorithm then matches that type with one of the general types of categories stored in a look up table as shown in . If the type of display or output device is an exact match with one of the stored types then the algorithm instructs the GUI Program to use the bit map indicated by the table. If the type of display or printer does not match with one of the stored types then the algorithm determines the optimal bitmap for this display or printer.

The preferred bit map fill algorithm determines an optimal fill by determining the category the display or printer being used is closest to and then picking a bitmap according to certain weighted factors. The algorithm preferably chooses a bitmap or swatch that will optimize the color depth and resolution of the display or printer. If both color depth and resolution cannot be optimized by one bitmap the algorithm preferably chooses a category of bitmaps which will optimize the display or printer s color depth and then looks in that sub category for bitmaps which will optimize its resolution. The use of this algorithm results in graphical outputs that take advantage of the user s hardware capabilities.

The GUI Program also preferably uses the look up table to determine the best bit map to be used as a background for the windows . The GUI Program executes an algorithm which determine what type of display is being used and accesses the look up table to determine the preferred bitmap . If the type of display being used is not in the table the algorithm preferably selects the bitmap that is the best fit again weighing factors such as color depth and resolution in determining the best bitmap for display as a window background .

It is preferred that the graphical user interface GUI use a windows approach or a Windows type application. The preferred GUI for a database is unusual in that during the normal course of operation it is common in fact preferred for many search map windows to be visible at any given time. The preferred GUI embodiments utilize various mechanisms to help manage these windows and avoid confusing the user with too many open or active windows .

An example of the type of hardware which may be used to implement a preferred window management system is shown in . Specifically it is preferred that a processor display memory and a input device such as a mouse or keyboard are used. Although the GUI is described primarily for use with a database management system the GUI may be used with many other software applications and in many other hardware configurations.

For the preferred GUI window management system embodiments a parent window or parent frame window is used with multiple active child windows. Various mechanisms or commands may be utilized to help manage a plurality of active windows . For example cascading may be used to arrange the currently displayed windows in an orderly consistently overlapping fashion. The windows are arranged such that each newly activated window is a fixed size and the title bars of previous windows are still visible. Tiling may also be used to arrange the currently displayed windows in an orderly non overlapping fashion. When using tiling the child windows are drawn as large as possible within the parent frame window covering the entire frame window area. There are two preferred methods of tiling Tile Vertical and Tile Horizontal. Vertical tiling generally involves the side by side display of child windows e.g. two windows side by side shown in while horizontal is above and below e.g. two windows one above and one below shown in . Minimizing may be used to display or represent a particular child window in a very small space examples of representative displays include graphics icons and or a text titles. The minimized child window may be displayed at various places in the parent window e.g. at the bottom of the parent window taskbar or titlebar . Maximizing may also be used to display a particular child window as large as possible within a parent windows area. A maximized child window covers or obscures all other active child windows. Restoring may be used to restore a minimized or maximized child window to its previous state. Icon arranging may be performed to arrange all child windows being represented as icons in an orderly fashion.

In addition in the preferred GUI embodiment an auto arrange feature is utilized for enhanced window management. The auto arrange feature solves many of the problems inherent in an interface which creates a large number of child windows. When the number of child windows is large no arrangement that tries to display all windows at the same time works very well. The child windows either become too small or too cluttered. Forcing the user to manually select a subset of the child windows in which the user is most interested manually arranging those windows to be viewed in a primary format and minimizing the rest of the windows for viewing in a secondary format or ignored . The user must perform this window management each time a new arrangement is desired which often means each time a new window is activated or displayed. The auto arrange feature automates this process for the user and intelligently arranges the windows for the user s screen.

With the auto arrange feature a limit is placed on the number of windows to be displayed in the primary format at any one time a desired number of activated windows . This limit may be set by default by the user or by an intelligent process which analyzes for example the amount of data to be visually represented screen size and other variables to determine an optimum number of windows and a layout for those windows .

Referring generally to one version of the auto arrange process involves the following general steps 1 Based on a default value or through an intelligent process identify the most recently activated windows which will be allocated the greatest amount of screen space 2 Using one of several methods minimize the screen size of the remaining windows so that their identities may be recognized by the user but only need a small amount of screen space e.g. icons text 3 Arrange the identified windows in a useful and space efficient manner. e.g. vertically horizontally cubes etc. 4 Arrange the minimized but recognizable windows in an orderly but non obtrusive manner on the screen e.g. arrange icons in lower corner of screen . Using this automated process the windows can be automatically rearranged each time a new window is activated by repeating the above steps or whenever the user initiates the process. The windows are kept in an organized and useable fashion with little effort on the part of the user. The auto arrange can use different formats primary secondary tertiary etc for different levels of interest in the window . The auto arrange feature can also be turned on or off at the will of the user.

Instead of recognizing and minimizing the windows which are beyond the desired number of active windows the system may simply ignore these windows or some combination of minimizing and ignoring may be used 2084. For example if the desired number of active windows for display is two the last two activated windows may by arranged on the screen side by side in a full format and an additional three windows may be recognized and minimized to icons for display on a small portion of the screen. Any windows beyond the last five activated windows are ignored by the GUI window management system.

By providing some options preferences options for the auto arrange feature the feature can be customized to the particular taste of a user. The desired arrangement of the windows or target arrangement can be explicitly chosen by the user and changed at will by the user or chosen from a list of available formats . For example a user can specify the number of windows to display the particular format each window will appear on the screen and the layout of the screen. There possible screen layouts are nearly limitless. Various formats are possible for each window for example as full vertically stretched horizontally stretched or enlarged format. The user can chose the number of windows to be displayed in each format for example two three or four windows in the format. And therefore a target arrangement can be chosen such as full format two windows vertically side by side. Thus when step three of the auto arrange process is preformed the system will identify the two most recently activated windows and arrange the two windows in the target arrangement side by side rather than in some other manner. In the preferred embodiment a menu is provided to the user permitting the user to chose a target arrangement including number of windows format of windows and screen arrangement.

For high end power users the window management system can be modified to allow the user to custom build nearly any arbitrary layout for the screen. The user creates any number of arbitrary layouts each of which is given a name that is inserted into a window menu and is stored in a database. After a layout has been named it is then treated as a new window management command which can be executed. In the most sophisticated embodiments through the use of pointer and or a mouse the user selects anchor points such as center points or upper left upper right lower left lower right and various shapes for the windows such as hand sketched rectangular triangular rhomboids octagons etc. In this manner displays can be generated which are suited for specific uses. Also through this medium the artistry and creativity of the user may be expressed in aesthetically pleasing displays.

An innovative feature of the preferred embodiment is the ability to call up a search screen or map while viewing the data of a particular object in the database . This feature is implemented through the use of embedded active links . By using embedded icons that are active within the data of an object being viewed or by using embedded text which is active within the data of an object in the database this feature allows the user to jump from viewing data to a search screen menu map or the like. The search screen or map can be one which has been previously generated or can be generated at the time of selecting the embedded active icon or active text.

The preferred method of using this feature is with text documents. Active icons or active text are embedded within the text documents and the user is alerted to these active icons or text through the use of highlighting or different coloring of the active icon or text. When the user sees an active icon or active text while viewing an object in the database the user may choose to jump out of the object and into a map search screen or the like.

The system may be configured so that upon selection of an active icon or active portion of text a menu is displayed to the user wherein the user may select the generation of a particular map or the return to an existing map that was previously generated.

Although these active links within an object in the database have been described for use in jumping from an object in the database to a map the active links may be used to jump to other objects in the database or extensions to other databases other applications or communication programs. Providing active links within objects being viewed in a database allows great flexibility for the user to navigate through data in any manner he chooses.

To allow access to extensions to other databases the preferred embodiment is set up in a modular fashion in order to be able to modularly add extensions or add on links to connect to other applications or programs which can be called up from the present invention.

In the preferred embodiment the invention is set up in a modular fashion to accept one or more extensions. An extension can be another application or can be a communications link to connect to another computer or application. Use of these connections is particularly well suited for the invention in that the underlying data need not be stored locally with the user but instead through the use of extensions the underlying data can be accessed by the user through an extension another application and or through a communications link.

Multiple extensions are possible and it is possible for the same underlying data to be available through one or more extensions this allows the user to choose which extension or communication link it will use to access underlying data. In the preferred implementation a box is given depth to signify that an extension associated with a particular box is available to the user. By activating the box the user is given the opportunity to use the extension. In the preferred embodiment with modular implementations of extensions a user can add on or plug in further extensions or eliminate extensions.

Another feature of the preferred embodiment is the show usage command. is a screen display depicting the use of the show usage command. The preferred embodiment includes this command to allow the user to see a portion of an object in the database which uses cites or refers to the node from which the show usage command is requested. More specifically the show usage command allows the user to see the text or data of a portion of the document that is represented by the node being searched. In the preferred embodiment the show usage command is only available from a result node . When a map or graphics display is shown the search node is the node upon which the search being displayed is based. The result nodes are the nodes which are graphically displayed as a result of the search conducted upon the search node . Referring to the search node is v. and the result node is 26 U.S.C. 83.

Through the use of the show usage command a user may immediately access that portion of the search node object or document which refers to a specific result node . This is accomplished by breaking up the data connected to the search node into groups of records with header identifiers. The data attached to the result node will also have an identifier a header identifier which particularly identifies the data attached to it. When the user executes the show usage command after activating the result node the record or records in the data attached to the source node which match the result node identifier will be displayed and highlighted. For example in the v. document is shown highlighted at the appropriate location identifying 26 U.S.C. 83 2104. The show usage command is accessed through the use of a pull down menu from the result node 26 U.S.C. 83 2104. Using the earlier example of modem an classical architecture if the search node was modern architecture and the search requested items influencing modem architecture an influence map or graphic display would be generated which would include the classical architecture node. By selecting the classical architecture node and using the show usage command on the classical architecture node for example through a pull down menu or directly in the node box the invention will immediately bring the user to the first location in the modem architectural data where classical architecture is referred to as influencing modem architecture. Thus in effect the show usage command allows the user to jump from a result node to the specific location in the search node where the result node is referenced or identified.

Finally one of the most important features of the invention is its method of integrating itself with third party software applications. Although useful with many third party software applications it is particularly useful to integrate the present invention with third party database applications which operate in a windows type environment. Nearly all of the database management functions and graphical user interface features can be used in an integrated scheme with third party database management software.

The preferred method of integrating the present invention with third party software is through the use of a subclassing technique in a windows multiple document interface MDI environment. Specifically the present invention can take advantage of the common behavior exhibited by MDI applications to integrate with third party software operating in a windows environment.

When the preferred embodiment of the invention is loaded to be used in conjunction with third party software application the invention immediately subclasses the third party software applications frame window. Through this subclassing technique the present invention receives intercepts every message or command originally intended for the third party software. Since the invention is the first to receive each window message it acts as a message arbiter. The message arbiter has the ability to recognize the message or command and decide how each message should be processed. For example the arbiter decides whether any given message should be processed by the master program the invention or by the subclassed third party software.

The precise processing that is appropriate for a given message is somewhat message dependent. However the general message scheme dictates that messages intended for one of the child MDI windows or that depend in some way on the content of a child window are dispatched to the application that is the real owner or creator of that child window. Thus most messages are dispatched to the software application to which the child window belongs to which the window is a native if it the window belongs to a subclassed application the message is directed or forwarded to the subclassed application. The subclassed application then processes the forwarded message and changes a child window display if necessary. Using this technique the subclassed software application acts as if it alone owns the main frame window. Thus operation of the master program has little affect on the performance of subclassed program. Further the operation of the subsclassed program is transparent to the user. To the casual user the master program operates all the windows and is the only user interface used.

Using this technique more than one software application may be subclassed with the present invention. Also each subclassed application may have multiple child window displays. And finally the master application may generate its own native windows which may be displayed simultaneously with the child windows of a subclassed application.

This computerized system for researching data is also effective with any type of internal or global network application see generally . As long as a network stores data and provides links between that data this system can provide an effective and efficient system for indexing searching and displaying that data. For example this system can be applied to the Internet and the World Wide Web. The World Wide Web is made up of numerous web sites which contain documents and internet or web pages. Documents are usually defined in the art as unique pieces of data which includes text files graphic files audio files and video files. A web page is usually a document with its own Universal Resource Locator URL . URLs are the standardized addresses commonly used for web pages. Generally web sites are a collection of web pages and documents. Web sites are usually identified by a home page which may contain an overall starting point for the web site and a summary of what is to be found at the web site. Hyperjump links or hyperlinks is the name commonly given to the links which connect web pages web sites and documents on the web. Hyperlinks are electronic links which allow end users to jump to the specified web page or web site. The software code commonly used to create the majority of web pages containing text files is HyperText Markup Language HTML . Other pages containing graphics audio video and other resources may not be coded in HTML but still will be connected by hyperlinks.

The Internet can be viewed as an immense collection of linked documents providing varied information to the public via an elaborate electronic distribution channel. In the past the end user s ability to search find index and navigate through relevant documents of interest has been primarily limited to word based queries which primarily rely on the target document s text indexing. Instead of relying on textual searching this method and apparatus for indexing searching and displaying data analyzes hyperlinks which connect web pages to other web pages in order to help the end user to search find and navigate through the relevant documents of interest. This system analyzes hyperlinks using proximity indexing or clustering technology discussed previously. Once identified the system displays the results in a variety of ways and end users are able to navigate directly to the documents identified by this system s analyzation technology.

In the preferred embodiment this system uses the cluster link generation algorithm described in to search and identify closely associated documents located on the Internet in the same manner as described above. The system treats hyperlinks on the Web in the same manner as it treats links in a database and it treats web pages on the Web in the same manner as it treats nodes in a database . Source links on the Web link a source node or source web page to a second node or second web page . Influence links perform the same function in reverse. Direct links as described above are the same as hyperlinks which use URLs in the World Wide Web and they directly link one web page or node to another. Indirect links link two web pages or nodes through more than one path. A cluster link for purposes of the Web is any relationship between two web pages.

To begin the process as shown generally in a node is chosen for analysis. Next the system accesses link data or crawls the source web page or source node looking for URLs which directly link the source web page to other web pages. Web crawling is a known technique in the art performed by most World Wide Web search services such as Yahoo located at www.yahoo.com or Alta Vista. Crawling is accomplished by the use of automated programs called robots or spiders which analyze a web page for objects which provide URL links to other web pages or documents. The source node whether it is a web page the home page of a web site or a document with no links is a data document which may have been encoded in HTML or some other language. The encoded data document includes commands such as insert picture here or begin a new paragraph or place a link here to another document along with the normal text of the document. These coded commands are generally invisible to the end user although many Web documents reveal text containing coded links to other documents in different colors. The system reads the coded HTML instructions to identify the coded links which are direct links . There are many publicly known methods of identifying links from a coded document that one skilled in the art could employ to perform this function.

Once a candidate cluster link set is identified the generator assigns 2064 2076 weights to the candidate cluster links . The weight of each individual path or link is a function of the weight of the path to the previous node and the weight of the last link . In order to determine the weight of an implied link the preferred formula WC min WC D W as previously discussed is used. Following weighting the generator sorts the set of candidate cluster links by weight and a subset of these links those links above a specified cut off weight are retained for display to the end user. In the preferred embodiment the formula T min constant 4 d discussed before determines the optimal cut off weight.

In another embodiment the Proximity Indexing Application Program Program organizes and categorizes the crawled links using the statistical techniques and empirically generated algorithms described earlier in this application. The Program treats URL addresses as citations and web pages as textual objects. The Program applies some or all of the eighteen pattern list to determine the relatedness of the web pages or nodes which are linked to the source web page or node . The Program weighs the patterns by importance giving one type of data document more importance than another type. For example it may give more importance to a web site than to a single document which has no other links. The Program may use other factors to weigh the data documents such as the number of hits . visits by other end users to the site a number which is available to web users a data document receives in a specific time frame or the number of hyperlinks within a page. The Program then forms a matrix based on ordered pairs of documents and the matrix calculations discussed before of this specification can be carried out. The Program generates a coefficient of similarity which will determine the relatedness of web pages to each other and to the source web page. The Program displays the most similar web pages to the user.

The preferred embodiment of the network application of this system uses the graphical user interface program to display the results of the algorithm as a list showing the selected links and the various data associated with the links . The links shown on the screen to the end user are active links similar to the active comments used in the text boxes described previously in this application. The end user may instantaneously link to the destination node that the user selects. The list format provides link information in a style familiar to user of the Internet. However this system is also capable of displaying the results in the user friendly graphical format as described above. The graphical user interface program described previously uses box coloring and sizing to communicate large amounts of information quickly and intelligibly to the user. In a preferred embodiment different colors for boxes are assigned depending on what type of node they represent e.g. a web page web site a document a file transfer protocol FTP a common internet designation for news sites . Preferably the box is given depth. The amount of URL links a node contains may determine the amount of depth.

The graphical user interface program displays a list of the most related web pages to the source web page. This list includes documents web sites and pages which are directly or indirectly linked to the subject document or the subject topic. The links can be source links or influence links so the end user may monitor the sites to which his site the source web page is referring and the end user may view the sites which are referring to his site. The system can parse the URL of the destination nodes for a variety of information. Thus the end user may monitor whether the connections to which his web site refers are still open the end user may view the date and time a destination node was modified and the end user may view the identification of the organization or author of the destination node that directly or indirectly links to the source node . The GUI program displays all of this information either in the list format or in the text box used in the graphical format. Graphical comments may be placed in the text box to communicate information quickly such as showing a happy face for a connected application and so forth. Hyperlinks can appear as active comments in a text box in order to allow the user to instantaneously jump to the web page represented by the text box.

Although this computerized system for researching data is described as functioning in the World Wide Web environment it can function equally well in any network system. A network that utilizes any type of hyperjump to connect documents together can serve as the links analyzed by this invention. This system therefore can be modified to navigate and search through internal company networks and provide the same features as described above for the Web application. Additionally the comment boxes can be tailored to display critical information about company files thus enhancing its usefulness for the company employee who is attempting to sort through company documents stored on a network.

