---

title: Method and apparatus for redirection of machine check interrupts in multithreaded systems
abstract: Disclosed is a communication mechanism among hardware, firmware and system software in order to redirect interrupts or other hardware events to only one thread execution context of an error domain for a multi-threaded processing system. Other embodiments are also described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07721148&OS=07721148&RS=07721148
owner: Intel Corporation
number: 07721148
owner_city: Santa Clara
owner_country: US
publication_date: 20060629
---
The present disclosure relates generally to information processing systems and more specifically to error handling in processor systems.

Error handling in computer systems involve error detection and error recovery. In error recovery errors should be contained and computer systems should be highly available. Computer systems utilizing error handling that is coordinated among processors system logic hardware firmware and operating system can contain errors and reduce the time computer systems are not available. Additionally the processor s system logic hardware firmware and operating system should have interfaces to one another to allow coordination between them during error handling.

System software is defined herein as any code including firmware code that is executed in a privileged mode such as any code that runs at ring 0 privilege level. This definition of system software is intended to include the firmware and operating system OS kernel that is executed by a single CPU in a single processor system or is executed by a plurality of CPUs in a multi processor system. Thus system software may include firmware such as PAL and SAL code discussed below as well as operating system kernel software code.

Firmware as used herein refers to code routines that are stored in non volatile memory structures such as read only memories ROMs flash memories and the like. These memory structures preserve the code stored in them even when power is shut off. Even though firmware is stored in non volatile memory firmware may be copied or shadowed to volatile memory. Typically this is done for performance reasons.

One of the principal uses of traditional firmware is to provide necessary instructions or routines that control a computer system when it is powered up from a shut down state before volatile memory structures have been tested and configured. Firmware routines may also be used to reinitialize or reconfigure the computer system following various hardware events and to handle certain platform events like system interrupts.

Another typical use of traditional firmware is to provide complex sequences to be performed in processors that utilize complex instruction sets. A typical instruction in a CISC complex instruction set computer computer processor performs a series of operations with microinstructions that define some of the more complex operations being encoded in a non volatile storage area in the form of microcode. The microcode defines all or a portion of the executable instruction set for the processor and may also define internal operations that are not implemented in software accessible code. The microcode is typically placed in a read only memory ROM within the processor at the time the processor is manufactured.

Operating systems OS interact with firmware to provide an environment in which applications can be executed by the CPU. By utilizing firmware an OS can be designed to run on many different processing systems without re writing the OS for each variation in platforms. For at least one embodiment the term operating system as used herein is intended to broadly encompass any privileged software layer that performs scheduling including a scheduling layer that is distributed over a cluster of platforms.

The following discussion describes selected embodiments of methods systems and mechanisms to redirect machine check interrupts in a system having multiple thread execution contexts sometimes referred to herein as TEC s to only one of the contexts which may then notify the operating system of the interrupt. The apparatus system and method embodiments described herein may be utilized with single core or multi core systems. In the following description numerous specific details such as processor types boot processing multithreading environments system configurations and specific API Application Programming Interface parameters have been set forth to provide a more thorough understanding of embodiments of the present invention. It will be appreciated however by one skilled in the art that the invention may be practiced without such specific details. Additionally some well known structures circuits and the like have not been shown in detail to avoid unnecessarily obscuring the present invention.

For at least one embodiment firmware includes BIOS basic input output system code and microcode that reside either on chip in ROM memory or off chip in other non volatile memory such as flash memory. Before a computer system can operate it must have an operating system OS in its memory that allows the computer s resources to be reached and controlled by the other software such as the various application programs. The computer hardware has a non volatile comparatively simple bootstrap program to perform a boot sequence and load the operating system from disk. Typically the bootstrap program is invoked by the BIOS program.

For at least one other embodiment firmware includes two major components the processor abstraction layer PAL and the system abstraction layer SAL . PAL and SAL may work together possibly along with other firmware components such as an Extensible Firmware Interface EFI to provide processor and system initialization for an operating system boot. The PAL and SAL also work together along with the operating system to perform error handling.

The PAL is the firmware layer that abstracts the processor implementation it encapsulates all processor model specific hardware. It encapsulates those processor functions that are likely to change based on implementation so that SAL firmware and operating system software can maintain a consistent view of the processor. The PAL thus provides a consistent software interface to access the processor resources across multiple different implementations of processor hardware.

SAL is a platform specific firmware component that isolates operating system and other higher level software from implementation differences in the platform. SAL is typically provided by original equipment manufacturers OEM and BIOS vendors.

In the following discussion particular embodiments are shown in order to illustrate certain features of the invention. The particular illustrated embodiments include PAL and SAL firmware components. However one of skill in the art will recognize that the principles discussed herein may be equally applied to other embodiments including embodiments of systems that do not include PAL and SAL firmware components. For example in such embodiments those PAL functions described below may be performed in hardware or microcode. Also for example those SAL functions described below may be performed by BIOS code or may also be performed by hardware circuitry.

Before discussing in detail and will be discussed in order to provide background information relevant to the methods shown in . Generally is a data flow diagram illustrating at least one embodiment of a method for selecting as thread execution units are added to an OS running system one thread execution context to receive corrected machine check interrupts for the error domain of a shared resource in a multi threaded computing system. is a data flow diagram illustrating at least one embodiment of a method for selecting a different thread execution context to receive corrected machine check interrupts for the error domain of a shared resource as thread execution units are removed from an OS running system in a multi threaded computing system.

The code for the PAL and SAL layers for the illustrated embodiment or for other firmware such as BIOS and microcode for other embodiments may reside in one or more non volatile memories or persistent memories of the system. For example the code may reside in flash read only memory ROM . Embodiments of systems that includes non volatile memory are discussed in further detail below in connection with . The code for these firmware layers may be shadowed to other memory devices. In the following discussion it is intended that the terms PAL SAL and OS represent PAL SAL or OS code intended to be executed by a processor.

Processor hardware represents one or more processors in a single or multiple core multi threaded computer system and is not limited to a certain processor. The processor may be any of a variety of different types of processors that execute instructions. For example the processor may be one or more general purpose processor cores such as a processor in the Pentium Processor Family or the Itanium Processor Family or other processor families from Intel Corporation or other processors from other companies. Thus the processor may be a reduced instruction set computing RISC processor a complex instruction set computing CISC processor a very long instruction word VLIW processor or any hybrid or alternative processor type. Moreover special purpose processors such as network or communication processors co processors embedded processors compression engines graphics processors etc. may use disclosed techniques. As integration trends continue and processors become even more complex the need to monitor and react to internal performance indicators may further increase thus making presently disclosed techniques more desirable. However due to rapid technological advance in this area of technology it is difficult to foresee all the applications of disclosed technology though they may be widespread for complex hardware that executes program sequences.

The processor hardware is multi threaded in the sense that it includes two or more thread execution contexts such that two or more threads may execute concurrently. That is one software thread may execute in each thread execution context. For instance for at least one embodiment the processor hardware is a multi processor chip known as a chip multiprocessor CMP where each of multiple single threaded processor cores in a single chip package may each execute one of the multiple software threads concurrently.

For at least one other embodiment referred to as simultaneous multithreading SMT each of one or more processor cores of the processor hardware may be a single physical processor core that is made to appear as multiple logical processors to operating systems and user programs. For SMT multiple software threads can be active and execute simultaneously on a single processor core without switching. That is each logical processor maintains a complete set of the architecture state but many other resources of the physical processor such as caches execution units branch predictors control logic and buses are shared. For SMT the instructions from multiple software threads thus execute concurrently on each logical processor.

Accordingly the processor hardware may be a single multi threaded processor such as an SMT processor in a single chip package. Alternatively the processor hardware may represent two or more SMT multi threaded processor cores in a single chip package. Alternatively the processor hardware may be two or more single threaded processor cores in the same CMP chip package. We now briefly turn to for further detail regarding some different implementation schemes for embodiments of processor hardware .

For the SMT environment a single physical processor is made to appear as multiple logical processors not shown referred to herein as LPthrough LP to operating systems and user programs. Each logical processor LPthrough LPn maintains a complete set of the architecture state AS AS respectively. The architecture state includes for at least one embodiment data registers segment registers control registers debug registers and most of the model specific registers. The logical processors LP LPshare most other resources of the physical processor such as caches execution units branch predictors control logic and buses. Although such features may be shared each thread context in the multithreading environment can independently generate the next instruction address and perform for instance a fetch from an instruction cache an execution instruction cache or trace cache .

Thus the processor includes logically independent next instruction pointer and fetch logic to fetch instructions for each thread context even though they may be implemented in a single physical fetch decode unit . For an SMT or embodiment the term thread execution context encompasses at least the next instruction pointer and fetch logic for a thread context along with at least some of the associated architecture state AS for that thread context. It should be noted that the thread execution contexts of an SMT system need not be symmetric. For example two SMT thread execution contexts for the same physical core may differ in the amount of architectural state information that they each maintain.

Accordingly for at least one embodiment the multi threading system is a single core processor that supports concurrent multithreading. For such embodiment each thread execution context is a logical processor having its own instruction next instruction pointer and fetch logic and its own architectural state information AS although the same physical processor core executes all thread instructions. For such embodiment the logical processor maintains its own version of the architecture state although execution resources of the single processor core may be shared among concurrently executing threads.

Accordingly for at least one embodiment of the multi core CMP embodiment illustrated in each of the thread execution contexts may be a processor core with the multiple cores residing in a single chip package . Each core may be either a single threaded or multi threaded processor core. The chip package is denoted with a broken line in to indicate that the illustrated single chip embodiment of a multi core system is illustrative only. For other embodiments processor cores of a multi core system may reside on separate chips.

Regardless of the particular implementation of processor hardware it is sufficient to note that the processor hardware represents a single chip package also referred to herein as a socket that supports multiple thread execution contexts that can concurrently execute multiple threads.

Returning now to it is shown that components of system illustrated in may work in close cooperation to handle different error conditions of the system . System errors may be handled by each of the following components platform hardware processor hardware PAL SAL and OS .

If the processor hardware or platform hardware corrects an error it signals a notification of the corrected event to the OS via a relatively low priority interrupt. For processor corrected events this interrupt is referred to as a corrected machine check interrupt CMCI . For platform corrected events this interrupt is referred to as a corrected platform error interrupt CPEI . For at least one embodiment the OS may choose to disable these interrupts and instead periodically poll firmware to collect information regarding corrected error events .

Further information regarding the generation and handling of corrected error interrupts may be found in Intel Itanium Architecture Software Developer s Manual Volume 2 System Architecture Revision 2.2 2006 at sections 5.8.3.8 and 13.3.1. Additional information may also be found at section 4.2 of Intel Itanium Processor Family System Abstraction Layer Specification 2003 and at sections 2.5.1 and 3.3 of Intel Itanium Processor Family Error Handling Guide 2004. Each of these references is available from Intel Corporation.

It should be understood that the term corrected error as used herein includes a broad range of types of hardware events. At the very least a corrected error is an error that has been detected. In addition to detection some action has been taken to ameliorate the error. It may be that the action taken results in complete correction of the error so that processing may continue without any further consequences from the error that was corrected. However for other embodiments the corrected error may have been partially corrected or may have been logged or flagged for later correction. For at least one embodiment for example a parity or ECC error correction code error may be detected but instead of immediately correcting the error a flag may be associated with the data associated with the errant parity ECC code to indicate for later processing that the data has been poisoned .

For at least one embodiment when the processor hardware detects an error that is not correctable directly by hardware it may generate a hardware event or signal called a machine check abort MCA when the error is one that threatens to damage the architectural state of the machine and may possibly cause data corruption. The MCA event passes control to the firmware.

Both PAL and SAL include error handling routines. An error that the PAL layer cannot correct may be passed to the SAL see MCA . The error handling routine of SAL can use the PAL set of procedures to obtain additional information from the processor or platform. illustrates that the interface between PAL and SAL may be for at least one embodiment an API Application Programming Interface which is a set of calling conventions in programming that define how a service is invoked. More generally the interface between PAL and SAL includes a mechanism for communicating events between the two layers.

The PAL and SAL error handling routines correct any errors that they are capable of correcting if control is passed to them for an error that the processor hardware or platform hardware cannot correct. Processor detected errors may be corrected by PAL whereas platform detected errors may be corrected by SAL .

The firmware handlers correct the errors and then resume execution of the interrupted context. These firmware corrected errors require no OS intervention for error handling. However they may be signaled to the OS so that the OS may utilize information regarding corrected errors for reliability purposes discussed below . Errors that are corrected by firmware layers are signaled to the OS as a CMCI if corrected by PAL or a CPEI if corrected by SAL . Again the OS may choose to disable these interrupts and instead poll the firmware for this information .

Corrected errors in the processor hardware and platform hardware may be logged by the OS in NVRAM or on disk. For a system that provides high reliability an OS may choose to proactively act upon receiving a corrected error indication. For example for at least one embodiment the OS may employ predictive failure analysis PFA algorithms which interpret the history of past corrected errors and attempt to correlate these instances to a specific system component. This allows the OS to take the errant component off line and thus prevent a potential failure situation where the entire system is brought down by a fatal error in the errant component.

On the other hand if an error is not correctable by firmware control is passed to the OS for further error handling see MCA . That is for errors which are not corrected by the error handling routine of SAL execution branches or hands off from the error handling routine of SAL to the error handling routine of OS .

If control is passed to the OS for error handling the OS corrects the errors that it can and then either returns control to the interrupted context switches to a new context or resets the system .

Reference is now made to for a further discussion of shared resources as they relate to error handling in a multi threaded system. is a block diagram illustrating different multi threaded systems that include shared resources. The first system generally shows two cores which may be either single threaded or multi threaded cores that share a resource . The cores provide for concurrent execution of software threads. The resource may be any resource that is shared among thread contexts in a multithreading system including a shared cache DRAM or other memory shared bus interface or the like. The double arrows and dotted lines in are intended to illustrate that the placement of the shared resource may be either inside the chip package or socket see solid box for shared resource or may optionally reside outside the socket see broken box for shared resource .

For simplicity of example specific embodiments of shared resources discussed in connection with specific example systems and in . The specific embodiments of shared resource illustrated in include a shared data buffer and shared bus interfaces . However such illustration should not be taken to be limiting. The shared resources illustrated in may be any resource that is shared in or among thread contexts.

Also for simplicity the multi threaded systems shown in are CMP systems. However one skilled in the art will appreciate that any other shared resource is equally applicable to the discussion of as are other types of multi threaded systems such as a single core SMT system that provides two or more logical processors to support concurrent execution of multiple software threads .

A corrected error for a shared resource may affect more than one thread execution context. For example a corrected error in the shared cache of system may affect threads running on both Core and Core . In a traditional single core single threaded system there is a 1 1 relationship between the resource and the thread execution context. If an error occurred on a resource such as a cache or translation lookaside buffer for example the associated CMCI is delivered to the core where the resource resided.

However this scheme becomes more complex in a multithreaded system such as an SMT system or CMP systems such as those illustrated in . Assuming that an instance of the OS is running on each of the cores the CMCI for a shared resource such as cache may be reported to the OS by each of the cores . Accordingly the OS may receive multiple corrected machine check interrupts for the same resource. Such approach preserves the 1 1 relationship between the error on the shared resource and the corresponding CMCI interrupt to the associated thread execution context. However an inefficiency associated with this approach is that there are multiple CMCI interrupts generated corresponding to each sharing thread execution context for every corrected error event. This approach can lead to unnecessary OS overhead especially for future processor architectures that may have significant numbers of cores and threads integrated on the same piece of silicon.

The set of execution contexts that share a resource is referred to herein as an error domain. illustrates that the two systems have differing error domains even though both systems have two cores that share a single socket.

For both systems illustrated in the error domain for shared bus interface and each includes two cores. The error domain for bus interface includes Core and Core while the error domain for bus interface includes Core and Core .

Because the cores of system each has a dedicated cache respectively the error domain for each cache only includes one core. Thus the 1 1 reporting scheme for corrected cache errors is preserved without the need to select a particular core for reporting CMCI interrupts regarding the caches .

In contrast the shared cache in system is shared by two processor cores . Thus the error domain for the shared cache includes multiple thread execution contexts. For a CMP embodiment of single threaded cores for system the error domain for shared cache includes two thread execution contexts Core and Core .

Discussed herein is a mechanism for reporting an error for a shared resource in a multi threaded system to only one of the thread execution contexts in the error domain for that shared resource. One possible approach for doing so which involves arbitrary selection of a fixed thread context to which to deliver CMCI interrupts is relatively simplistic and does not adequately address certain high reliability computing concerns.

For example if the predetermined thread execution context chosen to receive CMCI s needs to be taken off line for RAS reliability availability serviceability concerns or license management issues there may be no mechanism to ensure that the CMCI for errors is redirected to another thread execution context in the error domain. In such a scenario the OS may not be notified when subsequent corrected errors occur on the shared resource.

Another potential drawback of such approach that is of selecting a fixed thread execution context to receive CMCI interrupts for an error domain occurs if an instance of the operating system is not currently running on the fixed thread execution context. The running system of an OS is the subset of total thread execution contexts of a system on which an instance of the OS is running. Thread execution contexts that are in the running system are referred to herein as being active while those that are not in the running system but are instead e.g. in a rendezvous loop are referred to herein as being inactive. 

In the case that a thread execution context is not in the running set but has been designated as the predetermined thread execution for CMCI reporting the OS will not be notified when a corrected error occurs on the shared resource. Such a situation may occur for example if a thread execution context has been removed from the OS running system due to load balancing or capacity on demand reasons RAS considerations or due to licensing constraints with the OS software that limits the number of instances of the OS that may run on a given system.

As is illustrated in portions of the method may be performed by hardware or PAL firmware while others may be performed by SAL firmware and yet others may be performed by the OS . However it should be understood that for at least one embodiment of the method the actions taken by PAL and SAL during the method are transparent to the OS .

That is if an OS is designed to operate correctly for a single threaded system the method is designed to allow the OS to perform the same functions without modification even if the underlying implementation is a multithreaded system be it a single or multiple SMT cores or multiple single threaded CMP cores . Accordingly the following discussion focuses particularly on the portions of the method illustrated in that concern the communication mechanism between PAL and SAL in order to ensure that the thread context chosen as the CMCI recipient for a particular error domain does indeed have an instance of the OS running on it.

More generally it should be understood that illustrates one specific embodiment of a general scheme for providing communication pathways between hardware and or firmware to ensure consistency of reporting errors among different underlying hardware configurations. Although the discussion of below is focused on one particular embodiment reporting of corrected machine check errors one of skill in the art will recognize that the method may also be applied to any other instance where there is a desire maintain OS transparency for idiosyncrasies of underlying hardware implementation.

A little more specifically it should also be understood that for the embodiment illustrated in the SAL is aware of thread execution contexts that are handed off to join the OS running system see wakeup signal of and is also aware of thread execution contexts that are removed from the OS running system see remove signal of . However because SAL is removed by at least one layer of abstraction from the underlying hardware SAL is not aware of which processor resources are shared and which thread execution contexts share them. In other words SAL has no information about shared resource error domains.

In contrast PAL does have information about the shared processor resource error domains. In addition PAL also has information about the implementation specific mechanisms for redirecting a CMCI interrupt to a specific thread execution unit.

Accordingly illustrate cooperative methods for the SAL to notify the PAL when thread execution units are added to or taken out of the OS running system. This allows the PAL to avoid selecting a thread execution for CMCI notification that does not have an instance of the OS currently running on it.

In addition to each list the PAL may also maintain for each list one specific thread execution context that is designated as the target thread execution context for receiving CMCI s that occur on the particular shared resource. The target thread execution context for each list is designated in as the corresponding error domain s target . Of course in certain instances the target for a particular error domain may be undefined e.g. no thread execution units that share a particular resource are in the OS running set .

At block the boot process of PAL continues. During the boot process PAL performs processor testing and initialization. As part of this process PAL detects the thread execution contexts of the specific processor implementation and indicates them to SAL at block . From block PAL branches to an entry point in SAL .

At block SAL performs platform testing and initialization. As part of this processing SAL selects a bootstrap processor BSP from among the thread execution contexts of the system that have been indicated to it by PAL at block . All other thread execution contexts besides the BSP are placed into a rendezvous state at block . In the rendezvous state all thread execution contexts in the computer system except for one the BSP enter an idle state. The thread execution contexts in the rendezvous loop remain idle until started by the OS see block .

After selecting the bootstrap processor at block SAL communicates the event to PAL . For at least one embodiment this communication takes the form of an API call to an implementation specific PAL procedure. Just by way of example a sample API procedure call for this procedure may be characterized as follows 

Regardless of the specific implementation of the communication it should be generally understood that PAL receives the communication that an event e.g. selection of a thread execution context as a BSP has occurred. In order to notify the PAL that a thread execution context has been selected as a BSP and therefore is eligible to be a CMCI target the SAL may make a callback to PAL on the boot strap processor BSP with an indication to add the boot strap processor to the corresponding shared error reporting lists.

In response to the add callback communication the PAL updates its tracking data for each appropriate shared resource list in order to add the BSP to the list s . Processing proceeds from block to block .

At block PAL updates the target for each appropriate list in order to indicate the boot strap processor as the target if the boot strap processor is not the thread execution context selected at block as the default target.

At block the designated target TEC for each error domain may therefore be updated. Any time a target is updated at block the PAL may reprogram the underlying hardware to route also referred to herein as redirecting a CMCI interrupt only to the designated target TEC. Once this routing is set up the signaling of the CMCI to the target TEC may be handled completely in hardware with no firmware intervention until if when the target and routing needs to change . Thus this redirecting has the effect that CMCI interrupts will be routed only to a single TEC in the error domain rather than to all of them.

As other thread execution contexts in the system are awakened or made active by the OS at block the wakeup signal is detected by the SAL at block . Processing for the waking thread execution context proceeds from block to block . At block SAL makes a callback to PAL to add the waking thread execution context to the appropriate shared error reporting list s .

Responsive to the add callback PAL executes block for the waking thread execution context. At block PAL updates its tracking information for each appropriate shared resource list . Processing then proceeds to block . At block PAL sets the waking thread execution context as the target for the given shared resource error domain if no active thread execution unit is currently selected as the target for the error domain. Again PAL also reprograms at block the underlying hardware in order to facilitate CMCI signaling to the newly selected target.

The above processing is repeated for each thread execution context that is awakened by the OS during boot processing thereby removing the awakened TEC from the rendezvous loop and adding it to the OS running system so that it is now active .

Responsive to the remove signal SAL makes a callback to a PAL procedure to delete the removed TEC from the corresponding shared error reporting lists . The callback communication may be an API call along the lines of that discussed above in connection with communication of . For the delete callback SAL may provide 0 as the remove add parameter to indicate that the TEC should be removed from the appropriate shared error reporting lists .

In response to the delete callback communication the PAL updates its tracking data for each appropriate shared resource list in order to delete the removed TEC from the list s . Processing proceeds from block to block .

At block PAL checks the target for each appropriate list in order to determine whether the removed TEC is designated as a target for any of the error domains. If the TEC that is being removed from the OS running system is currently indicated as the target for any given shared resource then at block PAL selects a different TEC from the list as the target for that list . Again PAL also reprograms the hardware to signal CMCI s for the error domain to the new target TEC. In this manner the PAL ensures that CMCI s reported on the shared resource are reported on a TEC that is part of the OS system runtime.

As other thread execution contexts in the system are removed from the running system by the OS at block the remove signal is detected by the SAL at block . Processing for the removal of the thread execution context proceeds from block to block . At block SAL makes a callback to PAL to delete the waking thread execution context from the appropriate shared error reporting list s . The removed TEC s are disqualified from being a target at block and the hardware is reprogrammed accordingly.

Although not illustrated in one of skill in the art will realize that during runtime a thread execution context may be removed from the rendezvous loop by the OS in order to be added to the OS running system including any of the previously removed thread execution contexts . In such cases the processing discussed above in connection with is performed in order to update the lists and possibly update the targets as the awakened TEC is removed from the rendezvous loop and added to the OS running system and becomes active.

For the disclosed embodiment of system the at least one processor may execute code or routines stored in system memory . The code for the operating system OS may be stored in the system memory . The processor also executes code from the non volatile memory . The firmware including PAL and SAL may be stored in the non volatile memory .

The system logic may be a chipset or a portion of a chipset. The system logic may communicate with the processor s and control interaction between the processor s and memory . For at least one embodiment the system logic communicates with the processor s via a multi drop bus such as a frontside bus FSB .

Embodiments may be implemented in many different system types. Referring now to shown is a block diagram of a multiprocessor system in accordance with another embodiment of the present invention. As shown in the multiprocessor system is a point to point interconnect system and includes a first processor and a second processor coupled via a point to point interconnect . As shown in each of processors and may be multicore processors including first and second processor cores i.e. processor cores and and processor cores and .

The system shown in may instead have a hub architecture. The hub architecture may include an integrated memory controller hub Memory Controller Hub MCH integrated into each processor . A chipset may provide control of Graphics and AGP.

Thus the first processor further includes a memory controller hub MCH and point to point P P interfaces and . Similarly second processor includes a MCH and P P interfaces and . As shown in MCH s and couple the processors to respective memories namely a memory and a memory which may be portions of main memory locally attached to the respective processors.

While shown in as being integrated into the processors the memory controller hubs need not necessarily be so integrated. For at least one alternative embodiment the logic of the MCH s and may be external to the processors respectively. For such embodiment one or more memory controllers embodying the logic of the MCH s and may be coupled between the processors and the memories respectively. For such embodiment for example the memory controller s may be stand alone logic or may be incorporated into the chipset .

First processor and second processor may be coupled to the chipset via P P interconnects and respectively. As shown in chipset includes P P interfaces and . Furthermore chipset includes an interface to couple chipset with a high performance graphics engine . In one embodiment an Advanced Graphics Port AGP bus may be used to couple graphics engine to chipset . AGP bus may conform to the 2.0 published May 4 1998 by Intel Corporation Santa Clara Calif. Alternately a point to point interconnect may couple these components.

In turn chipset may be coupled to a first bus via an interface . In one embodiment first bus may be a Peripheral Component Interconnect PCI bus as defined by the 2.1 dated June 1995 or a bus such as the PCI Express bus or another third generation input output I O interconnect bus although the scope of the present invention is not so limited.

As shown in various I O devices may be coupled to first bus along with a bus bridge which couples first bus to a second bus . In one embodiment second bus may be a low pin count LPC bus. Various devices may be coupled to second bus including for example a keyboard mouse communication devices and a non volatile data storage unit . For at least one embodiment the non volatile data storage unit may include code including code for PAL and SAL. Further an audio I O may be coupled to second bus . Note that other architectures are possible. For example instead of the point to point architecture of a system may implement a multi drop bus see or another such architecture.

Embodiments of the mechanisms disclosed herein may be implemented in hardware software firmware or a combination of such implementation approaches. Embodiments of the invention may be implemented as computer programs executing on programmable systems comprising at least one processor a data storage system including volatile and non volatile memory and or storage elements at least one input device and at least one output device.

Program code may be applied to input data to perform the functions described herein and generate output information. Accordingly alternative embodiments of the invention also include machine accessible media containing instructions for performing the operations of the invention or containing design data such as HDL that defines structures circuits apparatuses processors and or system features described herein. Such embodiments may also be referred to as program products.

Such machine accessible media may include without limitation tangible arrangements of particles manufactured or formed by a machine or device including storage media such as hard disks any other type of disk including floppy disks optical disks compact disk read only memories CD ROMs compact disk rewritable s CD RWs and magneto optical disks semiconductor devices such as read only memories ROMs random access memories RAMs such as dynamic random access memories DRAMs static random access memories SRAMs erasable programmable read only memories EPROMs flash memories electrically erasable programmable read only memories EEPROMs magnetic or optical cards or any other type of media suitable for storing electronic instructions.

The output information may be applied to one or more output devices in known fashion. For purposes of this application a processing system includes any system that has a processor such as for example a digital signal processor DSP a microcontroller an application specific integrated circuit ASIC or a microprocessor.

The programs may be implemented in a high level procedural or object oriented programming language to communicate with a processing system. The programs may also be implemented in assembly or machine language if desired. In fact the mechanisms described herein are not limited in scope to any particular programming language. In any case the language may be a compiled or interpreted language

While particular embodiments of the present invention have been shown and described it will be obvious to those skilled in the art that changes and modifications can be made without departing from the scope of the appended claims. For example the embodiments discussed above of a mechanism for redirection of CMCI interrupts to a single TEC in an error domain where the TEC is in the running system of the OS and where the mechanism is transparent to the OS may be extended to systems that implement sub socket partitioning. For such systems more than one target TEC may be designated for a shared resource that spans partitions. An example of such an embodiment may include link or bus interface from the socket to the rest of the computer system. For such embodiment at block of PAL determines whether a TEC in the partition of the new TEC has already been set up as a target when the new TEC is being added to the OS running system. If not then at block the PAL may designate the newly added TEC as a target for the partition even if a target TEC is already designated as a target for the shared resource but in another partition. This results in multiple TEC s per error domain but only one TEC per partition for the error domain. Of course the hardware that implements CMCI routing need also support for such embodiment sending of the CMCI to multiple target TEC S that is one TEC for multiple partitions .

Also for example the concepts discussed above may be applied for other types of hardware events such as other types of interrupts in alternative embodiments.

Also for example the redirection functionality described herein as being handled by firmware may for at least one alternative embodiment be implemented in hardware instead.

Accordingly one of skill in the art will recognize that changes and modifications can be made without departing from the present invention in its broader aspects. The appended claims are to encompass within their scope all such changes and modifications that fall within the true scope of the present invention.

