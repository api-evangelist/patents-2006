---

title: Synchronized objects for software transactional memory
abstract: A system for implementing synchronized objects for software transactional memory may include one or more processors and a memory storing program instructions executable by the processor to implement a transactional-memory manager configured to coordinate memory access requests directed at the memory from a plurality of transactions. The transactional-memory manager records, within a collaborator record for a shared data object in the memory, identifications of a set of two or more transactions that have requested synchronization on the object. In response to a commit request from a given transaction of the set, the transactional-memory manager determines whether to commit or abort the given transaction based at least in part on the transactional states of other transactions in the set, examining the collaborator record to identify the other transactions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07720891&OS=07720891&RS=07720891
owner: Oracle America, Inc.
number: 07720891
owner_city: Redwood Shores
owner_country: US
publication_date: 20060214
---
The present invention is directed to computer systems. More particularly it is directed to synchronization mechanisms for computer systems implementing transactional memory.

In the field of computer systems considerable effort has been expended on developing techniques to support concurrent access to shared resources. Mutual exclusion locks and monitors represent two traditional concurrent programming synchronization mechanisms. Locks and monitors protect shared resources by separating access to them in time for example in one implementation as long as a given thread of execution retains a lock on an object or resource no other thread of execution may modify the object and any other thread attempting to modify the object may be blocked from further execution until the lock is released.

However locking techniques are known to suffer from several limitations. Coarse grained locks which protect relatively large amounts of data often do not scale. For example threads of execution on a multiprocessor system may block each other even when they do not actually require concurrent access to the same data. Fine grained locks may resolve some of these contention issues but only at the cost of added programming complexity and the increased likelihood of problems such as deadlocks. Locking schemes may also lead to an increased vulnerability to thread failures and delays e.g. a thread that is preempted or does expensive input output operations while holding a lock may obstruct other threads for relatively long periods thereby potentially reducing the overall throughput of the system.

The transactional memory programming paradigm has been gaining momentum as an approach of choice for replacing locks in concurrent programming. In transactional memory programming sequences of concurrent operations may be combined into nonblocking atomic transactions thus making parts of the code appear to be sequential without the need to use locks. Executing threads indicate transaction boundaries e.g. by specifying when a transaction starts and when it ends but do not have to acquire locks on any objects. Transactional memory programming techniques may allow transactions that do not overlap in data accesses to run uninterrupted in parallel transactions that do overlap may be aborted and retried.

The atomicity and isolation of transactions may significantly simplify concurrent programming. Atomicity is a property that guarantees that either all steps in a transaction succeed or the entire transaction is rolled back thus giving the impression that the transaction never occurred. Isolation refers to the ability of a transactional system to make operations in a transaction appear isolated from all other transactions or external operations. While attractive from the perspective of decreasing programming complexity strict isolation may have some negative implications for transactional memory systems e.g. it may prevent interactions between transactions. Such interactions may be useful for several purposes such as implementing condition synchronization and increasing concurrency. Synchronization techniques that allow such interactions may make it easier to implement increased parallelism within transactions thereby potentially enhancing system wide throughput in transactional memory systems and may provide a way for some transactions to share modified values of data prior to committing without compromising isolation for other transactions that do not need to share uncommitted data.

Various embodiments of methods and systems for implementing synchronized objects for software transactional memory are disclosed. According to one embodiment a system comprises one or more processors and a memory comprising program instructions executable by the processors to implement a transactional memory manager configured to coordinate memory access requests directed at the memory from a plurality of transactions. The transactions may each comprise a set of operations e.g. specifying memory locations at an address level and transaction boundaries may be defined programmatically within application code. The transactional memory manager may be configured to record within a collaborator record for a shared data object in the memory identifications of a set of two or more transactions that have each requested synchronization on the object e.g. so that each transaction of the set may see uncommitted updates performed on the shared object by other transactions of the set . In response to a commit request from a given transaction of the set the transactional memory manager may be configured to determine whether to commit or abort the given transaction based at least in part on the transactional states of other transactions in the set examining the collaborator record to identify the other transactions. If the transactional memory manager determines that the given transaction is to be committed based on the states of the other transactions it may commit the given transaction otherwise the given transaction may be aborted or may have to wait until either the other transactions are all ready to commit or at least one of the other transactions aborts. By requesting synchronization on the shared data objects the transactions of the set may indicate that isolation requirements which may typically prevent uncommitted updates from one transaction from being seen by other transactions be relaxed for the set of transactions and for the object or objects on which synchronization is requested by transactions in the set thereby potentially allowing increased concurrency and inter transaction update sharing without affecting the operations of other transactions that may not need to relax isolation requirements. Part or all of the functionality of the transactional memory manager may be implemented by a plurality of components in some embodiments e.g. by the threads that participate in the transactions.

In one embodiment the transactional memory manager may also be configured to record within a respective shared object record for each transaction of the set of transactions an identification of one or more additional shared data objects on which the corresponding transaction has also requested synchronization. In response to the commit request from the given transaction the transactional memory manager may be configured to examine the shared data object record of the given transaction to identify additional shared data objects on which the given transaction has requested synchronization. The determination of whether to commit or abort the given transaction may then also be based on the transactional state of an additional transaction identified from the collaborator record of the additional shared data object. Thus the set of transactions whose states may be examined in order to determine whether to commit or abort a given transaction may include the collaborator transactions for each of the shared data objects on which the given transaction has synchronized. A transaction T may be termed a cohort of another transaction T if T is either a collaborator of T or a collaborator of a cohort of T. In some embodiments the set of cohorts of the given transaction may be identified e.g. by recursively traversing linked shared data object records and collaborator records and the transactional states of each of the transactions in the cohort set may be examined to determine whether the given transaction is to be aborted or committed. Transactions in a cohort set may either all be committed or all be aborted e.g. if the transactional memory manager determines that one transaction requesting commit is to be committed all the cohorts of that transaction may also be committed and if the transactional memory manager determines that one transaction of a cohort set is to be aborted all transactions of the cohort set may be aborted.

In determining whether to commit or abort a given transaction requesting a commit the transactional memory manager may decide to commit if any one of the cohorts of the requesting transaction is already in a committed state or if each of the cohorts is in a committing state indicating that the cohort is ready to commit and has not been aborted. If any of the cohorts is in an aborted state the given transaction and its cohorts may all be aborted. If a cohort is in an active state indicating that the cohort has neither indicated that it is ready to commit nor been aborted the transactional memory manager may in some embodiments wait until the active transaction has changed state before making the commit abort decision. If the active cohort aborts the given transaction may be aborted if instead the cohort changes to a committing state the transactional memory manager may commit the given transaction eventually if all the other cohorts also reach the committing state. In some embodiments before a transaction commits the transaction logically seals any objects for which it has requested synchronization preventing any additional transactions not already identified in the collaborator records of those objects from making changes to the objects. In addition to being used for commits such a seal may for example serve as a delimiter between successive consistent versions of the data of the shared data object e.g. when a shared data object has been sealed no further requests for synchronization on the shared data object may be honored until the cohort set linked to the sealed shared data object either commits or aborts.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

In order to resolve some types of conflicts between transactions transactional memory manager may utilize services provided by a contention manager as described below in further detail. It is noted that the term transaction as used herein may in some embodiments refer to lower level operations than those typically managed by concurrency control algorithms within database management systems although even in such embodiments low level operations of threads of a database management system process may be coordinated using a transactional memory manager . In other embodiments the techniques described herein may also or instead be used to manage concurrent database transactions. In some embodiments transactional memory manager may be implemented entirely in application or user space while in other embodiments portions or all of transactional memory manager may be embedded within a virtual machine process e.g. a Java virtual machine JVM and or within an operating system which may be configured to implement virtual memory . In one embodiment transactional memory manager may be deployed as a shared library e.g. within one or more Java archive or jar files at a JVM . Transactional memory manager may rely on atomic operation support provided by an underlying operating system or virtual machine implementation in some embodiments e.g. to atomically change transaction state. Part or all of the functionality of the transactional memory manager may be implemented by a plurality of components in some embodiments e.g. by the threads that participate in the transactions.

The term transactional object as used herein may refer to an object that contains or encapsulates an ordinary object that may be declared or defined in a programming language e.g. any cloneable object defined in the Java programming language may be encapsulated in some embodiments . The encapsulation of the ordinary object within a transactional object may allow transactional memory manager to support concurrent programming without the use of locks as described below in further detail. A transactional object may be designated as either unsynchronized or synchronized e.g. using programming language declarations. In one implementation utilizing an object oriented language such as the Java programming language for example a transactional object that is unsynchronized may be declared as an instance of a TMObject class and a synchronized transactional object may be declared as an instance of a TMSynchronizer class that is a subclass of the TMObject class. The term unsynchronized object and unsynchronized transactional object may be used synonymously herein and the terms synchronized object and synchronized transactional object may also be used synonymously herein. Modifications made to the ordinary object encapsulated within an unsynchronized object by a transaction may not be visible to other transactions until the modifying transaction commits. Modifications made to the ordinary object encapsulated within a synchronized object by a transaction that has registered for synchronization on the synchronized object may be visible prior to the modifying transaction s commit only to other transactions that have also registered for synchronization on the same synchronized object . Thus some transactions may share updated data with other transactions prior to committing thereby relaxing the isolation requirement typical of transactional systems other transactions may restrict their updates to unsynchronized transactional objects and thus maintain strict isolation. It is noted that while the isolation requirement may be relaxed for transactions that access synchronized transactional objects the atomicity requirement may not be relaxed. All transactions are atomic a transaction is either committed i.e. its changes are made permanent or aborted its changes are discarded .

Transactional memory manager may be configured to provide a low level application programming interface API to support coordination of accesses to shared data without using locks in some embodiments. For example a beginTransaction interface may be provided to allow programmatic indication of the initiation of a transaction and a commitTransaction interface may be provided to allow programmatic indication of a request to commit a transaction i.e. to make permanent any data modifications performed between the invocations of the beginTransaction and commitTransaction interfaces . Transactional memory manager may in some embodiments provide different interfaces to allow access to unsynchronized and synchronized objects and respectively e.g. in one implementation an open interface may be used to request access to unsynchronized objects and a synchronize interface may be used to request synchronized access to synchronized objects . In some embodiments a single interface such as synchronize to access a synchronized object may serve two logically distinct purposes first the requesting transaction may be registered as a synchronizing transaction with respect to the object and second a pointer to the encapsulated data of the synchronized object may be returned to the requesting transaction . In some embodiments separate interfaces may be provided for registration and for obtaining access to the encapsulated data. In order to ensure that the relaxation of the isolation requirement does not lead to inconsistent data or incorrect operations all the transactions that synchronize concurrently on a given synchronized object are either committed or all are aborted. Further details on how the set of transactions that are to be committed or aborted together is enumerated and how it is determined whether to commit or abort the set are provided below. In some embodiments one or more of the transactions that synchronize on a synchronized object may not actually modify the encapsulated data of the synchronized object in some such cases for example a synchronized object may serve simply as a barrier synchronization mechanism without requiring any uncommitted updates to be shared across transactions. In one embodiment from among a set of transactions that have synchronized on a given object one or more transactions may modify the encapsulated object and one or more other transactions may read the uncommitted modifications to the object thus implementing for example a producer consumer buffer . It is noted that in embodiments where multiple transactions modify the encapsulated object the modifying transactions may implement a protocol e.g. a locking protocol to ensure that they do not make inconsistent modifications to the encapsulated object. In some such embodiments transactional memory manager may implement or participate in such a protocol and in other embodiments the protocol may be implemented independently of transactional memory manager .

A given transaction may access one or more unsynchronized objects one or more synchronized objects or a combination of synchronized and unsynchronized transactional objects in various embodiments. Transactions that register to synchronize on at least one synchronized object may be termed synchronizing transactions herein and transactions that do not attempt to register for any synchronized objects may be termed nonsynchronizing transactions. At any given time the set of transactions that are active in system may include any combination of nonsynchronizing and synchronizing transactions e.g. only nonsynchronizing transactions only synchronizing transactions or both nonsynchronizing transactions and synchronizing transactions . Transactional memory manager may be configured to manage interactions and conflicts among the nonsynchronizing and synchronizing transactions.

In one embodiment transactional memory manager may be configured to implement a synchronized object using a data structure termed a synchronized object locator SOL . shows an SOL for synchronized object A similar SOLs may be maintained for each of the other synchronized objects B K but are not shown in for clarity. In one embodiment synchronized object may comprise a reference or pointer to the corresponding SOL . An SOL may comprise a collaborator record such as collaborator list C List identifying the transactions that have registered to synchronize on the corresponding object . For example C List for object A in comprises transaction entries A L each transaction entry identifying a different transaction that has synchronized on object A. In response to a registration request from a transaction to synchronize on the object transactional memory manager may be configured to add a transaction entry to the C List . For each transaction a transaction state indicator may be maintained e.g. within a respective transaction entry and or in a transaction descriptor as shown in indicating for example whether the transaction is active not yet ready to commit aborted committed or ready to commit. In response to a request to commit received from one of the transactions on the C List the transactional memory manager may be configured to determine whether to commit or abort the requesting transaction based at least in part on the transactional states of other transactions on the C List . The transactional states of other transactions that may not necessarily all be identified in a single C List may also be taken into account in some embodiments in making the commit abort decision as described below in conjunction with the descriptions of and . For example in one embodiment if any one of the transactions identified in the C List is in an aborted state the requesting transaction and all other transactions in the C List may be aborted and if any one of the transactions identified in the C List is in a committed state the requesting transaction and all the other uncommitted transactions in the C List may be committed. C Lists may be implemented using a variety of techniques in different embodiments e.g. as linked lists arrays circular logs etc.

It is noted that locator objects similar in concept to SOLs may also be used to implement unsynchronized objects in some embodiments however since only a single transaction may be allowed to modify an unsynchronized object at a time the locator objects of unsynchronized objects may only need to identify a single opener transaction that most recently opened the unsynchronized object for access. In some embodiments e.g. to simplify implementation SOLs may also be used for unsynchronized objects in such an embodiment a C List for an unsynchronized object may not need to include more than one transaction entry .

In addition to the C List an SOL may also comprise an object state indicator which may also be termed a seal indicator herein that may be used for example to ensure that additional transactions do not succeed in registering for object and thereby potentially changing the encapsulated data of object after one of the transactions issues a commit request. A seal may be placed on a synchronized object e.g. by setting object state indicator to a particular value to act as a delimiter between different consistent versions of the encapsulated data a transaction that has synchronized on an object may be required to seal the object or to ensure that the object has been sealed by another collaborating transaction before it commits. After an object has been sealed the modifications made by the transactions in the C List of that object may not be visible to any other transaction until the transactions on the C List all commit. In some implementations the object state indicator may be implemented as a special entry in a C List . For example in one implementation the C List may be implemented as an ordered list of records and to seal a synchronized object a seal record may be placed at the head of the C List when a transaction from among the transactions identified in the C List issues a commit request and the synchronized object is not already sealed.

In some embodiments two or more versions of the encapsulated data of the synchronized object may be maintained such as an old version and a new version as shown in and SOL may include respective pointers and to the old and new versions respectively. The old version may at a given point in time comprise a committed version of the data and the new version may include uncommitted modifications made by one or more registered transactions . When a transaction sends a registration request for a synchronized object to transactional memory manager e.g. by invoking a synchronize interface and the synchronized object is currently sealed the requesting transaction may have to wait until the current set of collaborating transactions on object i.e. the transactions identified in the C List of the object either commit or abort and the object is thereby unsealed . After the unsealing a new SOL object may be allocated and passed to the requesting transaction with the C List of the new SOL object comprising only the requesting transaction. If the object was unsealed as a result of a commit the new version of the previous SOL s data may be cloned and the data pointers and of the new SOL may be appropriately adjusted so that the newly registered transaction sees the committed changes. If the object was unsealed as a result of an abort the old version of the previous SOL s data may be cloned and the data pointers of the new SOL may be appropriately adjusted so that the newly registered transaction does not see the uncommitted changes of the now aborted transactions. Further details of the techniques used to respond to synchronization request after a synchronized object is sealed and the manner in which data pointers and may be manipulated in various embodiments are provided below in conjunction with the descriptions of and . When a transaction successfully registers for a synchronized object e.g. when the transaction is placed on the C List of the object pointer i.e. a pointer to the new version of the data may be returned to the transaction and the registered transaction may then read and or modify the new version of the data . However as in other software transactional memory schemes no external references to the new data may be created all references to the encapsulated data are handled through the SOL and its pointers since the new version is to be accessible only to transactions that have registered for synchronized object until these transactions commit. It is noted that the organization of an SOL may differ from that shown in in some embodiments e.g. one or more other fields comprising data access timestamps and or statistical data may be included or in embodiments where each transaction has an associated priority a field indicating the highest priority transaction among the transactions in the C List may be included in the SOL .

The transactions identified in a given C List may be referred to herein as collaborators or collaborating transactions with respect to the corresponding synchronized object . In some embodiments a transaction may register to synchronize on more than one synchronized object each of which may have its own C List . As noted above collaborators of a given synchronized object are not isolated from one another since they can see each other s uncommitted changes to the encapsulated data. If a transaction A aborts then A s collaborators must also be aborted to prevent the observation of partial effects of the aborted transaction by noncollaborating transactions. This implies that collaborators of A s collaborators should also be aborted. For any given transaction the term cohort may be used herein to refer to another transaction that is either a collaborator of the transaction or a collaborator of a cohort of transaction . In terms of formal mathematics the cohort relationship may be an equivalence relation i.e. it may be reflexive symmetric and transitive. is a block diagram illustrating collaborator and cohort relationships among a set of transactions according to one embodiment. Transactions A and B may be collaborators with respect to synchronized object A e.g. both A and B may be identified in a C List of the SOL of object A. Similarly transactions B C and D may be collaborators with respect to synchronized object B and transactions D and E may be collaborators with respect to synchronized object C. All the transactions shown in are cohorts of each other. If for example transaction A aborts then because uncommitted changes to the data encapsulated by object A may have been seen by transaction B transaction B must be aborted. If transaction B is aborted transactions C and D must be aborted because the latter two transactions may have seen uncommitted changes from transaction B similarly if transaction D is aborted transaction E must also be aborted. In addition none of the cohorts A E in should be committed if there is a chance that any of the other cohorts may still abort. For example if transaction A commits and then transaction C is allowed to abort transaction B must both abort to ensure that the uncommitted changes of C are not seen externally and commit because changes made by B to data encapsulated by object A may have been made permanent by the commit of transaction A which is a logical impossibility. Therefore either all the cohorts A E must commit or all must abort. The transactions that are cohorts of each other at a given point in time may be termed a cohort set herein and the synchronized objects with respect to which the transactions are cohorts may be termed a synchronized object set herein. In the embodiments depicted in and once a transaction synchronizes on an object it joins a cohort set linked by relationships similar to those shown in and it remains part of that cohort set until it either commits or aborts. Cohort sets may expand over time e.g. as more transactions register to synchronize on one of the objects of the synchronized object set. It is noted that in some embodiments where features such as the unsynchronize method described below are implemented cohort sets may also shrink over time in other embodiments cohort sets may not shrink until the cohorts terminate by committing or aborting.

Transactional memory manager may be configured to identify the set of cohorts of any given synchronizing transaction that requests a commit in some embodiments. As described below in further detail in many cases transactional memory manager may not need to identify the complete cohort set before making a commit abort decision e.g. as soon as a cohort in an aborted state is found the enumeration of additional cohorts may no longer be needed however in principle at least the entire cohort set of a transaction may have to enumerated. is a block diagram illustrating a shared object list that may be maintained for each synchronizing transaction according to one embodiment for example to be used by transactional memory manager in identifying the transaction s cohort set. A transaction may be represented by a transaction descriptor which may in turn comprise a transaction state indicator and a shared object list . The shared object list may comprise a collection of shared object entries where each shared object entry identifies or points to an SOL for a synchronized object for which the transaction represented by transaction descriptor has registered. In some implementations the shared object list may comprise the SOLs without using intermediary shared object entries . In turn the C Lists of each SOL identified in the shared object list may identify the collaborators for the corresponding synchronized object . For example transaction entry Q of C List A in points to transaction descriptor indicating that the transaction represented by transaction descriptor is a collaborator with respect to SOL A. To avoid clutter C Lists of other SOLs are not shown in . In some implementations C Lists may comprise transaction descriptors instead of using intermediary transaction entries . The combination of shared object lists and C Lists may support a mechanism to identify the cohort set of a given transaction or all the cohorts associated with any given synchronized object . For example in order to determine the current cohort set of a given transaction transactional memory manager may be configured to traverse the shared object list for that transaction and for each SOL identified in the shared object list include all the transactions in that SOL s C List in the cohort set and recursively traverse the shared object lists of all those transactions. In order to determine the cohorts associated with a given synchronized object the transactional memory manager may start from the SOL for the object traverse its C List to identify the collaborators on that object add the collaborators to the cohort set and then for each collaborator recursively traverse its shared object list . It is noted that in practice especially in embodiments where transactions are relatively short lived and or where the number of objects on which each transaction synchronizes is on average relatively small C Lists and shared object lists may typically be relatively short so the recursive traversals of these lists may be fairly inexpensive.

Transactional state information may be maintained for each transaction e.g. in state indicator within the corresponding transaction descriptor . is a state transition diagram illustrating the possible states of a synchronizing transaction i.e. a transaction that synchronizes on at least one synchronized object according to one embodiment. When a transaction starts it enters the ACTIVE state . In some embodiments for example an invocation of a beginTransaction interface by a thread of execution may result in an atomic allocation of a transaction descriptor with an empty shared object list and a state indicator set to indicate the ACTIVE state. While in the ACTIVE state the transaction may perform various computations and memory accesses and may for example register for synchronized access to one or more synchronized objects e.g. by invoking a synchronize interface. When a transaction in the ACTIVE state has completed its data accesses and computations it may atomically change state to the COMMITTING state indicating that it is ready to commit any modifications it has made. In some embodiments transactional memory manager may provide a specific API for the transition between ACTIVE and COMMITTING states e.g. a readyToCommit interface while in other embodiments an invocation of a commitTransaction interface may result in the transaction being placed in the COMMITTING state and in an initiation of other operations needed to actually commit the transaction. The transactional memory manager may determine whether the transaction is to be committed or has to be aborted e.g. based at least in part on the states of one or more cohorts of the COMMITTING transaction. If the transactional memory manager determines that the transaction is to be committed it may commit the transaction and the transaction s state may be changed to the COMMITTED state . If the transactional memory manager determines that the transaction is to be aborted it may abort the transaction and the transaction s state may change from the COMMITTING state to the ABORTED state . In addition a transaction in the ACTIVE state may also be aborted e.g. when a cohort attempts to seal a synchronized object as described below or when transactional memory manager detects a conflict between the ACTIVE transaction and another transaction that is not a cohort of the ACTIVE transaction .

It is noted that in some embodiments a simpler set of state transitions may be implemented for nonsynchronizing transactions i.e. transactions that do not synchronize on any synchronized objects . The COMMITTING state may not be required for such transactions in some embodiments since nonsynchronizing transactions may not need to wait for any other transactions before being committed aborted. Thus nonsynchronizing transactions may change state atomically from the ACTIVE state to the COMMITTED state or from the ACTIVE state to the ABORTED state in such embodiments.

Similarly synchronized object S may be created to encapsulate and provide synchronized access to another object. In some embodiments the encapsulated object e.g. ti in the above code example may be required to be cloneable i.e. the underlying programming language may be required to provide support for duplication or cloning of the encapsulated object . In some implementations the ability to atomically duplicate the object may be needed to manage the new version and old version of the encapsulated object s data during commits and aborts. After synchronized objects S and S have been created transaction T may be started block e.g. by a thread invoking a beginTransaction API. T may enter the ACTIVE state in block . T may subsequently register to synchronize on S block and S block . Meanwhile transaction T may start block and register for synchronization on S block thus becoming a collaborator of T with respect to S. Similarly transaction T may start block and may register as a collaborator of T with respect to S block . Thus T T and T may form a cohort set with respect to S and S. Each of the transactions T T and T may begin independently of the others and may register for synchronization at desired synchronized objects independently of the others.

Each transaction may then perform data accesses on the synchronized objects and on any other objects accessed within the scope of the respective transactions . When T s data accesses block complete T may be ready to commit block and may for example atomically change state from ACTIVE to COMMITTING e.g. by invoking a commitTransaction API. Meanwhile T may still be performing its data accesses and computations block and may still have access to as yet uncommitted changes to S made by T. Also T may still be performing its data accesses and computations block and may be able to read uncommitted changes to S performed by T. T may have to wait for its cohorts T and T to complete their operations and enter the COMMITTING state block before T commits. When T changes to the COMMITTING state block T may seal S block e.g. by modifying object state indicator for S indicating that no other transactions are to be allowed to synchronize on S until T and T commit or abort. The dotted arrow from block to block indicates the dependency of T on T s reaching the COMMITTING state before T may seal S. Similarly when T changes to the COMMITTING state block T may seal S block . Having sealed all the synchronized objects for which it is registered i.e. S and S T may change from the COMMITTING state to the COMMITTED state indicating a successful commit operation . In some embodiments e.g. a value indicating success may be returned to T from the commitTransaction call to indicate the change to the COMMITTED state. T and T may also be committed i.e. they may change state to the COMMITTED state blocks and respectively . It is noted that while in the depicted time sequence shown in the cohorts are committed all the cohorts may instead have aborted if any one of them aborted after all three had registered. It is also noted that while T seals S and S in the specific example illustrated in it is also possible for either T or T to seal either S or S after reaching the COMMITTING state. In one embodiment transactional memory manager may guarantee that an attempt to seal an object fails only if either a another cohort has already successfully sealed the object or b a new transaction has registered for the object since the attempt to seal the object was made.

It is noted that in some embodiments the sealing of a synchronized object by T may be performed at a different time relative to the waiting operations of block . For example in the depicted embodiment if a transaction T attempts to register for S or S after T enters the COMMITTING state in block and before T or T enter the COMMITTING state T may be allowed to successfully register and may be included in the C List for S or S . T may then have to wait for T to also enter the COMMITTING state before S or S is sealed thus potentially lengthening the time window in which other transactions T T etc. may also join the cohort set. In another embodiment T may instead seal S and S as soon as T enters the COMMITTING state while T and T are still in the ACTIVE state e.g. operations of block and may be performed prior to the wait of block . By sealing objects S and S early T may reduce the time that it may have to wait for cohorts however new transactions that request registration for S or S may have to wait longer to register since they may have to wait until the objects are unsealed . In some embodiments the sealing operation may be independent of and performed prior to any transaction s being ready to commit. For example an API specifically for sealing e.g. setSeal may be supported in some embodiments allowing a transaction to freeze the cohort set at any time after the transaction registers e.g. by preventing any additional transactions from registering until the initiator of the freeze commits or aborts.

In one example use case transactions such as T T and T of may represent concurrent threads of a travel reservation application. A user of the travel reservation application may for example wish to make an airline reservation a car reservation and a hotel reservation. If all three reservations were made within a single transaction in a typical transactional memory implementation the three reservations would be made in sequence even though there may be no requirement for sequentiality. Instead in an environment where transactional memory manager supports synchronization on shared data objects as described above each of the three reservations may be performed by a different transaction. For example T may be responsible for the airline reservation T may be responsible for making the car reservation and T may be responsible for making the hotel reservation. If any of the three reservations fail e.g. if either T T or T fails or aborts the entire reservation set fails T T and T all abort if all three reservations succeed T T and T commit the user s combined request succeeds. In some cases none of the reservation transactions may actually modify any data of Si or S they may all simply register for synchronization on S or S and wait for all to commit abort together implementing a simple barrier synchronization mechanism. It is noted that even barrier synchronization mechanisms may need to modify some data to record which or how many transactions have arrived at the barrier and S and or S may be used for such records in embodiments where such records are not provided direct support by the transactional system. In other cases updated information may be passed from one cohort to another via S or S e.g. if a range of acceptable dates or flight times were specified by the requesting user an airline reservation transaction T may indicate via an updated field of S the specific flight time selected and this information may be used by a car reservation transaction T and or a hotel reservation transaction T.

If on the other hand the object was already in a sealed state when the registration request is received as detected in block the transactional memory manager may be configured to unseal the object block e.g. either by waiting until the cohorts associated with the object commit abort or by actively aborting the cohorts. Unsealing operations corresponding to block of are described in further detail below in conjunction with the description of . Whether the unsealing comprises only waiting a combination of waiting followed by an eventual abort an immediate active abort or some other action may be determined based on a variety of factors in different embodiments. For example in some embodiments a configurable parameter indicating a maximum unseal waiting time may be provided to transactional memory manager and after waiting for the specified maximum time the transactional memory manager may abort a cohort to unseal the object . In other embodiments each transaction may have an associated priority and transactional memory manager may be configured to abort a cohort if the requesting transaction has a higher priority than some or all of the cohorts. In one embodiment transactional memory manager may be configured to maintain statistics on the number of aborts and commits and make the decision on whether to wait or abort based on a heuristic derived from the statistics. Other techniques to determine how to respond to a registration request after the targeted synchronized object is sealed may also be used in various embodiments.

The object for which the registration request was received may eventually be unsealed either as a result of a commit by one or more cohorts or as a result of an abort by one or more cohorts. In some embodiments the object may remain sealed until all the cohorts states change to the COMMITTED state or the ABORTED state while in other embodiments the object may be unsealed as soon as any one of the cohorts state changes to the COMMITTED state or the ABORTED state. In one specific embodiment the object may be unsealed as soon as it becomes evident that the cohorts are going to be committed aborted e.g. a cohort may be deemed to be logically committed or effectively committed if all its cohorts are in the COMMITTING state and all the synchronized objects of the cohort set are sealed and the object may be unsealed as soon as a cohort is found to be effectively committed. When the commit abort occurs the object state indicator of the SOL for the object may be updated to reflect the unsealed state.

A new SOL may be created for the requesting transaction after the object is unsealed block e.g. with a C List that identifies only the requesting transaction. The new and old data pointers and shown in of the newly constructed SOL may be set to point to the appropriate versions of the data of the encapsulated object block . The pointer operations may differ based on whether the unsealing occurred as a result of a commit or an abort as illustrated in and .

Returning now to after the pointer manipulations of block are completed in some embodiments the old SOL may be atomically replaced by the new SOL block . A pointer to the new version of the data and a success indicator may be returned to the requesting transaction that issued the registration request indicating that the registration request has succeeded. It is noted that in the embodiment depicted in the registration request always eventually succeeds either after the synchronized object for which registration is requested is unsealed or if the object is unsealed at the time the registration request is received without requiring unsealing. In other embodiments transactional memory manager may be configured to reject a registration request in some circumstances e.g. if the targeted synchronized object is sealed or if only a limited number of transactions are to be permitted to register successfully for a given synchronized object . For example in a travel reservation application in which a user specifies a plurality of acceptable dates and or times for a flight several transactions may be initiated to search for the different alternative acceptable flights and the number of concurrent transactions may be limited e.g. to N by rejecting registration requests after the first N transactions have been registered on the same synchronized object. In one embodiment registration and data access may be implemented using different interfaces e.g. a transaction may register for synchronization using a first interface such as registerForSynchronizer and may obtain a handle or pointer to the data e.g. to the synchronized object locator for the object using a second interface such as open . In such embodiments the open interface may be used by both synchronizing and nonsynchronizing transactions to access transactional data e.g. nonsynchronizing transactions may invoke open to access data encapsulated within unsynchronized transactional objects and synchronizing transactions may after separately registering for synchronization invoke open to access data encapsulated within synchronized transactional objects .

As noted in the description of block of transactional memory manager may be configured to unseal a sealed synchronized object in response to a registration request in some embodiments. is a flow diagram illustrating aspects of the operation of transactional memory manager during an unseal operation on a sealed synchronized object according to one embodiment. During the unsealing transactional memory manager may be configured to identify the set of cohorts linked to the sealed synchronized object block of e.g. via a traversal of the C List of the object and the shared object lists of each collaborator on the C List and to examine the transactional states of the cohorts. Depending on the transactional states of the cohorts the process of enumeration and or examination of the cohort set may be cut short in some embodiments while in other cases the entire cohort set may have to be enumerated and the transactional states of the entire cohort set may have to be examined before the object is unsealed. In the embodiment depicted in the cohorts are examined one at a time however in various implementations the cohort set may also be examined and or enumerated by a plurality of parallel threads of the transactional memory manager.

When examining a next cohort block in the cohort set if the cohort is in the COMMITTED state as determined in block transactional memory manager may deduce that all the cohorts are either already committed or are going to be committed since no one cohort could be in the COMMITTED state if there is a possibility of any of the other cohorts not committing . Accordingly transactional memory manager may be configured to unseal the object cloning the new version of the encapsulated data to complete registration block as also illustrated in and in the portion of block of describing the unseal after commit operations. In the depicted embodiment no further examination of other cohorts may be required to complete the registration if a cohort in the COMMITTED state is found. In some embodiments transactional memory manager may be configured to commit any remaining uncommitted cohorts of the cohort set when one cohort in the COMMITTED state is found during an unseal operation.

If a cohort in the ABORTED state is found block once again no further examination of other cohorts may be required the transactional memory manager may deduce that all other cohorts are either already in or eventually going to be in the ABORTED state. Accordingly transactional memory manager may unseal the object and clone the old version of the complete registration block as illustrated in and in the unseal after abort portion of block of . In some embodiments transactional memory manager may be configured to abort any remaining cohorts of the cohort set when one cohort in the ABORTED state is found during an unseal operation.

If the cohort being examined is found in the ACTIVE state block this means that the requesting transaction is contending with a currently active transaction on a synchronized object that has been sealed. The sealed state of the object may indicate that no additional transactions apart from those transactions in the current cohort set associated with the object are to be allowed to view the changes made to the object at least until it is determined whether the cohort set is to commit or abort. Accordingly when an ACTIVE cohort is encountered transactional memory manager may be configured to determine based on a conflict resolution algorithm in use whether to wait for the ACTIVE cohort to voluntarily change state or whether to instead abort the ACTIVE cohort. In the embodiment depicted in the transactional memory manager may be configured to send an indication of the conflict between the ACTIVE cohort and the transaction requesting registration to a contention manager to arbitrate between the conflicting transactions and determine what action if any is to be taken to resolve the conflict block of .

Contention manager may be a modular or pluggable component in some embodiments e.g. allowing any of various contention management schemes to be employed without being tightly coupled to other functionality of transactional memory manager . In some implementations for example each thread of execution in system and therefore each transaction may have a priority associated with it and contention manager may be configured to decide that if the ACTIVE cohort is of a lower priority than the transaction requesting registration the ACTIVE cohort should be aborted. In some priority based schemes the requesting transaction may wait for a higher priority ACTIVE transaction to change state while in other priority based schemes the requesting transaction may itself be aborted if it contends with a higher priority ACTIVE transaction on a sealed object . In another implementation a threshold maximum wait time may be provided as a configurable parameter to the contention manager and the contention manager may determine that the requesting transaction is to wait for the ACTIVE transaction to change state until the requesting transaction has waited for at most the threshold maximum wait time after which the ACTIVE transaction may be aborted. If the contention manager determines to abort the ACTIVE transaction block the entire cohort set must also be aborted and the operations of block of may be performed to unseal the object . If the contention manager instead determines that the requesting transaction should wait for the ACTIVE transaction to change state in the depicted embodiment the transactional memory manager may be configured to examine the next cohort if there are any remaining cohorts block and may for example place the ACTIVE transaction in a list of transactions to be re examined later. In other embodiments instead of proceeding to examine the next cohort transactional memory manager may be configured to wait until the ACTIVE transaction does change state.

If the cohort being examined is not in the COMMITTED ABORTED or ACTIVE states it must be in the COMMITTING state in the embodiment depicted in . On encountering a cohort in the COMMITTING state in the depicted embodiment if there are any unexamined cohorts left as detected in block transactional memory manager may be configured to continue with the examination of the states of the remaining unexamined cohorts e.g. to repeat the operations starting at block . The COMMITTING cohort may in some implementations be placed in a set of cohorts to be re examined later. In other embodiments if a COMMITTING transaction is encountered during unsealing instead of proceeding to the next cohort the transactional memory manager may wait until the COMMITTING transaction either commits or aborts.

If after all the cohorts have been examined no cohort in the COMMITTED or ABORTED states has been found and no decision to abort any ACTIVE cohort has been made this means that all remaining cohorts are in the COMMITTING state or are in the ACTIVE state and are being waited for corresponding to the No transition out of decision block . Transactional memory manager may then be configured to wait for any remaining ACTIVE cohorts to change state block . An ACTIVE cohort may change state to the COMMITTING state or the ABORTED state. If it changes to the ABORTED state the cohort set must be aborted the object may be unsealed and the operations corresponding to block may be performed to complete registration block . If all remaining cohorts change state to the COMMITTING state and none changes to the ABORTED state and if all the synchronized objects on which the COMMITTING cohorts are synchronized are also sealed then the cohort set may be deemed to be effectively committed or logically committed herein because the only remaining possibility for a final state of each cohort is the COMMITTED state. If the remaining cohorts are determined to be effectively committed the commit after unseal operations corresponding to block may be performed. In some embodiments if all remaining cohorts are in the COMMITTING state and at least some of the synchronized objects on which the cohort set is synchronized are unsealed when block is reached transactional memory manager may be configured to wait until all the synchronized objects are sealed or until one or more cohorts of the cohort set abort .

Any of a number of variations of the unsealing technique described above may be employed in various embodiments. In one embodiment the entire cohort set may be enumerated first and the cohorts then examined one by one in another embodiment each cohort s state may be examined before the next cohort of the set is identified. In some embodiments if a cohort being examined is ACTIVE transactional memory manager may simply wait until the cohort changes state to either COMMITTED or ABORTED. In one embodiment multiple threads of the transactional memory manager may enumerate and or examine the states of the cohorts in parallel.

As shown in block of the commit processing may begin by the requesting transaction attempting to atomically change its state from ACTIVE to COMMITTING. The attempt may fail if the transaction is aborted. If the attempt succeeds the requesting transaction s state may be changed to COMMITTING and the transactional memory manager may be configured to attempt to seal each synchronized object on the shared object lists of the requesting transaction and its cohorts as described below. After all the synchronized objects on the shared object lists of the cohorts are sealed the requesting transaction may be committed e.g. the state of the requesting transaction may be set to COMMITTED and the objects may be unsealed making modifications made by the requesting transactions visible to other transactions . In the depicted embodiment the transactional memory manager may traverse the shared object lists sequentially sealing each object in sequence if its not already sealed in other embodiments multiple parallel threads may be used to examine and seal a plurality of synchronized objects concurrently.

Transactional memory manager may be configured to select the next cohort of the requesting transaction whose shared object list is to be examined block e.g. starting with the requesting transaction itself. The next synchronized object on the shared object list of the selected cohort may then be examined block . If the object is not sealed as detected in block transactional memory manager may traverse the C List of the object block to examine the states of the collaborator transactions identified in the C List and eventually seal the object if the collaborators are in acceptable states. If the object is already sealed as detected in block e.g. as a result of a commit request issued by another cohort and if unexamined synchronized objects remain on the shared object list as detected in block the next object on the shared object list may be examined.

If any of the collaborators of an as yet unsealed object on the shared object list of the requesting transaction is in the ABORTED state as determined in decision block the requesting transaction and its cohorts may be aborted block . If all the collaborators are in the COMMITTING state as detected in block the synchronized object may be sealed block and if there are more synchronized objects on the shared object list as determined in decision block the next synchronized object may be examined in turn repeating the operations of block onwards . If additional cohorts remain after the entire shared object list of the cohort has been examined as detected in decision block the shared object list of the next cohort may be examined.

If at least one of the collaborators is neither ABORTED nor COMMITTING it is typically in the ACTIVE state. It is noted that under certain race conditions it is possible for transactional memory manager to encounter a collaborator in the COMMITTED state after step because the collaborator may have committed after the seal was checked. In such a case the requesting transaction may also be committed along with the rest of the cohort set. The transactional memory manager may be configured to wait for any ACTIVE collaborators to change state to either COMMITTING or ABORTED block . If any of the waited for collaborators aborts as detected in decision block the requesting transaction and its cohorts may be aborted block otherwise all collaborators are in the COMMITTING state so the object may be sealed block and any remaining synchronized objects on the shared object list may be examined in turn.

After all the synchronized objects on the shared object list have been sealed the transaction may be committed block unless any of the cohorts has aborted. All the transaction s cohorts may also be committed at this point in some embodiments. The transaction s state may be changed to COMMITTED and the objects that it has synchronized on may be unsealed thus making visible to other transactions any modifications made by the cohorts. As noted earlier in some implementations the sealed state indicator may be implemented as a special entry in the C List of the synchronized object . In one such implementation where the C List is implemented as an ordered linked list in order to seal the synchronized object the special entry may be atomically inserted at the head of the C List to seal the object.

In some embodiments a nonsynchronizing transaction may contend with uncommitted synchronizing transactions for access to the same unsynchronized object . For example in addition to accessing one or more synchronized objects A using the techniques described above a synchronizing transaction A may access an unsynchronized transactional object A e.g. by invoking an open API on the object and a nonsynchronizing transaction designated herein as transaction N may also attempt to access the same unsynchronized transactional object A before the synchronizing transaction commits aborts. If the synchronizing transaction A is in the ACTIVE state when the nonsynchronizing transaction s access request is received transactional memory manager may treat the synchronizing transaction A as an unsynchronized transaction and the conflict may be resolved between transactions A and N alone i.e. without taking A s cohorts into account e.g. using a contention manager to arbitrate between the transactions. However if synchronizing transaction A is in the COMMITTING state when the conflict occurs its cohorts may have to be taken into account.

If the conflicting synchronizing transaction A is in the COMMITTING state however transactional memory manager may be configured to examine A s cohort set to designate A as either effectively committed effectively active or effectively aborted block . A synchronizing transaction may be deemed to be effectively committed if all its cohorts are in the COMMITTING or COMMITTED state and all the synchronized objects linked to the cohorts are sealed in this case the only possible end state for the transaction is the COMMITTED state. If after examining A s cohorts transactional memory manager determines that A is effectively committed as detected in block transactional memory manager may commit A block to resolve the conflict with N thereby making visible to N any changes to the unsynchronized transactional object O that were made by A.

If any of the conflicting synchronizing transaction A s cohorts are found in the ABORTED state A may be deemed effectively aborted as detected in block and may be actually aborted by transactional memory manager to resolve the conflict with N as indicated at block in this case A s changes to O may be discarded and not made visible to N. If A is neither effectively committed or effectively aborted it must be effectively active and the contention manager may be used to resolve the conflict block just as the contention manager would have been used if A had been in the ACTIVE state.

In various embodiments the basic mechanism for synchronizing on shared data objects described above may be extended to provide enhanced functionality using any of a number of techniques. As noted above in one embodiment a synchronize call to register a transaction may be extended to return an indication that the registration request failed e.g. to limit the number of cohorts based on application specific logic or to impose a system wide limit on the number of cohorts that can be included in a cohort set. In some embodiments transactions may be allowed to unregister e.g. by invoking an unsynchronize method if they have not actually modified data encapsulated by the object or objects for which they had earlier registered. In other embodiments transactional memory manager may be configured to abort a set of collaborating transactions and discard changes made by the aborted set of transactions as long as no other transactions have observed the uncommitted modifications of that set. Such a capability may be useful for example in implementing various types of producer consumer relationships including exchanger channels. In some embodiments an observe method or interface may be supported allowing a requesting transaction to read the encapsulated data of a synchronized object before generating a registration request thus the decision on whether or not to register and join a cohort set may be made based on the contents of the encapsulated data in such embodiments. In some embodiments an observe method may allow a particular transaction to identify one or more existing cohorts and to make the decision on whether to join the cohort set based at least in part on the current membership of the cohort set.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

