---

title: System and method for restoring data on demand for instant volume restoration
abstract: A technique is disclosed for restoring data of sparse volumes, where one or more block pointers within the file system structure are marked as ABSENT, and fetching the appropriate data from an alternate location on demand. Client data access requests to the local storage system initiate a restoration of the data from a backing store as required. A demand generator can also be used to restore the data as a background process by walking through the sparse volume and restoring the data of absent blocks. A pump module is also disclosed to regulate the access of the demand generator. Once all the data has been restored, the volume contains all data locally, and is no longer a sparse volume.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07809693&OS=07809693&RS=07809693
owner: NetApp, Inc.
number: 07809693
owner_city: Sunnyvale
owner_country: US
publication_date: 20060424
---
The present application claims the benefit of U.S. Provisional Patent Application Ser. No. 60 674 430 which was filed on Apr. 25 2005 by Jason Ansel Lango for a SYSTEM AND METHOD FOR RESTORING DATA ON DEMAND FOR INSTANT VOLUME RESTORATION and is hereby incorporated by reference.

This application is a continuation in part application of U.S. patent application Ser. No. 10 361 303 entitled SYSTEM AND METHOD FOR LAZY COPY SUB VOLUME LOAD BALANCING IN A NETWORK ATTACHED STORAGE POOL by Robert M. English filed Feb. 10 2003 now issued as U.S. Pat. No. 7 197 490 on Mar. 27 2007 the contents of which are herby incorporated by reference.

This application is also related to U.S. patent application Ser. No. 11 409 624 entitled SYSTEM AND METHOD FOR SPARSE VOLUMES by Jason Lango et al. and U.S. patent application Ser. No. 11 409 624 entitled ARCHITECTURE FOR SUPPORT OF SPARSE VOLUMES by Jason Lango et al. the contents of which are hereby incorporated by reference.

The present invention relates to file systems and more specifically to a file system that includes volumes having one or more files with absent blocks that can be restored on demand.

A storage system typically comprises one or more storage devices into which information may be entered and from which information may be obtained as desired. The storage system includes a storage operating system that functionally organizes the system by inter alia invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including but not limited to a network attached storage environment a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array wherein the term disk commonly describes a self contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive HDD or direct access storage device DASD .

Storage of information on the disk array is preferably implemented as one or more storage volumes of physical disks defining an overall logical arrangement of disk space. The disks within a volume are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of redundant information parity with respect to the striped data. The physical disks of each RAID group may include disks configure to store striped data i.e. data disks and disks configure to store parity for the data i.e. parity disks . The parity may thereafter be retrieved to enable recovery of data lost when a disk fails. The term RAID and its various implementations are well known and disclosed in by D. A. Patterson G. A. Gibson and R. H. Katz Proceedings of the International Conference on Management of Data SIGMOD June 1988.

The storage operating system of the storage system may implement a high level module such as a file system to logically organize the information stored on the disks as a hierarchical structure of directories files and blocks. For example each on disk file may be implemented as set of data structures i.e. disk blocks configured to store information such as the actual data for the file. The data blocks may be utilized to store both user data and also metadata within the file system. These data blocks are organized within a volume block number vbn space. The file system which controls the use and contents of blocks within the vbn space organizes the data blocks within the vbn space as a logical volume each logical volume may be although is not necessarily associated with its own file system. The file system typically consists of a contiguous range of vbns from zero to n 1 for a file system of size n blocks.

A known type of file system is a write anywhere file system that does not overwrite data on disks. If a data block is retrieved read from disk into a memory of the storage system and dirtied i.e. updated or modified with new data the data block is thereafter stored written to a new location on disk to optimize write performance. A write anywhere file system may also opt to maintain a near optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations particularly for sequential read operations directed to the disks. An example of a write anywhere file system that is configure to operate on a storage system is the Write Anywhere File Layout WAFL file system available from Network Appliance Inc. Sunnyvale Calif.

The storage operating system may further implement a storage module such as a RAID system that manages the storage and retrieval of the information to and from the disks in accordance with input output I O operations. The RAID system is also responsible for parity operations in the storage system. Note that the file system only sees the data disks within its vbn space the parity disks are hidden from the file system and thus are only visible to the RAID system. The RAID system typically organizes the RAID groups into one large physical disk i.e. a physical volume such that the disk blocks are concatenated across all disks of all RAID groups. The logical volume maintained by the file system is then disposed over spread over the physical volume maintained by the RAID system.

The storage system may be configured to operate according to a client server model of information delivery to thereby allow many clients to access the directories files and blocks stored on the system. In this model the client may comprise an application such as a database application executing on a computer that connects to the storage system over a computer network such as a point to point link shared local area network wide area network or virtual private network implemented over a public network such as the Internet. Each client may request the services of the file system by issuing file system protocol messages in the form of packets to the storage system over the network. By supporting a plurality of file system protocols such as the conventional Common Internet File System CIFS and the Network File System NFS protocols the utility of the storage system is enhanced.

When accessing a block of a file in response to servicing a client request the file system specifies a vbn that is translated at the file system RAID system boundary into a disk block number dbn location on a particular disk disk dbn within a RAID group of the physical volume. It should be noted that a client request is typically directed to a specific file offset which is then converted by the file system into a file block number fbn which represents a block offset into a particular file. For example if a file system is using 4 KB blocks fbn 6 of a file represents a block of data starting 24 KB into the file and extending to 28 KB where fbn 7 begins. The fbn is converted to an appropriate vbn by the file system. Each block in the vbn space and in the dbn space is typically fixed e.g. 4 K bytes KB in size accordingly there is typically a one to one mapping between the information stored on the disks in the dbn space and the information organized by the file system in the vbn space. The disk dbn location specified by the RAID system is further translated by a disk driver system of the storage operating system into a plurality of sectors e.g. a 4 KB block with a RAID header translates to 8 or 9 disk sectors of 512 or 520 bytes on the specified disk.

The requested block is then retrieved from disk and stored in a buffer cache of the memory as part of a buffer tree of the file. The buffer tree is an internal representation of blocks for a file stored in the buffer cache and maintained by the file system. Broadly stated the buffer tree has an inode at the root top level of the file. An inode is a data structure used to store information such as metadata about a file whereas the data blocks are structures used to store the actual data for the file. The information contained in an inode may include e.g. ownership of the file access permission for the file size of the file file type and references to locations on disk of the data blocks for the file. The references to the locations of the file data are provided by pointers which may further reference indirect blocks that in turn reference the data blocks depending upon the quantity of data in the file. Each pointer may be embodied as a vbn to facilitate efficiency among the file system and the RAID system when accessing the data on disks.

The RAID system maintains information about the geometry of the underlying physical disks e.g. the number of blocks in each disk in raid labels stored on the disks. The RAID system provides the disk geometry information to the file system for use when creating and maintaining the vbn to disk dbn mappings used to perform write allocation operations and to translate vbns to disk locations for read operations. Block allocation data structures such as an active map a snapmap a space map and a summary map are data structures that describe block usage within the file system such as the write anywhere file system. These mapping data structures are independent of the geometry and are used by a write allocator of the file system as existing infrastructure for the logical volume. Examples of the block allocation data structures are described in U.S. Patent Application Publication No. US2002 0083037 A1 titled Instant Snapshot by Blake Lewis et al. and published on Jun. 27 2002 which application is hereby incorporated by reference.

The write anywhere file system typically performs write allocation of blocks in a logical volume in response to an event in the file system e.g. dirtying of the blocks in a file . When write allocating the file system uses the block allocation data structures to select free blocks within its vbn space to which to write the dirty blocks. The selected blocks are generally in the same positions along the disks for each RAID group i.e. within a stripe so as to optimize use of the parity disks. Stripes of positional blocks may vary among other RAID groups to e.g. allow overlapping of parity update operations. When write allocating the file system traverses a small portion of each disk corresponding to a few blocks in depth within each disk to essentially lay down a plurality of stripes per RAID group. In particular the file system chooses vbns that are on the same stripe per RAID group during write allocation using the vbn to disk dbn mappings.

During storage system operation a volume or other data container such as a file or directory may become corrupted due to e.g. physical damage to the underlying storage devices software errors in the storage operating system executing on the storage system or an improperly executing application program that modifies data in the volume. In such situations an administrator may want to ensure that the volume is promptly mounted and exported so that it is accessible to clients as quickly as possible this requires that the data in the volume which may be substantial be recovered as soon as possible. Often the data in the volume may be recovered by e.g. reconstructing the data using stored parity information if the storage devices are utilized in a RAID configuration. Here reconstruction may occur on the fly resulting in virtually no discernable time where the data is not accessible.

In other situations reconstruction of the data may not be possible. As a result the administrator has several options one of which is to initiate a conventional full restore operation invoking a direct copy of the volume from a point in time image stored on another storage system. In the general case all volume data and metadata must be copied prior to resuming normal operations as a guarantee of application consistency. The time taken to complete a full copy of the data is often costly in terms of lost opportunity to run business critical applications. However such brute force data copying is generally inefficient as the time required to transfer substantial amounts of data e.g. terabytes may be on the order of days. Similar disadvantages are associated with restoring data from a tape device or other offline data storage. Another option that enables an administrator to rapidly mount and export a volume is to generate a hole filled volume wherein the contents of the volume are holes . In this context holes are manifested as entire blocks of zeros or other predefined pointer values stored within the buffer tree structure of a volume. An example of the use of such holes is described in the U.S. Pat. No. 7 457 982 entitled WRITABLE READ ONLY SNAPSHOTS by Vijayan Rajan the contents of which are hereby incorporated by reference.

In such a hole filled environment the actual data is not retrieved from a backing store until requested by a client. However a noted disadvantage of such a hole based technique is that repeated write operations are needed to generate the appropriate number of zero filled blocks on disk for the volume. That is the use of holes to implement a data container that requires additional retrieval operations to retrieve data further requires that the entire buffer tree of a file and or volume be written to disk during creation. The time required to perform the needed write operations may be substantial depending on the size of the volume or file. Thus creation of a hole filled volume is oftentimes impractical due to the need for quick data access to a volume.

A storage environment in which there is typically a need to quickly bring back or restore a volume involves the use of a near line storage server. As used herein the term near line storage server means a secondary storage system adapted to store data forwarded from one or more primary storage systems typically for long term archival purposes. The near line storage server may be utilized in such a storage environment to provide a back up of data storage e.g. a volume served by each primary storage system. As a result the near line storage server is typically optimized to perform bulk data restore operations but suffers reduced performance when serving individual client data access requests. This latter situation may arise where a primary storage system encounters a failure that damages its volume in such a manner that a client must send its data access requests to the server in order to access data in the volume. This situation also forces the clients to reconfigure with appropriate network addresses associated with the near line storage server to enable such data access.

The present invention overcomes the disadvantages of the prior art by providing a system and method for instantiating a sparse volume within a file system of a storage system that is used to restore data from a secondary storage system backing store on demand. As described herein a sparse volume contains one or more files with at least one data block i.e. an absent block that is not stored locally on disk i.e. on a local volume coupled to the storage system. By not immediately retrieving the data block or a block of zeros as in a hole environment the sparse volume may be generated and exported quickly with minimal write operations required. The missing data of an absent block is stored on the alternate possibly remote backing store and is illustratively retrieved using a remote fetch operation. Once the restored volume is activated the volume may be accessed for any file operations including new write operations. Received write operations are processed normally by allocating a new block and modifying a block pointer to reference the newly allocated data block. If the block pointer was previously marked as absent it is overwritten as the old data that was remotely stored has been updated which results in the storage system not needing to remotely retrieve the data.

In the illustrative embodiment a sparse volume is initialized with volume infrastructure metadata that utilizes special pointers to data stored on the backing store. In the illustrative embodiment special pointers ABSENT pointers are utilized to indicate that the data required a special retrieval operation. Use of these ABSENT pointers present a user such as a client with the illusion of an instant full restore thereby avoiding the long wait associated with a conventional full restore operation. The data may then be restored on demand which as used herein denotes waiting until a specific request for the data is issued before expending storage system and network resources to acquire the data. Such restoration of data may be accomplished in response to a client issuing a data access request to the storage system or by a restore module of the system generating a request demand for the data during e.g. background processing.

One feature of the present invention is that once the restoration has begun the sparse volume is available for all operations including e.g. accepting new modifications write operations directed to the sparse volumes. These write operations are written to the sparse volume and any new pointers that are written overwrite any ABSENT pointers to thereby signify that if a read operation is received the data should be retrieved from the sparse volume and not from the backing store. Thus if a particular block is labeled SPARSE and a write operation is directed to it the block is no longer labeled sparse. Any subsequent read operations will return the newly written data and will not require a remote fetch operation.

According to an aspect of the invention the restore module is embodied as a novel demand generator configured to scan the sparse volume searching for blocks with ABSENT pointers. Upon locating such a block the demand generator initiates a remote fetch operation to retrieve the missing data referenced by each ABSENT pointer from the backing store. The retrieved data is then write allocated to populate the sparse volume. Population of the sparse volume with missing data preferably occurs in connection with a multi phase projected sequence until there are no absent blocks remaining in the file system. Illustratively these phases include the inode file directories and files. In alternative embodiments the phases may be the inode file special data containers directories and files. The special data containers may comprise for example hidden or file system metadata containers such as special directories. At this time the sparse volume transitions to a fully restored detached local volume. The demand generator may also be configured to utilize a special load path that bypasses a buffer cache of the storage system so as not to pollute that cache with retrieved data not currently needed by the client. In addition the demand generator may implement a read ahead feature to enhance retrieval of data associated with a sequence of remote fetch operations.

According to another aspect of the present invention a pump module of the storage system provides flow control to the demand generator. In the event the number of outstanding demands and requests for data missing from the sparse volume reaches a predetermined threshold the pump module regulates the demand generator to slow down or temporarily pause the number of demands it generates. The pump module may further implement a priority policy that e.g. grants precedence to client issued requests over generated demands for missing data in the event available system resources are limited.

Advantageously a sparse volume of a storage system may be instantiated to quickly restore a local volume that has failed. To that end the demand generator and pump modules cooperate to permit efficient access to data that is not physically stored on the storage system without requiring transfer of an entire copy of the local volume before serving data access requests. Moreover the novel modules ensure that all missing data is eventually restored to the sparse volume bringing it to a fully detached volume state in an efficient manner.

Another advantage of the present invention is that backup operations to the remote backing store may be resumed while a restore operation is ongoing. This enables new client updates to be backed up which enables later restoration should a second disaster recovery operation need to be initiated.

In the illustrative embodiment the memory comprises storage locations that are addressable by the processor and adapters for storing software program code. A portion of the memory may be further organized as a buffer cache for storing certain data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. Storage operating system portions of which are typically resident in memory and executed by the processing elements functionally organizes the system by inter alia invoking storage operations executed by the storage system. It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the inventive technique described herein.

The network adapter comprises the mechanical electrical and signaling circuitry needed to connect the storage system to a client over a computer network which may comprise a point to point connection or a shared medium such as a local area network LAN or wide area network WAN . Illustratively the computer network may be embodied as an Ethernet network or a Fibre Channel FC network. The client may communicate with the storage system over network by exchanging discrete frames or packets of data according to pre defined protocols such as the Transmission Control Protocol Internet Protocol TCP IP .

The client may be a general purpose computer configured to execute applications . Moreover the client may interact with the storage system in accordance with a client server model of information delivery. That is the client may request the services of the storage system and the system may return the results of the services requested by the client by exchanging packets over the network . The clients may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over TCP IP when accessing information in the form of files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of blocks.

The storage adapter cooperates with the storage operating system executing on the system to access information requested by a user or client . The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks such as HDD and or DASD of array . The storage adapter includes input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance FC serial link topology.

Storage of information on array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.

Additionally a second storage system is operatively interconnected with the network . The second storage system may be configured as a near line storage server. The storage system generally comprises hardware similar to storage system however it may alternatively execute a modified storage operating system that adapts the storage system for use as a near line storage server. In alternate embodiments there may be a plurality of additional storage systems generally referred to herein as in environment .

To facilitate access to the disks the storage operating system implements a write anywhere file system that cooperates with virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each on disk file may be implemented as set of disk blocks configure to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization modules allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such where the term WAFL is employed it should be taken broadly to refer to any file system that is otherwise adaptable to the teachings of this invention.

An iSCSI driver layer provides block protocol access over the TCP IP network protocol layers while a FC driver layer receives and transmits block access requests and responses to and from the storage system. The FC and iSCSI drivers provide FC specific and iSCSI specific access control to the blocks and thus manage exports of luns to either iSCSI or FCP or alternatively to both iSCSI and FCP when accessing the blocks on the storage system. In addition the storage operating system includes a storage module embodied as a RAID system that manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations and a disk driver system that implements a disk access protocol such as e.g. the SCSI protocol.

The storage operating system further comprises an NRV protocol layer that interfaces with file system . The Network Appliance Remote Volume NRV protocol is generally utilized for remote fetching of data blocks that are not stored locally on disk. However as described herein the NRV protocol may be further utilized in storage system to storage system communication to fetch absent blocks in a sparse volume in accordance with the principles of the present invention. It should be noted that in alternate embodiments conventional file block level protocols such as the NFS protocol or other proprietary block fetching protocols may be used in place of the NRV protocol within the teachings of the present invention.

In accordance with the present invention and as described in further detail herein a demand generator of the storage operating system is used to systematically retrieve data blocks that are not stored locally on disk i.e. on a local volume of storage system while a pump module may be used to regulate the retrieval of those data blocks. Although they are shown and described herein as separate software modules the demand generator and the pump module may be alternatively integrated within a single module of the operating system. Moreover it should be noted that the demand generator and the pump module may be implemented as hardware software firmware or any combination thereof.

Bridging the disk software layers with the integrated network protocol stack layers is a virtualization system that is implemented by a file system interacting with virtualization modules illustratively embodied as e.g. vdisk module and SCSI target module . The vdisk module is layered on the file system to enable access by administrative interfaces such as a user interface UI in response to a user such as a system administrator issuing commands to the storage system. The SCSI target module is disposed between the FC and iSCSI drivers and the file system to provide a translation layer of the virtualization system between the block lun space and the file system space where luns are represented as blocks. The UI is disposed over the storage operating system in a manner that enables administrative or user access to the various layers and systems.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as disks. That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as mirroring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte KB blocks and using index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . The file system uses files to store metadata describing the layout of its file system these metadata files include among others an inode file. A file handle i.e. an identifier that includes an inode number is used to retrieve an inode from disk.

Broadly stated all inodes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The inode of the root fsinfo block may directly reference point to blocks of the inode file or may reference indirect blocks of the inode file that in turn reference direct blocks of the inode file. Within each direct block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

Operationally a request from the client is forwarded as a packet over the computer network and onto the storage system where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . Here the file system generates operations to load retrieve the requested data from disk if it is not resident in core i.e. in the buffer cache . Illustratively this operation may be embodied as a Load Block function of the file system . If the information is not in the cache the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in buffer cache for processing by the storage system. Upon completion of the request the storage system and operating system returns a reply to the client over the network .

The file system generally provides the Load Block function to retrieve one or more blocks from disk. These blocks may be retrieved in response to a read request or an exemplary read ahead algorithm directed to e.g. a file. As described further herein if any requested blocks within a buffer tree of the file contain a special ABSENT value thereby denoting absent blocks then the Load Block function initiates a fetch operation to retrieve the absent blocks from an appropriate backing store using the illustrative NRV protocol . Once the blocks including any data blocks have been retrieved the Load Block function returns with the requested data. The NRV protocol is further described in the above referenced U.S. patent application entitled ARCHITECTURE FOR SUPPORT OF SPARSE VOLUMES by Jason Lango et al. However it should be noted that any other suitable file or block based protocol that can retrieve data from a remote backing store including e.g. the NFS protocol can be advantageously used with the present invention. The file system also illustratively includes a Load Inode function that retrieves inode and file geometry when first accessing a file.

It should be further noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the storage system may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by storage system in response to a request issued by client . Moreover in another alternate embodiment of the invention the processing elements of adapters may be configure to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the system. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable to perform a storage function in a storage system e.g. that manages data access and may in the case of a file server implement file system semantics. In this sense the ONTAP software is an example of such a storage operating system implemented as a microkernel and including the WAFL layer to implement the WAFL file system semantics and manage data access. The storage operating system can also be implemented as an application program operating over a general purpose operating system such as UNIX or Windows NT or as a general purpose operating system with configurable functionality which is configure for storage applications as described herein.

In addition it will be understood to those skilled in the art that the inventive system and method described herein may apply to any type of special purpose e.g. file server filer or multi protocol storage appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system . An example of a multi protocol storage appliance that may be advantageously used with the present invention is described in U.S. Patent Publication No. 2004 030668 titled MULTI PROTOCOL STORAGE APPLIANCE THAT PROVIDES INTEGRATED SUPPORT FOR FILE AND BLOCK ACCESS PROTOCOLS published on Feb. 12 2004. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configure to perform a storage function and associated with other equipment or systems.

In the illustrative embodiment a file is represented in the write anywhere file system as an inode data structure adapted for storage on the disks . is a schematic block diagram of an inode which preferably includes a metadata section and a data section . The information stored in the metadata section of each inode describes the file and as such includes the type e.g. regular directory virtual disk of file the size of the file time stamps e.g. access and or modification for the file and ownership i.e. user identifier UID and group ID GID of the file. The contents of the data section of each inode however may be interpreted differently depending upon the type of file inode defined within the type field . For example the data section of a directory inode contains metadata controlled by the file system whereas the data section of a regular inode contains file system data. In this latter case the data section includes a representation of the data associated with the file.

Specifically the data section of a regular on disk inode may include file system data or pointers the latter referencing 4 KB data blocks on disk used to store the file system data. Each pointer is preferably a logical vbn to facilitate efficiency among the file system and the RAID system when accessing the data on disks. Given the restricted size e.g. 128 bytes of the inode file system data having a size that is less than or equal to 64 bytes is represented in its entirety within the data section of that inode. However if the file system data is greater than 64 bytes but less than or equal to 64 KB then the data section of the inode e.g. a first level inode comprises up to 16 pointers each of which references a 4 KB block of data on the disk.

Moreover if the size of the data is greater than 64 KB but less than or equal to 64 megabytes MB then each pointer in the data section of the inode e.g. a second level inode references an indirect block e.g. a first level block that contains up to 1024 pointers each of which references a 4 KB data block on disk. For file system data having a size greater than 64 MB each pointer in the data section of the inode e.g. a third level inode references a double indirect block e.g. a second level block that contains up to 1024 pointers each referencing an indirect e.g. a first level block. The indirect block in turn contains 1024 pointers each of which references a 4 KB data block on disk. When accessing a file each block of the file may be loaded from disk into the buffer cache .

When an on disk inode or block is loaded from disk into buffer cache its corresponding in core structure embeds the on disk structure. For example the dotted line surrounding the inode indicates the in core representation of the on disk inode structure. The in core structure is a block of memory that stores the on disk structure plus additional information needed to manage data in the memory but not on disk . The additional information may include e.g. a dirty bit . After data in the inode or block is updated modified as instructed by e.g. a write operation the modified data is marked dirty using the dirty bit so that the inode block can be subsequently flushed stored to disk. The in core and on disk format structures of the WAFL file system including the inodes and inode file are disclosed and described in the previously incorporated U.S. Pat. No. 5 819 292 titled METHOD FOR MAINTAINING CONSISTENT STATES OF A FILE SYSTEM AND FOR CREATING USER ACCESSIBLE READ ONLY COPIES OF A FILE SYSTEM by David Hitz et al. issued on Oct. 6 1998.

A file system layout is provided that apportions an underlying physical volume into one or more virtual volumes vvols of a storage system. An example of such a file system layout is described in U.S. Pat. No. 7 409 494 titled EXTENSION OF WRITE ANYWHERE FILE SYSTEM LAYOUT by John K. Edwards et al. and assigned to Network Appliance Inc. The underlying physical volume is an aggregate comprising one or more groups of disks such as RAID groups of the storage system. The aggregate has its own physical volume block number pvbn space and maintains metadata such as block allocation structures within that pvbn space. Each vvol has its own virtual volume block number vvbn space and maintains metadata such as block allocation structures within that vvbn space. Each vvol is a file system that is associated with a container file the container file is a file in the aggregate that contains all blocks used by the vvol. Moreover each vvol comprises data blocks and indirect blocks that contain block pointers that point at either other indirect blocks or data blocks.

In one embodiment pvbns are used as block pointers within buffer trees of files such as file stored in a vvol. This hybrid vvol embodiment involves the insertion of only the pvbn in the parent indirect block e.g. inode or indirect block . On a read path of a logical volume a logical volume vol info block has one or more pointers that reference one or more fsinfo blocks each of which in turn points to an inode file and its corresponding inode buffer tree. The read path on a vvol is generally the same following pvbns instead of vvbns to find appropriate locations of blocks in this context the read path and corresponding read performance of a vvol is substantially similar to that of a physical volume. Translation from pvbn to disk dbn occurs at the file system RAID system boundary of the storage operating system .

In an illustrative dual vbn hybrid flexible vvol embodiment both a pvbn and its corresponding vvbn are inserted in the parent indirect blocks in the buffer tree of a file. That is the pvbn and vvbn are stored as a pair for each block pointer in most buffer tree structures that have pointers to other blocks e.g. level 1 L1 indirect blocks inode file level 0 L0 blocks. is a schematic block diagram of an illustrative embodiment of a buffer tree of a file that may be advantageously used with the present invention. A root top level inode such as an embedded inode references indirect e.g. level 1 blocks . Note that there may be additional levels of indirect blocks e.g. level 2 level 3 depending upon the size of the file. The indirect blocks and inode contain pvbn vvbn pointer pair structures that ultimately reference data blocks used to store the actual data of the file.

The pvbns reference locations on disks of the aggregate whereas the vvbns reference locations within files of the vvol. The use of pvbns as block pointers in the indirect blocks provides efficiencies in the read paths while the use of vvbn block pointers provides efficient access to required metadata. That is when freeing a block of a file the parent indirect block in the file contains readily available vvbn block pointers which avoids the latency associated with accessing an owner map to perform pvbn to vvbn translations yet on the read path the pvbn is available.

As noted each inode has 64 bytes in its data section that depending upon the size of the inode file e.g. greater than 64 bytes of data function as block pointers to other blocks. For traditional and hybrid volumes those 64 bytes are embodied as 16 block pointers i.e. sixteen 16 4 byte block pointers. For the illustrative dual vbn flexible volume the 64 bytes of an inode are embodied as eight 8 pairs of 4 byte block pointers wherein each pair is a vvbn pvbn pair. In addition each indirect block of a traditional or hybrid volume may contain up to 1024 pvbn pointers each indirect block of a dual vbn flexible volume however has a maximum of 510 pvbn vvbn pairs of pointers.

Moreover one or more of pointers may contain a special ABSENT value to signify that the object s e.g. an indirect block or data block referenced by the pointer s is not locally stored e.g. on the volume and thus must be fetched retrieved from an alternate backing store. In the illustrative embodiment the Load Block function interprets the content of the each pointer and if a requested block is ABSENT initiates transmission of an appropriate request e.g. a remote fetch operation for the data to a backing store using e.g. the NRV protocol.

Whereas the aggregate is analogous to a physical volume of a conventional storage system a vvol is analogous to a file within that physical volume. That is the aggregate may include one or more files wherein each file contains a vvol and wherein the sum of the storage space consumed by the vvols is physically smaller than or equal to the size of the overall physical volume. The aggregate utilizes a physical pvbn space that defines a storage space of blocks provided by the disks of the physical volume while each embedded vvol within a file utilizes a logical vvbn space to organize those blocks e.g. as files. Each vvbn space is an independent set of numbers that corresponds to locations within the file which locations are then translated to dbns on disks. Since the vvol is also a logical volume it has its own block allocation structures e.g. active space and summary maps in its vvbn space.

A container file is a file in the aggregate that contains all blocks used by a vvol. The container file is an internal to the aggregate feature that supports a vvol illustratively there is one container file per vvol. Similar to a pure logical volume in a file approach the container file is a hidden file not accessible to a user in the aggregate that holds every block in use by the vvol. The aggregate includes an illustrative hidden metadata root directory that contains subdirectories of vvols 

Specifically a physical file system WAFL directory includes a subdirectory for each vvol in the aggregate with the name of subdirectory being a file system identifier fsid of the vvol. Each fsid subdirectory vvol contains at least two files a filesystem file and a storage label file. The storage label file is illustratively a 4 kB file that contains metadata similar to that stored in a conventional raid label. In other words the storage label file is the analog of a raid label and as such contains information about the state of the vvol such as e.g. the name of the vvol a universal unique identifier uuid and fsid of the vvol whether it is online being created or being destroyed etc.

In addition to being embodied as a container file having level 1 blocks organized as a container map the filesystem file includes block pointers that reference various file systems embodied as vvols . The aggregate maintains these vvols at special reserved inode numbers. Each vvol also has special reserved inode numbers within its vvol space that are used for among other things the block allocation bitmap structures. As noted the block allocation bitmap structures e.g. active map summary map and space map are located in each vvol.

Specifically each vvol has the same inode file structure content as the aggregate with the exception that there is no owner map and no WAFL fsid filesystem file storage label file directory structure in a hidden metadata root directory . To that end each vvol has a volinfo block that points to one or more fsinfo blocks each of which may represent a snapshot along with the active file system of the vvol. Each fsinfo block in turn points to an inode file that as noted has the same inode structure content as the aggregate with the exceptions noted above. Each vvol has its own inode file and distinct inode space with corresponding inode numbers as well as its own root fsid directory and subdirectories of files that can be exported separately from other vvols.

The storage label file contained within the hidden metadata root directory of the aggregate is a small file that functions as an analog to a conventional raid label. A raid label includes physical information about the storage system such as the volume name that information is loaded into the storage label file . Illustratively the storage label file includes the name of the associated vvol the online offline status of the vvol and other identity and state information of the associated vvol whether it is in the process of being created or destroyed .

The present invention overcomes the disadvantages of the prior art by providing a system and method for instantiating a sparse volume within a file system of a storage system that is used to restore data from a secondary storage system backing store on demand. As described herein a sparse volume contains one or more files with at least one data block i.e. an absent block that is not stored locally on disk i.e. on a local volume coupled to the storage system. By not storing the data block or a block of zeros as in a hole environment the sparse volume may be generated and exported quickly with minimal write operations required. The missing data of an absent block is stored on the alternate possibly remote backing store and is illustratively retrieved using a remote fetch operation.

The sparse volume is identified by a special marking of an on disk structure of the volume vvol to denote the inclusion of a file with an absent block. is a schematic block diagram of the on disk structure which illustratively is an exemplary fsinfo block . The fsinfo block includes a set of persistent consistency point image PCPI pointers a sparse volume flag field an inode for the inode file and in alternate embodiments additional fields . The PCPI pointers are dual vbn vvbn pvbn pairs of pointers to PCPIs snapshots associated with the file system. The sparse volume flag field identifies whether the vvol described by the fsinfo block is sparse. In the illustrative embodiment a flag is asserted in field to identify the volume as sparse. The sparse volume flag field may be embodied as a type field identifying the type of a vvol associated with the fsinfo block. The inode for the inode file includes the inode containing the root level pointers to the inode file of the file system associated with the fsinfo block.

Appropriate block pointer s of the file are marked labeled with special ABSENT value s to identify that certain block s including data and or indirect blocks within the sparse volume are not physically located on the storage system serving the volume. The special ABSENT value further alerts the file system that the data is to be obtained from the alternate source namely a remote backing store which is illustratively near line storage server . In response to a data access request the Load Block function of the file system detects whether an appropriate block pointer of a file is marked as ABSENT and if so transmits a remote fetch e.g. read operation from the storage system to the remote backing store to fetch the required data. The fetch operation illustratively requests one or more file block numbers fbns of the file stored on the backing store. It should be noted that while the present description is written in terms of a single backing store the principles of the present invention may be applied to an environment where a single sparse volume is supported by a plurality of backing stores each of which may support the entire or a subset of the sparse volume. As such the teachings should not be taken to be limited to single backing stores.

The backing store retrieves the requested data from its storage devices and returns the requested data to the storage system which processes the data access request and stores the returned data in its memory. Subsequently the file system flushes writes the data stored in memory to local disk during a write allocation procedure. This could be in response to the data being marked as dirty or other notation denoting to the file system that the data must be write allocated. In accordance with an illustrative write anywhere policy of the procedure the file system assigns pointer values other than ABSENT values to indirect block s of the file to thereby identify location s of the data stored locally within the local volume. Thus the remote fetch operation is no longer needed to access the data.

An example of a write allocation procedure that may be advantageously used with the present invention is described in U.S. Pat. No. 7 430 571 titled EXTENSION OF WRITE ANYWHERE FILE LAYOUT WRITE ALLOCATION by John K. Edwards which application is hereby incorporated by reference. Broadly stated block allocation proceeds in parallel on the flexible vvol and aggregate when write allocating a block within the vvol with a write allocator process selecting an actual pvbn in the aggregate and a vvbn in the vvol. The write allocator adjusts block allocation bitmap structures such an active map and space map of the aggregate to record the selected pvbn and adjusts similar structures of the vvol to record the selected vvbn. A vvid vvol identifier of the vvol and the vvbn are inserted into owner map of the aggregate at an entry defined by the selected pvbn. The selected pvbn is also inserted into a container map not shown of the destination vvol. Finally an indirect block or inode file parent of the allocated block is updated with one or more block pointers to the allocated block. The content of the update operation depends on the vvol embodiment. For a dual vbn hybrid vvol embodiment both the pvbn and vvbn are inserted in the indirect block or inode as block pointers.

In step the file system identifies one or more blocks to be loaded and in step invokes the Load Block function to load one or more of the identified blocks. In step a determination is made as to whether the block s is marked ABSENT. This determination may be made for example by examining a block pointer referencing the block. If the block is not absent the procedure branches to step where the block is retrieved from disk and in step the data access request is performed. In the case of a read request performance of the request includes returning the retrieved data to the client. The procedure then completes in step .

However if the block is absent step the procedure continues to step where a remote data access fetch request is sent to a backing store to fetch the requested block s . The fetch request may be issued by a fetch module of the storage operating system such as the exemplary NRV protocol mentioned herein. As noted above a plurality of backing stores may be utilized with a sparse volume. In the example of an environment with a plurality of backing stores metadata contained in a sparse configuration metadata file identifies the appropriate backing store to utilize. The backing store receives the remote data access request and responds with the requested data in step . In step the data access request is performed with the data retrieved from the backing store. Subsequently write allocation is performed to store the retrieved data on one or more local storage devices in step . The procedure then completes in step .

In the illustrative embodiment a sparse volume is initialized with volume infrastructure metadata that utilizes pointers e.g. ABSENT pointers to data stored on the backing store. Use of these ABSENT pointers present a user such as a client with the illusion of an instant full restore thereby avoiding the long wait associated with a conventional full restore operation. The data may then be restored on demand which as used herein denotes waiting until a specific request for the data is issued before expending storage system resources to acquire the data. Such restoration of data may be accomplished in response to a client issuing a data access request to the storage system or by a restore module of the system generating a request demand for the data during e.g. background processing. In accordance with the present invention a sparse volume may be instantiated to quickly restore a local volume that has failed. It should be noted that once a restoration of a sparse volume has begun the sparse volume available for all file system operations including e.g. new modifications write operations . Any operations may be performed to the sparse volume once restore on demand has been initiated. For example a back up operation may be initiated to a sparse volume.

Once the infrastructure of the sparse volume is created at step the volume is available for any client access. It should be noted that after failure of the local volume clients may be required to unmount and remount the restored sparse volume to ensure that they operate on valid data rather than previously cached versions of stale data. For client issued requests restoration of data including any file system data and remaining metadata may be accomplished as described above with reference to . In order to restore retrieve such data only logical file information such as file identification file ID numbers file handles and offset values need to be transferred between the storage system primary and the backing store secondary . The backing store then returns the requested data to the storage system which performs write allocation on that data. As a result fresh block allocation information is created for the sparse volume including new pvbns and vvbns in accordance with the write allocation procedure described above. Thus it is not necessary to transfer any write allocation files inode map summary map active map etc. between the systems. The procedure then ends at step .

The following example describes how a client can access its data on demand once a sparse volume is instantiated to quickly restore a failed local volume. Assume the client wishes to access a file document.doc from its directory served by the storage system . The file system accesses the root directory to locate the file in a conventional manner. If the file system encounters any absent blocks within the buffer tree of the file the blocks are restored from the backing store as described herein. For instance assume that document.doc is located in a . . . users client directory neither of which are present on the sparse volume. The file system cooperates with the NRV module to issue fetch requests for data from the backing store needed to populate the users directory in order to find the client directory and then subsequently populate the client directory to locate the document.doc file. Note that while populating the client directory other directories found in the users directory are not populated and remain absent thus space is reserved for the other directories until needed at a later time. With the file ID and file handle of document.doc the primary may then restore the file from the secondary in accordance with the present invention. It is possible that the primary storage system may only fetch the particular block or blocks of the file that are requested and not the entire file. An example of when this may occur is when servicing a client request for a thumbnail of a file in a Microsoft WINDOWS environment.

In addition to restoring absent data on the sparse volume in response to client requests it may be desirable to ensure that the entire content of the volume is restored as quickly as possible yet with minimal file service disruption. Entire volume restoration is desirable because each client access to the remote backing store generates a retrieval delay. Once all of the volume data is restored locally this delay no longer exists. Also in the event that the backing store becomes unavailable data not yet restored on the primary storage system may be lost. This window of vulnerability can be reduced by implementing a restore module of the storage operating system to run as a background process. It should be noted that if the backing store becomes unavailable the primary storage system may continue to service data access operations until the backing store becomes available and the restore on demand process is restarted. The primary storage system will be able to process write operations and serve any read operations directed to data that has already been restored.

According to an aspect of the invention the restore module is embodied as the novel demand generator configured to scan the sparse volume searching for blocks with ABSENT pointers. Upon locating such a block the demand generator initiates a remote fetch operation to retrieve the missing data referenced by each ABSENT pointer from the backing store. The retrieved data is then write allocated to populate the sparse volume. Population of the sparse volume with missing data preferably occurs in connection with a multi phase projected sequence until there are no absent blocks remaining in the file system. At this time the sparse volume transitions to a fully restored detached local volume.

In step the scanner scans the blocks of a buffer tree of the file and in step determines whether any blocks contain an ABSENT pointer thus indicating that blocks of the file are absent. If the blocks do not contain an ABSENT pointer then in step a determination is made as to whether this is the last file in the sparse volume. If so the procedure ends in step . If not the scanner proceeds to the next file e.g. by incrementing the file ID number in step . The procedure then returns to step .

If an absent block is encountered in step however the scanner signals the demand generator to proactively request the data for the absent block from the backing store. In an alternate embodiment the scanner issues a conventional read request directed to the data. This read request will trigger the fetch operation without invoking the demand generator. In step the demand generator issues a remote data access fetch request to the backing store to fetch a requested data block. The backing store receives the remote data access request and responds with the requested data in step .

Subsequently write allocation is performed on the retrieved data to store the data on one or more storage devices of the sparse volume in step . During the normal course of write allocation the remaining portions of the buffer tree for the file are created. Next at step it is determined if the file is the last file in the sparse volume and if so the procedure ends in step . If not the scanner proceeds to the next file by incrementing the file ID in step and returns to step to scan the blocks of the file. This process continues until all absent blocks have been restored or until the process is manually stopped. Before reaching the last file in the sparse volume the file system may also be notified of having restored the last absent block such as through the sparse volume indication field in which case the file system may then end the process.

The demand generator may also be configured to utilize a special load path that bypasses the buffer cache of the storage system A so as not to pollute that cache with retrieved data not currently needed by the client. For example while the file system cooperates with the NRV protocol module to restore files that a client may currently be accessing for an application which files may need to be cached for faster continued access the demand generator may further request the restoration of files that are not currently needed by the client. Hence these files do not need to be stored in the buffer cache after write allocation to the local volume. It is also important to note that a client request need not be stored on a cache of the secondary backing store because once the date is restored the primary storage system no longer needs to access it on the secondary.

One way to implement the special load path is to mark the demand generated data in the buffer cache as unnecessary so it may be promptly removed from cache once the data is written to disk. Marking of unnecessary data may be effected through a modified use of a least recently used LRU algorithm. When data is to be marked as unnecessary the cache block buffer containing the data is placed at the beginning of an LRU stack as opposed to the end so that it is the first buffer to be reused. Alternatively a new load path transmission link may be created which physically bypasses any unnecessary caches however this alternate solution may require hardware modification. It will be understood by those skilled in the art that other methods of preventing cache pollution may be used within the scope of the present invention.

In addition the demand generator may implement a read ahead feature to enhance retrieval of data associated with a sequence of remote fetch operations. Read ahead algorithms that may be advantageously employed by the demand generator are described in copending U.S. Pat. No. 7 333 993 entitled ADAPTIVE FILE READAHEAD TECHNIQUE FOR MULTIPLE READ STREAMS by Robert L. Fair and Patent Publication No. 2005 0154825 entitled ADAPTIVE FILE READAHEAD BASED ON MULTIPLE FACTORS by Robert L. Fair which are both expressly incorporated herein by reference. The demand generator may cooperate with the file system to employ a speculative read ahead operation that retrieves blocks that are likely to be requested by subsequent fetch operations. For example in response to a read request to retrieve a sequence of consecutive blocks the file system may invoke read ahead operations to retrieve additional blocks that further extend the sequence even though those blocks have yet to be requested by the demand generator. As an example this could be useful when reading a sequential series of absent blocks.

In still another embodiment it is possible to utilize multiple demand generators executing in parallel in the storage operating system to expedite data restoration. Here each demand generator is responsible for only a portion of the blocks in the sparse volume. For example two demand generators could divide a task into equal portions wherein the first demand generator is responsible for the first half of sequential addresses and the second generator is responsible for the second half. Those skilled in the art should understand that there are many alternative configurations for multiple demand generators and that those variant configurations are within the scope and protection of the present invention.

According to another aspect of the present invention the pump module provides flow control to regulate the processing of demands generated by the demand generator as well as the requests issued by clients . Flow control may be needed because the scanner and demand generator are capable of issuing and generating access requests for the blocks of the file system substantially faster than the time required to fetch and restore those blocks from the backing store primarily because the fetch and restore operations are impacted by network latency disk access delays as the data may not be located in the secondary backing store s cache or other external delays. Accordingly these fetch and restore operations may become a bottleneck with respect to performance of the system resulting in a backlog of outstanding demands and requests.

In the event the number of outstanding demands and requests for data missing from the sparse volume reaches a predetermined threshold the pump module regulates the demand generator to slow down or temporarily pause the number of demands it generates. The pump module may further implement a priority policy that e.g. grants precedence to client issued requests over generated demands for missing data in the event available system resources are limited.

The pump module may also function as a priority mechanism for the demands generated by the demand generator and data access requests issued by the client. In order to maintain the appearance of normal operation during a restore on demand operation the demand generator must not consume the bandwidth available for restoration leaving the client with over delayed file access times. To insure that this situation is avoided the pump module grants precedence to the requests from the client over those from the demand generator. Specifically if the demand generator has not reached the maximum threshold at step or is regulated at step the pump module determines at step if the demand generator is over utilizing consuming resources in a manner that limits available resources for client data access requests. If so the pump module grants priority to the client data access requests at step by e.g. placing the demand generator on hold and then returns to step to further monitor the requests. If it is not consuming an abundance of valuable resources the demand generator is allowed to continue unheeded and the procedure returns to step . Other types of requests may have different levels of priority such as for example high priority for special file system commands or low priority for read aheads.

In one embodiment of the present invention the pump module may be embodied as a plurality of threads organized to function as a type of queue through which all data fetch requests to the secondary flow. The pump module may generate the actual fetch requests using e.g. the exemplary NRV protocol. Each thread may be assigned to process i.e. generate and transmit one request at a time and wait for a response to that request prior to processing a next request. Yet through the use of multiple threads requests can complete out of order. This is similar to what is generally referred to in the art as a leaky bucket algorithm. Moreover the demand generator can issue demands to the pump module so long as there are a predetermined number of threads available. For example the pump module may be configured with one hundred threads i.e. a one hundred request queue length that allows essentially unlimited service of client issued requests but that also limits service of demand generated demands so long as at least ten threads are available. Thus if no client requests are issued the demand generator can send up to ninety demands at any one time.

It should be noted that the teachings of the present invention may be utilized with thinly provisioned volumes. Certain file systems including the exemplary write anywhere file layout WAFL file system available from Network Appliance Inc of Sunnyvale Calif. include the capability to generate a thinly provisioned data container wherein the data container is not completely written to disk at the time of its creation. As used herein the term data container generally refers to a unit of storage for holding data such as a file system disk file volume or a logical number LUN which is addressable by e.g. its own unique identification. The storage space required to hold the data contents of the thinly provisioned data container on disk has not yet been used. Thinly provisioned data containers are further described in U.S. Patent Publication No. 2006 0085471 entitled SYSTEM AND METHOD FOR RECLAIMING UNUSED SPACE FROM A THINLY PROVISIONED DATA CONTAINER by Vijajan Rajan et al.

In a restore on demand environment the use of thinly provisioned data containers may be utilized for a primary storage system in the event of a disaster recovery scenario. By utilizing a thinly provisioned primary data container which only has physical storage for a portion of the total amount of the primary volume an administrator does not need to procure physical storage in the total size of the secondary but can only provision the amount of space needed for files data containers that will be used.

To again summarize the present invention is directed to a system and method for implementing restore on demand ROD operation on a sparse volume of a computer such as a storage system. The sparse volume is a data container or volume wherein one or more files contained therein require a special retrieval operation to obtain the data. According to the present invention the sparse volume may be used to quickly restore the use of a local storage device once it has failed. The volume is populated with absent blocks and the data is then restored on demand. The restoration of data may be accomplished as client data access requests are received or by a demand generator. As noted above the demand generator may also be regulated by a pump module. Additionally as noted above once the restoration of a sparse volume has initiated the volume is illustratively available for all data access operations so that for example write operations may be performed back up operations initiated etc.

The foregoing description has been directed to specific embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. For instance it is expressly contemplated that the teachings of this invention can be implemented as software including a computer readable medium having program instructions executing on a computer hardware firmware or a combination thereof. Accordingly this description is to be taken only by way of example and not to otherwise limit the scope of the invention. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

