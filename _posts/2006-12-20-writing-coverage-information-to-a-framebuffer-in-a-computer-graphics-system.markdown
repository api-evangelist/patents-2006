---

title: Writing coverage information to a framebuffer in a computer graphics system
abstract: A computer-implemented graphics system has a mode of operation in which primitive coverage information is generated by a rasterizer for real sample locations and virtual sample locations for use in anti-aliasing. An individual pixel includes a single real sample location and at least one virtual sample location. If the coverage information cannot be changed by a pixel shader, then the rasterizer can write the coverage information to a framebuffer. If, however, the coverage information can be changed by the shader, then the rasterizer sends the coverage information to the shader.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08547395&OS=08547395&RS=08547395
owner: NVIDIA Corporation
number: 08547395
owner_city: Santa Clara
owner_country: US
publication_date: 20061220
---
This Application is related to U.S. patent application Ser. No. 11 171 816 by E. Hutchins filed Jun. 29 2005 and entitled System and Method for Single Sample Virtual Coverage Anti Aliasing assigned to the assignee of the present invention and hereby incorporated by reference in its entirety.

This Application is related to U.S. patent application Ser. No. 11 643 185 by C. Donham et al. filed concurrently herewith and entitled Selecting Real Sample Locations for Ownership of Virtual Sample Locations in a Computer Graphics System assigned to the assignee of the present invention and hereby incorporated by reference in its entirety.

This Application is related to U.S. patent application Ser. No. 11 643 558 by C. Donham et al. filed concurrently herewith and entitled A Shader that Conditionally Updates a Framebuffer in a Computer Graphics System assigned to the assignee of the present invention and hereby incorporated by reference in its entirety.

Embodiments of the present invention generally relate to data processing. More specifically embodiments of the present invention relate to computer graphics systems and graphics applications.

Computer graphics systems represent graphical primitives as pixel elements of a display. Aliasing refers to the visual artifacts such as stair stepping of surface edges sometimes known as jaggies that occur when an image is sampled at a spatial sample frequency that is too low.

A variety of anti aliasing techniques exist to reduce visual artifacts. One example is supersampling in which an image is sampled more than once per pixel grid cell and the samples are filtered. For example in supersampling the contribution of each sample in a pixel may be weighted to determine attributes of the pixel such as the pixel color. Another example of an anti aliasing technique is multisampling. As objects are rendered in a multisampling system a single color is typically computed per primitive and used for all subpixel samples covered by the primitive.

In both supersampling and multisampling the quality of the anti aliasing tends to improve as the number of samples per partially covered pixel increases. For example increasing the number of samples per pixel from four samples 4 sampling to sixteen samples 16 sampling would be expected to reduce visual artifacts. However as the number of samples per pixel increases more sample data must be generated stored transported and processed. Consequently more computing resources such as memory and bandwidth may be needed as the number of samples per pixel is increased. As a result the cost and complexity of graphics systems tend to increase as the number of samples used for anti aliasing increases.

Accordingly an effective but computationally efficient anti aliasing system or method would be advantageous. Embodiments in accordance with the present invention provide these and other advantages.

In one embodiment a computer implemented graphics system has a mode of operation referred to as virtual coverage anti aliasing VCAA or coverage sampling anti aliasing CSAA in which coverage information is generated by a rasterizer for real sample locations and virtual sample locations for use in anti aliasing. In one such embodiment an individual pixel includes a single real sample location and at least one virtual sample location. If the coverage information cannot be changed by a pixel shader then the rasterizer can write the coverage information to a framebuffer. If however the coverage information can be changed by the shader then the rasterizer sends the coverage information to the shader.

In one embodiment a scoreboard is used to keep track of which pixels are being worked on at any point in a graphics pipeline that includes the rasterizer and shader. If the rasterizer can write coverage information to the framebuffer then the rasterizer can also clear the appropriate entry in the scoreboard. Because in some embodiments the rasterizer processes up to four times more data than the shader the scoreboard can be updated more frequently if the rasterizer can write coverage information to the framebuffer. Also because the rasterizer precedes the shader in the pipeline the coverage information reaches the framebuffer sooner when written by the rasterizer and is thus on hand earlier if needed for other processing operations.

These and other objects and advantages of the various embodiments of the present invention will be recognized by those of ordinary skill in the art after reading the following detailed description of the embodiments that are illustrated in the various drawing figures.

Reference will now be made in detail to the various embodiments of the present invention examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with these embodiments it will be understood that they are not intended to limit the invention to these embodiments. On the contrary the invention is intended to cover alternatives modifications and equivalents which may be included within the spirit and scope of the invention as defined by the appended claims. Furthermore in the following detailed description of the present invention numerous specific details are set forth in order to provide a thorough understanding of the present invention. However it will be understood that the present invention may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail so as not to unnecessarily obscure aspects of the present invention.

Some portions of the detailed descriptions that follow are presented in terms of procedures logic blocks processing and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. In the present application a procedure logic block process or the like is conceived to be a self consistent sequence of steps or instructions leading to a desired result. The steps are those utilizing physical manipulations of physical quantities. Usually although not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a computer system. It has proven convenient at times principally for reasons of common usage to refer to these signals as transactions bits values elements symbols characters samples pixels or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present invention discussions utilizing terms such as accessing selecting performing using associating making identifying determining specifying receiving producing writing changing maintaining updating or the like refer to actions and processes e.g. flowcharts and of and respectively of a computer system or similar electronic computing device or processor e.g. system of . The computer system or similar electronic computing device manipulates and transforms data represented as physical electronic quantities within the computer system memories registers or other such information storage transmission or display devices.

In the example of computer system includes a central processing unit CPU for running software applications and optionally an operating system. Memory stores applications and data for use by the CPU . Storage provides non volatile storage for applications and data and may include fixed disk drives removable disk drives flash memory devices and CD ROM DVD ROM or other optical storage devices. User input includes devices that communicate user inputs from one or more users to the computer system and may include keyboards mice joysticks touch screens and or microphones. Network interface allows computer system to communicate with other computer systems via an electronic communications network including wired and or wireless communication. The components of computer system including CPU memory data storage user input devices and network interface are connected via one or more data buses .

In the present embodiment graphics system is connected with data bus and the components of the computer system . The graphics system may be integrated with the computer system motherboard or on a separate circuit board fixedly or removably connected with the computer system. The graphics system may include a graphics processing unit GPU and graphics memory. Graphics memory may include a display memory e.g. a framebuffer used for storing pixel data for each pixel of an output image. In another embodiment display memory and or additional memory are part of memory and are shared with the CPU . Alternatively display memory and or additional memory can be one or more separate memories provided for the exclusive use of the graphics system .

Pixel data can be provided to display memory directly from the CPU . Alternatively CPU can provide the GPU with data and or commands defining the desired output images from which the GPU can generate the pixel data of one or more output images. The data and or commands defining the desired output images can be stored in additional memory . In one embodiment the GPU can generate pixel data for output images from rendering commands and data defining the geometry lighting shading texturing motion and or camera parameters for a scene to be rendered.

The graphics system periodically outputs pixel data for an image from display memory for display on display device . Display device is any device capable of displaying visual information in response to a signal from the computer system . Computer system can provide the display device with an analog or digital signal.

In another embodiment graphics processing system includes one or more additional GPUs similar to GPU . In yet another embodiment graphics processing system includes a graphics coprocessor . Graphics coprocessor and additional GPU are adapted to operate in parallel with GPU or in place of GPU . Additional GPU generates pixel data for output images from rendering commands similar to GPU . Additional GPU can operate in conjunction with GPU to simultaneously generate pixel data for different portions of an output image or to simultaneously generate pixel data for different output images. In one embodiment graphics coprocessor performs rendering related tasks such as geometry transformation shader computations and backface culling operations for GPU and or additional GPUs .

Additional GPU can be located on the same circuit board as GPU sharing a connection with GPU to data bus or additional GPU can be located on an additional circuit board separately connected with data bus . Additional GPU can also be integrated into the same module or chip package as GPU . Additional GPU can have its own display and additional memory similar to display memory and additional memory or can share memories and with GPU . In one embodiment the graphics coprocessor is integrated with the computer system chipset not shown such as the Northbridge or Southbridge chip used to control the data bus .

In general geometry processor generates primitives from vertex data. In one embodiment geometry processor receives rendering commands and data used to define the desired rendered image or images including geometry lighting shading texturing motion and or camera parameters for a scene. The rendering data may include one or more vertices defining geometric primitives. Each vertex has a position that is typically expressed in a two dimensional or three dimensional coordinate system. In addition to a position various attributes are associated with each vertex. In general attributes of a vertex may include any property that is specified on a per vertex basis. In one embodiment the vertex attributes include scalar or vector attributes used to determine qualities such as the color transparency lighting shading and animation of the vertex and its associated geometric primitives.

In one embodiment geometry processor executes one or more vertex programs on each vertex to create a transformed vertex. The geometry processor is programmable and rendering applications can specify the vertex program to be used for any given set of vertices. In one embodiment the vertex program transforms a vertex from a three dimensional world coordinate system to a two dimensional screen coordinate system. More complicated vertex programs can be used to implement a variety of visual effects including lighting and shading procedural geometry and animation operations. In one embodiment geometry processor also culls or discards geometric primitives and or portions thereof that are outside the field of view or otherwise unseen in the rendered image and also may assemble one or more vertices into a geometric primitive such as a triangle or quadrilateral.

In general rasterizer rasterizes primitives. In one embodiment rasterizer converts each geometric primitive into one or more pixel fragments. A pixel fragment defines a set of one or more pixels to be potentially displayed in the rendered image. In one implementation a fragment comprises a two pixel by two pixel 2 2 array referred to herein as a quad. In alternate implementations fragments can include any other arrangement of fragments and pixels. Each fragment coming out of the rasterizer includes information defining the potential coverage of the associated geometric primitive in the rendered image for example image coordinates of the pixels associated with the fragment and coverage of the associated geometric primitive at that pixel location.

In one embodiment shader uses the position information generated by rasterizer and associated with each pixel fragment as well as per vertex and per geometric primitive attributes to determine the output values for example color and depth of each fragment. A shader program is executed on each pixel fragment to determine an output color value for a pixel. In the present embodiment texture unit fetches a texture specifically a texel and maps the texture to a pixel location in an image.

The shaded fragments are then output to the raster operations unit along with attributes such as fragment color depth and stencil values. The raster operations unit integrates the fragments that are output from the shader with the portion of the rendered image already stored in the framebuffer . Fragments can be blended or masked with pixels previously written to the rendered image in the framebuffer . Raster operations can also include anti aliasing and discarding of occluded primitives. The combination of each incoming fragment and any previously stored pixel values in the framebuffer is then output to the framebuffer as part of the rendered image.

Framebuffer may include an anti aliasing AA buffer such as a multi sample MS buffer in a multisampling embodiment for storing real samples. Depth buffers alpha buffers and stencil buffers can also be used to determine the contribution of each incoming fragment if any to the rendered image.

In a coverage sampling anti aliasing CSAA embodiment graphics system includes a virtual sample module to calculate the fractional coverage of pixels comprising a primitive . CSAA may also be referred to as virtual coverage anti aliasing for simplicity of discussion CSAA is used herein. In one such embodiment virtual sample module generates the primitive coverage at the virtual sample locations. The virtual samples that are generated may be stored in one or more locations such as in a framebuffer color buffer z buffer or another memory location. In one embodiment the coverage update unit reads the current coverage from the frame buffer updates the coverage based on the coverage of the real and virtual samples and writes the resulting coverage to the frame buffer . Although coverage update module and virtual sample module are illustrated at a particular location within graphics pipeline they may be located elsewhere such as in ROP .

Virtual sample module and coverage update module of may in some embodiments be configured to generate and utilize virtual samples in anti aliasing calculations for specific operational conditions. In some embodiments virtual samples are utilized for anti aliasing calculations only for edge pixels e.g. only for partially covered pixels . In some embodiments coverage updates used to generate virtual samples are disabled if a z depth test operation is disabled a z depth write operation is disabled or alpha blending is enabled. In some embodiments an application programming interface API provides commands for enabling disabling and configuring the use of virtual samples to update coverage information during execution of a graphics program by the CPU . In one embodiment heuristics are used to determine when coverage should be updated using virtual samples. For example the heuristics may be chosen so that rendering modes that correspond to scene geometry get high quality coverage information using virtual samples but rendering that corresponds to special effects or lighting e.g. particles or multi pass geometry do not.

In the present embodiment the real sample location is in the center of the pixel and the virtual sample locations are distributed through the interior of the pixel. In one embodiment the virtual sample locations are arranged along the edges of the pixel but not necessarily at a point that corresponds to the midpoint of the edges of pixel . In the example of virtual sample location is located to the left of the midpoint of its corresponding edge virtual sample location is above the midpoint of its corresponding edge virtual sample location is to the right of the midpoint of its corresponding edge and virtual sample location is below the midpoint of its corresponding edge.

In the example of virtual sample location can be associated with mapped to or owned by either real sample location or real sample location in pixel virtual sample location can be associated with either real sample location or real sample location in pixel virtual sample location can be associated with either real sample location or real sample location in pixel and virtual sample location can be associated with either real sample location or real sample location in pixel . In general the virtual sample locations on the left and right sides of a pixel are associated with a real sample location in the center of the pixel or the real sample location to the left or right of the virtual sample location and the virtual sample locations on the top and bottom of a pixel are associated with a real sample location in the center of the pixel or the real sample location above or below the virtual sample location.

A real sample location assumes the attributes e.g. color component value z depth value computed for the position of the real sample within the primitive and a virtual sample location assumes an attribute or attributes of the real sample location with which it is associated. Thus although a virtual sample location may reside within one pixel the local pixel it may have the attributes of another pixel specifically an adjacent pixel . The attribute values at a real sample location are referred to as a real sample and the attribute values at a virtual sample location are referred to as a virtual sample.

According to embodiments of the present invention a new primitive that crosses one or more real or virtual sample locations changes the status of virtual samples in the anti aliasing buffer. Any virtual sample location that is covered by the primitive is updated. Additionally the status of virtual samples that are uncovered but are associated with a real sample that is covered is also updated. Additional details are provided below in conjunction with .

The depth of a real sample is used as a surrogate for the virtual sample depth. Although for many primitives the depth value will not be constant across the primitive use of the real sample depth value still provides a reasonable approximation of the virtual sample depth value. The computed depth for the real sample can be referred to as Z x y . The computed depth for the real sample is determined using the following relationship alpha 0 beta 1 2 where alpha x y and beta x y are the barycentric coordinates for x y DZ0 Z0 Z2 and DZ1 Z1 Z2 where Z0 Z1 and Z2 are the z depth values at the vertices of a triangle primitive.

According to embodiments of the present invention depth and coverage values for the pixel to the right and for the pixel below the pixel being rendered are fetched refer to below. The depth value fetched from the framebuffer can be referred to as Z x y . The depth value for the pixel to the right can be referred to as Z x 1 y and the depth value for the pixel below can be referred to as Z x y 1 .

Only the coverage data for the virtual samples may be stored in the framebuffer. So C n x y always refers to virtual coverage data from the framebuffer where n is the virtual sample index ranging from 0 to 3 in .

Continuing with reference to in one embodiment the virtual coverage data from the framebuffer C n x y indicates which depth value to use for a particular sample. The depth value from the frame buffer to use for a particular virtual sample is called Z n where n is the virtual sample index ranging from 0 to 3 in . If the coverage value for a virtual sample is 0 the depth value from the adjacent pixel is used for the virtual depth. If the coverage value for a virtual sample is 1 the depth value from the local pixel is used for the virtual depth. With reference to 0 1 selects 0 0 0 selects 0 1 1 1 selects 1 1 1 0 selects 1 1 1 2 1 selects 2 1 2 0 selects 2 3 1 selects 3 1 1 3 0 selects 3 1 .

The primitive coverage can then be updated based on the results of a depth test. Using the depth value chosen to represent the framebuffer for each virtual sample as well as the depth value for the real sample from the framebuffer the depth test is performed against the computed depth for the pixel. For each sample that fails the depth test the coverage value is now considered to be 0 Test .

New coverage data can then be merged with the old coverage data. If the real sample is covered C x y 1 then the merged coverage values are the primitive virtual coverage values C i x y for all samples in the pixel C i x y C i x y . If the real sample is not covered C x y 0 then only the virtual sample data for covered samples C i x y 1 is updated. For any covered sample the merged coverage is 0. For any uncovered sample the merged coverage is the original framebuffer coverage C i x y C i x y 0 C i x y . Note that the real sample used to determine how to merge the coverage C x y is the one associated with each subsample for C 0 it s the one at x y for C 1 it s the one at x 1 y for C 2 it s the one at x y 1 and for C 3 it s the one at x 1 y 1 .

The merging of the framebuffer coverage C n x y and the primitive coverage C n x y depends on the operating mode. In a non transparency mode all coverage data is updated as described above. In a transparency mode only pixels which have partial coverage are updated e.g. fully covered pixels are not updated as described above. The framebuffer is then updated as needed.

In one embodiment the real sample locations are located at the center of the pixels. Each pixel such as pixel has a number of virtual sample locations e.g. virtual sample location which are identified using circles O . In the example of the virtual sample locations are arranged throughout the interior of each pixel as described previously herein. In one embodiment there are 4 virtual sample locations per pixel.

For a pixel that is partially covered by a new primitive a virtual sample location e.g. virtual sample locations and may be associated with the real sample location of the local pixel or with the real sample location of one of the proximate adjacent pixels. In the example of in which there are 4 virtual sample locations per pixel the adjacent pixel that is selected may be the closest pixel moving up down or to the side right or left from the local pixel as described previously herein. In an embodiment utilizing 8 virtual sample locations per pixel the adjacent pixel that is selected may be the pixel above below right left or along one of the 4 diagonal directions of the local pixel.

Because a scene is typically rendered as a sequence of primitives represents changes in a virtual coverage mask that occurs when one new primitive is rasterized. Previously determined coverage results for real and virtual sample locations that are not covered by the new primitive are unchanged.

In one embodiment a virtual coverage mask is changed when a new primitive is rasterized as follows. For pixels that have real sample locations covered by the new primitive e.g. real sample locations and of pixels and any virtual sample locations covered by the new primitive are marked as covered covered virtual sample locations are identified in as solid circles and uncovered virtual sample locations are identified in as open circles while virtual sample locations within those pixels that are not covered by new primitive are not marked as covered e.g. virtual sample locations and in pixels and are not marked as covered . For pixels in which new primitive does not cover any real sample locations but only covers a virtual sample e.g. virtual sample locations and in pixels and virtual sample locations within those pixels are marked as not covered.

In one embodiment the virtual sample coverage information is encoded as a single additional bit that is a pointer indicating ownership by one of two possible pixels either the local pixel within which the virtual sample location resides or an adjacent pixel. In one embodiment a binary 1 is used to indicate that a virtual sample belongs to a real sample in the local pixel and a binary 0 is used to indicate that a virtual sample belongs to a real sample in a neighboring pixel. Because there are only two possible owners per virtual sample location it is not necessary to point to a specific pixel or real sample location the value of the pointer bit either 0 or 1 is sufficient for identifying which pixel or real sample location owns the virtual sample location.

In one embodiment the set of single bit bitcodes for the virtual sample locations forms a virtual coverage mask. As a new primitive is received the virtual coverage mask is updated to reflect any changes in ownership of the virtual sample locations. The virtual coverage mask may be stored in a portion of anti aliasing buffer or some other memory location.

The virtual samples provide additional information and may be used to adjust a weight given to real samples in anti aliasing. In one embodiment because a virtual sample is assumed to have the same color as the real sample that owns it the number of sample counts for a particular color can be increased by the number of corresponding virtual sample counts and then scaled by the total number of real and virtual samples. Consider an example in which there are 4 virtual samples and one real sample per pixel the color component of the real sample is black two of the virtual samples are associated with the real sample and thus have a black color component and two of the virtual samples are associated with the real sample of an adjacent pixel that has a white color component. Consequently the color of the local pixel would be three fifths black and two fifths white. However more generally an arbitrary weighting function may be used for weighting real samples as a function of the virtual samples that they own. In one embodiment the weighting corresponds to a fraction of a number easily represented in binary e.g. an integer multiple of 1 128 . In one such embodiment the weight of the real sample is 20 128 and the weight of each virtual sample is 27 128.

Embodiments in accordance with the present invention provide a number of benefits. Each virtual sample represented using a single bit requires less data than a real sample. Consequently high quality anti aliasing can be achieved for a particular number of real and virtual samples with reduced data storage and bandwidth requirements. Additionally embodiments in accordance with the present invention are highly scalable and order independent are compatible with a low cost hardware implementation do not suffer from bleed through and are compatible with different color and depth buffer formats.

Some graphics systems render a scene in a particular order relative to the foreground and the background. In back to front rendering all objects are drawn from the background to the foreground even if the object will eventually be occluded. In contrast in front to back rendering the rendering process begins with objects likely to be in the foreground and moves towards objects likely to be in the background.

An advantage of front to back rendering order is that it allows early culling of occluded primitives at a stage when occluded primitives are not fully drawn. Invisible objects for example do not need to be fully drawn reducing the computational effort. After some initial data is generated for an object likely to be invisible an additional z depth or stencil test is performed. For example in the z depth test of possibly occluded primitives z depth values of primitives are checked against a z depth buffer to confirm that they are invisible e.g. occluded by nearer objects that block them from view .

High quality anti aliasing of silhouette edges in front to back rendering utilizes z depth or stencil information for the sample points to check whether the sample points are occluded or visible. For a virtual sample location that belongs to a real sample location within the same pixel the z depth or stencil value for the virtual sample can be selected to be the same as that of the real sample. In one embodiment the depth or stencil information for an uncovered virtual sample location is selected to be that of a neighboring pixel with which the virtual sample location has been associated as described above. This approximation permits z depth or stencil testing to be performed when new primitives are rasterized in front to back rendering. After z depth or stencil testing is performed the virtual coverage mask may be updated to reflect changes in virtual sample ownership resulting from the z depth or stencil testing.

In overview the array of real sample locations can be selected to delineate and encompass a region containing a number of virtual sample locations. All of the virtual sample locations in the region are associated with one of the real sample locations in the selected array . In other words none of the virtual sample locations in the region is or will be associated with a real sample location that is not a member of the array no virtual sample in the region points to a real sample past the boundary defined by the array of real samples. In one embodiment rendering is essentially shifted so that a three by three 3 3 array of real samples and an associated region containing 16 virtual samples is rendered.

In the present embodiment to perform testing e.g. depth or stencil testing for the 16 virtual sample locations in the region nine 9 real sample values are used one value per real sample in the array . In comparison in a conventional approach 12 real sample values are used to perform testing for 16 virtual samples in a quad of pixels 4 virtual samples per pixel . For example in a conventional approach z depth values for the 4 pixels in the quad as well as for the 2 pixels above the quad the 2 pixels to the left of the quad the 2 pixels to the right of the quad and the 2 pixels below the quad would be needed. According to the present embodiment 16 virtual sample locations can be processed using only 9 z depth values. Consequently computer resources e.g. the bandwidth associated with reads from the framebuffer are conserved. Although described for z depth values the example is equally valid for stencil values.

In considering the coverage of any one virtual sample location the conventional approach and the present invention approach would use the same real sample values to evaluate ownership of that virtual sample location and thus the results of the conventional approach and the present invention approach are the same. However an important difference between the conventional approach and the present invention approach is that the subset of 16 virtual samples processed at a time in accordance with embodiments of the present invention is different from the subset of 16 virtual samples processed at a time in the conventional approach.

Rendering generally proceeds through a scene from left to right and from top to bottom. Coverage of virtual sample locations outside of region is evaluated before or after the evaluation of region so that all virtual sample locations are processed. For example if the array and region are processed in step then in step a similar second array and region to the right of and adjacent to array and region would be processed. Processing of the second array region will reuse the real samples and and thus only six 6 new z depth or stencil values would need to be fetched from the framebuffer . In a similar manner when the next row is processed processing of the array region that is below and adjacent to array and region will reuse the real samples and and so again only 6 new z depth or stencil values would need to be fetched from the framebuffer . Again computer resources e.g. the bandwidth associated with reads from the framebuffer are conserved.

In general according to embodiments of the present invention as rendering proceeds from left to right and from top to bottom only depth or stencil values for pixels down and to the right of the current block of pixels being rendered are needed. Accordingly so called race situations in which a z depth or stencil value has been updated during processing of a previous quad but has not yet been written to the framebuffer and so cannot be fetched from the framebuffer when needed are avoided. In other words in a conventional approach to determine ownership of a virtual sample location in the conventional manner a real sample above or to the left opposite the order of rendering may be needed but that real sample if updated during rendering may not yet be available. According to embodiments of the present invention this situation is avoided.

In block of an array of real sample locations is selected e.g. array of . In one embodiment the array includes N by N real e.g. 3 3 real sample locations. However embodiments in accordance with the present invention are not so limited. Different shapes e.g. rectangular polygon honeycomb may be used instead of a squarish array. The array may be covered at least in part by a primitive see for example . A number of virtual sample locations are disposed within the region delineated by the array of real sample locations e.g. region of . In one embodiment the array of real sample locations includes less than all real sample locations associated with a frame of pixel data.

In block of in one embodiment a set of z depth or stencil values for the array of real sample locations is accessed one z depth or stencil value for each real sample location. In one such embodiment in which the array includes 9 real sample locations up to 9 z depth or stencil values may be accessed as values are reused perhaps less z depth values may be needed .

In block of tests e.g. a depth test or stencil test are performed using the first set of z depth or stencil values as described above in conjunction with .

In block of with reference also to the results of the tests are used to associate each virtual sample location within the region with one of two possible real sample locations selected from the array of real sample locations.

The process of flowchart can be repeated as new primitives are introduced into and pass through the graphics pipeline.

For example if the software driver determines that the shader is using alpha transparency to kill a pixel thus modifying the coverage information then the driver can direct the rasterizer to send the coverage information to the shader.

In one embodiment a scoreboard not shown is used to keep track of which pixels are being worked on at any point in a graphics pipeline that includes the rasterizer and shader . If the rasterizer can write coverage information to the framebuffer that is if the shader will not be modifying the coverage information then the rasterizer can also clear the appropriate entry in the scoreboard. Otherwise the shader clears the appropriate entry in the scoreboard at the appropriate time.

Because in some embodiments the rasterizer processes up to 4 times more data pixels than the shader the scoreboard can be updated more frequently if the rasterizer can write coverage information to the framebuffer . Also because the rasterizer generally precedes the shader in a graphics pipeline the coverage information reaches the framebuffer sooner when written by the rasterizer and is thus on hand earlier if needed for other pipeline operations.

In block the rasterizer changes the coverage information e.g. the virtual coverage mask to account for a new primitive that covers the pixel s at least in part producing modified coverage information as previously described herein.

In block a determination is made as to whether or not the shader can modify the coverage information early CSAA versus late CSAA . If the shader cannot modify the coverage information early CSAA then flowchart proceeds to block otherwise flowchart proceeds to block late CSAA .

In block early CSAA of and with reference also to the rasterizer writes the modified coverage information to the framebuffer provided the shader will not be causing a change to the modified coverage information.

In block late CSAA if the shader can change the coverage information the coverage information is sent from the rasterizer to the shader.

There are instances in which the shader can write virtual coverage information for virtual samples to the framebuffer but should not write information e.g. updated z depth values or updated stencil values for real samples to the framebuffer. One such instance occurs when a primitive covers only virtual sample locations that is the primitive does not cover any real sample locations. This situation may be referred to as virtual only coverage. With virtual only coverage the shader is instructed e.g. by a software driver via a shader program to update only the virtual coverage information for virtual sample locations but not to update information for real sample locations. In the context of the embodiment discussed above this situation can occur only during late CSAA because in early. CSAA coverage information for pixels that have virtual only coverage is not sent to the shader .

There are other instances in which the shader can write information such as color depth and or stencil values to the framebuffer even with virtual only coverage. As mentioned above pixels that have real sample locations that are covered can be distinguished from pixels with virtual only coverage in that color depth and or stencil information for pixels with covered real sample locations can be potentially written to the framebuffer while color depth and stencil information for pixels with virtual only coverage is not written to the framebuffer. However in some operating modes it is desirable for pixels with virtual only coverage to trigger an update of the color depth and or stencil information. One such operating mode is referred to as coverage to alpha in which the percentage of coverage of a pixel by a primitive is used to determine the degree of transparency associated with the pixel.

Accordingly in one embodiment even a pixel with virtual only coverage can trigger the shader to update color depth and or stencil information in the framebuffer . This can be accomplished in different ways. In one embodiment this is accomplished by changing the coverage bit associated with the pixel s real sample location from 0 to 1 thereby indicating to the shader that the real sample location is covered even though it is not. A coverage bit associated with one of the virtual sample locations may correspondingly be changed from 1 to 0 such that the overall coverage e.g. the total number of covered samples for the pixel is unchanged.

Thus according to the embodiments just described if no real sample locations are covered by a primitive but the shader may modify the coverage information e.g. as in late CSAA then the shader will not update color depth and or stencil information unless instructed to the contrary by the shader program in operating modes such as coverage to alpha for example.

In block the rasterizer receives a new primitive that covers only one or more of the virtual sample locations in the pixel s and does not cover any real sample locations.

In block the rasterizer produces modified coverage information by changing the virtual coverage information to account for the new primitive as previously described herein. In one embodiment a determination is made as to whether or not the shader can modify the coverage information early CSAA versus late CSAA as described above in conjunction with . In such an embodiment in the case of early CSAA the rasterizer writes the modified coverage information to the framebuffer while in the case of late CSAA the modified coverage information is sent to the shader .

In one embodiment in some operating modes such as coverage to alpha the coverage information is modified further to indicate that the real sample location is covered even though it is not covered.

In block of and with reference also to the shader writes the modified coverage information to the framebuffer . The shader also uses the modified coverage information to determine whether the shader can write color information stencil information and or depth information to the framebuffer . In one embodiment referred to above as virtual only coverage the shader can update virtual coverage information but does not update color stencil and or depth information.

In another embodiment in some operating modes such as coverage to alpha the shader can update real sample information such as color stencil and or depth information even with virtual only coverage. Because the coverage information may be modified as described above to indicate that a real sample is covered even though it is not the shader can still use the coverage information to make this decision. In other words from the perspective of shader the coverage information is believed to be correct and so the shader will act accordingly.

Although specific steps are disclosed in flowcharts and of and such steps are exemplary. That is the present invention is well suited to performing various other steps or variations of the steps recited in flowcharts and . The steps in flowcharts and may be performed in an order different than presented and that the steps in flowcharts and are not necessarily performed in the sequence illustrated. Furthermore the features of the various embodiments described above can be used alone or in combination.

Embodiments of the present invention are thus described. While the present invention has been described in particular embodiments it should be appreciated that the present invention should not be construed as limited by such embodiments but rather construed according to the below claims.

