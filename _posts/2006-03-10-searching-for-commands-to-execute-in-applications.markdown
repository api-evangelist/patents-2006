---

title: Searching for commands to execute in applications
abstract: A user can access a searching component that allows the user to enter search terms to search for commands associated with a computer program. The most likely commands are provided to the user, and a command can be selected for execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07925975&OS=07925975&RS=07925975
owner: Microsoft Corporation
number: 07925975
owner_city: Redmond
owner_country: US
publication_date: 20060310
---
A wide variety of different types of computer applications are currently in use. Such computer applications often fall into three or more different categories. For instance rich client applications are typically applications that run on a client device such as a desktop computer or laptop computer. Other software applications include web based applications in which a client interacts with a web based device such as a server using a web browser in order to run the application. Still other software applications include mobile device applications. Mobile device applications might run on mobile devices such as personal digital assistants PDAs telephones handheld computers etc.

In running a software application a user typically wishes to perform one or more different tasks. As used herein the term task means anything that a user wishes to do in the context of a given software application.

In order to allow users to accomplish the desired tasks many current software applications provide a graphical user interface. The user executes one or more commands on the graphical user interface to accomplish a desired task. There are substantially three main ways by which people accomplish tasks using a graphical user interface and they depend on how frequently the user performs a given task. For tasks that are performed frequently by the user the user might learn or memorize the sequence of steps or commands required to perform the task with the graphical user interface. Also with frequently performed tasks applications might expose the user interface elements for performing the most popular tasks prominently in the user interface.

A second group of tasks are those that are performed infrequently by the user. The user may typically browse the menus or tool bars displayed by the graphical user interface in order to attempt to locate the user interface element that can be used to perform the desired task. Another way in which users perform infrequent tasks is to seek the help of other people to find out how to perform the task. In doing this the user might go to a news group or simply ask another individual how to perform the task.

Finally when the user does not remember how to perform the task and cannot find out how to perform the task by asking others users might typically invoke a help mechanism associated with the application. For instance some applications are associated with help documentation stored on a client or on a web site. The help documentation allows a user to search for a help topic that often explains what to do in order to accomplish a task that a user wishes to perform.

Of course there are a number of problems associated with these types of current systems. Unless the user has the steps for performing a task memorized it can be fairly cumbersome for the user to find out how to perform the task. Asking news groups or physically asking other persons how to perform a task takes a relatively large amount of time and thus reduces efficiency.

In addition even where the user attempts to hunt through the user interface to find the user interface element necessary to accomplish the desired task the user may encounter problems. For instance in most graphical user interfaces the features or elements associated with the graphical user interface are categorized under other elements. In other words the user may go to the File drop down menu to look for a particular feature or element of the graphical user interface. The user may also go to the Edit drop down menu to look for another feature. Of course if the sought after feature is under an unexpected drop down menu this can result in frustration and extra time required for the user to find that feature.

Similarly attempting to determine how to perform a task using help documentation often requires a fairly high level of knowledge about the task. For instance some help documentation is simply an alphabetical listing of different tasks. This may be extremely unhelpful to a user who does not know the technical term for the task to be performed. By way of example in one spreadsheet software application adding rows and columns to a spreadsheet is performed using an insert command. Of course it would take a user a fairly long time to track this command down if the user was simply looking under the add commands in the help documentation.

Similarly many help mechanisms provide information that is not useful in a given context. For instance assume the user is in a word processing application which has no tables in it but the user wishes to add a table. The help mechanism might typically be arranged with all information related to tables found in a plurality of different spots within the help documentation. Thus the help documentation might include modifying existing tables adding or deleting rows or columns from tables and a wide variety of other information dealing with already existing tables. Of course since the user s document has no already existing tables this information is completely useless to the user. Yet the user must sift through this information in order to identify the steps necessary to add a table.

The discussion above is merely provided for general background information and is not intended to be used as an aid in determining the scope of the claimed subject matter.

A user can access a searching component that allows the user to enter search terms to search for commands associated with a computer program. In one embodiment the search component is context sensitive so that the search results are dependent not only upon the search terms input by the user but upon the current context of the application. In one embodiment the search is performed by computing likely search results after each letter entered by the user in a search term. In one embodiment a search is not only conducted for the desired commands but the command is automatically executed as well. In another embodiment a search returns relevant commands and a user can select a desired command from a list.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The claimed subject matter is not limited to implementations that solve any or all disadvantages noted in the background.

The present subject matter deals with searching for commands associated with software applications and executing those commands. However before that subject matter is discussed in more detail two illustrative computing devices will be described.

Embodiments are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with various embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

Embodiments may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Some embodiments are designed to be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules are located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing some embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer is operated in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Memory is implemented as non volatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is illustratively allocated as addressable memory for program execution while another portion of memory is illustratively used for storage such as to simulate storage on a disk drive.

Memory includes an operating system application programs as well as an object store . During operation operating system is illustratively executed by processor from memory . Operating system is illustratively designed for mobile devices and implements database features that can be utilized by applications through a set of exposed application programming interfaces and methods. The objects in object store are maintained by applications and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

Communication interface represents numerous devices and technologies that allow mobile device to send and receive information. The devices include wired and wireless modems satellite receivers and broadcast tuners to name a few. Mobile device can also be directly connected to a computer to exchange data therewith. In such cases communication interface can be an infrared transceiver or a serial or parallel communication connection all of which are capable of transmitting streaming information.

Input output components include a variety of input devices such as a touch sensitive screen buttons rollers and a microphone as well as a variety of output devices including an audio generator a vibrating device and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition other input output devices may be attached to or found with mobile device .

Client is shown with a platform . In one embodiment platform is for example an operating system that supports a plurality of different applications . In the embodiment shown in platform includes command searching and processing component and command store . As is described in greater detail below component is exposed to user through application or independent of application such that the user can search for commands associated with application and optionally execute the desired commands. In one embodiment platform exposes an interface such as an application programming interface which can be invoked by application .

Client is also shown with an optional speech recognition component . This can be used as described below.

In the embodiment shown in client is also connected to a server though a network . Network can be any desired network such as a wide area network a local area network etc.

In accordance with one embodiment user begins to enter a search request. In one embodiment user can enter the search request through speech recognition component by simply speaking the desired search request. For purposes of the present discussion however it will be assumed that the user types in the search request one letter at a time but the invention is not to be so limited.

In any case shows one graphical user interface which can be used to receive entry of the search request. User interface in illustrates that application is a presentation program referred to as Program A . Command searching and processing component exposes text box through user interface of application to the user. The user can enter a search request letter by letter into text box .

Therefore after the user types in a first letter in text box on user interface the letter is transmitted as a search request to command searching and processing component in platform . In order to do this in one embodiment application provides the search request through the interface exposed by component . Receiving the first letter at command searching and processing component is indicated by block in .

Component then calculates likely words that complete the letter string entered thus far. For instance if the user has typed ins the most likely completion of this prefix might be insert . This is indicated by block in and is described in more detail below with respect to the example shown in .

In one embodiment component also receives the context of application . For instance the context will illustratively identify the particular application for which a command is sought and provide an indication of the particular contents of the window currently open and under focus in the application a position of the cursor relative to the elements on the open window etc. Examples of context are described in greater detail below and the optional step of receiving the context is indicated by block in .

Once the first letter is received likely completions are calculated and the context component performs a search through command store that stores the commands associated with a plurality of different applications. This search is performed based on the received letters likely completions and the context. Performing the search is indicated by block in .

In performing the search component identifies possible commands and calculates a score indicative of how likely it is that each of the possible commands is being requested by the user in the search request. This is indicated by block in . While the search can be performed in any desired way in one embodiment the search is performed using a search engine that is trained with prior probabilities of commands.

Once the calculation has been made component returns the search results through interface where they are displayed at user interface through application . Of course the results can be returned without going through application as well. In any case in one embodiment component not only displays the most likely commands given the search request but also displays them in ranked order given the score calculated for each command in block . Displaying the ranked commands is indicated by block in .

User can then either select one of the displayed commands or continue typing additional letters in the search request. This is indicated by block in . In the embodiment in which the user does not select one of the commands but instead continues to type letters processing reverts back to block and another search is performed scores are calculated and the likely commands are again displayed in ranked order as indicated by blocks and .

Assume for the sake of the example shown in that the user wishes to insert a table in the particular application which is open. In the embodiment shown in user interface shows that user has typed into text box the letters ins . The context has also been provided to component . The context indicates among other things that the open application is a presentation application. Component calculates the probabilities of commands associated with the input ins stored in command store . In the particular example shown in component determines that the most probable completion of ins is insert and component displays as search results commands which relate to inserting or adding in the given context.

It will be noted from this example that component illustratively not only searches based upon the particular letters input but based upon synonyms of the most likely completions of those letters. In other words the most likely completion of the letters ins in the present context is insert . Therefore component identifies synonyms for insert such as add and searches for commands that are for inserting or adding things and that would be most likely given the current context of the application .

As shown in component returns the search results ranking them in order. It can be seen that the first command returned is insert slide which is more probable than any of the other commands in the list. The other commands in the list are rank ordered according to the score calculated by component which can be a likelihood or probability or other desired measure and they are numbered according to their rank. In the embodiment shown in the first nine results are number according to their rank and a plurality of other commands are also provided but are not numbered.

The user can select one of the commands from the list of returned results by simply clicking on the displayed command. However in one embodiment the user can also select one of the numbered search results by simply typing that number in box . Any other desired way of selecting a command from the list can be used as well.

In accordance with the example shown in the user selects the insert table command. Having component receive a command selection is indicated by block in .

Once the user has selected a command from list if more dialog with the user is required in order to further refine or disambiguate the command component can conduct that additional dialog. This is discussed in greater detail below with respect to . Determining whether the extra dialog is required and conducting that dialog is indicated by blocks and in .

Once the dialog is complete or if no further dialog is required that means that the selected command has been fully disambiguated by component . Component can then either provide additional information to user about the selected command such as tutorial information or component can simply execute the command selected by the user. Providing the additional information is described in more detail below with respect to and and executing the selected command is indicated by block in .

As an example of executing the commands where the user has selected the insert table command component after it determines that no additional dialog is necessary controls application such that application takes the user to the appropriate place in the application to execute the insert table command. displays the appropriate user interface mechanism that allows the user to execute the insert table command.

As an example of conducting additional dialog to refine a command component may conduct a dialog with the user as at block in to determine the size of the table which the user wishes to add. Component then adds it automatically. In another embodiment component simply allows the user to walk though the insert table functionality provided by application once component has taken the user to that place in the user interface provided by application .

Also the additional dialog may further define what the user wishes to do. For example if the user inputs delete cell and table the component may respond with an inquiry such as which table or which cell and then delete the specified table or cell based on the response from the user.

In accordance with another embodiment component or another component invoked by component automatically performs the command selected by the user receiving user inputs where necessary. For instance user can select the desired user interface elements to insert a table from the list of possible commands. Component or another component invoked by component can then assume control of application and begin to automatically perform that command. However when it comes to the point where the user interface asks the user to specify the size of the table in terms of columns and rows component simply highlights the field to be modified by the user and pauses until the user has input the desired information and clicked OK . In that example component or other component simply waits until the user has selected the desired number of columns and rows and clicked OK and component or other component then walks the application through the remainder of the steps necessary to perform the command of inserting the desired size table within the application at the specified spot. Automatically executing the command is indicated by block in .

Of course if component is not configured to automatically execute the command selected by the user the user can continue to use component as the user is taking the steps to execute the command. For instance if in the user again types ins into text box component again identifies the possible commands and calculates the scores for the various commands and again displays a list of possible commands given the new context. This is shown in . Specifically illustrates that component has now calculated the highest scores for the commands of inserting rows and inserting columns in a table because the context indicates that the table has already been added as shown in .

As briefly mentioned above component can convey additional information to the user and not just execute the command. This is indicated in . For instance component may illustratively be configured to provide user with tutorial information or guided help in executing the command. In doing so component first determines that it must convey this additional information e.g. the guided help to the user as indicated at block . The decision to provide the additional information can be predetermined by the developer or set by the user using any desired user interface element or based on any other desired criteria. Component then retrieves and conveys the additional information as indicated by block . In the embodiment discussed herein the additional information is the guided help or tutorial help which can be offered to a user in executing a command and an example of this is illustrated in .

For instance assume for the sake of example that the user types back in text box as shown in . Component then calculates the most probable commands given the input back and given the present context and provides the ranked results shown in list . also shows that the user has selected the first result in the list i.e. the change the background wizard command . The selected command is actually comprised of a command bundle of subcommands that are executed to perform the overall command or task of changing the background. Component then launches the change background command bundle associated with application . In the embodiment illustrated one example of the guided help is shown in .

From the above discussion it will be clear that the particular user interface for conducting command searching can take a wide variety of different forms. For instance shows another embodiment of user interface . In the embodiment shown in the user has entered open in text box and the possible commands are shown in list . The user can ask for additional results using elements .

From the description thus far it is clear that the command searching and processing component and the subject matter related to it are applicable not only to rich client applications such as word processing applications spreadsheets presentation software etc. that reside on a client such as a desktop or laptop computer but that the subject matter is also applicable and useful in an environment in which application resides on a mobile device such as a personal digital assistant a mobile telephone a handheld computer etc. However illustrate that the command searching and processing component and the associated subject matter are also useful in other environments. In one such environment application resides on a client but command searching and processing component resides remotely such as on a server. In another such environment application and command searching and processing component both reside remotely from the client such as on a server. Items in are numbered similarly to corresponding items in .

More specifically shows that command searching and processing component and command store are no longer resident on client . Instead component resides on server and component is shown coupled to component and can reside at any desirable location. In the embodiment shown in search request and context are provided through platform over network to component on server . Component performs the search calculates the scores associated with the results and provides the ranked search results back through network and platform to application where they are provided to user through user interface .

It can thus be seen that the present system uses language to find substantially any command that a user wishes to execute in an application. The user can provide a search request in the user s own language and the present system illustratively maps that language to the correct command by searching based on prior probabilities given context. The commands that are returned are likely the most relevant ones for a given search request in the current context. Commands returned once selected can be automatically performed for the user or a user interface can be brought up based on the selected command a wizard can be launched a rich wizard can be launched or a tutorial can be run based on the selected commands.

It should also be noted that the present system pivots functionality of the application around the particular command that the user wishes to execute. For instance if the user wishes to find all commands in the system that have to do with printing it may be difficult in conventional systems to find those specific commands because printing information is located in help systems in many different places relative to many different functions within an application. However the present component can be used to gather all of that information into a single place in response to a search request for a printing related command.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

