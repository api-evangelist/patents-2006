---

title: Method and apparatus for application verification
abstract: A method for verification of an application for zones that includes determining an execution environment of the application, obtaining a list of permissions from the execution environment, analyzing the application to identify a restricted instruction within the application, wherein the restricted instruction is zone specific, and generating a report when a required permission of the restricted instruction is not in the list of permissions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07814465&OS=07814465&RS=07814465
owner: Oracle America, Inc.
number: 07814465
owner_city: Redwood Shores
owner_country: US
publication_date: 20060512
---
The typical computer system includes software and hardware. The software includes all processes that may execute on the computer system such as web browsers word processors software development tools networking applications operating system applications etc. The hardware includes a processor memory networking equipment etc.

In the past several years hardware and software technologies have advanced at an exorbitant rate. Concerning hardware for example memory manufacturers are steadily increasing the amount of available storage on all sizes of computers chip manufacturers advance processor speeds and networking is now pervasive. In terms of software for example new programming languages have been created and programming language functionality has increased. Further operating systems network applications and other such applications are constantly advancing. Using the greater functionality provided by the new hardware and software technologies have led to more enhanced features in the execution environment of the application.

However over time applications must evolve with technology. Specifically the applications must be compatible with the environment in which the application is to execute. For example applications that previously executed on operating systems developed twenty years ago may not be able to execute on the newest operating systems of today.

One trivial method for ensuring that an application can execute on the environment intended for the application is to actually execute the application in the new environment in a controlled setting. In this trivial method various software testers use the execution environment that would be used by users of the application. The software testers must ensure not only that the execution environment is consistent with the users but also that the input parameters match all possible input parameters of the users. Ensuring both the execution environment and the input parameters are consistent with the use of the application can be cumbersome.

Thus toolkits are developed. The toolkits typically gather data about the application both before the application is executing and while the application is executing. Specifically toolkits may perform algorithmic analysis on the application and or determine the most likely input parameters of the application.

In general in one aspect the invention relates to a method for verification of an application for zones that includes determining an execution environment of the application obtaining a list of permissions from the execution environment analyzing the application to identify a restricted instruction within the application wherein the restricted instruction is zone specific and generating a report when a required permission of the restricted instruction is not in the list of permissions.

In general in one aspect the invention relates to a system for verification of an application that includes an application verification toolkit configured to determine an execution environment of the application obtain a list of permissions from the execution environment and analyze the application to identify a restricted instruction within the application wherein the restricted instruction is zone specific and a report generator configured to generate a report when a required permission of the restricted instruction is not in the list of permissions.

In general in one aspect the invention relates to a user interface for verification of an application that includes a web application configured to receive the application and an execution environment of the application and obtain a list of permissions from the execution environment and a report generator configured to generating a report when a required permission of a restricted instruction is not in the list of permissions wherein the report is generated after analyzing the application to identify the restricted instruction within the application.

Other aspects of the invention will be apparent from the following description and the appended claims.

Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.

In the following detailed description of embodiments of the invention numerous specific details are set forth in order to provide a more thorough understanding of the invention. However it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail to avoid unnecessarily complicating the description.

In general embodiments of the invention provide a method and apparatus for verifying that an application can execute in a specific execution environment. Specifically embodiments of the invention provide a mechanism for determining the permissions of the execution environment. After determining the permissions of the execution environment embodiments of the invention determine whether an application executing in the execution environment uses restricted instructions such as any restricted application programming interfaces APIs restricted system calls restricted library functions restricted commands networking based restricted instructions e.g. cacheFS or have security constraints that require different permissions than the permissions of the execution environment.

The client corresponds to a component that includes functionality to transfer code to an application verification toolkit. Specifically within the memory of the client is the code . The code corresponds to any collection of instructions that when executed constitute all or a part of the application. Specifically the code corresponds to the portion of the application that is verified. The code may correspond to source code or binary code in accordance with one or more embodiments of the invention. Source code corresponds to a collection of instruction in the form that is written by an application developer. Binary code corresponds to instructions that have been processed by a development program. Specifically binary code corresponds to a format of the application that is ready for execution i.e. executable code .

Continuing with the client in the client may additionally include an application development program such as a source control application. The source control application may include functionality to submit the code to the application verification toolkit described below on a scheduled basis such as nightly or on request by the application developer.

In accordance with one or more embodiments of the invention the application verification toolkit corresponds to a tool for verifying that an application is able to execute in a specific execution environment not shown . The execution environment corresponds to the hardware and or software environment in which an application is to be executed. Specifically the execution environment may corresponds to a particular hardware configuration such as an x86 or an x64 platform to an application configuration such as the operating system container application or any other such application or to the environment of the user. The execution environment typically includes a group of permissions. The permissions correspond to the access capabilities of an application in the execution environment. For example the permissions may include a set of restricted instructions e.g. APIs system calls library functions commands etc. that are available to an application the resources that an application may use and the resources that are not available to the application. For example the permissions may specify that an application in a particular execution environment has access to read from specific files but not write to specific files. The permissions may also specify that an application in a particular execution environment may not access a specific service directly but rather must use a particular management interface. Accordingly a restricted instruction in the application for accessing the service must specify the management interface.

Continuing with the application verification toolkit the application verification toolkit includes an interface and a verifier . The interface corresponds to a component that includes functionality to communicate with the client . In accordance with one or more embodiments of the invention the interface includes a web application and a report generator . The web application includes functionality to receive the code and information about the execution environment from the client . In one or more embodiments of the invention the web application is Internet based. Specifically the web application is associated with a URL of the client. Those skilled in the art will appreciate that rather than interfacing with a web application an application that provides the functionality provided by the application verification toolkit may exist locally on the client .

The report generator includes functionality to receive results of the verification of the application and concatenate the results into a report not shown . In one or more embodiments of the invention the report includes information regarding whether the code passed the verification process. If the code did not pass the verification process then the report also contains information regarding which restricted instruction in the code caused the error and the portion of the code that used the restricted instruction.

Continuing with the application verification toolkit of the interface is connected to the verifier . In one or more embodiments of the invention the verifier includes functionality to determine whether the code uses any restricted instructions that the execution environment of the code would not have permission to use. The verifier includes a set of rules in accordance with one or more embodiments of the invention. The rules specify the restricted instructions that a given execution environment does not have permission to use. Specifically the rules correlate the restricted instructions with the execution environment.

A repository is connected to the application verification toolkit in accordance with one or more embodiments of the invention. The repository corresponds to any storage unit for data such as a database file system directory server disks etc. The repository contains lists of restricted instructions e.g. application restricted instructions platform restricted instructions miscellaneous restricted instructions . In one or more embodiments of the invention the lists of restricted instructions are divided into categories. Specifically the categories include application restricted instructions platform restricted instructions and miscellaneous restricted instructions . The application restricted instructions correspond to restricted instructions that are application specific. The application restricted instructions may also include a list of restricted instructions that a user cannot use but would be acceptable for an administrator to use. Thus if the execution environment is for the user then the code cannot contain an administrator specific restricted instruction.

Continuing with another category of restricted instructions are platform specific restricted instructions . The platform specific restricted instructions correspond to the set of restricted instructions that are for specific hardware and operating system. For example the restricted instructions that are specific to an x86 architecture may be included in the platform specific set of restricted instructions. Further if the execution environment includes a specific operating system then the code cannot use restricted instructions for other operating systems. Accordingly in the example the platform restricted instructions contain the list of restricted instructions that are specific to different operating systems.

The categories of restricted instructions may also include miscellaneous restricted instructions . The miscellaneous restricted instructions correspond to any remaining restricted instruction that the code should not include because the code does not have appropriate permissions or does not have access to use.

Continuing with the repository of the repository also includes test probes in accordance with one or more embodiments of the invention. The test probes correspond to small programming modules that can be embedded into code. The test probes include functionality to trace the execution of the code and output the trace. Accordingly the test probes include functionality to test for specific restricted instructions and output the restricted instructions that are used in the code . In one or more embodiments of the invention the test probes are restricted instruction specific. In particular each probe is used to test for a single restricted instruction.

Initially a restricted instruction listing including restricted instructions is obtained Step . Specifically a listing of restricted instructions is obtained. The restricted instruction listing may be obtained for example by searching a variety of knowledge sources. For example the restricted instruction listing may be obtained from the website of an application or platform vendor or from a third party source. Before adding the restricted instruction listing to the repository those skilled in the art will appreciate that the system may verify that the restricted instruction listing is not already found in the restricted instruction repository. For example an administrator may review a list of all the restricted instructions i.e. a restricted instruction listing .

After obtaining the restricted instruction listing a determination is made whether the restricted instruction listing is application specific Step . In particular a determination is made whether the restricted instruction listing is for a particular application. If the restricted instruction listing is application specific then the specific application for the restricted instruction is determined Step . The application may be determined from the restricted instructions and the vendors. Specifically each restricted instruction is associated with an application to which the restricted instruction is an interface. Accordingly the application can be determined from the restricted instruction. Next the restricted instruction listing is added to the application specific space in the repository Step .

Alternatively if the listing of restricted instructions is not application specific then a determination is made whether the listing of restricted instructions is platform specific in accordance with one or more embodiments of the invention Step . Those skilled in the art will appreciate that a restricted instruction may be both application specific and platform specific.

If the restricted instruction is platform specific then the specific platform for the restricted instruction is determined Step . Determining the specific platform for the restricted instruction may be performed for example by accessing knowledge sources known in the art. Once the platform is determined then the restricted instruction listing is added to the repository for the specific platform Step .

Alternatively if the restricted instruction listing is not platform specific then the restricted instruction listing is added to the miscellaneous space in the repository Step . The process of adding restricted instructions to the repository may continue until repository is completely populated with the necessary restricted instructions.

In one or more embodiments of the invention after adding the restricted instruction listing to the repository the restricted instruction repository is verified Step . Specifically a developer administrator or agent may review the restricted instruction repository to ensure that all restricted instructions that should be listed are listed and that all restricted instructions that are listed should be listed.

Once the repository is populated with the restricted instructions from the listings then the repository may be used to verify an application. shows a flowchart of a method for application verification in accordance with one or more embodiments of the invention. Initially the execution environment is determined Step . The execution environment may be determined from the user or may be detected automatically. Specifically the user may specify the hardware and operating system of the application. Further the user may specify any previous applications executing on the hardware where the application is to be deployed.

Next the permissions for the execution environment is determined Step . The permissions for the execution environment can be determined from knowledge sources or from the user. Specifically the user may specify that the application is to be executed by a user or within a certain area within the system.

After determining the set of permissions for the execution environment a determination is made whether the application is in binary code Step . In accordance with one or more embodiments of the invention if the application is in binary code then probes in the binary code are activated Step . At this stage the probes may be added to the binary code or the probes may be preexisting in the binary code. Activating the probes in the binary code may be performed for example by changing parameters either before or during execution of the binary code. Further in one or more embodiments of the invention only the probes that relate to the restricted instructions are activated. Specifically using the rules of the verifier at this stage only the probes specified by the rules are activated.

Further in one or more embodiments of the invention the probes correspond to Dtrace probes developed by Sun Microsystems Inc. located in Santa Clara Calif. . Dtrace probes may be executed dynamically without changing the source code. Accordingly a Dtrace probe may verify for restricted instructions and or permission without requiring source code changes.

Accordingly the execution of the binary code is then initiated in a test environment Step . While the code is executing output from the probes is received Step . The output may specify the portion of the application that is executing and which restricted instructions are used in the code.

Alternatively if the application is not in binary code then the application is most likely in source code. Accordingly the source code is loaded into the verifier Step . Next the source code is reviewed for the presence of restricted instructions. Specifically the restricted instructions in the source code are checked against the restricted instructions in the repository.

Regardless of whether the application is in the source code or in binary code a determination is made whether any of the restricted instructions are used without permission Step . Specifically a determination is made whether any restricted instructions exist in the application that should not be in the application.

If restricted instructions that are used without permission exist then the faulty code is determined Step . The faulty code corresponds to the portion of the application that has the restricted instruction that is used without permission. Determining the faulty code may be performed by the probe of the verifier when the restricted instruction is found.

Once the faulty code is determined then an alert is generated Step in accordance with one or more embodiments of the invention. At this stage the alert may halt the verification process or remain unreported to the client until the verification process completes.

If restricted instructions are used with permissions or after the alert is generated then a determination is made whether a dependency exists in the application Step . A dependency exists in the application if the application calls on one or more other applications. Specifically the application may use an unrestricted API to call a separate application. Accordingly the dependent code is recursively obtained Step . Next the dependent code is verified starting with Step using the same permissions and execution environment as the original application in accordance with one or more embodiments of the invention. Those skilled in the art will appreciate that verifying the dependent code may be performed recursively or iteratively.

Alternatively if a dependency does not exist in the application or if all dependencies have been verified then a determination is made whether the verification is finished. Specifically a determination is made whether the application has completed the verification process. If the verification is not finished then the remainder of the application is verified starting with Step .

Once the verification of the application completes then the results of the verification are outputted Step . Specifically a report is generated that shows which restricted instructions are used in which the application did not have permission to use the restricted instruction. The report may be outputted to the display e.g. screen of the client transmitted to a managing application executing on the client or transmitted to the memory of the client. Those skilled in the art will appreciate that a report may only be generated if a restricted instruction is used without the required permission.

In one or more embodiments of the invention the report is used to perform an action on the code. Specifically the client may remove the faulty code by removing the restricted instruction or using a different restricted instruction. Once the faulty code is removed the application may be re verified using the application verification toolkit. Alternatively the client may also use the information to add in a specification of the application that the application should not be used in the particular execution environment. Those skilled in the art will appreciate that other corrective actions may also be performed.

The virtual platform typically includes a set of services and resources that allow full functionality of the zone architecture. For example the virtual platform may include network interfaces devices administration utilities etc. The virtual platform may interface with one or more zones i.e. a global zone zone zone zone .

In one or more embodiments of the invention each non global zone i.e. zone zone zone provides an isolated environment for running applications. Processes running in a given zone are prevented from monitoring or interfering with other activities in the system. Access to other processes network interfaces file systems devices and inter process communication facilities is restricted to prevent interaction between processes in different zones. The permissions available within a zone are restricted to prevent operations with system wide impact. In one embodiment of the invention each zone i.e. zone zone zone may be identified by an alphanumeric name and a numeric ID.

The zones i.e. zone zone zone are typically configured and administered using the utilities provided by the zone management layer. These utilities may allow an administrator to specify the configuration details of a zone install file system contents including software packages into the zone manage the runtime state of the zone etc. In addition a pseudo terminal utility may allow an administrator to run commands within an active zone without logging into the zone through a network based login server such as rlogind or sshd.

A global zone manages the previously mentioned non global zones e.g. zone zone zone . The global zone always exists and acts as the default zone in which all processes run if no zones have been created. Further in one or more embodiments of the invention the global zone is the general operating environment that is created when the OS is booted and executed and serves as the default zone in which processes may be executed if no non global zones e.g. zone zone zone are created present. In the global zone administrators and or processes having the proper rights and permissions may generally perform any task and access any device resource that is available on the computer system on which the OS is run. Thus processes running in the global zone typically have the same set of permissions available on a system running without zones i.e. permissions to load kernel modules access physical devices etc. Further an administrator logged into the global zone may monitor and control the system as a whole including the physical devices and network interface that are hidden from the other non global zones .

The zone architecture shown in allows the physical system to be separated into isolated individual portions. Having non global zones that are isolated from each other may be desirable in many applications. For example if a single computer system running a single instance of an OS is to be used to host applications for different competitors e.g. competing websites then it would be desirable to isolate the data and processes of one competitor from the data and processes of another competitor. That way it can be ensured that information is not being leaked between the competitors. Partitioning the OS into non global zones and hosting the applications of the competitors in separate non global zones is one possible way of achieving this isolation.

While isolating individual portion of a computer system using zones is advantageous from a security and virtualization perspective the zone architecture requires additional mechanisms to facilitate communication of processes and resources between zones without using network based login servers. In one embodiment of the invention pseudo terminals are provided that facilitate non network based login servers while maintaining isolation between the respective zones.

In one embodiment of the invention the ownership component allows the pseudo terminals to bridge zones i.e. global to non global zones and non global to non global zones and accordingly bridge isolated file systems i.e. bridge the individual file systems associated with each zone . Thus in accordance with one embodiment of the invention each zone may open a pseudo terminal within the zone i.e. within the file system associated with the zone and also open a pseudo terminal that bridges zones i.e. bridges the file system of two isolated zones .

Specifically in one embodiment of the invention each pseudo terminal includes an ownership component. More specifically each pseudo terminal is owned by a particular zone and visible to all zones regardless of whether the pseudo terminal is in use. When a pseudo terminal is opened within a given non global zone e.g. zone zone zone the pseudo terminal is owned by the zone that opened the pseudo terminal.

Similarly when a pseudo terminal is opened in the global zone the pseudo terminal is owned by the global zone . However when a pseudo terminal is opened in the global zone the global zone may transfer ownership of the slave side of the pseudo terminal to a target zone i.e. a non global zone thereby forming a communication channel between the global zone and the target zone.

In one embodiment of the invention the ownership component of the pseudo terminals is maintained by the global zone . The ownership component may be represented as a flat text file an array indexed by pseudo terminals or any other data structure that can store ownership information. The ownership information may include the alphanumeric name of the zone the numeric ID of the zone any other means of uniquely identifying the zone or a combination thereof.

Returning back to a global process may open a pseudo terminal having a master side owned by the global zone and a slave side owned by the global zone . The global zone may subsequently transfer ownership of the slave side of the pseudo terminal from the global zone to the target zone which in is zone . Thus the ownership of the master side is retained by the global zone while the slave side becomes owned by zone and is transferred into zone . This allows the global zone process to communicate with a zone process .

In the zone architecture certain APIs are restricted to only the global zone. The following are tables that include examples of restricted APIs in a zone execution environment in accordance with one or more embodiments of the invention. Table 1 shows a list of restricted APIs for restricted interfaces when they are called in a non global zone in accordance with one or more embodiments of the invention.

Table 2 shows a list of restricted library functions when the library functions are called in a non global zone in accordance with one or more embodiments of the invention.

Table 3 shows a list of restricted commands when the commands are called in a non global zone in accordance with one or more embodiments of the invention.

Table 4 shows a list of restricted device file APIs when the device file APIs are called in a non global zone in accordance with one or more embodiments of the invention.

Further an application that executes in the zone architecture is restricted in terms of the types of system calls library functions and commands allowed. Specifically in a zone environment an application is restricted to only the privileges necessary to perform a job. A process rights manager enforces the restriction using the concept of privilege sets. In one or more embodiments of the invention each process has four sets of privileges. The four sets of privileges include the effective privilege set the permitted privilege set the limit privilege set and the zone process privileges. Each of the listed privilege sets are described below.

In one or more embodiments of the invention the effective privilege set corresponds to the set of privileges that a program uses at the time of execution. Specifically the effective privilege set may be used to determine whether a process can use a particular privilege.

In order for a privilege to be in the effective privilege set the privilege must also be in the permitted set. In one or more embodiments of the invention a permitted privilege set corresponds to the set of privileges that is available for use by a process. Privileges may be available to a program from inheritance or from assignment. Accordingly the permitted set is a subset of the inheritable set.

Continuing with the example an inheritable privilege set corresponds to the set of privileges that a process can inherit from a parent process. The privilege a child process may inherit is controlled by how the process was initiated and by the permitted set for the child process.

For example with regards to users the inheritable set includes a basic set of privileges in accordance with one or more embodiments of the invention. Specifically programs that are initiated with a call to fork 2 inherit all privileges from the parent process and can add new privileges to the process. In contrast programs that are initiated using a call to exec 2 inherit all the privileges from the parent process without being able to add any new privileges.

Finally in one or more embodiments of the invention a limit privilege set corresponds to the upper bound of privileges that a process and children of the process may inherit. By default the limit set is set as all privileges. Thus if a user is assigned a profile that includes a program that has been assigned privilege the user can execute the program because the assigned privileges are within the user s limit set. Further all privileges in the permitted set might not be used at the time of execution. In addition the limit set is only enforced at the call to exec 2 time. Thus a process is allowed to drop privileges used before exec 2 after exec 2 . The relationship between the privilege sets corresponds to the permitted set is a subset of the inheritable set. Further the inheritable set is limited by the value of the limit set.

Processes in a non global zone are constrained by the privilege sets that are assigned to the processes when created. Table 5 shows a list of system calls library functions and commands that can return errors when they are called in a non global zone in accordance with one or more embodiments of the invention.

Continuing with the example suppose the developer wants to ensure that the application complies with the zone architecture described in and in the above tables. Specifically the developer needs to ensure that all restricted instructions that are used in the application and in any dependent code are for non global zones. Accordingly the restricted instructions cannot be in the above restricted tables. Thus in the example the developer accesses the zone application verification toolkit. show an example user interface that the developer may use to test whether the application can execute in a zone environment.

Specifically shows an example user interface for the developer to request verification of the application. As shown in the developer may have multiple execution environments to choose from for the application. Specifically each execution environment is represented by a machine e.g. 10.0.8.2 MachineA MachineA vServer MachineA vServer MachineA vServer .

In the application verification may include both a non zone architecture such as the architecture represented by 10.0.8.2 and zone architectures such as the architectures of MachineA MachineA vServer MachineA vServer MachineA vServer . MachineA represents the execution environment of a global zone. The remaining machines e.g. MachineA vServer MachineA vServer MachineA vServer represent the execution environment of non global zones.

Accordingly the developer first chooses the execution environment of the application by selecting checkboxes e.g. checkbox A checkbox B checkbox C checkbox D checkbox E associated with the execution environment to verify.

Next in order to submit the request the developer either types in or chooses the application from a drop down box and selects the submit button . After selecting the submit button the job is added to the job box e.g. Job A Job B Job C Job D Job E and the binary code or source code of the application is sent to the machines for verification. Alternatively the developer may choose to use the command line interface to submit the requests to individual machines.

Continuing with the example the code is verified. Specifically code is checked for the presence of any restricted instructions listed in the above tables. More specifically if the application is binary code then the probes are added to the code if necessary and activated. Next the binary code is executed. Further any code in which the binary code is dependent also has probes activated and is also executed. The output of the probes is then sent to the developer.

Alternatively if the application is source code then the code is scanned for the presence of the restricted instructions in the tables. Further any application on which the source code is dependent is also verified. The results of the scanning are sent to the developer.

Regardless of whether the application is source code or binary code shows an example user interface for returning the results to the developer. As shown in the developer can view the hardware profile whether the verification was a success a description of the verification process and the number of remaining jobs on each machine e.g. checkbox A checkbox B checkbox C checkbox D checkbox E .

Further in the example user interface the developer may choose a specific checkbox e.g. checkbox A checkbox B checkbox C checkbox D checkbox E to obtain a description of the results. Specifically a developer either enters information into the drop down box or selects a checkbox e.g. checkbox A checkbox B checkbox C checkbox D checkbox E and selects the discover button . In the example MachineA vServer did not pass the verification. Accordingly the developer may choose the checkbox D associated with MachineA vServer and select the discover button .

Using the description about the verification of the application on MachineA vServer allows the developer to perform a corrective action on the application. Specifically the developer may remove the faulty portion of the code and re verify the application.

The invention may be implemented on virtually any type of computer regardless of the platform being used. For example as shown in a computer system includes a processor associated memory a storage device and numerous other elements and functionalities typical of today s computers not shown . The computer may also include input means such as a keyboard and a mouse and output means such as a monitor . The computer system is connected to a local area network LAN or a wide area network e.g. the Internet not shown via a network interface connection not shown . Those skilled in the art will appreciate that these input and output means may take other forms.

Further those skilled in the art will appreciate that one or more elements of the aforementioned computer system may be located at a remote location and connected to the other elements over a network. Further the invention may be implemented on a distributed system having a plurality of nodes where each portion of the invention e.g. repository verification trigger zone application verification toolkit etc. may be located on a different node within the distributed system. In one embodiment of the invention the node corresponds to a computer system. Alternatively the node may correspond to a processor with associated physical memory. The node may alternatively correspond to a processor with shared memory and or resources. Further software instructions to perform embodiments of the invention may be stored on a computer readable medium such as a compact disc CD a diskette a tape or any other computer readable storage device.

Embodiments of the invention allow for a simple solution to verify an application. Specifically a client interacts with a simple user interface and receives a report that includes the restricted instructions in accordance with one or more embodiments of the invention. Further embodiments of the invention interface easily with source control applications and testing application that may submit job requests to the interface to verify the application.

Moreover because the verification toolkit verifies the APIs and the permissions of the execution environment embodiments of the invention provide a mechanism whereby a developer and or an administrator is able to verify the application in the execution environment in which the application is executing. Thus before the application is even deployed to the execution environment the developer and or administrator is assured that the application will execute properly.

In addition embodiments of the invention provide a mechanism whereby the list of restricted instructions may be easily extended to encompass additional restricted instructions. Specifically adding restricted instructions can be performed by updating the repository to encompass more restricted instructions. Accordingly the verifier is able to verify that an application can execute in multiple different execution environments.

While the invention has been described with respect to a limited number of embodiments those skilled in the art having benefit of this disclosure will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly the scope of the invention should be limited only by the attached claims.

