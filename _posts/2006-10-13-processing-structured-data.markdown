---

title: Processing structured data
abstract: The present invention provides a fast and efficient way of processing structured data by utilizing an intermediate file to store the structural information. The structured data may be processed into a Binary mask Format (BMF) file which may serve as a starting point for post-processing. A tree structure built on top of the BMF file may be constructed very quickly, and also takes up less space than a DOM tree. Additionally, BMF records may reside entirely in the memory and contain structural information, allowing SAX-like sequential data access.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07761459&OS=07761459&RS=07761459
owner: XimpleWare, Inc.
number: 07761459
owner_city: Milpitas
owner_country: US
publication_date: 20061013
---
This application is a continuation in part of U.S. patent application Ser. No. 10 272 077 filed Oct. 15 2002 now U.S. Pat. No. 7 133 857 entitled PROCESSING STRUCTURED DATA which is hereby incorporated by reference.

The present invention relates to the field of structured data files in computer systems. More specifically the present invention relates to the processing of structured data in an efficient manner.

Structured data represents a large portion of the information accessed on the Internet and other computer networks. There are several reasons why structured data is so popular. American Standard Code for Information Interchange ASCII and its extensions such as Unicode Transformation Formats UTF 8 and UTF 16 are among the most common standard encoding formats. Text encoding puts information into a format that is easily readable by a human thus it is easy for programmers to develop and debug applications. Lastly textual encoding is extensible and adding new information may be as simple as adding a new key value pair.

Recently Extensible Markup Language XML has been growing in popularity. XML is a markup language for documents containing structured information. Unlike its predecessor Hypertext Markup Language HTML where tags are used to instruct a web browser how to render data in XML the tags are designed to describe the data fields themselves. XML therefore provides a facility to define tags and the structural relationships between them. This allows a great deal of flexibility in defining markup languages to using information. Because XML is not designed to do anything other than describe what the data is it serves as the perfect data interchange format.

XML however is not without its drawbacks. Compared with other data formats XML can be very verbose. Processing an XML file can be very CPU and memory intensive severely degrading overall application performance. Additionally XML suffers many of the same problems that other software based text based processing methods have. Modern processors prefer binary data representations particularly ones that fit the width of the registers over text based representations. Furthermore the architecture of many general purpose processors trades performance for programmability thus making them ill suited for text processing. Lastly the efficient parsing of structured text no matter the format can present a challenge because of the added steps required to handle the structural elements.

Most current XML parsers are software based solutions that follow either the Document Object Model DOM or Simple API for XML SAX technologies. DOM parsers convert an XML document into an in memory hierarchical representation known as a DOM tree which can later be accessed and manipulated by programmers through a standard interface. SAX parsers on the other hand treat an XML document as a stream of characters. SAX is event driven meaning that the programmer specifies an event that may happen and if that event occurs SAX gets control and handles the situation.

In general DOM and SAX are complementary not competing XML processing models each with its own benefits and drawbacks. DOM programming is programmer friendly as the processing phase is separate from application logic. Additionally because the data resides in the memory repetitive access is fast and flexible. However DOM requires that the entire document data structure usually occupying 7 10 times the size of the original XML document be loaded into the memory thus making it impractical for large XML documents. SAX on the other hand can be efficient in parsing large XML documents at least when only small amounts of information need to be processed at once but it maintains little of the structural information of the XML data putting more of a burden on programmers and resulting in code that is hardwired bulky and difficult to maintain.

What is needed is an application program interface API that combines the best attributes of both DOM and SAX parsing.

The present invention provides a fast and efficient way of processing structured data by utilizing an intermediate file to store the structural information. The structured data may be processed into a Binary mask Format BMF file which may serve as a starting point for post processing. A tree structure built on top of the BMF file may be constructed very quickly and also takes up less space than a DOM tree. Additionally BMF records may reside entirely in the memory and contain structural information allowing SAX like sequential data access.

Embodiments of the present invention are described herein in the context of a system of computers servers and software. Those of ordinary skill in the art will realize that the following detailed description of the present invention is illustrative only and is not intended to be in any way limiting. Other embodiments of the present invention will readily suggest themselves to such skilled persons having the benefit of this disclosure. Reference will now be made in detail to implementations of the present invention as illustrated in the accompanying drawings. The same reference indicators will be used throughout the drawings and the following detailed description to refer to the same or like parts.

In the interest of clarity not all of the routine features of the implementations described herein are shown and described. It will of course be appreciated that in the development of any such actual implementation numerous implementation specific decisions must be made in order to achieve the developer s specific goals such as compliance with application and business related constraints and that these specific goals will vary from one implementation to another and from one developer to another. Moreover it will be appreciated that such a development effort might be complex and time consuming but would nevertheless be a routine undertaking of engineering for those of ordinary skill in the art having the benefit of this disclosure.

In accordance with the present invention the components process steps and or data structures may be implemented using various types of operating systems computing platforms computer programs and or general purpose machines. In addition those of ordinary skill in the art will recognize that devices of a less general purpose nature such as hardwired devices field programmable gate arrays FPGAs application specific integrated circuits ASICs or the like may also be used without departing from the scope and spirit of the inventive concepts disclosed herein.

For purposes of this disclosure a structured data file is any file containing content as well as some information regarding the structural organization of the content. The present invention provides a fast and efficient way of processing structured data by utilizing an intermediate file to store the structural information. The structured data may be processed into a Binary mask Format BMF file which may serve as a starting point for post processing. A tree structure built on top of the BMF file may be constructed very quickly and also takes up less space than a DOM tree. Additionally BMF records may reside entirely in the memory and contain structural information allowing SAX like sequential data access. However while this document will describe advantages that the present invention provides over DOM or SAX one of ordinary skill in the art will recognize that the present invention need not be limited to replacing DOM or SAX and can be expanded to non XML type processing.

The hardware may be designed such that it may quickly match multiple patterns against an incoming data stream. is a block diagram illustrating an apparatus for efficiently processing structured data in accordance with an embodiment of the present invention. A text processor may be the core of the accelerator. It may be composed of multiple Finite State Machines FSMs that process an incoming document in parallel. The output may be the BMF file. It also may set several result registers not pictured . A PCI interface may handle all handshaking between the hardware and a server PCI bus . A memory controller may receive commands from the PCI interface and convert the PCI address to on board memory address space. It also may access the board memory accordingly. Configuration registers may determine the configuration of the text processing pipeline and the organization of the memory controller . It may load default values from configuration ROM . Some of the values may be modified by software through the PCI interface . The Configuration ROM may store the default setting of the text processor configuration. It also may store the configuration map of FPGAs.

A document buffer may store the incoming document. This may be a Synchronous Dynamic Random Access Memory SDRAM . Paging may be utilized if the incoming document is larger than the total buffer size. A BMF buffer may store the output BMF files together with several other text processor result register values. This may be a separate SDRAM although in one embodiment of the present invention it may share a single SDRAM with the document buffer. A string cache may buffer the incoming data to smooth out and speed up SDRAM access. A DMA engine may grab the frame data from server main memory and send it back the BMF file.

The PCI target may sense a valid window to send data. Then the PCI master may assert the frame number to indicate the beginning of a read transaction . The PCI target holds the bus. The DMA engine may then transfer the BMF and result register data to main memory . When all the data is transferred the PCI target interface may send an end signal to the device driver . The next document processing cycle may start again with a start signal from the device driver .

The output of the hardware is a BMF. In one embodiment of the present invention the BMF defines a binary record format that is used to describe various fields in a structured data file. It can be viewed as a two dimensional field of bits. Each piece of useful information in the structured data file may correspond to a record in the BMF file. A record may comprise a starting offset and length of a target string in the structured data file. It may also comprise the depth value node type and bit wide flags. These will be discussed in more detail below. The total length of a record may be an integer multiple of a 32 bit word the width of the memory bus in most commercial architectures. Two record types may be defined a full version of 12 bytes in length and a compressed version of 8 bytes in length. The full version may be based on the assumption that both the string length and the starting offset are 32 bits wide whereas the compressed version may assume a 16 bit field which translates to a maximum length of 65536 bytes.

There are at least three types of possible BMF file modes read only mode read modify mode and read modify add mode. In read only mode records representing various types of nodes may be placed sequentially into a BMF file leaving no empty records. For example a leaf level element may be represented as a record for the starting tag records one of r property name and one property value for n properties and one record for the text for the element and finally one record for an ending tag name. The presence of the ending tag record may be used for document validation.

The read modify mode may be identical to read only mode except each record allows for limited write access meaning content can be altered but not added.

The read modify add mode allows complete write access which is done by embedding empty records into the file.

The record format may be picked to efficiently represent the necessary information of the original data structure. It may also be made less efficient on purpose to speed up downstream processing.

A modification indicator may also be provided which indicates whether or not the record has been modified. This is important because as described above if the record has been modified then the offset field will contain the real pointer value not a relative offset. An insertion indicator may indicate that data was inserted in between two existing records. Once again this is important in determining how to utilize the offset field. If the insertion indicator is set to 1 it indicates that the offset field contains a pointer to an external piece of memory one that can be used to add child nodes to the current node. An end of document indicator may indicate whether the tag is the last one in the document. This can be important because in some embodiments ending tags may be ignored when encoding the BMF file in order to save space. Therefore the last tag in the BMF file may not correspond to the last tag in the structured data file.

A current record in use field may be used to indicate that a record has been deleted. If the field is set to 0 the record may be safely ignored because it has been deleted. A name space indicator may indicate whether or not there is a name space within the token which may be represented by an sign . A reference bit may indicate when there is an external reference such as an in a text string.

There may be one or more reserved bits which are set aside for future uses. Lastly a length field may indicate the length of the content.

The BMF file together with the original data in memory completely describes the original data and its inherent data structure. Traversing the data structure may be easily accomplished using the BMF records. Higher level applications and processing are therefore facilitated by using the BMF. To make it easily accessible and readily integrated to higher level application and processing device drivers and an application programming interface API may be built on top of the BMF.

At a modification indicator for the piece of content may be stored in the BMF record the modification indicator indicating if the BMF record has been modified and the modification indicator initially set to indicate that no modification has been made. At an insertion indicator for the piece of content may be stored in the BMF record the insertion indicator indicating if the BMF record has been inserted between two existing BMF records and the insertion indicator initially set to indicate that the BMF record has not been inserted between two existing BMF records. At an end of document indicator for the piece of content may be stored in the BMF record the end of document indicator indicating if the BMF record corresponds to a last piece of content in the structured data file. At a current record in use field may be stored for the piece of content in the BMF record the current record in use field indicating whether the piece of content has been deleted.

The following example may be used to illustrate an embodiment of the present invention. One of ordinary skill in the art will recognize that this is merely an example and should not be read to be limiting in any way. Suppose an XML file as follows 

Currently DOM a W3C standard is well defined and the most widely used representation of XML s inherent hierarchy. DOM represents an XML document as a tree structure with the elements attributes and text defined as nodes. A node may have a single parent node sibling nodes and child nodes. For example consider the following XML snippet 

The node named B has a parent node named A. It also has two child nodes respectively named C and C. The C node is the first child node as it appears before the C node in the XML text. The B node also has sibling nodes named text B and B respectively. The text node named Text is the previous sibling of the node B. The B is the next sibling for B node as it appears before B node. By the same token the B node is the next sibling node for B node. Also the first and only child of the C node is a text node named text. 

DOM treats attribute nodes differently. In the XML snippet shown above the B node doesn t treat its attribute named attrName as its child.

Many DOM node types have their equivalent BMF types. For example an element type in DOM corresponds to the starting tag. DOM however does not have a node type corresponding to BMF s ending tag type.

Since a BMF file completely describes the inherent structure in the data file as one can navigate the document by scanning across of BMF records and keeping track of their token types. And they don t need any additional descriptors to identify its siblings children or parent. The inclusion of ending tag as a type is important. DOM resorts to various pointers and complex data structures to maintain the hierarchical information of XML and does not have a node type corresponding to ending tag. SAX returns ending tags of XML but discards them by default. In contrast a BMF file maintains the ending tag in memory as a record so the structure information of an XML file is unambiguous. Consider the following examples 

Without ending tags it will be difficult to determine whether b is the sibling or child of b. With ending tags one can clearly tell the relationship between b and b in the above examples.

To tell whether b is a sibling or child of b one can calculate the depth value of each tags. In example 1 b and b both have the same depth value so they are siblings. In example 2 b and b have depth value of 1 and 2 respectively so b is the child of b.

In some cases it would be beneficial to have some additional way to speed up the traversal of document structure. For example a BMF record can contain a 32 bit descriptor which contains the reference in various forms such as the relative index value absolute index value or memory address of the next sibling or first child but not both as there is additional storage overhead for having such descriptors.

The reference to the next sibling makes it possible to jump to the next sibling without scanning the BMF records between the current record and its next sibling. The reference to the first child record makes it possible to jump to the first child without scanning the BMF records between the current record and first child record. Some of the other possible references a BMF record can have are parent root previous sibling last child. It should be noted that the reference to a child node is actually a reference to a record corresponding to the child node as the nodes are represented in the intermediate file as records. Likewise the reference to a next sibling node is actually a reference to a record corresponding to the next sibling node.

When a record does not have a sibling it is convenient to use some constant value to denote the absence of the sibling. That constant value can be thought of as a special reference value. For example a constant value of zero at the descriptor field could be interpreted as there is not sibling or child depending on the actual usage of the descriptor.

One of ordinary skill in the art will recognize that the processes described herein can also be embodied in a program storage device tangibly embodying a set of computer instructions to perform the processes. Examples of such program storage devices include floppy disks hard drives and CD ROMs.

While embodiments and applications of this invention have been shown and described it would be apparent to those skilled in the art having the benefit of this disclosure that many more modifications than mentioned above are possible without departing from the inventive concepts herein. The invention therefore is not to be restricted except in the spirit of the appended claims.

