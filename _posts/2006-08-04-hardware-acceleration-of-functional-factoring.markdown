---

title: Hardware acceleration of functional factoring
abstract: A hardware accelerator factors functions during the compilation of a user design. The hardware accelerator includes cofactor units, each adapted to determine a cofactor of a function in response to a specified factorization and a set of input values. The factorization specifies the constant function inputs and varying function inputs. Each cofactor unit determines the cofactor of the function in response to a different constant value. The hardware accelerator operates all of the cofactor units simultaneously to determine some or all of the cofactors of a function for a factorization in parallel. Signature generators determine attributes of the cofactors. A signature analyzer uses these attributes to identify identical cofactors, constant cofactors, and inverse cofactors. The signature analyzer returns potentially optimal factorizations to compilation software applications for possible incorporation into user designs. The hardware accelerator may be implemented using a programmable device, such as the FPGA or other programmable device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07640528&OS=07640528&RS=07640528
owner: Altera Corporation
number: 07640528
owner_city: San Jose
owner_country: US
publication_date: 20060804
---
The present invention relates to the field of programmable devices and the systems and methods for programming the same. Programmable devices such as FPGAs typically includes thousands of programmable logic cells that use combinations of logic gates and or look up tables to perform a logic operation. Programmable devices also include a number of functional blocks having specialized logic devices adapted to specific logic operations such as adders multiply and accumulate circuits phase locked loops and one or more embedded memory array blocks. The logic cells and functional blocks are interconnected with a configurable switching circuit. The configurable switching circuit selectively routes connections between the logic cells and functional blocks. By configuring the combination of logic cells functional blocks and the switching circuit a programmable device can be adapted to perform virtually any type of information processing function.

The process of determining the configuration of a programmable device from a user specified design is referred to as compilation. Typical compilation processes start with an extraction phase followed by a logic synthesis phase a clustering and placement phase a routing phase and an assembly phase. The extraction phase takes a user design typically expressed as a netlist in a hardware description language such as Verilog or VHDL and produces a set of logic gates implementing the user design. In the logic synthesis phase the set of logic gates is permuted over the hardware architecture of the programmable device in order to match elements of the user design with corresponding portions of the programmable device.

Compilation software applications often must optimize a user design to match the architectural characteristics of the programmable device. These optimizations often change portions of the user design into functionally equivalent circuits that are better suited for implementation by the programmable device. Compilation software applications may also optimize the user design to increase the operating speed decrease the number of logic gates and other hardware resources required by the design and or decrease the power consumption.

For example a logic cell of a programmable device may have a predetermined number of inputs. This allows the logic cell to potentially implement a Boolean function having up to that number of inputs. For a function with more inputs than are available in a single logic cell the function must be split into sub functions implemented by multiple logic cells. There are numerous techniques for manipulating designs to match hardware architectures and optimize performance.

Functional factoring is one approach to manipulating functions in designs to match hardware architectures and optimize performance. Functional factoring manipulates a truth table or binary decision diagram BDD representing a function to re express the function as a combination of smaller functions.

Functional factoring is often extremely time consuming with complex functions taking days or even weeks of computational time to solve. Part of the reason for this is that functional factoring must separately analyze every possible factorization of a function to determine an optimal factorization of the function. Thus as the number of function inputs increase the number of possible factorizations considered increases exponentially. Additionally complex functions often have a truth table or BDD representation too large to fit into most conventional processor caches. Because of this functional factoring algorithms often incur frequent cache misses as they access a function s truth table or BDD further increasing computation time.

Moreover functional factoring algorithms typically factor one function at a time. In some cases an optimal factorization of a first function may be adversely impact the factorization of a second related function. Conversely sub optimal factorizations of two or more separate functions may be optimal for the entire design due to the ability to share one or more sub functions between the functions. Prior functional factoring algorithms cannot find an optimal factorization of the combination of two or more functions.

It is therefore desirable for a system and method to perform functional factoring in substantially less time than prior techniques. It is also desirable for the system and method to enable optimal factorization of the combination of two or more functions. It is further desirable for the system and method to be implemented with little or no additional cost over typical design development systems.

An embodiment of the invention uses a hardware accelerator to perform function factoring during the compilation of a user design. The hardware accelerator includes a number of cofactor units. Each cofactor unit includes logic for determining a cofactor of a function in response to a specified factorization and a set of input values. The factorization specifies which function inputs are held to a constant value and which function inputs can vary. Each cofactor unit determines the cofactor of the function in response to a different constant value. In an embodiment the number of cofactor units is greater than or equal to the total possible number of different cofactors of the function for a factorization. This allows the hardware accelerator to determine all of the cofactors of a function for a specified factorization in parallel.

In an embodiment each cofactor unit further includes a signature generator for determining one or more attributes of a cofactor. These attributes are used by a signature analyzer to identify sets of two or more identical cofactors to identify cofactors that are constant and to identify cofactors that are the inverse of other cofactors. The signature analyzer compares the attributes of cofactors for a factorization against one or more criteria to determine if the factorization is potentially optimal. Potentially optimal factorizations are returned to compilation software applications for possible incorporation into user designs. The hardware accelerator may repeat this analyze for some or all of the possible factorizations of the function.

In an embodiment the hardware accelerator is implemented using a programmable device such as the FPGA or other programmable device included in many programmable device development kits. Thus a user developing a design for a programmable device may use their programmable device development kit as an accelerator for compilation at no additional cost. In other applications a dedicated hardware accelerator implemented as an ASIC or on a programmable device may be connected with the user s computer as an expansion card in the computer s expansion card slot or as a processor card adapted to interface with a processor slot or socket.

An embodiment of the invention uses a hardware accelerator to perform function factoring during the compilation of a user design. In an embodiment the hardware accelerator is implemented using a programmable device such as the FPGA or other programmable device included in many programmable device development kits. Thus a user developing a design for a programmable device may use their programmable device development kit as an accelerator for compilation at no additional cost. In other applications a dedicated hardware accelerator implemented as an ASIC or on a programmable device may be connected with the user s computer as an expansion card in the computer s expansion card slot or as a processor card adapted to interface with a processor slot or socket.

Function factoring accelerator system includes a set of cofactor units such as cofactor units and . In an embodiment the set of cofactor units includes a total of at least 2cofactor units. Each of the set of cofactor units is adapted to evaluate a factorization of the function for a cofactor of the function. A cofactor is the portion of a function s truth table or BDD that remains when one or more inputs are set to a constant value. In this embodiment a N input sub function is factored from the given M input function. As the N input sub function has 2possible input values there are 2possible cofactors for each N input factorization of the function. By including 2cofactors units in the set of cofactor units the function factoring accelerator system can evaluate all of the cofactors of each factorization of the function in parallel.

In an alternate embodiment the set of cofactor units includes less than 2cofactor units. In this embodiment some cofactors of each factorization of the function can be evaluated sequentially.

Each of the set of cofactor units includes a constant unit such as constant unit in cofactor unit . The constant units outputs a constant value corresponding with the value of one of the cofactors of a function. For example constant unit outputs a value in binary of 0 constant unit outputs a value of 1 constant unit outputs a value of 2 constant unit outputs a value of 3 constant unit outputs a value of 4 and constant unit outputs a value of 2 1. In this arrangement the 2constant units output all 2cofactor values of a factorization of function. As discussed in detail below the function factoring accelerator will evaluate multiple or all of the possible factorizations of the function however in an embodiment the outputs of the constant units will be unchanged for all factorizations.

Each of the set of cofactor units includes a multiplexer unit such as multiplexer unit in cofactor unit . The outputs of the multiplexer units are connected with function unit such as function unit in cofactor unit . The function unit is adapted to implement the function to be factored. If the function to be factored has M inputs then each of the function units has M inputs as well. Embodiments of the set of multiplexer units may share common portions of their logic circuits across multiple cofactor units to save area and device resources or alternatively each cofactor unit may have its own independent multiplexer unit to reduce path delays.

In an embodiment each of the function units is implemented as a memory storing a truth table representing the function. In an embodiment each of the cofactor units includes a separate memory storing a copy of the function s truth table. In another embodiment two or more of the cofactor units share a memory storing a copy of the function s truth table for example using a multiport memory or by arbitrating memory access requests from multiple cofactor units . In embodiments where system is implemented as programmable device truth tables for functions can be loaded into the function units without the need to reconfigure the programmable device. This allows system to evaluate multiple functions in sequence efficiently.

In another embodiment each of the function units is implemented as a circuit of logic gates logic cells or other programmable logic resources implementing the functionality of the function. In this embodiment the arrangement of logic gates logic cells or other programmable logic resources does not need to be optimized for the programmable device hardware architecture. Typically there are sufficient available programmable logic resources on a programmable device implementing system to allow for inefficient implementations of the function to serve as the function units . Embodiments implementing function units as a circuit of logic gates or equivalent programmable device resources are useful for functions too large to fit in the memory resources of the device implementing system . Additionally this embodiment is useful when the truth table or BDD representation of the function is not known or is difficult to derive. This embodiment may also be efficient to implement on programmable devices that allow for partial reconfiguration.

Each of the cofactor units is adapted to evaluate all of the output values of a factorization of a function for a given cofactor value. To this end each of the cofactor units iterates through all of the possible input values of the function with the cofactor inputs held constant and analyzes the resulting output values of its function unit . A input value counter is adapted to enumerate all of the values of the non constant inputs of the function. The input value counter is connected in parallel to inputs of the multiplexer units of each of the cofactor units .

Additional inputs of each of the multiplexer units are connected to the outputs of the corresponding constant unit . For example in cofactor unit N constant unit outputs and M N input value counter outputs are connected to the inputs of multiplexer unit . Multiplexer unit thus has a total of M outputs connected with the M inputs of the function unit .

The multiplexer units are adapted to rearrange the constant unit and input counter outputs to connected with different inputs of the function units thus representing all of the possible factorizations of the M input function into a combination of a N input and a M N input sub functions. Typically if the function to be factored has M inputs and one of the sub functions has N inputs then there will be M choose N which is defined as

The sets of assignments of input counter unit outputs and constant unit outputs to function unit inputs each of which specifies a factorization of the function are determined by input mask generator . Input mask generator controls the multiplexer units . In an embodiment input mask generator is connected in parallel with the control inputs of each of the multiplexer units so that each of the multiplexer units has the same settings.

In an embodiment the input mask generator is implemented as a counter and state machine. The input mask generator generates a set of all possible input mask values with each input mask value having a specified number of activated multiplexer unit inputs. For example the input mask generator may create a set of input mask values with three activated multiplexer inputs set to 1 in this example . An example set could include input mask values 00111 01011 01101 01110 10010 and 10101. The number of activated multiplexer unit inputs is based how many inputs are being factored out of the given function. Input mask generator can be implemented using any type of state machine or counter configuration capable of generating in any order all of the possible input mask values having the specified number of activated multiplexer unit inputs.

In each cofactor unit in response to the sequence of input values provided by the input value counter and its associated constant unit the cofactor unit s function unit outputs a sequence of values representing the portion of the function s truth table remaining when some of the function inputs are held to a constant value. This sequence of values is input into signature generator unit . Each of the cofactor units includes a signature generator . For example the outputs of function unit in cofactor unit are fed to signature generator

Signature generators determine the characteristics of the output of its associated function unit for each factorization analyzed. In an embodiment signature generators determine a signature checksum hash or other abbreviated representation of the output of the function unit for a factorization. The signatures from each of the signature generators are output to the signature analyzer .

Signature analyzer compares the signatures from different cofactors units to determine the number of unique cofactors for a given factorization of the function. If two or more signatures match it is very likely that the corresponding cofactors are identical. Factorizations with fewer unique cofactors typically require less logic resources to implement as the same logic resources can be reused to represent multiple cofactors. Thus the factorizations with the fewest unique cofactors are typically the best and should be used to implement the function.

In an alternate embodiment if the output of the function unit is relatively small for example when factoring a function with few inputs the signature generators can bypass the determination of the signature and provide the function unit outputs directly to the signature analyzer .

In further embodiments signature generators determine additional characteristics of the output of its associated function unit for each factorization. A signature unit may determine if the cofactor output by an associated function unit is constant such as always zero or one. In this embodiment each of the signature units may output flag values or other indicators to signature analyzer when its cofactor is a constant. In a further embodiment signature units could be configured to detect independent input signals.

In an additional embodiment signature generators may also compare the value of its cofactor with the corresponding values of the other cofactors. In this embodiment each of the signature units may determine if its cofactor is the inverse of one or more other cofactors. In an embodiment this determination can be made using a simple state machine. As a first one of the signature units receives each bit of its cofactor in sequence it compares this value with the values received by the other signature units . If the value received by the first one of the signature units ever matches one or more of the values received by the other signature units then these matching cofactors are eliminated as a possible inverse of the cofactor. After all of the cofactor values have been received by the signature units each of the signature units may output flag values or other indicators to signature analyzer when its cofactor is an inverse of another cofactor.

For example signature units and are connected together via data connections and . Signature unit compares the values it receives with corresponding values received by the other signature units. If the value received by signature unit ever matches the corresponding value received by signature unit then the cofactor produced by cofactor unit is eliminated as a possible inverse of the cofactor produced by cofactor unit . This comparison is repeated for the other signature units. After all of the values of a cofactor are analyzed any cofactor units not eliminated from consideration are inverses of the cofactor of cofactor unit

An embodiment of the signature analyzer may use some or all of these attributes to identify optimal factorizations of the function. In an embodiment the signature analyzer compares the attributes received from signature generators with one or more criteria to determine whether the factorization may be optimal. Example criteria can include a maximum number of unique cofactors a minimum number of constant and or inverted cofactors as well as other attributes such as the relationships between different matching cofactors. The relationships between different matching cofactors may be considered to account for limitations or specific capabilities of the programmable device or other hardware architecture intended to implement the user design. In a further embodiment the signature analyzer could store the attributes of a factorization identified as potentially optimal. The signature analyzer can then compare these stored attributes with attributes of subsequent factorizations. For example this can be used to only return information on subsequent factorizations having attributes that meet or exceed that of a previously stored factorization.

In another embodiment all or a portion of the signature analyzer can be implemented in software executed by the device or on a user s computer system. Although this may reduce performance and increase communications bandwidth requirements it decreases the area and device resources required for the signature analyzer .

If the attributes of a factorization meet or exceed the criteria specified by the signature analyzer the signature analyzer indicates to the control and I O unit that a possible optimal factorization has been found. In response the control and I O unit outputs from the system information identifying this factorization. In an embodiment this information can include the input mask value provided by the input mask generator which represents the factorization. In an additional embodiment the control and I O unit may also output attributes provided by the signature generators and signature analyzer such as signatures of cofactors the number and or location of unique constant and or inverted cofactors.

In a further embodiment the control and I O unit also handles the initialization of system such as receiving functions in the form of truth tables or BDDs and loading this representation into function units resetting the input value counter and input mask generator and other initialization tasks.

Following the initialization of system input mask generator outputs a first input mask value to the set of multiplexer units thereby specifying a factorization of the function. For each input mask value the input value counter outputs a sequence of all possible function input values for the non constant inputs of the function. In response to this sequence of function input values and each of the cofactor units associated constant values each of function units outputs the corresponding cofactor or the sequence of function output values resulting when some of the function inputs are held to a constant value. The signature generators determine attributes of each of the cofactors output by the function units and the signature analyzer then evaluates these attributes of the cofactors to determine if the specified factorization is potentially optimal. Following this evaluation the input mask generator may specify a different factorization the input value counter is reset and the evaluation is repeated.

Because an embodiment of system generates and evaluates all of the cofactors of a factorization of a function in parallel the amount of time required for factorization is greatly reduced. For example if the cofactor units can evaluate one set of input values every clock cycle then a M input function factored by a N input sub function can evaluate all of the cofactors of a factorization in approximately 2clock cycles. Further all possible factorizations of the M input function factored by a N input sub function can be evaluated in approximately 2 M choose N clock cycles excluding any clock cycles possibly required for overhead such as configuring a programmable device to implement system loading one or more functions into the system analyzing attributes in signature analyzer and or communicating the results of the analysis to the user s computer system or compilation software. Typical implementations of system on low cost programmable device hardware can operate at 100 Mhz or more enabling optimal factorings of functions of 12 inputs to be found in a few milliseconds including overhead time. This is often a thousand or more times faster than prior factorization techniques implemented on general purpose computers operating at gigahertz speeds.

In further embodiments system can be applied recursively to functions to evaluate more complex factorizations. In an additional embodiment system can be used to accelerate Boolean satisfiability solvers. In this embodiment the function units implement a Boolean satisfiability function representing the constraints often referred to as clauses of a particular problem. The function units may be implemented as logic circuits or lookup tables as described above. In this embodiment the signature generators are adapted to identify the number and locations of 1 values in the outputs of the function units. These 1 values correspond with input values consistent with the Boolean satisfiability function.

The inputs of function unit are connected with a multiplexer unit . The multiplexer unit includes four inputs . Inputs and are connected with two outputs of an input counter unit similar to that described above. These counter outputs labeled C and C will provide a sequence of all possible input values which in this example is the set of values in binary of 0 1 2 and 3. Inputs and are connected with the outputs of a constant unit similar to that described above. The constant unit outputs labeled K and K will remain fixed at a constant value. Each cofactor unit operating in parallel will have a constant unit outputting a different constant value.

Multiplexer unit can connect its inputs to the function unit inputs in any permutation. By rearranging the mapping of constant and counter unit outputs to function unit inputs the function F is factored by different sub functions. As discussed above the multiplexer unit settings are controlled by the input mask generator. In factorization the counter outputs and are connected with function unit inputs and representing function inputs A and B and the constant unit outputs and are connected with the function inputs and representing function inputs C and D. This configuration of multiplexer unit corresponds to factoring a sub function with inputs C and D from function F.

With the multiplexer units holding inputs C and D of each cofactor unit s function unit to its respective constant value an input counter unit supplies a sequence of all possible input values of input variables A and B to multiplexer unit inputs . In response to the sequence of values of A and B and the constant values of C and D each of the function units outputs one of the cofactors of the function F. For example function unit outputs cofactor of function F which corresponds to rows of the truth table in where inputs C and D are set to 00.

Similarly cofactor corresponds to rows of truth table cofactor corresponds with rows of truth table and cofactor corresponds with rows of truth table .

In this example signature generators output a signature of the cofactor attributes specifying if the cofactor is a constant zero or one and an attribute indicating if the cofactor is an inverse of another cofactor. For example based on cofactor signature generator outputs data including a first signature value indicators and specifying that cofactor is constant zero for this factorization and indicator specifying that cofactor is not the inverse of any of the other cofactors 

Similarly signature generators and output data and respectively. Data include signature values . In this example signature values are all equal.

The data output by all of the cofactors units is received by signature analyzer . Signature analyzer compares the signature values from each of the signature generators to identify the number of unique cofactors. In this example because signature values are all equal it is highly likely barring a hash collision that cofactors and are equal. Thus signature generator determines that there are only two unique cofactors. If the number of unique cofactors or other cofactor attributes such as the number of constant or inverted cofactors satisfies the criteria of the signature analyzer signature analyzer outputs information identifying this factorization such as the number of unique cofactors and the input mask values specifying the factorization. This information is then used by the compilation software application to optimize the user s design.

In system the set of cofactor units is partitioned into at least two portions portions and . In portion the function units of the cofactor units implement a first function function F. In portion the function units of the cofactor units implement a second function function G. The cofactor units and of portions and operate simultaneously and in parallel. This enables system to evaluate cofactors of functions F and G simultaneously. In an embodiment signature analyzer evaluates the signatures associated with the cofactors of function F and G both separately and together. This allows system to determine if a factorization of F and G is optimal for both functions. For example from the signatures from the cofactors units of portions and signature analyzer may determine that some cofactors of function F are equal to some cofactors of function G. As a result this factorization of functions F and G may be able to share logic increasing performance and reducing the resources required for the user s design.

Synthesis phase converts the register transfer layer description of the user design into a set of logic gates. Technology mapping phase subdivides the set of logic gates into a set of atoms which are groups of logic gates matching the capabilities of the logic cells or other functional blocks of the programmable device. A given user design may be converted into any number of different sets of atoms depending upon the underlying hardware of the programmable device used to implement the user design. For other types of devices technology mapping phase and the cluster phase discussed below may be omitted or replaced with other compilation phases specific to the type of device.

As discussed above an embodiment of the function factoring accelerator is used by a synthesis phase and or technology mapping phase to optimize portions of the design. In an embodiment the accelerator system is initialized in phase . If the accelerator is implemented using a programmable device phase loads a programmable device configuration into the programmable device to implement the accelerator system.

Typically it may take several minutes to optionally prepare and load a programmable device configuration into a programmable device. Thus in an embodiment phase is initiated prior to phases and and is performed in parallel with extraction phase . In this embodiment it is desirable if possible to complete phase prior to phases and or so that the compilation process does not stall while waiting for the programmable device to be configured to serve as an accelerator system. In applications where the function units of the accelerator are implemented as lookup tables the programmable device needs to be loaded with configuration data only one time to evaluate multiple functions.

In other embodiments phase is during phases and . If the function units are implemented as logic circuits on a programmable device then configuration data representing these function units must be generated by phases and or when functions in need of factorization are identified. In this embodiment all or part of the configuration data representing the accelerator system or at least the function units of the accelerator system must be loaded into the programmable device each time a new function is to be analyzed.

During phases and functions representing portions of the user s design are generated. Functions in need of optimization via factoring are loaded from the user s computer system into the accelerator system. In phase all or a portion of the possible factorizations of these functions are evaluated by the accelerator system as described above. Information on factorizations that are promising based on the criteria specified in the signature analyzer of the accelerator system are then transferred back to the user s computer system. The transfer of functions and data between the user s computer system and the accelerator system is facilitated by an application programming interface.

Following phase phase verifies the validity of the factorizations of the identified by the accelerator system in phase . In an embodiment phase is performed by the user s computer system. Typically phase identifies only a small portion of function s possible factorizations as promising. Thus phase requires very little time to perform. Function factorizations passing the verification phase are then used by phases and to optimize the synthesis and technology mapping of the user s design.

Following the technology mapping phase the cluster phase groups related atoms together into clusters. The placement phase assigns clusters of atoms to locations on the programmable device. The route phase determines the configuration of the configurable switching circuit of the programmable device used to connect the atoms implementing the user design.

The delay annotator phase determines the signal delays for the set of atoms and their associated connections in the configurable switching circuit using a timing model of the programmable device. The timing analysis phase determines the maximum operating speed of the programmable device when implementing the user design for example by determining the portions of the user design have the largest signal delay.

The assembler phase generates a set of configuration information specifying the configuration of the programmable device implementing the user design including the configuration of each of the logic cells used to implement the user design and the configuration of the configurable switching circuit used to connect the logic cells. The assembler phase can write the configuration information to a configuration file which can then be used to configure one or more programmable devices to implement instances of the user design.

In addition to logic cells arranged in LABs programmable device also include specialized functional blocks such as multiply and accumulate block MAC and random access memory block RAM . For clarity the portion of the programmable device shown in only includes a small number of logic cells LABs and functional blocks. Typical programmable devices will include thousands or tens of thousands of these elements.

An embodiments of computer include an I O interface adapted to handle input output and communications with a programmable device development system . Example interfaces can include standard wired or wireless communications interfaces such as USB firewire and Bluetooth interfaces as well as interfaces specialized for electronic system development and testing such as JTAG and SPI.

Programmable device development system includes a programmable device such as an FPGA as described above. Programmable device development system may also include additional supporting hardware such as I O and or programming interfaces for the programmable device and volatile or non volatile memory for storing configuration information for the programmable device .

Embodiments of the invention in conjunction with computer system are well suited for applications in which the user design is also intended for a programmable device or structured ASIC. For these applications the user will often already have a programmable device development kit which allows embodiments of the invention to be implemented with no additional hardware or expenses. Alternatively users may elect to acquire a programmable device development kit solely for the purpose of accelerating factorization using embodiments of the invention for any type of digital device design.

Computer typically includes components such as one or more general purpose processors and memory storage devices such as a random access memory RAM disk drives and system bus interconnecting the above components. RAM and disk drive are examples of tangible media for storage of data audio video files computer programs applet interpreters or compilers virtual machines and embodiments of the herein described invention. Other types of tangible media include floppy disks removable hard disks optical storage media such as DVD ROM CD ROM and bar codes non volatile memory devices such as flash memories read only memories ROMS battery backed volatile memories and networked storage devices.

An embodiments of computer include a programmable device hardware interface adapted to handle input output and communications with a programmable device development system . Interface may be an internal or external interface to computer . Example interfaces can include standard wired or wireless external communications interfaces such as USB firewire and Bluetooth interfaces internal interfaces such as PCI PCI E and PCI X dedicated microprocessor interfaces as well as interfaces specialized for electronic systems applications development and testing such as JTAG and SPI.

Programmable device hardware interface includes a programmable device such as an FPGA as described above. Programmable device hardware interface may also include additional supporting hardware such as I O and or programming interfaces for the programmable device and volatile or non volatile memory for storing configuration information for the programmable device .

Embodiments of the invention in conjunction with computer system may be used for applications in which the user design is intended for a programmable device or structured ASIC as well as for any other general digital device design.

Further embodiments can be envisioned to one of ordinary skill in the art after reading the attached documents. For example although the invention has been discussed with reference to programmable devices it is equally applicable to logic minimization applications used to design any type of digital device such as standard or structured ASICs gate arrays and general digital logic devices. In other embodiments combinations or sub combinations of the above disclosed invention can be advantageously made. The block diagrams of the architecture and flow charts are grouped for ease of understanding. However it should be understood that combinations of blocks additions of new blocks re arrangement of blocks and the like are contemplated in alternative embodiments of the present invention.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

