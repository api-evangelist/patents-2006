---

title: Type bridges
abstract: Methods, systems, and computer program products for converting an object of one type to an object of another type that allow for the runtime operation of the conversion process to be altered or customized. The conversion may occur within an extensible serialization engine that serializes, deserializes, and transforms objects of various types. The runtime operation of the serialization engine is altered by one or more extension routines that implement the desired customizations or extensions, without requiring replacement of other existing routines. Based on type information, identified for an initial object, the object is converted to an intermediate representation which permits runtime modification, including modification of object names, object types, and object data. The intermediate representation of the initial object is modified in accordance with extension routines that alter the runtime operation of the serialization engine, and the intermediate representation is converted to a final object and type.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07624400&OS=07624400&RS=07624400
owner: Microsoft Corporation
number: 07624400
owner_city: Redmond
owner_country: US
publication_date: 20061205
---
This application is a continuation of U.S. application Ser. No. 10 401 244 filed Mar. 26 2003 and entitled TYPE BRIDGES now U.S. Pat. No. 7 197 512. The foregoing application is incorporated herein by reference.

The present invention relates to object serialization. More particularly the present invention relates to methods systems and computer program products for transforming objects of one type to objects of another type through extension routines that alter the runtime operation of a serialization engine without having to replace other existing routines within the serialization engine.

In a general sense serialization is the conversion of single or graph of nested in memory objects into a linear sequence of bytes suitable for transmission to a remote location persistence on disk etc. Conversely deserialization takes the linear sequence of bytes and creates the corresponding single or graph of in memory objects. Together serialization and deserialization typically result in the creation of an exact clone of the original object.

Traditionally serialization code has been written as a monolithic implementation with no provision for customization short of replacing the entire implementation. A lack of customization or extensibility imposes an inflexible serialization mechanism on the marketplace including developers and other interested parties. With a monolithic implementation incremental improvements or customizations to address a particular problem directly often are not possible and may require awkward workarounds or simply preclude certain desired operations. Should customization be undertaken in any event standard routines implementing desirable operation typically are not accessible to the developer and therefore need to be re implemented substantially and often prohibitively increasing the effort required to develop the desired customization. As a result new features typically may be added to the serialization code only by the serialization code developers precluding end users from developing their own enhancements or improving upon existing features.

Although an exact copy of an object often is the goal of serialization and deserialization runtime transformations of object types names and data may be desirable in some circumstances. As indicated above for example serialization and deserialization may be used in transmitting an object to a remote location. The remote location may expect certain object types object data and object names that differ from the source object. Traditional serialization code may be written to perform object transformations but the transformation cannot be added at runtime and is the same for all users which ignores the likelihood that different users may have different needs. While a given transform may be extremely important for a particular user at a particular time the overall relevance of the transform may be insignificant to the user base as a whole and therefore never developed.

Traditional serialization code also tends to offer little flexibility in terms of identifying objects to transform or basing transforms on data contained within an object. Accordingly methods systems and computer program products for transforming objects from one type into objects of another type based on customized routines for altering serialization and deserialization at runtime without having to re implement standard routines are desired.

The present invention relates to methods systems and computer program products for converting an object of an initial type to an object of a final type and allows for the runtime operation of the conversion process to be altered or customized. In accordance with example embodiments of the present invention which are described more fully below an extensible serialization engine serializes deserializes and transforms objects of various types. The runtime operation of the serialization engine is altered by one or more extension routines that implement the desired customizations or extensions. These extension routines alter the runtime operation of the serialization engine without requiring replacement of other existing routines.

In one example embodiment type information is identified for an initial object received by the serialization engine for processing. Based on the type information the initial object is converted to an intermediate representation which permits runtime modification including modification of object names object types and object data. The intermediate representation of the initial object is modified in accordance with one or more extension routines which alter the runtime operation of the serialization engine and the intermediate representation is converted to a final object of a final type.

The intermediate representation of the initial object may include an object name an object type and object data each of which may be modified by the extension routines. The intermediate representation also may be modified by one or more standard routines within the serialization engine. Modification of the intermediate representation may be based on a particular pattern within the type information object data within the initial object metadata or combinations of the foregoing.

Where the initial object is an in memory object the serialization engine serializes the initial object to generate the final object. The final object may be formatted in eXtensible Markup Language XML or in some other format suitable for representing a serialized object. Similarly where the final object is an in memory object the serialization engine deserializes the initial object to generate the final object. The final object may be instantiated and populated as part of the deserialization process. In some circumstances both the initial object and final object may be in memory objects or both may be serialized objects such as when the serialization engine performs an object transform. To reduce buffer requirements modification of the intermediate representation may be deferred until the intermediate representation is converted to the final object.

Additional features and advantages of the invention will be set forth in the description which follows and in part will be obvious from the description or may be learned by the practice of the invention. The features and advantages of the invention may be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. These and other features of the present invention will become more fully apparent from the following description and appended claims or may be learned by the practice of the invention as set forth hereinafter.

The present invention extends to methods systems and computer program products for converting objects of an initial type to objects of a final type that and allows for the runtime operation of the conversion process to be altered or customized. The embodiments of the present invention may comprise one or more special purpose and or one or more general purpose computers including various computer hardware as discussed in greater detail below with respect to .

Serialization module includes one or more reflection modules one or more conversion modules and one or more generation modules . In this example embodiment serialization module converts a received in memory object instance to an XML object suitable for transmission to a remote location and converts a received XML object instance to an in memory object instance . Of course in memory and XML are merely examples of object types that may be created or received by serialization module . Each of the modules within serialization module reflection modules conversion modules and generation modules may be replaced at runtime for customized serialization deserialization or transformation.

Reflection modules are responsible for identifying type information for received object instance and received XML object . The type information may comprise stored or received metadata that is associated with managed types within a manage code environment. Alternatively the type information may be supplied to reflection modules from various sources including automated generation at compile time manual generation standard type information etc.

Conversion modules convert between objects of different types. Example conversion processes are described in more detail below with respect to . Conversion between different objects may be arbitrarily complex and include the generation of intermediate objects. Part of this complexity may include conversion based on data within an object and patterns of types associated with an object. For example which conversions are performed may depend on certain object types or type names the existence of a certain named or typed properties on a type the existence of a property with certain meta data attached object names associated with an object etc. Conversion may be deferred until generation of the final object to reduce or avoid buffer requirements that otherwise may be part of converting one object to another.

Generation modules are responsible for generating the final object produced by serialization module . In the case of XML object generation module creates the object it generates the appropriate XML for the object and may write the object to a stream. In the case of object instance generation module instantiates and populates the object.

As indicated above serialization module is also known as a serialization engine. As shown in the serialization engine is composed of several ordered sets of modules. Collectively these modules are responsible for all operations. An individual module is known as a type bridge because as described in greater detail below modules convert from one type to another or bridge between different types . A type bridge allows for type and instance transformation at runtime and or to track information about an object being serialized deserialized or transformed. With reference to an ordered set of type bridges is known as a type bridge pipeline and generally corresponds to an ordered set of conversion modules . For each of the operations performed by the serialization engine a separate type bridge pipeline may exist. There is a pipeline for serialization e.g. deserialization e.g. transformation e.g. object copy etc. Information generally applicable to all three drawing is presented below prior to an individual discussion for each of .

For the example pipelines shown in the code one or more modules that is responsible for serialization deserialization and transformation of objects is implemented as a number of predefined type bridges. These modules are placed in the appropriate pipeline and used at runtime. The dashed squares in are intended to represent available type bridge modules for use in various type bridge pipelines. A large portion of the public application programming interface API for the example serialization engine shown in is simply a wrapper over this predefined set of pipelines. This demonstrates how the serialization engine is extensible the serialization engine is a simple set of abstract pipelines. The actual implementation of specific logic is found in pluggable modules that can be replaced at any time.

For the example type bridge pipelines illustrated in a given type bridge is capable of transforming one of three types of objects an initial type object an intermediate type object and a final type object. In the initial type object is a managed code object and the final type object is an XML object based on the World Wide Web Consortium W3C Infoset standard. The intermediate type object or intermediate representation shown in all three Figures is a construct found within the serialization engine and as described in further detail below represents an extensibility point. The intermediate representation is a mutable object based on a mutable type. As such the mutable type serves to define behavior and typed data storage with the mutable object serving to store typed data and act on the stored data through behavior defined on the type.

Custom extension routine converts intermediate representation A of initial object to intermediate representation B. This conversion may include changing object types object names object data and the like. Custom extension routine represents a runtime extension of the serialization engine in general and type bridge pipeline in particular. Note that using custom extension routine did not require re implementing standard routine as typically is the case with conventional serialization implementations.

Standard routine converts the intermediate representation B to final object of final type or format . Final object is suitable for transmission to a remote location persistence etc. Accordingly the final format of final object includes a wide range of object types. Here as in other portions of the description object type format and representation are broad terms that encompass the overall type and format of the object and type format names and data that may be contained within an object.

Standard routine converts intermediate representation B to final object of final type . Because type bridge pipeline is for deserializing final object is an in memory object that is instantiated and populated. As will be described in more detail below the type bridge pipeline is connected to code for instantiating and populating object instances. This code may be referred to as an instance factory or writer or write factory and corresponds generally to generation modules shown in .

CLR objects are instances of CLR types that contain a combination of data and behavior although only the data is relevant for serialization purposes. As indicated above an Infoset object or representation is formatted according to a W3C standard for a tree structure composed of a predefined set of data nodes with certain semantics. A flex object is a construct found within the serialization engine and represents an extensibility point for the serializer.

A flex object is a mutable object that is based on a mutable type. The mutable type is known as a flex type. In the example type bridge pipeline shown in a flex type serves the same function as its corresponding CLR type defining behavior and type data storage. Similarly a flex object serves the same function as a CLR object storing typed data and acting on this data through behavior defined on the type. The reason for using flex type and flex object is that CLR types are immutable.

For the example type bridge pipeline shown in certain constraints are placed on the types that can be serialized to foster simplicity and extensibility. These constraints reduce the number of different patterns and permutations that the serializer needs to recognize in order to serialize and deserialize a given type. To this end the serialization engine only understands how to serialize CLR objects whose types follow what is known as the core model. Types that conform to the core model must either expose their data as properties or fields or implement a particular interface which defines explicit read and write methods . In addition these types need to provide a public default constructor. Types that do not follow the core model cannot be serialized.

Flex types and flex objects are used to change the shape members interfaces etc. of a given CLR object to conform to the core model. For the given CLR object a flex type can be constructed that exposes a different set of member and type information than the instance s CLR type. A flex object based on the flex type can be instantiated that delegates certain invocations to the CLR object itself. The flex object also can perform optional transformations of the data within the CLR object either prior to or following delegation. As a result data within the CLR object may be exposed in various ways including one that conforms to the core model. Accordingly a type bridge may start with an object type that does not conform to the core model and produce an object type that does.

A type bridge may transform CLR objects flex objects and Infoset representations in a variety of ways. Any given type bridge has an input type which it acts upon and an output type which it produces or generates. This output is passed to the next type bridge in the pipeline. For the example type bridge pipeline the following transforms are permitted 

The different classifications of type bridges are composed to provide the base operation of the serialization engine. Although reference generic types reference to these Figures is made below with the specific types illustrated in to provide further context. 

In order to support the above operations the serialization engine provides stock or base type bridges that perform the appropriate transformations. In any of the standard or custom routines and may be stock type bridges or custom replacements. Using an extensible configuration mechanism the appropriate type bridges are identified and loaded into pipelines at runtime. The serialization engine uses these stock pipelines to perform the requested operation. The stock type bridges however may be replaced at any time as the engine uses a notion of abstract type bridges rather than specific stock implementations. In one example embodiment a pipeline simply comprises a list of type bridges for the pipeline changing the list changes the pipeline. For this example embodiment once a particular type bridge is called for an object no other type bridges are called for that object.

Note that in an example embodiment CLR flex and Infoset correspond to initial format intermediate format and final format for serialization as shown in and correspond to final type intermediate type and initial type for deserialization as shown in . Flex object is the intermediate format between both CLR and Infoset. In this example embodiment a type bridge is not permitted to transform directly from CLR to Infoset or vice versa. Among other things this helps to simplify the example serialization engine. While the base functionality or operation of the serialization engine is defined by stock type bridges there are many additional features such as support for legacy programming models that developers may expect as well. The stock type bridges could have been designed to implement these features but instead there are several stock flex to flex type bridges that serve this purpose. This approach ensures that stock type bridges are simple and extensible. As a result various developers can make modifications to standard features and provide new features of their own.

For this example embodiment consider a serialization process for a CLR type named Person with two properties FirstName and LastName. In order to serialize see an instance of this type a pipeline with stock CLR to flex and flex to Infoset type bridges is needed. The serialization engine passes the Person instance to the CLR to flex type bridge. This type bridge returns a new flex object instance based on and delegating to the Person instance. The flex object is then passed to the flex to Infoset type bridge.

The flex to Infoset type bridge is responsible for transforming or converting the flex object into an Infoset representation. Prior to the conversion the stock flex to Infoset type bridge determines the manner in which to map the structure of the flex object to Infoset. The stock implementation in this example uses a schema language and defines mappings with the constructs defined in the language. Since type bridges are replaceable a new mapping mechanism including support for a new schema language could be introduced which represents another extensibility point within the serialization engine. Once the mapping process is complete the flex object is transformed into an Infoset representation which is written to a stream.

As briefly mentioned above the type bridges within the serialization engine are connected to writer factories. Writer factories are responsible for creation of a resource that is capable of writing data. Although the resource could write data to any target the most common destinations are data streams following serialization for transport and CLR objects following deserialization . The stock writer factory for this example embodiment returns a resource that writes to a user supplied data stream. The resource produced by this factory can write to the stream in any format it desires. As such it is not pinned to the XML serialization format which make the writer factory replaceable and introduces yet another extensibility point within the serialization engine.

Deserialization see for example of the Infoset representation in this example embodiment involves a pipeline that includes the stock Infoset to flex and flex to CLR type bridges. The serialization engine passes a user provided stream representing the source Infoset as well as the CLR type Person that is being deserialized to the first type bridge Infoset to flex . This type bridge creates a new flex object instance based on the Person type that delegates to the stream. The resulting flex object is passed to the flex to CLR type bridge which populates an instance of Person with data from the flex object the flex object is actually in the stream since the flex object is delegating . As with serialization the deserialization pipeline terminates in a writer factory. The stock write factory for the deserialization pipeline is responsible for creating the instance of the CLR type being deserialized.

In addition to serialization and deserialization it may be desirable to transform the Person type. As indicated above the shape of the Person type includes two properties FirstName and LastName. Suppose for example that one application using this definition of Person interacts with another application using a different Person definition e.g. a Person with one property FullName . While one option would be to have both applications use the same Person type this might not always be possible both application may have already been written .

In accordance with the example embodiment being described a type bridge may be created that transforms the shape of a Person instance in one application to the shape expected in the other. To make the transformation see a new flex to flex type bridge e.g. custom extension routine needs to be constructed and placed in the serialization pipeline after the stock CLR to flex type bridge e.g. standard routine . During the serialization process this type bridge is passed a flex object that delegates to the Person instance. The type bridge constructs a new flex type with the different shape single FullName property . Based on this flex type a new flex object is created that concatenates the FirstName and LastName properties found on the original flex object which also delegates to the Person instance . This flex object is passed to the stock flex to Infoset type bridge e.g. standard routine which serializes one property rather than two. It is worth noting that the concatenation may not actually be performed until the flex to Infoset type bridge requests the value of the new FullName property. Accordingly the transformation is deferred until the creation of the Infoset or final object.

Accordingly a serialization engine in accordance with the present invention may offer an extensible architecture for transforming between systems and types including support for pluggable type and data transformations support for mutable types and objects support for pluggable schema type systems support for pluggable data formats etc.

The present invention also may be described in terms of methods comprising functional steps and or non functional acts. The following is a description of acts and steps that may be performed in practicing the present invention. Usually functional steps describe the invention in terms of results that are accomplished whereas non functional acts describe more specific actions for achieving a particular result. Although the functional steps and non functional acts may be described or claimed in a particular order the present invention is not necessarily limited to any particular ordering or combination of acts and or steps.

It should be noted that the intermediate representation may comprise an object name an object type and or object data. Although not shown a step for modifying the intermediate representation also may include acts of calling not shown one or more custom extension routines and calling not shown one or more standard routines to modify the intermediate representation. A step for modifying the intermediate representation may further include an act of changing an object s name type and or data. A step for deferring modification may include an act of specifying how to modify the intermediate representation without actually modifying the intermediate representation. Deferring may help to reduce buffer and processing requirements otherwise associated with modifying the intermediate representation in place.

A step for converting the intermediate representation of the initial object to a final object of a final type or format may include the following acts. When serializing the step may include an act of creating or generating the final object. In one example embodiment as described above the final object is formatted in XML for transport. Creating or generating the final object therefore may include generating the appropriate XML and writing the final object to a stream. Alternatively the final object may be formatted for persistence to disk or in any other format suitable for representing the serialized initial object. When deserializing the step may include acts of instantiating and populating the final object. During the step for converting custom extension and standard routines are invoked for any deferred modifications that indicated how a change should be made but did not actually make the change.

Embodiments within the scope of the present invention also include computer readable media for carrying or having computer executable instructions or data structures stored thereon. Such computer readable media can be any available media that can be accessed by a general purpose or special purpose computer. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disc storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to carry or store desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. When information is transferred or provided over a network or another communications connection either hardwired wireless or a combination of hardwired or wireless to a computer the computer properly views the connection as a computer readable medium. Thus any such connection is properly termed a computer readable medium. Combinations of the above should also be included within the scope of computer readable media. Computer executable instructions comprise for example instructions and data which cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions.

Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations including personal computers hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by local and remote processing devices that are linked either by hardwired links wireless links or by a combination of hardwired or wireless links through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an example system for implementing the invention includes a general purpose computing device in the form of a conventional computer including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help transfer information between elements within the computer such as during start up may be stored in ROM .

The computer may also include a magnetic hard disk drive for reading from and writing to a magnetic hard disk a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disc drive for reading from or writing to removable optical disc such as a CD ROM or other optical media. The magnetic hard disk drive magnetic disk drive and optical disc drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer executable instructions data structures program modules and other data for the computer . Although the exemplary environment described herein employs a magnetic hard disk a removable magnetic disk and a removable optical disc other types of computer readable media for storing data can be used including magnetic cassettes flash memory cards digital versatile discs Bernoulli cartridges RAMs ROMs and the like.

Program code means comprising one or more program modules may be stored on the hard disk magnetic disk optical disc ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer through keyboard pointing device or other input devices not shown such as a microphone joy stick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface coupled to system bus . Alternatively the input devices may be connected by other interfaces such as a parallel port a game port or a universal serial bus USB . A monitor or another display device is also connected to system bus via an interface such as video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers.

The computer may operate in a networked environment using logical connections to one or more remote computers such as remote computers and . Remote computers and may each be another personal computer a server a router a network PC a peer device or other common network node and typically include many or all of the elements described above relative to the computer although only memory storage devices and and their associated application programs and have been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN that are presented here by way of example and not limitation. Such networking environments are commonplace in office wide or enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment the computer may include a modem a wireless link or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing communications over wide area network may be used.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

