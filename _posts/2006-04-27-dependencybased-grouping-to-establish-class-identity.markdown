---

title: Dependency-based grouping to establish class identity
abstract: A method for using dependency-based grouping to establish class identity comprises categorizing a plurality of classes into a set of class groups based at least in part on one or more dependencies between the classes, and generating metadata to be use for loading the classes, where the metadata includes a mapping between the set of class groups and the plurality of classes. The metadata may also include respective signatures for class groups and/or the individual classes. The method may also include validating, using at least a portion of the metadata, the identity of a particular version of a class of the plurality of classes, prior to loading the version for execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07836440&OS=07836440&RS=07836440
owner: Oracle America, Inc.
number: 07836440
owner_city: Redwood City
owner_country: US
publication_date: 20060427
---
The present invention is directed to computer systems. More particularly it is directed to determining the identity of executable objects at run time in computer systems.

Many modern programming languages such as Java provide a simple way to establish the identity of different programming language constructs at compile time in the source code of a Java program for example two classes are identical if they have the same name and differ if they have different names. However the problem of establishing identity may be somewhat more complicated at run time. Several computing platforms such as various versions of the Java platform enable processes to load application and system code at run time from a variety of sources such as a local file system a remote web server or an in memory buffer. More than one class with the same name potentially with significantly different behaviors may be present in the different sources for example two versions of a given Java class may be available one locally and one at a remote source.

In order to distinguish between different classes with the same name at run time class loaders may sometimes be used as name space indicators for the classes. In Java run time environments for example a class loader is responsible for mapping a class name e.g. a string to a loaded class object. A Java class loader is itself an instance of a class which is a subclass of the abstract java.lang.ClassLoader class that provides a method such as loadClass allowing callers to request loading of named classes. The identity of the loaded class at run time in such environments is based on the tuple class name defining class loader that is for two classes to be identical both must have the same class name and both must have the same defining class loader. The defining class loader of a Java class is the particular class loader that passes the definition of a currently unloaded class to the Java Virtual Machine JVM for processing receives an initialized class object from the JVM and returns the class object to the requester. It is noted that the terms JVM virtual machine process virtual machine and process may be used synonymously herein to indicate execution environments at which applications comprising dynamically loadable classes are executed.

Questions of class identity are particularly relevant in distributed programs for example programs that use Java Remote Method Invocation RMI or the Jini networking technology subsequently referred to herein as Jini . Such distributed programs may rely on passing objects between processes where the executable code for a transmitted object may not be preinstalled at the destination. Individual processes at the different nodes of a distributed programming environment may have access to different versions of the class for the same object which may potentially lead to errors and failures that are hard to diagnose and resolve. Consider an example scenario in which a first process P sends an object obj which is an instance of a class C to a second process P intending that a version v of class C be executed for object obj at process P . The run time environment in use in the scenario may not however require that P execute any specific version of class C . If process P has access to a locally available version v of class C it may execute the locally available version which may perform different computations than were expected by process P potentially resulting in errors in the distributed computation being performed by P and P . Since neither P nor P does anything in this scenario that violates any rules the error introduced by the naming ambiguity of different class versions corresponding to obj may be hard to detect and therefore hard to fix. Disambiguating between classes with the same name may thus be even more important in distributed programming environments.

A number of different approaches have been used for establishing class identities at run time. In the standard implementation of Java RMI for example the class loader used to download and define a class is determined by the location or codebase from which the class is downloaded. A process that sends a class to another process is responsible for also sending a codebase annotation e.g. one or more Uniform Resource Locators URLs from which a class is to be downloaded for the class to the receiving process. If different codebases implement different versions of the same class this approach will disambiguate between the versions since each version will have a different defining class loader. Unfortunately however if different codebases implement identical versions of a given class this approach will still treat the versions as distinct which may contribute to one or more of a number of problems. Such problems include for example potential loss of codebase annotation when objects are relayed from one process to another in distributed applications unexpected type conflicts when codebase changes occur e.g. when a hostname or port corresponding to a codebase changes unnecessary memory usage caused by loading multiple identical versions of the same class at a single process etc.

Several enhancements to the standard codebase approach have been proposed. In a technique called preferred classes downloaded applications explicitly specify that a subset of their classes should not be shared with the local platform thus avoiding some of the confusion possible in the standard codebase approach. However this technique requires that a decision be made in advance of application deployment as to which classes should be shared and which classes should be kept separate independent of whether locally available classes are compatible with the downloaded application. Such a technique leaves open the possibility that unexpected versions of classes available locally are used and that applications may fail to share locally available classes compatible with downloaded code. Other approaches such as a technique called content addressable codebases may be sensitive to how classes are packaged within codebases. If two downloaded objects have some classes in common but use codebases that contain different additional classes then the content addressable codebase approach fails to treat the common classes as identical. Traditional techniques for class loading and therefore for class identity disambiguation are often problematic at least partly because they rely in some form on the location of class definitions or the specific contents at each location.

Various embodiments of methods and systems for using dependency based grouping to establish class identity are disclosed. According to one embodiment a method comprises categorizing a plurality of classes into a set of class groups based at least in part on one or more dependencies between the classes e.g. references from one class to another and generating metadata to be used for loading the classes where the metadata includes a mapping between the set of class groups and the plurality of classes. The metadata may also include a variety of signatures or digest values in various embodiments for example a respective group signature for each class group may be included which may in turn be derived from class signatures computed for each class of the class group as well as from group signatures of other class groups referenced by the classes included in the class group. The method may also include validating using at least a portion of the metadata the identity of a particular version of a class of the plurality of classes prior to loading the version for execution. In one embodiment a respective class loader may be identified to load the classes of each class group e.g. if the plurality of classes of an application is categorized into a set of four class groups a total of four class loaders may be created for the application at each execution environment where the application is executed with each class loader responsible for loading the classes of a corresponding class group. The class loader for a particular class group may use a signature included in the metadata to verify the identity of a particular executable version of a class included in the particular class group e.g. by comparing the signature in the metadata with a signature derived from the particular executable version. Since class identity verification using the method is based on metadata derived from the behavior of the classes themselves rather than on external factors such as the location where executable code for the classes may be obtained or developer supplied hints or directives some of the problems experienced with traditional class identity verification mechanisms that are caused by reliance on such external factors may be avoided.

In one embodiment the method may include analyzing executable versions of the plurality of classes to identify dependencies between the classes. In an embodiment where the metadata comprises class signatures for each class the class signature for a particular class may be obtained by providing a representation of the executable version e.g. byte codes of the class as input to a mathematical function such as a hash function with a desired set of mathematical properties and using an output of the mathematical function as the class signature. Signatures for class groups may be obtained using similar mathematical functions in some embodiments where the class signatures for the classes contained in the class group and the group signatures for referenced groups may be used as inputs for the mathematical function. In some embodiments the categorization of the classes into groups may take into consideration the packages to which the classes belong e.g. all the classes of a given package may be placed into a single group. The process of categorizing classes may include merging groups that are involved in circular dependencies in some embodiments.

In one embodiment a system comprises one or more processors and memory coupled to the processors. The memory comprises program instructions executable by the processors to categorize a plurality of classes into a set of class groups based at least in part on one or more dependencies between a class and an other class of the plurality of classes. The instructions may be further executable to generate metadata to be used in loading one or more classes of the plurality of classes for execution wherein the metadata includes a mapping between the set of class groups and the plurality of classes. The instructions may also be executable to generate respective group signatures for the class groups and or respective class signatures for the classes included in the class groups in various embodiments.

In another embodiment a system also comprises one or more processors and memory coupled to the processors. The memory comprises program instructions executable by the processors to receive metadata associated with a plurality of classes wherein the metadata includes a mapping indicative of a categorization of the plurality of classes into a set of class groups based at least in part on one or more dependencies between a class and another class of the plurality of classes. The metadata may also include respective group signatures corresponding to the class groups and or respective class signatures corresponding to the plurality of classes in some embodiments. The program instructions are further executable to validate an identity of a version of a given class of the plurality of classes using at least a portion of the metadata prior to loading the version for execution.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

The class analyzer may be further configured to generate metadata to be used in loading the classes . The metadata may be provided to the class loading mechanism e.g. when an application including the classes is to be executed. Prior to loading a given class the class loading mechanism may be configured to validate an identity of the class using the metadata . In one embodiment for example the metadata may include a mapping between the classes and the class groups i.e. information identifying the class groups and indicating which classes belong to each class group to be used in the process of validating class identity. The metadata may also include signatures or digest values for each of the classes . The terms signature and digest of an entity may be used synonymously herein to refer to the result of a mathematical function such as a hash function selected for specific mathematical properties applied to the entity such that the result for a given entity has a high probability of being different from the result for any other entity. Depending on the specific mathematical function chosen the probability of the signature for a given class being different from the signature for another class may be so high that the signature may serve effectively as a unique identifier for the class. In some embodiments the class loading mechanism may comprise a software program configured to use the metadata to create a set of class loaders such as class loaders CL CL and CL at an application deployment site such as a Java virtual machine where each class loader is responsible for validating and loading classes belonging to a particular class group e.g. in the example scenario of class loader CL corresponds to class group A CL to class group B and CL to class group C . The class loaders may use class signature values included in the metadata to validate class identity. In one embodiment the metadata may also include signatures or digest values for each of the class groups and each of the class loaders may be associated with or identified by the group signature for the corresponding class group .

The class analyzer may be executed at a different execution environment than the class loading mechanism in some embodiments. For example classes of an application may be analyzed and categorized into class groups at a first Java virtual machine JVM and the metadata for the application s classes may be sent to a different JVM where the application is to be executed e.g. over a network connection. Any of a variety of techniques for distributed programming such as techniques based on Java RMI or Jini may be employed in various embodiments for the execution of the application. In some embodiments the metadata may be included or piggybacked within a data object that is already required for the distributed programming technique for example in one implementation the metadata may be stored in a file within a well known directory such as META INF included within a Java Archive JAR file corresponding to the application.

The categorization of classes into groups based on class reference behavior the use of class and or group signatures and the association of a unique class loader with each class group may together result in a robust class disambiguation mechanism that does not rely on class location e.g. as in conventional techniques based on codebases or developer input e.g. developer provided hints or directives designating which classes are not to be shared with a local execution environment . The metadata including the class to group mappings and the signatures may be relayed unchanged from one execution environment to another resulting in the establishment of similar class loader hierarchies at each execution environment where the application is to be executed and avoiding some of the problems of traditional distributed programming techniques such as codebase annotation loss and unexpected type conflicts if codebase changes such as hostname changes or port changes occur.

A simple example of the operation of system in one embodiment in which the Java programming language is employed to implement the classes and in which the classes are arranged into class groups based on their parent packages as well as on their reference behavior is provided below. In the context of the Java programming language the term package refers to a named collection of classes that defines a namespace for the contained classes. The package for each class is typically defined by a package directive in the source code for the class usually in the first non comment non blank line of the source code. For example two source files that each begin with the source code line package com.abc.xyz indicate that each class defined in the two source files belongs to the com.abc.xyz package. The source code of four classes of the simple example includes the following 

In the example classes Main and App belong to package main class Processor belongs to package main.proc and class Utilities belongs to package main.util. In one embodiment class analyzer may be configured to analyze the byte code of the classes i.e. an executable version of each of the classes to determine which classes refer to which other classes. For example a class such as the publicly available com.sun.jini.tool.ClassDep class from release 2.1 of the Jini Technology Starter Kit available from Sun Microsystems may be used to analyze the byte code to identify class dependencies or a program written using the Byte Code Engineering Library BCEL technology available as open source from the Apache Software Foundation may be employed for byte code analysis. In other embodiments analysis may be performed on the source code of the classes instead of or in addition to analysis on byte codes.

The analysis of the classes in the example may indicate the following initial set of dependencies a main.Main i.e. class Main of package main references main.App b main.App references main.proc.Processor c main proc.Processor references main.util.Utilities as well as main.App and d main.util.Utilities does not reference any other class. The reference relationships among the classes may be represented graphically as follows where an arrow leading from a given class to an other class indicates that the given class references the other class 

Note that in the graphical representation a double pointed arrow links main.App to main.proc.Processor since each of these two classes references the other in an example of a circular reference or circular dependency . As used herein the terms circular reference and circular dependency between two entities A and B refers to the fact that entity A depends directly or indirectly on entity B and entity B depends directly or indirectly on entity A. To map classes to groups in the example the class analyzer first creates a group for each package as follows 

The dependency relationships between the groups may be represented as follows using similar notation to that used above for representing class dependencies 

Next the class analyzer may be configured to combine groups involved in circular references into a single group leading to a new group G comprising the elements of G and G 

The class analyzer may generate the metadata for this simple example in the form of a file comprising the following information 

In the exemplary metadata each ResourceGroupSignature line introduces a new class group named using an encoding e.g. a Base64 encoding in which binary data is represented as ASCII characters of the signature of the group while the signature of the group is derived from the signatures of the classes contained in the group and the signatures of the groups referenced by the group. Each Name entry in the metadata names a class in the group followed by the signature of the class which may for example be computed as a hash value from the byte code of the class. Each ReferencedGroupSignature line specifies another group referenced by the current group where the referenced group is identified by its signature. Since there are four classes and two groups G and G in this example there are four Name entries and two ResourceGroupSignature entries in the metadata. The first ResourceGroupSignature entry in the metadata corresponds to group G and the second ResourceGroupSignature entry corresponds to group G and since group G depends on group G the section of the metadata that corresponds to G includes a ReferencedGroupSignature entry identifying G.

The order in which entries for various class groups is stored in the metadata and the format in which the metadata is stored and or transmitted to class loading mechanism may vary in different embodiments. As shown in the example above in some embodiments entries for leaf class groups class groups that do not depend on other class groups may be computed and placed first in the metadata and entries for other class groups may be computed and placed later in the metadata e.g. in a depth first traversal of a dependency graph between class groups. In other embodiments the metadata may be arranged according to an ordering that does not correspond to a depth first traversal of the group dependency graph.

When metadata shown above is received for the first time at a class loading mechanism e.g. in response to a request to load a specific class where the request also specifies a URL from which the class files for the class may be obtained the class loading mechanism may be configured to create a respective class loader for each class group identified in the metadata in some embodiments. The class group associated with a given class loader i.e. the class group for which the class loader is created by class loading mechanism may be termed the primary group for the class loader herein. In some embodiments the class loaders may be created in depth first order based on the reference graph of the class groups . In the example scenario whose metadata is shown above two class loaders may be created one whose primary group is G and one whose primary group is G. In some embodiments each class loader may be configured to record its own signature e.g. derived from the signature of its primary group the signatures of the individual classes of the primary group and or the signatures of the other class groups referenced by the classes of the primary group. The recorded class loader signatures may be used for example by the class loading mechanism to ensure that the appropriate class loader is invoked for any future class loading request. The class loader may also be configured to retain e.g. in a persistent database some or all of the information included in the metadata associated with its primary group for use during future class loading requests. In one embodiment for example the class loader may be configured to store a mapping between the names of classes included in the primary group and their respective signature values as well as the signature values for groups referenced from the primary group.

In response to a request to load a particular class e.g. main.Main in the above example the particular class loader whose primary group e.g. group G in the example includes the class may be configured to download a class file corresponding to the class from a specified URL and generate a signature for the downloaded class. The identity of the downloaded class may be validated by checking whether the signature of the downloaded class matches the signature in the metadata. If the signatures match the class may be loaded. If the signatures do not match the class loader may generate an error indication in some embodiments. If the downloaded class references classes that are not in the primary class group class loaders for the referenced classes may be identified e.g. using the ReferencedGroupSignature entries in the exemplary metadata described above or using corresponding information stored in the class loader s database . For example since main.Proc.Processor references main.Utilities in the above example a request to load main.proc.Processor handled by a class loader created for G may also lead to an invocation of a class loader for G to handle the loading of the referenced class main.Utilities. After a set class loaders have been created for a given set of class groups subsequent class loading requests for classes belonging to those class groups may be handled by re using the class loaders.

As noted above the metadata may be generated and or stored by class analyzer in a variety of different formats in various embodiments. illustrates an exemplary template for organizing metadata according to one embodiment. The exemplary metadata described above for groups G and G for example may be generated by a class analyzer configured to use the template illustrated in . As shown the metadata may comprise a plurality of group entries e.g. A N . Each group entry may comprise information for a particular class group including for example a group signature and a collection of class entries e.g. A M . If the class group is not a leaf group i.e. if classes that are not included in the class group are referenced from the class group the class group entry may include a collection of referenced group entries A P. Each class entry may in turn include a class name and a class signature . In some embodiments the ordering of group entries within the metadata may be based on a traversal order of a dependency graph e.g. the class analyzer may be configured to generate a graph representing dependencies between various class groups and the group entries may be arranged in depth first order or breadth first order with respect to the graph. In other embodiments the group entries may be arranged within the metadata based on other ordering criteria e.g. based on a numerical order of the corresponding signature values. In some embodiments class entries within a given group entry may be arranged in lexical order e.g. alphabetically based on class name and referenced group entries within the given group entry may be arranged in numerical order of their signatures. In some implementations the metadata may include names for the class groups and the referenced groups e.g. to ease debugging both names and signature values for class groups and referenced groups may be stored. In one implementation additional information may be included in the metadata such as a URL for obtaining executable class files an indication of the specific mathematical function or functions used for generating signatures security information etc. Part or all of the metadata may be encrypted in some embodiments before it is transmitted to a class loading mechanism .

In some embodiments the class analyzer and the class loading mechanism may be used during local execution of applications i.e. in some scenarios the classes may be analyzed and the metadata generated at the same execution environment or JVM at which the classes are to be loaded and executed. In other embodiments the techniques described above may be used with distributed programming techniques such as Jini or RMI and the metadata may be relayed from one execution environment to another according to the needs of one or more distributed applications. is a block diagram illustrating one embodiment in which the class analyzer runs at an analysis site that is linked via a network to a plurality of deployment sites e.g. A C at which classes are to be loaded for execution. The network may comprise any combination of wired and or wireless local area networks LANs metropolitan area networks MANs and wide area networks WANs including for example a portion of the Internet in various embodiments. In some embodiments each site shown in may correspond to a different physical location and each site may include one or more execution environments or JVMs. In the depicted embodiment executable versions of the classes e.g. class files comprising byte codes for the classes may be stored at the analysis site as well and a URL for the analysis site may be provided to allow class loaders at the deployment sites to download the executable versions as needed. In other embodiments executable versions of the classes may be stored at a different site than the site where the class analyzer executes or may be replicated at a plurality of locations.

In one embodiment the metadata for the classes of one or more applications may be initially transmitted from the analysis site to a plurality of deployment sites such as A and C as indicated by the arrows labeled and in . The initial transmission of the metadata may occur prior to the time at which any of the classes have to be loaded or executed in some embodiments e.g. the metadata may be distributed to a collection of deployment sites in preparation for future class loading requests. In response to receiving the metadata class loading mechanisms at each receiving site may create respective class loaders for each of the class groups identified in the metadata. During the execution of a distributed application the metadata may be sent from one deployment site to another e.g. if a method referencing a class is invoked remotely from deployment site A at deployment site B metadata corresponding to the class may be transmitted over network from site A to site B as indicated by the arrow labeled in . It is noted that once metadata is generated for a given set of classes in the embodiment shown in the metadata may not be changed as it is transmitted from one site to another. Thus even though the various deployment sites may differ in various respects such as in the sets of executable classes each site may have cached locally in the details of the local programming environments such as compiler versions etc. the fact that the metadata for a given set of classes remains unchanged across the deployment sites may help to ensure that an identical hierarchy of class loaders is set up at each site for the classes and that the identity of each class can be unambiguously validated prior to loading at any of the sites.

In embodiments such as those described above where the metadata is derived from the content e.g. the byte code and referencing behavior of the classes a change in the content of a class may automatically result in invalidating the existing metadata and may require new metadata to be generated. In turn the new metadata may lead to a different set of class loaders being created at various deployment sites . In such embodiments the same class loader may not be used to load the two different versions of the class. As a result in execution environments such as JVMs where the identity of a class is determined by the tuple class name defining class loader each version of the class may be provided a different unique identity.

In the embodiment illustrated in the classes may be categorized into an initial set of class groups based for example on the packages to which the classes belong block of e.g. one class group may be set up for each package. The information on inter class dependencies generated in operations corresponding to block may be used to determine inter group dependencies e.g. if a class A in a group G references a class B in group G G may be identified as being dependent on G. It is noted that in embodiments where classes belonging to a particular package can be loaded by different class loaders categorization based on packages may not be required and the initial categorization corresponding to block may be based simply on an initial set of identified dependencies. After the initial set of class groups and corresponding group dependencies have been identified class analyzer may be configured to search for circular dependencies between class groups and for every circular dependency identified merge the class groups participating in the circular dependency block . For example if class analyzer identifies three class groups G G and G during initial categorization of which G depends on G and G depends on G G and G may be merged into a single group G. Some circular dependencies may include more than two participating groups and may include indirect dependencies e.g. in one exemplary scenario G may depend on G G on G and G on G in which case G G and G may all be merged into a single group G. In this example the dependency of G on G may be termed a direct dependency and the dependency of G on G may be termed an indirect dependency.

After circular dependencies have been processed as described above the class analyzer may be configured to begin generating signatures for the classes and for the class groups block . The sequence in which signatures for various classes and class groups are computed may vary in different embodiments. In one embodiment for example signatures may be computed first for the individual classes of leaf class groups i.e. for class groups that do not depend on other class groups . Next the group signatures of the leaf class groups may be computed. A leaf class group signature computation for a given leaf class group LG may be followed by the computation of individual signatures for classes of a referencing class group RG that directly reference LG s classes followed by the computation of RG s signature and so on. In other embodiments the signatures for all the individual classes may be computed first and then the signatures for class groups may be computed.

In one embodiment a signature for individual class may be obtained by providing the byte codes corresponding to the class as input to a mathematical function and using an output value of the function as the signature. For example a hash function that has the following characteristics may be used to generate the signature in one implementation given two input streams that are identical the output value is identical and given two input streams that are not identical the output values for the two streams have a very high probability of not being identical. In other embodiments instead of providing the byte codes for a class as input names or identifications of one or more interfaces of the class may be used as input to the mathematical function. In embodiments where interface names rather than byte codes are used to generate signatures the signatures for a class may be independent of the specific compilers used to generate the byte code for example even if the byte code produced by a compiler C for a class A differs from the byte code produced by a different compiler C for the same source code the signatures for the two compiled versions may not differ. Class identity disambiguation in such embodiments may therefore be compiler independent. It is noted that computing signatures based on interface identifications e.g. method names may be especially useful for classes that are part of the standard packages that make up the Java runtime environment since the application programming interfaces APIs for these classes are standardized while the byte codes for the classes may vary from one Java implementation to another. In another embodiment e.g. instead of just using interface identifications e.g. method names to generate a class signature the source code of the class may be used as input to the mathematical function. Portions of the text of the source code that are not directly related to the behavior of the class may be ignored or manipulated in various implementations of source code based signature generation techniques e.g. in an effort to ensure that classes with identical behavior have identical signatures. For example comments in the source code may be ignored during signature generation sequences of one or more consecutive whitespace characters such as blanks tabs new line characters etc. may be replaced by a single canonical character and so on.

A signature for a class group may be derived from the signatures of the constituent classes of that group as well as from the signatures of any other groups referenced by the constituent classes. For example in one embodiment where a particular hash function H is used for generating individual class signatures a class group signature may be obtained by providing the set of class signatures of the constituent classes e.g. arranged in lexical order according to class name as well as the signatures of any referenced groups as input to the same hash function H. In another embodiment a different mathematical function may be used to generate group signatures than the mathematical function used for generating individual class signatures. It is noted that in some embodiments e.g. where class analyzer comprises a plurality of executable threads signatures for several classes and or class groups may be generated concurrently.

In the depicted embodiment the class analyzer may be configured to assemble the metadata identifying class to group mappings i.e. information indicating to which group each class belongs as well as the various computed signature values in a desired format e.g. using an organization similar to that illustrated in block of . In some embodiments the metadata may be pre assembled e.g. prior to deployment of an application or applications that include the classes in other embodiments the metadata may be assembled only in response to a request to deploy an application. Pre assembled metadata may be stored in a repository e.g. together with the source code and or executable versions of the classes in some embodiments. In some embodiments an explicit representation such as a directed graph of the dependencies between class groups may be included in the metadata instead of or in addition to implicit dependency information provided by listing referenced class groups for each non leaf class group.

If no existing class loader is found for the class group as also detected in block the class loading mechanism may be configured to create a new class loader for the class group block for example by creating a new instance of a subclass of the abstract java.lang.ClassLoader class in embodiments where the Java programming language is used to implement the classes . The newly created class loader may be configured to record its own signature e.g. derived from the group signature of its primary class group and or other portions of a group entry for the primary class group mappings between the class names and class signatures for classes of the primary class group and signatures for other class groups referenced from the primary class group block . The class loader signature may be saved in persistent storage for example and may be used to identify the appropriate class loader to use when a subsequent request to load a class of the primary class group is received.

In response to determining that the requested class is included in the set of class names for its primary class group the class loader may download the class from the URL block and validate the identity of the downloaded class block . For example the class loader may check whether a signature computed from the downloaded class matches a signature indicated by the metadata corresponding to the class e.g. a signature stored earlier based on received metadata in operations corresponding to block of . If the identity of the downloaded class is validated the class may be loaded and the class object corresponding to the class may be returned to the requester block . If the identity is not validated the class loader may generate an error message in some embodiments indicating for example that an invalid or unexpected version of the class has been encountered block .

If in operations corresponding to block the class loader determines that the class is not among the named classes of its primary class group the class loader may infer that the class is a referenced class belonging to a different class group . The class loader may then be configured to identify a different class loader appropriate for the class e.g. by searching among class loaders corresponding to referenced class groups of its primary class group. For example in one embodiment a query interface may be supported by the class loading mechanism allowing the appropriate class loader for a given class to be identified. If an appropriate class loader is found as detected in block the class may be transferred to the appropriate class loader for loading block . The class loader to which the class is transferred may be configured to repeat operations corresponding to blocks onwards before loading the class as indicated by the rounded block labeled To in . If no appropriate class loader is found an error may be generated block .

In some embodiments e.g. to prevent the creation of an excessive number of class loaders by class loading mechanism heuristics may be used to limit the total number of class loaders generated. For example if the class analyzer determines that the number of class groups for a given application exceeds a specified threshold the class analyzer may be configured to merge selected class groups until the total number falls below the threshold. It is noted that decisions about combining multiple class groups may be made in some embodiments at the deployment sites instead of or in addition to being made by the class analyzer and different deployment sites may make different decisions about which class groups are to be combined in some such embodiments. In some embodiments class groups that contain only leaf classes and or class groups that contain no more than a specified small number of classes may be merged to reduce the total number of class groups and hence the total number of class loaders . Heuristics based on observed application behavior e.g. how often classes belonging to two different class groups are executed in close time proximity may be used to merge class groups in some embodiments e.g. if classes in class group A are frequently executed at about the same time that classes in class group B are executed class groups A and B may be merged.

It is noted that although several exemplary embodiments described above have dealt with classes written in the Java programming language and executed at JVMs the techniques described here for grouping classes based on reference behavior and using the grouping information to verify class identity are not limited to Java based environments. In various embodiments any appropriate programming language and any suitable execution environment may be used. In addition the techniques described herein may be employed to support class disambiguation in any appropriate distributed programming techniques in addition to RMI and Jini based techniques.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

