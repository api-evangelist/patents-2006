---

title: Method and system for generating and employing a dynamic web services interface model
abstract: A system and method are provided to generate a dynamic web services interface model. In one embodiment, description content of a Web Service Definition Language (WSDL) file is identified. A first metadata and a second metadata are extracted from the description content. A dynamic web services interface model is created via the first metadata and the second metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08099709&OS=08099709&RS=08099709
owner: SAP AG
number: 08099709
owner_city: Walldorf
owner_country: DE
publication_date: 20060428
---
Embodiments of the invention generally relate to the field of web services. More particularly the embodiments of the invention relate to generating and providing a dynamic web services interface model via a core web services framework.

Efforts are being made to more easily conduct business in a web based environment. Web Services is loosely understood to mean the ability to discover and conduct business in a web based environment. For example a user e.g. a web based application or person with a web browser may 1 search through an online registry of businesses and or services 2 find a listing in the registry for web based access to a service that that the user desires to have performed and then 3 engage in a web based business relationship with the service application including the passing of relevant information e.g. pricing terms and conditions over the network. In other words web services generally refer to offerings of services by one application to another via the World Wide Web.

Given the nature and use of web services and the rapid increase in their demand interoperability of web services across clients and servers is becoming increasingly important and cumbersome. Some attempts have been made to achieve interoperability across a wide range of platforms and runtimes. For example using open standards like eXtensible Markup Language XML Simple Object Access Protocol SOAP Web Services Description Language WSDL and Universal Description Discovery and Integration UDDI some interoperability has been achieved.

However the open standards are not evolving fast enough to keep up with the increasing demand for web services and needs of additional flexibility and control on the client side. One of the problems today is the convoluted relationships and mappings between relevant standards. With conventional web services modeling applications and tools neither the interoperability nor the client side flexibility are sufficiently achieved because of the limitation in use of web services metadata and conventional separation of standards models and entities for web services WS and web services client WSC . For example Java application programming interface API for Extensible Markup Language XML based Remote Procedure Call RPC JAX RPC such as JAX RPC 1.1 does not provide for loading and describing of dynamic web services interfaces data access and object manipulation. Furthermore its metadata hides important web service details and is not suitable for building specialised web service applications.

A system and method are provided to generate a dynamic web services interface model. In one embodiment description content of a Web Service Definition Language WSDL file is identified. A first metadata and a second metadata are extracted from the description content. The first metadata includes an interface metadata while the second metadata includes a type metadata. A dynamic web services interface model is created via the first metadata and the second metadata

The above attributes may be implemented using a computer program a method a system or apparatus or any combination of computer programs methods or systems. These and other details of one or more embodiments of the invention are set forth in the accompanying drawings and in the description below.

As used herein references to one or more embodiments are understood as describing a particular feature structure or characteristic included in at least one implementation of the invention. Thus phrases such as in one embodiment or in an alternate embodiment appearing herein describe various embodiments and implementations of the invention and do not necessarily all refer to the same embodiment. However they are also not necessarily mutually exclusive. Descriptions of certain details and implementations follow including a description of the figures which may depict some or all of the embodiments described below as well as discussing other potential embodiments or implementations of the inventive concepts presented herein.

In one embodiment dynamic proxy is employed as a common dynamic API such that an application or user such as WS consumer does not need to generate or use proxy classes but instead WS consumer can use dynamic proxy as the common dynamic API to invoke web services via WS endpoint . Stated differently dynamic proxy is independent of web services APIs and although it allows building applications dynamic proxy is not bound by any single or specific web service and can consume multiple web services using dynamic proxy . In one embodiment to obtain knowledge about the web service parameters and operations no need for consumer application to generate or use classes interfaces but instead it can obtain such information from metadata structures via WSDL . Using this technique various user interfaces UIs are built around web services such that they are independent of the web services as part of web service model . WSDL and WS endpoint are provided by the WS provider . Furthermore external object trees are used as web service parameters by implementing specific interface and object factory so that the web services client framework can gain access and instantiate objects.

To send and receive information in one embodiment the dynamic runtime uses generic objects so that in those cases where a web service can be used having to generate a proxy and or write client application against a generated proxy. The metadata structures via WSDL for example provide information about the structure of the object tree. Since the type definition language for web services is XML Schema the metadata that describes the request and response structure is also XML or XML infoset based. A metadata model is developed to provide an easy to use model that is based on metadata structure without covering one hundred percent of XML Schema. In the illustrated embodiment various Object to XML and XML to Object features of schema are supported such as simple content model groups and simple content restrictions.

In one embodiment dynamic proxy uses WSDL to build a metadata model containing web services metadata provided by the web services description e.g. description of interfaces methods parameters and types such as the WS description provided via WSDL . Using a WS invocation API or WS endpoint application can invoke the loaded web service model via dynamic proxy . An object tree is then used to pass parameters while the requests and responses are managed by client application . In one embodiment the implementations of generic object interface e.g. GenericObject interface and generic object factory e.g. GenericObjectFactory are provided by the application developer or administrator. In one embodiment dynamic proxy is used in container managed environments e.g. Java 2 Platform Enterprise Edition J2EE as well as in standalone environments e.g. Java 2 Platform Standard Edition J2SE .

Interface metadata model provides an interface metadata API which contains web service interfaces and description of the interface methods and parameters. The parameter type descriptions may be found in type metadata model or the type metadata API. In one embodiment interface metadata model includes interface metadata that describes an interface metadata API. Similarly dynamic invocation model provides a dynamic invocation API. The interface metadata API of interface metadata model and the dynamic invocation API of dynamic invocation model are provided in a package e.g. com.sap.engine.services.webservices.espbase.client.dynamic package . In one embodiment object access model provides an object access API to describe the API for generic object access. The object access API is used by the runtime to serialize and or deserialize external objects. Further it contains those interfaces that the applications are to implement to provide access to their object trees. The object access API of object access model is contained in a package e.g. com.sap.engine.services.webservices.espbase.client.dynamic.content package .

Proxy component is used to retrieve interface metadata model and type metadata model from a WSDL document. Proxy component further includes various classes e.g. GenericServiceFactory and ServiceFactoryConfig classes from a package e.g. com.sap.engine.services.webservices.espbase.client.dynamic package that are used to instantiate dynamic web services clients and to configure their creation. Dynamic invocation provides a dynamic invocation API to provide methods to invoke loaded web service models using generic object trees. In one embodiment interface metadata model and type metadata model contain the web services client metadata. The objects sent or received by the client are herein referred to as generic object trees. These are the instances of the data types described in the metadata. The objects in such trees are either instances of one or more of interface and primitive Java types e.g. com.sap.engine.services.webservices.espbase.client.dynamic.content.GenericObject interface or primitive Java types .

After obtaining factory an instance e.g. DGenericService instance via interface may be obtained by a user e.g. developer administrator by using a method e.g. GenericServiceFactory.createService method at factory further described with reference to . Such create methods are used to load a WSDL and create a dynamic proxy for the referenced web service. The factory configuration can be provided by an object e.g. ServiceFactoryConfig object . When a dynamic API is used on the J2EE engine the factory is configured by the J2EE engine and no configuration is necessary to be provided. For example the following two methods for service creation at factory may be available for a container managed environment 1 public DGenericService createService String wsdlURL and 2 public DGenericService createService String logicalMetaTargetName QName interfaceName . For example the following method at factory may be used for a standalone mode public DGenericService createService String wsdlName ServiceFactoryConfig config .

In one embodiment the interface metadata model includes dynamic interface dynamic operation dynamic parameter and dynamic generic service . The illustrated embodiment of the dynamic invocation model includes dynamic interface invoker and dynamic parameters configuration . A relationship between some of these components is illustrated in .

A dynamic interface object e.g. DInterface object is returned to the application . In one embodiment each interface metadata is represented by an interface or object e.g. com.sap.engine.services.webservices.espbase.client.dynamic.DInterface object . The DInterface object represents the information from a WSDL PortType and a WSDL Binding couple. Each interface object may contain a set of operations and each operation may contain multiple parameters. The operations and operation parameters are represented by a dynamic operation object e.g. DOperation object and a dynamic parameter object e.g. DParameter object respectively. The web service type metadata e.g. type metadata of can be obtained by the DGenericService object by using a method e.g. DGenericService.getTypeMetadata method . Since the web service is represented by a single WSDL the web service interfaces share a common type system.

Each WSDL port may be represented by a single web service interface invoker e.g. getInterfaceInvoker QName portName that is communicated from the application to a DInterface . The invoker may not be thread safe which means a single invoker may not be used for multiple calls at the same time. To decrease memory usage invoker instances may be returned to the runtime for pooling by invoking a method e.g. DInterfaceInvoker.release method after the invocations are finished.

The invocation point names for a given web service interface are listed by the a dynamic interface port name method e.g. DInterface.getPortNames method . A dynamic interface invoker object e.g. DInterfaceInvoker object is communicated to the application . The DInterfaceinvoker object provides invocation functionalities for interface methods. For each operation the DInterfacelnvoker object uses a parameter configuration object e.g. ParametersConfiguration object to transfer input parameters and operation results. These parameters are set or obtained using their names in the respective DParameter metadata entries. Using the operation name as a key parameters configuration is invoked prior to the operation invocation. Such parameters configuration is communicated to the application . After setting inputs parameters an operation method e.g. invokeOperation method is invoked to facilitate operation invocation via parameters configuration via dynamic invocation model . A web services operation is then invoked and the parameters are inspected using the ParametersConfiguration object .

In one embodiment type metadata model includes several type and model group related interfaces classes components and elements such as type element type attribute type group type simple content type any type XML node type field type structure type complex type type facet type simple type type base and extended type mapping . Extended type mapping is contained in dynamic generic service of . In one embodiment javax.xml. namespace.QName may be used to denote fully qualified XML names which includes an xml local name and a namespace. Further this composes an xml identifier to be used to name xml nodes elements or attributes. This identifier may also be used in XML Schema to name XML Schema Definition XSD Types. The top level types defined in XML Schema may have unique qname to serve as a key to finding an XSD type metadata in the registry. The type system of XML schema contains two groups of types simple types and complex types . Simple types are used to contain textual content without other XML tags. Complex types are used to represent structured XML content containing tags and attributes. Base type in this type system e.g. xsd anyType can contain both the simple and complex contents and serves as the base type for both the simple and complex types .

DBaseType represents the base type for each type in the type system. It further represents xsd anyType in type metadata model . This schema type represents values of any valid schema type in the type system. The following two kinds of types descend DBaseType 1 DSimpleType and DComplexType . The DSimpleType and DComplexType represent the two main XSD types of the simple types and the complex types respectively. In the set of the known types some types are built in into the schema language such as string int. etc. These types are recognized by the isBuiltIn flag. For example this flag is set to true if the type represented is built in.

DSimpleType represents each of the schema simple types including xsd anySimpleType that is base type for each simple type in schema. DSimpleType includes simple types that represent textual content. No simple type represents structured XML however the XML attributes can have simple types as their type. Examples of simple types include xs string xs int and xs date. In these types there are some that are built in into the schema language and some that are derived by using restrictions. The restrictions applied to a derived type are aggregated into a set of Facet name value pairs . For example a simple type object may result with facet set as true and facet set as false. Further runtime provides a method to validate a string value against simple type metadata which implements the validation of fields prior to sending them.

DComplexType includes complex types that represent types having structured XML content. Each complex type describes a set of attributes and elements that describe the content of this type. The XML attributes may have simple content types and may not have cardinality. They can be optional or required. Each complex type contains structure of some elements. The type field can be used to get the structure type. For example an ALL field indicates that elements in the structure can be of any order. When the ALL field is used merely XML elements are allowed to be contained in the structure. A CHOICE field indicates that the elements in the structure are alternatives and merely one valid alternative between the elements is possible to be sent or received. A SEQUENCE field includes ordered set of elements. The fields of the structure are not merely XML elements. XML Schema allows for a group set of elements without creating a type. This set of elements is called group. Mixing elements and groups and nesting groups can be used to create complex ordering of elements. This definition makes the complex type and the group structures but the group is not a complex type and the complex type is not a group. A SIMPLE field includes those complex types that can extend simple types to achieve structures that contain simple type contents and attributes. In such cases the structure of the complex type includes a SIMPLE set as its type. In case of such a structure it may not contain those fields that are elements and model groups. One other field that can be used is that of type DSimpleContent field. The simple content of a complex type may not have a name and may represent the textual content of the complex type. In this case those complex types that are extended simple types are XML nodes with attributes and textual content.

DStructure provides an interface to be used to describe a structural content. In XML Schema a set of XML elements composes a structure. It contains a set of fields e.g. DField . DGroup represents a model group. Model groups are used often in XML Schemas to allow to group elements and create alternative groups of elements using for example xsd choice . Model groups are treated as separate structures and are regarded as embedded objects. Model groups have special names given by the loader which is unique and is used to set this model group value within the scope of the generic object that contains it. DField includes a component that is used to represent fields and contents inside a complex type. The property Type contains information about the kind of the field. It is an element a group or fields e.g. ALL CHOICE SEQUENCE etc. other components e.g. ANY SIMPLE etc. can be detected by examining the value of this property. The QName of the field XSD type can be accessed using the FieldType property. Scope is a property of a DField interface that contains the QName of the type that contains the field. This is used to quickly find the owner type of a specific field.

DElement is used to extend DField and is further used to represent an XML Element. It contains cardinality information and element names. DAny is used to represent the special wildcard XSD component e.g. xsd any which is used for representing any element into the xml content. DSimpleContent is used to represent simple content when some a complex type extends a simple type. Because the entity is unnamed and is not an element it can be a separate component. This component is stored as a field in the containing complex type. Once created this model also allows for creating valid object trees using generic objects. Anonymous type handling at top level anonymous types may not be used. They can appear in the element or attribute declaration to specify local un referencable type. These types have special unique local names such as XPath of the XML node in which they are declared. The core web services framework may use these names to reference the anonymous types. Model groups include have name property that is used by the core framework to set or receive their values. Their names are of local meaning within the structure of the type they belong to and the order in which they are declared. Each model group contains a scope property that references the ComplexType to which it belongs.

Once the interface and type metadata are obtained a model builder or model building module is used to generate the dynamic web services interface model . The dynamic web service interface model includes an interface metadata model and a type metadata model having the interface metadata and the type metadata respectively. In one embodiment the interface metadata model and the type metadata model describe an interface metadata API and a type metadata API respectively. The dynamic WS interface model provides a dynamic WS interface API. The interface metadata may also contain the type metadata which describes data types. The type metadata is further used to examine the WS types and build parameters for dynamic WS invocation using a dynamic WS invocation model. The interface metadata is used to examine WS interface and use the related information for a dynamic WS invocation API as described by the dynamic WS invocation model invocation API to dynamically invoke web services. The conventional JAX RPC does not describe the types of web services.

In one embodiment using the model builder a dynamic WS interface model is generated containing the interface metadata and the type metadata at processing block . Each model describes a corresponding API such as a dynamic interface API an interface metadata API and a type metadata API. At processing block the interface metadata and the type metadata are inspected and the relevant information such as innovation description and type description and the APIs are used for a dynamic WS invocation model to dynamically invoke web services. At processing block the dynamic invocation model dynamically invokes a web services e.g. without having to create a corresponding proxy for the web service .

In one embodiment to perform various embodiments of the present invention a server or node e.g. J2EE server is employed which supports Enterprise Java Bean EJB components and EJB containers at the business layer and Servlets and Java Server Pages JSP at the presentation layer . A virtual machine VM may include a Java virtual machine JVM to host the server or server node. It is understood that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments Java based environments such as a J2EE environment or environments defined by other releases of the Java standard other environments e.g. a .NET environment a Windows NT environment each provided by Microsoft Corporation and the like.

Processes taught by the discussion above may be performed with program code such as machine executable instructions which can cause a machine such as a virtual machine a general purpose processor disposed on a semiconductor chip a special purpose processor disposed on a semiconductor chip etc. to perform certain functions. Alternatively these functions may be performed by specific hardware components that contain hardwired logic for performing the functions or by any combination of programmed computer components and custom hardware components.

One or more modules within or associated with the dynamic web service proxy such as dynamic proxy of and its APIs e.g. dynamic proxy API models components and other elements may include hardware software and a combination thereof. In a case where a module includes software the software data instructions and or configuration may be provided via an article of manufacture by a machine electronic device hardware. An article of manufacture may include a machine accessible readable medium having content to provide instructions data etc. The content may result in an electronic device for example a filer a disk or a disk controller as described herein performing various operations or executions described. A machine accessible medium includes any mechanism that provides i.e. stores and or transmits information content in a form accessible by a machine e.g. computing device electronic device electronic system subsystem etc. . For example a machine accessible medium includes recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. etc. The machine accessible medium may further include an electronic device having code loaded on a storage that may be executed when the electronic device is in operation. Thus delivering an electronic device with such code may be understood as providing the article of manufacture with such content described above. Furthermore storing code on a database or other memory location and offering the code for download over a communication medium via a propagated signal may be understood as providing the article of manufacture with such content described above. The code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

Client systems may execute multiple application or application interfaces. Each instance or application or application interface may constitute a user session. Each user session may generate one or more requests to be processed by server . The requests may include instructions or code to be executed on a runtime system such as VM on server and its components and modules as described throughout this document.

In addition to what is described herein various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

