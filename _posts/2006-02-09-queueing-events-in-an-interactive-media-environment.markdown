---

title: Queueing events in an interactive media environment
abstract: An arrangement is provided where all applications in an interactive media environment run on a single application thread in a media player. Event queues are utilized to schedule the application thread's processing of workitems corresponding to events that occur in the environment. Workitems include methods to be invoked when the workitem is processed and arguments for the method. Workitems further include a begin time and an end time and are ordered in the event queue first by begin time followed by the order in which they were inserted into the queue. The application thread marks workitems whose begin times corresponds to the current or previous time and then processes marked workitems from the queue in order. Such processing is committed so that once the application thread begins processing of a workitem it does not stop. Workitems are dropped from the event queue if their end times have been passed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08656268&OS=08656268&RS=08656268
owner: Microsoft Corporation
number: 08656268
owner_city: Redmond
owner_country: US
publication_date: 20060209
---
This application claims the benefit of provisional application No. 60 695 944 filed Jul. 1 2005 which is incorporated by reference herein.

The described arrangements systems and methods relate generally to interactive media and more particularly to queuing events in an interactive media environment.

Interactive media environments are typically resource constrained in terms of available processing power memory and other resources that are available to applications running in the environment. One common example of interactive media is video encoded on DVD digital versatile disc where users can interact with graphical menus or other controls to navigate to specific video content or invoke special features that are authored into the DVD.

In more complex interactive media environments despite the limited resources applications need to respond to users in real time manner that is frame accurate with the video. However the use of real time multithreaded programming to accomplish such a goal would place a large burden on interactive media authors in dealing with issues such as thread management and synchronization.

An arrangement is provided where all applications in an interactive media environment run on a single application thread in a media player. Event queues are utilized to schedule the application thread s processing of workitems corresponding to events that occur in the environment. Workitems include methods to be invoked when the workitem is processed and arguments for the method. Thus the scheduling and processing of workitems from the event queues determines what work get done and when in the environment. Typical events include user events that are fired from user interaction with the media player system events fired by the media player and events that are fired by the applications.

In various illustrative examples workitems further include a begin time and an end time and are ordered in the event queue first by begin time followed by the time in which they were inserted into the queue. In one illustrative example the application thread marks workitems whose begin time corresponds to the current or previous time and then processes marked workitems from the queue in order. All processing is performed on a committed basis so that once the application thread begins processing a workitem it does not stop. Workitems are dropped from the event queue if their end times have been passed. Workitems for new events that occur during processing are inserted at the end of the queue to be handled after the committed workitems. In another illustrative example workitems for new events are inserted into the event queue based on their relative begin times to be handled after the committed workitems. Repetitive events like timer events and application drawing events may have individual occurrences dropped from the event queue. However one shot i.e. single occurrence non repetitive events are never dropped.

Advantageously the event queuing model with single application thread provide a stable and predictable methodology for interactive media authors to manage events in a real time frame accurate manner where hardware resources including processor cycles and memory are limited.

Referring to an illustrative block diagram of the elements making up an application used in an interactive media environment is shown. Applications are typically used in the interactive media environment to enable interaction between a user and an interactive media player rendering graphics and video on a coupled display device such as a television or monitor through a user interface such as a remote control. More specifically applications control presentation behavior of various content objects including video playback in the environment. Presentation of graphic objects such as menus and interactive buttons over the video is also realized using applications. Applications further manage and control audio playback and sounds in the environment. It is contemplated that multiple applications will generally be running simultaneously in most interactive media settings. However there is no requirement the multiple applications run simultaneously and the decision to divide or aggregate applications in a particular setting is a design choice of the interactive media author. Applications may also be logically subdivided into application pages depending on the requirements of a specific setting.

The application comprises a script host containing zero or more script files and and zero or more markup documents that is used to generate a document object model DOM . The markup documents include information relating for example to content style timing and layout of graphic objects. Thus the markup context is used generally to provide graphics on a graphics plane in the interactive media environment.

In this illustrative example the markup documents are XML document files in accordance with W3C standards. As indicated in multiple physical XML files may be accessed using the element in the section of the markup. In some settings it may be preferable for an application to not have more than one active markup at a time. However an application may switch its markup by using a element in the markup. Alternatively an application may switch its markup by utilizing an application programming interface API that enables applications to gain access to functional objects within a current application. Using a loadMarkup call through the API an application may switch markup files by passing the Uniform Resource Identifier URI of the new markup through an API.

In cases where an application accesses a new markup the API call takes effect only after a current event handler in the application finishes executing its current task. Any current markup related event handlers that are pending are also cancelled as the new markup once loaded will invalidate those event handlers.

In this illustrative example script host contains script files and which are used along with the markup to implement interactive media experiences. Script files and may be implemented for example using ECMAScript as defined by Ecma International in the ECMA 262 specification. Common scripting programming languages falling under ECMA 262 include JavaScript and JScript. In some settings it may be desirable to implement scripts and using a subset of ECMAScript 262 in particular ECMA 327 along with a host environment and a set of common APIs. Script context in most settings is utilized to deal with interactive control issues from user along with system events graphics control video playback resource management e.g. use of caching or persistent store resources and other issues that are not readily or efficiently implemented using solely markup .

The availability of APIs and resources to application is indicated by reference numeral in . Resources include for example audio and video files fonts pictures and images e.g. in common file formats including PNG JPEG GIF BMP TIFF etc. and other resources as may be required by an application according to the circumstances of a specific setting.

Each application maintains its own script host that maintains the context for the script s variables functions and other states. In most settings variables and functions in one application are not visible to another application unless the applications are specifically set up to enable such cross application visibility for example by using an object that is shared across all applications. For example in this illustrative example the interactive media player object has a single instance that is shared across all applications. Optionally therefore special objects may be placed inside script host for example using a C object to implement singletons i.e. a objects having limited instantiation where the special objects all reference the same internal function for example of the player. This optional aspect enables interactive media script authors to logically treat common objects as singletons while still allowing the script host to implement the functionality necessary to expose an object to the single script host.

Referring now to an illustrative diagram showing the relationship among multiple markup documents and script is provided. An application manifest interacts with applications which as noted above are defined generally by resources script and markup documents and as shown. Each application typically uses a single application manifest file in most settings but the application manifest is not part of the runtime state of the application. In this illustrative example the application manifest is encoded as an XML document file.

The application manifest describes the initial markup file to be used by the application as well as the script files collectively indicated by the rectangle with reference numeral in FIG. contained in script host . If the application manifest lists more than one script as in this illustrative example then all the scripts are loaded into a script handling engine in the interactive media player. Thus the multiple script files are treated and behave as if the script author had concatenated all of the script files into a single large file in the order listed in the application manifest .

As shown in the application manifest refers to resources . The resources available to an application in an interactive media environment form a directed graph rooted by the resources referenced in the application manifest . The allowed extent of the graph for each application is proscribed by the application manifest .

The progression of context execution by applications in the interactive media environment is guided by a playlist which describes among other things the relationship among objects in the environment including presentation objects that are rendered by the player onto the display device. These presentation objects typically include video which may include multiple streams as described in more detail below and graphics produced by the applications.

Playlist further manages resources across the interactive media environment as a single management entity in order to efficiently allocate and control the consumption of resources by applications. As with the application manifest the playlist may be advantageously embodied as an XML document file in most settings.

The markup pages in may be used in some settings to fire events into an execution context created by the script files and in . The execution context then manipulates the DOM created by the current application markup. As the markup is used in the interactive media environment to specify style content timing and layout of graphical objects in the environment as represented by elements and in the combination of script and markup enables the creation of a comprehensive set of capabilities.

VCP manages one or more media streams that may be received from multiple sources including a local optical drives such as a DVD drive or a high definition DVD HD DVD drive a local memory or a remote broadband source over a network. VCP in this illustrative example includes one or more media processors . . . N as indicated by elements and in . Media processors and process the received media streams which typically include audio and video to decode and render the corresponding images and sound which are output as an audio video stream on line . Audio video stream may represent a plurality of video elements for example to render multiple separate video windows using a picture in picture type configuration.

Media processors and each comprise a media source interface demultiplexer and decoder. Media processors and may optionally include decryption capabilities as well. A display device is coupled to receive and display the audio video stream.

A media clock is utilized so that each received media has an associated Media Time. When a video stream is paused on the interactive media player then the media clock is paused as well. When the video stream is set by a user to go faster or slower than real time for example when the video is put into fast forward rewind or slow motion modes using any of these modes is referred to as trick play then the media clock speeds up or slows down accordingly. The Media Time is thus derived from the media clock and the operation of the media processors and . The Media Time is passed to the playlist manager in ICP over line . Time in the interactive media environment including Media Time is typically counted in units of ticks. 

ICP performs all application related processing and may be arranged from several components that may be realized in hardware software firmware or a combination thereof. The components of ICP include for example a markup engine script language interpreter and an XML parsing component not shown . ICP outputs a graphics stream on line which is synchronous with the audio video stream . Mixer takes the graphics stream on line and the audio video stream on line so that the graphics are rendered in a graphics layer over the video stream to implement an interactive media session for a user.

In most settings ICP outputs graphics that are synchronized on a frame by frame basis with the video stream. However such synchronization may be performed using other bases including for example time including Title Time and Media time as defined below content in the video or other metadata embedded in the video that is used to indicate or mark a particular point in the stream.

ICP includes a playlist manager and a task manager . The playlist manager is responsible for controlling presentation objects in the environment. These objects include video playback on the player along with applications that are running to generate interactive graphics. Playlist manager manages the playlist which is described above in the text accompanying .

The playlist manager also computes the Title Time associated with each portion of content in a media stream. A title is a unique sequence of video and audio content with a start and end time that is typically defined by the DVD author. However what such author defines as a title can be arbitrary. Thus particular content which is perceived in a video may be part of one title a complete title or run across multiple titles.

One example of a title is the copyright warning that precedes all pre recorded video in both analog and digital format in the United States. The featured attraction e.g. the main movie on a DVD is another example and is often the longest title. In some settings individual chapters in a movie might be designated as separates titles by the DVD author. For all such titles Title Time is defined as the time elapsed since a given title started playing as shown on the media clock .

A presentation clock is coupled to the playlist manager on line . The presentation clock is a clock whose time changes at the same pace as a real world clock i.e. it takes one second of real time for the presentation clock to advance by one second . In contrast to the media clock the presentation clock never stops and cannot be sped up or slowed down. The Presentation Time from the presentation clock is passed to the task manager which uses it to calculate Application Time and application Page Time. 

Application Time is the time elapsed since an application started or enters an Active state as described in more detail below . When multiple applications are in runtime each application has a notion of its own Application Time. For each application Application Time always starts at zero when an application is started in the environment.

For example if an application App starts at Presentation Time of 20 arbitrary time units which is 0 time units for App and application App starts at Presentation Time of 25 time units which is 0 time units for App then at Presentation Time of 35 time units App s Application Time is 15 time units and App s Application Time is 10 time units. For applications that are logically subdivided into pages the Page Time is the time elapsed since a page of an application has been loaded.

The audio video feeds and along with the synchronous graphics stream from ICP are mixed in mixer and output on line to a display device . The other elements in including ICP comprising playlist manager and task manager media clock in VCP and presentation clock are configured and function in a similar manner as their counterparts shown in and described in the accompanying text.

Each of the event queues and are arranged to feed into application thread from their head ends located at the right side of . A plurality of applications App App . . . AppN as designated by reference numerals and respectively are arranged to post workitems representatively designated by reference numeral into the queues and from their tail ends on the left side of .

Application events are events which are fired by an application. These may include events fired by either script e.g script host in or by markup e.g. markup in . Application events in most scenarios are handled only by script. However applications and do not invoke script or markup functionality directly. Instead all such functionality is posted to the applications respective event queues in the form of workitems and are invoked when the application thread processes the workitem.

In alternative arrangements events from sources other than applications are also scheduled using event queues. For example user events are fired by user interaction with a remote control. System events are events fired by the interactive media player such as player shown in and described in the accompanying text.

Each workitem in events queues and contains fields as shown in . These fields include an application association field a method field a BeginTime field an EndTime field and an optional ClockSelector field .

The application association field indicates the particular application to which a workitem applies. The method field contains a method that is invoked when the workitem is processed by the application thread . Method field also includes arguments for the method.

The BeginTime field and EndTime field are used respectively to indicate when the workitem s method begins and ends. In this illustrative example time is expressed using Application Time. However in alternative examples the BeginTime field and EndTime field contain values which may be alternatively expressed in Title Time Application Time or Page Time depending on the requirements of a particular setting. In such cases the particular timeframe used by a workitem is indicated in the ClockSelector field . Regardless of the timeframe utilized a BeginTime for a workitem must always be less than the EndTime.

Event queue includes workitems . . . N as indicated by reference numerals and respectively. Each workitem includes the fields shown in and described in the accompanying text.

Workitem includes a BeginTime and an associated time of insertion t into the event queue as indicated in block in . Similarly workitem includes a BeginTimeand an associated time of insertion tinto the event queue as indicated in block . Workitem includes a BeginTimeand an associated time of insertion tinto the event queue as indicated in block . And workitem includes a BeginTimeand an associated time of insertion tinto the event queue as indicated in block .

In this illustrative example workitems are ordered in the event queue first by BeginTime and then by the time in which workitems were inserted into the event queue. Such ordering results in the application thread processing workitems in order of BeginTime or when two workitems have the same begin time then in FIFO first in first out order.

The ordering of workitems in an event queue is performed using two alternative methods workitems may be ordered when inserted into an event queue or when workitems are extracted from the event queue prior to processing. Either arrangement is equally usable so long as the processing of workitems from the event queue is performed by BeginTime followed by queue insertion time.

Workitem includes calls into the markup engine e g a markup engine disposed in ICP in to process timing for a page in application App as indicated in block . In block workitem includes calls into the markup to reflow application App s markup to reflect processed events and then render the markup on the display device e.g. display in . Workitems and are always the last workitems processed in an application s tick by application thread .

The process starts at block . At block when the application thread is free to process workitems it first marks each workitem in the event queue whose BeginTime corresponds to the current or previous ticks. Application thread will only process marked workitems. Thus a workitem in event queue will never be processed before its BeginTime.

At decision block if a marked workitem s EndTime has already been passed then it is dropped from event queue as indicated in block . No processing on that workitem will be performed in such a case. Should application App reloads its page the application s page clock is reset to zero and all outstanding i.e. queued workitems based on the application s page clock are dropped from event queue just as if they had reached their EndTime.

If at decision block a marked workitem s EndTime has not been passed then control is passed to block and the application thread processes the workitem. As noted above in the description accompanying each workitem is processed in order from the event queue first by BeginTime followed by the time each workitem was inserted into the event queue .

Both repetitive events and one shot i.e. single occurrence non repetitive events are managed using the method shown in . A repetitive event may include a periodic event where the associated workitem has an EndTime that is equal to the next scheduled BeginTime. That is each periodic event has a duration equal to the event s period.

Periodic events typically include events like timer events and application drawing events. For example if an application s script e.g. in script host in creates a timer that will call back once every seconds it will add a timer workitem to the event queue with a BeginTime equal to the current time plus seconds. The EndTime will be set to the BeginTime plus seconds. Once the timer workitem is executed out of the event queue the BeginTimes and EndTimes will be adjusted by adding another seconds and the workitem will be reinserted into the event queue at the proper location based on the new BeginTime.

Periodic events are invoked whenever possible. But if they cannot be processed by the application thread before the EndTime in their associated workitems expires then that particular invocation is dropped and the next invocation is scheduled with a new workitem.

Advantageously the event queuing method enables a parameter may be passed to timer events to indicate the time that the event is to be invoked. This parameter must be the same as the BeginTime in the associated workitem. Script associated with a periodic timer event might not be run exactly at the invoked time as noted above. However as each workitem includes a method field that specifies arguments to the method the argument s value will reflect an intended time of invocation and not the actual time. Accordingly the handler for a timer event will know what time i.e. tick it is handling.

A one shot event has a corresponding workitem with an EndTime of INFINITE. Therefore a one shot event will never be dropped from the event queue . For example if a one shot event is an input event then that event s handler is scheduled as a workitem in the event queue with an EndTime of INFINITE.

As indicated in block the processing is performed on a committed basis. That is once the application thread begins processing a workitem from the event queue it does not stop processing. For example script which may be long running is not aborted nor are exceptions injected into the script in order to throw it out. While such a scheme can tie up the application thread while it processes script as noted above the ICP e.g. ICP in may be arranged to include other threads which continue to run during the committed processing of workitems. In alternative arrangements it may be desirable to handle workitems in a manner such that a new event is inserted into the event queue based on its relative BeginTime to be handled after the commited workitems.

At block any new workitems that are created during the processing of marked workitems are inserted into the event queue after the marked workitems regardless of their BeginTime. The process of marking workitems committing to them and inserting new workitems after the committed workitems in an event queue as shown in blocks and ensures that the applications are always afforded some visible progress.

In accordance with one aspect of the invention an application scheduler is provided which is arranged to manage processing of workitems corresponding to events occurring in an interactive media environment where time is counted using a sequence of ticks each of the workitems having a timestamp that includes a begin time and an end time and includes a plurality of event queues for queuing the work items each of the event queues having a head end and a tail end and arranged so that workitems are rocessed from the head end of the event queue each of the event queues further being accessible by respective ones of a plurality of interactive media applications in order to insert the workitems into the event queues and an application thread coupled to the plurality of event queues at their head ends the application thread being arranged for marking workitems whose begin time corresponds to a current tick or a previous tick processing marked workitems and inserting workitems associated with new events that occur during the processing at the tail end of an event queue so that they follow after marked workitems.

As indicated at block and in the application thread automatically inserts two workitems into each application s event queue for each tick as shown in and described in the accompanying text. These workitems call into the markup engine for each application to evaluate application timing and then reflow and render the markup on a display device. As noted above the workitems are inserted upon application start and a rescheduled after each tick. In addition these two workitems are always the last two to be processed for an application s tick and are treated as periodic events that may be dropped from the event queue .

It is noted that for the sake of clarity and ease of illustration in the description above that data programs and other executable program components such as operating systems are shown is discrete blocks boxes or other elements although it is recognized and emphasized that such programs and components may reside at various times in different storage memory or processing components of any hardware host used and are executed by one or more processors in such host hardware.

Although various illustrative arrangements and methods for managing application states in an interactive media environment have been shown and described it should be understood that the scope of the claims appended hereto shall not necessarily be limited to the specific features arrangements or methods described. Instead the specific features arrangements or methods are disclosed as illustrative forms of implementing managed applications states in an interactive media environment as more particularly claimed below.

