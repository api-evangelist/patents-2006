---

title: Accessories for teleconference component
abstract: A system and method providing capability expansion in a teleconferencing environment. One or more accessories are invoked and arranged in an accessory stack associated with an application. The accessory stack is positioned logically between a teleconferencing application and a conference component in both a local and a remote end point. Each accessory provides at least one additional capability to the system independent of the application and the conference component
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07392286&OS=07392286&RS=07392286
owner: Apple Inc.
number: 07392286
owner_city: Cupertino
owner_country: US
publication_date: 20060731
---
This application is a continuation application of co pending U.S. patent application Ser. No. 10 763 587 filed Jan. 23 2004 which is a continuation application of U.S. patent application Ser. No. 08 646 500 filed on May 8 1996 now U.S. Pat. No. 7 167 897.

The present invention relates to teleconferencing systems. More specifically the invention relates to accessories for a teleconference component.

Teleconferencing is increasingly becoming a popular application in personal computer systems. Such applications typically allow the transfer of audio and video data between users so that they can speak and otherwise communicate with one another. Such applications sometimes also include data sharing wherein various types of data such as documents spreadsheets graphic data or other types of data can be shared and manipulated by all participants in the teleconference. Different teleconference applications perhaps residing on different hardware platforms have different capabilities. Moreover a wide variety of features has been implemented in different teleconference applications and the proliferation of different types of computer systems with different capacities and different networking media has created challenges for teleconferencing.

For example for most teleconferencing applications it is assumed that the sender and the receiver have certain minimum capabilities. However with the wide diversity of systems having different computation capacities and in addition the wide variety of networking media that certain systems may not have certain capabilities. Prior art systems have typically required that the application provide support for all capabilities used within the teleconference. This fact has substantially complicated teleconferencing applications and made expansion of capabilities difficult or impossible. It would be desirable to be able to relieve the application of the burden of supporting all capabilities by providing accessories which interface logically between the application and a base teleconference component to provide additional and expandable capabilities.

A system and method providing capability expansion in a teleconferencing environment is disclosed. One or more accessories are invoked and arranged in an accessory stack associated with an application. The accessory stack is positioned logically between a teleconferencing application and a conference component in both a local and a remote end point. Each accessory provides at least one additional capability to the system independent of the application and the conference component. The number of accessories so stacked can be arbitrarily large. In this way a teleconference application with limited functionality can be made to appear to the user to be quite robust. Moreover additional capabilities can be easily added to the system.

In one embodiment the application only communicates directly with the top accessory in the stack and the conference component only communicates directly with the bottom accessory in the stack. Also in one embodiment the accessories with which user interaction is required remain independent of the application by previewing system events before the application sees such events. This allows the accessory to claim such system events as mouse downs in its window transparently to the application.

The present invention relates to teleconferencing systems more specifically the present invention describes systems in which accessories are employed to increase the functionality of the teleconference independent of a teleconferencing application employed. Although the present invention will be described with reference to certain specific embodiments thereof especially with relation to certain hardware configurations data structures packets method steps and other specific details these should not be viewed as limiting the present invention. Various modifications and other may be made by one skilled in the art without departing from the overall spirit and scope of the present invention.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. They copyright owner has no objection to the facsimile reproduction by anyone of the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever. Copyright Apple Computer Inc.

A typical system configuration in which a teleconference may take place is illustrated as in . For example a first workstation may communicate via teleconference with a second workstation as illustrated. System may include a central processing unit which is coupled to a display a video input device and a sound input device . The system may communicate with system over networking medium via network connection module . may include any number of network adapters commercially available such as using Ethernet Token Ring or any other networking standard commercially available. Note that network adapter may also include a wireless network adapter which allows transmission of data between components without a medium . Communication is thus provided via network adapter coupled to system and bi directional communications may be established between two systems. System further has a keyboard and a pointing device such as a mouse track ball or other device for allowing user selections and user input.

The particular accessory shown is a file sharing accessory which allows advertisements to be posted by a user at a remote endpoint and viewed by a user at a local endpoint within the accessory window . Similarly the local user can post advertisements in the accessory window that can then be viewed by a remote user. The advertisement includes an icon a file name a file size and type and the name of the remote member responsible for the posting. A copy bar is also provided.

To copy a file associated with an advertisement the local member need only drag the icon to a location to which copying is desired and the accessory will copy the file to that location. Here icon has been dragged to the desktop where the icon appears. The copy bar begins to fill as the copying from a remote endpoint is performed. The file name is highlighted when selected. An advertisement need not remain selected during copying. Once copying is complete the file name will revert from boldface type to plain text The time remaining to complete copying is displayed in the lower part of the accessory window . Clicking on stop sign while copying of a selected file is in progress will abort the copy and cause the partially copied file to be deleted. If no file is selected the stop sign option is unavailable. In one embodiment once a file has been copied the advertisement effectively becomes an alias allowing the file to be launched by double clicking on the advertisement. Significantly prior to copying said double clicking will only result in a dialog box indicating that the file must be copied to be launched. This is because no physical file exists on the local end point and the advertisement merely provides an access path through which the physical file may be copied.

A locally posted advertisement differs from a remotely posted advertisement in that the file name is displayed in italic type and instead of a poster s name the copy status is displayed. In one embodiment copying locally posted files is not permitted. As other members of the conference copy the file associated with advertisement the copy status will change to reflect copied by everyone or copied by x of n where x is the number of copiers and n is the number of conference members. At any time a member may delete an advertisement in the accessory window by dragging the corresponding icon to the trash . If the deleting member is also the posting member for the advertisement once trashed the advertisement will disappear from all conference members windows. Conversely if a remotely posted advertisement is trashed it is only deleted from the trasher s file sharing window.

A computer system such as a workstation personal computer or other processing apparatus or as shown in is illustrated in more detail in comprises a bus or other communication means for communicating information and a processing means coupled with bus for processing information. System further comprises a random access memory RAM or other volatile storage device referred to as main memory coupled to bus for storing information and instructions to be executed by processor . main memory also may be used for storing temporary variables or other intermediate information during execution of instructions by processor . Included in memory during run time may be the conference component module which operates according to the communication protocols generally known in the art. System also comprises a read only memory ROM and or other static storage device coupled to bus for storing static information and instructions for processor and a data storage device such as a magnetic disk or optical disk and its corresponding disk drive. Data storage device is coupled to bus for storing information and instructions.

System may further be coupled to a display device adapter such as a cathode ray tube CRT or liquid crystal display LCD coupled to bus for displaying information to a computer user. Such a display may further be coupled to bus for the receipt of video or image information. An alphanumeric input device including alphanumeric and other keys may also be coupled to bus for communicating information and command selections to processor . An additional user input device is cursor control such as a mouse a trackball stylus or cursor direction keys coupled to bus for communicating direction information and command selections to processor and for controlling cursor movement on display . For teleconferencing applications system may also have coupled to it a sound output device a video input device and sound input device along with the associated D A Digital to Analog and A D Analog to Digital converters for inputting or outputting media signal bitstreams. System may further be coupled to communication device which is coupled to network adapter for communicating with other teleconferencing stations.

Note also that any or all of the components of system and associated hardware may be used in various embodiments however it can be appreciated that any configuration of the system may be used for various purposes according to the particular implementation.

In one embodiment system is one of the Apple Computer brand family of personal computers such as the Macintosh 8100 brand personal computer manufactured by Apple Computer Inc. of Cupertino Calif. Processor may be one of the PowerPC brand microprocessors manufactured by Motorola Inc. of Schaumburg Ill.

Note that the following discussion of various embodiments discussed herein will refer specifically to a series of routines which are generated in a high level programming language e.g. the C or C programming language and compiled linked and then run as object code in system during run time within main memory by processor . For example the object code may be generated by the C Compiler available from Symantec Inc. of Cupertino Calif.

Although a general purpose computer system has been described it can be appreciated by one skilled in the art however that the following methods and apparatus may be implemented in special purpose hardware devices such as discrete logic devices large scale integrated circuits LSI s application specific integrated circuits ASIC s or other specialized hardware. The description here has equal application to apparatus having similar function.

Because the accessory provides its capability to the teleconference system while remaining independent of the application an application with only minimal teleconference capability may appear to the user to be quite robust simply by accessorizing a number of accessories. The accessories are transparent to the application and are typically stored on the system heap in memory. In the case of automatic accessories the application need not know of the existence or capability of the accessory. The application merely issues API calls as it would in the prior art and the accessories take care of themselves. Such accessories will forward events including events related to the accessory to the application but the application can ignore unfamiliar events without detriment. If the application knows about the accessories such events may be used e.g. to update menus or status information. Accessories are generally independent of the transport protocol used and do not deal with the real time media.

Accessories fall within two classes accessories associated with a window and faceless accessories. Many window associated accessories are used for relatively low bandwidth sharing functions including but not limited to file sharing shared whiteboard chat window application sharing and desk top sharing. File sharing allows members of a teleconference to share files by placing those files in the associated accessory window. Application sharing would allow members to share a running application. For example a word processing document may be shared such that all members can edit the document during the conference. A shared white board accessory would create a window in which graphics and text can be shared between members. Desk top sharing allows the teleconference members to access and use items residing on remote members desk tops. A chat window could be used as a low bandwidth replacement for the audio visual media of the teleconference allowing near real time sharing of typed messages.

To remain independent of the application the window associated accessories take advantage of certain features of the operating system and the MovieTalk Toolbox. Specifically the accessory must be able to identify system events that apply to it before the application receives the event. Each accessory makes a call to MTToolboxPreviewSystemEvent . Upon receiving a system event the MovieTalk Toolbox passes it to each accessory which has made this call until an accessory claims the event or all such accessories have failed to claim this event. For example a mouse down event may be passed to an accessory which determines if the mouse down occurred in its window. In this way user interaction is handled transparently to the application. In one embodiment corresponding windows on a remote end point of some or all of the windows associated accessories automatically reflect changes e.g. typing cutting pasting posting etc. to the local window. Simultaneously the local window will automatically share remote changes. Thus corresponding representations will appear in both the local and remote windows associated with a particular accessory.

Other window associated accessories perform other types of functions such as window mirroring. Window mirroring associates events within some window of interest with the real time media events and converts those window occurrences into a video stream. This might be particularly useful in the context of a lecture with for example changing slides. In such case it is desirable that the slide be associated with the audio and video at the proper time in the lecture. By placing the slides in a window subject to window mirroring the slide will be so associated and converted to a video stream receivable by the teleconference members. A movie of the teleconference could subsequently be played back and the audio video and the slides in the movie would be correctly associated.

Faceless accessories have no associated window but nevertheless provide some useful capability. Examples of faceless accessories include call logging data compression encryption and protocol translation. Call logging can be used even where no other member has that capability. It might for example track the number of calls placed and received to whom and the disposition or length of the calls. Faceless accessory have no direct user interaction. Rather they remain independent of the application by monitoring messages moving through the accessory stack and taking action according to the messages. While in most cases the ordering of window associated accessories in the accessory stack can be arbitrary faceless accessories need to be at the bottom of the stack e.g. closer to the conference component . Moreover within a group of faceless accessories specific ordering is desirable. For example data compression should be performed before encryption. Moreover the ordering must be the same at both end points e.g. so that decryption occurs before decompression at the remote endpoint . Also significant is the fact that accessories communicate through a point to point link rather than through a multicast. This allows accessories to be used between any two conference members even if other members do not have that accessory capability. For example in a three way teleconference in which only two members have data compression. The two having data compression can communicate in compressed messages while not compressing the messages sent over the links to the third member.

The conference component allows the application to establish communications between two or more teleconference stations. Control information and media information can be transmitted between the first participant system and a second participant system. The conference component will be shown in more detail in . Conference component communicates with the transport component by sending MovieTalk messages for other teleconferencing stations which are encapsulated and placed into a form that the transport component the network component and the system network component can packetize and transmit over networking medium . For the purposes of the remainder of this disclosure certain of the API calls and messages which are transmitted between conference components in a teleconferencing system will be described in more detail.

The transport component and the networking component provide the necessary operations for communication over the particular type of network adapter and networking medium according to implementation. For example networking component may provide the TCP or ADSP protocols and packetizing according to those respective standards.

The conference component s main function is to establish and maintain a bi directional connection between every member of a conference. Conferencing applications use a preestablished control channel to exchange control data that is pertinent to the conference. This data might include user identification information or other information that is germane to the application s operation. Conferencing applications e.g. define the format and content of these control messages by establishing their own control protocols. The conferencing component further establishes communication channels between a first endpoint and a second endpoint using the underlying transport component . Thus once a media channel has been established the conference component uses the transport component s media channel which is provided for transmission of media and non media information.

The application program controls the accessories and conference component by the issuance of API calls. The conference component operates using an event driven model wherein events are passed serially through the accessories. If the event is pertinent to the accessory the accessory may consume the event. Otherwise it is passed through each accessory until it reaches the application. The application or accessory can then take appropriate action either by modifying internal local data structures and or issuance of appropriate messages over the network to other connected participants or potential participants. According to messages received by the conference component a current context and API calls from the application the conference component can take appropriate action. Two API calls which are particularly applicable to an accessory environment are MTConferenceGetError and MTConferenceSetScrapSynchronizationProc . When a certain error occurs the application may then make the MTConferenceGetError API call to determine the actual cause of the error. GetError API call will return the cause of the error and then clear the error. Such errors are for example when an accessory tries and is unable to create its window. The GetError call may then return an error code indicating e.g. insufficient memory. The Scrap Synchronization call handles the case where editing e.g. cutting and pasting is performed in the accessory windows. If the application maintains a private copy of the scrap the Scrap Synchronization must be used to ensure consistency during operations involving the scrap. To ensure the correct operation the application must update the system scrap since moving between the accessory windows will not generally cause an update as would be the case of moving between applications. Thus this call forces an update of system scrap. Other API calls relevant to accessories are discussed below.

Then during the teleconference session a variety of other events may be issued and acted upon by the conference component. These may include message events mode events incoming call events data transmission events etc.

Members leaving the conference result in the issuance of MemberTerminated events to the application program. Thus for every MemberReady event for any member participating in a conference there is a corresponding MemberTerminated event prior to the end of the conference. After the last member supporting e.g. file sharing issues a MemberTerminated event a Dispose Window event is issued followed by an Accessory Terminated. The conference terminated event signals the end of the conference illustrated in and that teleconference data should no longer be transmitted. Any additional clean up operations are then performed by the application and the source may be discarded.

Significantly the accessory only exists within the context of a teleconference. It is therefore subject to such limitations accepting a call if the call is not accepted which implies no ConferenceReady event the accessory never comes on line. In for example file sharing this prevents unauthorized access to files on a remote end point. Unlike the Unix protocol FTP in which a daemon always exists and it is only an issue of finding the password to gain complete access to the remote files the accessory only provides access to files explicitly posted and does not provide a facility for requesting files not posted. Moreover it does not allow files to be placed on a local endpoint by a remote member only the local member may make copy decisions for the local end point.

FileExchangeMessageArrived events correspond to the arrival of various messages between the file exchange accessories at the local and remote end point. Such messages may include data corresponding to a file being copied a MorePlease message or any other message sent between the file sharing accessory of a local and remote end point as discussed further below. File exchange copy status event corresponds to a change in the copy status of the file being advertised. Copy status changes when the file is copied by a member or when a member joins or leaves the conference. Finally file exchange PostingRemove event corresponds to the removal of the advertisement posted which generated PostingAdded event . It should be recognized that this is only one example of a possible series of events and innumerable other possible sequences exist.

A typical application s initialization is shown as process of . The application program makes a number of API calls in order to set various parameters associated with the member or potential participant. First an application may cause the conference component to set its capability at step if it is different than the default The call to MTConferenceSetMessageCapabilities causes the conference component to recall and store the capabilities of the application and all intervening accessories within the conference component which are later used during transmission of messages to alert recipients that the sender system has certain functional capabilities prior to the establishment of a connection between the sender and the receiver. Each accessory adds its capabilities to the arguments of the API call before passing it along.

Each capability has associated with it a type version and desire of the capability. Each desire for each capability type may be flagged as 

These types of capabilities are included in a capabilities list which is transmitted to endpoints as will be described below. An optional capability is a message which is not required to be exchanged before setting up a conference. A desired capability is one which is not required that it be exchanged before setting up a conference however it is preferred that it is. A required capability is one which requires that a message be exchanged before setting up a conference. This may include access control or other messages which are transferred prior to setting up a conference. An access control capability may include the transmission of a account number and password prior to the commencement of a teleconference. An accessory capability is provided by an accessory that has been accessorized. If a corresponding accessory exists in a remote member the capability will be employed. A negotiation message is a capability which indicates that the application wishes to query the receiving application regarding installed hardware or software functionality information about the applications prior to the establishment of a conference. Any other types of exchanges which require negotiated information between applications may be set. Once all individual capabilities have been set by the issuance of Set Capabilities API calls to the conference component at step . The application may restore previously saved setting by calling MTConferenceSetSettings . MTConferenceSetAccessoryOptions can be called to set the accessory options discussed below in connection with . Then a member may set its operating mode at step . The mode will be contained within a mode mask value which is sent in the API call to the conference component and moreover is included in certain messages transmitted from the conference component in the sender to the conference component in the receiver. The mode mask specifies the characteristics of a conference that the member makes available. Different capabilities modes and other initialization values shown in may be set for any number of conference types which are made available by the member. At any rate the default mode includes the following values 

The send media mode flag indicates that the member intends to send media data in its conferences. Most members will want to send media however there will be instances where the member will be a receive only member thus the send media mode flag will not be set. The receive media mode flag indicates that the member intends to receive media in conferences. In the case of a send only member e.g. a server providing a real time video and or audio source will have the receive media mode flag set to off e.g. a numeric value 0 . The shareable mode flag indicates that the member is willing to share the conference media data with new conference members. Thus in the instance of a send only media server the shareable mode flag would be set indicating that new members can receive the conference data.

The joiner mode flag indicates that all conference members are allowed to interact. This would allow two way transmission between each of the conference members. However the setting of this flag to off e.g. a numeric value 0 results in broadcast type conferences wherein one member sends media data to other conference members but the individual conference members do not exchange any media data among themselves. Each of these mode flags is transmitted at the beginning of a connection e.g. contained within the hello message in .

By default the conference component establishes conferences that are fully two way media data capable shareable and joinable. If different characteristics are desired then the application must call set mode at step along with the appropriate flag s set. Conference mode settings are stored and associated with a particular conference ID in the sender s conference component so that when messages are created for that conference ID the appropriate mode flags are transmitted along with the initialization or other messages sent before any other communications.

In addition to the capabilities and mode settings at steps and a time out value associated with calls placed from the member may be set. The time out value is then included at the beginning of certain messages preceding a conference in order to enable a recipient to determine when the caller will stop listening for responses. This allows certain features to be incorporated into participant conference components such as the smart triggering of events based upon context. For example if the recipient is receiving a call but a user does not wish to take the call at that time the recipient s conference knows the time out occurs and can take certain context dependent action e.g. forward the call send a message etc. .

The application can then invoke an API call Listen for Call which implements steps and . At step using the underlying transport to which the system is connected a high level address is registered and published. This then allows other potential participants in the system to call the member. The registration and publication of the address is implementation dependent depending upon the media to which the system is connected. Then at step the conference component waits for incoming calls.

The conference component in the member enters an idle state wherein incoming messages alerts for the transport component API and calls will be detected and acted upon. Note that the capabilities mode and time out values are all optional and the default settings may be used by the member if none of these functions is required by the application. In the call to the MTConferenceListen function the application must specify the networks on which the member is willing to accept calls. The conference component proceeds to register the member on those networks doing whatever is appropriate in the various network contexts and sends an MTListenerStatus event to the application to specify whether the registration attempt was successful. After listeners are operational if another application desires to establish communication with the application then an MTIncomingCallEvent is forwarded to the application.

At functional block MTConferenceActivateAccessory is called to activate the accessory. At decision block a determination is made if the activated accessory is associated with a window. If there is a window associated the accessory then creates a window at functional block having a size and location. Then MTConferenceSetWindowAttributes is called at functional block to establish the attributes including window associate conference associated member and owner of the window. Subsequent manipulation of the window results in a setting of the window event flags including a resize flag a moved flag a hidden flag and a disposed flag.

If at decision block it is determined if the requested fork type is a comment for the advertised file a determination is made at decision block of whether or not a comment exists. If no comment exists the reply length is set to zero at functional block . If a comment does exist the comment is fetched into the reply buffer at and the reply length is set to the length of the comment at functional block . Then the reply with either zero length or the comment is sent to the requesting end point as a message in functional block . Kill copy with normal status is then called at functional block . If at functional block the copy structure is not found or following functional blocks or the routine terminates.

If at decision block it is determined that the reply is a comment the comment is associated with the file and saved at functional block . At functional block kill copy with normal status is called. If the copy structure is not found at decision block no error in writing occurred at decision block after either kill copy is called or if size equals zero at decision block the routine ends.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. Therefore the scope of the invention should be limited only by the appended claims.

