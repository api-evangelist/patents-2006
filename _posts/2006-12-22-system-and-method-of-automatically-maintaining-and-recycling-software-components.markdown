---

title: System and method of automatically maintaining and recycling software components
abstract: In one aspect of the disclosure, a computer program product, system and method for maintaining and recycling software components is disclosed. A first set of usage data for one or more software components is recorded. At least one of the plurality of software components is automatically removed if the first set of usage data for the at least one software component meets usage criteria specified in an expiration policy. Access is then provided to the removed software component through a remote server. A second set of usage data is now recorded for the removed software component. The removed software component is automatically re-instated if the second set of usage data meets usage criteria specified in a re-instatement policy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07590599&OS=07590599&RS=07590599
owner: International Business Machines Corporation
number: 07590599
owner_city: Armonk
owner_country: US
publication_date: 20061222
---
The present disclosure generally relates to a method apparatus and computer usable code for recycling software components. More particularly the disclosure relates to automatically retiring software components based on usage level.

Conventional software architectures tend to be planned ahead and rigid not flexible and resilient enough to adapt to the fast requirement changes. They are not made to deal with changes other than the pre determined set of IF THEN conditions. Software design assumes all variables would have been considered before the system is deployed.

In reality since changes are not 100 predictable software must be periodically revised and updated. Therefore software is often updated with new releases or patched to cope with changes. A patch is a small piece of software designed to update or fix problems with a computer program. This includes fixing bugs replacing graphics and improving the usability or performance. Though meant to fix problems poorly designed patches can sometimes introduce new problems aka. software regressions .

There are several methods of updating software. Old software can be uninstalled or removed and new software installed in its place. This is time consuming and involves downtime. Alternatively software can be upgraded which involves adding onto the already existing framework.

Deployment of new software releases tends to cause system down time and service interruption. Release cycles also cause stress on the software development process as shown in the pressure of handling defects near the end of every release and the leisure of reinventing the wheel in the beginning of a release cycle. Software needs to change more constantly smoothly and with less interruption.

Componentization and plug in framework infrastructures make it possible to update software with on demand augmentation such as the software updater on Eclipse and Microsoft Windows automatic update. Microsoft Windows Windows NT and the Windows logo are trademarks of Microsoft Corporation in the United States other countries or both. Still a consequence of such augmentation is that the user s system gets larger and larger with time not only in the sense of software foot print but also the complexity. We call this problem software obesity.

In one aspect of the disclosure a computer program product is disclosed. The computer program product includes a computer useable medium that has a computer readable program. The computer readable program when executed on a computer causes the computer to record a first set of usage data for one or more software components. The computer readable program further is configured to automatically remove at least one of the plurality of software components if the first set of usage data for the at least one software component meets usage criteria specified in an expiration policy. Further the computer readable program when executed on the computer causes the computer to provide access to the removed software component through a remote server. The computer readable program when executed on the computer further causes the computer to record a second set of usage data for the removed software component. The computer readable program is also configured to re instate the removed software component if the second set of usage data meets usage criteria specified in a re instatement policy.

In another aspect of the disclosure a computer program product is disclosed. The computer program product includes a computer useable medium that has a computer readable program. The computer readable program when executed on a computer causes the computer to record usage data for one or more software components. The computer readable program further is configured to automatically remove at least one of the plurality of software components if the usage data for the at least one software component meets usage criteria specified in an expiration policy. The computer readable program further is configured to provide access to the removed software component through a remote server.

In another aspect of the disclosure a system for maintaining software components is disclosed. The system comprises a usage data recording module for recording data regarding the usage of a plurality of software components installed within a local environment and storing the data as usage data. The system further comprises a pruning module for comparing the usage data with an expiration policy and automatically removing at least one of the plurality of software components from the local environment if it is determined that usage of the software component is below a level specified in an expiration policy. The system further comprises a remote access module for relocating the removed component to a location remote from the local environment and providing future access to the removed component.

In yet another aspect of the present disclosure a method for maintaining software components is disclosed. The method includes recording a first set of usage data for one or more software components. The method further includes automatically removing at least one of the plurality of software components if the usage data for the at least one software component meets usage criteria specified in an expiration policy. The method further provides access to the removed software component through a remote server. The method of maintaining software components further involves recording a second set of usage data for the removed software component. The method further includes re instating the removed software component if the second set of usage data meets usage criteria specified in a re instatement policy. In one aspect usage data comprises a length of time since the last use of the software component. In another aspect usage data comprises a number of times the software component has been accessed. In yet another aspect the usage data comprises information regarding utilization of hardware resources by the software component. In one aspect the usage data is stored as metadata.

The expiration policy can be a global expiration policy and applies to all or a group of the plurality of software components. Alternatively the expiration policy is an individual expiration policy and applies to an individual software component. In one aspect the expiration policy is set by a user.

In one aspect the usage criteria specified in the expiration policy is a length of time and the usage data meets the usage criteria if the length of time since the last use of the software component is greater than the length of time in the usage criteria. In another aspect the usage criteria specified in the expiration policy is a number and the usage data meets usage criteria if the number of times the software component has been accessed is less than the number in the usage criteria.

In one aspect removing the software component comprises un installing the software component. In one aspect access to the removed software component is provided through a remotely run web service running on a web server. In one aspect re instating the removed software component comprises re installing the software component.

An automated approach to maintaining software components based on usage can be implemented. Since a user s software system can not be placed on a diet due to increasing functional demands the solution is to actively prune or archive components based on demand and usage. Software systems can change gradually by adding or replacing components and pruning unwanted ones depending on the change of requirements.

A customer utilizes software components produced by the vendor . For example customer may be a company which sells products and uses the vendor s software to facilitate selling their products. The customer similarly maintains its own software component repository customer component repository . The customer can select the components it needs from the vendor s repository and store them in it s own company component repository . The customer s software components are indicated by the cells within block . In this example the customer selects only components W X Y and Z from the vendor s repository . The vendor component repository is preferably accessed by the customer component repository through a network connection or the Internet.

In one aspect as the vendor updates components within its vendor component repository corresponding software components are updated within the customer component repository . For example consider component Y is updated by the vendor to address a performance issue. Updated component Y is stored in the vendor s repository and component Y in the customer s repository is automatically updated to reflect the changes made. This can be accomplished by downloading the newly updated component through an Internet connection between customer component repository and vendor component repository .

Furthermore each customer may comprise a plurality of clients which utilize various software components from the software component repository. Each individual client system in the company can download desired components to the infrastructure that can host the components e.g. download a plug in to Eclipse or a Windows component. For example three clients and are illustrated in each utilizing a different set of software components. Client has selected and installed components W X Y and Z from the software component repository. Client has selected components X and Y. Client has selected components X Y and Z. In this example clients and may be individual desktops of laptop computers used by employees of the company.

In another embodiment the clients can retrieve software components directly from the vendor component repository eliminating the need for an intermediary customer component repository . For example a client may be a personal home computer and directly download and install software components from a plurality of various software component repositories accessed through an Internet connection. Clients may be any computing device including but not limited to desktop laptop computers cell phones handheld devices or PDA s set top boxes server etc.

With time the company s repository and client systems will grow and become larger and larger. The growth will add overhead to footprint and component management. How can the system clean itself and remove less used components In other words what is the pruning mechanism to prevent system obesity The solution proposed by the present disclosure involves automatically retiring existing software components if they are determined to be less in demand based on the usage level and or usage pattern.

In one embodiment this is accomplished through a simple mechanism such as associating an expiration policy with one or more software components. For example a software component that has not been used for a long time can be set to automatically retire. Therefore the expiration policy can specify a length of time the component can go without use before being retired. As another example a software component that has been called or used only a few times can be set to automatically retire. In this case the expiration policy may specify a number of times the component is accessed below which the software component should be retired.

Several examples of a system and method for automatically maintaining software components based on usage are explained with reference to . As mentioned above with reference to for exemplary purposes three clients and are illustrated each client having downloaded and installed various components from the customer component repository .

In order to implement such a system and method of automatically maintaining software components based on usage usage data regarding each of the software components is recorded. For example a process running on the client monitors the use of the software components installed on the client and data regarding the usage of each software component as usage data. In this example clients and record usage data as indicated at blocks and respectively. In one aspect the usage data is stored as metadata. The usage data as indicated at and may be stored as a single file or a plurality of files and the data file can be of any type.

Usage can be measured in a number of ways. Usage could be recorded as a length of time since the software component was last used. Therefore software components that have not been used for a long period of time could be set to retire according to an expiration policy. Usage could simply be measured by the number of times the software component was called or accessed. Usage could also be measured by the number of clients or users which access the software component. For example a software component could be used by only one person many times or by many different people but accessed infrequently. Alternatively usage could be measured by the hardware resources utilized by a software component such as memory usage hard disk space processor usage or bandwidth usage.

As mentioned above an expiration policy is specified. The expiration policy contains rules or criteria regarding the usage level above or below which a software component can be set to retire. In clients and each have their own expiration policies and respectively. In one embodiment the expiration policy may specify that if a software component has not been used for a predetermined period of time e.g. number of days it should be retired. In another embodiment the expiration policy could specify that usage below a certain level results in the software component being retired. The expiration policy may use a combination of different measures of usage to determine if a software component should be retired. For example the expiration policy might specify a combination of length of time since last use and the number of times the accessed.

The expiration policy can be a global expiration policy an individual expiration policy or a combination of both. For example a global expiration policy could apply to all or a group of software components. An individual expiration policy could also be set to apply to individual software components. A combination of both a global expiration policy and an individual expiration policy may also be used. For example a global expiration policy might apply to all software components except for those components where an individual expiration policy is specified in which case the individual expiration policy takes precedent. The expiration policy can be set by the vendor the customer the client or by the user. Therefore in one aspect each client user can set his or her own preferences as to when software components should be automatically set to retire. For example one user may want software components to automatically retire with no use after months while another user may prefer to set the time limit to weeks.

In addition to an expiration policy other types of policies can be set which govern the retirement of components. For example an individual expiration policy could specify that a core infrastructure component will never expire regardless of how rarely it is used.

In one aspect each client records its own usage data and sets its own expiration policies. For example client has downloaded and installed software components W X Y and Z from the software component repository . Client is configured to monitor the software components installed on its system and record usage data related to the usage of each of its installed software components. Furthermore client is configured with an expiration policy regarding the installed software components. The expiration policy may be initially set as a generic expiration policy and later be revised by the user according to his or her preferences. Consider an example of usage data as recorded by client indicates the following 

The usage data indicates that software component X was last used more than three months ago while the other software components were recently used. An expiration policy could therefore be set to automatically expire component X.

In another aspect the software component repository itself can maintain and recycle its own software components in a similar way as each of the clients. Therefore in one aspect customer component repository records its own usage data and has its own expiration policy . For example the usage data and collected by each of the plurality of clients can be collected by the customer repository and analyzed as a whole. Consider for example that usage data indicated that a particular component component W has not been used in a while by the group as a whole clients and collectively . For example in component W is only utilized by client and not by clients and . Therefore it may be determined that the software component should be retired from the software component repository altogether. The customer component repository could collect the usage data from the plurality of clients in this example clients and and determine that component W is not used enough to justify keeping it in the repository.

In one aspect the act of retiring a software component involves removing or uninstalling the component. However because there is no guarantee that a retired component will never be called again it is preferable that access to the component still be provided. Therefore in one embodiment the component is wrapped as a web service and is made accessible from a remote location such as an intranet server. In an unlikely event the retired service is called again by a client the component just runs remotely as a web service with slower performance.

Generally a component has an interface or application programming interface API that demonstrates its behavior. Other components can call this component using its interface without knowing the detailed implementation of this component. The interface can be used by a web service wrapper to wrap the component into a Web Service. For example an Extensible Markup Language XML based protocol such as Simple Object Access Protocol SOAP can be used to provide access to components through HyperText Transfer Protocol HTTP . SOAP provides a way to communicate between applications running on different operating systems with different technologies and programming languages. Therefore a web service wrapper places a SOAP envelop around the interface to transform the request response to from the component into XML messages.

Alternatively a Web Service Definition can be produced in WSDL Web Service Definition Language which can be used to generate a proxy client which invokes the service component. Various transport protocols are supported by Web Services with http being the most popular. Other technologies can of course be used to convert components such as a database stored procedure into a web service. Alternate methods of invocation beyond Web Service invocation include Remote Procedure Call RPC or CORBA component model invocations.

A more complex mechanism can also be used to determine when software components should be retired. One more complex mechanism involves recording a component s usage history dynamically in its usage data and using the usage history to calculate statistical patterns. For example a software component named DISCOUNT may tend to be used heavily right after Christmas and the end of each quarter. However the rest of the year it is rarely called. The system uses this historical pattern statistics to dynamically move the component in and out of the system. When the discount season is over the software component is retired and put on reserve as a Web Service on a server. The metadata can be located in either the local system or a remote repository or both. When the discount season approaches again the software component can be brought back to the local environment and reinstalled. The same mechanisms can be used to prune shared components in the company s component repository.

These mechanisms guarantee that a software system remembers its components usage history and can recall backward versions of components on demand. Therefore backward compatibility can be resolved. Calling components on reserve will cost extra time and impact system performance but it will reduce system breakage and prevent many Null Pointer errors.

The history metadata can also be pruned using the same mechanisms mentioned above which requires the creation of another layer of metadata for the history metadata. This cycle of creating metadata layers promotes the scalabilty of the above mentioned mechanisms however in reality extra layers of metadata will inevitably slow down system performance.

Another aspect of the system and method of automatically maintaining software components is the ability to re instate software components that have previously been retired. For example once a component has been retired from use if the usage is frequent or heavy enough depends on user s policy then the component should be brought back or reinstalled. A software system can therefore adapt to its usage environment through a concept of recycling software components putting them in storage when they are not being used often enough and retrieving them from storage when they become useful again.

For example a retired component which was made remotely accessible through a web service can be converted back to the native component just the reverse process of the above mentioned web service wrapping process of components. This does not mean the web service will be deleted. Both representations of the component can exist in different places as a remote web service or as a native component locally. It is up to user s policy whether to keep both representations.

This may be particularly advantageous for smaller portable computer devices. Only frequently used components will stay local extra ones not used often get pushed remotely. This way a wireless device can be small and light but also powerful. Also different users devices can behave quite differently based on the users usage patterns.

The usage of a plurality of software components installed on a system is monitored and data regarding the usage of each of the software components is recorded. The step of monitoring usage of various software components within a system is indicated at block . The usage data is then stored as is indicated at block . In one aspect the usage data is stored as metadata and associated with one or more software components. The usage data is then analyzed in view of an expiration policy as indicated at step . The expiration policy may be a global expiration policy applying to all or a group of software components or an individual expiration policy applying to individual software components. Usage data for each individual component is compared with the applicable expiration policy applying to that component. This may involve comparing more than one expiration policy e.g. a global and an individual expiration policy. A determination regarding whether or not the criteria specified in the one or more expiration policies is met by the usage data at block . If it is determined that the criteria specified within the expiration policy has been met then the component is retired as shown at block . In one aspect retiring a component involves removing or uninstalling the component from the system. In order to provide continued access to the component in the case it is called again the component is then made available through some other resource. For example in one aspect the component is moved to a remote location such as a web server and access is provided through a web service. The step of providing remote access to the component after being retired is indicated at block .

However usage of the retired component can still be monitored and the software component can potentially be re instated if usage of the retired component warrants. Therefore the usage of the retired component via remote access is monitored and usage data related to the retired component is stored . A re instatement policy is used to determine if the usage warrants re instatement of the retired component. The re instatement policy is similar to the expiration policy. Therefore the usage data is analyzed in view of the re instatement policy and if the usage data meets the criteria specified in the re instatement policy then the retired component can be re instated as indicated at block . In one aspect re instatement involves re installing the software component on the local environment. Once a component has been re instated the cycle starts again.

The processor is coupled either directly or indirectly to the memory through a system bus. The memory can include local memory employed during actual execution of the program code bulk storage and or cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

The I O devices can be coupled directly to the system or through intervening input output controllers. Further the I O devices can include a keyboard a keypad a mouse a microphone for capturing speech commands a pointing device and other user input devices that will be recognized by one of ordinary skill in the art. Further the I O devices can include a receiver transmitter speaker display image capture sensor biometric sensor etc. In addition the I O devices can include storage devices such as a tape drive floppy drive hard disk drive compact disk CD drive etc.

Network adapters may also be coupled to the system to enable the system to become coupled to other systems remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

It should be understood that the method and system described herein can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. If software is utilized to implement the method or system the software can include but is not limited to firmware resident software microcode etc.

Further the method and or system can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purpose of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a RAM a ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include CD read only memory CD ROM CD read write CD R W and DVD.

While the apparatus and method have been described in terms of what are presently considered to be the most practical and preferred embodiments it is to be understood that the disclosure need not be limited to the disclosed embodiments. It is intended to cover various modifications and similar arrangements included within the spirit and scope of the claims the scope of which should be accorded the broadest interpretation so as to encompass all such modifications and similar structures. The present disclosure includes any and all embodiments of the following claims.

