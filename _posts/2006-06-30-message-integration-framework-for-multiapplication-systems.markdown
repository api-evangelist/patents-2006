---

title: Message integration framework for multi-application systems
abstract: A system and method for integrating messages across multiple applications. The applications may be on one server or on several servers, and each application may service one or more e-clients. The system and method securely segregates the data for each e-client. Further, the system can be dynamically reconfigured by adding or deleting new messages and/or applications, without affecting the performance of the unchanged parts of the system. The various applications using the system need not be aware of the existence of the other applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07712107&OS=07712107&RS=07712107
owner: Fair Isaac Corporation
number: 07712107
owner_city: Minneapolis
owner_country: US
publication_date: 20060630
---
This application is a continuation of U.S. patent application Ser. No. 09 915 492 now U.S. Pat. No. 7 093 261 filed Jul. 25 2001 which claims benefit of U.S. provisional application Ser. No. 60 222 094 filed Jul. 28 2000 entitled Method and Apparatus for Integration Framework which applications are herein incorporated by reference in their entireties.

The present invention generally relates to middleware systems and more particularly to middleware systems that use databases to configure the integration of various applications.

Vast amounts of data are stored transmitted and manipulated in today s Internet driven world. Organization of this data so that information can easily be accessed is thus an important need. Huge amounts of data are often organized in databases. Such stored data often cuts across several databases and other applications that may support a business and several customers that an Application Service Provider ASP may service. The customers serviced by an ASP can be referred to as e clients. 

A single e client often uses various applications. For example an e client may have an Automatic Call Distributor ACD that is used with an Interactive Voice Response IVR system to direct customers of the e client to particular customer service representatives that have expertise in a particular area. Further the e client may have a web page which allows its customers to enter into interactive sessions on the web page and learn more information about products and support issues. Further e mail can be used by e clients to contact their customers and for customers to contact the e client business regarding sales and support issues. Such an e client may use an IVR application a web application and an email application.

These various applications may be on a single server or on various different servers. In either case it is desirable to be able to exchange messages between applications and to route these messages accurately from one application to another regardless of whether the applications reside on a single server or on different servers.

In some conventional systems this problem is handled by specifying a configuration file for each application. The configuration file for an application may specify where messages sent by the application are to be delivered. However when such application specific configuration files are used it is difficult to dynamically modify or update the system. Any time a change needs to be made for example a new e client is to be added each of the configuration files for each application on each server need to be updated accordingly.

Another issue arises in systems that integrate multiple applications. Conventionally each application needs to be aware of the existence of the other applications. Each application also needs knowledge of which server the other applications are using and so on in order to route messages to these other applications. One of the problems with such a system is that any time a new application is added or deleted each of the other applications needs to be modified to reflect that change. Dynamic addition or deletion of applications while the rest of the applications continue to function in a normal manner is not possible.

Some conventional applications eliminate this issue by providing a central message processing hub which each application is aware of. However the hub solution has another drawback which is that each message must first be sent to the hub for processing then re sent by the hub to the ultimate destination of the message and this is inefficient.

In addition several e clients may use each of these applications. Thus it is important to keep data for each e client secure and not allow it to be accessed by any other e clients. It is thus often desirable to segregate data regardless of what application requires that data.

There are two ways in which conventional systems deal with this problem. One approach entails having applications which themselves support partitioning of data. However this approach implies that only applications that have this partitioning capability can be used. Since not all applications possess this capability systems employing this approach are restricted in the applications they can support.

The second approach entails using separate servers for separate e clients. However this approach often results in the increased use of hardware and or software and is thus expensive and cumbersome. Hosting multiple e clients on a single server and or using the same software instances of applications for different e clients is more economical.

Thus what is needed is 1 a system and method for enabling the configurable exchange of messages between applications regardless of the servers on which these applications may reside 2 a system and method for centralizing control of message exchange but which distributes the message processing to the applications which produce and consume the messages 3 a system and method for integrating multiple applications where the various applications do not need to be aware of the existence of the other applications and 4 a system and method that segregates data for multiple e clients and multiple applications.

The present invention is a system and method for enabling the configurable exchange of messages between applications regardless of the servers on which these applications may reside. The present invention centralizes the control of the messages but distributes the processing to each application so that a separate message processing hub is not needed. Further the present invention is a framework for integrating applications where the various applications do not need to be aware of the existence of the other applications. In addition the present invention is a method and system for segregating data for multiple applications and multiple e clients.

An integration framework in accordance with an embodiment of the present invention is a software topology that has a number of different characteristics such as what server an application resides on what e client it is servicing etc. The present invention is database driven and the various relationships for the different data entities are modeled into the database. The functionality of the system is driven by the database model and by the applications which send and receive messages which adhere to the rules that are in the database.

In one embodiment the following data entities are included in the data model application partition metadata host message queue and queue manager. These various data entities and their relationships with each other which are represented by the entities app instance app partition and app message are stored in the database. The various applications in the integrated framework communicate with each other through Message Oriented Middleware MOM modules. In one embodiment these MOM modules have two layers. One of these layers is specific to the application with which the MOM module is coupled while the other layer is a layer common to all the MOM modules. This common layer communicated with the database mentioned above and with the MOM system also known as the message bus.

In one embodiment of the present invention the structure of the data model is such that when the application topology is updated in the database the message routing schema is automatically updated accordingly. In addition messages applications servers etc. can be added or deleted from the system without affecting the operation of the other unchanged parts of the system.

Different embodiments of the present invention are now described with reference to the figures where like reference numbers indicate identical or functionally similar elements. Also in the figures the left most digit of each reference number corresponds to the figure in which the reference number is first used.

In one embodiment of the present invention the applications are standalone applications. An application can be a standalone application having an MOM module . An example of such an application is a unified administration application. An application can also be a third party application where the application s Application Programming Interface API is used to interface with the MOM module . Some examples of such applications are Octane from Epiphany San Mateo Calif. WebLine from Cisco Systems San Jose Calif. and Kana from Kana Communications Redwood City Calif. . The application can also be an unmodified third party application. Such applications could include reporting and email applications. Further application can be a service application modified to use the MOM module . Such applications can include monitoring control logging and or error handling applications. Moreover an application can also be a custom application which uses the MOM module . Such custom applications can include blending applications and Graphical User Interface FUI managers. In addition an application can be a normal system service application. Such an application could include time applications security applications and directory applications. These applications can all be on the same server or can all be on individual servers. Alternately some of the applications could share servers while other applications reside on separate servers.

These applications communicate with each other through a message bus on a network . The message bus provides the ability for exchanging messages between applications. In one embodiment the message bus is a commercial Message Oriented Middleware product such as the MQSeries product from IBM Corporation Armonk N.Y. . In one embodiment the network could be a Local Area Network LAN . In another embodiment the network could be a Wide Area Network WAN .

In the embodiment shown in the applications communicate with the message bus through Message Oriented Middleware MOM modules . In other embodiments applications may also communicate with each other across a network. In still other embodiments applications may also use Operating Systems OS interface. That is an application may use a standard call across the network initiated by the application.

The MOM Modules interact with the database . The MOM modules read the configuration database and query it for information regarding message routing. is a block diagram illustrating the structure of a MOM module in some detail. illustrates that a MOM module is comprised of two layers an application adapter layer and a message adapter layer . The application adapter is specific to each application that the MOM module interfaces with and is based on the Application Programming Interface API provided by the application . The message adapter is the part of the MOM module that communicates with the database to determine the routing of messages sent and received by the MOM module .

The database stores data regarding various applications and their characteristics. In one embodiment the database stores the relationships between the physical servers hosts applications messages and message queues to define the flow of messages in the system. In addition the one embodiment the characteristics of the applications are reflected in the database . For instance the database may specify that Application A must reside on its own separate server or that Application B can only support one partition of data. In one embodiment of the present invention a partition is a subdivision of the system as a whole to be used by a particular e client. In one embodiment a partition and an e client have a one to one relationship. That is one e client has only one partition and one partition corresponds to a single e client. In other embodiments an e client may have more than one partition associated with it.

Further the database defines the messages used the relationship of the system components to each other and the routing of messages. The use of the database provides great flexibility of message routing in a system in accordance with an embodiment of the present invention. Addition of messages or deletion of existing messages is controlled by the database and the applications which use the messages. Neither the MOM modules nor the database needs to be recompiled to add data entities in the database such as Hosts Applications Queues Queue Managers etc. Messages and MetaData can also be added modified or deleted without redesign or recompilation of a system in accordance with one embodiment of the present invention. Further in one embodiment these changes can be made while the system is in use without affecting the operation of other unchanged parts of the system.

In one embodiment of the present invention the database is centralized. In other embodiments the database can be distributed across various servers.

The data model on which the database is based in one embodiment of the present invention is illustrated in . illustrates the following data entities Partition MetaData Application Message Host Appinstance AppMessage AppPartition Queue Queue Manager . Each of these data entities is described below. The collection of these data entities and their correlations defines the way in which messages flow between applications .

In the embodiment illustrated in Partition defines one e client of the system. MetaData defines data which is used to uniquely identify a specific e client. In one embodiment this is in addition to the e client Name which is only one way to identify the e client. The MetaData is used to uniquely identify the e client. MetaData is a component of the message format described below and is used to determine initially what partition a particular message is intended for.

The data entity Application defines the software applications which comprise the system. Various applications have been discussed above with reference to . Message defines the messages by a unique message id which flow through the system. Host defines the physical servers on which Applications may be hosted.

Appinstance defines the relationship between Hosts and Applications . Each Appinstance represents an instance of a software application running on a host. A many to many relationship exists between the Hosts and Applications and the Appinstance data entity is the database modeling method used to implement that relationship. For example many Applications could be running on one Host and one Application could be running on many Hosts .

AppMessage defines the relationship between Messages and Applications and AppMessage is the database entity used to implement that relationship. For example many Applications could be associated with one Message and one Application could be associated with many Messages .

AppPartition defines the relationship between AppInstances and Partitions . A many to many relationship exists between the AppInstances and Partitions and AppPartition is the database entity used to implement that relationship. For example many AppInstances could be associated with one Partition and one Appinstance could be associated with many Partitions .

Queue defines a repository for messages sent and received by an application. Queue has a many to one relationship with AppPartition and a many to one relationship with QueueMgr . That is many Queues may be associated with an AppPartition many Queues are associated with a QueueMgr . In one embodiment a Queue Manager Name and Queue Name uniquely identify a queue for sending and receiving messages. QueueMgr defines a special software application the Queue Manager running on a Host . The QueueMgr is required to send and receive messages for Applications on a Host and a many to one relationship exists between QueueMgr and Host i.e. many QueueMgrs may be associated with one Host . In one embodiment Queues and Queue Managers are third party commercial software products.

In one embodiment of the present invention the messages to be routed in the system are direct messages from one application to another. In another embodiment the messages to be routed in the system are broadcast messages to multiple applications . In yet another embodiment direct messages as well as broadcast messages are to be routed. Regardless of what type of messages are to be routed in a system the messages follow a certain message format.

In one embodiment the message format consists of keyword value pairs. The use of keyword value pairs permits great flexibility in the messages and also eliminates the need for multiple nearly identical messages used by different applications. If two applications use essentially the same message with one keyword difference then one message can be defined with the superset of keywords used by each application and when a message of this type is received by an application the application can use the keywords relevant to it and discard the others. Further there is no need for a specific ordering of keywords. Since the keywords themselves are contained in the message any application using the message can search the message for the keywords rather than needing a fixed ordering of the data in the message.

In one embodiment certain keywords are required to be in a message while other keywords are optional. The mandatory keywords are used by the system to determine how to handle the message. In one embodiment these mandatory keywords are those shared in common between multiple messages and those which affect the routing of messages in the system.

In one embodiment of the present invention the mandatory keywords are AppID MessageID and MetaData. The MessageID is used to uniquely identify a message. MetaData is used to uniquely identify an e Client. These two keywords are inserted into the message by the MOM Module . Other keywords such as PartitionID and AppInstanceID are derived from the AppID MessageID and MetaData by the MOM module by communicating with the database . This is discussed in greater detail below with reference to .

In one embodiment of the present invention some of the more commonly present optional fields include CustomerID Media Unique Identifier MediaUID Global Unique Identifier GUID MessageID and DateTimeStamp. CustomerID is the source application the application which the MOM Module connects to identifier for the e Client which the data in the messages belongs to where applicable . MediaUID is a unique identifier which is provided by the source application. It is carried in the message in case the source application needs it later for example in a response to a request message . GUID is a system wide Global Unique Identifier which uniquely identifies a specific instance of a type of message. MessageID is the identifier of the type of message for example a RequestAgent message . DateTimeStamp is the date and time the message was generated.

A system in accordance with an embodiment of the present invention is a dynamically configurable system. The use of the database provides great flexibility of message routing in the system. Addition of messages or destinations of existing messages is completely controlled by database and the applications which use messages. Further the MOM modules do not require recompilation to add Hosts Applications Queues or Queue Managers to the system. Moreover in one embodiment Messages and MetaData can also be added modified or deleted without redesign or recompilation of a system in accordance with an embodiment of the present system. In addition in one embodiment these changes can be made while the system is in use without affecting the operation of other unchanged parts of the system.

These aspects of the various embodiments of the present invention can be better understood with the help of an example. is a diagram which illustrates an example of a topology of a number of different applications running on different hosts for different partitions some of which overlap in various ways. The diagram in represents data in accordance with the data model in . The topology in consists of four hosts four partitions seven applications nine app partitions seven app instances and four queue managers .

The dotted lines in indicate different partitions which may cross multiple hosts and applications . The applications shown in are Octane AppID 1 Kana AppID 2 eGain EMS AppID 3 WevLine MB AppID 4 EIC AppID 5 TEST  AppID 6 and TEST  AppID 7 . The partitions are SwitchSoft Partition ATN Partition Partition and TestPartition Partition . It can be seen from that some of the applications are used by more than one partition . For instance the EIC AppID 5 is used by two partitions Partition and Partition . Thus there are two app partitions corresponding to the EIC application EIC QA and EIC QB. Also one host can have multiple partitions. For instance Host supports both Partition and Partition. Finally a single partition can overlap across various hosts. For instance Partition overlaps across Host Host and Host.

An example of the data that can be stored in the database in accordance with the datamodel illustrated in follows.

In one embodiment several views can be created using the data in the tables above. Apart from the data entities illustrated in the created views can also be queried to obtain information. In one embodiment the following views are created 

For a system with a database with the above data entity tables and views a query against the Qmgr Qname view with the parameters of MsgID 1010 and MetaData Development returns this information 

The single row result set from the query indicates that in this example there is one destination for the message given that metadata 

This uniquely identifies the destination for the message id and metadata combination. A simple change in configuration for example making a new assignment of an existing message to an existing application results in adding a row to the AppMessage table like this 

This results in a change in the data returned by the views with the ultimate result that a query against the Qmgr Qname view returns this information 

Another example involves a more complex configuration. In this example adding a new message results in two changes. The first change is the addition of the message to the message table 

The second change due to the addition of a new message is the addition of the message to the AppMessage table defining which applications this message is routed to 

This also results in a change in the data returned by the views with the ultimate result that a query against the Qmgr Qname view with the parameters of MsgID 8000 and

Another query given AppID which is compiled into the Application Adapter and HostName determines the Queue Manager Name and Queue Name on which incoming messages are received for an AppPartition . Any messages received on this queue or set of queues are automatically delivered to the Application Adapter which provided the information for the original query. is a dataflow diagram which illustrates this interaction between the MOM modules and the database .

Referring to it can be seen that various modules of the system are represented along the X axis and time is represented along the Y axis time increasing downwards. The modules shown in are the application adapter the message adapter and the database .

The application adapter supplies the MessageID and the MetaData in the message to the message adapter layer. The message adapter then queries the database with this data. Next the database returns data to the message adapter . This data includes the QueueManagerName and the QueueName. The message is then passed to the message bus . In one embodiment this message is sent via a MQSeries API call.

While particular embodiments and applications of the present invention have been illustrated and described it is to be understood that the invention is not limited to the precise construction and components disclosed herein and that various modifications changes and variations which will be apparent to those skilled in the art may be made in the arrangement operation and details of the method and apparatus of the present invention disclosed herein without departing from the spirit and scope of the invention as defined in the following claims.

