---

title: Policy setting for client-side caching
abstract: An improved method and system for client-side caching that transparently caches suitable network files for offline use. A cache mechanism in a network redirector transparently intercepts requests to access server files, and if the requested file is locally cached, satisfies the request from the cache when possible. Otherwise the cache mechanism creates a local cache file and satisfies the request from the server, and also fills in a sparse cached file as reads for data in ranges that are missing in the cached file are requested and received from the server. A background process also fills in local files that are sparse, using the existing handle of already open server files, or opening, reading from and closing other server files. Security is also provided by maintaining security information received from the server for files that are in the cache, and using that security information to determine access to the file when offline.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07392345&OS=07392345&RS=07392345
owner: Microsoft Corporation
number: 07392345
owner_city: Redmond
owner_country: US
publication_date: 20060807
---
This application is a divisional of U.S. patent application Ser. No. 10 880 056 filed Jun. 28 2004 now U.S. Pat. No. 7 089 284 which is continuation of U.S. patent application Ser. No. 09 134 720 filed Aug. 14 1998 now U.S. Pat. No. 6 757 705 each of which is hereby incorporated by reference

The invention relates generally to computer systems and more particularly to an improved method and system for caching network files on a client computer system.

The caching of network information on a local computer has two main advantages a first being the ability to access the information when the local computer is disconnected from the network and a second being a reduction in the amount of data transmitted on the network server to the client. The benefit to having network information available when disconnected is readily apparent i.e. network users may work on files when disconnected from the network such as when traveling working at home or at times when the network is down. This is highly important as more and more corporations require that company data be stored on the network and at the same time require their employees to be more mobile and be able to continue working even when fully disconnected from the corporate network. Benefits to reducing the amount of transmitted data include a reduction in the server workload a reduction in the client s perceived latency and an increase in available network bandwidth.

U.S. Pat. No. 5 721 916 assigned to the assignee of the present invention and hereby incorporated by reference in its entirety describes a caching shadowing method and system that was designed to operate on multiple types of networks. While this shadowing method and system provide the above described advantages of offline access and reduced communication certain drawbacks are inherent therewith. One drawback is that the system architecture is complex and inefficient primarily resulting from the supporting of multiple network types. For example the caching mechanism of the shadowing system and method is located separately from the network redirectors whereby the redirector needs to exchange a lot of information with the caching mechanism to properly cache the files. Another drawback was in the area of security for example those with access to the disconnected client machine had access to the cached data. Lastly other improvements enhancements and optimizations to existing client side caching are generally needed.

Briefly the present invention provides a system and method for improved client side caching that transparently caches suitable network files for offline use. A cache mechanism in a network redirector transparently intercepts requests to access server files and if the requested file is locally cached satisfies the request from the cache when possible. For files existing locally local and remote timestamps may also be compared to ensure that the local file is current. Otherwise the cache mechanism creates a local cache file and satisfies the request from the server and also fills in sparse cached files as reads for data in ranges that are missing in the cached file are requested and received from the server. The cache mechanism also sends write requests to both files to keep the files concurrent and extend them as necessary. A background process further fills in local files that are sparse using the existing handle of already open server files or opening reading from and closing other server files. Security is also provided by maintaining security information received from the server for files that are in the cache and using that security information to determine access to the file when offline.

Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings in which 

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer or the like including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the personal computer such as during start up is stored in ROM . The personal computer may further include a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system preferably Windows NT one or more application programs other program modules and program data . A user may enter commands and information into the personal computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers.

The personal computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks Intranets and the Internet.

When used in a LAN networking environment the personal computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment the personal computer typically includes a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used. For purposes of the description below the computer system may serve as the client machine while one of the remote computers may serve as a file server having files accessed by the client machine.

In general the present invention provides a method and system for improved client side caching that transparently caches suitable network files for offline use and the like. The present invention is described within a Microsoft Windows NT architecture however it is understood that the invention may be implemented in other architectures and or operating systems.

As shown in a caching mechanism is maintained at a network redirector level preferably within the redirector . As is known a redirector basically provides the illusion of a local file system drive when in actuality the file system physically resides on another computer connected to the network by handling among other operations the mapping of local references to universal naming convention UNC references. Since the caching mechanism is at the redirector level the caching mechanism is made aware of communications over the network and can intercept and or act on those communications as described below. Although not necessary to the present invention in a preferred tiered architecture various functions of the redirector have been distributed to a redirector drive buffering subsystem and an appropriate network specific e.g. Server Message Block or SMB type network mini redirector . Since these components are not directly related to the caching operations of the present invention for purposes of simplicity they will not be described hereinafter.

When an application requests a file open operation e.g. via an appropriate application programming interface call an I O Manager receives the request and in combination with an Object Manager determines an appropriate file system corresponding to the requested file and handles the request. Note that the correct file system is known to the Object Manager since during boot up each of the file systems registered their information with the system registry e.g. the redirector is the provider of UNC namespace . Essentially the I O Manager creates a uniform view to the application of the various file systems .

If the requested file is a network file the redirector ultimately receives the request from the I O Manager and assuming at present that the requested file is not already cached the redirector causes the request to be passed to the network server where the file is opened or an error occurs. If no error occurred a handle to the remote file is returned to redirector along with other file metadata including a timestamp the maximum access rights of the requested user access rights if any for guests and client side caching policy settings. The client side policy settings described below are bit values or other values indicative of whether the network file may be locally cached and if so how the file may be cached e.g. automatically or manually. For purposes of efficiency the settings may be associated with the network shared folder and the files of that shared folder treated the same way.

If the requested file is cacheable the client side caching mechanism stores file related information in a database and creates the file in the cache otherwise the caching mechanism simply returns the server file handle to the application. The database is preferably an NTFS Windows NT file system file object for purposes of security. The file related information includes the UNC information stored in a superroot table of the database . Additionally the client side caching mechanism recreates and persists the precise hierarchical network path information for that file in a local set of directory structures whereby the local path is the same as the network path. Note that unlike other programs that place files into their own directories storing the local set of directory structures enables the precise online path and filename to be recreated by the caching mechanism when offline which provides advantages.

One advantage is that the file name is truly transparent to the user as the user has a view of the file that is the same whether online or offline. A related advantage is that applications also see the same pathname. By way of example a word processing program may maintain a list of the most recently used documents. If a user accesses a file e.g. X dir1 dir2 file3.doc from the network server the file is entered into the application s most recently used list. If the user is later offline and clicks on one of these files to open it the precise path will be recreated by the caching mechanism whereby the cached copy of the file may be found. Note that other programs which copy network files into their own directories e.g. c syncpgm dir1 dir2 file3.doc do not provide a way in which the application program may locate the offline copy. In this manner the user of the application receives the same experiences whether online or offline. Indeed if the server goes down or the connection is otherwise lost while the user is working on a cached file the user will not necessarily notice the change except to possibly detect a performance improvement since changes will not be written to the server copy or unless some other notification mechanism informs the user. Of course the number of files available to the user will also likely change since network files that are not fully cached are no longer displayed to the offline user.

Once the file is opened it may be read by the application and at the same time may be read into the local cache . However as with typical read requests the entire file is not ordinarily read at once unless the file is small but rather only a specified range of the file is read at any one time. Thus following the first read the cached file may be sparse. The file is filled in via two mechanisms. A first mechanism is present in the caching mechanism and checks the read request of the application against the data if any in the cached file. If the cached data in the sparse file satisfies the read request the cached data is used while if not a read request is sent to the server. Then in addition to returning the requested read data to the application the caching mechanism fills in the sparse file with the read data returned. Note that part of the requested read data may be cached whereby the caching mechanism may send a request for partial data and recombine the partial request s result with the cached data into a full result. For example if the application requests bytes to numbers are decimal and bytes to are already cached then the caching mechanism need only request bytes to to have enough information to receive the request. Reads are described in more detail below with reference to .

A second way in which sparse files are filled in with data is shown in . The steps of are preferably implemented by a background thread i.e. a daemon process or agent as referred to in the aforementioned U.S. Pat. No. 5 721 916. The background thread occasionally wakes up and via control calls to the redirector finds a sparse file if any in the database according to some order and then fills a missing part of that file with data from the server file. For purposes of simplicity assumes no errors occur however as can be readily appreciated such errors may be handled via standard error handling techniques.

In accordance with one aspect of the present invention after locating the file step the background thread checks at step to see if the file is already open. If so the process branches to step wherein the existing file handles local and remote are obtained from the caching mechanism . The use of the existing file handle is significant as errors and the like otherwise may occur such as if the thread was reading the file via one handle while a write to the file via another handle were pending and so on. By using the same handle such possibly conflicting operations may be properly queued thereby keeping the correct ordering of the operations. Thus at step a read request is appropriately generated such as based on the current file length and or by keeping a read pointer associated therewith to read server data and possibly extend the file as conceptually represented in and described below.

If the file was not open then steps are executed in general to open the remote and the local files transmit an appropriate read request to the server via the server file handle receive and write the data to the local file and then close the file handles. The process may use the local file length and or maintain a read pointer to request a range of data as desired to extend the file.

In any event if the requested file is not in the cache at step step branches to step to open the server copy and receive the file handle thereto and step creates the local file. The open process is then accomplished and the cache mechanism then awaits further requests related to this file such as conceptually represented by awaiting a read request as shown in .

If the file is in the local cache then step branches to step wherein a test is performed by checking designated bits of information to see if the server is in a bandwidth conservation mode. In general when in the bandwidth conservation mode the server file is opened only if necessary. If in the bandwidth conservation mode step branches to step to determine if the local file copy has the same length as the server file copy i.e. the local file copy is not sparse. If the local file is sparse then step branches to step of described below else step branches to step wherein the local and server files are opened and the respective file handles obtained. Note that it is generally necessary to open the server file when the local file is incomplete and thus bandwidth may not be conserved by opening only the local file.

Once the handles are obtained step is next executed to compare the timestamps of the files to determine if the server file and the local file are the same. As can be appreciated the file may have been changed on the server since the file was last written to the cache and if so a timestamp difference will exist. Note that instead of timestamps the server may use checksums version numbers strong entity tags and so on to accomplish the same thing. Thus if not the same the local file data is stale whereby at step the local file is truncated i.e. its data is essentially cleared. Note that the steps of do not address the issue of a timestamp being different because the user modified the file offline. However as described below synchronization between offline changes and the server is performed at logon to avoid this problem and moreover a simple test may be performed on a modified file indicator maintained as metadata with the file described below to ensure that any offline changes are not inadvertently overwritten. At this time the open process is complete whereby the cache mechanism awaits further requests related to this file such as conceptually represented by awaiting a read request as shown in described below.

As represented in in the bandwidth conservation mode step is executed which examines system policy to determine whether to check a timestamp of the locally cached file against the timestamp of the remote file on the server. According to policy settings the timestamp is not necessarily checked every time i.e. a policy may be set that may skip the timestamp comparison according to some criteria. For example the policy may be set so as to only check each file once per day unless specifically reset instead of checking every time. Similarly so as to not defeat the primary purpose of caching when the machine is offline the timestamp comparison which cannot be performed when offline will not be performed. If the timestamp need not be checked step branches to step to open the local copy from the cache and thereby receive the local file handle thereto.

However if the timestamp needs to be checked and of course the system is thus online step branches to step to request and receive the server s timestamp corresponding to this file. Once the timestamp is received again assuming no errors step continues to step to make the comparison against the local file s timestamp i.e. the timestamp received from the server when the file was cached. If the local timestamp is the same as the timestamp returned from the server then the cached file is up to date and thus step branches to step to open the file as described above. Alternatively if the timestamps are not the same step branches to step where the stale cached copy is truncated or otherwise marked as stale. Step then continues to step to open the server copy as described above.

In accordance with one aspect of the present invention if at step the complete local copy was opened and the client is online then the corresponding server file may or may not be opened at the same time primarily depending on the type of file opened. In general the server file is opened sometimes referred to as flowing the opens and a handle to that file obtained so that modifications to the local copy are also written to the server copy keeping the files consistent. In other words write operations while online comprise two separate writes one to the cached file and one to the server file in order to keep the files coherent and extend the files as needed.

However the present invention takes advantage of the fact that not all files may be written while other files are not ordinarily shared. By way of example some files such as CD ROM files are always read only while others are read only to most users such as executable program files. When such files are in the cache and opened there is no reason to open the server copy for writing purposes. Similarly some files can be written to but are not intended to be shared with other users. If only one user will make changes to a file that file need not be opened for simultaneous writing thereto but instead may be sent to the server at a later time when all offline changes are complete. Step checks certain policy properties stored with the cached file which indicate whether the server copy needs to be opened when the cached copy is opened. If so step branches to step to open the server file and receive the handle for performing writes thereto to keep the local and server files coherent and extend the files as necessary. As can be readily appreciated not having to always open the server copy provides a significant increase in network and file server performance when considered in the context of many network users concurrently accessing many files.

Four policy settings two metadata bits presently are associated with each server file per folder for efficiency a manual setting an automatic for documents setting an automatic for programs read only not shared files setting and a no caching setting. These properties are maintained with the cached file in a cached file table described below of course no caching will prevent such files from being cached . Manual indicates that the user needs to directly request caching of the file as described below. The automatic settings are also described below with the difference being that automatic for documents causes the server copy to be opened at step while the other automatic setting does not.

In accordance with another aspect of the present invention a user may pin a file to which proper access and caching is allowed causing that file to be locally cached. In general the user does this when specifically requesting a file for offline use typically by selecting a file such as via the Windows Explorer tool and clicking a pin option. Files which are pinned are not subject to any cache quota and thus must be specifically removed from the cache by the user. Other unpinned files may be automatically removed from the cache to enforce cache size limitations. To this end each time a file is accessed the file i.e. an identifier thereof moves to the top of a cached file queue . Unpinned files are removed from the cache starting with those identified at the bottom of the queue. In this manner disregarding pinned files the least recently accessed files are the first to be removed.

For a sparse file that is already opened e.g. by an application the caching mechanism and the background thread generally implement the steps of to extend the file. Step conceptually represents the caching mechanism awaiting a read request made by the application for the specified file although as can be readily appreciated in actuality the caching mechanism awaits many types of possible operations for possibly many files. Note that the background thread generates its own read request as described above and thus does not wait for another entity to request the read. In any event once a read request is present step is executed to look and see if the requested range of data is already in the local file. If so the request is satisfied at step via the local file data. If not in the local file step branches to step where the read request is sent to the server. Note that as described above if some of the requested data is in the local file the read request sent to the server may be smaller than the read request received with data returned from the server being combined with local data to properly satisfy the request.

At step the returned data is evaluated to determine if it may be used to extend the sparse file. More particularly if the local file is not completely filled step tests whether the current endpoint of the local file falls between the start point and the end point of the read request. If so step branches to step to extend the local file. Step then returns the data and as represented by the dashed lines the data reading process either conceptually returns to the background thread process or conceptually returns to step to await further reads.

Turning now to an explanation of security when a file is opened on the server and the server returns the file handle the server also returns a resultant bitmask of maximum access rights for the user along with a bitmask of guest rights and other metadata information including the file timestamp and the caching policy. The bitmask sets forth the access rights that the user has to that file such as read access write access and so. In accordance with another aspect of the present invention the maximum access rights are maintained in association with a cached file for each user that accesses the file via the local machine i.e. the machine having the cache stored thereon . Since when offline the server may not be contacted to determine a user s rights a user gets his or her last stored rights to the file when attempting to access the file offline. To this end the cached file table includes security information in a record associated with each file as represented in . Note that the last access rights granted for a user are maintained until that user next logs on. If a user who does not have rights stored with the file attempts to access the file the user gets the guest rights which may deny access.

The cached file table also includes the length of the file in the cache and the length of the file in the server. This is used by the background thread to check for sparse files i.e. when the file lengths are the same the file is complete and may be displayed and otherwise accessed by the user while working offline otherwise the file is sparse and still needs to be filled. Sparse files are hidden from the user while the user is working offline. The record for each file also includes the caching policy described above and an indicator bit as to whether the file is pinned so that the quota mechanism operates correctly.

There is a possibility that a document having a long filename i.e. with more characters and or variety thereof than the well known eight character filename with a three character extension will be edited offline by a program that can only function with a converted short filename. The long filename is stored in association with the file so that any changes made offline that result in the short filename being used may be converted back to the long file name for synchronization with the correct server file.

Moreover in order to synchronize offline changes rather than taking the brute force approach of logging every relevant file operation additional information is maintained in association with the file. Such information includes whether the file was created offline whereby it will need to be written to the server when the client next logs onto the server. Similarly deleted status needs to be maintained as does modified status. Note that renaming is a combination of a delete and a create operation.

Although not necessary to the invention for each file having such a status change thereto the appropriate superroot entry in the table that is above that file is marked as changed i.e. dirty. This optimization eliminates having to walk through the UNC paths that have no files with status changes thereunder. Upon the next logon the file status information for each changed file is then processed. For each file created offline a new file is created on the server and for each file deleted offline the corresponding file on the server is deleted possibly following a warning prompt . Files marked as modified files are not combined but rather provide the user with choices comprising keep the offline copy keep the server copy or save the offline copy under a new name. The new name is chosen by the system as the original filename followed by the username and a version number attached thereto.

As can be seen from the foregoing detailed description there is provided a method and system for client side caching that is straightforward and efficient. The system and method provide security along with numerous other improvements enhancements and optimizations to client side caching.

While the invention is susceptible to various modifications and alternative constructions a certain illustrated embodiment thereof is shown in the drawings and has been described above in detail. It should be understood however that there is no intention to limit the invention to the specific form or forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

