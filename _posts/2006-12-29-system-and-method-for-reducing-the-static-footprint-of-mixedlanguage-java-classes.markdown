---

title: System and method for reducing the static footprint of mixed-language JAVA classes
abstract: A system and a method for minimizing the functionality-gap between JAVA™ and native platforms while keeping the impact on each JAVA™ API static footprint as small as possible. A JAVA™ Runtime Dynamic Invocation API is used for low-level bridging between JAVA™ and C/C++, enabling the dynamic invocation of native C/C++ functions and C++ class/object methods from the JAVA™ side without adding any additional ad hoc implemented native code to the overall JAVA™ component implementation. Thereby, the need to write new native code when implementing a JAVA™ component that needs to invoke some native functionality is reduced.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08756616&OS=08756616&RS=08756616
owner: Core Wireless Licensing S.A.R.L.
number: 08756616
owner_city: Luxembourg
owner_country: LU
publication_date: 20061229
---
The present invention relates generally to native code invocation from JAVA classes. More particularly the present invention relates to systems for reducing the size and static footprint of mixed language or mixed mode code JAVA classes i.e. classes having one or more methods implemented in programming languages other then JAVA .

This section is intended to provide a background or context to the invention that is recited in the claims. The description herein may include concepts that could be pursued but are not necessarily ones that have been previously conceived or pursued. Therefore unless otherwise indicated herein what is described in this section is not prior art to the description and claims in this application and is not admitted to be prior art by inclusion in this section.

JAVA is an object oriented programming language and platform that was originally developed in the early 1990s. JAVA components can invoke native platform application programming interfaces APIs by using a standard native code embedding mechanism commonly referred to as a JAVA Native Interface JNI The JNI is primarily intended to foster native API reuse or to implement mission critical parts of the code in a native language for improved efficiency. The JNI approach is quite helpful for the reuse of existing APIs from JAVA . The JNI allows a component written in the JAVA language to call code written in any other programming language by declaring one or more native JAVA methods implementing a native library containing one or more functions that implement the native JAVA methods in a different programming language loading the library that contains the native code and then calling the native method.

The static footprint of a JNI based mixed language JAVA class comprises two primary contributions namely the JAVA class bytecode footprint and the additional native code footprint. Native code comprises the method s business logic implementation and additional JNI specific boilerplate code e.g. for marshalling un marshalling I O parameters between JAVA and native side to create new JAVA objects and or to invoke methods on a JAVA object from native code . Invoking native objects from JAVA via JNI requires the addition of more JAVA side and native side boilerplate code in order to deal with a native object s lifecycle i.e. invocation of a native object constructors methods and destructors since JNI relies on a procedural programming model. Thus object oriented concepts must be implemented from scratch on top of the functional JNI programming model.

When using JNI to implement JAVA system components and APIs developers must find a satisfactory trade off between a pair of conflicting requirements. The first such requirement is to provide a minimum functionality gap meaning that most of the native APIs available to native developers should be available to JAVA components as well. The second requirement is for a minimum JAVA component static footprint. In other words adding new JAVA APIs to a certain JAVA runtime should not have a strong impact on the overall JAVA runtime static footprint in terms of both native and JAVA libraries to be added. This requirement is very important when deploying and running JAVA platforms on embedded and mobile devices which often possess relatively low memory and processing capabilities.

Unfortunately the above two requirements conflict with each other as minimizing the functionality gap by using JNI can cause the final static footprint of a JAVA component to increase significantly. This is commonly referred to as footprint explosion. In fact the one to one relationship between native JAVA methods and functions in the native implementation makes the amount of native code used to implement native JAVA methods increase when the number of JAVA native methods to implement increases. Even if native boilerplate code can be reused by wrapping frequently used libraries in a JAVA API as depicted in it is still difficult to avoid footprint explosion since the more native functions are wrapped the larger the size of the additional JNI code. This conflict is even more difficult to solve when dealing with object oriented native APIs due to the existing programming model mismatch between the JNI C primitives and the C object oriented programming model.

A number of proposals have been made to enable JAVA wrapping of native C objects. These proposals are discussed for example in the Simplified Wrapper and Interface Generator SWIG User s Manual 1.1 available at the SWIG website U.S. Pat. No. 6 066 181 issued May 23 2000 and U.S. Patent Publication No. 2005 0044540 published Feb. 24 2005. These documents discuss a pair of strategies for the JAVA wrapping. However the processes discussed in these documents do not allow for the minimizing of the static footprint as they require one new native library for each class function to be integrated. Therefore the minimizing of the functionality gap with these systems can easily lead to footprint explosion since all boilerplate code cannot be re used.

In addition to the above MICROSOFT Corporation s C Programmer s Reference Platform Invoke Tutorial available at the MSDN Microsoft Development website while somewhat useful is strictly limited to the invocation of native procedural APIs and not for the invocation of object oriented APIs.

There is therefore a need for a system and method of reducing the functionality gap between JAVA and native platform while at the same time providing only a minimum impact on the static footprint of the JAVA environment.

Various embodiments of the present invention involve a system and a method for minimizing the functionality gap between JAVA and native platforms while keeping the impact on each JAVA API static footprint as small as possible. The various embodiments provide a general purpose mechanism for low level bridging between JAVA and C C enabling the dynamic invocation of native C C functions and C class object methods from the JAVA side without adding any additional ad hoc implemented native code to the overall JAVA component implementation. In this way the need to write new native code when implementing a JAVA component that needs to invoke some native functionality is drastically reduced.

With the various embodiments of the present invention the need for writing JNI native code in JAVA component e.g. JSR implementations is reduced as is the amount of boilerplate code that is needed for JNI invocation. In addition these various embodiments enable JAVA developers to write JAVA applications that consume native APIs without writing any additional application specific native code. Still further with these embodiments JAVA consumers can reuse all of the needed JAVA and native boilerplate code thus reducing the overall size of the resulting JAVA consumer APIs. This system can also be used to reduce start up time and dynamic footprints as there are fewer native libraries to load and libraries are only loaded once. Still further this system and method can also be used for garbage collection of native C objects instantiated by a JAVA application.

These and other advantages and features of the invention together with the organization and manner of operation thereof will become apparent from the following detailed description when taken in conjunction with the accompanying drawings wherein like elements have like numerals throughout the several drawings described below.

Various embodiments of the present invention involve a system and a method for minimizing the functionality gap between JAVA and native platforms while keeping the impact on each JAVA API static footprint as small as possible. The various embodiments provide a general purpose mechanism for low level bridging between JAVA and C C enabling the dynamic invocation of native C C functions and C class object methods from the JAVA side without adding any additional ad hoc implemented native code to the overall JAVA component implementation. In this way the need to write new native code when implementing a JAVA component that needs to invoke some native functionality is drastically reduced.

A set of JAVA peer classes referred to herein as JavaPointers is used to represent dynamically allocated native entities on the JAVA side. Different types of native entities such as objects and primitive variables are represented on the JAVA side by an instance of a dedicated JAVA class e.g. a NativeObjectPointer or a Native StructurePointer instance. As a result of programming idioms and interfaces provided by the JRDI API JAVA applications can use a JavaPointer as a type of JAVA peer pointer in order to invoke methods on dynamically allocated native entities or to use them as I O arguments when invoking another entity s functionality. In this sense a JavaPointer is used in the same way as a native application would use native pointers to manage dynamically allocated variables.

Various embodiments of the present invention operate under the assumption that the JAVA runtime comprises two points of functionality. First there needs to be a working mechanism for embedding native code in JAVA components by using the standard JNI mechanism. Second there must also be a working mechanism for loading native dynamic link libraries DLLs at run time.

The following is a description of a first use case involving the creation of an effective system development JAVA platform for memory constrained devices. In this situation a mobile device manufacturer desires to include a powerful pure JAVA application development platform on a memory constrained device. In order to accomplish this goal almost all on device native functionality should be exposed to JAVA via a set of JAVA mixed language classes representing platform features and system calls. In this case however standard JNI coding can easily lead to static footprint explosion as the number of native functions methods to expose can be quite large e.g. around 10functions methods to wrap on the latest releases of one operating system . This in turn makes a pure JNI based approach unsuitable for memory constrained devices. If a general purpose native platform invocation JAVA component is available JAVA developers can exploit it to invoke whatever native API are needed from JAVA without having to write and install any additional C C application specific library. In this way device manufacturers can provide an effective system development JAVA platform that is suitable for memory constrained devices since it has a minimum impact on the overall JAVA platform static footprint.

The following is a description of a second use case involving the small footprint implementation of different time critical methods by re using a large native C object oriented API. In this case a JAVA developer wishes to implement a large number of time critical methods of a JAVA class. It has been decided to implement them in the C programming language because the developer wishes to re use an existing library of C classes. Since JNI does not provide support for invocation of object oriented APIs the wrapping of the needed class library can require the developer to write a lot of native and JAVA boilerplate code. However this problem can be alleviated if the developer can invoke the native C object oriented API from JAVA .

Upon the JRDI based dynamic creation of a native entity from JAVA a new native variable object is allocated on the heap and a new JavaPointer instance is returned to JAVA applications for further usage. The dynamic destruction interface allows JAVA applications to explicitly remove the created native entities from the heap.

With regard to the native APIs to invoke the available C C functions and C classes may have been either exported by a DLL or not e.g. using template and inline functions methods as well as inherited methods . C and C compilers treat these two alternatives differently and such differences may have an impact on the implementation of the JRDI API . In particular DLL exported APIs can be loaded and invoked at run time without a DLL invoker posing any API specific build time constraint to the native part of the JAVA component. However native APIs typically also include other C C definitions and declarations such as template methods functions and inline methods functions . These definitions and declarations can pose several build time API specific dependencies between the target APIs of the native platform and the native implementation of a JAVA consumer component. These dependencies are due to the fact that C C compilers generate templates instantiations and expand inline code only at the calling block and add them statically to the calling component s object code at build time.

Therefore in addition to DLL based invocation an exemplary JRDI implementation may also include components for invoking functionality that does not have any corresponding entry points in DLLs and thus may pose some build time dependencies to the mixed language JAVA class. In this case each native method can be wrapped in C style wrappers commonly referred to as C functions or more generally downcalling wrapper functions. Downcalling wrapper functions are functions that are used to wrap a call to a native c c API in order to enable a downcall. A downcall refers to a call from a managed e.g. JAVA component to a native e.g. C C function or method. The necessary wrappers can then be included into a dedicated library namely a dynamic invocation library DIL . In addition to wrappers the DIL also includes an array of opaque function pointers. These pointers are referred to as an Entry Point Table EPT which is used by the entry point table invoker component of the JRDI library to perform the actual invocation of the needed existing native API.

In various embodiments the JRDI framework relies on the invokers to actually invoke a given native method at run time by using either DLL based or EPT based JRDI approach. For this purpose in these embodiments the JRDI framework includes two primary invoker components namely CDynLibInvoker and CEPTInvoker components. These components are derived from the same mixin class namely MJRDInvoker which represents the abstract core of the low level invocation API. Each invoker instance is associated with an instance of a given native class that has been previously allocated on the heap during invoker s creation. Upon native object creation each invoker holds a pointer to it that is represented by the iThisPointer member of the MJRDInvoker class. Such a pointer is subsequently used to invoke different methods on the target object instance.

The actual method invocation approach relies on the assumption that the member functions to invoke are represented in native object code as calls to standard C functions. For example invokers assume that the following method 

is compiled and thus can be invoked as a C function having the following prototype int myclass myMethod MyClass aThisPointer int anInt 

It should be noted that method invocations are not necessarily converted to such a function call from C compilers. Therefore it is assumed that the native C compiler supports this calling convention. If the compiler adopts a different conventions the low level JRDI API must support it explicitly. For example MICROSOFT C Win32 and ARM RVCT compilers support different default calling conventions and we had to deal with such a difference when implementing the JRDI proof of concept prototype.

In order to invoke a given method invokers both CEPTInvoker and CDynLibInvoker typically retrieve a generic function pointer to it and then cast it to a precise type representing a pointer to a function having a specific prototype. For example in order to invoke the MyMethod method above the retrieved function pointer should be cast to the T1ArgMethod type defined as follows 

It is also noted that while the first void argument of T1ArgMethod represents a pointer to the dynamic target object instance the so called this pointer the second void argument represents the actual argument to pass to the native method i.e. the int anInt input parameter of MyClass MyMethod. A JavaPointer is in charge of converting arguments to void representation and of invoking the appropriate method on the right invoker at run time. If the native method call returns any leave error code a JAVA exception is thrown. For example for invoking the mentioned MyClass MyMethod method the JAVA consumer must invoke the InvokeIntOneArg argument of the JavaPointer. This method converts the argument to a void and then invokes the CallOneArgOneWayWithReturn method on the right invoker as follows 

In one embodiment of the present invention both DLL based and EPT based invocation of native APIs are enabled. According to this embodiment in DLL based invocation a CDynLibInvoker component contains an RLibrary object that is used to dynamically load a certain target DLL containing one or more class implementations. The CDynLibInvoker component uses the RLibrary object at run time to retrieve function pointers to exported methods by ordinal by using a RLibrary Lookup method in accordance with the following code 

The invoked Invoke1ArgMethod of the CDynLibInvoker object then casts the retrieved generic i.e. void function pointer to the appropriate function prototype and then invokes the native method. For example for invoking an int MyClass MyMethod int anInt the function pointer should be cast to a T1ArgMethod i.e. T2ArgFunction pointer and then invoked as a 2 arguments function as follows 

EPT based invocation is similar to DLL based invocation in that the CEPTInvoker must retrieve the appropriate function pointer as a void pointer cast it to the actual function pointer type to use and invoke it. However a primary difference with EPT based invocation involves the function pointer retrieval mechanism. While the CDynLibInvoker relies on the assumption that the method to invoke is available at a given ordinal of a given DLL the CEPTInvoker has no DLL to refer to since the native functionality is not exported by any existing DLL. In order to invoke unexported native APIs each required method function of such APIs must be wrapped in a C style wrapper function having the same prototype as the appropriate function prototype to use e.g. T2ArgFunction . For example the MyClass MyMethod method could be wrapped in a C style wrapper function defined as follows 

During the construction of a new JavaPointer the CEPTInvoker instance is initialized by providing it with an array of pointers to all the required wrapper functions related to MyClass. Such an array is defined as follows 

Given such an array in order to invoke the mentioned MyClass MyMethod method the CEPTInvoker can retrieve the pointer to the JW MyClass MyMethod wrapper and then invoke it by using the generic CEPTInvoker Invoke2ArgFunction method as follows 

It is also noted that EPT based invocation can be used to provide JAVA side setter and getter methods to access a given Class object member variables. For example a setter method for the OneField member of the MyClass class could be invoked by means of the following wrapper function 

A JavaPointer instance can hold one CEPTInvoker as well as multiple CDynLibInvoker instances. This approach results in forcing each EPT to contain all of the DLL unexported methods that the JAVA consumer wishes to invoke on a given object including methods belonging exactly to object s class as well as to its mother class es . In other words inherited methods are always explicitly wrapped by a DIL and thus explicitly represented in a certain class EPT.

Both the DLL based and EPT based approaches assume that the JAVA developer knows beforehand the C C signature of the native functionality that his application is interested in consuming. Therefore these approaches requires developers to consult native service documentation but in any case developers must be aware of native platform s APIs if they want to use them.

Communication devices implementing the various embodiments of the present invention may be capable of communicating using various transmission technologies including but not limited to Code Division Multiple Access CDMA Global System for Mobile Communications GSM Universal Mobile Telecommunications System UMTS Time Division Multiple Access TDMA Frequency Division Multiple Access FDMA Transmission Control Protocol Internet Protocol TCP IP Short Messaging Service SMS Multimedia Messaging Service MMS e mail Instant Messaging Service IMS BLUETOOTH IEEE 802.11 etc. A communication device may communicate using various media including but not limited to radio infrared laser cable connection and the like. The communication devices may be stationary or mobile as when carried by an individual who is moving. The communication devices may also be located in a mode of transportation including but not limited to an automobile a truck a taxi a bus a boat an airplane a bicycle a motorcycle etc.

The present invention is described in the general context of method steps which may be implemented in one embodiment by a program product including computer executable instructions such as program code executed by computers in networked environments. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Computer executable instructions associated data structures and program modules represent examples of program code for executing steps of the methods disclosed herein. The particular sequence of such executable instructions or associated data structures represents examples of corresponding acts for implementing the functions described in such steps.

Software and web implementations of the present invention could be accomplished with standard programming techniques with rule based logic and other logic to accomplish the various database searching steps correlation steps comparison steps and decision steps. It should also be noted that the words component and module as used herein and in the claims is intended to encompass implementations using one or more lines of software code and or hardware implementations and or equipment for receiving manual inputs.

The foregoing description of embodiments of the present invention have been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the present invention to the precise form disclosed and modifications and variations are possible in light of the above teachings or may be acquired from practice of the present invention. The embodiments were chosen and described in order to explain the principles of the present invention and its practical application to enable one skilled in the art to utilize the present invention in various embodiments and with various modifications as are suited to the particular use contemplated.

