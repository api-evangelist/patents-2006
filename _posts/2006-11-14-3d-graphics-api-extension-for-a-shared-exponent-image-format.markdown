---

title: 3D graphics API extension for a shared exponent image format
abstract: A three dimensional (3D) graphics application programming interface (API) extension provides support for specifying images in a shared exponent format. The shared exponent format is used to represent high dynamic range textures in a compact encoding to reduce the memory footprint needed to store the image data compared with other high dynamic range formats. Image data is encoded to and decoded from the shared exponent format using a pixel processing pipeline. Image data encoded into the shared exponent format can be decoded and used as texture data during rendering.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08432410&OS=08432410&RS=08432410
owner: Nvidia Corporation
number: 08432410
owner_city: Santa Clara
owner_country: US
publication_date: 20061114
---
This application claims benefit of United States provisional patent application titled API Extensions for Advanced Graphics Processing Units filed Jul. 28 2006 and having Ser. No. 60 833 978 which is herein incorporated by reference.

One embodiment of the present invention relate generally to a three dimensional 3D graphics application programming interface API extension and more particularly to converting image data to and from a shared exponent format.

Recently 3D graphics content developers are using high dynamic range color components to increase visual realism. An 8 bit per component fixed point format does not provide enough range and precision to represent the high dynamic range color components. A floating point format typically 16 or 32 bits per component provides the needed range and precision but does not have a compact encoding compared with the fixed point format.

As the foregoing illustrates what is needed in the art is the ability to represent high dynamic range values using a floating point format with a compact encoding in order to store images in the same or less memory than fixed point format images. Furthermore it is desirable to specify the high dynamic range format with the compact encoding for use with graphics library operations that are provided by conventional APIs.

Systems and methods of the present invention provide a 3D graphics API extension for specifying images in a shared exponent format to encode high dynamic range values. The shared exponent format is used to represent high dynamic range textures in a compact encoding to reduce the memory footprint needed to store the image data compared with other high dynamic range formats. Image data is encoded to and decoded from the shared exponent format using a pixel processing pipeline. Image data encoded into the shared exponent format can be decoded and used as texture data during rendering. By using the 3D graphics API extension to specify a source or destination image format image data may be encoded to and decoded from the shared exponent format without requiring a graphics application to perform the encoding or decoding. In particular the shared exponent format may be specified for images that are processed using graphics library operations provided by the OpenGL architecture.

Various embodiments of a method of the invention for providing image data represented in shared exponent format for graphics processing include receiving source image data specified by an application program and a parameter that specifies the shared exponent format processing the source image data using a pixel processing pipeline provided by function calls of a 3D graphics library to produce processed source image data encoding the processed source image data into the shared exponent format to produce the image data represented in the shared exponent format and transmitting the image data represented in the shared exponent format to a graphics memory for storage.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

A 3D graphics API extension provides support for specifying images in a shared exponent format. The shared exponent format is used to represent high dynamic range textures in a compact encoding. Consequently the memory footprint needed to store the image data is reduced compared with other high dynamic range formats. Image data is encoded to and decoded from the shared exponent format using the pixel processing pipeline. Image data encoded into the shared exponent format can be decoded and used as texture data during rendering. Importantly using the 3D graphics API extension to specify a source external or internal or destination internal or external image format image data may be encoded to and decoded from the shared exponent format without requiring a graphics application to perform the encoding or decoding. The shared exponent format may be specified as a format parameter for the destination image data. The shared exponent format may also be specified as a format parameter for the source image data to allow the application to provide the source image data pre encoded in the shared exponent format. Furthermore the 3D graphics API extension enables the shared exponent format to be specified or returned for existing OpenGL function calls such as glDrawPixels glReadPixels glTexlmagel D glTexlmage2D glGetTexlmage glTexlmage3D glTexSublmagel D glTexSublmage2D glTexSublmage3D glCopyTexlmagel D glCopyTexlmage2D glRenderbufferStorageEXT glGetHistogram glGetMinmax glConvolutionFilterl D glConvolutionFilter2D glConvolutionFilter3D glGetConvolutionFilter glSeparableFilter2D glGetSeparableFilter glColorTable glColorSubTable glGetColorTable glGetTexLevelParameterfv and glGetTexLevelParameteriv.

The present invention provides an API extension to OpenGL that allows data representing pixel or texture components to be specified encoded to and decoded from a packed format with an exponent that is shared between multiple texture or pixel components. The packed format is compact compared with storing an exponent for each component. Therefore the amount of memory need to storage the data in a texture memory or frame buffer memory is reduced. Notably when using the present invention three floating point precision components may be represented in 32 bits compared with 36 bits or 96 bits for 16 or 32 bit per component floating point precision without a shared exponent.

The pixel unpack engine and a pixel transfer engine of pixel processing pipelines and may be embodied as a software program or as circuitry designed to execute specific function calls for pixel processing defined by the OpenGL specification and provided in the form of a 3D graphics library. Similarly texture encode engine and shared exponent decode engine may be embodied as a software program or as circuitry designed to execute functions for specifying and processing source image data to from the shared exponent format defined by the 3D graphics API extension.

In step pixel transfer engine is configured to perform pixel transfer operations on the component values such as scaling biasing matrix operations convolution and the like. In particular pixel transfer engine may be configured to perform data conversions such as color conversions or floating point to from fixed point format conversions. In step texture encode engine determines is the shared exponent format is specified as the output data format for the source image and if not texture encode engine proceeds directly to step . Otherwise in step texture encode engine processes the processed component values to produce shared exponent texture data as described in conjunction with .

In step the encoded texture data is output by texture encode engine for storage in texture memory as a texture map. In some embodiments of the present invention the texture data may be filtered to produce mipmapped texture maps that include two or more level of detail textures for a single source image. In step the texture data is read from texture memory and decoded for use during shading operations.

In a conventional pixel processing pipeline that is not configured to process the shared exponent format conversion to the shared exponent format may be performed by the application before the data is stored for use as a texture map. Including shared exponent format encoding in the pixel processing pipeline allows for the conversion of pixel components to be performed in the pixel pipeline in addition to the conventional pixel processing pipeline operations provided by pixel unpack engine and pixel transfer engine . It is desirable to maintain compatibility with the existing pixel processing pipeline i.e. existing graphics library functions while adding the ability to conserve memory space by encoding high dynamic range image data into the shared exponent format. Furthermore it is desirable to offload the format conversion processing from the application by performing the format conversion in the pixel pipeline.

In step texture encode engine determines the largest magnitude clamped component max c for each texel using the following equation max c max red c green c blue c . In step texture encode engine computes the shared exponent exp shared max B 1 floor log 2 max c 1 B. In step texture encode engine computes the component mantissas for the shared exponent format. For example when the shared exponent format is a 5 bit exponent and a 9 bit mantissa with an implied leading zero the equations shown in TABLE 2 may be used to perform step to compute the mantissas as integer values in the range of 0 to 2 N 1.

In step texture encode engine packs the texel component mantissas and the shared exponent for each texel and texture encode engine proceeds to step of . The single 5 bit exponent is stored as an unsigned value biased by 15 and there is a 9 bit mantissa for each component. There are no sign bits because all of the components should be non negative due to the clamping in step . The fractional mantissas assume an implied zero left of the decimal point because having an implied leading one is inconsistent with sharing the exponent. Finally neither infinity nor Not a Number NaN is representable using the shared exponent format. The shared exponent format using a 5 bit exponent and 9 bit mantissas closely matches the range and precision of the half precision floating point format described in the ARB half float pixel and ARB texture float specifications that uses a 5 bit exponent and 10 bit mantissa for each exponent. In some embodiments of the present invention both signed and unsigned values may be represented by using a 5 bit exponent that is shared between 8 bit mantissas that each have a corresponding sign bit.

In step pixel processing pipeline receives a source image specified by an application. The image is unpacked into pixel components by step . The application may specify that the source image is represented in the shared exponent format provided by the 3D graphics API extension. After unpacking in step shared exponent decode engine determines if the source image is represented in the shared exponent format and if not then the source image is output to pixel transfer engine . Otherwise in step shared exponent decode engine decodes the unpacked source components assuming the shared exponent format to produce floating point data with an exponent for each mantissa. For example when the shared exponent format is a 5 bit exponent and a 9 bit mantissa with an implied leading one the equations shown in TABLE 3 may be used to perform step to compute the decoded component values. The unpacked components red s green s blue s and exp shared values are processed as unsigned integers and are decoded to red green and blue components.

A graphics device driver is stored in host memory and includes 3D graphics library and 3D API extension . Graphics device driver is configured to interface between applications using functions provided by 3D graphics library and 3D API extension and a graphics subsystem . Graphics device driver translates instructions for execution by graphics processor based on the specific capabilities of graphics processor . In some embodiments of the present invention graphics device driver is configured to perform the format encoding to and decoding from the internal format specified by the application using graphics processor . Offloading the format encoding and decoding to graphics processor may improve the encoding and decoding performance.

3D graphics API extension provides shared exponent format encode and decode support for 3D graphics library . A memory image is stored in host memory for processing using functions provided by 3D graphics library and 3D API extension to produce image data including component values encoded using the shared exponent format and or decoded from the shared exponent format. Alternatively the memory image may reside in local memory not shown . 3D graphics library provides function calls for graphics processing including operations performed by pixel unpack engine and pixel transfer engine . Likewise 3D API extension provides the functions of texture encode engine and shared exponent decode engine for use with 3D graphics library .

Host computer communicates with graphics subsystem via system interface . Data received by graphics processor can be processed by a graphics pipeline within graphics processor or written to a local memory . Graphics processor uses graphics memory to store graphics data and program instructions where graphics data is any data that is input to or output from units within graphics processor . Graphics memory can include portions of host memory local memory register files coupled to the components within graphics processor and the like. Graphics processor includes one or more processing units that may each read and or write graphics memory. In alternate embodiments host processor graphics processor system interface or any combination thereof may be integrated into a single processing unit. Further the functionality of graphics processor may be included in a chip set or in some other type of special purpose processing unit or co processor.

In a typical implementation graphics processor performs geometry computations rasterization pixel texture mapping and shading computations and raster operations. Texel components provided by pixel processing pipeline or are stored in texture memory within local memory . The texel components represented in the shared exponent format may be read and decoded by graphics processor for use during the execution of graphics processing programs. Specifically the texture data may be used during the processing of geometry vertex or pixel data. Pixel components provided by pixel processing pipeline or are stored in frame buffer within local memory . The pixel components represented in the shared exponent format may be read and decoded by graphics processor for use during the execution of graphics processing programs. In particular the pixel components may be read during raster operations.

When the data received by graphics subsystem has been completely processed by graphics processor outputs processed graphics data to a frame buffer within local memory . In particular source image data that is produced by graphics processor may be stored in frame buffer and provided to pixel processing pipeline or for encoding. Source image data that includes either signed or unsigned components may then be encoded and stored as an encoded texture map in texture memory when texture encode engine is included in pixel processing pipeline or . Therefore image data may be read from frame buffer and provided to pixel processing pipeline or directly without requiring intervention by a graphics application to copy the image data to host memory . As previously described the functionality of texture encode engine may be provided using 3D API extension .

In some embodiments of the present invention graphics processor is optionally configured to deliver data to a display device network electronic control system other computing system other graphics subsystem or the like. Alternatively data is output to a film recording device or written to a peripheral device e.g. disk drive tape compact disk or the like.

Primitive assembler receives processed vertex data from vertex processing unit and constructs graphics primitives e.g. points lines triangles or the like for processing by geometry processing unit . Geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs transforming graphics primitives received from primitive assembler as specified by the geometry shader programs. For example geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives. Geometry processing unit outputs the parameters and new graphics primitives to rasterizer . Geometry processing unit may read texture map data that is stored in local memory through an interface for use in processing the geometry data.

Rasterizer scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Fragment processing unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from rasterizer as specified by the fragment shader programs. For example Fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are output to raster operations unit . Fragment processing unit may read texture map data that is stored in local memory through a texture fetch unit for use in processing the fragment data. Texture fetch unit produces read requests for texels decodes texel components represented in the shared exponent format and performs texture filtering operations e.g. bilinear trilinear anisotropic and the like as described in conjunction with . Raster operations unit is a fixed function unit that optionally performs near and far plane clipping and raster operations such as stencil z test and the like and outputs pixel data as processed graphics data for storage in graphics memory.

Texture filtering unit receives the converted texture data and performs point sampling bilinear filtering trilinear filtering or anisotropic filtering to produce filtered texel values that are output to fragment processing unit . In some embodiments of the present invention additional texture fetch units are coupled to other processing units within graphics processor such as vertex processing unit and geometry processing unit to allow those units to read texture data for processing.

In step graphics processor renders an image and stores the image in frame buffer of local memory . The image may be specified using 3D graphics library as a source image for processing by pixel processing pipeline . For example a pointer to a memory location in frame buffer may be provided along with a source format. A destination location within texture memory may be specified with a destination internal format as provided by 3D API extension of shared exponent format texture components. In step pixel processing pipeline reads the image from frame buffer for processing as a source image. Steps and correspond to steps and of respectively and are performed as previously described to produce shared exponent format texel components for storage in texture memory and use during rendering.

Pixel processing pipeline may be used in various texture image query modes to convert texture data to from the shared exponent format. For example a texture map represented in the shared exponent format may be read and converted to a fixed point format or conventional floating point format. Conversely a texture map represented in a fixed point or conventional floating point format may be read and converted to the shared exponent format. Pixel processing pipeline may also be used to perform an optimized memory to memory transfer in order to copy a texture map represented in the shared exponent format to a source image represented in the shared exponent format.

In step pixel processing pipeline reads the texture data from texture memory . In step shared exponent decode engine determines if the texture data is represented in the shared exponent format and if so in step shared exponent decode engine decodes the texture data outputs the expanded texture data to pixel encode engine and proceeds to step . If in step shared exponent decode engine determines that the texture data is not represented in the shared exponent format then shared exponent decode engine outputs the texture data to pixel encode engine .

In step pixel encode engine determines if the shared exponent format is specified for the destination image and if so in step the texture data or expanded texture data received from shared exponent decode engine is encoded into the shared exponent format and output as the destination image data by pixel encode engine . If in step pixel encode engine determines that the shared exponent format is not specified for the source image then pixel encode engine outputs the texture data or expanded texture data as the source image data. In step the destination image data output by pixel encode engine is stored in a portion of host memory allocated to an application or local memory . In some embodiments of the present invention when the shared exponent format is specified for the texture data and the source image pixel processing pipeline is configured in a pass through mode and the texture data is transferred without changing the format.

Pixel transfer engine process the decoded source image and produce processed source image components. Pixel encode engine is configured to convert processed source image components that are not represented in the shared exponent format into the shared exponent format and output the converted components as a pixel image for storage in frame buffer .

In step pixel processing pipeline reads the source image data from a location in graphics memory specified by a function call. The data is unpacked into components by step . In step pixel decode engine determines if the source image is represented in the shared exponent format and if so in step pixel decode engine decodes the source image data outputs the expanded source image data to pixel transfer engine and proceeds to step . If in step pixel decode engine determines that the source image is not represented in the shared exponent format then pixel decode engine outputs the source image to pixel transfer engine .

In step pixel transfer engine performs pixel transfer operations on the unpacked source image data. In step pixel encode engine determines if the shared exponent format is specified for the destination image to be stored in frame buffer and if so in step the processed source image data received from pixel transfer engine is encoded into the shared exponent format and output as the destination image data by pixel encode engine . If in step pixel encode engine determines that the shared exponent format is not specified for the destination image then pixel encode engine outputs the processed source image data as the destination image data. In step the destination image data output by pixel encode engine is stored in frame buffer . In some embodiments of the present invention when the shared exponent format is specified for the source image data and the destination image pixel processing pipeline is configured in a pass through mode and the source image data is transferred without changing the format.

Pixel transfer engine processes the decoded rendered image and produces processed rendered image components. Pixel encode engine is configured to convert processed rendered image components that are not represented in the shared exponent format into the shared exponent format and output the converted components as a source image. In some embodiments of the present invention pixel encode engine is configured to convert the processed rendered image components into conventional integer or floating point data formats in addition to the shared exponent format.

In step pixel processing pipeline reads the rendered image data from a location in frame buffer specified by a function call. In step pixel decode engine determines if the rendered image is represented in the shared exponent format and if so in step pixel decode engine decodes the rendered image data outputs the expanded rendered image data to pixel transfer engine and proceeds to step . If in step pixel decode engine determines that the rendered image is not represented in the shared exponent format then pixel decode engine outputs the rendered image to pixel transfer engine without decoding the rendered image data.

In step pixel transfer engine performs pixel transfer operations on the rendered image data or expanded rendered image data to produce processed image data. In step pixel encode engine determines if the shared exponent format is specified for the source image to be stored in a portion of host memory that is allocated to the application and if so in step the processed image data received from pixel transfer engine is encoded into the shared exponent format and output as the source image data by pixel encode engine . If in step pixel encode engine determines that the shared exponent format is not specified for the source image then pixel encode engine outputs the processed image data as the source image data. In step the source image data output by pixel encode engine is stored in host memory . In some embodiments of the present invention when the shared exponent format is specified for the rendered image data and the source image pixel processing pipeline is configured in a pass through mode and the rendered image data is transferred without changing the format.

High dynamic range image data may be stored in the compact shared exponent format provided by the 3D graphics API extension while requiring less memory than conventional floating point formats that are typically used to represent high dynamic range data. Furthermore using a 3D graphics API extension to add support for the shared exponent format maintains compatibility with existing pixel processing while adding the ability to conserve memory space. The 3D graphic API extension allows for an application to provide an image in a conventional format without requiring the application to perform the encoding to the shared exponent format or the decoding from the shared exponent format. Therefore applications may seamlessly specify the new shared exponent format for image data and save memory space needed to store the image while maintaining the capability to execute conventional graphics library function calls. Applications may also pre encode image data in the shared exponent format and specify a different format or the shared exponent format for the destination internal format .

One embodiment of the shared exponent format that may be used to represent image components includes a 5 bit shared exponent and three 9 bit mantissas each with an implied leading zero. An advantage of using a 5 bit shared exponent rather than an 8 bit shared exponent is that the 5 bit exponent allows for more bits to be allocated to the mantissa while fitting three components into a 32 bit word. Having an extra bit of precision for each component is advantageous in situations where a high magnitude component dominates a low magnitude component. Furthermore graphics processors that are configured to process a conventional half precision floating point format with a 5 bit exponent and 10 bit mantissa for each component existing filtering units for textures represented in the expanded shared exponent format. The allocation of three 9 bit mantissas and a shared 5 bit exponent without signed bits is well suited to storing RGB color values with high dynamic range but other embodiments may allocate the number of bits and components differently to better match domain specific requirements.

With conventional floating point formats the number corresponding to a finite non denormalized non zero floating point value is value 1 sign 2 exponent bias 1.frac. Sign is the sign bit 1 is a negative sign and 0 is a positive sign . Exponent is an unsigned biased exponent and bias is the constant bias for the format that is subtracted to get the unbiased possibly negative exponent. frac is the fractional portion of the mantissa with the 1. indicating an implied leading one. An exp value of zero indicates so called denormalized values. With conventional floating point formats the number corresponding to a denormalized floating point value is value 1 sgn 2 exp bias 1 0.frac. The only difference between the denormalized and non denormalized case is that the bias is one greater in the denormalized case and the implied leading digit is a zero instead of a one. While conventional floating point formats use an implied leading one for non denormalized finite values a shared exponent format does not use an implied leading one because each component may have a different magnitude for its most significant binary digit.

The largest biased exponent for a conventional floating point format 31 for the half precision floating point format and 127 for a 32 bit IEEE floating point format indicates Infinity and NaN values. This means these two extrema exponent values are off limits and cannot be used to represent other values. There should be no off limits exponents for the shared exponent format since there is no requirement for representing Infinity or NaN values and denormalized is not a special case. Because of the implied leading zero any component with all zeros for its mantissa is zero no matter the shared exponent s value. Representing Infinity and NAN values limits the range of exponents for the conventional half precision floating point format to between 1 and 30. In contrast the shared exponent format consistently uses the same rule for all exponents from 0 to 31.

In the preferred embodiment of the present invention an exponent bias of 15 is used. The maximum value that can be represented by the half precision floating point format results from an exponent of 30 and the binary mantissa of the implied leading one followed by ten fractional 1 s. Therefore the maximum value that can be represented by the half precision floating point format is 1.1111111111 2 30 15 1.1111111111 2 15. The maximum value that can be represented by the shared exponent format is 0.111111111 2 31 15 0.111111111 2 16 1.11111111 2 15. Ignoring only two least significant bits these values are nearly identical.

The minimum non zero representable value for the shared exponent format with a bias of 15 is 0.000000001 2 0 15 0.000000001 2 15 0.0000000001 2 14. The minimum values for the shared exponent format and the half precision floating point format match exactly for the exponent bias of 15. Therefore the shared exponent format using a shared 5 bit exponent represents nearly the same range of finite values as the half precision floating point format specified by the ARB texture float extension. However the half precision floating point format requires 48 bits for three components and the shared exponent format requires only 32 bits. Therefore the shared exponent format is more compact than the half precision floating point format while maintaining nearly the same precision. It is advantageous to store image data in the shared exponent format since the image data will require less memory compared with the half precision floating point format or a conventional 32 bit per component floating point format.

Persons skilled in the art will appreciate that any system configured to perform the method steps of B C B B or B or their equivalents are within the scope of the present invention. A 3D graphics API extension provides support for specifying images in a shared exponent format. The shared exponent format is used to represent high dynamic range textures in a compact encoding to reduce the memory footprint needed to store the image data compared with other high dynamic range formats. Image data is encoded to and decoded from the shared exponent format using the pixel processing pipeline. Image data encoded into the shared exponent format can be decoded and used as texture data during rendering.

The invention has been described above with reference to specific embodiments. Persons skilled in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. One embodiment of the invention provides a computer readable medium storing instructions for causing a processor to provide uncompressed texture data for graphics processing by performing the steps of receiving source image data specified by an application program and a parameter that specifies the shared exponent format processing the source image data using a pixel processing pipeline provided by function calls of a 3D graphics library to produce processed source image data encoding the processed source image data into the shared exponent format to produce the image data represented in the shared exponent format and transmitting the image data represented in the shared exponent format to a graphics memory for storage.

