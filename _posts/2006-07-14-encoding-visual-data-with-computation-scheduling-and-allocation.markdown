---

title: Encoding visual data with computation scheduling and allocation
abstract: Computation scheduling and allocation for visual communication is described. In one aspect, multiple frames of video data are encoded by allocating for at least a subset of inter-coded frames, on frame-by-frame basis, computational resources to encode the inter-coded frame. To this end, a computational budget to encode a current inter-coded frame is estimated. The estimate is based on the actual computational costs to encode a previous inter-coded frame of video data. Next, sets of operations associated with encoding the current inter-coded frame are analyzed to determine computational resources to implement the operations. If the computational resources exceed the computational budget, complexity of the operations is reduced until the associated computational resources are less than or equal to the computational budget. At this point, the current inter-coded frame is encoded using the operations and the computational budget. This process is repeated for the remaining inter-coded frames of video data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08358693&OS=08358693&RS=08358693
owner: Microsoft Corporation
number: 08358693
owner_city: Redmond
owner_country: US
publication_date: 20060714
---
With rapid increases in network communications bandwidth real time visual communication transmissions of video are generally not restricted by bandwidth availability. However computational costs i.e. processor workloads to encode different frames of video content typically vary. That is as video frame content changes so does computational requirements to encode the content. For instance an early termination mechanism adopted in H.264 video encoding motion estimation ME operations results in varying computational costs to encode different frames of video data. This is potentially problematic especially since availability of a processor s limited computational resources generally changes over time. When necessary computational resources are not available it is often difficult to maintain a consistent frame encoding rate for real time video transmission. Generally this causes computation overflow dropped video frames and the introduction of jitter transmission delays into a video stream resulting in low quality video playback.

Computation scheduling and allocation for visual communication is described. In one aspect multiple frames of video data are encoded by allocating for at least a subset of inter coded frames on frame by frame basis computational resources to encode the inter coded frame. To this end a computational budget to encode a current inter coded frame is estimated. The estimate is based on the actual computational costs to encode a previous inter coded frame of video data. Next sets of operations associated with encoding the current inter coded frame are analyzed to determine computational resources to implement the operations. If the computational resources exceed the computational budget complexity of the operations is reduced until the associated computational resources are less than or equal to the computational budget. At this point the current inter coded frame is encoded using the operations and the computational budget. This process is repeated for the remaining inter coded frames of video data.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Techniques using motion history memory and sorted distortion computation slopes have been used to estimate and allocate computation resources for video transmission. These techniques however are problematic in that they may introduce prohibitive memory demands and computational costs into video encoding and transmission operations. As discussed above the may result in dropped frames and the introduction of jitter. These techniques are also limited in that they do not produce precise enough results to utilize H.264 fast motion estimation FME techniques.

In contrast systems and methods for computation scheduling and allocation for visual communication described below in reference to balance computation adaptation with coding efficiency to guarantee that frames of video data are encoded before a certain delay. Since this is performed on a frame by frame basis the systems and methods ensure a consistent encoding rate for real time video transmission and thereby prevent dropped frames and or introduction of jitter into resulting real time video transmissions.

Although not required systems and methods for computation scheduling and allocation for visual communication are described in the general context of computer executable instructions executed by a computing device such as a personal computer. Program modules generally include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. While the systems and methods are described in the foregoing context acts and operations described hereinafter may also be implemented in hardware.

For example server includes processor coupled to system memory . Processor may be a microprocessor microcomputer microcontroller digital signal processor etc. System memory includes for example volatile random access memory e.g. RAM and non volatile read only memory e.g. ROM flash memory etc. . System memory comprises program modules and program data . Program modules include for example video encoder computation resource scheduling and allocation CSA complexity adjustable motion estimation CAME and other program modules such as an Operating System OS device drivers and or so on.

Video encoder employs operations of CSA and CAME to encode frames of video data . In one implementation for example CSA and CAME expose respective application programming interfaces APIs and to allow video encoder to utilize their respective operations. In another implementation operations of one or more of CSA and CAME are encapsulated by video encoder independent of one or more exposed APIs. For purposes of exemplary illustration encoded video data that has been generated by video encoder according to the following described operations is shown as a respective portion of other program data .

More particularly for each of at least a subset of frames of video data i.e. inter coded frames video encoder uses CSA to calculate and schedule a computational budget i.e. b to encode the frame. Detailed aspects of CSA are described below in the section titled Computation Resource Scheduling . In general however CSA determines computational budget in view of a actual computational cost to encode a previous frame of video data b calculated upper and lower computational bounds of processor in view of buffer constraints and c smallest and largest encoding complexities associated with encoding the current frame i.e. current inter coded frame of video data . At this point CAME analyzes ME operations of the current frame to balance motion RD and computational costs and thereby identify an optimal set of ME operations for the frame to at least match computational budget . Detailed aspects of CAME are described below in the section titled Complexity Adjustable Motion Estimation .

Video encoder encodes the frame using the identified optimal set of ME operations using the allocated computational budget of processor . Server then transmits the encoded video to a remote server for decoding e.g. using decoder module and playback e.g. using player module including presentation e.g. via display device to a user. After a frame is encoded the encoded frame is ready to be transmitted. The instant of its transmission depends on other program modules . For purposes of exemplary illustration such video transmission logic is shown as a respective portion of other program modules .

In one implementation CAME directs processor to allocated computational budget to encode the frame. In another implementation a different module e.g. CSA etc directs processor to allocated computational budget to encode the frame.

Video encoder utilizes CSA to balance computation resource adaptation and coding efficiency thereby providing computation control guaranteeing that each frame of input video data a video stream is successfully encoded before a certain delay. That is CSA maintains actual computation consumption e.g. between line Aand line Aof . This provides a consistent encoding frame rate with no jitter no buffer overflow frame dropping and no buffer underflow.

More particularly assume T Tand Trespectively denote time instants that 1 a kframe arrives at an encoding buffer 2 video encoder starts encoding the kframe and 3 video encoder ends encoding of the kframe. An exemplary encoding buffer is shown as a respective portion of other program data as a computation buffer . Tof denotes a time when the kframe is removed by video encoder from the computation buffer. Suppose computation cost of encoding the kframe is b size of the computation buffer is B and fullness of the computation buffer when the kframe arrives is B. Suppose the computation rate is C and frame encoding delay is a constant . Thus the time when the kframe is removed by video encoder from the computation buffer is T T . Suppose the rate at which frames of video data arrive at the computation buffer i.e. frame rate is M frames per second. The time instant a kframe arrives at the computation buffer is T k 1 M. CSA guarantees the time when the kframe is removed by video encoder from the computation buffer is greater than or equal to the time when video encoder ends encoding of the kframe i.e. T T to avoid overflow overload of computational cost.

Since the time when video encoder starts encoding a kframe T is equal to the time when the kframe arrives at an encoding buffer T plus an indication of fullness of the computation buffer when the kframe arrives i.e. B divided by the computation rate C i.e. T T B C then T T b C. Supposing the frame encoding delay B C we get b B B. i.e. computation cost of encoding the kframe is less than or equal to the size B of the computation buffer minus fullness B of the computation buffer when the kframe arrives . Thus the upper computation bound upper bound of processor workload for a current frame is U B B. Additionally CSA guarantees b B C M so as to avoid underflow of computational cost. Accordingly the lower computation bound lower bound of processor workload for the current frame k is L max0 C M B. With the upper and lower bounds representing respective states of the computation buffer buffer states CSA schedules for allocation of computation resources of processor to encode a current frame of video data .

CSA determines the number of overall processing cycles to a current frame not the number of processing cycles to perform a task such ME. A certain number of processing cycles to a specific task such as ME is determined for example with CAME . To this end CSA estimates computational cost of the current frame bbased on the actual computational cost of encoding a previous frame of video data and estimated task complexities of encoding a previous frame of video data. In this implementation the previous frame is an immediately previous frame. In another implementation the previous frame is the immediately previous frame or a frame prior to the immediately previous frame. CSA then calculates a computational budget b according to computation bound statuses of the computation encoding buffer and encoding complexities of the current frame. This is accomplished as follows 

After a current frame of video data has been encoded CSA or a different module updates state buffer computational statuses of the computation buffer to reflect the actual computational cost to encode of the current frame.

In real time video communication systems there is a high computational cost of full search motion estimation operations. Such costs are based on encoding rates and distortion. To address this CAME analyzes ME path costs. This analysis provides an objective determination of whether select one of ME operations and associated operational paths of the current frame are compatible with the computational budget b . In this implementation operations of CAME are performed done after the determination of computation budget of a current frame. After the encoding of the current frame parameters related to CAME will be updated for the encoding of a following frame.

In general a fast motion estimation algorithm 1 checks motion vector predictors using both spatial and temporal correlations to determine an initial searching point 2 evaluates candidate points around the initial searching point using searching patterns to obtain motion vector s and 3 locally searches around the obtained motion vectors using a small search pattern to refine the motion vector s . Exemplary motion vector predictors include for example the median prediction the 0 0 vector and the motion vectors of the neighboring left top and top right blocks. A searching point is a location of a candidate predicting block in the reference frame.

Of steps 1 3 step 2 utilizes the majority of processor computational resources. This is because step 2 evaluates candidate searching points. Step 1 may identify very good motion vector s and if so the second step 2 could be skipped. However step 2 is still efficient to identify motion vector s for video sequences with complex motions and textures. In this implementation CAME determines whether use of a particular step e.g. step 2 will provide gain i.e. not overflow computational resources during frame encoding operations. If such objectively determined gain is evident CAME will implement the particular set of operations. Otherwise CAME will skip the particular step. To this end and in this implementation CAME separates fast ME operations from slower ME operations implemented by video encoder into multiple ME operational paths e.g. two paths as shown for example in . In another implementation CAME separates segments fast motion estimation operations implemented by video encoder into more than two paths based on the particular encoding algorithm being employed.

CAME provides complexity level c for use equations 1 and 2 defines c a set of candidate motion vectors and selects a best ME search path in terms of these motion vectors. CAME implements path selection criterion based for example on the following ratio 

For example in the above described path selection process J B and J C are used to select a certain path of A B D or A C D. To further select a stopping point at the selected path for example when the path of A B b is selected we can use J B and J D to select the stopping point to be either B or D with a second pre defined threshold. In this implementation for example the second threshold is 0.01 although it could be a different value to tune the results to the data being encoded.

Since ME cost at each step prior to coding of a current frame of video data is not available CAME employs actual cost of a previously coded frame of video data to estimate ME cost of the current frame of video data . The estimate is denoted as J X wherein X represent a specific searching point or ME operation. This process is called forward path selection. In the forward path selection. In this implementation and to guarantee that there is minimal performance loss CAME assumes computation budget determined by CSA is enough to encode the current frame. CAME determines whether computation budget is enough by comparing it with the motion cost associated with various ME paths and stopping points in forward path selection operations. TABLE 2 shows exemplary forward path selection operations that are implemented independent of computational cost of operations associated with an ME path according to one embodiment.

If CAME determines that computation budget b is not enough to encode the current frame k CAME adjusts the operations of selected ones of the ME operational paths by calculating slopes of ME operational paths to trace backward to a certain point to meet computation budget . In this process a path with smaller slope indicates more coding gain per computation. Therefore CAME selects a path with a smaller slope as compared to slope s of other path s . Referring to the example of please note that the slope of path A B is not always larger than that of path A C. The above process is called the backward path selection. TABLE 3 shows exemplary backward path selection operations to refine computational cost of ME path operations according to one embodiment.

Again CAME implements forward path selection operations first to select a ME path and stopping point independent of available computation resources. After this resource independent ME path and stopping point have been determined ME path computation resources to implement the path are identified. For purposes of exemplary illustration such E path computation resources are shown as a respective portion of other program data . If the determined ME path computation resources are greater than computational budget CAME performs the backward path selection operations e.g. TABLE 2 to change the selected ME path and the stopping point. This process is iteratively performed until a selected ME path and stopping point are determined to use less than or equal amounts of computational resources as computational budget .

At this point CAME allocates computational budget to encode a current frame of video data . Techniques to direct a processor to allocate a certain number of processing cycles to execute a set of operations are known. For example in one implementation CAME sets a register used by processor to indicate the number of processing cycles to allocate to encode a current frame of video data . Video encoder encodes the frame to generate encoded video data for transmission to client computing device .

Referring to CSA component implements operations of CSA of to schedule computational budget to encode a current frame of video data as described above with respect to . Component implements operations of CAME as described above with respect to to identify a select set of motion vectors a path between a current frame F and a reference frame F of video data that meet computational budget . Remaining blocks through of represent conventional video encoding operations implemented by video encoder of .

At block video encoder or CSA calculates upper and lower computational bounds of processor . In one implementation these computational bounds are determined in view of encoding buffer constraints such as size of the computation buffer fullness of the computation buffer when a current frame arrives computation rate frame encoding delay time when the frame is removed by encoder for encoding and or so on. At block video encoder determines whether the current frame of video data is an inter coded frame of video data . If not operations continue at block where the frame is encoded using conventional frame encoding operations. At this point the procedure continues at block wherein the encoded frame is communicated to a remote computing device for real time presentation to a user. At block video encoder determines if there is a next frame of video data to encode. If so operations continue at on page reference A and block as discussed above for non inter coded frames and below for inter coded frames.

Referring again to block if the current frame of video data is an inter coded frame operations continue at block wherein the procedure determines if the frame is a first interceded frame encountered in this encoding operation. If so operations continue at block where the frame is encoded using conventional frame encoding operations and actual computational cost to encode the inter coded frame is determined. Techniques to determine computational costs of a set of operations are known. In one implementation this and other computational costs are stored as statuses of an encoding or computational buffer. At this point operations continue at block as discussed above.

Referring again to block if the current frame of video data is not the first interceded frame encountered in this encoding operation operations continue at block . At block video encoder leverages operations of CSA to determine and schedules computational budget to encode the current frame of video data. This computational budget is based at least on actual computational costs to encode a previous frame of video data. More particularly the computational budget is calculated based on an evaluation of complexity levels associated with coding the current frame upper and lower computational balance of the processor that is being used to encode the current frame and the actual computational cost of encoding a previous inter coded frame.

At block video encoder uses CAME to calculate computational costs of respective ones of multiple motion estimation operations associated with the current frame of video data . CAME utilizes these computational costs to adjust encoding complexity of to include at least a subset of these operations so that they conform to the computational budget the computational budget was generated at block . At block video encoder encodes the current frame of video data using the selected motion estimation operations and the computational budget and calculated the actual computational cost to encode the current frame of video data. Operations of procedure continue at block as discussed above.

Although systems and methods for computation scheduling and allocation for visual communication have been described in language specific to structural features and or methodological operations or actions it is understood that the implementations defined in the appended claims are not necessarily limited to the specific features or actions described above. Rather the described features are disclosed as exemplary forms of implementing the claimed subject matter.

