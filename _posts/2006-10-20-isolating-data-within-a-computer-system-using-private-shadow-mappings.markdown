---

title: Isolating data within a computer system using private shadow mappings
abstract: Virtualization software establishes multiple execution environments within a virtual machine, wherein software modules executing in one environment cannot access private memory of another environment. A separate set of shadow memory address mappings is maintained for each execution environment. For example, a separate shadow page table may be maintained for each execution environment. The virtualization software ensures that the shadow address mappings for one execution environment do not map to the physical memory pages that contain the private code or data of another execution environment. When execution switches from one execution environment to another, the virtualization software activates the shadow address mappings for the new execution environment. A similar approach, using separate mappings, may also be used to prevent software modules in one execution environment from accessing the private disk space or other secondary storage of another execution environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274974&OS=09274974&RS=09274974
owner: VMware, Inc.
number: 09274974
owner_city: Palo Alto
owner_country: US
publication_date: 20061020
---
This application claims benefit under 35 U.S.C. 119 e of U.S. Provisional Application No. 60 729 185 filed 21 Oct. 2005.

This invention relates to isolating the code and or data of one or more software modules within a computer system.

The invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. For example the computer readable media may comprise one or more CDs Compact Discs one or more DVDs Digital Versatile Discs some form of flash memory device a computer hard disk and or some form of internal computer memory to name just a few examples. An embodiment of the invention in which one or more computer program modules is embodied in one or more computer readable media may be made by writing the computer program modules to any combination of one or more computer readable media. Such an embodiment of the invention may be sold by enabling a customer to obtain a copy of the computer program modules in one or more computer readable media regardless of the manner in which the customer obtains the copy of the computer program modules. Thus for example a computer program implementing the invention may be purchased electronically over the Internet and downloaded directly from a vendor s web server to the purchaser s computer without any transference of any computer readable media. In such a case writing the computer program to a hard disk of the web server to make it available over the Internet may be considered a making of the invention on the part of the vendor and the purchase and download of the computer program by a customer may be considered a sale of the invention by the vendor as well as a making of the invention by the customer.

This invention may be implemented in a wide variety of computer systems having a wide variety of hardware platforms and configurations and a wide variety of software platforms and configurations. If a computer system includes multiple software entities or software modules or at least has the potential to contain multiple software modules then the integrity of the computer system may be improved by implementing this invention to protect the code and or data of one or more of the software modules from other software modules in the system.

Over the years a variety of techniques have been used for executing multiple software modules within a computer system. Early computer systems could execute multiple software programs but they could only execute one program at a time. Such computers might load one program into memory and execute it to completion or other termination before proceeding to a subsequent program that would then be loaded into memory and executed. As another example various multitasking operating systems OSs enable multiple programs or selected portions thereof to be loaded into memory at one time and executed in an alternating manner according to a scheduling algorithm. Also some processors include multithreading capabilities which enable multiple threads of one or more programs to be executed simultaneously on a single processor. Finally multiprocessor computer systems have also become commonplace in which each of multiple processors can execute one or more threads all at the same time. This invention may be advantageously implemented in any of these types of systems as well as other possible computer systems in which multiple software modules may be executed.

Such computer systems generally attempt to isolate the code and data of the different software modules within the computer system from each other so that for example one software module cannot interfere with the execution of another software module by altering its code or data. Such isolation may be provided for code and or data that is stored on a hard drive or other secondary data storage means and or that is resident in main memory or other primary data storage means . In this patent the term data is generally used in a broad sense to include data that is operated on by the instructions code of a software module as well as the contents of a stack and any other possible forms of data that are associated with a software module. As one example of the isolation of code and data many systems implement a virtual addressing mechanism in which different software modules within the system have different virtual address spaces with each virtual address space generally being mapped to different portions of the physical address space of the computer system so that the virtual addresses of a given software module are generally only mapped to physical addresses that contain the code or data of that particular software module. Virtual addressing mechanisms are described in greater detail below. A given software module may attempt to access every memory location in its own virtual address space accessing every memory location to which it has access and it will still only be able to access its own code and data assuming that there is no shared memory . Thus providing a virtual addressing mechanism provides some isolation between the code and data of multiple software modules in a computer system. Various other protection mechanisms may also be implemented in such computer systems to isolate the code and or data of multiple software modules from one another.

Although the invention may be implemented in a wide variety of computer systems having a wide variety of hardware and software platforms and configurations the following description is generally limited to a single hardware platform for brevity. In particular this description is generally limited to computer systems that include one or more processors having the x86 architecture which is described in the IA 32 Intel Architecture Software Developer s Manual the IA 32 Manual from Intel Corporation. Also for brevity the following description is generally limited to computer systems running a Windows OS from Microsoft Corp. or a Linux OS although there are certainly other OSs that operate on the x86 platform. A Windows OS from Microsoft Corp. may be a Windows XP OS or a Windows 2000 OS for example while a Linux OS may be a distribution from Novell Inc. SUSE Linux Mandrakesoft S.A. or Red Hat Inc. Based on the following description related to the x86 architecture and a Windows or Linux OS a person of skill in the art will be able to implement the invention in a wide variety of other computer systems.

The x86 architecture provides two primary memory protection mechanisms that may be used by an OS or other system software to try to isolate the code and data of multiple tasks or processes that execute on the processor namely a segmentation mechanism and a paging mechanism. The IA 32 Manual may be consulted for a detailed description of these protection mechanisms. The Windows and Linux OSs use the paging mechanism but they generally don t take advantage of the segmentation mechanism. Instead these OSs define segments that include the entire addressable range of the processor so that the segmentation protection mechanism becomes ineffective in providing isolation between the code and data of multiple tasks. Thus for simplicity this discussion focuses on the paging mechanism of the x86 processor which implements a virtual addressing mechanism as described briefly above and in greater detail below.

Very briefly for now for Windows and Linux OSs different user processes are generally given different virtual address spaces. The OS creates a different set of page tables and a page directory for each virtual address space which maps the respective virtual addresses to physical addresses. Thus the page tables for a given user process map that process s virtual addresses to the physical addresses that contain the code and data for that process. The page tables for the user processes also contain mappings for code and data of the OS but the user processes cannot use these mappings because the user processes are executed at a Current Privilege Level CPL of 3 and these mappings are set to require a supervisor privilege level a CPL of 0 1 or 2 . Otherwise the page tables for a given user process generally only contain mappings to physical memory pages that contain that process s code and data. Therefore a user process can generally only access its own code and data. Executing the user processes at a CPL of 3 also prevents the processes from modifying their own page tables. Otherwise a process could add entries to its page tables that map to any physical address in the system so that the process could give itself access to the code and data of other software modules including other user processes and the OS.

Windows and Linux OSs generally provide adequate protection for the software modules in a computer system so long as all of the software modules are well designed and well behaved meaning that they are not attempting to circumvent the protection mechanism. Thus many processes may be running concurrently in such a computer system with the OS giving each process a share of the system resources including processor time memory space and hard disk space without any of the processes interfering with the code or data of the other processes.

The OS A in conjunction with the system hardware A attempts to isolate the code and data of the applications A and B from one another. For example the OS A and the system hardware A may implement a virtual addressing mechanism as described above. As illustrated in implementing such a protection mechanism may be characterized as establishing an isolation barrier B between the applications A and B preventing or at least hindering one application from accessing the code and data of the other application. There may also be some code and or data that is shared explicitly or transparently between the applications A and B. Techniques are known for allowing such sharing of code and data while maintaining isolation between the applications A and B. For example the OS A may mark physical memory pages that contain shared code or data as read only such as when using a copy on write COW technique. The isolation barrier B may be referred to as an OS isolation barrier because it is implemented by the OS A in conjunction with the system hardware A. The OS A again in conjunction with the system hardware A also establishes an OS isolation barrier A between the OS A and all applications in the system including the applications A and B so that the applications are prevented or hindered from directly accessing the code and data of the OS A. In the case of a Windows or Linux OS running on an x86 platform the OS isolation barrier A is established by executing the applications in the system at a CPL of 3 and requiring a supervisor privilege level to access memory pages containing the code and data of the OS A.

Although the Windows and Linux OSs provide adequate isolation between software modules for computer systems that contain only well designed and well behaved software modules malicious software modules have been known to wreak havoc in such computer systems by circumventing the protection mechanisms and engaging in all sorts of mischief. In particular such malicious software modules have been known to breach the OS isolation barriers B and A and corrupt the code and or data of other applications in the system and or of the OS itself. Numerous security vulnerabilities have been discovered in the Windows OSs and to a lesser extent in the Linux distributions and many of these vulnerabilities have been exploited by hackers using different types of malicious software such as viruses worms etc. Microsoft Corp. acknowledges in its 006 patent referenced below that open operating systems that allow users to easily install hardware and software . . . are inherently untrustworthy the 006 patent paragraph 0004 . Poorly designed or implemented software may inadvertently bypass these protection mechanisms too and may also wreak havoc in a computer system. Although the description in this patent generally relates to malicious software it also applies to software that inadvertently has the same or similar effects as malicious software.

Thus hackers that exploit the vulnerabilities described above do so for a variety of reasons and with a variety of goals some being relatively benign and others being quite destructive or disruptive. As one example a malicious software module may be written and deployed that searches for sensitive data on a computer s hard drive or in its memory and transmits any such sensitive data back to the hacker that launched the malicious code. If the malicious software manages to execute at supervisor level with a CPL of 0 1 or 2 which is a common occurrence then the malicious software may access a variety of system resources that are supposed to be safeguarded. For example the malicious software can create its own page table entries and obtain access to any address within the physical address space of the processor. The malicious software can then scan the entire physical memory for sensitive data including memory that contains code and data of other software modules. A wide variety of other possibilities also exist.

Security threats such as these have been gaining greater notoriety and it is widely accepted that something should be done to improve the security of the ubiquitous personal computer and in particular there is a recognized need to improve the security for the vast number of computers based on the x86 architecture. Many people believe that software changes alone will not provide adequate protection. Accordingly many different companies are working toward solutions that involve substantial changes to both the system hardware and the system software of a computer system. Many such security measures will also require substantial changes to application level software as well. Some of the security measures that have been or are being pursued by various companies are described below.

U.S. Pat. No. 6 507 904 Ellison et al. Executing Isolated Mode Instructions in a Secure System Running in Privilege Rings the 904 patent which was assigned to Intel Corporation describes a computer system in which a processor operates in either a normal execution mode or an isolated execution mode. Among other features the computer system includes an isolated region in system memory that is protected by both the processor and a chipset of the computer system. Access to the isolated region is permitted only when using special bus cycles referred to as isolated read and write cycles. The isolated read and write cycles may only be issued by the processor when it is executing in the isolated execution mode. Execution in the isolated execution mode is restricted so that access to the isolated memory region is also restricted accordingly.

U.S. Pat. No. 6 820 177 Poisner Protected Configuration Space in a Protected Environment the 177 patent which was also assigned to Intel Corporation describes a computer system in which the physical address space encompasses a protected configuration space and a non protected configuration space. Attempts to access addresses within the protected configuration space are redirected to protected configuration hardware that is external to the system memory. This protected configuration hardware holds control values provides control information and performs operations pertaining to a protected operating environment. Attempts to access the protected configuration space are permitted only if they are made by a processor and only if they are made using a protected command. Restricting access to the protected configuration hardware purportedly enables the system to maintain a protected operating environment. The protected operating environment may include blocks of protected memory which are apparently protected from any attempted access by non processor devices.

U.S. Pat. No. 6 986 006 Willman et al. Page Granular Curtained Memory via Mapping Control the 006 patent which was assigned to Microsoft Corporation describes a method by which access to trusted memory is restricted using a paging mechanism by not including mapping entries in page tables that map to physical memory pages that contain the trusted memory. The memory pages that contain the page tables are then restricted to read only access when the processor is operating in a non trusted mode to prevent non trusted software from adding a new mapping entry or modifying an existing mapping entry to map to trusted memory. If non trusted software attempts to write to a memory page containing a page table a context switch is initiated into a page table entry edit module which is trusted software. The page table entry edit module then ensures that the attempted write does not establish a mapping into trusted memory. The 006 patent does not specifically indicate how non trusted software is prevented from changing the memory pages containing page tables to read write access or from corrupting or supplanting the page table entry edit module to enable the non trusted software to establish a mapping to trusted memory. The 006 patent does indicate however that the memory controller or other hardware may be able to restrict access to certain pages of physical memory under the control of the page table entry edit module. A new hardware platform or substantial changes to an existing hardware platform would presumably be necessary to implement such a restriction.

U.S. Pat. No. 7 058 768 Willman et al. Memory Isolation Through Address Translation Data Edit Control the 768 patent which is a continuation in part of the 006 patent and which was also assigned to Microsoft Corporation is similar to the 006 patent although the 768 patent uses different terminology and it goes into greater detail in some areas. The 768 patent describes a computer system that includes a trusted environment and an untrusted environment. A trusted component in the trusted environment purportedly ensures that when the system is executing in the untrusted environment no active address translation map includes an address mapping that maps to isolated memory so that the isolated memory is not accessible to untrusted components. Again the 768 patent does not specify how the trusted environment is established or maintained but implementing the computer system described in the 768 patent presumably requires substantial hardware changes.

U.S. Patent Application Publication No. 2004 0205203 Peinado et al. Enforcing Isolation Among Plural Operating Systems the 203 application which was also assigned to Microsoft Corporation describes a method for restricting the physical addresses that are accessible to Direct Memory Access DMA devices in a computer system in which multiple OSs run. In this method a security kernel maintains a DMA exclusion vector that specifies which physical addresses are accessible to different DMA devices. A hardware device referred to as a regulator enforces the physical address restrictions specified in the DMA exclusion vector. The 203 application also briefly mentions the possibility of using a shadow page table technique to prevent one OS from accessing the private data of another OS and the 203 application mentions the more general possibility of employing an adjunct memory access control scheme. 

U.S. Pat. No. 6 651 171 England et al. Secure Execution of Program Code the 171 patent which was also assigned to Microsoft Corporation describes a system in which hardware enforces a restricted memory arrangement. Multiple curtained memory rings are arranged in a hierarchical manner similar to the protection rings of the x86 architecture. Different code and data are associated with each of the memory rings. Software in more privileged rings can access code and data in less privileged rings but software in less privileged rings cannot access code or data in more privileged rings. Also there may be multiple subrings within a given ring. Software within a given ring can also access code and data within its own ring except that it cannot access code or data within a different subring.

U.S. Patent Application Publication No. 2003 0093686 Barnes et al. Memory Management System and Method Providing Linear Address Based Memory Access Security the 686 application which was assigned to Advanced Micro Devices Inc. describes a Memory Management Unit MMU that includes a Security Check Unit SCU that receives a linear address generated during the execution of a current instruction. The linear address has a corresponding physical address residing within a selected memory page. The SCU uses the linear address to access one or more security attribute data structures located in the memory to obtain a security attribute of the selected memory page. The SCU compares a numerical value conveyed by a security attribute of the current instruction to a numerical value conveyed by the security attribute of the selected memory page and produces an output signal dependent upon a result of the comparison. The MMU accesses the selected memory page dependent upon the output signal. The security attribute of the selected memory page and the security attribute of the current instruction may each include a security identification SCID value indicating a security context level of the selected memory page or the current instruction respectively.

U.S. Pat. No. 6 823 433 Barnes et al. Memory Management System and Method for Providing Physical Address Based Memory Access Security the 433 patent which was also assigned to Advanced Micro Devices Inc. discloses a MMU that is similar to the MMU disclosed in the 686 application. A security unit in the MMU of the 433 patent uses a physical address instead of a linear address to access security attribute data structures to obtain a security attribute of a selected memory page. Otherwise the disclosure of the 433 patent is substantially similar to the disclosure of the 686 application.

U.S. Pat. No. 7 073 059 Worley J R. et al. Secure Machine Platform that Interfaces to Operating Systems and Customized Control Programs the 059 patent which was assigned to Hewlett Packard Company describes a Secure Platform SP which includes a software layer that executes at a privileged level on a modern processor architecture such as the IA 64 processor architecture from Intel Corporation. The SP interfaces with one or more OSs and customized control programs and allows them to access non privileged machine instructions and registers. However the OSs and customized control programs purportedly have no direct access to privileged instructions and registers and firmware interfaces. Instead the SP allows the OSs and customized control programs to invoke software routines that provide control of the hardware without exposing the privileged machine instructions and registers. The SP also organizes the resources of the system into one or more disjoint mutually isolated partitions called domains. A single OS and all user level processes managed by that OS together comprise a domain and each domain is allocated a separate portion of virtual memory along with other system resources. The SP employs the region registers and region identifiers along with protection keys of the IA 64 processor architecture to partition memory between the different domains.

With respect to the ubiquitous x86 platform each of the possible security measures described above would require substantial hardware changes or an entirely new hardware platform. They would also require substantial changes to existing software platforms including system software and possibly application software. Applications in some of these implementations might also have limited access to input output devices because of a limited supply of trusted device drivers. A widespread transition from the x86 platform to a new hardware platform will likely be a slow gradual process. The amount of money that is invested in computer hardware and software based on the x86 architecture throughout the world is enormous. Many individuals businesses schools governments and other organizations will be reluctant to scrap their current x86 systems along with all the software that currently runs on x86 systems and replace them with new technology. Even if a new more secure and widely accepted hardware platform were available today it would still take a long time for the new hardware to become anywhere near as widespread as the x86 platform is today. In the meantime a large number and proportion of computers would remain vulnerable to the security threats described above.

Also even those individuals and organizations that quickly adopt the new hardware and software technology may still be susceptible to adverse effects resulting from lingering vulnerabilities of x86 computers. For example a malicious software module may attack an x86 based server computer running a web application. If the malicious software takes down the server computer any client computer attempting to access the web application will be adversely affected no matter how secure the client computer is. As another example a malicious software module may infect a large number of x86 computers connected to the Internet. The many instances of the malicious software module on all the x86 computers may then mount a coordinated denial of service attack on a particular website on the Internet. In this case the server computer s that are hosting the website and any bonafide client computers trying to access the website may be adversely affected by the attack again regardless of the technology implemented in either the server computer s or the bonafide client computers.

As a final example even if an individual or organization has spent the money to replace all of its own computers and software with the new technology sensitive information of the individual or organization may still reside on some external computer that remains vulnerable to the security threats described above. Suppose for example that an individual forks out the money to buy a new computer system based on a new hardware and software platform so that all the sensitive information on the individual s computer system is now relatively secure. Suppose further however that the individual s bank or any other organization that has sensitive information of the individual such as some small company running an obscure Internet website from which the individual has made a purchase has thus far continued to use its x86 computers instead of investing in the new technology. Again if malicious software is able to exploit a vulnerability in the bank s computer system a hacker may be able to steal sensitive information of the individual no matter what technology the individual is using.

What is needed therefore is a security measure that can be implemented more quickly and easily without requiring such a large investment in new computer hardware and software. More particularly what is needed is a solution that provides better isolation for the code and or data of software modules within a computer system but that can be implemented in software without any hardware changes and with at most only minor software changes.

There are some proposed security measures that may be implemented primarily in software. In particular there are some such measures that use virtualization technology to create multiple virtual machines VMs where different software modules run in different VMs. It is widely recognized that a well designed and implemented virtualization layer can generally provide much greater isolation between multiple VMs than a general OS can provide between multiple software modules. For example U.S. Pat. No. 6 922 774 Meushaw et al. Device for and Method of Secure Computing Using Virtual Machines the 774 patent which was assigned to the National Security Agency of the U.S. Government describes a computer system that includes a Virtual Machine Monitor VMM that allows a user to create a number of VMs. The system includes a user definable number of non sensitive VMs and a user definable number of sensitive VMs all of which are isolated from one another by the virtualization technology. Each sensitive VM provides access to a secure area in a computer system that is accessible only through encrypted and or authenticated connections. An encryption VM is created for and connected to each sensitive VM where each encryption VM provides encryption capabilities as well as possibly digital signature and key exchange capabilities. The computer system may also include a server connected to each VM in the system where the server may be another VM or a stand alone device. Each VM in the system can send information to the server and the server can send information to any VM in the system except as limited by user definable rules for when a transfer is or is not appropriate to be transferred from one VM to another. Thus the server allows information to be transferred from one VM to another when appropriate while maintaining isolation between VMs.

Another proposed security measure that takes advantage of the isolation provided by implementing multiple VMs was described in a technical paper entitled Terra A Virtual Machine Based Platform for Trusted Computing which was submitted to and presented at the Symposium on Operating Systems Principles October 19 22 2003 by Tal Garfinkel Ben Pfaff Jim Chow Mendel Rosenblum and Dan Boneh the Terra paper . The Terra paper describes a trusted VMM that partitions a single tamper resistant general purpose platform into multiple isolated VMs. Existing applications and OSs can each run in a standard open box VM that provides the semantics of today s open platforms. Applications can also run in their own closed box VMs that provide the functionality of running on a dedicated closed platform. Among various other aspects of the proposed security measure VMs on a single physical machine communicate with one another over virtualized standard input output interfaces such as network interface cards serial ports etc.

In supporting the VM A the virtualization software A virtualizes a virtual system hardware A which may be based on an existing hardware platform such as the x86 platform. An OS B along with a set of drivers B run on the virtual system hardware A. The OS B may be any OS designed to run on the hardware platform virtualized in the virtual hardware A. For example if the virtual hardware A is based on the x86 platform the OS B may be a Windows OS or a Linux OS. The set of drivers B may be conventional drivers for the OS B. A first application C and a second application D run on the OS B. The applications C and D may be any applications designed to run on the platform of the virtual hardware A and the OS B. Similar to the OS A of the OS B in conjunction with the virtual system hardware A attempts to isolate the code and data of the applications C and D from one another establishing an OS isolation barrier B between the applications C and D. Also similar to the OS A of the OS B again in conjunction with the virtual system hardware A also establishes an OS isolation barrier A between the OS B and all applications in the VM A including the applications C and D. Thus the VM A may be substantially the same as the computer system A except that the virtual system hardware A is virtual hardware virtualized by the virtualization software A instead of physical hardware.

In supporting the VM B the virtualization software A virtualizes a virtual system hardware B which may be based on an existing hardware platform such as the x86 platform. An OS C along with a set of drivers C run on the virtual system hardware B. The OS C may be any OS designed to run on the hardware platform virtualized in the virtual hardware B. For example if the virtual hardware B is based on the x86 platform the OS C may be a Windows OS or a Linux OS. The set of drivers C may be conventional drivers for the OS C. A first application E and a second application F run on the OS C. The applications E and F may be any applications designed to run on the platform of the virtual hardware B and the OS C. Again similar to the OS A of the OS C in conjunction with the virtual system hardware B attempts to isolate the code and data of the applications E and F from one another establishing an OS isolation barrier B between the applications E and F. Also similar to the OS A of the OS C again in conjunction with the virtual system hardware B establishes an OS isolation barrier A between the OS C and all applications in the VM B including the applications E and F. Thus again the VM B may be substantially the same as the computer system A except that the virtual system hardware B is virtual hardware virtualized by the virtualization software A instead of physical hardware.

The virtualization software A isolates the VMs in the computer system B from one another. For example the virtualization software A allows software within the VM A to access portions of physical memory in the system hardware B and it allows software within the VM B to access other portions of the physical memory. The virtualization software A maps attempted memory accesses from the respective VMs A and B to different portions of the physical memory ensuring that no memory address generated by software in one VM can access code or data of another VM. In a similar manner the virtualization software A maps attempted hard disk accesses from the respective VMs A and B to different portions of one or more hard disks in the system hardware B ensuring that one VM cannot access the hard disk space of another VM.

The virtualization software A also takes other precautions to isolate the VMs in the computer system B from one another and from the virtualization software A itself. For example U.S. patent application Ser. No. 10 917 713 Agesen et al. Restricting Memory Access to Protect Data when Sharing a Common Address Space the 713 application which has been assigned to the same assignee as this patent and which is hereby incorporated herein by reference describes methods that may be used to enable a VMM to occupy a portion of a linear address space of a VM while preventing the VM from accessing the memory of the VMM. There are also various other methods that may be used to enable virtualization software to coexist with VMs in a virtual computer system while protecting or isolating the virtualization software from software within the VMs. The virtualization software A may also prevent software within the VMs A and B from directly accessing certain hardware resources to further isolate the VMs from one another and from the virtualization software A. For example the virtualization software A may prevent software within the VMs A and B from directly accessing a Direct Memory Access DMA device to prevent the possibility that the DMA device could be used to access either the hard disk space or the memory of other VMs or of the virtualization software itself. Various other precautions may also be taken depending on the particular implementation. In addition to the precautions described thus far the underlying system hardware may provide further support for isolating the VMs from each other and from the virtualization software. For example Intel Corporation has implemented its Virtualization Technology Intel VT and Advanced Micro Devices Inc. has implemented its AMD Virtualization AMD V or Secure Virtual Machine SVM which provide hardware enhancements to facilitate the implementation of virtual computer systems.

Thus the virtualization software A in conjunction with the system hardware B may be said to establish a first isolation barrier B between the VMs A and B and a second isolation barrier A between the virtualization software A and all VMs in the computer system B including the VMs A and B. The isolation barriers A and B may be referred to as virtualization barriers because they are implemented by the virtualization software A in conjunction with the system hardware B. The isolation barriers A and B may also be referred to as virtualization barriers because they are established through the virtualization of hardware resources such as the virtualization of system memory.

It is widely recognized that virtualization techniques can generally provide better security and more effective isolation between multiple software modules than general OSs provide. Thus the virtualization barriers A and B of can generally provide much better isolation between the multiple VMs A and B and the virtualization software A than the OS isolation barriers A and B of provide between the multiple applications A and B and the OS A. This improved isolation can be attributed to a variety of factors depending on the particular situation. For example OSs such as the OS A generally provide an Application Programming Interface API for use by applications such as the applications A and B. These APIs can be used by application software first to discover and then to exploit vulnerabilities within the OS. Virtualization software in contrast generally has no such interface or at least a more limited and or restricted interface for use by the software within a VM. Also virtualization software generally does not need to rely on the integrity of third party device drivers. In contrast general OSs often allow third party device drivers to execute at a most privileged level on the system hardware so that they can access restricted hardware resources. If such a device driver contains malicious software the driver can compromise the integrity of the entire computer system. Also virtualization software is generally smaller and in some ways less complex than a general OS such as a Windows or Linux OS which generally leads to a smaller number of vulnerabilities that may be exploited to compromise the integrity of the computer system. Thus virtualization software is likely to have fewer vulnerabilities than a general OS and more importantly by the very nature of virtualizing a computer system the virtualization software is much more isolated from software within a VM than a general OS is from other software within a computer system making it much harder to discover and exploit any possible vulnerabilities.

Although computer systems that establish multiple VMs and that run different software modules within the different VMs generally provide better isolation for the software modules than do general OSs such virtual computer systems have other limitations. First if the software within a VM becomes corrupted by malicious software the same problems described above relative to non virtualized computer systems can occur within the affected VM. All software modules within the particular VM may be compromised by the malicious software. This scenario may be seen in . Suppose a malicious software module is able to execute within the VM A. If the malicious software is able to circumvent the OS isolation barriers A and or B within that VM then the malicious software can corrupt the OS B and or the applications C and D. The virtualization barriers A and B will generally contain the malicious software within the VM A however so that it is not able to corrupt the virtualization software A or the software within the VM B. Thus while the computer system B of is able to limit the corruption to the VM A the software within the VM A may be no more secure than the software within the computer system A of depending on the circumstances. Of course more VMs can be created within the virtual computer system B of to further isolate the software modules within the computer system but this increased isolation aggravates a second limitation of these virtual computer systems.

Multiple VMs within a computer system are generally similar to multiple physical computer systems. The multiple VMs generally have at most only limited communication and interaction with one another. For example in the computer system of the 774 patent the multiple VMs in the system can communicate with each other by sending information to a server which can send the information on to another VM in the system except as limited by user definable rules. In the computer system described in the Terra paper VMs on a single physical machine can communicate with one another over virtualized standard input output interfaces such as network interface cards serial ports etc. Many software modules within a computer system however require more effective interaction or communication with other software modules. For example multiple software modules may need to use shared memory to facilitate fast and efficient communication of data or a software module may need to call a subroutine of another software module.

Another disadvantage of a computer system in which multiple VMs are used to isolate multiple software modules is that setting up and using such a system generally takes significantly more time and effort than a computer system in which multiple software modules and a general OS run directly on physical hardware. Individuals and organizations may be reluctant to adopt a multiple VM solution or they may not use such a solution consistently enough. Anytime such a solution is not used and multiple software modules are run directly on a physical computer system or within a single VM the risk of corruption by a malicious software module is increased.

What is needed therefore is a computer system for executing multiple software modules that provides improved security such as is provided by the virtualized computer systems described above while also providing more efficient and effective communication and or interaction between multiple software modules. It would also be advantageous if such a computer system were easy to configure use and maintain.

One general embodiment of the invention is a computer system comprising system hardware the system hardware including a system memory containing a plurality of memory locations virtualization software supporting a virtual machine VM and guest software executing within the VM the guest software including a first software entity and a second software entity. In such an embodiment the virtualization software may activate hardware address mappings that are used to map attempted memory accesses to actual physical addresses in the system memory the attempted memory accesses resulting from the execution of the guest software and being directed to guest physical addresses within the VM the virtualization software may activate a first set of hardware address mappings when the first software entity executes within the VM the virtualization software may activate a second set of hardware address mappings when the second software entity executes within the VM where the first set of hardware address mappings map attempted memory accesses directed to a first guest physical address to a first actual physical address while the second set of hardware address mappings map attempted memory accesses directed to the first guest physical address to a second actual physical address where the second actual physical address is different from the first actual physical address so that attempted memory accesses directed to the first guest physical address are mapped to the first actual physical address when the first software entity is executing and to the second actual physical address when the second software entity is executing.

Another general embodiment of the invention is a method for inhibiting access to a first set of data by a second software entity the method being performed in a computer system comprising virtualization software running on system hardware and supporting a VM where the first set of data is stored in a system memory in the system hardware and where the first set of data is used by a first software entity. This method comprises when the first software entity is executing within the VM mapping from outside the VM attempted memory accesses to a first guest physical address within the VM to a first actual physical address in the system memory where the first set of data is stored in the system memory at the first actual physical address and when the second software entity is executing within the VM mapping from outside the VM attempted memory accesses to the first guest physical address within the VM to a second actual physical address in the system memory where the second actual physical address is different from the first actual physical address.

Another general embodiment of the invention is a computer program module embodied in a computer readable medium the computer program module being executable in a computer system comprising virtualization software running on system hardware and supporting a VM the computer program module inhibiting access to a first set of data by a second software entity where the first set of data is stored in a system memory in the system hardware and where the first set of data is used by a first software entity the computer program module performing the method described above.

More specific embodiments of the invention may be based on the above described general embodiments of the invention as described in the following paragraphs.

In other embodiments of the invention there is a first virtualization barrier between the VM on a first side of the first virtualization barrier and the virtualization software and the first and second sets of hardware address mappings on a second side of the first virtualization barrier. In other embodiments of the invention there is a second virtualization barrier between the first software entity on a first side of the second virtualization barrier and the second software entity on a second side of the second virtualization barrier.

In other embodiments of the invention the system hardware further comprises a physical secondary storage and the VM comprises a virtual secondary storage and an attempted access to a first location of the virtual secondary storage is mapped to a second location of the physical secondary storage when the first software entity executes within the VM and an attempted access to the first location of the virtual secondary storage is mapped to a third location of the physical secondary storage when the second software entity executes within the VM where the third location of the physical secondary storage is different from the second location of the physical secondary storage. In other embodiments of the invention the physical secondary storage comprises a physical disk drive and the virtual secondary storage comprises a virtual disk drive.

In other embodiments of the invention the hardware address mappings in both the first set of hardware address mappings and the second set of hardware address mappings are shadow address mappings. In other embodiments of the invention the first set of hardware address mappings is contained in a first shadow page table the second set of hardware address mappings is contained in a second shadow page table activating the first set of hardware address mappings comprises activating the first shadow page table and activating the second set of hardware address mappings comprises activating the second shadow page table. In other embodiments of the invention the first set of hardware address mappings is derived from a first set of guest address mappings and a first set of virtualization address mappings the second set of hardware address mappings is derived from a second set of guest address mappings and a second set of virtualization address mappings and the first set of virtualization address mappings maps the first guest physical address to the first actual physical address and the second set of virtualization address mappings maps the first guest physical address to the second actual physical address. In other embodiments of the invention the first set of virtualization address mappings is contained in a first address mapping module and the second set of virtualization address mappings is contained in a second address mapping module.

In other embodiments of the invention the hardware address mappings in both the first set of hardware address mappings and the second set of hardware address mappings are virtualization address mappings. In other embodiments of the invention the first set of hardware address mappings is contained in a first nested page table the second set of hardware address mappings is contained in a second nested page table activating the first set of hardware address mappings comprises activating the first nested page table and activating the second set of hardware address mappings comprises activating the second nested page table.

In other embodiments of the invention the virtualization software determines whether the first software entity is executing and whether the second software entity is executing by monitoring attempts to activate different page tables. In other embodiments of the invention the virtualization software determines whether the first software entity is executing and whether the second software entity is executing by monitoring use of address space identifiers. In other embodiments of the invention the virtualization software determines whether the first software entity is executing and whether the second software entity is executing by monitoring code that is being executed.

In other embodiments of the invention there is also an application stub and a bridge where the stub executes within the VM to facilitate operation of the first software entity where the bridge enables communications between the stub and the virtualization software and between the first software entity and the virtualization software and where the communications between the first software entity and the virtualization software takes place through a secure application programming interface.

In other embodiments of the invention the first set of hardware address mappings and the second set of hardware address mappings each map attempted memory accesses directed to a second guest physical address to a third actual physical address so that both the first software entity and the second software entity may access the third actual physical address by directing attempted memory accesses to the second guest physical address.

As described above this invention may be implemented in a wide variety of computer systems having a wide variety of hardware and software platforms and configurations. The invention involves creating one or more virtualization barriers to isolate one or more software modules from one or more other software modules in a computer system. The invention may be implemented in a wide variety of ways in a wide variety of virtualization configurations. Several different embodiments are described below along with some variations but many more embodiments and variations are also possible. The invention is described below in connection with two different virtual computer system configurations. These two virtual computer system configurations are substantially similar to configurations used in commercially available products of the assignee of this patent VMware Inc. The invention may also be implemented in a wide variety of other virtual computer systems however.

Also the commercial products of the assignee and the description in this patent are based on the x86 platform but the invention may be implemented on a wide variety of other hardware platforms. Also in the commercial products of the assignee and in this description the hardware platform that is virtualized within virtual machines is also based on the x86 architecture. However the invention may also be implemented in virtual computer systems that virtualize other hardware platforms including cross platform virtual computer systems. This description is also based on the popular Windows and Linux OSs although the invention may also be used in connection with other OSs as well.

Also the commercial products of the assignee and this description are based on a full virtualization of the x86 platform although the invention may also be implemented in other computer systems that involve less than full virtualization. Thus the invention may be implemented in systems in which direct access is provided to some physical resources instead of virtualizing all physical resources. In addition this invention may be implemented in computer systems involving so called paravirtualization. In paravirtualized computer systems the virtualized hardware platform is not identical to an actual physical platform so software that is designed to run on the actual physical platform must be modified or ported to run on the virtualized hardware platform. This invention may be implemented in a wide variety of virtual computer systems ranging from systems in which only selected physical resources are virtualized to systems in which a complete actual hardware platform is virtualized.

As is well known in the art a virtual machine VM is a software abstraction a virtualization of an actual or an abstract physical computer system. The VM runs as a guest on an underlying host hardware platform. Guest software such as a guest OS and guest applications may be loaded onto the virtual computer for execution. The guest OS may but need not be the same as the OS or other system software running at the system level in the host. For example a Windows OS may be run in the VM even though the OS used to handle actual I O input output memory management etc. on the host might be a Linux OS. Also as long as a suitable interface is provided between the VM and the host platform a user of a VM need not even be aware that he is not using a real computer that is a system with hardware dedicated exclusively to his use. The existence of the underlying host can be made transparent to a user of the VM and to the guest software itself. The virtual computer systems described below as implemented in the commercial products of the assignee of this patent support VMs that have these characteristics.

The system software W either is or at least includes an operating system OS W which has drivers W as needed for controlling and communicating with various devices X and usually with the disk X as well. Conventional applications W if included may be installed to run on the hardware X via the system software W and any drivers needed to enable communication with devices.

The virtual machine VM X also known as a virtual computer is a software implementation of a complete computer system. In the VM the physical system components of a real computer are emulated in software that is they are virtualized. Thus the VM X will typically include virtualized guest system hardware X which in turn includes one or more virtual CPUs X VCPU virtual system memory X VMEM one or more virtual disks X VDISK and one or more virtual devices X VDEVICE all of which are implemented in software using known techniques to emulate the corresponding components of an actual computer. The concept design and operation of virtual machines are well known in the field of computer science.

The VM X also includes system software X which may include a guest operating system X which may but need not simply be a copy of a conventional commodity OS as well as drivers X DRVS as needed for example to control the virtual device s X. Note that a disk virtual or physical is also a device but is usually considered separately because of its essential role. Of course most computers are intended to run various applications and a VM is usually no exception. Consequently by way of example illustrates one or more applications X installed to run on the guest OS X any number of applications including none at all may be loaded for running on the guest OS limited only by the requirements of the VM. Software running in the VM X including the guest OS X and the guest applications X is generally referred to as guest software. 

Note that although the virtual hardware layer X will be a software abstraction of physical components the VM s system software X may be the same as would be loaded into a hardware computer. The modifier guest is used here to indicate that the VM although it acts as a real computer from the perspective of a user and guest software is actually just computer code that is executed on the underlying host hardware and software platform X W. Thus for example I O to a virtual device X will actually be carried out by I O to a corresponding hardware device X but in a manner transparent to the VM.

Some interface is usually required between the VM X and the underlying host hardware X which is responsible for actually executing VM related instructions and transferring data to and from the actual physical memory X and other system hardware X. One advantageous interface between the VM and the underlying host system is often referred to as a Virtual Machine Monitor VMM also known as a virtual machine manager. Virtual machine monitors have a long history dating back to mainframe computer systems in the 1960s. See for example Robert P. Goldberg Survey of Virtual Machine Research IEEE Computer June 1974 p. 54 45.

A VMM is usually a relatively thin layer of software that runs directly on top of a host such as the system software W or directly on the hardware and virtualizes the resources of the or some hardware platform. shows virtualization software X which may be implemented as a VMM running directly on the system hardware X. The virtualization software X is also referred to as a VMM X herein although it may alternatively comprise other virtualization software that may not be considered or called a VMM. The VMM X will typically include at least one device emulator X which may also form the implementation of the virtual device s X. The interface exported to the respective VM is usually such that the guest OS X cannot determine the presence of the VMM. The VMM also usually tracks and either forwards to the host OS W or itself schedules and handles all requests by its VM for machine resources as well as various faults and interrupts. therefore illustrates an interrupt including fault handler X within the VMM. The VMM also includes a memory manager X the general operation of which is described below. The general features of VMMs are well known and are therefore not discussed in further detail here.

In all of these configurations there must be some way for the VM to access hardware devices albeit in a manner transparent to the VM itself. One solution would of course be to include in the VMM all the required drivers and functionality normally found in the host OS W to accomplish I O tasks. Two disadvantages of this solution are increased VMM complexity and duplicated effort if a new device is added then its driver would need to be loaded into both the host OS and the VMM. A third disadvantage is that the use of a hardware device by a VMM driver may confuse the host OS which typically would expect that only the host s driver would access the hardware device. In its Workstation virtualization product VMware Inc. has implemented a different method which is better in some situations. This method is also illustrated in .

In the system illustrated in both the host OS and the VMM are installed at system level meaning that they both run at the greatest privilege level and can therefore independently modify the state of the hardware processor s . For I O to at least some devices however the VMM may issue requests via the host OS W. To make this possible a special driver VMDRV is installed as any other driver within the host OS W and exposes a standard API to a user level application VMAPP . When the system is in the VMM context meaning that the VMM is taking exceptions handling interrupts etc. but the VMM wishes to use the existing I O facilities of the host OS the VMM calls the driver VMDRV which then issues calls to the application VMAPP which then carries out the I O request by calling the appropriate routine in the host OS.

In a vertical line X symbolizes the boundary between the virtualized VMNMM and non virtualized host software worlds or contexts. The driver VMDRV and application VMAPP thus enable communication between the worlds even though the virtualized world is essentially transparent to the host system software W. The line X may also be characterized as a virtualization barrier as that term is used above. However the virtualization barrier X does not provide as complete a barrier or as secure a barrier between the host OS W and the VM X as the virtualization barrier B provides between the VM A and the VM B of . This is primarily because the system software W has direct access to the system hardware X including all of the memory X and the disk X including in particular the memory and disk space that contains the code and data of the VMM X and the VM X. Accordingly the virtualization barrier X may be referred to more specifically as a limited virtualization barrier while the virtualization barrier B may be referred to more specifically as a complete virtualization barrier or as a bidirectional virtualization barrier. Another virtualization barrier would be established between the VM X and any other VM in the computer system X although no such other virtualization barrier is illustrated in because only one VM is illustrated. does show a virtualization barrier W between the VM X and the VMM X. The virtualization barrier W may be substantially the same as the virtualization barrier A of .

In the computer system X of the VMM is co resident at system level with a host operating system. Both the VMM and the host OS can independently modify the state of the host processor but the VMM calls into the host OS via a driver and a dedicated user level application to have the host OS perform certain I O operations on behalf of the VM. The virtual computer in this configuration is thus fully hosted in that it runs on an existing host hardware platform and together with an existing host OS.

In other implementations a dedicated kernel takes the place of and performs the conventional functions of the host OS and virtual computers run on the kernel. illustrates a kernel based virtual computer system in which a kernel serves as the system software for one or more VMM VM pairs. Compared with a system in which VMMs run on a host OS use of a kernel offers greater modularity and facilitates provision of services that extend across multiple VMs for example for resource management . Compared with the hosted deployment a kernel may offer greater performance because it can be co developed with the VMM and be optimized for the characteristics of a workload consisting of VMMs. The ESX Server virtualization product of VMware Inc. has such a configuration. A kernel based virtualization system of the type illustrated in is described in U.S. Pat. No. 6 961 941 Nelson et al. Computer Configuration for Resource Management in Systems Including a Virtual Machine the 941 patent which has been assigned to the same assignee as this patent and which is hereby incorporated herein by reference.

The VM Y includes virtual system hardware Y which typically includes at least one virtual CPU Y at least one virtual disk Y a virtual system memory Y and various virtual devices Y. The VM Y also includes a guest operating system Y which may simply be a copy of a conventional operating system running on the virtual system hardware Y along with a set of drivers Y for accessing the virtual devices Y and the virtual disk Y. One or more applications Y may execute in the VM Y on the guest OS Y and the virtual system hardware Y. All of the components of the VM may be implemented in software using known techniques to emulate the corresponding components of an actual computer. This implementation of the VM Y may generally be substantially the same as the implementation of the VM X in .

The VMs Y and Z are supported by a virtualization software Y comprising a kernel Y and a set of VMMs including a first VMM Y and a second VMM Z. In this implementation each VMM supports one VM. Thus the VMM Y supports the VM Y and the VMM Z supports the VM Z. The VMM Y includes among other components device emulators Y which may constitute the virtual devices Y that the VM Y accesses. The VMM Y may also include a memory manager Y the general operation of which is described below. The VMM also usually tracks and either forwards to some form of system software or itself schedules and handles all requests by its VM for machine resources as well as various faults and interrupts. A mechanism known in the art as an exception or interrupt handler Y may therefore be included in the VMM. The VMM will handle some interrupts and exceptions completely on its own. For other interrupts exceptions it will be either necessary or at least more efficient for the VMM to call the kernel to have the kernel either handle the interrupts exceptions itself or to forward them to some other sub system such as a console OS as described below. The VMM may forward still other interrupts to the VM.

The computer system Y may initially have an existing operating system Z that may be at system level and the kernel Y may not yet even be operational within the system. The initial system level interface between the OS Z and the system hardware Y is shown by a dashed line in . In such case one of the functions of the OS Z may be to make it possible to load the kernel Y after which the kernel runs on the native hardware Y and manages system resources. In effect the kernel once loaded displaces the OS Z. Thus the kernel Y may be viewed either as displacing the OS Z from the system level and taking this place itself or as residing at a sub system level. When interposed between the OS Z and the hardware Y the kernel Y essentially turns the OS Z into an application which has access to system resources only when allowed by the kernel Y. The kernel then schedules the OS Z as if it were any other component that needs to use system resources. Accordingly another interface is shown between the OS Z and the kernel Y for enabling the OS Z to access the system hardware Y. This second interface is shown with a solid line in .

The OS Z may also be included to allow applications unrelated to virtualization to run for example a system administrator may need such applications to monitor the hardware Y or to perform other administrative routines. The OS Z may thus be viewed as a console OS COS . In such implementations the kernel Y preferably also includes a remote procedure call RPC mechanism to enable communication between for example the VMM Y and any applications Z installed to run on the COS Z.

As described in the 941 patent the kernel Y handles the various VMMNMs and the COS Z as entities that can be separately scheduled which are referred to as worlds . The worlds are controlled by a world manager represented in within the kernel Y as module Y. The kernel Y preferably also includes an interrupt exception handler Y that is able to intercept and handle interrupts and exceptions for all devices on the machine.

The kernel Y also includes a system memory manager Y that manages all machine memory that is not allocated exclusively to the COS Z. When the kernel Y is loaded the information about the maximum amount of memory available on the machine is available to the kernel as well as information about how much of it is being used by the COS. Part of the machine memory is used for the kernel Y itself and the rest is used for the virtual machine worlds. Virtual machine worlds use machine memory for two purposes. First memory is used to back portions of each world s memory region that is to store code data stacks etc. For example the code and data for the VMM Y is backed by machine memory allocated by the kernel Y. Second memory is used for the guest memory of the virtual machine. The memory manager may include any algorithms for dynamically allocating memory among the different VM s.

In some embodiments of the invention the kernel Y is responsible for providing access to all devices on the physical machine. In addition to other modules that the designer may choose to load onto the system for access by the kernel the kernel will therefore typically load conventional drivers as needed to control access to devices. Accordingly shows a module Y containing loadable kernel modules and drivers. The kernel Y may interface with the loadable modules and drivers in a conventional manner using an API or similar interface.

When memory addresses are generated in the VM X of either by the applications X or the guest system software X the addresses are generally mapped to corresponding addresses in the physical memory X. Both the guest OS X and the memory manager X are involved in this mapping process. Similarly when memory addresses are generated in the VM Y of either by the applications Y or the system software of the VM Y the guest OS Y and the memory manager Y are involved in the process of mapping the addresses to corresponding addresses in the physical memory Y. These address mapping processes are substantially similar in both the hosted virtual computer system X of and the kernel based virtual computer system Y of . Thus the following description is generally limited to the process of mapping addresses from the VM X of to the physical memory X although it generally also applies to the corresponding process of and to corresponding processes in other virtual computer systems.

Most modern computers implement a virtual memory mechanism as described briefly above which allows user level software to specify memory locations using a set of virtual addresses. These virtual addresses are then translated or mapped into a different set of physical addresses that are actually applied to physical memory to access the desired memory locations. The range of possible virtual addresses that may be used by user level software constitute a virtual address space while the range of possible physical addresses that may be specified constitute a physical address space. The virtual address space is typically divided into a number of virtual memory pages each having a different virtual page number while the physical address space is typically divided into a number of physical memory pages each having a different physical page number. A memory page in either the virtual address space or the physical address space typically comprises a particular number of memory locations such as either a four kilobyte KB memory page or a two megabyte MB memory page in an x86 computer system.

In a conventional non virtualized computer system system level software generally specifies mappings from memory pages in the virtual address space using virtual page numbers to memory pages in the physical address space using physical page numbers. The terms virtual address and virtual address space relate to the well known concept of a virtual memory system which should not be confused with the computer virtualization technology described elsewhere in this patent involving other well known concepts such as VMMs and VMs. A well known technique of memory paging may be used to enable an application to use a virtual address space that is larger than the amount of physical memory that is available for use by the application. The code and data corresponding to some of the pages in the virtual address space may reside in physical memory while other pages of code and data may be stored on a disk drive for example. If the application attempts to access a memory location in the virtual address space for which the corresponding data is stored on the disk drive instead of in physical memory then the system software typically loads a page worth of data from the disk drive including the desired data into a page of physical memory possibly first storing the contents of the memory page to disk . The system software then allows the attempted memory access to complete accessing the physical memory page into which the data has just been loaded.

Now suppose that the host OS W of implements a virtual memory system with memory paging. Now if an application W requests access to the hardware memory X for example the request is issued with a virtual address which must be mapped to a physical address that is issued to the actual hardware memory. This mapping or translation is typically specified by the OS W which includes some form of memory management module for this purpose. The OS thus converts the virtual address VA in particular the virtual page number VPN of the request into a physical address PA in particular a physical page number PPN that can be applied directly to the hardware. The VA and PA have a common offset from a base address so that only the VPN needs to be converted into a corresponding PPN. 

When accessing a given memory location specified by a virtual address the processor breaks the virtual address into a virtual page number higher order address bits plus an offset into that page lower order address bits . The virtual page number VPN is then translated using mappings established by the OS into a physical page number PPN based on a page table entry PTE for that VPN in the page tables associated with the currently active address space. The page tables will therefore generally include an entry for every VPN. The actual translation may be accomplished simply by replacing the VPN the higher order bits of the virtual address with its PPN mapping leaving the lower order offset bits the same.

To speed up virtual to physical address translation a hardware structure known as a translation look aside buffer TLB is normally included for example as part of the hardware Memory Management Unit MMU X. The TLB contains among other information VA to PA mapping entries at least for VPNs that have been addressed recently or frequently. Rather than searching all the page tables the TLB is searched first instead. If the current VPN is not found in the TLB then a TLB miss occurs and the page tables in memory are consulted to find the proper translation and the TLB is updated to include this translation. The OS thus specifies the mapping but the hardware MMU X usually actually performs the conversion of one type of page number to the other. Below for the sake of simplicity when it is stated that a software module maps page numbers the existence and operation of a hardware device such as the MMU X may be assumed.

An extra level of addressing indirection is typically implemented however in virtualized systems in that a VPN issued by an application X in the VM X is remapped twice in order to determine which page of the hardware memory is intended. A mapping module within the guest OS X translates the guest VPN GVPN into a corresponding guest PPN GPPN in the conventional manner. The guest OS therefore believes that it is directly addressing the actual hardware memory but in fact it is not. Of course a valid address to the actual hardware memory address must however ultimately be used.

The memory manager X therefore takes the GPPN issued by the guest OS X and maps it to a hardware page number PPN that can be used to address the hardware memory X. Note that in some literature involving virtualized systems GVPNs GPPNs VPNs and PPNs are sometimes referred to as VPNs PPNs VPNs and MPNs respectively where MPN means machine page number that is the page number used to address the hardware memory. The problem is though that VPN is then used to mean the virtual page number in both the guest and host contexts and one must always be aware of the current context to avoid confusion. Regardless of notation however the intermediate GPPN PPN mapping performed by the VMM is transparent to the guest system.

Virtualization software B executes on the system hardware C and may be substantially the same as the virtualization software X of or the virtualization software Y of . The virtualization software B includes a memory manager B which further includes an address mapping module B and a set of shadow page tables B. The memory manager B may be substantially the same as the memory manager X of or the memory manager Y of .

The virtualization software B supports a VM C which may be substantially the same as the VM X of or the VM Y of . The VM C includes virtual system hardware C which further includes an MMU C which may further include a virtual TLB VTLB C although the MMU C may also be implemented without a virtual TLB. The VM C also includes a guest OS D and a set of one or more applications G. The guest OS D includes a set of guest OS page tables D.

The guest OS D generates the guest OS page tables D that map the guest software virtual address space to what the guest OS perceives to be the physical address space. In other words the guest OS D maps GVPNs to GPPNs. Suppose for example that a guest application G attempts to access a memory location having a first GVPN and that the guest OS has specified in the guest OS page tables that the first GVPN is backed by what it believes to be a physical memory page having a first GPPN.

The address mapping module B keeps track of mappings between the GPPNs of the guest OS D and the real physical memory pages of the physical memory within the system hardware C. Thus the address mapping module B maps GPPNs from the guest OS D to corresponding PPNs in the physical memory. Continuing the above example the address mapping module translates the first GPPN into a corresponding PPN let s say a first PPN.

The memory manager B creates a set of shadow page tables B that are used by the MMU C. The shadow page tables B include a number of shadow PTEs that generally correspond to the PTEs in the guest OS page tables D but the shadow PTEs map guest software virtual addresses to corresponding physical addresses in the actual physical memory instead of to the physical addresses specified by the guest OS D. In other words while the guest OS page tables D provide mappings from GVPNs to GPPNs the shadow PTEs in the shadow page tables B provide mappings from GVPNs to corresponding PPNs. Thus continuing the above example instead of containing a mapping from the first GVPN to the first GPPN the shadow page tables B would contain a shadow PTE that maps the first GVPN to the first PPN. Thus when the guest application attempts to access a memory location having the first GVPN the MMU C loads the mapping from the first GVPN to the first PPN in the shadow page tables B into the physical TLB C if the mapping is not already there. This mapping from the TLB C is then used to access the corresponding memory location in the physical memory page having the first PPN.

For purposes of this patent certain address mapping phrases are defined as follows address mappings or translations from guest virtual addresses to guest physical addresses e.g. mappings from GVPNs to GPPNs are defined as guest address mappings or just guest mappings address mappings or translations from guest physical addresses to actual physical addresses e.g. mappings from GPPNs to PPNs are defined as virtualization address mappings or just virtualization mappings and address mappings or translations from guest virtual addresses to actual physical addresses e.g. from GVPNs to PPNs are defined as shadow address mappings or just shadow mappings. Hardware address mappings or hardware mappings are defined more generally as any address mappings or translations that provide mappings to actual physical memory such that hardware address mappings include both virtualization address mappings and shadow address mappings. 

To further explain the example of suppose the guest OS page tables and were created by the guest OS D of . Suppose further that the first guest virtual address space is used by a first guest application and the second guest virtual address space is used by a second guest application where the first and second guest applications are applications G of . Thus when the guest OS D allows the first guest application to run it configures the virtual system hardware C so that the MMU C uses the first guest OS page table for address translations and when the guest OS D allows the second guest application to run it configures the virtual system hardware C so that the MMU C uses the second guest OS page table for address translations. For example in an x86 system the guest OS D attempts to write an appropriate address to a virtual CR Control Register to activate either the guest OS page table or the guest OS page table . In this case if the first guest application generates an attempted memory access to the GVPN A the MMU C in the virtual system hardware C maps the virtual address to the GPPN A based on the PTE A if the first guest application generates an attempted memory access to the GVPN B the MMU C maps the virtual address to the GPPN B based on the PTE B and if the first guest application generates an attempted memory access to the GVPN C the MMU C maps the virtual address to the GPPN C based on the PTE C. On the other hand if the second guest application generates an attempted memory access to the GVPN A the MMU C maps the virtual address to the GPPN A based on the PTE A if the second guest application generates an attempted memory access to the GVPN D the MMU C maps the virtual address to the GPPN B based on the PTE B and if the second guest application generates an attempted memory access to the GVPN C the MMU C maps the virtual address to the GPPN D based on the PTE C.

To further explain the example of suppose the scenario described above in which the guest OS page tables and were created by the guest OS D of and the first guest virtual address space is used by a first guest application and the second guest virtual address space is used by a second guest application is extended so that the address mapping module and the shadow page tables and are created by the memory manager B of . When the guest OS D attempts to activate the first guest OS page table before allowing the first guest application to run the virtualization software C intercepts the attempted activation and instead activates the first shadow page table while when the guest OS D attempts to activate the second guest OS page table before allowing the second guest application to run the virtualization software C intercepts the attempted activation and instead activates the second shadow page table . In this case if the first guest application generates an attempted memory access to the GVPN A the MMU C in the physical system hardware C maps the virtual address to the PPN A based on the PTE A if the first guest application generates an attempted memory access to the GVPN B the MMU C maps the virtual address to the PPN C based on the PTE B and if the first guest application generates an attempted memory access to the GVPN C the MMU C maps the virtual address to the PPN E based on the PTE C. On the other hand if the second guest application generates an attempted memory access to the GVPN A the MMU C maps the virtual address to the PPN A based on the PTE A if the second guest application generates an attempted memory access to the GVPN D the MMU C maps the virtual address to the PPN C based on the PTE B and if the second guest application generates an attempted memory access to the GVPN C the MMU C maps the virtual address to the PPN G based on the PTE C.

Much of what is illustrated in may be substantially the same as corresponding elements that have been described above in connection with . Thus shows a system hardware D which includes a system memory and one or more disks . The system hardware D may be substantially the same as the system hardware X of the system hardware Y of or the system hardware C of . also shows virtualization software D which includes a guest address mapping module D and a set of shadow page tables D. Except as described below the virtualization software D may be substantially the same as the virtualization software X of the virtualization software Y of or the virtualization software B of . The guest address mapping module D may be substantially the same as the address mapping module B of and the shadow page tables D may be substantially the same as the shadow page tables B of .

All of the elements of that have been identified thus far are generally found in existing virtual computer systems. These elements and other elements that are not illustrated for simplicity generally implement a virtual computer system that may be substantially the same as existing virtual computer systems. The virtualization software D supports a VM D that may have substantially the same characteristics as existing VMs such as the VMs that are supported by the virtualization products of VMware Inc. Thus for example the VM D may be a virtualization of an ordinary x86 computer the guest OS E may be an ordinary general purpose OS such as a Windows OS or a Linux OS and the applications H may be ordinary applications that are designed to run on the OS E. Everything that has been described thus far relative to may comprise a general purpose virtual computer system on which a wide variety of system level software and application level software may run.

As described above such a general purpose virtual computer system does not provide a secure environment for software execution. If malicious software is able to execute within the VM D it will generally be able to compromise all the software within the VM including the guest OS E and all the applications H. As described above however the virtualization software D establishes a virtualization barrier C between itself and the VM D which generally provides better security and more effective isolation between multiple software modules than a general OS provides. Thus even if malicious software is able to compromise all the software modules within the VM D it is still not likely to be able to penetrate the virtualization barrier C and compromise the virtualization software D.

The virtualization software D also establishes a second virtualization barrier D as shown in . This second virtualization barrier D isolates the ordinary virtual computer system described thus far from an isolated execution environment IEE . One or more applications may execute in the IEE and the virtualization barrier D isolates these applications from the software modules in the VM D. Applications that execute within the IEE are referred to herein as secure applications not because the applications themselves necessarily implement any security features but because they are made more secure by the operation of the virtualization barrier D. Thus for example shows a secure application which may generally be an ordinary application that can run in other execution environments. For example the secure application may be an application that could also be run in the VM D. Alternatively the secure application may be customized in one or more ways for execution in the IEE .

As described below the virtualization software D uses a private address mapping module and a private shadow page table to effectively provide the secure application with its own private physical memory B which is isolated from the software modules in the VM D. In effect the virtualization software D divides the system memory into a VM memory A for use by the VM D and a private memory B for use by the secure application . However the system memory may be ordinary physical memory as found in a conventional physical computer system and there need not be any physical distinction whatsoever between the VM memory A and the private memory B. The system memory may comprise one or more physical components that implement a contiguous or noncontiguous physical address space comprising a number of physical memory pages where the physical characteristics of the individual memory pages may be indistinguishable from one another. A first arbitrary selection of contiguous or noncontiguous memory pages in the system memory may constitute the VM memory A and a second arbitrary mutually exclusive selection of contiguous or noncontiguous memory pages in the system memory may constitute the private memory B. Also the particular physical memory pages that constitute the VM memory A and those that constitute the private memory B may vary over time. Also the system memory typically includes additional physical memory pages that are used by the virtualization software D or by other software modules running on the system hardware D.

Also in some embodiments of the invention one or more memory pages within the system memory may be accessible to both the secure application and the software modules in the VM D. Thus also shows the system memory as including an optional shared memory C.

The use of the private address mapping module and the private shadow page table to isolate the private memory B from the software modules in the VM D is illustrated in . These figures extend the example of address mapping that was begun in and they apply the extended example to the virtual computer system of to show how the virtualization software D maps virtual addresses to a physical address space of a computer system.

In this case the guest OS page tables E of comprise the first guest OS page table and the second guest OS page table . The guest OS E creates the first guest OS page table to map addresses from the first guest virtual address space to the guest physical address space and the guest OS E creates the second guest OS page table to map addresses from the second guest virtual address space to the guest physical address space .

The virtualization software D creates the guest address mapping module D to map addresses in the guest physical address space to the actual physical address space . The contents of the guest address mapping module D are shown in and for this example these contents are the same as the contents of the address mapping module of . Thus the guest address mapping module D contains four entries or mappings namely a first entry A that maps the GPPN A to the PPN A a second entry B that maps the GPPN B to the PPN C a third entry C that maps the GPPN C to the PPN E and a fourth entry D that maps the GPPN D to the PPN G. Again what this means is that the code and or data that the guest OS believes to be stored in the GPPN A is actually stored in the PPN A the code and or data that the guest OS believes to be stored in the GPPN B is actually stored in the PPN C the code and or data that the guest OS believes to be stored in the GPPN C is actually stored in the PPN E and the code and or data that the guest OS believes to be stored in the GPPN D is actually stored in the PPN G.

The virtualization software D also creates the first shadow page table for mapping addresses from the first guest virtual address space to the physical address space and the second shadow page table for mapping addresses from the second guest virtual address space to the physical address space . Again the entries in the shadow page table are derived from the entries in the guest OS page table and the entries in the guest address mapping module D and the entries in the shadow page table are derived from the entries in the guest OS page table and the entries in the guest address mapping module D both in the same manner as described above.

All of the elements of that have been described thus far everything in except for the private address mapping module the private shadow page table and a software switch operate in substantially the same manner as the corresponding elements of . Thus suppose that a scenario is applied to that is analogous to the scenario that was applied to above so that the guest OS page tables and are created by the guest OS E of the first guest virtual address space is used by a first guest application and the second guest virtual address space is used by a second guest application where the first and second guest applications are applications H in the VM D and the guest address mapping module D and the shadow page tables and are created by a memory manager in the virtualization software D. Again when the guest OS E attempts to activate the first guest OS page table before allowing the first guest application to run the virtualization software D activates the first shadow page table instead and when the guest OS E attempts to activate the second guest OS page table before allowing the second guest application to run the virtualization software D activates the second shadow page table instead. In this case if the first guest application generates an attempted memory access to the GVPN A a MMU not shown in the physical system hardware D maps the virtual address to the PPN A based on the PTE A see if the first guest application generates an attempted memory access to the GVPN B the MMU maps the virtual address to the PPN C based on the PTE B and if the first guest application generates an attempted memory access to the GVPN C the MMU maps the virtual address to the PPN E based on the PTE C. On the other hand if the second guest application generates an attempted memory access to the GVPN A the MMU maps the virtual address to the PPN A based on the PTE A if the second guest application generates an attempted memory access to the GVPN D the MMU maps the virtual address to the PPN C based on the PTE B and if the second guest application generates an attempted memory access to the GVPN C the MMU maps the virtual address to the PPN G based on the PTE C.

In the example of the secure application uses the second guest virtual address space sharing the virtual address space with one or more software modules within the VM D including possibly the guest OS E and one or more applications H. However using this invention the secure application generally does not share any of the actual physical address space with any software module within the VM D.

To accomplish this the virtualization software D creates the private address mapping module which is a corresponding alternate data structure to the guest address mapping module D and the private shadow page table which is a corresponding alternate data structure to the second shadow page table . Like the guest address mapping module D the private address mapping module provides mappings from the guest physical address space to the actual physical address space providing mappings from GPPNs to PPNs. However the private address mapping module maps the GPPNs of the guest physical address space to a set of PPNs of the actual physical address space that is generally mutually exclusive with the PPNs to which the guest address mapping module D maps the guest physical address space . Specifically as shown in the private address mapping module contains four entries or mappings namely a first entry A that maps the GPPN A to the PPN H a second entry B that maps the GPPN B to the PPN I a third entry C that maps the GPPN C to the PPN B and a fourth entry D that maps the GPPN D to the PPN J.

Also like the second shadow page table the private shadow page table provides mappings from the second guest virtual address space to the physical address space providing mappings from GVPNs to PPNs. The entries in the private shadow page table are derived from the entries in the guest OS page table and the entries in the private address mapping module in the same manner that the entries in the shadow page table are derived from the entries in the guest OS page table and the entries in the guest address mapping module D. Thus for example the guest OS page table indicates that the GVPN A maps to the GPPN A and the private address mapping module indicates that the GPPN A maps to the PPN H so the private shadow page table should generally contain a PTE that maps the GVPN A to the PPN H. Thus as shown in the private shadow page table contains three PTEs namely a PTE A that maps the GVPN A to the PPN H a PTE B that maps the GVPN D to the PPN I and a PTE C that maps the GVPN C to the PPN J.

Now when a software module executes that is using the first guest virtual address space the virtualization software D activates the first shadow page table so that the MMU in the system hardware D uses this page table for address translations. When a software module from within the VM D executes that is using the second guest virtual address space the virtualization software D activates the second shadow page table . When the secure application executes the virtualization software D activates the private shadow page table . Thus when the second guest address space is used the virtualization software D effectively implements a software switch as illustrated in . If the secure application is executing then the private shadow page table is used to translate virtual addresses to physical addresses while if a software module within the VM D is executing and using the second guest virtual address space then the second shadow page table is used to translate virtual addresses to physical addresses.

The private address mapping module indicates the PPNs in the physical address space that contain the code and or data of the secure application . Thus all of the PPNs to which the private address mapping module maps the guest physical address space constitute the private memory B assuming that there is no shared memory C. In the example of the private memory B comprises the memory pages PPN H PPN B PPN I and PPN J. However there is actually no need for the entry C in the private address mapping module mapping the GPPN C to the PPN B because the private address mapping module only applies to the second guest virtual address space and there is no mapping in the second guest virtual address space to the GPPN C see the second guest OS page table in . Thus the private memory B can actually comprise only the memory pages PPN H PPN I and PPN J.

The guest address mapping module D indicates the PPNs in the physical address space that contain the code and or data of the software modules within the VM D. Thus all of the PPNs to which the guest address mapping module D maps the guest physical address space constitute the VM memory A again assuming that there is no shared memory C. In the example of the VM memory A comprises the memory pages PPN A PPN C PPN E and PPN G.

The memory pages that constitute the VM memory A and the memory pages that constitute the private memory B are mutually exclusive because the PPNs to which the guest address mapping module D maps and the PPNs to which the private address mapping module maps are mutually exclusive. So long as this relationship holds and the shadow page tables and are configured and used as described above no software modules within the VM D will be able to access the private memory B of the secure application . The virtualization barriers C and D protect the virtualization software D and these data structures from the software modules in the VM D to ensure that this situation is maintained.

Suppose again that malicious software is able to execute within the VM D. The malicious software may gain full access to the guest OS page tables and and it may then use the guest OS page tables and to gain access to any memory page in the guest physical address space . The guest physical address space constitutes the entire system memory D of the VM D which is the only memory that is visible from within the VM D. As long as the virtualization software D is well designed and well implemented there will be no way for any software in the VM D to determine that there is any memory in the computer system besides the guest system memory D. And yet accessing the entire system memory D does not give any access to the private memory B of the secure application .

This isolation which is achieved through the virtualization of the system memory and which is represented by the virtualization barriers C and D is further illustrated in . Malicious software within the VM D may obtain full access to the guest virtual address spaces and the guest OS page tables and and the guest physical address space . However the virtualization barriers C and D prevent such malicious software from accessing or directly affecting the operation of the virtualization software D the guest address mapping module D the private address mapping module the software switch and the shadow page tables and all of which restrict access to the physical address space as described above. So long as the virtualization barriers C and D are able to protect these software modules and data structures the private memory B will be effectively isolated from all software within the VM D.

Also although the isolated execution embodiment illustrated in A and B involves the use of specific data structures and software modules to maintain the data needed to isolate the private memory B other data structures and software modules could be used in other embodiments. For example the guest address mapping module D and the private address mapping module could be combined into a single software module or they could use a single data structure so long as some means is provided to maintain distinct mutually exclusive mappings for the VM D and the IEE . Alternatively the guest address mapping module D and or the private address mapping module could be further divided into a larger number of software modules or data structures. Also in other embodiments the shadow mappings contained in the shadow page tables and may be configured into other arrangements and or into other data structures.

More generally a first set of hardware address mappings is used for the VM D and a second set of hardware address mappings is used for the IEE . In addition for this embodiment a first set of virtualization address mappings is used for the VM D and a second set of virtualization address mappings is used for the IEE . In other embodiments the information contained in the multiple sets of virtualization address mappings may be determined retained and or conveyed in other manners.

Returning now to like the system memory the disk in the physical system hardware D is also divided into a VM storage area A for use by software modules in the VM D a private storage area B for use by the secure application and an optional shared storage area C that is accessible to both the secure application and the software modules in the VM D. As is well known storage disks and other secondary storage devices are typically divided into a number of data blocks with a unique block number being associated with each block on a disk. Also different disks in a system are typically identified by different disk numbers or names. Thus the one or more disks may comprise a number of data blocks each of which may be uniquely identified by a disk number or name combined with a block number. The following description assumes that the disk s constitute only a single disk for simplicity although it can also be applied to systems containing multiple disks or other secondary storage devices.

So the virtualization software D divides the blocks of the disk into the VM storage A the private storage B and possibly the shared storage C. The blocks of the VM storage A and the blocks of the private storage B may each be contiguous or noncontiguous and the blocks in each of these storage areas are generally mutually exclusive. Also the disk will typically include additional data blocks that are not included in the VM storage A the private storage B or the shared storage C these additional blocks may be used by other software entities running on the system hardware such as the virtualization software D.

As described above the virtualization software D provides software modules in the VM D with access to secondary storage by creating one or more virtual disks D in the virtual system hardware D which may be substantially the same as the virtual disk X of or the virtual disk Y of . This description also assumes that the virtual disk s D constitute only a single disk for simplicity. The virtual disk D is also divided into a number of blocks with each block having a unique block number.

The software within the VM D can access a particular block in the virtual disk D by specifying an appropriate block number. The virtualization software D then maps this virtual block number to a corresponding physical block number in the disk . This mapping of data blocks is substantially similar to the mapping of memory addresses described above except that for the mapping of data blocks there is no need to translate from a guest virtual address to a guest physical address within the VM D.

To isolate the private storage B from the software modules in the VM D the virtualization software D uses a method that may be substantially the same as the method described above for isolating the private memory B from the software modules in the VM D. This method may be performed in particular by the disk emulator D which may be substantially the same as a device emulator X of or a device emulator Y of . The device emulator D may also use data structures that are comparable to the data structures used in isolating the private memory B from the software modules in the VM D. Thus the device emulator D may create and maintain a guest mapping data structure see and a private mapping data structure see each of which contains mappings from virtual block numbers to physical block numbers with the guest mapping data structure mapping to the physical data blocks that contain the code and or data of the software modules within the VM D i.e. mapping to the VM storage A and the private mapping data structure mapping to the physical data blocks that contain the code and or data of the secure application i.e. mapping to the private storage B . The disk emulator D may also write values into the metadata of the disk to indicate for each physical data block whether it belongs to the VM storage A or the private storage B or whether the data block has some other use.

Again the physical data blocks to which the guest mapping data structure maps and the physical data blocks to which the private mapping data structure maps are generally mutually exclusive to ensure that the VM storage A and the private storage B are mutually exclusive except for possible physical data blocks in the optional shared storage area C to which both the guest mapping data structure and the private mapping data structure map. When software within the VM D is executing the guest mapping data structure is used mapping disk accesses to the VM storage A. When the secure application is executing the private mapping data structure is used mapping disk accesses to the private storage B. Again so long as these two mapping data structures are maintained in a mutually exclusive manner and the operation of the virtualization software D is not compromised no software within the VM D will be able to access the private storage area B. The virtualization of the secondary storage may be implemented in a manner that ensures that these conditions are satisfied so that the virtualization software D the guest and private mapping data structures and the private storage B are isolated from the software in the VM D. This isolation is also represented by the virtualization barriers C and D of .

A few important issues have yet to be addressed in this description of the isolated execution embodiment of A and B. One such issue is how the configuration of A and B is established. Another is how system services are provided to the secure application . Another is how and under what circumstances execution is switched between the IEE and the environment of the VM D. Another issue is what communication and interaction there is between the secure application and software modules in the VM D and how this communication and interaction is facilitated without creating or while limiting vulnerabilities to the IEE .

The technical literature in the field of computer science is replete with descriptions and explanations of a wide variety of methods and configurations that may be used to address these issues or similar analogous issues in a wide variety of hardware and software implementations. Different techniques may be appropriate in different embodiments of the invention depending on the particular hardware and software configurations and the relative importance that is placed on a variety of factors including the degree of security desired and the amount and nature of communication and interaction that is desired between the secure application and the software modules in the VM D.

One configuration that may be used to address these issues is also illustrated in . In addition to all of the other components that have been described thus far shows an application stub a bridge and a secure API . In this particular implementation one objective is to allow the guest OS E to manage hardware resources for the secure application along with managing hardware resources for the applications H without the OS E or other software modules in the VM D having access to the private code and data of the secure application in the private memory B and in the private storage B. Another objective of this implementation is to minimize changes that need to be made to existing OSs and applications to implement the guest OS E the applications H and the secure application . In other embodiments of the invention as mentioned above the secure application may be substantially different from an ordinary application that can run in a conventional operating environment. For example an explicit API such as a hypercall interface may be established between the secure application and the virtualization software D which may require substantial modifications to the secure application .

Suppose initially that the stub the secure application and the secure API have not been loaded into the computer system but that the bridge is implemented as a part of the virtualization software D. A secure installer may be started from outside the VM D so that the installer can interface directly with the virtualization software D. The installer may interact with the virtualization software D to install the secure API and the secure application into the private storage B. The secure application may be linked to the secure API prior to installation or they may be linked after installation by a secure dynamic loader when the secure application first executes. If the secure API provides functional equivalence to the API of an existing OS then using the dynamic loader allows an existing application to run in the IEE without even having to recompile the existing application. The installer may also initiate or activate a process within the VM D to interact with the guest OS E. This process may then obtain space in the VM storage A from the guest OS E in a conventional manner and install the stub generally in a conventional manner.

After the stub the secure application and the secure API have been installed the stub or a portion thereof may be loaded into the VM memory A and it may begin to execute such as in response to the activation of the stub by a user. The stub may use the second guest virtual address space for example possibly sharing it with one or more other guest applications H. From within the VM D the stub may initiate and support the execution of the secure application through the use of hypervisor calls.

A hypervisor call is a special function that allows select software modules to communicate with the virtualization software D through the bridge . For example a software module in the VM D such as the stub may place information into one or more registers or into memory and then execute an instruction that causes a hardware fault such as an IN or OUT instruction in the current x86 platform or an instruction such as VMCALL from the new Vanderpool or Virtualization Technology from Intel Corporation. The virtualization software D then responds to the hardware fault obtains the information passed by the stub and reacts accordingly. For example the virtualization software D may switch the hardware context to allow the secure application to execute and the virtualization software D may pass information received from the stub to the secure application using the bridge and the secure API . The virtualization software D may also communicate with the secure application through the bridge and the secure API for other reasons.

A wide variety of restrictions may be placed on the making of hypervisor calls and on the passing of information using hypervisor calls depending on the requirements of the implementation. For example a policy can be enforced that a hypervisor call can only be made through a predefined set of entrances into a special gate page of memory in which all valid hypervisor calls are defined. Also certain checks can be made on the software module that places a hypervisor call such as running a hash algorithm on the memory page s containing the calling software module and comparing the outcome of the hash to expected values for software modules that are allowed to make hypervisor calls. As another alternative hypervisor calls may be permitted only from specific portions of code in the code cache of a binary translation system within the virtualization software D where those specific portions of code are created by the same vendor as the virtualization software and the code is generated and distributed along with the virtualization software D for example. Hypervisor calls can also be secured with other validity checks commonly used in secure communications.

Other software modules within the VM D may also interact and or communicate with the secure application by first interacting and or communicating with the stub and relying on the stub to relay the interaction and or communication to the secure application . Depending on the implementation such interaction and or communication may be limited to the guest OS E or it may be extended to guest applications H as well. The range of possibilities for types and amounts of interactions and communications that may be permitted is extensive depending on the particular implementation.

The secure application may also initiate communications and interactions with other software modules by making system calls using the secure API . The secure API may include a library for handling all system calls that are supported by the guest OS E for example along with separate code to start and finish the secure application . The system calls from the secure application are generally reissued as corresponding system calls to be handled by the guest OS E although some of the system calls may be handled by the virtualization software D instead.

When the secure application makes a system call that is to be handled by the guest OS E a hypervisor call is first made by the secure API to the virtualization software D. The virtualization software D stores the current CPU state and switches to a CPU state that enables the stub to execute. The virtualization software D then causes the stub to begin executing at a point where the stub issues a corresponding system call to the guest OS E. In addition if the secure application makes a system call using a memory pointer the secure API copies the data structure pointed to by the memory pointer or some portion of memory that includes the data structure from the private memory B to the VM memory A at corresponding locations in the virtual address space.

After the guest OS E completes a system call on behalf of the secure application through the stub the stub makes another hypervisor call to switch execution back to the IEE . The virtualization software D restores the CPU context of the secure application that was saved before switching to the stub . The virtualization software D may also update certain registers as part of implementing the system call. For example a register may contain a return value of the call. Also if necessary the secure API copies data representing results of the system call from the VM memory A to the private memory B. The secure application is now able to continue execution with the system call having been completed just as would normally be expected by the secure application. In this manner the guest OS E and or the virtualization software D may provide a full complement of system services to the secure application .

Returning to the process for beginning to execute the stub and the secure application after the stub begins executing the stub issues a hypervisor call that causes the virtualization software D and or the secure API to begin executing the secure application . At least a portion of the secure application is loaded from the private storage B to the private memory B for execution. The virtualization software D also switches the hardware context to that of the IEE . In particular the virtualization software effectively operates the figurative software switch of to activate the private shadow page table instead of the second shadow page table . The secure application then begins to execute.

The particular method by which the execution of the stub and the secure application is initiated can also vary substantially in different embodiments of the invention. illustrate a first method for installing loading and initiating execution of the stub and the secure application while illustrate a second method for installing loading and initiating execution of the stub and the secure application . The isolated execution embodiment of A and B may be considered a more general embodiment that encompasses a number of more specific embodiments. illustrate a first such more specific embodiment which may be referred to as a dual mapping embodiment while illustrate a second such more specific embodiment which may be referred to as an indirection embodiment. The methods of and A to C are illustrated by stepping through a common simplified example in which the stub and the secure application are each installed into the disk loaded into the system memory and then executed. The example is simplified by assuming that blocks of the disk blocks of the virtual disk D memory pages of the system memory and memory pages of the virtual system memory D are all the same size. Also it is assumed that the code and data of the stub fits in a single block or page and that the code and data of the secure application also fits in a single block or page. Also this example does not consider the installation loading and execution of the secure API but this can be done along with and in substantially the same manner as the secure application .

Referring first to B and C assume initially that neither the stub nor the secure application have been installed. illustrates the installation of the stub into the VM storage A and the installation of the secure application into the private storage B. First the secure installer initiates or activates a process within the VM D which interfaces with the guest OS E to attempt to install the stub into the virtual disk D. Although the stub only occupies a single block the installer process requests two blocks from the guest OS E in the virtual disk D. Suppose the guest OS E allocates a Virtual Block Number VBN A and a Virtual Block Number VBN B. The installer process then attempts to write the stub into the VBN A. The disk emulator D translates this attempted disk write to a corresponding write to the VM storage A. Thus the stub is actually written to a block of the VM storage A such as a block having a Physical Block Number PBN D. The disk emulator D also adds an entry A into the guest mapping data structure mapping the VBN A of the virtual disk D to the PBN D of the VM storage A.

The installer process does not have any data that needs to be written to the VBN B because the entire stub was written to the VBN A. The installer process may nonetheless attempt to write some sort of data to the VBN B to convince the guest OS E that the VBN is being used for the stub . The disk emulator D determines that the data written to the VBN B is not real data and so the disk emulator D does not write the data to any physical block in the disk . This determination may be made in a variety of ways. For example the disk emulator D may coordinate with the secure installer. The disk emulator may be aware that the stub is being installed and that the stub only takes up a single block. This way when the disk emulator D sees the installer process attempting to write a second block it knows that the data of the second block is not real. In any case upon determining that the data to be written to the VBN B is fake the disk emulator D adds another entry B into the guest mapping data structure to indicate that the VBN B is not backed by real data in the physical disk .

Next the secure installer writes the secure application into a block of the private storage B such as into a block having a Physical Block Number PBN G. From the perspective of the IEE the secure application occupies the VBN of the virtual disk D which is identified as the VBN D in the IEE. Thus the disk emulator D adds an entry B into the private mapping data structure mapping the VBN D of the virtual disk D to the PBN G.

After the stub and the secure application have been installed a user of the VM D may initiate execution of the stub in a conventional manner. The stub is loaded into the VM memory A and it begins to execute. The stub then causes the secure application to be loaded into the private memory B and the secure application begins to execute. illustrates the loading of the stub into the VM memory A and the initial execution of the stub while FIG. C illustrates the loading of the secure application into the private memory B and the initial execution of the secure application .

Thus referring first to when execution of the stub is initiated the guest OS E attempts to load the stub specifically the VBN A into the virtual system memory D such as into a guest physical page GPPN A. In response to this attempted disk read the virtualization software D adds an entry to the guest address mapping module D not shown in mapping the GPPN A to a physical page into which the stub will actually be loaded such as a physical page PPN D. Based on the mapping A in the guest mapping data structure the virtualization software D determines that the physical block PBN D corresponds with the virtual block VBN A specified by the guest OS E. Thus the virtualization software D loads the physical block PBN D into the physical page PPN D. Next when execution continues in the guest OS E the guest OS creates a page table entry in the guest OS page table not shown in mapping a guest virtual page number such as a GVPN to the guest physical page GPPN A. Thus the GPPN A into which the guest OS E believes the stub was loaded can be accessed using the GVPN.

Next the guest OS E attempts to initiate execution of the stub at the GPPN A which the virtualization software D converts into the corresponding PPN D so that execution of the stub begins at the PPN D. When the stub first uses a virtual address in the GVPN a page fault occurs because the shadow page table which is currently the active page table does not yet contain a mapping for the GVPN. The virtualization software D responds to this page fault and adds an entry D to the shadow page table mapping the GVPN to the PPN D based on the mapping in the guest OS page table from the GVPN to the GPPN A and the mapping in the guest address mapping module D from the GPPN A to the PPN D. This page fault may be referred to as a hidden page fault because it is handled by the virtualization software D without any software within the VM D even being aware that the fault occurred.

Now execution continues in the stub at the PPN D. The stub makes a hypervisor call through the bridge to the virtualization software D as described above to initiate execution of the secure application . In response to the hypervisor call the virtualization software D switches the hardware context to the IEE including activating the private page table instead of the shadow page table . In this implementation execution resumes in the IEE at the next instruction of the stub within the PPN D. Again the stub will use a virtual address in the GVPN and again a page fault will occur this time because the private page table does not yet contain a mapping for the GVPN. The virtualization software D responds to this page fault and adds an entry D to the private page table also mapping the GVPN to the PPN D again based on the mapping in the guest OS page table from the GVPN to the GPPN A and the mapping in the guest address mapping module D from the GPPN A to the PPN D. Now the PPN D is accessible both from within the VM D and from within the IEE . Thus the PPN D can be considered a part of the shared memory C of or it can be considered part of the VM memory A as well as a part of the private memory B as illustrated in . Instead of the general case in which the pages of the VM memory A and the pages of the private memory B are mutually exclusive this implementation of the invention involves at least one memory page that is shared between the VM memory A and the private memory B. Of course any such shared memory pages preferably contain no private code or data of the secure application . In this example the shared page D contains the code and data of the stub which was already available or vulnerable to software modules in the VM D. also shows that from the perspective of the IEE the GVPN provides access to the virtual system memory D as represented by a block C. In this example using the GVPN from within the IEE provides access to the PPN D. After the mapping D is added to the private page table execution continues in the IEE in the stub on the PPN D.

At this point the main object of the code of the stub is to initiate the loading and execution of the secure application . illustrates this process of loading the secure application into the private memory B along with the initial execution of the secure application. To begin the process a reference is made to a GVPN that maps to the code and or data of the secure application . In this case the appropriate GVPN is the GVPN. When the GVPN is first referenced a page fault occurs because the private page table does not contain a mapping for this GVPN. The virtualization software D responds to the page fault and determines that there are no mappings for the GVPN in the private page table in the shadow page table or in the guest OS page table . Because there is no mapping for the GVPN in the guest OS page table it is appropriate to forward the page fault to the guest OS E. Thus the virtualization software D saves the current hardware context and switches to the hardware context of the VM D including activating the shadow page table instead of the private page table . Execution then resumes within the stub .

Now the stub references the GVPN to raise the same page fault to the guest OS E. The guest OS E believes that the GVPN corresponds with the VBN B so the guest OS attempts to load the VBN B into a GPPN such as a GPPN B. As described above the VBN B is not backed by a physical data block as indicated by the mapping B in the guest mapping data structure . When the virtualization software D attempts to find a physical block corresponding to the virtual block VBN B the virtualization software discovers the mapping B and begins handling the attempted disk read in a special manner. In particular the virtualization software D maps the GPPN B to a physical page such as a PPN E in the guest address mapping module D but then preferably loads special data into the PPN E that can be used to detect an error condition. The PPN E should not be accessed for any substantive reason because it corresponds with the VBN B which does not contain real data. There is no reason for any software module within the computer system to attempt to access the actual data of the PPN E. Thus the PPN E can be written with particular code or data that causes an error condition if the page is accessed so that the virtualization software D can determine that an error has occurred. In some embodiments to conserve memory one or more physical pages containing error code or data may be shared in the sense that multiple GPPNs may be mapped to a given PPN because the contents of the physical page s are not important except to cause an error condition.

Also because the mapping B indicates that the VBN B is not backed by a physical data block in the environment of the VM D the virtualization software D determines that a corresponding data block actually needs to be loaded in the IEE instead. Specifically the virtualization software D determines from the mapping B in the private mapping data structure that in the IEE the VBN D is backed by the PBN G. Thus in addition to loading error data into the PPN E the virtualization software D also effectively loads the VBN D within the IEE into the private memory of the secure application . More specifically the virtualization software D adds an entry to the private address mapping module not shown in mapping the GPPN to a physical page in the private memory B such as a PPN G. Then the virtualization software D loads the PBN G into the PPN G.

When execution returns to the guest OS E the guest OS adds an entry to the guest OS page table mapping the GVPN to the GPPN B. Next execution continues on the PPN D. Again a page fault occurs at the GVPN because the shadow page table still does not contain a mapping for the GVPN. In response to this page fault the virtualization software D adds an entry E to the shadow page table mapping the GVPN to the PPN E based on the mapping in the guest OS page table from the GVPN to the GPPN B and the mapping in the guest address mapping module D from the GPPN to the PPN E. Also in response to this page fault the virtualization software D adds an entry E to the private page table mapping the GVPN to the PPN G based on the mapping in the guest OS page table from the GVPN to the GPPN B and the mapping in the private address mapping module from the GPPN to the PPN G. Now from the perspective of the IEE the GVPN corresponds to a guest physical page in the virtual system memory D as illustrated by a block D in . This page is backed in the physical memory by the PPN G as indicated by the entry E of the private page table .

Now when execution resumes the reference to the GVPN does not cause a page fault because the shadow page table contains a mapping for the GVPN. As the stub continues to execute it issues another hypervisor call which again causes the secure application to resume execution. Thus in response to the hypervisor call the virtualization software D switches the hardware context to the IEE including activating the private shadow page table . Now when the secure application resumes execution it can proceed into the GVPN because of the entry E in the private shadow page table . Thus the secure application code can now be executed in the PPN G.

Referring now to B and C this indirection embodiment is substantially the same as the dual mapping embodiment of B and C except as described below. Assume again that neither the stub nor the secure application have been installed initially. illustrates the installation of the stub into the VM storage A and the installation of the secure application into the private storage B. In this embodiment the secure installer installs the secure application into the private storage B first. Thus the secure installer writes the secure application into a block of the private storage B such as the block PBN G. The virtualization software D returns a pointer value to the installer that indicates in some manner the location within the private storage B at which the secure application was written. Thus in this example the virtualization software D returns some value to the installer that indicates that the secure application was written to the PBN G. This pointer value is described in greater detail below. From the perspective of the IEE the secure application again occupies the VBN of the virtual disk D which is identified as the VBN D in the IEE. In this embodiment however the private mapping data structure is not used so unlike the dual mapping embodiment the disk emulator D does not establish a mapping from the VBN D of the virtual disk D to the PBN G.

Next the secure installer initiates or activates a process within the VM D which interfaces with the guest OS E to attempt to install the stub into the virtual disk D. Again although the stub only occupies a single block the installer process requests two blocks from the guest OS E in the virtual disk D. Suppose again that the guest OS E allocates the VBN A and the VBN B. The installer process then attempts to write the stub into the VBN A and the disk emulator D translates this attempted disk write into a corresponding write to the VM storage A such as to the block PBN D. The disk emulator D also adds an entry A into the guest mapping data structure mapping the VBN A of the virtual disk D to the PBN D of the VM storage A.

Now in this embodiment the installer process actually writes meaningful data to the VBN B even though the entire stub has already been written to the VBN A. Specifically the installer process writes to the VBN B a block of data containing the pointer value that was returned by the virtualization software D during the installation of the secure application . Again the disk emulator D translates this attempted disk write to a corresponding write to a block of the VM storage A such as the block PBN E. The disk emulator D also adds another entry B into the guest mapping data structure mapping the VBN B of the virtual disk D to the PBN E of the VM storage A.

Now the pointer value that is written into the PBN E may be any value that may be interpreted by the virtualization software D to indicate where in the private storage B the secure application was written. However the pointer value preferably does not provide any meaningful information to any software module within the VM D that may access the PBN E. Thus for example the pointer value could be an encrypted value that can be decrypted to determine the physical block number at which the secure application was written. As another alternative an array may be maintained by the virtualization software D that indicates all of the physical blocks of the disk that constitute the private storage B. Then the pointer value could simply be the index value into the array that points to the physical block into which the secure application was written.

As another alternative a pointer value that points to the secure application within the private storage B may be included within the executable file of the stub which may extend into the PBN E. The executable file may contain a bit vector that indicates which blocks of the disk constitute the private storage B. The bit vector may then be used to load blocks from either the VM storage A or the private storage B and the bit vector may be used to determine the location of the secure application within the private storage B. In this alternative as well as in other embodiments of the invention the stub as contained in the VM storage A may be accessible to other software modules within the VM D. Therefore these other software modules could modify the stub . As a safeguard against this possibility after execution is switched from the stub to the secure application the secure application for example may verify the integrity of the stub in some way such as by performing a hash function on the PBN D and or the PBN E and comparing the results against expected results. As another alternative one or more checksums may be kept in the private storage B that may be used to verify the integrity of the PBN D and or the PBN E. As yet another alternative identical copies of the contents of the PBN D and or the PBN E may also be kept in the private storage B so that the secure application for example may verify the integrity of the stub by comparing the different copies of the code and data of the stub.

Again after the stub and the secure application have been installed a user of the VM D may initiate execution of the stub in a conventional manner. The stub is loaded into the VM memory A and it begins to execute. The stub then causes the secure application to be loaded into the private memory B and the secure application begins to execute. illustrates the loading of the stub into the VM memory A and the initial execution of the stub while illustrates the loading of the secure application into the private memory B and the initial execution of the secure application .

Referring first to when execution of the stub is initiated the guest OS E attempts to load the stub specifically the VBN A into the virtual system memory D such as into the GPPN A. In response to this attempted disk read the virtualization software D adds an entry to the guest address mapping module D not shown in mapping the GPPN A to a physical page into which the stub will actually be loaded such as the PPN D. Based on the mapping A in the guest mapping data structure the virtualization software D determines that the physical block PBN D corresponds with the virtual block VBN A specified by the guest OS E. Thus the virtualization software D loads the physical block PBN D into the physical page PPN D. Next when execution continues in the guest OS E the guest OS creates a page table entry in the guest OS page table not shown in mapping a guest virtual page number such as a GVPN to the guest physical page GPPN A. Thus the GPPN A into which the guest OS E believes the stub was loaded can be accessed using the GVPN.

Next the guest OS E attempts to initiate execution of the stub at the GPPN A which the virtualization software D converts into the corresponding PPN D so that execution of the stub begins at the PPN D. When the stub first uses a virtual address in the GVPN a page fault occurs because the shadow page table which is currently the active page table does not yet contain a mapping for the GVPN. The virtualization software D responds to this page fault and adds an entry D to the shadow page table mapping the GVPN to the PPN D based on the mapping in the guest OS page table from the GVPN to the GPPN A and the mapping in the guest address mapping module D from the GPPN A to the PPN D.

Now execution continues in the stub at the PPN D. The stub makes a hypervisor call to the virtualization software D as described above to initiate execution of the secure application . In response to the hypervisor call the virtualization software D switches the hardware context to the IEE including activating the private page table instead of the shadow page table . In this embodiment also execution resumes in the IEE at the next instruction of the stub within the PPN D. In other embodiments however the virtualization software D may immediately begin to execute the secure application after switching to the IEE .

Again the stub will use a virtual address in the GVPN and again a page fault will occur because the private page table does not yet contain a mapping for the GVPN. The virtualization software D responds to this page fault and adds an entry D to the private page table mapping the GVPN to the PPN D again based on the mapping in the guest OS page table from the GVPN to the GPPN A and the mapping in the guest address mapping module D from the GPPN A to the PPN D. Now again the PPN D is accessible both from within the VM D and from within the IEE and the PPN D can be considered a part of the shared memory C of or as a part of the VM memory A as well as a part of the private memory B as illustrated in . also shows that from the perspective of the IEE the GVPN provides access to the virtual system memory D as represented by the block C. In this example using the GVPN from within the IEE provides access to the PPN D. After the mapping D is added to the private page table execution continues in the IEE in the stub in the PPN D.

Again at this point the main object of the code of the stub is to initiate the loading and execution of the secure application . illustrates this process of loading the secure application into the private memory B along with the initial execution of the secure application. To begin the process a reference is made to a GVPN that maps to the code and or data of the secure application . In this case the appropriate GVPN is the GVPN. When the GVPN is first referenced a page fault occurs because the private page table does not contain a mapping for the GVPN. The virtualization software D responds to the page fault and determines that there are no mappings for the GVPN in the private page table in the shadow page table or in the guest OS page table and forwards the page fault to the guest OS E by causing the stub to raise the same page fault within the VM D as described above.

When the stub references the GVPN to raise the same page fault to the guest OS E the guest OS attempts to load the VBN B into a GPPN such as the GPPN B. In this embodiment the VBN B corresponds with the PBN E which contains the pointer to the secure application in the private storage B. In response to this attempted disk read the virtualization software D adds another entry to the guest address mapping module D not shown in mapping the GPPN B to a physical page into which the pointer value will actually be loaded such as the PPN E. Based on the mapping B in the guest mapping data structure the virtualization software D determines that the physical block PBN E corresponds with the virtual block VBN B specified by the guest OS E. Thus the virtualization software D loads the physical block PBN E into the physical page PPN E.

When execution returns to the guest OS E the guest OS adds an entry to the guest OS page table mapping the GVPN to the GPPN B. Execution then continues on the PPN D and a page fault occurs again at the GVPN because the shadow page table still does not contain a mapping for the GVPN. The virtualization software D again adds an entry E to the shadow page table mapping the GVPN to the PPN E based on the mapping in the guest OS page table from the GVPN to the GPPN B and the mapping in the guest address mapping module D from the GPPN B to the PPN E. Now the stub is able to continue executing and it issues another hypervisor call which again causes the virtualization software D to switch to the IEE .

When execution resumes in the IEE another reference is made to the GVPN and another page fault occurs because the private page table does not yet contain a mapping for the GVPN. Now the virtualization software D checks the shadow page table and finds the mapping E from the GVPN to the PPN E. The virtualization software D then reads the PPN E and determines the pointer value that has been stored in that page. At this point the virtualization software D may verify the integrity of the contents of the PPN E in some manner or at least the integrity of the pointer value such as by comparing hash values checksums or the actual contents with corresponding data stored in the private storage B as described above. The virtualization software D then uses this pointer value to determine the location of the secure application within the private storage B. Thus in this example the virtualization software D determines that the secure application was loaded into the PBN G. Next the virtualization software D adds an entry to the private address mapping module not shown in mapping the GPPN to a physical page in the private memory B into which the secure application will be loaded such as the PPN G. The virtualization software D also adds an entry E to the private page table mapping the GVPN to the same PPN G. Then the virtualization software D loads the PBN G into the PPN G.

Now from the perspective of the IEE the GVPN corresponds to a guest physical page in the virtual system memory D as illustrated by the block D in . This page is backed in the physical memory by the PPN G as indicated by the entry E of the private page table . Now when the secure application resumes execution it can proceed into the GVPN because of the entry E in the private shadow page table . Thus the secure application code can now be executed in the PPN G.

Although the example illustrated in and A to C is simple it can easily be extended to more realistic computer systems. Thus in a real computer system in which the stub and the secure application may comprise additional storage blocks and memory pages the same techniques may be used to load and execute the additional blocks pages in both the IEE and the environment of the VM D. In both the dual mapping embodiment and the indirection embodiment every memory page in the IEE will generally have a corresponding memory page in the environment of the VM D. In each of these embodiments except for the memory pages that are used for the stub none of the corresponding memory pages in the environment of the VM D are used within the VM D. In the dual mapping embodiment these unused corresponding memory pages contain error data while in the indirection embodiment they contain pointers to physical blocks in the private storage B. For each of these embodiments depending on the implementation and the circumstances some of these unused memory pages may be reclaimed for other uses. Even if the guest OS E believes that the unused memory pages are loaded into the virtual system memory D the virtualization software D may not need to allocate corresponding pages of the physical system memory to back these pages. In this case the virtualization software D may use these pages for other purposes.

In the isolated execution embodiments including both the dual mapping embodiment and the indirection embodiment the guest OS E manages the hardware resources for the guest applications H and the secure application in a conventional manner from the perspective of the guest OS E without being able to access or even detect the presence of the private storage B or the private memory B of the secure application . The virtualization software D also responds to actions by the secure application the stub and the guest OS E in a relatively straightforward manner to facilitate the interaction and communication between the IEE and the environment of the VM D while maintaining the isolation between the two environments. The virtualization software D also responds to faults and interrupts and either handles them itself or the virtualization software effectively forwards the faults and interrupts to the guest OS E for handling.

During these various system calls hypervisor calls interactions and communications faults interrupts etc. the virtualization software D switches back and forth between the IEE and the environment of the VM D as needed saving and restoring the respective CPU contexts at each switch. In addition the virtualization software D may periodically switch from the IEE to the environment of the VM D to allow the guest OS E to schedule the times when different software modules within the VM D are allowed to execute. When the secure application is pending execution the stub is also pending execution within the VM D. Whenever the guest OS E schedules the stub to execute the stub makes another hypervisor call to allow the secure application to execute during that time slot. This allows the guest OS E to effectively include the secure application in its ordinary scheduling algorithm along with all the processes within the VM D even though switching to the IEE involves a complete hardware context switch from which the guest OS E could not otherwise regain control.

Although in these embodiments the guest OS E manages hardware resources for the secure application in other embodiments the virtualization software D may be designed to provide more system services to the secure application instead of relying so much on the guest OS E. In such embodiments the computer systems will likely have better overall performance because there will be fewer context switches but the virtualization software D will also be more complex which could make the virtualization software more vulnerable to malicious software.

The isolated execution embodiment may be utilized under at least two distinct strategies. One strategy is to try to maintain the integrity of the IEE accepting the possibility that the software in the VM D may become compromised. Another strategy is to use the IEE for software that may involve security risks while attempting to maintain the integrity of the software within the VM D.

Under the first strategy for example applications that involve particularly sensitive data may be executed in the IEE . For example a financial program such as Quicken financial software from Intuit Inc. may be run in the IEE so that sensitive financial data is isolated from the software modules in the VM D. As another example the IEE may be used for digital rights management purposes. An application for playing digital content such as a movie a song or a video game may be run in the IEE so that the content may be enjoyed within the particular computer system but the digital content cannot otherwise be accessed for copying or for further distribution.

Under the second strategy applications that involve potential security risks are executed in the IEE while all other applications run in the VM D or in other VMs. For example Internet applications such as web browsers and email clients may be run in the IEE . Then before any data is transferred from the IEE to the VM D it can be scanned for viruses etc. to avoid contaminating the software within the VM D. Also the integrity of the software within the IEE may be verified from time to time such as by running a hash operation on the private memory B and or the private storage B and comparing the results to expected values.

As described above in addition to memory pages in the VM memory A that are only accessible from within the VM D and memory pages in the private memory B that are only accessible from within the IEE there may also be one or more memory pages in the shared memory C that are accessible both from within the VM D and from within the IEE . There are a wide variety of reasons why the invention might be implemented with such shared memory pages. For example one or more memory pages may be shared between the IEE and the environment of the VM D so that data may be passed between the environments by the secure application and the software modules in the VM D. As another example one or more memory pages that are used by software modules in the VM D may also be mapped into the IEE making such memory pages shared memory pages so that they may be accessed by the secure application for example. As a specific example of such a use of shared memory pages the secure application may implement a virus scanner which scans all of the memory pages used by the software modules in the VM D i.e. all of the PPNs corresponding to the GPPNs of the VM D . In this case all of the memory pages used by the software modules in the VM D are also mapped into the IEE so that they may be scanned by the secure application . As a means of protecting the memory pages used by the software modules in the VM D in this example the PTEs in the private shadow page table for these memory pages may be marked as read only or non executable. Such a virus scanner would need to interface with the virtualization software D to access all of the GPPNs of the VM D. Depending on the implementation system calls from the secure application to access the GPPNs can either be forwarded to the guest OS E or they may be handled by the virtualization software D using its own API. In this example the secure application is protected from the software modules in the VM D but it is able to gain access to the memory pages used by these software modules to inspect them for viruses. In some implementations too only a relatively small portion of the data used by the secure application may be isolated in the private memory while the rest of the data used by the secure application may be located in the shared memory C. For example only a few pages of physical memory or even just one page may be isolated in the private memory B to store sensitive data such as passwords or encryption keys.

Finally the isolated execution embodiment may be implemented in a wide variety of virtual computer systems including a hosted virtual computer system such as the system X of or a kernel based virtual computer system such as the system Y of . If the embodiment is implemented in the system Y of then the virtualization software Y facilitates and controls all interactions between the VM Y and the system hardware Y. So long as the virtualization software Y is not compromised malicious software should not be able to compromise the IEE . One possible vulnerability for such an implementation could arise if third party modules or drivers are included in the loadable modules and drivers Y in the kernel Y. Depending on the circumstances different measures may be taken to limit the risk of such a vulnerability including possibly not allowing the loading of third party modules and drivers or possibly requiring some form of authentication before loading any third party software.

If the isolated execution embodiment is implemented in the system X of the precautions described in the preceding paragraph can generally be applied to any third party drivers W and any third party applications W that are loaded into the execution environment of the host system software W. Additional measures may also be taken such as encrypting sensitive data before switching to the host environment.

This invention may also be implemented using system hardware that implements Nested Page Tables NPTs . For example Intel Corporation is developing a NPT implementation referred to as Extended Page Tables EPT while Advanced Micro Devices Inc. is developing a NPT implementation referred to as Nested Paging Facility NPF . Documentation regarding these and other implementations of NPTs are publicly available. Generally a first page table a guest page table containing guest address mappings is maintained by a guest OS and maps from GVPNs to GPPNs while a second page table a nested page table containing virtualization address mappings is maintained by virtualization software and maps from GPPNs to PPNs. A hardware MMU uses both the guest page table and the nested page table to map a GVPN issued by guest software to a PPN. The guest and nested page tables may be located through the use of a first and second pointer respectively which may be stored in respective first and second control registers for example.

In such an NPT implementation there is no need for virtualization software to maintain software shadow page tables such as the shadow page table D or the private page table of for example. Instead address mapping modules such as the guest address mapping module D and the private address mapping module could be used as nested page tables. Then using the example of when a software module from within the VM D executes that is using the second guest virtual address space the virtualization software D activates the guest address mapping module D as the nested page table by loading the second control register with an address pointing to the guest address mapping module D. When the secure application executes the virtualization software D activates the private address mapping module as the nested page table by loading the second control register with an address pointing to the private address mapping module .

This invention may also be used to implement multiple isolated execution environments IEEs within a single virtual computer system so that software modules within each of the execution environments cannot access the code or data in either primary or secondary storage of any of the other execution environments. illustrates one embodiment of the invention involving the implementation of multiple IEEs.

Much of what is illustrated in may be substantially the same as corresponding elements that have been described above in connection with . Thus shows a system hardware E which includes a TLB E a system memory E and one or more disks E. The system hardware E may be substantially the same as the system hardware X of the system hardware Y of the system hardware C of or the system hardware D of . also shows virtualization software E which except as described below may be substantially the same as the virtualization software X of the virtualization software Y of the virtualization software B of or the virtualization software D of .

All of the elements of that have been identified thus far are generally found in existing virtual computer systems. These elements and other elements that are not illustrated for simplicity generally implement a virtual computer system that except as described below may be substantially the same as existing virtual computer systems. The virtualization software E supports a VM E that for example may be a virtualization of an ordinary x86 computer the guest OS F may be an ordinary general purpose OS such as a Windows OS or a Linux OS.

The virtualization software E establishes a virtualization barrier E between itself and the VM E. The virtualization software E also establishes one or more additional virtualization barriers between the plurality of applications J K L M and N although these virtualization barriers are not illustrated in . These additional virtualization barriers establish different secure sessions or isolated sessions within different IEEs. Each application executing in the VM E generally belongs to a single isolated session executing in a single IEE but more than one application may belong to the same isolated session in the same IEE. Each of the isolated sessions may be identified by a different Session IDentifier SID . Thus as illustrated in the first application J may belong to a first isolated session having a SID of zero SID executing in a first IEE the second application K may belong to a second isolated session having a SID of one SID executing in a second IEE the third application L and the fourth application M may belong to a third isolated session having a SID of two SID executing in a third IEE and the fifth application N may belong to a fourth isolated session having a SID of three SID .

Thus one of the additional virtualization barriers isolates the first application J from all of the other applications within the VM E that are not within the first isolated session another virtualization barrier isolates the second application K from all of the other applications within the VM E that are not within the second isolated session another virtualization barrier isolates the third application L and the fourth application M as a group from all of the other applications within the VM E that are not within the third isolated session and another virtualization barrier isolates the fifth application N from all of the other applications within the VM E that are not within the fourth isolated session. Thus each application within the VM E can access its own code and data in either primary or secondary storage and possibly the code and data of other applications if any within its own isolated session but each application generally cannot access the code and data of any applications that are in other isolated sessions. Each of the applications running in the different IEEs within the VM E may generally be an ordinary application that can run in other execution environments such as on a conventional physical computer and a conventional OS. Alternatively these applications may be customized in one or more ways for execution in the IEEs.

In the single IEE embodiment illustrated in a set of address mapping modules the guest address mapping module D and the private address mapping module and a set of shadow pages tables the shadow page tables D and the private shadow page table generally divide the system memory into a first set of memory pages that can be accessed from within the VM D and a second set of memory pages that can only be accessed from within the IEE as well as possibly some shared memory pages and some other memory pages that are used for other purposes. In a similar manner in the multiple IEE embodiment of a set of address mapping modules E and a set of shadow page tables E generally divide the system memory E into a first set of memory pages that can only be accessed from within the first IEE a second set of memory pages that can only be accessed from within the second IEE a third set of memory pages that can only be accessed from within the third IEE and a fourth set of memory pages that can only be accessed from within the fourth IEE. There may also be additional memory pages that are shared between two or more of the IEEs and or other memory pages that are used for other purposes.

Also in the single IEE embodiment illustrated in the disk emulator D maintains a set of disk block mapping data structures the guest mapping data structure and the private mapping data structure see that are used to generally divide the physical disk s into a first set of data blocks that can be accessed from within the VM D and a second set of data blocks that can only be accessed from within the IEE as well as possibly some shared data blocks and some other data blocks that are used for other purposes. In a similar manner in the multiple IEE embodiment of a disk emulator E maintains a set of disk block mapping data structures not shown that are used to generally divide the physical disk E into a first set of data blocks that can only be accessed from within the first IEE a second set of data blocks that can only be accessed from within the second IEE a third set of data blocks that can only be accessed from within the third IEE and a fourth set of data blocks that can only be accessed from within the fourth IEE. There may also be additional data blocks that are shared between two or more of the IEEs and or other data blocks that are used for other purposes.

The virtualization software E also includes a session administrator . The session administrator determines and or controls which isolated session is active and activates the appropriate address mapping module E and shadow page table E as described in greater detail below as well as causing the disk emulator E to use the appropriate mapping data structure.

The use of the address mapping modules E and the shadow page tables E to isolate the memory pages of the system memory E that belong to each of the IEEs is illustrated in . These figures extend the example of address mapping that was begun in and they apply the extended example to the virtual computer system of to show how the virtualization software E maps virtual addresses to a physical address space of a computer system.

In this case again the guest OS page tables F of comprise the first guest OS page table and the second guest OS page table . The guest OS F creates the first guest OS page table to map addresses from the first guest virtual address space to the guest physical address space and the guest OS F creates the second guest OS page table to map addresses from the second guest virtual address space to the guest physical address space . In the SCENARIO illustrated in A and B the first guest application J and the second guest application K both use the first guest virtual address space while the third guest application L the fourth guest application M and the fifth guest application N all use the second guest virtual address space .

In existing computer systems each application typically has its own virtual address space. Even separate processes of a single application typically have separate virtual address spaces. However this example in which multiple applications share a common virtual address space is used to illustrate some of the capabilities of different possible embodiments of the invention. In existing computer systems however multiple threads of a given process may share a common virtual address space. Therefore this example may also be applied to typical existing computer systems by considering the guest applications J K L M and N as threads instead of applications. Thus a first thread represented by the first guest application J and a second thread represented by the second guest application K may both use the first guest virtual address space while a third thread represented by the third guest application L a fourth thread represented by the fourth guest application M and a fifth thread represented by the fifth guest application N may all use the second guest virtual address space .

The virtualization software E creates the address mapping modules E to map addresses in the guest physical address space to the actual physical address space for each of the respective isolated sessions. Thus the first address mapping module maps addresses in the guest physical address space to the actual physical address space for SID the second address mapping module maps addresses in the guest physical address space to the actual physical address space for SID the third address mapping module maps addresses in the guest physical address space to the actual physical address space for SID and the fourth address mapping module maps addresses in the guest physical address space to the actual physical address space for SID.

The virtualization software E also creates the shadow page tables E for mapping addresses from the guest virtual address spaces and to the physical address space for each of the respective isolated sessions. More specifically the first shadow page table maps addresses from the first guest virtual address space to the physical address space for SID the second shadow page table maps addresses from the first guest virtual address space to the physical address space for SID the third shadow page table maps addresses from the second guest virtual address space to the physical address space for SID and the fourth shadow page table maps addresses from the second guest virtual address space to the physical address space for SID.

The contents of the address mapping modules E are shown in . Thus the first address mapping module contains three entries or mappings namely a first entry A that maps the GPPN A to the PPN A a second entry B that maps the GPPN B to the PPN C and a third entry C that maps the GPPN C to the PPN E. What this means is that during the first isolated session having SID the code and or data that the guest OS believes to be stored in the GPPN A is actually stored in the PPN A the code and or data that the guest OS believes to be stored in the GPPN B is actually stored in the PPN C and the code and or data that the guest OS believes to be stored in the GPPN C is actually stored in the PPN E.

The second address mapping module also contains three entries or mappings namely a first entry A that maps the GPPN A to the PPN A a second entry B that maps the GPPN B to the PPN B and a third entry C that maps the GPPN C to the PPN D. What this means is that during the second isolated session having SID the code and or data that the guest OS believes to be stored in the GPPN A is actually stored in the PPN A the code and or data that the guest OS believes to be stored in the GPPN B is actually stored in the PPN B and the code and or data that the guest OS believes to be stored in the GPPN C is actually stored in the PPN D.

The third address mapping module contains two entries or mappings namely a first entry B that maps the GPPN B to the PPN H and a second entry C that maps the GPPN D to the PPN G. What this means is that during the third isolated session having SID the code and or data that the guest OS believes to be stored in the GPPN B is actually stored in the PPN H and the code and or data that the guest OS believes to be stored in the GPPN D is actually stored in the PPN G.

The fourth address mapping module also contains two entries or mappings namely a first entry A that maps the GPPN A to the PPN J and a second entry C that maps the GPPN D to the PPN I. What this means is that during the fourth isolated session having SID the code and or data that the guest OS believes to be stored in the GPPN A is actually stored in the PPN J and the code and or data that the guest OS believes to be stored in the GPPN D is actually stored in the PPN I.

In the single IEE embodiment of as described above if the set of PPNs of the actual physical address space to which the private address mapping module maps the GPPNs of the guest physical address space is mutually exclusive with the PPNs to which the guest address mapping module D maps the guest physical address space then the memory pages that are accessible from within the VM D are mutually exclusive with the memory pages that are accessible from within the IEE . Similarly in the multiple IEE embodiment of if the different sets of PPNs to which the different address mapping modules E map the GPPNs are all mutually exclusive with respect to one another then the memory pages that are accessible from within each of the IEEs will also be mutually exclusive with respect to one another.

Thus if the set of PPNs to which the first address mapping module maps the GPPNs are mutually exclusive with the PPNs to which the second address mapping module maps the GPPNs then the memory pages that are accessible from within the first isolated session having SID are mutually exclusive with the memory pages that are accessible from within the second isolated session having SID if the set of PPNs to which the first address mapping module maps the GPPNs are mutually exclusive with the PPNs to which the third address mapping module maps the GPPNs then the memory pages that are accessible from within the first isolated session having SID are mutually exclusive with the memory pages that are accessible from within the third isolated session having SID if the set of PPNs to which the first address mapping module maps the GPPNs are mutually exclusive with the PPNs to which the fourth address mapping module maps the GPPNs then the memory pages that are accessible from within the first isolated session having SID are mutually exclusive with the memory pages that are accessible from within the fourth isolated session having SID if the set of PPNs to which the second address mapping module maps the GPPNs are mutually exclusive with the PPNs to which the third address mapping module maps the GPPNs then the memory pages that are accessible from within the second isolated session having SID are mutually exclusive with the memory pages that are accessible from within the third isolated session having SID if the set of PPNs to which the second address mapping module maps the GPPNs are mutually exclusive with the PPNs to which the fourth address mapping module maps the GPPNs then the memory pages that are accessible from within the second isolated session having SID are mutually exclusive with the memory pages that are accessible from within the fourth isolated session having SID and if the set of PPNs to which the third address mapping module maps the GPPNs are mutually exclusive with the PPNs to which the fourth address mapping module maps the GPPNs then the memory pages that are accessible from within the third isolated session having SID are mutually exclusive with the memory pages that are accessible from within the fourth isolated session having SID.

With the address mapping modules E as illustrated in the different sets of PPNs to which the different address mapping modules E map the GPPNs are all mutually exclusive with respect to one another except that both the first address mapping module and the second address mapping module map the GPPN A to the PPN A. Thus the memory page PPN A is a shared memory page accessible from within both the first isolated session having SID and the second isolated session having SID. Otherwise all of the memory pages that are accessible from within each of the isolated sessions are mutually exclusive with respect to one another. More specifically in the example of A and B the memory pages PPN A PPN C and PPN E are accessible from within the first isolated session having SID the memory pages PPN A PPN B and PPN D are accessible from within the second isolated session having SID the memory pages PPN H and PPN G are accessible from within the third isolated session having SID and the memory pages PPN J and PPN I are accessible from within the fourth isolated session having SID.

The mappings in the address mapping modules E may be viewed as establishing a separate private memory for each of the isolated sessions so that the memory pages in a private memory for a particular isolated session are only accessible from within that isolated session as well as possibly one or more shared memories which contain memory pages that are shared between two or more isolated sessions. Thus the address mapping modules E establish a first private memory for the first isolated session having SID including the memory pages PPN C and PPN E a second private memory for the second isolated session having SID including the memory pages PPN B and PPN D a third private memory for the third isolated session having SID including the memory pages PPN H and PPN G a fourth private memory for the fourth isolated session having SID including the memory pages PPN J and PPN I and a shared memory that is shared between the first isolated session having SID and the second isolated session having SID including the memory page PPN A.

The entries in the shadow page tables E are derived from the entries in the corresponding guest OS page tables and and the entries in the corresponding address mapping modules E in the same manner as described above for the shadow page tables and of . Thus the entries in the first shadow page table are derived from the entries in the first guest OS page table and the entries in the first address mapping module the entries in the second shadow page table are derived from the entries in the first guest OS page table and the entries in the second address mapping module the entries in the third shadow page table are derived from the entries in the second guest OS page table and the entries in the third address mapping module and the entries in the fourth shadow page table are derived from the entries in the second guest OS page table and the entries in the address mapping module all in the same manner as described above.

Thus as shown in the first shadow page table contains three mappings or PTEs mapping GVPNs to PPNs namely a PTE A that maps the GVPN A to the PPN A a PTE B that maps the GVPN B to the PPN C and a PTE C that maps the GVPN C to the PPN E. The second shadow page table also contains three PTEs mapping GVPNs to PPNs namely a PTE A that maps the GVPN A to the PPN A a PTE B that maps the GVPN B to the PPN B and a PTE C that maps the GVPN C to the PPN D. The third shadow page table contains two PTEs mapping GVPNs to PPNs namely a PTE B that maps the GVPN D to the PPN H and a PTE C that maps the GVPN C to the PPN G. The fourth shadow page table also contains two PTEs mapping GVPNs to PPNs namely a PTE A that maps the GVPN A to the PPN J and a PTE C that maps the GVPN C to the PPN I.

All of the elements of operate in substantially the same manner as corresponding elements of except as described herein. Thus suppose that a scenario is applied to A and B that is analogous to the scenario that was applied to above so that the guest OS page tables and are created by the guest OS F of . In this scenario however as described above the first guest virtual address space is used by the first guest application J and the second guest application K while the second guest virtual address space is used by the third guest application L the fourth guest application M and the fifth guest application N. The guest address mapping modules E and the shadow page tables E are created by a memory manager in the virtualization software E.

Now when the first guest application J is executed the guest OS F attempts to ensure that the first guest OS page table is active but the virtualization software E ensures instead that the first shadow page table is active to ensure that the first isolated session having SID is active. If the first guest application J generates an attempted memory access to the GVPN A a MMU not shown in the physical system hardware E maps the virtual address to the PPN A based on the PTE A if the first guest application J generates an attempted memory access to the GVPN B the MMU maps the virtual address to the PPN C based on the PTE B and if the first guest application J generates an attempted memory access to the GVPN C the MMU maps the virtual address to the PPN E based on the PTE C.

When the second guest application K is executed the guest OS F also attempts to ensure that the first guest OS page table is active but the virtualization software E ensures instead that the second shadow page table is active to ensure that the second isolated session having SID is active. If the second guest application K generates an attempted memory access to the GVPN A the MMU maps the virtual address to the PPN A based on the PTE A if the second guest application K generates an attempted memory access to the GVPN B the MMU maps the virtual address to the PPN B based on the PTE B and if the second guest application K generates an attempted memory access to the GVPN C the MMU maps the virtual address to the PPN D based on the PTE C.

When the third guest application L or the fourth guest application M is executed the guest OS F attempts to ensure that the second guest OS page table is active but the virtualization software E ensures instead that the third shadow page table is active to ensure that the third isolated session having SID is active. If the third guest application L or the fourth guest application M generates an attempted memory access to the GVPN D the MMU maps the virtual address to the PPN H based on the PTE B and if the third guest application L or the fourth guest application M generates an attempted memory access to the GVPN C the MMU maps the virtual address to the PPN G based on the PTE C.

When the fifth guest application N is executed the guest OS F also attempts to ensure that the second guest OS page table is active but the virtualization software E ensures instead that the fourth shadow page table is active to ensure that the fourth isolated session having SID is active. If the fifth guest application N generates an attempted memory access to the GVPN A the MMU maps the virtual address to the PPN J based on the PTE A and if the fifth guest application N generates an attempted memory access to the GVPN C the MMU maps the virtual address to the PPN I based on the PTE C.

Thus more generally when a software module executes in the first isolated session having SID using the first guest virtual address space the virtualization software E activates the first shadow page table so that the MMU in the system hardware E uses this page table for address translations when a software module executes in the second isolated session having SID again using the first guest virtual address space the virtualization software E activates the second shadow page table so that the MMU in the system hardware E uses this page table for address translations when a software module executes in the third isolated session having SID using the second guest virtual address space the virtualization software E activates the third shadow page table so that the MMU in the system hardware E uses this page table for address translations and when a software module executes in the fourth isolated session having SID again using the second guest virtual address space the virtualization software E activates the fourth shadow page table so that the MMU in the system hardware E uses this page table for address translations.

Now suppose that malicious software is able to execute within the first IEE in the first isolated session having SID. Because the isolation barriers provided by the guest OS F are typically relatively weak in comparison to a virtualization barrier the malicious software may gain full access to the guest OS page tables and and it may then use the guest OS page tables and to gain access to any memory page in the guest physical address space . The guest physical address space constitutes the entire system memory E of the VM E which is the only memory that is visible from within the VM E. Accordingly the only actual physical memory that is accessible from within the VM E is the physical memory to which the guest physical address space is mapped. Thus in this example the only physical memory pages that would be accessible to the malicious software despite the malicious software having defeated the isolation barriers provided by the guest OS F are the memory pages to which the guest physical address space is mapped by the first address mapping module . As long as the virtualization software E is well designed and well implemented there will be no way for any software in the first IEE to determine that there is any memory in the computer system besides the physical memory to which the guest system memory E is mapped during the isolated session having SID. And yet accessing the entire system memory E does not give any access to the private memory of any of the other IEEs. Similarly if malicious software is able to execute within any of the other IEEs the malicious software would only be able to access the physical memory pages to which the guest physical address space is mapped during that particular isolated session.

Malicious software within an IEE may obtain full access to the guest virtual address spaces and the guest OS page tables and and the guest physical address space . However the virtualization barriers including the virtualization barrier E and the additional virtualization barriers that isolate the multiple isolated sessions from one another prevent such malicious software from accessing or directly affecting the operation of the virtualization software E the session administrator the address mapping modules E and the shadow page tables E all of which restrict access to the physical address space as described above. So long as these virtualization barriers are able to protect these software modules and data structures the private memory of each of the IEEs will be effectively isolated from software modules in all of the other IEEs.

Also although the multiple IEE embodiment illustrated in A and B involves the use of specific data structures and software modules to maintain the data needed to isolate the private memory of the multiple IEEs other data structures and software modules could be used in other embodiments.

A method was described above for dividing the physical disk s of into a first set of data blocks constituting the VM storage A a second set of data blocks constituting the private storage B a third set of data blocks constituting the shared storage C and possibly other sets of data blocks that are used for other purposes. The virtualization software E may use substantially the same method for dividing the physical disk E into different sets of data blocks some of which provide private storage for each of the isolated sessions others of which may be shared between multiple isolated sessions and some of which may be used for other purposes. This method may be performed in particular by the disk emulator E which may be substantially the same as the disk emulator D of except as required to maintain private and shared storage for the multiple IEEs.

The device emulator E may use a plurality of disk block mapping data structures with one mapping data structure for each IEE each of which may be substantially the same as the guest mapping data structure of so that each mapping data structure contains mappings from virtual block numbers to physical block numbers for a different IEE. Thus a first mapping data structure may be used for the first isolated session having SID that maps the virtual block numbers of the virtual disk E to the physical data blocks in the physical disk E that contain the code and or data of the first IEE a second mapping data structure may be used for the second isolated session having SID that maps the virtual block numbers of the virtual disk E to the physical data blocks in the physical disk E that contain the code and or data of the second IEE a third mapping data structure may be used for the third isolated session having SID that maps the virtual block numbers of the virtual disk E to the physical data blocks in the physical disk E that contain the code and or data of the third IEE and a fourth mapping data structure may be used for the fourth isolated session having SID that maps the virtual block numbers of the virtual disk E to the physical data blocks in the physical disk E that contain the code and or data of the fourth IEE. The sets of physical data blocks to which each of the four mapping data structures map the virtual block numbers are generally mutually exclusive to ensure that the private storage for the different isolated sessions are generally mutually exclusive. The disk emulator E then uses the first mapping data structure during SID the second mapping data structure during SID the third mapping data structure during SID and the fourth mapping data structure during SID to isolate the code and data of each IEE stored in the physical disk E from software modules within each of the other IEEs.

Many of the same issues that arose in the single IEE embodiment also arise in this multiple IEE embodiment. The methods used to resolve these issues in the single IEE embodiment may generally be extended by a person of skill in the art to resolve the same issues in the multiple IEE embodiment. The vast technical literature in the field of computer science may also be consulted for descriptions and explanations of a wide variety of methods and configurations that may be used to address these issues or similar analogous issues to implement the multiple IEE embodiment in a wide variety of hardware and software implementations. Different techniques may be appropriate in different embodiments of the invention depending on the particular hardware and software configurations and the relative importance that is placed on a variety of factors including the degree of security desired and the amount and nature of communication and interaction that is desired between the multiple IEEs.

One particular issue that should be addressed for the multiple IEE embodiment however is how to handle the guest OS F relative to the multiple IEEs. When an application is running on an OS the OS must typically access some of the data of the application in various circumstances such as in response to a system call by the application. Thus to provide support to the applications the guest OS F must generally have some sort of access to data belonging to each of the IEEs in the VM E. However if the guest OS F is simply given access to data in each of the IEEs then all of the IEEs are vulnerable again to attacks from malicious software. Malicious software could infiltrate the guest OS F to gain access to data in any of the IEEs. Therefore the guest OS F is preferably given only limited access to private data belonging to each of the IEEs in the VM E with the access restricted in some manner that protects against misuse of the private data. Depending on the particular implementation involved a variety of approaches may be used. One such approach is illustrated in and another such approach is illustrated in .

The virtual computer system of may also have additional components that are substantially the same as corresponding components of so that except as described below the virtual computer system illustrated in is substantially the same as the virtual computer system illustrated in . For example the virtual computer system may include a system memory such as the system memory E of a physical disk such as the physical disk E of a virtual system memory such as the virtual system memory E of a virtual disk such as the virtual disk E of a session administrator such as the session administrator of a set of address mapping modules such as the address mapping modules E of a set of shadow page tables such as the shadow page tables E of a disk emulator such as the disk emulator E of a set of guest OS page tables such as the guest OS page tables F of and a file manager such as the file manager F of although these components are not illustrated in for simplicity.

As shown in the virtualization software F maintains at least three address mapping modules including a first address mapping module A a second address mapping module B and a third address mapping module C and at least three corresponding shadow page tables including a first shadow page table A a second shadow page table B and a third shadow page table C. In the same manner as described above each of the address mapping modules A B and C separately maps the guest physical address space into the actual physical address space. Through these mappings the first address mapping module A specifies which physical memory pages are accessible from within a first IEE during a first isolated session having SID the second address mapping module B specifies which physical memory pages are accessible from within a second IEE during a second isolated session having SID and the third address mapping module C specifies which physical memory pages are accessible from within a third IEE during a third isolated session having SID. The three sets of physical memory pages to which the respective address mapping modules A B and C map the guest physical address space are generally mutually exclusive from one another so that each address mapping module generally defines a private memory for the respective isolated session with each private memory including physical memory pages that are only accessible from within the respective isolated session. Thus the first address mapping module A defines a first private memory for the first isolated session having SID that is only accessible from within the first isolated session the second address mapping module B defines a second private memory for the second isolated session having SID that is only accessible from within the second isolated session and the third address mapping module C defines a third private memory for the third isolated session having SID that is only accessible from within the third isolated session. The address mapping modules A B and C may also jointly specify physical memory pages that are shared between multiple isolated sessions but for simplicity this description assumes that there are no such shared memory pages except for a shared library as described below.

The mappings in the first shadow page table A are derived from the mappings in the first address mapping module A and the mappings in a guest OS page table the mappings in the second shadow page table B are derived from the mappings in the second address mapping module B and the mappings in a guest OS page table and the mappings in the third shadow page table C are derived from the mappings in the third address mapping module C and the mappings in a guest OS page table all in the same manner as described above. As described above the first shadow page table A is active during the first isolated session having SID the second shadow page table B is active during the second isolated session having SID and the third shadow page table C is active during the third isolated session having SID. As shown in the first application O executes in the second IEE during the second isolated session having SID and the second application P executes in the third IEE during the third isolated session having SID.

A person of skill in the art may devise a variety of techniques for ensuring that the desired shadow page table is active whenever a given isolated session is active such as ensuring that the second shadow page table B is active whenever the first application O is executing and ensuring that the third shadow page table C is active whenever the second application P is executing. The particular technique used for any given implementation may depend on a variety of factors. One such technique that may be used is to switch shadow page tables in response to the guest OS attempting to switch guest OS page tables. In many OSs such as in Windows and Linux OSs a separate virtual address space is typically defined for each application running on the OS with each application having its own page table. Whenever the OS switches from the execution of a first application to the execution of a second application the OS switches page tables from that of the first application to that of the second application. Although having a separate page table and virtual address space for each application running on an OS is a common practice this practice differs from the example illustrated in A and B because in that example multiple applications share the same guest OS page table and virtual address space. The example of A and B is intended to show more of the possibilities for implementing the invention.

Assume however that for the virtual computer system illustrated in each guest application has a separate guest OS page table and a separate virtual address space. Thus the guest OS G creates and maintains a first guest OS page table for the first application O defining a first virtual address space and a second guest OS page table for the second application P defining a second virtual address space. Now when the guest OS G is going to execute the first application O the guest OS attempts to ensure that the first guest OS page table is active and when the guest OS is going to execute the second application P the guest OS attempts to ensure that the second guest OS page table is active. The virtualization software F detects any attempt to change which guest OS page table is active and the virtualization software activates the corresponding shadow page table. Thus if the guest OS G attempts to activate the first guest OS page table before allowing the first application O to execute the virtualization software F detects this attempted activation and instead activates the second shadow page table B and if the guest OS G attempts to activate the second guest OS page table before allowing the second application P to execute the virtualization software F detects this attempted activation and instead activates the third shadow page table C. In an x86 system for example the virtualization software F detects an attempt by the guest OS G to write to control register CR to specify a different guest OS page table. The virtualization software F then writes to the physical CR to specify the corresponding shadow page table and updates a virtual CR to reflect the attempted write by the guest OS G. In other computer systems that use Address Space Idenfitiers ASIDs these ASIDs may be tracked and monitored to determine which isolated session is currently active.

As shown in the guest OS G includes a conventional kernel A and a conventional shared library A. In this specific implementation of the multiple IEE embodiment when the guest OS G executes on behalf of an application such as in response to a system call or when handling a hardware interrupt on behalf of the application the guest OS G executes in the same IEE as the application. Thus for example if the first application O calls a routine from the shared library A the called routine executes in the isolated session having SID with the second shadow page table B active while if the second application P calls a routine from the shared library A the called routine executes in the isolated session having SID with the third shadow page table C active. Similarly if the kernel A executes on behalf of the first application O the kernel executes in the isolated session having SID with the second shadow page table B active while if the kernel A executes on behalf of the second application P the kernel executes in the isolated session having SID with the third shadow page table C active. When the kernel A executes and it s not on behalf of a specific application the kernel executes in the isolated session having SID with the first shadow page table A active.

Now as mentioned above if the kernel A or the shared library A is infiltrated by malicious software then this malicious software can gain access to the private memory of the applications O and P while the kernel or shared library is executing in the respective isolated session SID or SID. Therefore some restriction is preferably imposed on the execution of the guest OS G to reduce the risk that malicious software can gain access to the private memory of the applications O and P. The restriction that is imposed may depend on the particular implementation of the invention and on various other factors such as the importance of maintaining the security of the private memories of the applications and the importance of allowing the guest OS to execute efficiently.

One restriction that may be imposed is represented in by a first hashlist B and a second hashlist C. The first hashlist B is used during the isolated session having SID and the second hashlist C is used during the isolated session having SID. The first hashlist B contains expected hash values for all routines in the kernel A and the shared library A that are expected to be executed during the isolated session having SID and the second hashlist C contains expected hash values for all routines in the kernel A and the shared library A that are expected to be executed during the isolated session having SID. Before executing any routine from the kernel A or the shared library A during the isolated session having SID corresponding hash value s for the routine are computed and compared against the expected hash value s for the routines from the hashlist B while before executing any routine from the kernel A or the shared library A during the isolated session having SID corresponding hash value s for the routine are computed and compared against the expected hash value s for the routines from the hashlist C. Such a technique is disclosed in U.S. patent application Ser. No. 10 791 602 Waldspurger et al. Dynamic Verification Of Validity Of Executable Code the 602 application which has been assigned to the same assignee as this patent and which is hereby incorporated herein by reference. If the hash value s for a routine compare favorably with the expected hash value s for the routine then it is generally safe to assume that the routine has not been adversely affected by malicious software and the routine may be executed in the respective isolated session giving the routine access to the private memory of the isolated session. Other techniques for verifying the integrity of routines prior to execution are also disclosed in the 602 application and these other techniques may also be used in other embodiments of this invention.

Although this description related to is limited to isolating the private memories of the different isolated sessions from one another the same approach may be used to isolate the private disk storage of the different isolated sessions from one another. Based on this description related to a person of skill in the art will be able to apply the same approach to isolated private disk storage for the isolated sessions.

The virtual computer system of may also have additional components that are substantially the same as corresponding components of so that except as described below the virtual computer system illustrated in is substantially the same as the virtual computer system illustrated in . For example the virtual computer system may include a system memory such as the system memory E of a physical disk such as the physical disk E of a virtual system memory such as the virtual system memory E of a virtual disk such as the virtual disk E of a session administrator such as the session administrator of a set of address mapping modules such as the address mapping modules E of a set of shadow page tables such as the shadow page tables E of a disk emulator such as the disk emulator E of a set of guest OS page tables such as the guest OS page tables F of and a file manager such as the file manager F of although these components are not illustrated in for simplicity.

As shown in the virtualization software G maintains at least three address mapping modules including a first address mapping module A a second address mapping module B and a third address mapping module C and at least three corresponding shadow page tables including a first shadow page table A a second shadow page table B and a third shadow page table C. In the same manner as described above each of the address mapping modules A B and C separately maps the guest physical address space into the actual physical address space. Through these mappings the first address mapping module A specifies which physical memory pages are accessible from within a first IEE during a first isolated session having SID the second address mapping module B specifies which physical memory pages are accessible from within a second IEE during a second isolated session having SID and the third address mapping module C specifies which physical memory pages are accessible from within a third IEE during a third isolated session having SID. The three sets of physical memory pages to which the respective address mapping modules A B and C map the guest physical address space are generally mutually exclusive from one another so that each address mapping module generally defines a private memory for the respective isolated session with each private memory including physical memory pages that are only accessible from within the respective isolated session. Thus the first address mapping module A defines a first private memory for the first isolated session having SID that is only accessible from within the first isolated session the second address mapping module B defines a second private memory for the second isolated session having SID that is only accessible from within the second isolated session and the third address mapping module C defines a third private memory for the third isolated session having SID that is only accessible from within the third isolated session. The address mapping modules A B and C may also jointly specify physical memory pages that are shared between multiple isolated sessions but for simplicity this description assumes that there are no such shared memory pages.

The mappings in the first shadow page table A are derived from the mappings in the first address mapping module A and the mappings in a guest OS page table the mappings in the second shadow page table B are derived from the mappings in the second address mapping module B and the mappings in a guest OS page table and the mappings in the third shadow page table C are derived from the mappings in the third address mapping module C and the mappings in a guest OS page table all in the same manner as described above. As described above the first shadow page table A is active during the first isolated session having SID the second shadow page table B is active during the second isolated session having SID and the third shadow page table C is active during the third isolated session having SID. As shown in the first application Q executes in the second IEE during the second isolated session having SID and the second application R executes in the third IEE during the third isolated session having SID.

As described above a person of skill in the art may devise a variety of techniques for ensuring that the desired shadow page table is active whenever a given isolated session is active such as ensuring that the second shadow page table B is active whenever the first application Q is executing and ensuring that the third shadow page table C is active whenever the second application R is executing. The particular technique used for any given implementation may depend on a variety of factors. A second such technique that may be used is to monitor the code that is being executed and determine when the code that is to be executed next is in a different isolated session from the code that has just been executed and switching to an appropriate isolated session for the code that is to be executed next. For example code that is about to be executed may be run through a hash algorithm and the results may be compared with known hash values for code in the different isolated sessions.

As shown in the guest OS H includes a conventional kernel B a first conventional shared library B and a second conventional shared library C. In this specific implementation of the multiple IEE embodiment the kernel B always executes in the isolated session having SID with the first shadow page table A active. Also each isolated session other than the isolated session having SID has its own shared library. Thus the first shared library B is associated with the application Q and executes in the second isolated session having SID while the second shared library C is associated with the application R and executes in the third isolated session having SID. Thus when the virtualization software G determines that code belonging to the kernel B is to execute the virtualization software G ensures that the first shadow page table A is active when the virtualization software G determines that code belonging to either the application Q or the shared library B is to execute the virtualization software G ensures that the second shadow page table B is active and when the virtualization software G determines that code belonging to either the application R or the shared library C is to execute the virtualization software G ensures that the third shadow page table C is active. In this specific embodiment there is no need to verify the integrity of the shared libraries B and C because each shared library is specific to its own isolated session. There is also no need to verify the integrity of the kernel B because the kernel executes in its own isolated session. However any time the kernel B is executing and there is a reference to memory that belongs to an isolated session other than the first isolated session having SID a fault will occur. The virtualization software G can handle such faults and virtualize the execution of the kernel code while protecting the memory of the other isolated sessions.

Although this description related to is limited to isolating the private memories of the different isolated sessions from one another the same approach may be used to isolate the private disk storage of the different isolated sessions from one another. Based on this description related to a person of skill in the art will be able to apply the same approach to isolated private disk storage for the isolated sessions.

