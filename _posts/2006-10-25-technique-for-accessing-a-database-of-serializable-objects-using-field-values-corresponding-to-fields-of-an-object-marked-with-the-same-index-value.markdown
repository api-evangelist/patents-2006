---

title: Technique for accessing a database of serializable objects using field values corresponding to fields of an object marked with the same index value
abstract: A converter may be used to convert a serializable object to other file formats. A serializable objects database can be used to store these serializable objects. The serializable object database may be accessed by passing a field value, corresponding to a selected field of the serializable object, to the database. The selected field of the serializable object is marked with an index value. The database is queried using the field value to determine whether any record stored in the database includes the field value in a matching field indicated by the index value. If the query determines that the serializable objects database includes at least one record with the field value in the matching field indicated by the index value, then a plurality of field values are returned to populate a plurality of fields of the serializable object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07620526&OS=07620526&RS=07620526
owner: Zeugma Systems Inc.
number: 07620526
owner_city: Richmond
owner_country: CA
publication_date: 20061025
---
This disclosure relates generally to software and in particular but not exclusively relates to databases.

Since database merely indexes data buffers or records to internal keys the knowledge and complexity required to run higher level queries on database is pushed onto application developers of database client . Furthermore since the internal keys themselves are not part of the useful data stored by database client but rather independently generated values used simply for retrieving records or data buffers the internal keys consume additional memory resources within database .

In an alternative conventional database system database itself may contain knowledge of the internal representation of the data buffers or records it stores to perform it own complex queries and indexing. This alternative embodiment pushes the complexities of indexing and queries onto the database developer however does so at the expense of performance by adding a layer of abstraction between the records stored and the database clients accessing the records.

Embodiments of a system and method for serializable objects and a serializable objects database are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the techniques described herein can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring certain aspects.

Reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of the phrases in one embodiment or in an embodiment in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In the illustrated embodiment network service element is implemented using an Advanced Telecommunication and Computing Architecture ATCA chassis. Mesh interconnect may provide cross connectivity between traffic and compute modules and with the ATCA backplane. In the exemplary configuration shown in the ATCA chassis is fully populated with 14 ATCA blades i.e. traffic and compute modules and with each blade installed in a respective chassis slot in an actual implementation the chassis may be populated with less blades or may include other types of blades in addition to compute and traffic blades. The illustrated configuration includes four compute modules and traffic modules with one of the compute modules being provisioned to provide operations administration maintenance and provisioning functionality OAMP functions. As depicted by interconnection mesh each module is communicatively coupled with every other module under the control of fabric switching operations performed by each module s fabric switch. In one embodiment mesh interconnect provides a 10 Gbps connection between each pair of modules with an aggregate bandwidth of 280 Gbps.

In the illustrated embodiments network service element is implemented using a distributed architecture wherein various processor and memory resources are distributed across multiple modules. To scale a system one simply adds another module e.g. blade . The system is further enabled to dynamically allocate processor tasks and to automatically perform fail over operations in response to a module failure or the like. Furthermore under an ATCA implementation modules may be hot swapped without taking the system down thus supporting dynamic scaling.

HAL abstracts the underlying hardware resources to the software layers above and may include various device drivers a kernel software buffers or the like. Runtime layer is used to maintain dynamic state information for the modules of network service node which may be in a state of flux during operation. For example routing demons may execute in runtime layer to setup and tear down route changes to receive and process open shortest path first OSPF protocol packets or service other dynamic change requests coming up from HAL .

Management layer services application programming interface API calls from interface layer and translates the calls into data typically to be stored into a provisioning database or occasionally into a runtime database . The APIs are published into interface layer via a management layer API MLAPI which may provide a variety of APIs for accessing the databases. For example the MLAPI may publish five APIs into interface layer including a set API a get API a get multiple API a create API and a remove API. Management layer typically facilities the provisioning of static attributes assigned to the modules of network service node . For example static attributes may include port assignments the existence or lack thereof of a module in a slot power settings a registry of applications executing on each module and the like.

Finally interface layer proves an access layer to enable a user e.g. network administrator or other Information Technology IT technician to interface with network service element and the lower layers of layered software stack . For example the user may invoke any of the APIs published by the MLAPI using a command line interface CLI to get e.g. retrieve one or more records stored in provisioning database or runtime database create a new record remove e.g. delete an existing record therefrom or set an attribute of an object existing in lower layers of layered software stack . In other cases the interface layer may enable the user to push user data files e.g. extensible markup language XML files etc. down to the lower layers through one or more converters.

As mentioned interface layer enables a user to push in data files from external sources. Data files may be XML files C objects C objects C objects Java objects or otherwise. As a data file is pushed down to management layer layered software stack may convert data file into a serializable object . A serializable object SO is a software object that lends itself well to serialization and which is typically a complex of linked memory structures. As SO is pushed further down to runtime layer SO may be converted into a flat structure . Flat structure typically is a fixed length contiguous memory structure which may be quickly and easy manipulated in memory and therefore well suited for the high speed dynamic environment of runtime layer .

Provisioning database may be used to store provisioning data for setting static or semi static attributes of network service element while runtime database may be used to store runtime data arriving on datapaths rising up from HAL . In one embodiment provisioning database may convert SO into variable length compressed flat memory structures prior to storing SO while runtime database may simply store flat structure as a fixed length uncompressed flat structure. Since runtime layer manages high speed dynamically changing events it is reasonable to tradeoff memory consumption e.g. fixed length uncompress structures in exchange for low latency high speed access to runtime database . In contrast management layer typically manages static or semi static attributes therefore compressed variable length structures are advantages even at the expense of incurring some processing overhead related to accessing variable length structures.

SO may operate as a sort of intermediary between the various file formats and provides a sort of common currency within a processing system between various entities which otherwise communicate in a different language or format. SO is amenable to serialization and conversion between some or all of the various file formats listed above as well as others. Generic file CV is included in to illustrate that converters may be provided to convert SO to a number of different file types beyond those illustrated in . For example file may represent a Java file or any other file type or format. In one embodiment the converters are software modules that are generated and linked to endpoints e.g. DB CLI network file C code C code XML file display etc. and may be invoked by SO to read from or write to the selected endpoint.

In one embodiment converters may be used to perform software upgrades of serializable objects. The converters could be inserted in the execution runtime to perform in service software upgrades to translate the serializable objects between version v to version v. Updating an SO may include removing a field with the SO rearranging the order of one or more fields adding new fields or changing the type of a field i.e. translating the field from one basic type to another . As illustrated in upgrades from version v to a version v may be implemented by linking or daisy chaining converters in series. In this manner each software release need only create a converter for converting from the previous release.

One or more fields may be marked with an index . Indexes are substitute identifiers that may be used to reference the corresponding marked field . Indexes enable SO to write out subsets of its fields through a converter into any other form. In one embodiment indexes may either represent a primary index or a secondary index. A primary index is an index which may be used to uniquely identify SO from all other SO s. Accordingly the primary index marks a field having a unique field value . In one embodiment an index value of 1 is reserved for the primary index. The same index value may be used to mark multiple fields as illustrated by index value 2 marking fields and . By invoking index value 2 the field values e.g. VALUE A and VALUE B corresponding to the fields marked with an index having an index value of 2 are referenced.

The to struct method and the from struct method may be invoked by SO to convert itself into a fixed length flat contiguous memory structure or generate itself from a fixed length flat contiguous memory structure respectively. These methods may be useful for manipulating flat contiguous memory structures in runtime layer see and particularly for converting an SO in interface layer or management layer into flat structure in runtime layer . The to struct method enables a user to quickly push an SO down into runtime database . The to struct method pre allocates memory and defines how to map the complex linked memory structures of SO into fixed length flat contiguous memory structures which are amenable to high speed manipulation. The from struct method may be invoked by a blank or empty SO to populate its fields with data from a flat structure.

In one embodiment fields may include flags not illustrated for identifying each field as set unset or modified. When an object reads in an unset field from source object the reader will simply read in a default value for the unset field as opposed to reading the unset field from the source object. In contrast the reader will actually read in field values from a source object for fields marked as set . The modified flag may be used to indicate whether or not a particular field has been changed whether or not it is set or unset. For example a field marked as unset and modified indicates that a user has explicitly unset a field as opposed to a field that was initialized as unset with a default value.

In one embodiment SO may include a merger function to merger its field values with the field values from another SO. In this case if a field is flagged as modified then it field value is retained while fields flagged as unmodified will retain existing values. In one embodiment SO may include a comparison function e.g. diff struct which may be invoked to compare SO against another SO. The output of the comparison function may be a bit field for each field where a 1 represents is different and a 0 represents is same. 

Operation of converter to write from or read into SO is now described with reference to B and C. is a flow chart illustrating a process for writing from SO in accordance with an embodiment of the invention. In a process block one or more fields within SO are set or assigned specific field values . In a process block the write method within SO is invoked which in turn will invoke converter process block .

Once invoked converter will execute a corresponding one of its write methods on each set field in SO . For example if VAR A was declared as basic type INT64 i.e. 64 bit integer then converter will invoke WRITE BT corresponding to INT64 in table . Similarly if VAR B was declared as basic type BOOLEAN then converter will invoke WRITE BT corresponding to basic type BOOLEAN in table . Each write method invoked by converter will access the corresponding field convert the contents of the field based on the converter type and write out the converted field to the destination object file process block .

In one embodiment specific fields of SO may be referenced to be written out by specifying corresponding indexes . For example by invoking a write method identifying a particular converter and passing one or more index values to the write method specified fields may be written out from SO while skipping others. In one embodiment the default setting is writing out all fields when a write method is invoked without specifying index values. In one embodiment all fields may be written out by passing a default index number such as 0 .

As discussed above to translate SO from interface layer or management layer to runtime layer SO may be converted into a flat structure using the to struct method . There may some scenarios where it may be desirable to store more than one type of SO into runtime database . This may be achieved using a concept referred as union . From interface layer or management layer records may be passed down to runtime layer that contain multiple types. For example 

In a process block an empty SO is created illustrated in by arrow . An empty SO is a serializable object where none of the fields have been set or assigned field values. Empty SO may be created by instantiating a new SO based on a class definition file . In a process block one or more fields of empty SO e.g. fields are set or assigned field values illustrated in by arrow to create set SO . In the embodiment illustrated in field is set with a field value VALUE A. In a process block a GET command is issued on database illustrated in by arrow to retrieve data from database . In one embodiment the GET command may be invoked from interface layer via the MLAPI.

In one embodiment the GET command is passed set SO a destination address or pointer to a destination object to which database should return the data and one or more index values . The destination object may be set SO itself or some other object or file. Index value s passed into the GET command indicates to database which fields of all the objects stored in database it should inspect and attempt to match against the set fields of set SO . The set field value e.g. VALUE A operates as the key for searching database to find any SO stored therein having a field marked with an index value matching index value e.g. index 1 and having a corresponding field value matching field value VALUE A. Accordingly a user of database can query database using the data itself rather than using an extraneous or separate key. Furthermore even though multiple fields of set SO may be set with field values by selecting different index values corresponding to different fields a particular record e.g. serializable object stored in database can be searched for using a variety of different data as the key. Fields marked with the primary or secondary indexes provide search flexibility to the end user to query database based on a variety of different subsets of the data fields within set SO .

For example database may store phone records that include the following three fields a name field a phone number field and an address field. If the name fields are marked with index value 1 the phone number fields are marked with index value 2 and the address fields are marked with index value 3 then a user who wishes to determine the phone number associated with a particular name would set the first field with the name and pass the set SO to the GET command. Since the name field is marked with an index value 1 index value would be passed as a 1 into the GET command. Of course the user could also set the address field and or phone number field pass the set SO to the GET command and retrieve the corresponding name.

Returning to in a process block the one or more set fields marked with index value s is are converted to flat contiguous memory structure s by database CV . As illustrated serializable objects that exist outside of database may exist as link memory structures which are serialized into flat contiguous memory structures prior to passing into database . Although DB CV is illustrated as external to database it should be appreciated that DB CV may in fact be an internal component to database . Once passed into database by the GET command a query is executed to determine whether a matching record index value field value pair exists decision block . If such a record is not found then an empty set null or void response is returned to the destination object in a process block . If such a record is found then process continues to a process block .

In process block the matching record or records is converted from a flat contiguous memory structure into a more complex linked memory structure by DB CV and returned to the destination object illustrated as set SO in . Finally in a process block the data from the matching record is written into the destination object to populate the empty fields of set SO with field values from the matching record stored in database .

In one embodiment SO may be written into database by invoking the CREATE command published by the MLAPI into interface layer . In this embodiment the CREATE command may be passed SO and one or more index values to identify which fields are to be written into database . In this manner a subset of the data or fields within SO may be written into database .

In accordance with architecture aspects of some embodiments the aforementioned functions may be facilitated by various processing and storage resources hosted by associated line cards and the like which are mounted in a common chassis. As shown in from a datapath perspective the hardware architecture of one embodiment of network service node can be decomposed into three entities Traffic Blades TB Compute Blades CB and the chassis . A TB can be further reduced to its physical and link layer portions and network layer components and infrastructure components . Similarly a CB provides Service Layer termination and infrastructure components . In one embodiment a CB can be further re defined to be an OAMP Blade based on its slot index within chassis . OAMP blades are a functional superset of CBs adding operations administration maintenance and provisioning functionality collectively referred to as OAMP card function or OAMP CF .

As illustrated in the embodiments herein chassis comprises an Advanced Telecommunication and Computing Architecture ATCA or AdvancedTCA chassis. The ATCA Chassis provides physical connectivity between the blades via a passive backplane including a full mesh interconnect . It is noted that the ATCA environment depicted herein is merely illustrative of one modular board environment in which the principles and teachings of the embodiments of the invention described herein may be applied. In general similar configurations may be deployed for other standardized and proprietary board environments including but not limited to blade server environments.

The ATCA 3.0 base specification approved Dec. 30 2002 which is being carried out by the PCI Industrial Computer Manufacturers Group PICMG defines the physical and electrical characteristics of an off the shelf modular chassis based on switch fabric connections between hot swappable blades. As used herein the terms board blade and card are interchangeable. This specification defines the frame rack and shelf chassis form factors core backplane fabric connectivity power cooling management interfaces and the electromechanical specification of the ATCA compliant boards. The electromechanical specification is based on the existing IEC60297 EuroCard form factor and enables equipment from different vendors to be incorporated in a modular fashion with guaranteed interoperability. The ATCA 3.0 base specification also defines a power budget of 200 Watts W per board enabling high performance servers with multi processor architectures and multi gigabytes of on board memory.

In addition to power input to ATCA boards mating connectors on the boards and backplane are employed for coupling input output I O signals. Many of the ATCA boards as well as other modular boards used for telecommunications and computer such as but not limited to CompactPCI employ very high speed I O channels. For example Advanced Switching AS employs a serial communication channel operating at Gigahertz frequencies. ATCA boards may also provide one or more I O ports on their front panels enabling an ATCA board to be coupled to other network resources.

An exemplary architecture for a compute blade is shown in . In one embodiment a single compute blade physical architecture is employed for both Compute Blades and OAMP CF s. More particularly under architecture a corresponding blade may be deployed to support both Compute Blade and OAMP functionality.

Compute Blade employs four multiple processor compute nodes . In general each of compute nodes functions as multiple processor resources with each processor resource being associated with a logical processor. Accordingly such processor resources may be implemented using separate processors or processor chips employing multiple processor cores. For example in the illustrated embodiment of each of compute nodes is implemented via an associated symmetric multi core processor. Exemplary multi core processors that may be implemented include but are not limited to Broadcom and devices. Each of the compute nodes is enabled to communicate with other compute nodes via an appropriate interface e.g. bus or serial based interfaces . For the Broadcom and devices this interface comprises a Hyper Transport HT interface. Other native standard or proprietary interfaces between processors may also be employed.

As further depicted in architecture each compute nodes is allocated various memory resources including respective RAM . Under various implementations each of compute nodes may also be allocated an external cache or may provide one or more levels of cache on chip. In one embodiment the RAM comprises ECC Error Correction Code RAM. In one embodiment each compute node employs a NUMA Non Uniform Memory Access cache coherency scheme. Other cache coherency schemes such as MESI Modified Exclusive Shared Invalidated may also be implemented for other embodiments.

Each Compute Blade includes a means for interfacing with ATCA mesh interconnect . In the illustrated embodiment of this is facilitated by a Backplane Fabric Switch . Meanwhile a field programmable gate array FPGA containing appropriate programmed logic is used as an intermediary component to enable each of compute nodes to access backplane fabric switch using native interfaces for each of the compute nodes and the fabric switch. In the illustrated embodiment the interface between each of compute nodes and the FPGA comprises an SPI System Packet Interface 4.2 interface while the interface between the FPGA and backplane fabric switch comprises a Broadcom HiGig interface. It is noted that these interfaces are merely exemplary and that other interface may be employed depending on the native interfaces of the various blade components.

In addition to local RAM e.g. RAM the compute node associated with the OAMP function depicted in as Compute Node is provided with local SRAM and a non volatile store depicted as Compact flash . The non volatile store is used to store persistent data used for the OAMP function such as provisioning information and logs. In Compute Blades that do not support the OAMP function each compute node is provided with local RAM and a local cache.

In the embodiment illustrated in compute blade is provisioned as an OAMP blade. In one configuration as shown one of the compute nodes is employed for performing OAMP functions e.g. compute node while the other three compute nodes e.g. compute nodes perform normal compute functions associated with compute blades as described in further detail below. When a compute blade is provisioned as a compute blade each of compute nodes is available for performing the compute functions described herein.

PHY block and Ethernet MAC block respectively perform layer Physical and layer Data Link functions which are well known in the art. In general the PHY and Ethernet MAC functions may be implemented in hardware via separate components or a single component or may be implemented in a combination of hardware and software via an embedded processor or the like.

One of the operations performed by a traffic blade is packet identification classification. As discussed above a multi level classification hierarchy scheme is implemented for this purpose. Typically a first level of classification such as a 5 Tuple signature classification scheme is performed by the traffic blade s NPU . Additional classification operations in the classification hierarchy may be required to fully classify a packet e.g. identify an application flow type . In general these higher level classification operations may be performed by the traffic blade s host processor and or a processor on a compute blade depending on the particular classification.

NPU includes various interfaces for communicating with other board components. These include an Ethernet MAC interface a memory controller not shown to access RAM Ethernet and PCI interfaces to communicate with host processor and an XGMII interface. SERDES interface provides the interface between XGMII interface signals and HiGig signals thus enabling NPU to communicate with backplane fabric switch . NPU may also provide additional interfaces to interface with other components such as an SRAM Static Random Access Memory interface unit to interface with off chip SRAM both not shown .

Similarly host processor includes various interfaces for communicating with other board components. These include the aforementioned Ethernet and PCI interfaces to communicate with NPU a memory controller on chip or off chip not shown to access RAM and a pair of SPI 4.2 interfaces. FPGA is employed to as an interface between the SPI 4.2 interface signals and the HiGig interface signals.

Typically NPUs are designed for performing particular tasks in a very efficient manner. These tasks include packet forwarding and packet classification among other tasks related to packet processing. To support such functionality NPU executes corresponding NPU software . This software is shown in dashed outline to indicate that the software may be stored persist on a given traffic blade e.g. in a flash device or the like or may be downloaded from an external to the traffic blade store during initialization operations as described below. During run time execution NPU software is loaded into internal SRAM provided by NPU .

Host processor is employed for various purposes including lower level in the hierarchy packet classification gathering and correlation of flow statistics and application of traffic profiles. Host processor may also be employed for other purposes. In general host processor will comprise a general purpose processor or the like and may include one or more compute cores as illustrated in one embodiment a two core processor is used . As with NPU the functionality performed by host processor is effected via execution of corresponding software e.g. machine code and or virtual machine byte code which is depicted as host software . As before this software may already reside on a traffic blade or be loaded during blade initialization.

In one embodiment host processor is responsible for initializing and configuring NPU . Under one initialization scheme host processor performs network booting via the DHCP or BOOTP protocol. During the network boot process an operating system is loaded into RAM and is booted. The host processor then configures and initializes NPU via the PCI interface. Once initialized NPU may execute NPU software on a run time basis without the need or use of an operating system.

The processes explained above are described in terms of computer software and hardware. The techniques described may constitute machine executable instructions embodied within a machine e.g. computer readable medium that when executed by a machine will cause the machine to perform the operations described. Additionally the processes may be embodied within hardware such as an application specific integrated circuit ASIC or the like.

A machine accessible medium includes any mechanism that provides i.e. stores information in a form accessible by a machine e.g. a computer network device personal digital assistant manufacturing tool any device with a set of one or more processors etc. . For example a machine accessible medium includes recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. .

The above description of illustrated embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various modifications are possible within the scope of the invention as those skilled in the relevant art will recognize.

These modifications can be made to the invention in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification. Rather the scope of the invention is to be determined entirely by the following claims which are to be construed in accordance with established doctrines of claim interpretation.

