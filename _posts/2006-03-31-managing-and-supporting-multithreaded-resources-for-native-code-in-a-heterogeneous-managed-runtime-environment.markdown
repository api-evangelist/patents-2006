---

title: Managing and supporting multithreaded resources for native code in a heterogeneous managed runtime environment
abstract: A computer implemented method and apparatus to manage multithread resources in a multiple instruction set architectures environment comprising initializing a first thread from a first context. The initialization of the first thread is suspended at a position in response to an operating system request call to create the first thread. A second thread from a host environment is created based on the position. After the second thread is created, completion of the initialization of the first thread based on the position is then performed. Other embodiments are described in the claims.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08087018&OS=08087018&RS=08087018
owner: Intel Corporation
number: 08087018
owner_city: Santa Clara
owner_country: US
publication_date: 20060331
---
The present application is a National Phase Application of International Application No. PCT CN2006 000580 filed Mar. 31 2006 and claims priority from that PCT application.

The embodiments of the invention relate to multithreaded programming and thread resource managements.

Multithreading is a common programming techniques often used to maximize the efficiency of computer programs by providing a tool to permit concurrency or multitasking. Threads are ways for a computer program to be divided into multiple and distinct sequences of programming instructions where each sequence is treated as a single task. By assigning different tasks to multiple threads programmers can design a program in a way that multiple tasks are executed concurrently.

One of the essential functions of a thread is to manage resources used by a task. A particular portion of resource such as a system memory e.g. random access memory RAM may be shared between multiple threads or used only by a single thread. Generally allocation of resources by a requesting thread is required. Managing the particular portion of resource allocated by the requesting thread is referred to as the per thread context management. For example allocating and releasing the resources specifically used by a thread.

Another programming technique often used to enhance software development is to maximize program reuse and to minimize program rewrite. Conventionally a program designed to be executed on specific operating systems e.g. Windows 98 IA 32 etc. must be rewritten or at least encapsulated if the program is to be executed on a different platform. Programming language such as Java has attempted to introduce and deliver a write once and deploy anywhere mechanism. For example the Java virtual machine is a platform that creates a virtual environment and enables programming code such as Java to be executed independent of the underlying hardware e.g. Itanium SPARC PA RISC etc. Programming code that may be executed independent of the underlying hardware may be referred to as the platform independent code.

A conventional method to permit the execution of platform independent code on any hardware platform may require a translator. The translator translates the platform independent code to a native code understood by the specific platform. For example in a managed runtime environment that supports platform independent managed code such as Java bye code a Java virtual machine may be used to translate the Java byte code to platform specific code. In this case the Java virtual machine is a binary translator that translates the Java byte code to platform specific code.

Managing multiple threads in a platform independent code can be challenging. Traditionally each thread is created and managed by underlying supporting libraries. For example a thread written in C programming language is created and managed by the standard C library or the standard thread library. The underlying supporting library allocates resources such as stack frame saved register status control words and per thread local resource.

Conventionally a thread is created by the following procedure. First a parent thread calls a routine e.g. CreateThread to create a child thread. CreateThread can be an application programming interface API defined in a thread library. When the thread library receives this function call the thread library allocates resources such as the ones described above for the new child thread. Subsequent to the allocation of child thread resources the thread library sends a request to an operating system and requests a creation of the new child thread. This may be necessary because while the thread library may manage per thread context the operating system may manage the multiple threads operations. For example the operating system manages the intercommunication between multiple threads.

After the operating system has successfully created the new child thread the thread library will complete the new thread initialization by associating the resources of a parent thread with the newly created child thread. The parent thread is referred to as the portion of the programming code that initiates the child thread creation. While the child thread may freely use the allocated resources the parent thread needs to maintain an access to the child thread. This may be done by providing or retaining an access to the child thread from the parent thread and associating the resource allocated for the child thread with the parent thread.

After the child thread has completed its task the thread is usually terminated and the resources are returned to a resource pool so other threads may use the resource. An API call to the thread library e.g. TerminateThread could initiate the termination process. When TerminateThread is called the thread library would de allocate the resources that were allocated during the thread initialization process. Subsequent to the de allocation of thread resource the thread library sends a notification to the operation system and notifies an exit or termination of the child thread.

When executing threads on a different platform the platform may be equipped with different underlying supporting libraries and may not support the native thread code. As a result a child native thread may not have been created and initialized properly. For example a thread that has not been initialized due to lack of proper underlying supporting libraries may not be able to access its local variable because data structures and memory of this local variable have not yet been properly allocated.

Another challenge in program reuse may occur when porting existing program from a slower processor environment e.g. a 32 bit program to a faster processor environment e.g. a 64 bit platform . In this situation the 32 bit program is conventionally executed on an instruction set architecture ISA that supports 32 bit program e.g. ISA 32. On the other hand the faster processor environment may support only ISA 64 specific programming code. When attempting to execute the 32 bit program on a 64 bit platform a mix ISA Execution MIE has occurred.

A multithreaded program including a mixture of thread codes such as the platform independent thread code e.g. Java byte code and native thread code e.g. C may be ported and transferred to a new platform that may not support the native thread code. Conventionally when a multithreaded program including a mixture of code is ported to a new platform a dynamic binary translator may be used to translate the entire program including the platform independent code such that the ported program may be executed on the new platform. However translating the entire program may cause the program to be inefficient. Instead the problem is how to manage and support per thread context wherein the native thread code may be transparently initiated and created in the new platform.

One embodiment of the invention includes a method to initialize a native thread code from a new platform and suspend the initialization of the native code at a position where it can later be associated with a new thread created in the new platform.

One embodiment of the invention includes a method to create a new thread from a new platform and associate the resource allocated for a native thread with the new thread created in the new platform.

An advantage of the embodied solutions is that a multithreaded program including a mixture of platform independent code and native thread code may be executed on a new platform without rewriting the program.

A method and apparatus for managing and supporting threads in multiple instruction set architectures ISA is described below. A person of ordinary skill in the pertinent art upon reading the present disclosure will recognize that various novel aspects and features of the present invention can implemented independently or in any suitable combination and further that the disclosed embodiments are merely illustrative and not meant to be limiting.

The multithreaded program that includes the foreign thread code may be transferred and ported to be executed on a host platform . In the example depicted in the multithreaded program may be encapsulated with platform independent code wherein the encapsulating code or the platform independent code is supported by the underlying host platform . In this example the platform independent code may include the foreign thread code which may be identical to the foreign thread code . For the purpose of illustration only a foreign thread code is discussed. It may be appreciated that since the multithreaded program may also be transferred and executed on the host platform without encapsulation of platform independent code the following discussions apply to the multithreaded program as well.

The foreign thread code may be designed with an expectation that the foreign thread code is supported by a foreign platform . A portion of the foreign code may use other libraries and thread libraries . Furthermore foreign platform may also include an operating system and a foreign instruction set architecture ISA that is understood by a foreign processor . An ISA is a specification of a set of all binary codes also known as the opcodes or machine language that are commands in native forms to be understood by a particular computer processing unit CPU . For example the Intel 64 bit processor such as the Itanium Processor Family IPF and Extended Memory Technology EM64T processors may be designed with a particular ISA. The ISA supporting the Intel 64 bit processor may be referred to as ISA 64 and the ISA supporting the Intel 32 bit processor may be referred to as ISA 32.

The other libraries may be any library that are used by the foreign thread code . For example if part of the foreign thread code requires a sorting of a data structure the other libraries may include a sort library. If part of the foreign thread code requires mathematically computation the other libraries may include a math library.

After the foreign thread code is transferred to the host platform the foreign thread code may have to rely on the other libraries to support the specific library function calls as discussed above. In addition the foreign thread code may also rely on thread libraries for proper thread initialization creation and termination. For example the thread libraries may be a foreign thread library that is capable of managing and supporting the foreign thread code .

Furthermore the host platform may also include an operating system a host ISA and a host processor . An example of the foreign processor and the foreign ISA may be the Intel 32 bit processor supporting ISA 32. An example of the host processor and host ISA may be the Intel IPF supporting ISA 64. An example of the thread libraries may be the IA 32 library that supports the ISA 32 program or thread code e.g. foreign thread code . An example of the thread libraries may also be the IA 32 library that supports the foreign thread code .

In one embodiment of the invention the foreign thread code may be included in a platform independent code to ensure that the transferred code may be properly executed on the operating system the host ISA and the host processor . For example a Java application may contain foreign native code wherein the Java application is supported by the operating system while the operating system does not support the foreign native code contained within the Java application. It can be appreciated that a virtual machine not shown in the figure may be used in addition to the operating system to ensure the operability of the Java application.

In an embodiment of the invention a dynamic binary translator may be used to ensure the program portability to a host platform . Similar to the configuration described in a platform independent code may encapsulate a foreign thread code . The foreign thread code is translated by the dynamic binary translator to a host native code . The host native code may then be executed by the host platform and supported by the underlying components such as other libraries the thread libraries an operating system a host ISA and a host processor . Here the thread libraries may be a foreign thread library capable of managing and supporting the foreign thread code .

An embodiment of the invention may define a minimum set of APIs in the API to be used for communication between the multithreaded programming code and the dynamic binary translator . For example mie init translator and mie unload translator may be defined in the API to initialize and release the dynamic binary translator . In addition API calls such as mie thread init mie complete thread init and mie thread term may be defined in the API to initialize new threads complete the thread initialization and terminate the threads. Thread creation and termination function calls such as mie thread init mie complete thread init and mie thread terms may be called through the API into the dynamic binary translator and the middle tier layer .

In an embodiment of the invention an operating system request may be sent to the dynamic binary translator . Upon receiving the operating system request by an operating system wrapper the operating system request may be suspended. The operating system request may be initiated by the multithreaded programming code to request a creation of a new thread. When the operating system wrapper detects the request to create a new thread instead of passing the operating system requests down to an operating system the operating system wrapper may suspend the operating system request and handle the thread creation function call later. The suspension may be needed because the new thread may require translation from a foreign code to a code supported by a host platform.

Subsequent to the resources allocation performed by the foreign thread library the parent thread may initiate an operating system request and request a host operating system to create a new thread. However since the foreign thread may not have been properly initialized in a host environment an operating system wrapper may be used to intercept the operating system requests and suspend the operating system request until the proper initialization is performed.

In one embodiment of the invention the parent thread may call CreateThread to create a new thread in the host environment . This function call may be received by a host thread library . Similar to the process of initializing the foreign thread as discussed above the host thread library may begin resource allocations for the new thread. Subsequently an operating system request may be requested by the parent thread to the host operating system to create the new child in operation . Since this thread is initialized by the host thread library the initialization and the allocation of the resources is assumed to be properly performed. Therefore a child thread may be immediately created by the host operating system .

After the child thread is properly created the parent thread may call mie complete thread init PARENT in operation . This function call may be executed to associate the parent thread and the resource allocated for the foreign thread. A flag PARENT may be provided to indicate that the thread completion is to be performed in the context of the parent thread . In essence this function call may be executed to complete the foreign thread resource initialization. In one embodiment of the invention the operating system request is then processed at this point to complete the foreign thread creation in the parent thread context.

A similar process is performed for the child thread to associate the resources allocated for the foreign thread and the child thread . As discussed above the child thread is created as the result of the CreateThread . In an embodiment of the invention the child thread calls mie complete thread init CHILD in operation . It is the same function call as the one with respect to associating the parent thread and the foreign thread resources. In this situation a flag CHILD may be provided to indicate that the thread completion is to be performed in the context of the child thread . The operating system wrapper may provide the starting point wherein the completion process may begin. As a result the thread completion process associates the resources allocated for the foreign thread and the child thread .

An application that may use these operations is a migration and reuse of a 32 bit application such as the IA 32 library to a new 64 bit Itanium Processor Family IPF platform. In this situation a 64 bit multithread program may need to call a native code encapsulated in the IA 32 library. Therefore the IA 32 library is treated as the foreign thread code for the purpose of this discussion.

In this example the 64 bit multithread program calls an IPF operating system to create an IA 32 thread. Initially the program calls mie thread init to notify the middle tier layer . In mie thread init resource is allocated for the IA 32 thread. Subsequently the program sends an operating system request to create the IA 32 thread. This request is intercepted by the operating system wrapper and the mie thread init call is returned to the middle tier layer at this point. This point of suspension may be referred to as the clone point.

After the function call mie thread init is executed the program calls another function call to create a thread in the host environment . In this example the program calls CreateThread directly to the IPF to create an IPF thread. In the host environment the IPF thread may be properly initiated and created.

To associate the IA 32 thread and the IPF thread the program calls mie complete thread init PARENT . In this function the parent IPF thread completes its thread initialization by creating the IA 32 thread beginning from the clone point. Furthermore the child IPF thread also complete its thread initialization by calling mie complete thread init CHILD . In this function the IA 32 thread is translated and the resource context also begins from the clone point until the execution returns at the middle tier layer .

Subsequently the thread code may call a function to terminate the child thread created in the host environment . For example the thread code may call TerminateThread and the function call may be received by a host thread library . In responds to this function call the host thread library may de allocate the thread resources allocated for the child thread . In addition the host thread library may send a notification of thread termination to a host operating system . In responds to the notification of thread termination the host operating system may mark the child thread as to have exited the code.

Operation records a position Position A when the suspension occurs. This position may be used to associate the resource allocated for the foreign child thread with a thread created in a host environment. In operation a host child thread is created. In one embodiment of the invention creating the host child thread may involve at least a two step process. First resources may be allocated for the host child thread in the host environment. For example in operation a thread initialization request may be sent to a host thread library and request an allocation of the resource operation . Second an operating system request may be sent to a host operating system in requesting a creation of the host child thread operation .

Subsequent a successful completion of host child thread creation the operating system returns thread information to a calling code in operation . In operation the foreign child thread initialization process is completed starting from Position A from operation . In operation the host child thread initialization process is completed also starting from Position A from operation .

An example of a pseudo code according to an embodiment of the invention in which the method to construct an additional dependency graph may be implemented is provided below.

One embodiment of the invention may be implemented on a machine readable medium. A machine readable medium may include any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer not limited to Compact Disc Read Only Memory CD ROMs Read Only Memory ROMs Random Access Memory RAM Erasable Programmable Read Only Memory EPROM and a transmission over the Internet.

Although the invention has been described in detail hereinabove it should be appreciated that many variations and or modifications and or alternative embodiments of the basic inventive concepts taught herein that may appear to those skilled in the pertinent art will still fall within the spirit and scope of the present invention as defined in the appended claims. For example although the invention has been described to manage foreign thread resources between IA 32 threads and IPF platform those skilled in the pertinent art may use the embodiments disclosed herein on different host and foreign ISA system e.g. PA RISC with IPF IA 32 with PA RISC etc.

