---

title: Methods of processing graphics data including reading and writing buffers
abstract: Apparatuses and methods for detecting position conflicts during fragment processing are described. Prior to executing a program on a fragment, a conflict detection unit, within a fragment processor checks if there is a position conflict indicating a RAW (read after write) hazard may exist. A RAW hazard exists when there is a pending write to a destination location that source data will be read from during execution of the program. When the fragment enters a processing pipeline, each destination location that may be written during the processing of the fragment is entered in conflict detection unit. During processing, the conflict detection unit is updated when a pending write to a destination location is completed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07683905&OS=07683905&RS=07683905
owner: NVIDIA Corporation
number: 07683905
owner_city: Santa Clara
owner_country: US
publication_date: 20060726
---
This application is a continuation of co pending U.S. patent application Ser. No. 10 736 437 filed Dec. 15 2003 now U.S. Pat. No. 7 139 003. Each of the aforementioned related patent applications is herein incorporated by reference.

One or more aspects of the invention generally relate to processing graphics data in a programmable graphics processor and more particularly to writing and reading graphics data associated with a buffer.

Current graphics data processing is exemplified by systems and methods developed to perform a specific operation on several graphics data elements e.g. linear interpolation tessellation texture mapping depth testing. Traditionally graphics processing systems were implemented as fixed function computation units and more recently the computation units are programmable to perform a limited set of operations. Computation units are connected in a shading pipeline to perform shading operations. The shading pipeline includes a texture read interface for reading texture data from graphics memory and a write interface for writing graphics data including texture data to graphics memory. When the texture data is being written to a buffer stored in graphics memory the buffer may not be read from by the texture read interface until the shading pipeline has been flushed. The shading pipeline is flushed to assure that any pending writes to the buffer are completed before the texture data is read from the buffer by the shading pipeline. Processing throughput of the shading pipeline is reduced whenever a flush instruction is executed.

For the foregoing reasons it is desirable to write to a buffer and read from the buffer without flushing the shading pipeline between the write and read.

Various embodiments of the invention include an application programming interface for a programmable graphics processor. The application programming interface includes one or more program instruction to configure a fragment processor within the programmable graphics processor to detect a position conflict for a position and prevent a subsequent access of the position until the position conflict is resolved.

Various embodiments of a method of the invention include processing fragment program instructions. A pixel load instruction including a source address corresponding to a location within the buffer is received. A write to the source address is determined to be pending. Data stored in the location corresponding to the source address is read after the write to the source address is complete.

Various embodiments of a method of the invention include a fragment program for processing fragment data in a fragment processing pipeline. The fragment program includes a fragment program instruction to write a destination location in a buffer and a fragment program instruction to read the destination location in the buffer without an intervening instruction to flush the fragment processing pipeline.

Various embodiments of the invention include a computer program product having a computer readable medium having computer program instructions recorded thereon. The computer program product includes a fragment program for execution by a fragment processing pipeline. The fragment program includes a fragment program instruction to write a position in a buffer and a fragment program instruction to read the position in the buffer without an intervening instruction to flush the fragment processing pipeline.

The current invention involves new systems and methods for processing graphics data elements using position conflict detection and avoidance in a programmable graphics processor.

Host computer communicates with Graphics Subsystem via System Interface and a Graphics Interface . Graphics Subsystem includes a Local Memory and a Programmable Graphics Processor . Programmable Graphics Processor uses memory to store graphics data and program instructions where graphics data is any data that is input to or output from computation units within Programmable Graphics Processor . Graphics memory is any memory used to store graphics data or program instructions to be executed by Programmable Graphics Processor . Graphics memory may include portions of Host Memory Local Memory directly coupled to Programmable Graphics Processor register files coupled to the computation units within Programmable Graphics Processor and the like.

In addition to Graphics Interface Programmable Graphics Processor includes a Graphics Processing Pipeline a Memory Controller and an Output Controller . Data and program instructions received at Graphics Interface can be passed to a Geometry Processor within Graphics Processing Pipeline or written to Local Memory through Memory Controller . Memory Controller includes read interfaces and write interfaces that each generate address and control signals to Local Memory storage resources and Graphics Interface . Storage resources may include register files caches FIFO first in first out memories and the like. In addition to communicating with Local Memory and Graphics Interface Memory Controller also communicates with Graphics Processing Pipeline and Output Controller through read and write interfaces in Graphics Processing Pipeline and a read interface in Output Controller . The read and write interfaces in Graphics Processing Pipeline and the read interface in Output Controller generate address and control signals to Memory Controller .

Within Graphics Processing Pipeline Geometry Processor and a programmable graphics fragment processing pipeline Fragment Processing Pipeline perform a variety of computational functions. Some of these functions are table lookup scalar and vector addition multiplication division coordinate system mapping calculation of vector normals tessellation calculation of derivatives interpolation and the like. Geometry Processor and Fragment Processing Pipeline are optionally configured such that data processing operations are performed in multiple passes through Graphics Processing Pipeline or in multiple passes through Fragment Processing Pipeline . Each pass through Programmable Graphics Processor Graphics Processing Pipeline or Fragment Processing Pipeline concludes with optional processing by a Raster Operation Unit . Data produced in a pass through Programmable Graphics Processor Graphics Processing Pipeline or Fragment Processing Pipeline may be written to a buffer in graphics memory to be read from during a subsequent pass.

Vertex programs are sequences of vertex program instructions compiled by Host Processor for execution within Geometry Processor and Rasterizer . Fragment programs are sequences of fragment program instructions compiled by Host Processor for execution within Fragment Processing Pipeline . Graphics Processing Pipeline receives a stream of program instructions vertex program instructions and fragment program instructions and data from Graphics Interface or Memory Controller and performs vector floating point operations or other processing operations using the data. The program instructions configure subunits within Geometry Processor Rasterizer and Fragment Processing Pipeline . The program instructions and data are stored in graphics memory. When a portion of Host Memory is used to store program instructions and data the portion of Host Memory can be uncached so as to increase performance of access by Programmable Graphics Processor . Alternatively configuration information is written to registers within Geometry Processor Rasterizer and Fragment Processing Pipeline using program instructions encoded with the data or the like.

Data processed by Geometry Processor and program instructions are passed from Geometry Processor to a Rasterizer . Rasterizer is a sampling unit that processes graphics primitives and generates sub primitive data such as pixel data or fragment data including coverage data. Coverage data indicates which sub pixel sample positions within a pixel are covered by a fragment formed by the intersection of the pixel and a primitive. Graphics primitives include geometry such as points lines triangles quadrilaterals meshes surfaces and the like. Rasterizer converts graphics primitives into sub primitive data performing scan conversion on the data processed by Geometry Processor . Rasterizer outputs fragment data and fragment program instructions to Fragment Processing Pipeline .

The fragment programs configure the Fragment Processing Pipeline to process fragment data by specifying computations and computation precision. A Fragment Processor optionally is configured by fragment program instructions such that fragment data processing operations are performed in multiple internal passes within Fragment Processor . Fragment Processor outputs processed fragment data and codewords generated from fragment program instructions to Raster Operation Unit . Raster Operation Unit includes a read interface and a write interface to Memory Controller through which Raster Operation Unit accesses data stored in one or more buffers in Local Memory or Host Memory . Raster Operation Unit optionally performs near and far plane clipping and raster operations such as stencil z test blending and the like using fragment data read from the one or more buffers in Local Memory or Host Memory at the x y position associated with the fragment data and the processed fragment data to produce output data. The output data from Raster Operation Unit is written back to Local Memory or Host Memory at the x y position associated with the output data.

In various embodiments Memory Controller Local Memory and Geometry Processor are configured such that data generated at various points along Graphics Processing Pipeline may be output via Raster Operation Unit and provided to Geometry Processor or Fragment Processor as input. The output data is represented in one or more formats as specified by the codewords. For example color data may be written as 16 32 64 or 128 bits per pixel fixed or floating point RGBA red green blue and alpha to be scanned out for display. As a specific example four 16 bit floating point components RGBA are combined forming 64 bits of color data for each fragment. The output data e.g. color depth and other parameters may be processed according to a fragment program and stored in a buffer in graphics memory to be used as a texture map e.g. shadow map height field stencil and the like by the fragment program. Alternatively color and depth output data may be written to a buffer and later read and processed by Raster Operation Unit to generate the final pixel data prior to being scanned out for display via Output Controller .

For example Fragment Processing Pipeline is configured by fragment program instructions to produce processed data and store the processed data in a buffer in Local Memory . The Fragment Processing Pipeline is configured by the fragment program instructions to read and further process the processed data. For example Fragment Processing Pipeline may be configured to implement a modified depth buffer algorithm e.g. sorting and maintaining more than one depth value for each pixel. A modified depth buffer algorithm may be used to implement correct transparency by rendering fragments in back to front order while applying transparency blending.

Conventionally a shading pipeline such as Fragment Processing Pipeline is flushed using a flush instruction prior to executing fragment program instructions that read the shadow map to avoid any read after write RAW conflicts. A RAW conflict exists when a write to an x y position within a buffer is pending when a read from the same x y position in the buffer is received. The RAW conflict is removed when the write to the x y position within the buffer is completed. In various embodiments of Fragment Processing Pipeline in accordance with one or more aspects of the present invention Fragment Processing Pipeline a flush is not needed between writing a buffer and reading the buffer as an input to a Fragment Processor as described further herein.

When processing is completed an Output of Graphics Subsystem is provided using Output Controller . Alternatively Host Processor reads the composited frame e.g. buffer stored in Local Memory through Memory Controller Graphics Interface and System Interface . Output Controller is optionally configured by opcodes received from Graphics Processing Pipeline via Memory Controller to deliver data to a display device network electronic control system other Computing System other Graphics Subsystem or the like.

Memory Controller outputs the buffer data and the additional fragment program instructions to Read Interface . Texture Unit outputs the buffer data processed fragment data and the additional fragment program instructions to a Fragment Processing Unit . Fragment Processing Unit processes the processed buffer data and processed fragment data as specified by the additional fragment program instructions and outputs shaded fragment data e.g. x y color depth configuration control other parameters to Raster Operation Unit . In some embodiments Fragment Processing Unit is configured to process at least two fragments in parallel. Likewise Conflict Detection Unit and Read Interface may also be configured to process at least two fragments in parallel. Raster Operation Unit optionally processes the shaded fragment data according to the configuration control. A Write Interface within Raster Operation Unit writes the optionally processed shaded fragment data to a buffer stored in Local Memory or Host Memory via Memory Controller . Write Interface also outputs write position information to Conflict Detection Unit to update the status of position conflicts as described further herein.

In step Conflict Detection Unit determines if a RAW position conflict exists for the position associated with the second fragment and if so in step Conflict Detection Unit locks processing of the second fragment. Locking a fragment prevents any processing of the fragment requiring source data that is not yet available due to a RAW position conflict. In step Raster Operation Unit writes the shaded first fragment to the position in the buffer stored in graphics memory. Step may be completed several even hundreds of clock cycles after step . Raster Operation Unit outputs the write position information to Fragment Processor confirming that the write is complete. In one embodiment the write is considered complete when the write request is output from Memory Controller to Local Memory or to Host Memory via Graphics Interface . In another embodiment the write is considered complete when the write request is output from Raster Operation Unit to Memory Controller . In step Fragment Processing Pipeline unlocks the second fragment and proceeds to step . In step Fragment Processor begins shading the second fragment as specified by the shader.

If in step Conflict Detection Unit determines a RAW position conflict does not exist for the position associated with the second fragment then in step Fragment Processor begins shading the second fragment as specified by the fragment program producing a shaded second fragment. In step Fragment Processor receives one or more additional fragments each fragment associated with a position for which a RAW position conflict does not exist. Fragment Processor shades the one or more additional fragments. In step Raster Operation Unit writes the shaded first fragment to the position in the buffer stored in graphics memory and outputs the write position information to Conflict Detection Unit confirming that the write is complete.

After shading the second fragment Fragment Processor outputs the shaded second fragment to Raster Operation Unit . The number of clock cycles from step to when the shaded second fragment is output by Fragment Processor to Raster Operation Unit may depend on the complexity of the shading program or the number of pipeline stages in Fragment Processor . In an alternate embodiment step is completed before step . In a further alternate embodiment Fragment Processing Pipeline does not receive the one or more additional fragments and step is omitted.

In step Fragment Processor begins shading the first fragment as specified by the fragment program producing a shaded first fragment several cycles or more later. The shaded first fragment is output to Raster Operation Unit . In step Fragment Processing Pipeline receives a second fragment associated with the position within the buffer. To produce a shaded second fragment the fragment program specifies reading the shaded first fragment as source data.

In step Conflict Detection Unit determines if a RAW position conflict exists for the position associated with the second fragment and if so then in step Conflict Detection Unit locks processing of the second fragment. In step Raster Operation Unit writes the shaded first fragment to the position in the buffer stored in graphics memory. Raster Operation Unit outputs the write position information to Conflict Detection Unit confirming that the write is complete. In step the position is removed from Conflict Detection Unit thereby updating the status of the position conflict.

In step Conflict Detection Unit unlocks the second fragment and in step Conflict Detection Unit determines if the fragment program specifies writing the shaded second fragment to the position within the buffer. If the fragment program specifies writing the shaded second fragment to the position within the buffer then in step the position is entered in Conflict Detection Unit and the second fragment is output to Fragment Processor . In step Fragment Processor begins shading the second fragment as specified by the fragment program producing a shaded second fragment several or more clock cycles later. The shaded second fragment is output by Fragment Processor to Raster Operation Unit .

If in step Conflict Detection Unit determines a RAW position conflict does not exist for the position associated with the second fragment then in step Conflict Detection Unit determines if the fragment program specifies writing the shaded second fragment to the position within the buffer. If the fragment program specifies writing the shaded second fragment to the position within the buffer then in step the position is entered in Conflict Detection Unit and the second fragment is output to Fragment Processor . In step Fragment Processor begins shading the second fragment as specified by the fragment program producing a shaded second fragment several or more clock cycles later. Steps and proceed as previously described in relation to and in step the first position is removed from Conflict Detection Unit .

If in step Conflict Detection Unit determines a RAW position conflict does not exist for the position associated with the second fragment then in step Conflict Detection Unit determines if the fragment program specifies writing the shaded second fragment to the position within the buffer. If the fragment program specifies writing the shaded second fragment to the position within the buffer then in step the position is entered in Conflict Detection Unit and the second fragment is output to Fragment Processor . In step Fragment Processor begins shading the second fragment as specified by the fragment program producing a shaded second fragment several or more clock cycles later. Steps and proceed as previously described. Steps and proceed as previously described in relation to and in step the first position is removed from Conflict Detection Unit .

In step Conflict Detection Unit determines if the write to the location in the buffer is still pending and if so in step Conflict Detection Unit waits for the write to the location in the buffer to be completed. When the write is no longer pending i.e. when the write is completed Conflict Detection Unit proceeds to step . In step if additional fragments or fragments remaining after at least a portion of the fragments are shaded in step are available for shading without position conflicts those additional fragments or fragments remaining are output by Conflict Detection Unit to Fragment Processor and are shaded by Fragment Processing Unit .

If in step the write to the location in the buffer is not pending Conflict Detection Unit proceeds to step . The write to the location in the buffer may be completed when either the shaded fragment data output by Fragment Processor to Raster Operation Unit in step is written or when other shaded fragment data produced using other fragments received prior to the fragments received in step is written to the location in the buffer.

In step Read Interface reads data stored in the location in the buffer. In step the fragment associated with the location in the buffer is shaded by Fragment Processing Unit as specified by the fragment program producing additional shaded fragment data. In step the additional shaded fragment data is output by Fragment Processor to Raster Operation Unit .

In step fragments are received by Fragment Processing Pipeline . In step the location in the buffer to be written by the first fragment is entered in Conflict Detection Unit CDU . The second fragment is also associated with the location in the buffer specifically the fragment program specifies using data read from the location source data to produce a shaded second fragment. Conflict Detection Unit determines that a write to the location in the buffer is pending and does not initiate reading the location in the buffer. Steps and are completed as previously described in relation to .

Following step or step Conflict Detection Unit proceeds to step . In step Raster Operation Unit outputs write position information to Conflict Detection Unit to update the status of the position conflict i.e. removing the location from Conflict Detection Unit . Steps and proceed as described in regard to .

Texture Unit outputs the texture map data processed fragment data and the additional program instructions to a Fragment Processing Unit . Fragment Processing Unit stores the buffer data in a Register to be used as source data. Fragment Processing Unit processes the processed map data and processed fragment data as specified by the additional fragment program instructions and outputs shaded fragment data e.g. x y color depth configuration control other parameters to Raster Operation Unit . Raster Operation Unit optionally processes the shaded fragment data according to the configuration control. A Write Interface within Raster Operation Unit writes the optionally processed shaded fragment data to a buffer stored in Local Memory or Host Memory via Memory Controller . Write Interface also outputs write position information to Conflict Detection Unit to update the status of position conflicts. Write Interface outputs the position information and processed shaded fragment data to Data Cache to update the entry.

The entry in Data Cache may have been allocated to store data associated with another location in which case Data Cache may store the processed shaded fragment data in the next available entry. In an alternate embodiment Write Interface does not output the processed shaded fragment data to Data Cache and Data Cache instead reads the processed shaded fragment data from the buffer. In another alternate embodiment the write position information includes a buffer identifier and Data Cache stores data for more than one buffer.

If in step Conflict Detection Unit determines there is not a position conflict then in step Conflict Detection Unit stores a destination location and outputs the fragment to Fragment Processor . A destination location may be an x y position an address corresponding to a memory location a register address or the like. The destination position is stored because there is an implied write for each fragment being processed. However a processed fragment may not be written to a destination position if the processed fragment fails a depth or stencil test as determined by Raster Operation Unit . In step Read Interface reads the source location in graphics memory to obtain buffer data and outputs the buffer data. If in step Conflict Detection Unit determines that the fragment program does not specify a read in step Conflict Detection Unit stores the position to be written destination location in Conflict Detection Unit and outputs the fragment to Fragment Processor .

In step Texture Unit outputs the fragment and any source data read from the source location in step to Fragment Processing Unit for processing as specified by the fragment program. In step Fragment Processing Unit outputs shaded data and configuration control to Raster Operation Unit . Raster Operation Unit processes the shaded data and Write Interface and optionally outputs the processed shaded data to Memory Controller with a write request to the destination location. Write Interface also outputs a write update to Conflict Detection Unit . The write update is output to Conflict Detection Unit even when the processed shaded data is not written to the destination location because it failed a depth or stencil test. In step Conflict Detection Unit unstores the position as described further herein.

If in step Conflict Detection Unit determines that the fragment program does not specify a read in step Conflict Detection Unit stores the position to be written destination location and outputs the fragment and destination location to Fragment Processor . In step Data Cache determines if any entry is associated with the destination location and if so in step Data Cache marks the entry associated with the destination location as dirty . If in step Data Cache determines no entries are associated with the destination location Data Cache proceeds to step .

In step Texture Unit outputs the fragment and any buffer data read in step or step to Fragment Processing Unit for processing as specified by the fragment program. In step Fragment Processing Unit outputs shaded data and configuration control to Raster Operation Unit . Raster Operation Unit processes the shaded data and Write Interface and optionally outputs the processed shaded data to Memory Controller with a write request to the destination location. Write Interface also outputs a write update to Conflict Detection Unit . In step Conflict Detection Unit unstores the position as described further herein. In step if the processed shaded data was output to Memory Controller in step Write Interface outputs the processed shaded data and destination location to Data Cache . Data Cache stores the processed shaded data in an entry associated with the destination location.

A Hash Function within Hash Unit receives a first portion of Input and outputs an index to a storage resource Storage . A storage resource may be a register file embedded RAM or the like. When the destination write request is asserted a second portion of Input is output by Hash Function to Storage . The second portion of Input is stored in an entry accessed using the index provided by Hash Function in a Storage . When the destination write request is asserted a Compare Unit outputs a signal on Output indicating that a position conflict does not exist.

When the destination write confirmation is received from Write Interface Input provides the destination write confirmation to Hash Function . Hash Function outputs an index to Storage and the entry corresponding to the index is cleared or otherwise marked as available.

When the source read request is asserted Storage outputs the data stored in the entry corresponding to the index to a Compare . Compare also receives the second portion of Input from Hash Function and compares it to the data output by Storage . When the second portion of Input is equal to the data output by Storage Compare outputs a signal on Output indicating that a position conflict exists. When the second portion of Input is not equal to the data output by Storage Compare outputs a signal indicating that a position conflict does not exist. When a position conflict exists Conflict Detection Unit blocks processing of the fragment until the position conflict does not exist i.e. a pending write to the source read position is completed.

In a first embodiment the first portion of Input is the position and the buffer identifier is the second portion of Input . In a second embodiment the first portion of Input is the buffer identifier and the second portion of Input is the position. In a third embodiment the first portion of Input is the buffer identifier and the position and the second portion of Input is a logic true. In the third embodiment Compare is omitted and Output is the output of Storage .

Storage has a limited number of entries that may vary from one embodiment to another. When all of the entries are allocated and a destination write request is received requiring an unused entry Hash Unit does not accept any new requests or confirmations on Input until an entry in Storage becomes available. In a highly parallel system capable of processing thousands of samples an embodiment of Conflict Detection Unit including Hash Unit may become an expensive solution because it requires storage of thousands of entries for optimal performance. An alternate embodiment relies on using coverage mask data to track pending writes for fragments being processed in Fragment Processor as described further herein.

A coverage mask may be stored for each tile the coverage mask representing pending writes for each pixel tile position within the tile. In some embodiments the coverage mask may represent pending writes for a group of pixel tile positions within the tile. In addition to a tile origin each tile may also have a unique tile number as an identifier. In some embodiments the tile number may be the same as the tile origin.

A storage resource Tile Lookup Unit receives the tile origin included in the x y position and outputs a corresponding tile number to a Control Unit . In an alternate embodiment the tile number equals the tile origin Tile Lookup Unit is omitted and the tile origin is received by Control Unit . When Tile Lookup Unit does not include an entry for each tile within an image or Display i.e. the tile resolution exceeds the number of entries in Tile Lookup Unit Tile Lookup Unit outputs a match signal indicating whether or not the tile origin matches the contents of an entry. When the match signal indicates the tile origin matches the contents of an entry Tile Lookup Unit also outputs a tile number corresponding to the entry e.g. entry address to Control Unit . In one embodiment Tile Lookup Unit is a content addressable memory CAM .

Control Unit outputs a write signal to Tile Lookup Unit to write an entry in Tile Lookup Unit effectively allocating an entry to a tile corresponding to the tile origin. Control Unit also outputs a signal Stall indicating whether or not Conflict Detection Unit may accept another Input as described further herein in relation to . Control Unit outputs read and write requests to a storage resource Tile Storage Unit . Tile Storage Unit stores coverage mask data for each of the tiles that are stored in Tile Lookup Unit . Tile Storage Unit receives the pixel position portion of Input from Control Unit when the match signal indicates the tile number matches an entry in Tile Lookup Unit . Tile Storage Unit outputs the coverage mask corresponding to the pixel position to Control Unit . Control Unit receives tile clear commands including a tile number from Write Interface and clears the entry in Tile Lookup Unit corresponding to the tile number and clears the coverage mask data stored in Tile Storage Unit associated with the tile number. Control Unit also writes coverage mask data to Tile Storage Unit to modify the coverage mask data and outputs commands to Fragment Processor as described further herein. In an alternate embodiment Tile Lookup Unit and Tile Storage Unit are combined in one storage resource.

Control Unit produces tokens that are output via Fragment Processor . The commands are determined based on the state of a tile the coverage mask data stored in Tile Storage Unit Input and the tile clear signal. The tile state for each tile may be stored in Tile Storage Unit and the tile state may be one of CLEARING EMPTY ACTIVE and FLUSH. In an alternate embodiment the tile state for each tile is stored in Tile Lookup Unit . The tile state for each tile is initialized to CLEARING.

When a first fragment including an x y position and coverage mask data is received by Conflict Detection Unit an entry in Tile Lookup Unit is allocated to track x y positions within the tile. The tile state for the tile is changed from CLEARING to ACTIVE. When a second fragment is received and the second fragment conflicts with the first fragment i.e. the second fragment requires source data read from the x y position of the first fragment the tile state is changed from ACTIVE to FLUSH and Control Unit within Conflict Detection Unit outputs a flush token to Read Interface . The flush token includes the tile number and the flush token is passed through Fragment Processor and returns to Control Unit within Conflict Detection Unit as a clear tile signal also including the tile number. The clear tile signal is returned by Raster Operation Unit after any writes preceding the flush token are written to memory via Raster Operation Unit . Control Unit changes the tile state for a tile from FLUSH to EMPTY when a clear tile signal including the tile number for the tile is received from Raster Operation Unit .

If in step Control Unit determines the tile state is not set to FLUSH then in step Control Unit determines if the tile state is set to ACTIVE. If the tile state is set to ACTIVE Control Unit proceeds to step . In step Control Unit compares the coverage mask data read from Tile Storage Unit with the coverage mask data received from Input . In step Control Unit determines if the comparison indicates there is any overlap and if so in step Control Unit sets the tile state to FLUSH and outputs a flush token to Fragment Processor .

In step following either step or step Control Unit waits for the tile state to become EMPTY and then proceeds to step . Control Unit asserts Stall while waiting for the tile state to become EMPTY thereby not accepting new data on Input . If in step Control Unit determines the tile state is not set to ACTIVE i.e. the tile state is set to EMPTY then in step Control Unit sets the tile state to ACTIVE writes the tile origin in the entry in Tile Lookup Unit if the tile origin has changed thereby allocating the entry to the tile origin and writes the coverage mask data received via Input into Tile Storage Unit . In step Control Unit determines if all of the tile entries in Tile Lookup Unit are allocated and the tile states are all set to ACTIVE i.e. if there isn t an EMPTY tile or a tile with a tile state of FLUSH. If in step Control Unit determines all of the tile entries are not allocated or all of the tile entries are allocated and at least one tile state is not set to ACTIVE Control Unit proceeds to step . Otherwise Control Unit proceeds to step .

In step Control Unit identifies the least recently used LRU entry in Tile Lookup Unit and outputs a flush token to Read Interface the flush token including the tile number corresponding to the LRU entry and proceeds to step . If in step Control Unit determines the comparison indicates there is not any overlap then in step Control Unit updates the coverage mask data stored in Tile Storage Unit by writing a combination e.g. bitwise OR of the coverage mask data read from Tile Storage Unit and the coverage mask data received via Input . In step Conflict Detection Unit passes the x y position to Read Interface for further processing.

An embodiment of Conflict Detection Unit configured to use coverage mask data to track pending writes for fragments may include fewer storage resources than an embodiment including Hash Unit . Furthermore the number of pixels represented by a tile may vary from one embodiment to another. Likewise the size of storage resources Tile Lookup Unit and Tile Storage Unit may be sized to store each tile within an image or Display or to store a small number of tiles. Increasing the size of the storage resources may reduce the number of clock cycles spent waiting for a tile to become available for allocation thereby improving fragment processing throughput of Fragment Processor .

In this embodiment of Conflict Detection Unit Control Unit generates and outputs an interlock token to Read Interface for every n quads received via Input . In one embodiment n is equal to 32. In other embodiments n may be greater than or less than 32. ITS Unit increments an issue timestamp whenever an interlock token is output. The interlock token passes through Fragment Processor to Raster Operation Unit and an acknowledgement ack is output by Write Interface within Raster Operation Unit when all of the reads and writes preceding the interlock token have been output by Memory Controller to Conflict Detection Unit . RTS Unit increments a retire timestamp whenever an ack is received via Write Interface . In one embodiment the issue timestamp and the retire timestamp are set to a predetermined value at initialization. All issue timestamp values in Tile Storage Unit are also set to the predetermined value at initialization.

In addition to coverage mask data Tile Storage Unit stores an issue timestamp value for each tile. Whenever an x y position is output by Control Unit to Fragment Processor the issue timestamp is copied into the entry in Tile Storage Unit corresponding to the tile number. The difference between the issue timestamp and the retire timestamp defines a timestamp TS window. When an issue timestamp value stored in Tile Storage Unit lies within the TS window a quad in the tile associated with the tile number is being processed by Fragment Processor or Raster Operation Unit . Conversely when an issue timestamp value stored in Tile Storage Unit lies outside of the TS window the tile number is available for allocation to an incoming quad with a tile origin that does not match an entry in Tile Lookup Unit .

In step Control Unit determines if the issue timestamp value read in step is within the TS window and if not Control Unit proceeds to step . If in step Control Unit determines the issue timestamp value read in step is within the TS window then in step Control Unit compares the coverage mask data read from the entry to the coverage mask received in step . In step Control Unit determines if the comparison indicates there is any overlap and if so in step Control Unit asserts Stall indicating that Conflict Detection Unit is not accepting new data on Input . In step Control Unit also signals to ITS Unit to increment the issue timestamp and outputs an interlock token via Fragment Processor .

In step Control Unit determines if the issue timestamp value read in step is still within the TS window and if so Control Unit remains in step while asserting Stall to indicate that Conflict Detection Unit is not accepting new data on Input . If in step Control Unit determines the issue timestamp value read in step is not within the TS window then Control Unit proceeds to step .

If in step Control Unit determines the match signal indicates that the tile origin does not match the contents of an entry in Tile Lookup Unit then in step Control Unit determines if an entry in Tile Lookup Unit is available for allocation. If an entry is available then Control Unit proceeds to step . Otherwise Control Unit proceeds to step and identifies the LRU available entry in Tile Lookup Unit signals to ITS Unit to increment the issue timestamp and outputs an interlock token to read Interface . In step Control Unit determines if an entry in Tile Lookup Unit is available for allocation and if not Control Unit remains in step while asserting Stall to indicate that Conflict Detection Unit is not accepting new data on Input . If in step Control Unit determines an entry in Tile Lookup Unit is available for allocation then Control Unit proceeds to step . In step Control Unit writes the tile origin received in step extracted from the x y position into the entry thereby allocating the entry to the tile origin. In step Control Unit writes the coverage mask received in step into the entry in Tile Storage Unit associated with the tile number of the entry in Tile Lookup Unit . In step Control Unit also copies the issue timestamp value into the entry in Tile Storage Unit associated with the tile number and proceeds to step .

If in step Control Unit determines the comparison indicates there is not any overlap then in step Control Unit combines the coverage mask data read from Tile Storage Unit in step with the coverage mask received in step to produce combined coverage mask data and writes the combined coverage mask data to the entry in Tile Storage Unit . In step Control Unit also copies the issue timestamp from ITS Unit to the entry in Tile Storage Unit . In step Conflict Detection Unit passes the x y position received in step to Fragment Processor for further processing.

In step Conflict Detection Unit receives a fragment program instruction specifying a write to a first destination location. The first destination location may be a register in Fragment Processor or a location in graphics memory within a buffer. The first destination location may also include a buffer identification. The buffer may include depth data color data stencil data or the like.

In step Conflict Detection Unit receives a PLD instruction including a source location and a second destination location. In one embodiment the source location is the first destination location and the second destination location is Register . In another embodiment the source location is another location within the buffer. In yet another embodiment the source location is another location within another buffer.

In step Conflict Detection Unit determines if a write to the source location is pending and if so Conflict Detection Unit remains in step waiting until the write to the source location is complete i.e. for the position conflict to be resolved. Execution of the PLD instruction eliminates the need for executing a flush instruction to drain Fragment Processing Pipeline prior to reading the source location.

If in step Conflict Detection Unit determines that a write to the source location is not pending in step Read Interface outputs a read request for the source location to Memory Controller and receives the data stored in the source location from Memory Controller . In an alternate embodiment Read Interface reads the data stored in the source location from Data Cache . In step Read Interface outputs the data stored in the source location to Fragment Processing Unit and Fragment Processing Unit stores the data in the destination location e.g. Register .

In an embodiment the source location specified in the PLD instruction is the first destination location specified in the fragment program instruction received in step . Execution of the PLD instruction in the embodiment permits reading the source location during processing of the additional fragment program instructions rather than draining Fragment Processor after the write to the first destination location and before executing the source read. Steps and are completed as previously described.

A subsequent fragment program instruction may only be permitted to bypass a pending fragment program instruction if the subsequent fragment program instruction does not have a data dependency on the pending fragment program instruction i.e. the subsequent fragment program instruction does not source data that is produced by the pending fragment program instruction. After executing the subsequent fragment program instruction Fragment Processor returns to step . In step Conflict Detection Unit determines if a write to the source location is still pending and if not steps and are completed as previously described to complete execution of the PLD instruction.

Embodiments of Conflict Detection Unit that permit fragment program instructions without position conflicts to bypass fragment program instructions with position conflicts include storage resources to store the fragment program instructions with position conflicts. Conflict Detection Unit outputs a stored fragment program instruction when the position conflict is removed for that fragment program instruction. Likewise some embodiments of Conflict Detection Unit include storage resources to store fragments associated with positions for which conflicts exist. When storage resources are not available Conflict Detection Unit blocks fragment processing until storage resources become available.

In step Fragment Processor is configured by fragment program instructions to compute the fragment depth value of a fragment for a position. In step Texture Unit reads a depth buffer value for the position. The read is performed using a PLD instruction i.e. Conflict Detection Unit detects any position conflicts and the read is not performed until any detected position conflicts are resolved. The depth buffer value read is stored in Register . In step Texture Unit outputs the depth buffer value and the fragment depth value to Fragment Processing Unit . Fragment Processing Unit is configured by the fragment program instructions to determine if the fragment depth value will be written to the depth buffer. For example in one embodiment the fragment will be written to the depth buffer when the fragment depth value is nearer to the viewpoint than the depth buffer value at the position. If in step Fragment Processing Unit determines the fragment depth value will be written to the depth buffer then in step Fragment Processing Unit is configured by the fragment program instructions to produce a computed fragment color.

In step Fragment Processor determines if the fragment program instructions specify to read a buffer such as a texture map to compute a shaded fragment color and if so the fragment is processed in an additional pass within Fragment Processor . In step Texture Unit is configured by the fragment program instructions to read buffer data from the buffer and output the buffer data to Fragment Processing Unit . In step Fragment Processing Unit is configured by the fragment program instructions to shade the fragment using the computed fragment color and the buffer data to produce a shaded fragment color. If in step Fragment Processor determines the fragment program instructions do not specify to read a buffer then the computed fragment color is the shaded fragment color and Fragment Processor proceeds to step .

In step Fragment Processor determines if blending is enabled and if not Fragment Processor proceeds to step . If in step Fragment Processor determines that blending is enabled then in step the shaded fragment color configuration control and fragment depth value are output by Fragment Processor to Raster Operation Unit . Raster Operation Unit reads a color from a buffer such as a color buffer for the position. In step Raster Operation Unit is configured by the fragment program instructions to blend the color read from the color buffer with the shaded fragment color to produce a blended color. In step Write Interface within Raster Operation Unit writes the blended color and the fragment depth value to the color buffer and the depth buffer respectively. In an alternate embodiment the color data and the depth data are stored in a buffer containing color and depth in each location within the buffer.

In step Fragment Processor determines if another fragment will be processed and if so returns to step . In step Fragment Processor is configured by fragment program instructions to compute the fragment depth value of another fragment for another position. In step Texture Unit reads a depth buffer value for the other position. The read is performed using the PLD instruction and the depth buffer value read is stored in Register . Because Fragment Processor is pipelined processing of the other fragment may begin before processing of the fragment is completed. Therefore the PLD instruction should be used to detect and avoid RAW position conflicts. When the PLD instruction is not used Fragment Processing Pipeline may be flushed using an instruction to assure processing of the other fragment does not begin until the processed fragment is output to graphics memory. Flushing should be minimized to effectively utilize computing resources within Fragment Processing Pipeline and to maximize fragment throughput.

In step Fragment Processing Unit receives the depth buffer value read in step and the fragment depth value computed in step . Fragment Processing Unit is configured by the fragment program instructions to determine if the fragment depth value will be written to the depth buffer. If in step Fragment Processing Unit determines the fragment depth value will not be written to the depth buffer then in step Fragment Processor determines if another fragment will be processed and if not in step Output Controller reads the color buffer for output to Output such as a display or the like. In an alternative embodiment the color buffer is output via either Graphics Interface or Output Controller to a film recording device or written to a peripheral device e.g. disk drive tape compact disk or the like.

At the end of the first additional pass through Graphics Processing Pipeline the second color buffer contains the image color for the first two layers of fragments. A second additional pass through Graphics Processing Pipeline may be completed storing a next front most depth in the first depth buffer and a blended color for the first three layers of fragments in the first color buffer. Likewise further additional passes through Graphics Processing Pipeline may be completed either reading from the first depth and color buffers and writing to the second depth and color buffers or reading from the second depth and color buffers and writing to the first depth and color buffers. The PLD instruction is used during depth peeling to improve fragment processing throughput so that Fragment Processing Pipeline does not need to be flushed between each pass to avoid position conflicts.

Steps and are completed as described in relation to . If in step Fragment Processing Unit determines the fragment depth value will be written to the depth buffer in step Fragment Processing Unit is configured by the fragment program instructions to produce a shaded fragment color. Step includes steps and shown in . In step Write Interface within Raster Operation Unit writes the shaded fragment color and the fragment depth value to the first color buffer and the first depth buffer respectively.

In step Fragment Processor determines if another fragment will be processed and if so returns to step . In step Fragment Processor is configured by fragment program instructions to compute the fragment depth value of another fragment for another position. In step Texture Unit reads a depth buffer value for the other position. In step Fragment Processing Unit receives the depth buffer value read in step and the fragment depth value computed in step . Fragment Processing Unit is configured by the fragment program instructions to determine if the fragment depth value will be written to the first depth buffer. If in step Fragment Processing Unit determines the fragment depth value will not be written to the first depth buffer then in step Fragment Processor determines if another fragment will be processed and if so Fragment Processor returns to step . If in step Fragment Processor determines another fragment will not be processed then in step Fragment Processor determines if this is the first pass through Graphics Processing Pipeline . If in step Fragment Processor determines this is the first pass through Graphics Processing Pipeline then in step Graphics Processing Pipeline determines if another pass through Graphics Processing Pipeline the first additional pass will be completed to determine the next front most fragment layer within the image. If in step Graphics Processing Pipeline determines another pass will be completed Fragment Processor returns to step . Prior to starting the first additional pass the second depth buffer is initialized to the furthest depth value to determine the next front most fragment layer which lies between the front most layer and the furthest depth value.

In step Fragment Processor is configured by fragment program instructions to compute the fragment depth value of a fragment for a position. In step Texture Unit reads depth buffer values for the position from the first depth buffer and the second depth buffer. The read of the second depth buffer the first depth buffer is read only for this pass is performed using the PLD instruction and the depth buffer value read next front most is optionally stored in Register . The depth buffer value read from the first depth buffer may also be stored in a register like Register within Fragment Processing Unit .

In step Fragment Processing Unit receives the front most depth buffer value read from the first depth buffer in step the next front most depth buffer value read from the second depth buffer in step and the fragment depth value computed in step . Fragment Processing Unit is configured by the fragment program instructions to determine if the fragment depth value will be written to the depth buffer. For example the fragment will be written to the depth buffer when the fragment depth value is nearer to the viewpoint than the next front most depth buffer value at the position and further from the viewpoint than the front most depth buffer value at the position. If in step Fragment Processing Unit determines the fragment depth value will be written to the second depth buffer then in step Fragment Processing Unit is configured by the fragment program instructions to produce a shaded fragment color.

In step the shaded fragment color and fragment depth value are output by Fragment Processor to Raster Operation Unit and Raster Operation Unit writes the shaded fragment color and fragment depth value to the second color buffer and the second depth buffer respectively. In an alternative embodiment in step Raster Operation Unit reads a color from the first color buffer for the position and Raster Operation Unit is configured by the fragment program instructions to blend the color read from the first color buffer with the shaded fragment color to produce a blended color. In the alternative embodiment Write Interface within Raster Operation Unit writes the blended color and the fragment depth value to the second color buffer and the second depth buffer respectively.

In step Fragment Processor determines if another fragment will be processed and if so returns to step . In step Fragment Processor is configured by fragment program instructions to compute the fragment depth value of another fragment for another position. In step Fragment Processing Unit receives the front most depth buffer value read from the first depth buffer in step the next front most depth buffer value read from the second depth buffer in step and the fragment depth value computed in step . The read of the second depth buffer is performed using the PLD instruction and the depth buffer value read next front most is stored in Register . The depth buffer value read from the first depth buffer may also be stored in a register like Register within Fragment Processing Unit . Fragment Processing Unit is configured by the fragment program instructions to determine if the fragment depth value will be written to the depth buffer. If in step Fragment Processing Unit determines the fragment depth value will not be written to the second depth buffer then in step Fragment Processor determines if another fragment will be processed. If in step Fragment Processor determines another fragment will not be processed then in step Fragment Processor determines if this is the first pass through Graphics Processing Pipeline .

If in step Fragment Processor determines this is not the first pass through Graphics Processing Pipeline then in step Fragment Processor blends the front most first color buffer with the next front most second color buffer and stores the blended color buffers in the second color buffer. In step Graphics Processing Pipeline determines if another pass will be completed to process the next front most layer of fragments in the image. If in step Graphics Processing Pipeline determines another pass will be completed then steps and are repeated with the second depth and color buffers containing the front most layers read only and writing the third layer to the first depth and color buffers.

If in step Graphics Processing Pipeline determines another pass through Graphics Processing Pipeline will not be completed then in step Output Controller reads the first or second color buffer whichever was written during the last pass for output to Output such as a display or the like. In an alternative embodiment the color buffer is output via either Graphics Interface or Output Controller to a film recording device or written to a peripheral device e.g. disk drive tape compact disk or the like.

In step Fragment Processor is configured by a fragment program to compute the fragment depth value of a fragment for a position. In step Texture Unit reads depth buffer values for the position from each depth buffer storing a layer of depth values for the image as specified by a fragment program. In step Fragment Processor determines if the layers need to be reordered. For example the layers need to be reordered if the fragment depth value is between the depth values in layer and the depth value in layer where layer is the front most layer. The fragment depth value in layer is moved to layer and the fragment depth value will be written to layer . If layer has not been used an output buffer identifier will be assigned to layer and each memory location in the layer depth buffer is initialized to the furthest depth value. Likewise each memory location in the layer color buffer is initialized to transparent black.

If in step Fragment Processor determines if the layers need to be reordered in step Fragment Processor determines the output buffer identifier associated with each depth value that is moved from one depth buffer layer to another depth buffer layer during reordering. Fragment Processor also determines the output buffer identifier associated with the fragment depth value. Likewise Fragment Processor determines the output buffer identifier associated with each color value that is moved from one color buffer to another color buffer during reordering.

If in step Fragment Processor determines the layers do not need to be reordered Fragment Processor proceeds to step . For example the layers do not need to be reordered if the fragment depth value is behind the depth value in layer and the depth value in layer where layer is the front most layer. The fragment depth value will be written to unused layer and an output buffer identifier will be assigned to layer . In step Fragment Processing Unit is configured by the fragment program to produce a shaded fragment color for the fragment.

In step Fragment Processing Unit outputs configuration control the fragment depth value depth buffer identifier shaded fragment color color buffer identifier and reordered data to Raster Operation Unit . In one embodiment the reordered data includes additional depth and color buffer identifiers corresponding to reordered layers of color and depth values. The additional depth buffer identifiers are used by Raster Operation Unit to read the depth buffer values reordered in step . Likewise the additional color buffer identifiers are used by Raster Operation Unit to read the color buffer values reordered in step . In another embodiment the reordered data includes reordered color values and color buffer identifiers and reordered depth values and depth buffer identifiers.

In step Raster Operation Unit writes the shaded fragment color to the color buffer corresponding to the color buffer identifier. Raster Operation Unit writes the fragment depth value to the depth buffer corresponding to the depth buffer identifier. Raster Operation Unit also writes each additional depth value reordered in step to each depth value s associated depth buffer corresponding to each depth value s color buffer identifier determined in step . Likewise Raster Operation Unit also writes each additional color value reordered in step to each color value s associated color buffer corresponding to each color value s color buffer identifier determined in step .

In step Fragment Processor determines if another fragment will be processed and if so steps and are repeated. If in step Fragment Processor determines another fragment will not be processed depth sorting and shading of all of the fragments in the image is complete. In step each color buffer containing a layer is read by Raster Operation Unit . In step each position in each color buffer is blended by Raster Operation Unit to produce a blended color buffer. In one embodiment the color buffers are read and the color values for each position are blended from a back to front order to produce a blended color value for each position. In another embodiment the color buffers are read and the color values for each position are blended from a front to back order to produce a blended color value for each position. In yet another embodiment Texture Unit reads the color buffers and Fragment Processing Unit blends the color values for each position and outputs a blended color value for each position to Raster Operation Unit .

In step Raster Operation Unit writes the blended color values to an output buffer color buffer . The output buffer may be one of the color buffers read in step . In step Output Controller reads the output buffer for output to Output such as a display or the like. In an alternative embodiment the output buffer is output via either Graphics Interface or Output Controller to a film recording device or written to a peripheral device e.g. disk drive tape compact disk or the like.

In further embodiments of methods of processing graphics data the PLD instruction may be used to perform frame buffer blending floating point raster operations dual depth shadow mapping and the like using Fragment Processing Pipeline .

Index Processor optionally reads processed data e.g. data written by Raster Operation Unit from graphics memory and outputs the data processed data and formatted commands to Programmable Graphics Processing Pipeline . Programmable Graphics Processing Pipeline and Raster Operation Unit each contain one or more programmable processing units to perform a variety of specialized functions. Some of these functions are table lookup scalar and vector addition multiplication division coordinate system mapping calculation of vector normals tessellation calculation of derivatives interpolation and the like. Programmable Graphics Processing Pipeline and Raster Operation Unit are each optionally configured such that data processing operations are performed in multiple passes through those units or in multiple passes within Programmable Graphics Processing Pipeline .

In one embodiment Programmable Graphics Processing Pipeline performs geometry computations rasterization and pixel computations. Therefore Programmable Graphics Processing Pipeline is programmed to operate on surface primitive vertex fragment pixel sample or any other data.

Execution Pipelines may receive first samples such as higher order surface data and tessellate the first samples to generate second samples such as vertices. Execution Pipelines may be configured to transform the second samples from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. Each Execution Pipeline communicates with Texture Unit using Read Interface to read program instructions and graphics data stored in buffers in graphics memory via Memory Controller . An optional Data Cache within Texture Unit is used to improve memory read performance by reducing read latency. In another alternate embodiment a Texture Unit is included in each Execution Pipeline . In yet another alternate embodiment program instructions are stored within Programmable Graphics Processing Pipeline .

Execution Pipelines output processed samples such as vertices that are stored in a Vertex Output Buffer in a register file FIFO memory cache or the like not shown . Processed vertices output by Vertex Output Buffer are received by a Primitive Assembly Setup . Primitive Assembly Setup calculates parameters such as deltas and slopes for rasterizing the processed vertices. Primitive Assembly Setup outputs parameters and samples such as vertices to Raster Unit . The Raster Unit performs scan conversion on samples and outputs fragments to a Pixel Input Buffer .

A graphics program vertex program or fragment program is executed within one or more Execution Pipelines as a plurality of threads where each vertex or fragment to be processed by the program is assigned to a thread. Although threads share processing resources within Programmable Graphics Processing Pipeline and graphics memory the execution of each thread proceeds in the one or more Execution Pipelines independent of any other threads. A RAW position conflict may exist when a fragment program specifies to write to a position in a buffer that the fragment program later specifies to read from. Likewise a RAW position conflict may exist when a fragment program specifies to write to a position in a buffer that a subsequent fragment program specifies to read from. Furthermore because threads are executed independently RAW conflicts may exist when a thread executes a write to a position in a buffer that the thread or another thread executes a read from.

In order to eliminate the need to track RAW conflicts between two or more Execution Pipelines each Execution Pipeline is configured to process fragments for at least one specific destination location. For example an Execution Pipeline is configured to process fragments corresponding to any destination location within a contiguous region e.g. x y position scanline tile or the like. In another example an Execution Pipeline is configured to process fragments corresponding to any destination location modulo n vertically and modulo m horizontally e.g. one x y position in each tile every mth x y position in a scanline and the like. Texture Unit includes Conflict Detection Unit to track pending destination write operations in order to detect and avoid RAW position conflicts. Alternatively each Execution Pipeline includes a Conflict Detection Unit . Furthermore if execution of a thread is blocked because of a RAW position conflict some embodiments may permit execution of one or more other threads that do not have position conflicts thereby improving throughput.

Pixel Input Buffer receives fragments from Raster Unit and outputs the fragments to each Execution Pipeline . The fragments output by Pixel Input Buffer are each processed as in Fragment Processing Unit by only one of the Execution Pipelines . Pixel Input Buffer determines which one of the Execution Pipelines to output each fragment to depending on a position e.g. x y associated with each sample. In this manner each fragment is output to the Execution Pipeline designated to process fragments associated with the position.

Each Execution Pipeline signals to Pixel Input Buffer when a fragment can be accepted or when a fragment cannot be accepted. Fragment program instructions associated with a thread configure at least one multithreaded processing unit within an Execution Pipeline to perform operations such as texture mapping shading blending and the like. Processed fragments are output from each Execution Pipeline to a Pixel Output Buffer . Pixel Output Buffer optionally stores the processed samples in a register file FIFO memory cache or the like not shown . The processed samples are output from Pixel Output Buffer to Raster Operation Unit .

Execution Pipelines are optionally configured using program instructions read by Texture Unit such that data processing operations are performed in multiple passes through at least one multithreaded processing unit within Execution Pipelines .

The invention has been described above with reference to specific embodiments. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. The listing of steps in method claims do not imply performing the steps in any particular order unless explicitly stated in the claim. Within the claims element lettering e.g. a b i ii etc. does not indicate any specific order for carrying out steps or other operations the lettering is included to simplify referring to those elements.

