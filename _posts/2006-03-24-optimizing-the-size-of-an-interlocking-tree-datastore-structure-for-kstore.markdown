---

title: Optimizing the size of an interlocking tree datastore structure for KStore
abstract: A method for optimizing the construction of a KStore includes providing a data set having a plurality of records with a plurality of fields, providing an optimization structure from a sample of the data set and analyzing the optimization structure to determine a field order for the records contained in the data set. A KStore is provided from the data set in accordance with the field order. The sample of the data set can include the entire data set, a random sample of the data set or a predetermined number of records from the data set. The data set has an initial order having earlier records and later records and the sample can include a plurality of the earlier records. The sample of the data set includes a user determined number of records from the data set. The optimization structure can be a KStore.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07689571&OS=07689571&RS=07689571
owner: Unisys Corporation
number: 07689571
owner_city: Blue Bell
owner_country: US
publication_date: 20060324
---
This invention relates to computing and in particular to the field of optimizing the building of KStore interlocking trees data structures.

The process of optimizing data structures and methods for accomplishing such is fairly common in the art. For example U.S. Pat. No. 6 141 655 entitled Method and apparatus for optimizing and structuring data by designing a cube forest data structure for hierarchically split cube forest template teaches a method to structure data that enables quick searching for particular aggregates and the compact storage of this data within a multidimensional database MDB . U.S. Pat. No. 6 470 335 entitled System and method for optimizing the structure and display of complex data filters teaches a system and method for optimizing the structure and visual display of complex data filters that are used to query a relational database.

U.S. Patent Application No. 20040103081 entitled Method and system for optimizing data searches in tree structures teaches a method for optimizing data searches in tree structures by organizing multiple search levels of data into sub trees contained in fixed size blocks of shared external memory of an embedded processing system and requiring each reference to the data to proceed from one half of a sub tree during a descent of the search tree based on a search pattern.

There are several limitations with the above methods of optimization and compression. While all of the examples deal with some form of data optimization they all relate to schemes useful in optimizing the structure of data and queries in traditional relational databases.

A method for optimizing the construction of a KStore includes providing a data set having a plurality of records with a plurality of fields providing an optimization structure from a sample of the data set and analyzing the optimization structure to determine a field order for the records contained in the data set. A KStore is provided from the data set in accordance with the field order. The sample of the data set can include the entire data set a random sample of the data set or a predetermined number of records from the data set. The data set has an initial order having earlier records and later records and the sample can include a plurality of the earlier records. The sample of the data set includes a user determined number of records from the data set. The optimization structure can be a KStore. The analyzing of the optimization structure includes obtaining analysis data from the optimization structure. The method includes querying the optimization structure to determine a number of record fields. The optimization structure is queried to determine a number of unique variables in a record field. A data structure is provided to contain the analysis data and the number of fields within a record in the data structure is recorded. The data structure can contain the analysis data a field name can be recorded in the data structure. A variable in the data structure is representative of a number of differing field values in a field. A plurality of variables is recorded in the data structure each variable of the plurality of variables being representative of a number of differing field values in a respective field of the plurality of fields.

Our solution overcomes the inherent limitations associated with the prior art of optimization through compression that use traditional relational databases by using a method that was specifically invented for use in KStore interlocking trees datastores.

We have developed a system and various methods for creating and using interlocking trees datastores and various features of said interlocking trees datastores. We refer to an instantiation of these interlocking trees datastores that we have developed as a KStore or just K . In particular these structures and methods have been described in patent applications U.S. Ser. Nos. 10 385 421 now published as US 20040181547 A1 and 10 666 382 by inventor Mazzagatti. Additionally we described a system in which such interlocking trees datastores could more effectively be used in U.S. Ser. No. 10 879 329. We hereby incorporate these referenced patent documents in their respective entireties into this patent by this reference. While the system and method we describe in this patent relate with particularity to the specific interlocking trees datastores which inventor Mazzagatti hereof described in the above referenced patent applications it should be readily apparent that the system and methods described herein may also be applicable to similar structures.

The invention described herein below relates to interlocking trees datastores having a structure that has been described in prior patent applications and may be readily used by and adapted to devices described in patent application Ser. No. 10 759 466 now published as 20050165749 and Ser. No. 10 879 329 which themselves are for use with such interlocking trees datastores which are hereby incorporated by this reference in their respective entireties.

As explained in the above mentioned patents a KStore data store may be built within the memory of a computer system or computer systems. Depending on the amount of data being loaded the KStore data store may be quite large and thus the amount of computer memory used may be quite large as well. This invention provides a method to reduce the size requirements associated with a large K by optimizing how the data is loaded and how the data store is built. In this invention an initial K may be used to record and evaluate the relationships of the incoming data and calculate a more efficient order for the data. The new data order may then be used to learn the entire data set with the result that the required space to hold a K may be decreased.

In the current embodiment data coming into a KStore are learned formed into a unique interlocking tree data store K and K nodes representing the relationships among the data may be constructed. Refer to . shows a block diagram representation illustrating the interaction of the main components used in preferred embodiments of this invention. Generally the KStore interlocking trees datastore may typically be built into a relatively fixed structure using a resource called a K Engine . K Engine may have a small set of rules it applies to data that has been particlized for it and sent to it in order to support the K Engine task of recording the particlized data as events in the KStore. The KStore itself may be accessed to answer queries about the data preferably using resources called API Utilities. This is described in detail in the above referenced patents.

The size of a K may be a direct result of the number of K nodes required to record the data and the number of K nodes required may be directly related to the order and relationships of the incoming data. Because we anticipate working with large data sets with large amounts of data the size of the K structure may be exceedingly large. Anything that can be done to reduce the size of K is important. In effect this invention provides a method to reorder data and compress large amounts of data being loaded into the K Engine through the Learn Engine . The data store which may be built after optimization may be compressed because it may have fewer K nodes and smaller as Result lists. By reducing the number of K nodes in the interlocking trees datastore the data may be loaded faster its size may be reduced and because there are fewer nodes to traverse it may be faster to query.

The optimization process may begin with a procedure which we refer to here as Teach. Refer again to . Teach or Teach Engine may be programmatically called or initiated by any external data source application through the use of a common API application programming interface . Note also that Teach may pass data back and forth programmatically to an application and back and forth to Learn through APIs. Note that in an alternative embodiment Teach may exist in the application environment outside of the KStore System and call into the Learn Engine from outside the K environment.

In one embodiment data that may be loaded by the K Engine may be formatted in .csv comma separated value format such as data exported from Microsoft Excel. In another embodiment the data may be loaded from XML or a message queue. However those skilled in the art will understand that any other formats may be used. The data that comes in may be passed from a data source application to either the Learn Engine or to the Teach Engine .

To begin optimization the Teach procedure may first determine if the data was previously optimized. In one embodiment a special file containing information pertaining to how to optimize the incoming data may be present. If the file containing optimization information is present then this existing optimization may be used in loading the data. If the data was not previously optimized or if it is determined that the optimization process should be performed again the Teach procedure may open the data file and start counting the records. Within the Teach procedure there may be a counter that is incremented as each record is read.

Depending on the size of the data set being read as possibly determined by the above mentioned counter the user may elect to sample just a portion of the data or all of the data set before the optimization process begins. For example if the data set is extremely large e.g. consisting of millions of records the user may elect to stop reading in records when the number of records reaches 10 000. If however the number of records is less than 10 000 for example the user may set a parameter to load the entire data set before the optimization process begins.

As records are read or received by the Teach Engine they may be grouped into blocks. When a block is filled the block may be passed to the Learn Engine . As taught in U.S. patent Ser. No. 10 879 329 entitled Functional operations for accessing and or building interlocking trees datastores to enable their use with applications software the Learn Engine provides an ability to receive or get data in various forms from various sources and to particlize the data such that the K Engine may process it. The Learn Engine basically provides interface translation and particlizing functions in order to provide the K Engine with particlized data to process. Thus the Learn Engine may process appropriate protocol transport and translation capabilities to receive input from any expected data sources whether they are XML Oracle DBMS or whatever whether they are from static or streaming sources or even external event triggered real time sensor sources. Of course the particular embodiment may be geared to any combination of such inputs. Learn may also be able to translate the data from such sources into appropriate sized chunks of data that may be readily particlized to fit with the expected data particle formatting for a KStore and it may have a particlizer to send such particles to the K Engine utilizing any buffering as may be appropriate.

As each record is passed to the Learn Engine the Learn Engine may particlize the data and pass the particles to a K Engine to be processed into a K or interlocking trees data store .

In a preferred embodiment the optimization process uses the Learn Engine to learn either all or a sub set of the records before the optimal order may be calculated. This optimal order may then be used to relearn the data already learned plus any new records. Using the above exemplary information the user may decide that 10 000 data records of a 1 000 000 record data set may be learned before the optimal order may be determined.

The optimal order for loading data into a Learn Engine may be determined by a Teach Engine analytic using a KStore constructed from the sample data set. Note however that any other structures which help identify the number of fields and their distinct values may be used. The Teach Engine may first identify all of the fields used within the data. The analytic may then determine preferably from a K the number of unique values that exist for each specific field.

Refer to . shows a set of five fictional sales activity records which identify sales and invoice numbers for a single day for a furniture store salesman named Bill. These five records will be used to help illustrate the method of optimizing the size of a K data store.

In the field salesperson has only one value Bill in this data set. However for the field Invoice there are 5 values invoice 123 invoice 124 invoice 125 invoice 126 and invoice 127 . shows a data store that may be built for the sample data before optimization. Each record from may be loaded and built into a K. For example record has six discrete individual K subcomponent nodes in the data store invoice 123 Tuesday Bill NJ TV and 125. Note that BOT refers to beginning of thought and EOT refers to end of thought which are explained in the above mentioned patents. Record also has six discrete individual K subcomponent nodes invoice 123 Tuesday Bill NJ TV and 125. The entire data store based on this fictional data set loaded in this order may contain 30 individual discrete K subcomponent nodes note that BOT node and EOT node are elemental root nodes and are not included in this count .

In the current embodiment if the user chooses to optimize the date the Teach Engine may run the optimization analytic. The analytic calculates the number of unique values for each field in the sample set of records e.g. the first 10 000 records . Based on this calculation a table or any other structure known to those skilled in the art may be created which has all of the fields sorted from the field with the lowest number of unique values to the field with the highest number of unique values. For example the following table shows how the fields in the above figure might be sorted from the lowest magnitude to the highest magnitude. Note that due to the small number of records in the data set all the records were used for the optimization process.

Because all of the records occur on the same day of the week Tuesday the number of unique field values for Day of Week in the table is 1 . Salesperson Item and State also have the value 1 since there is only one unique value for each of those fields. Because there are three different discrete values for Sale amt. the value in the table for Sale amt is 3 . There are five unique values for Invoice number therefore the value in the table for Invoice number is 5 . The table values when sorted from lowest to highest indicate an optimal load order. This means that K subcomponent nodes for fields with a value of 1 may be loaded into a K interlocking trees datastore only once. Those with higher numbers of unique field values may be loaded only the number of times corresponding to the unique number of field values. This may reduce the number of K nodes that may be constructed in the resulting interlocking trees datastore.

After optimization the Teach Engine may store information about the optimal load order. This may be saved as metadata and may be saved in any manner known to those skilled in the art. If the data is ever re loaded the optimal order may be determined either by reusing the previously determined optimal order or the optimal order may be re calculated. The Teach procedure may then reference the optimal load order information and begin loading the data into the Learn Engine field by field using the optimal load order determined during the optimization process.

The load order indicates which field to load first. For example in Tuesday may be loaded first. Using an array or any other known structure that may associate a field with a particular order in which it may be optimally loaded the Teach Engine may use a transformation process to reorder the input fields prior to passing them to the Learn Engine. This transformation may utilize those processes known to those skilled in the art. One preferred embodiment uses indirect referencing. All of the data may then be loaded into K using the optimal order. The records that were learned before the optimal order was determined may be deleted forgotten before being learned optimally. The Teach Engine continues passing fields into the Learn Engine. The Teach Engine does not stop at 10 000 records as it did during pre learning but loads all of the data into K.

While the invention has been described in detail and with reference to specific examples thereof it will be apparent to one skilled in the art that various changes and modifications can be made therein without departing from the spirit and scope thereof.

