---

title: Feedback and record of transformed vertices in a graphics library
abstract: One embodiment of the invention is a method for storing transformed vertex attributes that includes the steps of allocating memory space for a transform feedback buffer, selecting one or more transformed vertex attributes to store in the transform feedback buffer independently of any shader programs executing on any processing units in the graphics rendering pipeline, configuring the transform feedback buffer to store the one or more transformed vertex attributes, and initiating a processing mode wherein vertex data is processed in the graphics rendering pipeline to produce the transformed vertices, the attributes of which are then written to the transform feedback buffer. One advantage is that the transform feedback buffer can be used to store and access transformed vertices, without having to convert the vertex data to a pixel format, store the pixels in a frame buffer, and then convert the pixels back to a vertex format.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07928989&OS=07928989&RS=07928989
owner: NVIDIA Corporation
number: 07928989
owner_city: Santa Clara
owner_country: US
publication_date: 20061212
---
This application claims priority to the U.S. Provisional Application titled API Extensions for Advanced Graphics Processing Units filed on Jul. 28 2006 and having U.S. patent application No. 60 833 978.

Embodiments of the present invention generally relate to computer programming using graphics hardware. More specifically embodiments of the invention relate to techniques for feeding back and recording transformed vertices in a graphics library.

Graphics processing units GPUs are configured to execute instructions that generate images that may then be displayed on a display device. GPUs typically implement a pipelined architecture and the different processing units within the pipeline execute shader language programs on the streams of graphics data as that data passes through the different parts of the graphics pipeline. For example common shader language programs include vertex and fragment programs and new geometry programs have been added recently. The vertex processing unit executes a vertex shader program on data passing through the vertex shader portion of the graphics pipeline the geometry processing unit executes a geometry shader program on data passing through the geometry shader portion of the graphics pipeline and the fragment processing unit executes a fragment shader program on data passing through the fragment shader portion of the graphics pipeline. Generally the output of the vertex shader is the input to the geometry shader and the output of the geometry shader is the input to the fragment shader.

Over the past decade the cost of adding on chip logic to processors has substantially decreased. Consequently certain types of processors such as advanced graphics processing units GPUs now include functionality not previously available in earlier GPU designs. For example the newest CPUs are now able to perform geometry processing operations whereas such operations traditionally had been left to the central processing unit CPU .

Given the increased computing power available on advanced CPUs graphics developers are using the graphics pipeline for more than just generating images for display on a display screen. For example a vertex shader program operating on a set of input vertices may take each vertex process it and output a transformed set of vertices. Such a shader program could perform physics calculations to determine positions for a set of vertices at an initial point in time and output a subsequent position for each vertex at a second point in time. Another example is in the field of molecular modeling. In such cases a shader program may calculate a future position and a net charge of each atom in a molecule based on a current position and charge of each atom. By repeating such a calculation millions of times the shader program can calculate a theoretical steady state configuration of the overall molecule. In such applications the graphics pipeline is not limited to the conventional process of computing or determining color and intensity values for each pixel of a display.

However getting transformed vertex data out of the graphics rendering pipeline has proven to be somewhat difficult. One approach is to write the transformed data from the frame buffer to a buffer object once the data has been processed by the graphics pipeline and written to the frame buffer. Since the fragment shader is typically the only part of the graphics pipeline able to compute values written to the frame buffer this approach requires that the transformed vertex data be passed completely through the pipeline even though no downstream processing may be performed on the transformed vertex data. Moreover the fragment shader is typically configured to write pixel data to the frame buffer. Therefore if other data representations are desired such as an array of vertex attributes then the application developer has to map the transformed vertex data output from either the vertex shader or the geometry shader into a pixel format so that the data can then be written to the frame buffer. Once the transformed graphics data has been written into the frame buffer then the data has to be mapped back from a pixel formal to the desired format i.e. as an array of vertex attributes . Thus this approach may require substantial overhead especially if the pixel data needs to be passed back to the CPU to be reformatted into a vertex data representation which is often the case.

Another approach is to configure the graphics API to allow a graphics developer to insert tokens into a stream of data passed to the graphics pipeline to allow portions of the data to be written to a buffer object after being processed by a particular processing unit in the graphics pipeline. This approach is used by the Open GL feedback mode and allows developers to insert tokens into the graphics rendering pipeline with a point line or triangle. For example a token may specify to write a set of vertices following the token into a buffer as a triangle or other graphics primitive once the graphics processing unit has processed the vertices. Different tokens are typically provided for different graphics primitives resulting in a buffer format of 

One drawback of this approach is that the results of the graphics processing pipeline are written to a CPU system memory buffer. The data written to the system memory buffer may include both the results of the graphics rendering pipeline as well as which tokens were passed through the pipeline with the data. Thus the graphics pipeline cannot directly process the results of the graphics rendering pipeline. More specifically before the graphics pipeline can receive any of the transformed data stored in a buffer object using this approach the transformed data must first be copied from the buffer object into system memory parsed by the CPU formatted into an appropriate form and then passed back to the graphics pipeline for further processing. Thus this approach incurs a substantial performance penalty.

In addition some graphics APIs have allowed graphics developers to compose a shader program that enables certain attributes of transformed vertices to be written to a buffer object as part of the shader program. However this approach directly ties writing certain vertex attributes to the buffer object to a particular shader program. If the graphics developer desires to change which attributes are written to the buffer object then the shader program currently bound to the relevant processing unit must be unbound from that processing unit and a new shader program that includes instructions for writing the desired transformed vertex attributes to the buffer object must then be bound to the processing unit. This process must be followed even when the only difference between the two shader programs lies in which transformed vertex attributes each program writes to the buffer object. The delay created by unbinding a shader program from a processing unit just to change which transformed vertex attributes are written to the buffer object may in some cases cause an unacceptable performance bottleneck for data processing on the GPU thereby limiting the usefulness of this API feature.

As the foregoing illustrates what is needed in the art is way to access transformed vertex data in a graphics processing pipeline that avoids one or more of the problems set forth above.

One embodiment of the present invention sets forth a method for storing attributes of vertices transformed in a graphics rendering pipeline. The method includes the steps of allocating memory space in a memory for a transform feedback buffer selecting one or more attributes of the transformed vertices to store in the transform feedback buffer independently in that the set of variables captured is not compiled into a shader program executing on processing units in the graphics rendering pipeline and configuring the transform feedback buffer to store the one or more attributes of the transformed vertices. The method also includes the step of initiating a processing mode wherein vertex data is processed by a processing unit in the graphics rendering pipeline to produce the transformed vertices and the one or more attributes of the transformed vertices are then written to the transform feedback buffer. Additionally a query mechanism may be used to determine the number of primitives written to the transform feedback buffer. In some cases a graphics application can determine in advance know up front how many vertices were written to the transform feedback buffer however for a geometry shader the number of primitives written may depend on the execution of the shader itself and may not be known in advance. In this case the application may issue a query to determine how much data is in the transform feedback buffer.

One advantage of the disclosed method is that by providing API calls to define initiate and end transform feedback a transform feedback buffer may be used to record transformed vertices over one or more passes through a graphics rendering pipeline without having to map the data to a pixel format store the pixels in a frame buffer and then map the pixels back to a vertex format for storage in another buffer. Further because the API calls allow the transform feedback buffer to be configured independently from the shader programs executing on the different processing units of the graphics rendering pipeline the attributes written to the transform feedback buffer may be modified without having to load new shader programs onto the GPU as is required by other approaches.

Embodiments of the invention provide an application programming interface API and associated constructs to take advantage of new processing capabilities of GPUs such as the ability to provide and use feedback and record transformed vertices.

Once a transform feedback buffer is defined a graphics developer may initiate and end a transform feedback mode using an API call. While active transformed vertex attributes written by a vertex processing unit and in some cases transformed vertex attributes written by a geometry processing unit are written to a transform feedback buffer. Further a graphics hardware device may provide multiple transform feedback buffers. The transformations may include fixed function processing performed by either the vertex shader or the geometry shader. For example a graphics hardware device may provide a fixed function mode that transforms vertices evaluates lighting equations and generates texture and fog coordinates in a non programmable fashion. The transformations may also include vertex transformations carried out using vertex shader programs running on a vertex processing unit and if active those carried out geometry shader program running on a geometry processing unit. In either case the vertex transformations may be recorded in the transform feedback buffer prior to clipping or similar rasterizing operations typically performed to graphics data passed through the graphics pipeline. Doing so is useful in cases where the processing units are used to process data sets not intended for producing display images.

Additionally which transformed vertex attributes i.e. attributes of the vertex data processed by the vertex processing unit and if active by the geometry processing unit and how those attributes are recorded into the transform feedback buffer may be specified when the transform feedback buffer is defined. For example a graphics developer may use an API call to define a transform feedback buffer to store multiple vertex data attributes in an interleaved fashion within a single buffer. Alternatively a graphics developer may define multiple transform feedback buffers each used to store a different set of transformed vertex attributes.

Also should the graphics developer desire to change which transformed vertex attributes are being written a new transform feedback buffer may be defined and used to store the new attributes. Similarly when processing data using fixed function attributes or assembly level shader programs the particular shader programs or fixed function mechanisms running on the different processing units in the graphics pipeline may be changed without disrupting the transform feedback mode. Thus embodiments of the invention provide a highly flexible and configurable approach to feeding back and recording transformed vertices relative to prior art techniques. For linked high level shader programs the particular set of attributes captured during transform feedback is tied to the shader program running on the processing units of the graphics rendering pipeline. However the set of attributes captured may be changed dynamically without recompiling the shader so long as the new attributes are produced by the shader program.

Further transformed vertex data written to the transform feedback buffer may be accessed by the different processing units in the graphics pipeline as needed. For example by formatting the data stored in the transform feedback buffer as a texture image the different processing units of the graphics pipeline may sample the transformed vertices using an texture lookup functions. In a particular embodiment extensions to the OpenGL graphics API described in a commonly assigned application titled Indexed Access to Texture Buffer Objects Using a Graphics Library filed on Dec. 12 2006 and having Ser. No. 11 609 859 may be used.

If the transform feedback buffer is set up to store transformed vertices over each pass through the graphics pipeline then vertices may be cycled through the graphics pipeline repeatedly without being passed back to the system memory or CPU. Processing data in such a fashion may greatly improve processing performance on certain datasets.

Local memory stores among other things transformed vertex attributes in a transform feedback buffer and graphics data rendered by GPU in a frame buffer . When a display frame is completed the contents of frame buffer may be output to display device for display. Typically display device is a CRT or LCD display. Persons skilled in the art will recognize that any system having one or more processing units configured to implement the teachings disclosed herein falls within the scope of the present invention. For example computing device may be without limitation a desk top computer a laptop computer a mobile telephone a set top box or a personal digital assistant device. Thus the architecture of computing device in no way limits the scope of the present invention. Further In alternate embodiments the CPU GPU the system interface between these processing units not shown or any combination thereof may be integrated into a single processing unit. Further the functionality of GPU may be included in a chipset of in some other type of special purpose processing unit or co processor.

Between vertex processing unit geometry processing unit and fragment processing unit are primitive assembly unit and optionally primitive assembly and rasterizer unit . The primitive assembly unit is typically a fixed function unit that receives processed vertex data from vertex processing unit and constructs graphics primitives e.g. points lines triangles or the like for processing by geometry processing unit . If geometry processing unit is enabled primitive assembly and rasterizer unit may receive the graphics primitives output by geometry processing unit such as a set of triangles and perform clipping operations to limit the triangles passed to fragment processing unit to ones that might be viewable on display device . If geometry processing unit is not enabled the primitives assembled by primitive assembly unit are passed directly to primitive assembly and rasterizer unit that generates fragments processed by geometry processing unit .

As previously described herein the actual processing performed by vertex processing unit and geometry processing unit may be defined by various fixed functions specific to each of these two processing units or may be defined by separate shader programs each configured to execute on a different one of these two processing units. Illustratively shows a vertex shader program a geometry shader program and a fragment shader program . In one embodiment these shader programs may be written using a high level shading language such as the OpenGL Shading Language GLSL and transmitted to API for processing within GPU driver . In one embodiment the shader programs may then compiled and linked by a compiler linker included with GPU driver to produce a linked assembly code version of the shader programs. Alternatively compiler linker may be implemented to generate machine code directly.

The assembly code is then converted into machine code also referred to as microcode by an assembler also included in GPU driver . The machine code versions of the shader programs are then transmitted to the vertex processing unit the geometry processing unit and the fragment processing unit as the case may be for execution. In alternative embodiments the vertex shader program the geometry shader program and the fragment shader program may be written in assembly code or may be compiled into assembly code externally to GPU driver . In such embodiments the GPU driver would not necessarily include compiler linker and would receive assembly code versions of the shader programs directly. Assembler would then convert the assembly code into machine code and transmit the machine code versions of the shader programs to the appropriate processing units of the graphics rendering pipeline as set forth above.

As also shown graphics rendering pipeline also includes a transform feedback path used to write attributes of transformed vertices from graphics rendering pipeline into transform feedback buffer . As set forth below in the next section new API calls provided by graphics API may be used to bind transform feedback buffer to the output of transform feedback path to define which transformed vertex attributes are to be stored in transform feedback buffer and to enable and disable transform feedback mode while graphics rendering pipeline is active.

When transform feedback is active attributes of the vertices processed by vertex processing unit or if active geometry processing unit may be written into transform feedback buffer . If a geometry program is used transform feedback buffer may be used to capture captures outputs of geometry processing unit . In such a case the transformed values written by the vertex processing unit may be used to generate values passed to the geometry program running on geometry processing unit . Otherwise in the case where no geometry program is used transform feedback mode may be used to capture the output of the vertex processing unit .

Depending on how transform feedback mode is set up the attributes may be written with each attribute in separate transform feedback buffers or with all attributes interleaved into a single transform feedback buffer. However if the geometry portion of graphics rendering pipeline is disabled then the attributes written to transform feedback buffer are those of vertices processed only by vertex processing unit . In this second case vertices processed by vertex processing unit pass through graphics rendering pipeline unchanged by geometry processing unit . The vertices are then transmitted to transform feedback path and written to feedback buffer . Additionally transform feedback path may be configured such that transformed vertex attributes are captured and written to transform feedback buffer prior to clipping operations performed by primitive assembly block . If the primitives are not used apart from the transform feedback buffer a rasterizer discard mode may be used to discard primitives after they have been written to the transform feedback buffer. Otherwise however the captured primitives may be rasterized by primitive assembly and rasterizer unit processed by fragment processing unit raster operations unit and stored as rasterized pixel data in frame buffer .

In one embodiment the attributes recorded in transform feedback buffer may be stored as an array of vertex attributes. By using such regular representations the array of transformed vertex attributes may be accessed by one or more of the processing units of graphics rendering pipeline in subsequent rendering passes without any intervention from CPU or any requirement that the data first be copied to system memory . In other cases transformed vertex attributes written to transform feedback buffer may be directly accessed by CPU for further processing. For example vertex shader program may perform intermediate processing operations on a set of vertices and the resulting transformed vertices may be written to transform feedback buffer as a set of formatted vertices. CPU may then access this set of vertices directly from transform feedback buffer as opposed to having to access the data from frame buffer after the data has been converted to a pixel format. Importantly accessing the data from frame buffer requires that the GPU driver convert the data from an optimized hardware representation to a form more readily processed by the CPU. In other words the disclosed transform feedback functionality enables the superior capabilities of graphics rendering pipeline to be used to process certain datasets without the extra expense of passing the data completely through the graphics rendering pipeline to the frame buffer and then reformatted that data from a pixel format to a vertex format.

As shown method begins at step where a buffer may be bound to the output of the transform feedback path to create transform feedback buffer . Memory space is allocated within local memory for transform feedback buffer . In one embodiment the relevant API call may have a signature like the following 

The parameter is the constant TRANSFORM FEEDBACK BUFFER EXT indicating transform feedback usage. The parameter is the transform feedback buffer number e.g. 0 3 if the implementation supports capturing to four buffers simultaneously . The parameter is the name of a buffer object that has previously been set up to capture transform feedback data.

At step the transformed vertex attributes to be written to transform feedback buffer are specified. For example after binding transform feedback buffer to transform feedback path an application developer may use an API call to specify which attributes to store in the transform feedback buffer. In one embodiment the relevant API calls may have signatures like the following 

After the setup actions performed in step and the transform feedback buffer is configured to store attributes of vertices transformed by vertex processing unit and if active geometry processing unit . Importantly attributes of the transformed vertices are stored in the transform feedback buffer independently of any shader programs executing on any processing units in graphics rendering pipeline . At step transform feedback mode may be activated. For example another API call may be used to activate the transform feedback path shown in . At step the specified attributes of data sets processed by vertex processing unit and the geometry processing unit if any are recorded in the transform feedback buffer defined in steps and .

At step transform feedback mode may be ended by invoking another API call. In one embodiment the relevant API calls may have signatures like the following 

Advantageously by providing API calls to define initiate and end transform feedback a transform feedback buffer may be used to record transformed vertices over one or more passes through a graphics rendering pipeline without having to convert the data to a pixel format store the pixels in a frame buffer and then map the pixels back to a vertex format for storage in another buffer. Since these mappings do not occur no data processing is required to be performed by a system CPU instead the data processing may remain within the graphics hardware and graphics pipeline improving the processing efficiency. Further because the API calls allow the transform feedback buffer to be configured independently of the shader programs executing on the different processing units of the graphics rendering pipeline the attributes written to the transform feedback buffer may be modified without having to load new shader programs onto the GPU as is required by other approaches.

The following discussion describes extensions to the OpenGL API and related APIs to implement feedback and recording of vertex transformations in a graphics processing pipeline as described herein. Persons skilled in the art will appreciate that the information in this section should be considered in conjunction with the current OpenGL 2.0 specification.

Importantly the extensions presented herein introduce API calls to the OpenGL API and the GLSL that may be used to create a transform feedback buffer to specify which attributes vertex data to write to the transform feedback buffer and to begin and end transform feedback mode.

Transform feedback is started and finished by calling the BeginTransformFeedbackEXT and the EndTransformFeedbackEXT API calls respectively. Transform feedback is said to be active after a call to BeginTransformFeedbackEXT and inactive after a call to EndTransformFeedbackEXT . Transform feedback is initially inactive. Transform feedback is performed after color clamping but immediately before clipping in the OpenGL pipeline. is one of TRIANGLES LINES or POINTS and specifies the output type of primitives that will be recorded into the buffer objects bound for transform feedback. places a restriction on the primitive types that may be rendered during an instance of transform feedback.

Quads and polygons will be tessellated and recorded as triangles the order of tessellation within a primitive is undefined primitives specified in strips or fans will be assembled and recorded as individual primitives. Incomplete primitives are not recorded. Begin or any operation that implicitly calls Begin such as DrawElements will generate INVALID OPERATION if the begin mode is not an allowed begin mode for the current transform feedback buffer state. If a geometry program or geometry shader is active its output primitive mode is used for the error check instead of the begin mode.

A buffer object is made to be a target of transform feedback by calling one of BindBufferRangeEXT BindBufferOffsetEXT and BindBufferBaseEXT . where the parameter is set to TRANSFORM FEEDBACK BUFFER EXT. Any of the three BindBuffer commands perform the equivalent of the BindBuffer target buffer API call. The parameter specifies which buffer object to bind to the target at index number . The parameter exists for use with the TRANSFORM FEEDBACK SEPARATE ATTRIBS EXT mode and must be less than the value of MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS EXT which indicates the implementation dependent maximum number of transform feedback buffers that can be used in separate attribute mode. The parameter specifies a starting offset into the buffer object . The parameter specifies the number of elements that can be written during transform feedback mode. Both and are in basic machine units. BindBufferBaseEXT is equivalent to calling BindBufferOffsetEXT with an of 0. BindBufferOffsetEXT is the equivalent of calling BindBufferRangeEXT with sizeof buffer and rounding down so that it is word aligned.

If recording the vertices of a primitive to the buffer objects being used for transform feedback purposes would result in either exceeding the limits of any buffer object s size or in exceeding the end position 1 as set by BindbufferRangeEXT then no vertices of the primitive are recorded and the counter corresponding to the asynchronous query target TRANSFORM FEEDBACK PRIMITIVES WRITTEN EXT is not incremented.

The API functions listed above include two methods used to specify which transformed vertex attributes are streamed to one or more buffer objects in transform feedback mode. If an OpenGL Shading Language vertex and or geometry shader is active then the state set with the TransformFeedbackVaryingsEXT command determines which attributes to record. If neither a vertex nor geometry shader is active the state set with the TransformFeedbackAttribsEXT command determines which attributes to record. When a program object containing a vertex shader and or geometry shader is active the set of vertex attributes recorded in transform feedback mode is specified using the TransformFeedbackVaryingsEXT API call. This command sets the transform feedback state for and specifies which varying variables to record when transform feedback is active. The array contains locations of active varying variables as queried with the GetVaryingLocationEXT API call to stream to a buffer object. The parameter is one of TRANSFORM FEEDBACK INTERLEAVED ATTRIBS EXT or TRANSFORM FEEDBACK SEPARATE ATTRIBS EXT.

In the TRANSFORM FEEDBACK INTERLEAVED ATTRIBS EXT mode varying variables are written interleaved into one buffer object. This is the buffer object bound to index 0. Varying variables are written out to that buffer object in the order that they appear in the array . In the TRANSFORM FEEDBACK SEPARATE ATTRIBS EXT mode varying variables are recorded non interleaved into several buffer objects simultaneously. The first varying variable in the array is written to the buffer bound to index 0. The last varying variable is written to the buffer object bound to index 1.

It is not necessary to re link after calling TransformFeedbackVaryingsEXT . Changes to the transform feedback state will be picked up right away after calling TransformFeedbackVaryingsEXT . The value for any attribute specified to be streamed to a buffer object but not actually written by a vertex or geometry shader is undefined.

When neither a vertex nor geometry shader is active the set of vertex attributes recorded in transform feedback mode is specified using the API call TransformFeedbackAttribsEXT . This call specifies which attributes to record into one or more buffer objects. The value TRANSFORM FEEDBACK BUFFER MODE EXT will be set to and the value TRANSFORM FEEDBACK ATTRIBS EXT set to .

The array contains an interleaved representation of the attributes desired to be fed back containing 3 count values. For attrib i the value at 3 i 0 is the enum corresponding to the attrib as given in Table 3. The value at 3 i 1 is the number of components of the provided attrib to be fed back and is between 1 and 4. The value at 3 i 2 is the index for attribute enumerants corresponding to more than one real attribute. For an attribute enumerant corresponding to only one attribute the index is ignored.

The attrib column specifies which attribute to record. The permitted sizes column indicates how many components of the attribute can be recorded. The index column indicates if the attribute is indexed. The gpu program 4 column shows which result variable of a vertex or geometry program corresponds to the attribute to record.

The TransformFeedbackAttribsEXT API call sets a transform feedback state which is used both when the GL is in fixed function vertex processing mode as well as when an assembly vertex and or geometry program is active. The parameter has the same meaning as described for the TransformFeedbackVaryingsEXT API call. Attributes are either written interleaved or into separate buffer objects in the same manner as described earlier for the TransformFeedbackVaryingsEXT .

In one embodiment of the invention a computer readable medium including a plurality of instructions that when executed by a processor causes a computing device to store attributes of vertices transformed in a graphics rendering pipeline by performing the steps of allocating memory space in a memory for a transform feedback buffer selecting one or more attributes of the transformed vertices to store in the transform feedback buffer independently of any shader programs executing on any processing units in the graphics rendering pipeline configuring the transform feedback buffer to store the one or more attributes of the transformed vertices and initiating a processing mode where vertex data is processed by a processing unit in the graphics rendering pipeline to produce the transformed vertices and the one or more attributes of the transformed vertices are then written to the transform feedback buffer.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow

