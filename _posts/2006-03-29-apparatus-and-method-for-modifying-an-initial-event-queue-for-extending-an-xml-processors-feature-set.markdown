---

title: Apparatus and method for modifying an initial event queue for extending an XML processor's feature set
abstract: A method and apparatus for modifying an events queue for extending an extended mark-up language (XML) processor's feature set are described. In one embodiment, the method includes the parsing of an XML document to generate an initial event queue. During parsing of the XML document, an event associated with a parser plug-in module may be detected. When an event associated with a parser plug-in module is detected, control is passed to the plug-in module to perform event-based functionality to modify the initial event queue to form a modified event queue. Subsequently, any additional event information contained within the modified event queue, as generated by the parser plug-in module, is reported to, for example, an end user application. Other embodiments are described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07962919&OS=07962919&RS=07962919
owner: Intel Corporation
number: 07962919
owner_city: Santa Clara
owner_country: US
publication_date: 20060329
---
One or more embodiments relate generally to the field of mark up languages. More particularly one or more of the embodiments relate to a method and apparatus for modifying an events queue for extending an XML processor s feature set.

Hypertext mark up language HTML is a presentation mark up language for displaying interactive data in a web browser. However HTML is a rigidly defined language and cannot support all enterprise data types. As a result of such shortcomings HTML provided the impetus to create the extensible mark up language XML . The XML standard allows an enterprise to define its mark up languages with emphasis on specific tasks such as electronic commerce supply chain integration data management and publishing.

XML a subset of the standard generalized mark up language SGML is the universal format for data on the worldwide web. Using XML users can create customized tags enabling the definition transmission validation and interpretation of data between applications and between individuals or groups of individuals. XML is a complementary format to HTML and is similar to HTML as both contain mark up symbols to describe the contents of a page or file. A difference however is that HTML is primarily designed to specify the interaction and display text and graphic images of a web page. XML does not have a specific application and can be designed for a wide variety of applications.

For these reasons XML is rapidly becoming the strategic instrument for defining corporate data across a number of application domains. The properties of XML mark up make it suitable for representing data concepts and context in an open vender and language neutral manner. XML uses tags such as for example identifiers that signal the start and end of a related block of data to recreate a hierarchy of related data components called elements. In turn this hierarchy of elements provides context implied meaning based on location and encapsulation. As a result there is a greater opportunity to reuse this data outside the application and data sources from which it was derived.

SAX simple application programming interface API for XML is a traditional event driven parser. SAX reads the XML document incrementally calling certain call back functions in the application code whenever it recognizes a token. Call back events are generated for the beginning and end of a document the beginning and end of an element etc. The SAX parser may populate an event queue with detected SAX events to enable certain call back functions in the user application code whenever a recognized token is detected.

A method and apparatus for modifying an initial event queue for extending an extended mark up language XML processor s feature set are described. In one embodiment the method includes the parsing of an XML document to generate an initial event queue. During parsing of the XML document an event associated with a parser plug in module may be detected. When an event associated with a parser plug in module is detected control is passed to the plug in module to perform event based functionality to modify the initial event queue to form a modified event queue. Subsequently any additional event information contained within the modified event queue as generated by the parser plug in module is reported to for example an end user application.

In the following description numerous specific details such as logic implementations sizes and names of signals and buses types and interrelationships of system components and logic partitioning integration choices are set forth in order to provide a more thorough understanding. It will be appreciated however by one skilled in the art that the invention may be practiced without such specific details. In other instances control structures and gate level circuits have not been shown in detail to avoid obscuring the invention. Those of ordinary skill in the art with the included descriptions will be able to implement appropriate logic circuits without undue experimentation.

In the following description certain terminology is used to describe features of the invention. For example the term logic is representative of hardware and or software configured to perform one or more functions. For instance examples of hardware include but are not limited or restricted to an integrated circuit a finite state machine or even combinatorial logic. The integrated circuit may take the form of a processor such as a microprocessor application specific integrated circuit a digital signal processor a micro controller or the like.

Representatively display network interface controller NIC hard drive devices HDD main memory and firmware hub FWH may be coupled to chipset . In one embodiment chipset is configured to include a memory controller hub MCH and or an input output I O controller hub ICH to communicate with I O devices such as NIC . In an alternate embodiment chipset is or may be configured to incorporate a graphics controller and operate as a graphics memory controller hub GMCH . In one embodiment chipset may be incorporated into CPU to provide a system on chip.

In one embodiment main memory may include but is not limited to random access memory RAM dynamic RAM DRAM static RAM SRAM synchronous DRAM SDRAM double data rate DDR SDRAM DDR SDRAM Rambus DRAM RDRAM or any device capable of supporting high speed buffering of data. Representatively computer system further includes non volatile e.g. Flash memory . In one embodiment flash memory may be referred to as a firmware hub or FWH which may include a basic input output system BIOS that is modified to perform in addition to initialization of computer system initialization of XML processor and plug in module for modifying an initial event queue for extending an XML processor s feature set according to one embodiment.

As further illustrated in network interface controller NIC may couple network to chipset . In the embodiments described network may include but is not limited to a local area network LAN a metropolitan area network MAN a wide area network WAN a wireless network including a wireless LAN WLAN a wireless MAN WMAN a wireless WAN WWAN or other like network. Accordingly in the embodiments described NIC may provide access to either a wired or wireless network. It should be recognized in the embodiments described NIC may be incorporated within chipset .

In one embodiment NIC may receive an input XML document from network . As further shown in end user application which may be loaded within main memory by operating system OS for execution by processor may rely on data such as elements represented by input XML document . Accordingly in one embodiment XML processor parses input XML document to provide the data contained therein to end user application . As described in further detail below plug in module enables XML processor to include an expanded feature set by for example modifying an initial event queue to provide extended functionality to end user application according to one embodiment.

As shown in in one embodiment non validating parser generates initial event queue from input XML data . In one embodiment initial event queue provides a representation of an XML document as a sequence of SAX events. Using initial event queue various plug ins may be generated based on non validating SAX parser . In one embodiment initial event queue is presented as an array of structures with the following fields 

In one embodiment initial event queue is provided as an input to at least one parser plug in module . In one embodiment parser plug in module includes event analyzer to analyze initial event queue and event processing functionality to perform event based functionality. As described herein event based functionality may include validation of an XML document parsing of an inclusion document data reduction logic or other like functionality for extending the features of XML processor . As further shown in parser plug in module may include data generator for providing new events and additional data within an initial event queue to form a modified event queue to include the new events and additional data.

As described herein parser plug in modules may include but are not limited to DTD plug ins XML schema validation plug ins DOM tree building plug ins XSL Extensible Stylesheet Language transformations XSLT XInclude plug ins or other like plug ins for extending an XML processor s functionality. As shown in standard inputs for parser plug in may include initial event queue a memory manager for allocating memory used by a parser plug in module as well as a link to initial event queue. Accordingly in one embodiment initial event queue is generated by parser such that events generated during parsing of input XML document are packed into initial event queue .

In one embodiment memory manager is represented by a class that allows control over memory operations inside parser plug in . In one embodiment when a plug in needs to modify received information the plug in may use memory manager to avoid conflicts between use of different memory modules by parser core and parser plugs ins . In one embodiment memory manager performs memory distribution among different modules. Memory manager may deal with two kinds of memory SAX parser system memory and SAX event data memory.

In one embodiment memory manager stores information about SAX parser states and is responsible for handling of extensible events queue structure. In one embodiment memory manager deals with internal memory. In one embodiment memory manager allocates system memory through invoking of user defined callback functions for allocation reallocation free memory in case of SW implementation. In one embodiment memory manager stores data of SAX events that go to end user application and invokes user defined callback functions for allocation reallocation free memory.

Accordingly in one embodiment plug in module does not work directly with SAX parser system memory. The process of updating SAX parser system memory is hidden by public API functions such as InsertEventBefore InsertEventAfter see Table 4 but a plug in has to call memory manager to store data of a SAX event in SAX event data memory otherwise the data of a newly generated or updated event will not be processed by post processing module and as result cannot be accessed from end user application .

Standard output from parser plug in may include modified event queue where modified events queue may include additional data such as a DOM tree for a DOM plug in post validation information PVI for an XML schema validation plug in or other like additional data. In one embodiment event analyzer provides event information to an event processing application module of end user application . As further illustrated in SAX events post processing logic and plug in event post processing may generate callbacks for user callback functions .

Accordingly based on such events a parser plug in module may be associated with a respective event to begin performing of the additional event based functionality. As shown in core SAX parser includes non validating SAX parser and a set of plug ins that extend core parser s functionality. In one embodiment new features may be added to core SAX parser such as DOM functionality XSLT and XInclude without rewriting of core parser . Also because all plug ins use the same data flow some memory optimization may be performed using the memory manager. Accordingly using modified events queue allows not only processing of SAX events and generation of additional data but also changes the stream of data provided to additional parser plug ins and an end user application.

Accordingly in one embodiment a validating parser may be formed from a non validating XML parser for example as shown in . By definition validation is the process of examination of documents against specified constraint rules. Current constraint rules for XML can be specified in two ways document type definitions DTD XSD XML Schema Definition language or other like constraint rules. In the classical situation validation support mode and XML processing is required to implement validating XML parsers. In one embodiment a validating plug in can report validation information by insertion of new events into an event queue such that processing following of the SAX parser can work with the validation information inserted by the parser plug in module. As a result validation information may be reported by the plug in to avoid the need for making serious changes to the XML SAX parser to provide validation.

In one embodiment XML schema validation plug in provides modified event queue including standard XML events queue which are extended by schema validating information and validation errors violation of XML schema validation constraints . Accordingly features provided by a core XML processor may be extended by providing a pipeline of plug ins to achieve a desired XML processing functionality to enable various end user applications . Procedural methods for implementing one or more embodiments are now described.

Turning now to the particular methods associated with various embodiments are described in terms of computer software and hardware with reference to a flowchart. The methods to be performed by a computing device e.g. an XML processor may constitute state machines or computer programs made up of computer executable instructions. The computer executable instructions may be written in a computer program and programming language or embodied in firmware logic. If written in a programming language conforming to a recognized standard such instructions can be executed in a variety of hardware platforms and for interface to a variety of operating systems.

In addition embodiments are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement embodiments as described herein. Furthermore it is common in the art to speak of software in one form or another e.g. program procedure process application etc. as taking an action or causing a result. Such expressions are merely a shorthand way of saying that execution of the software by a computing device causes the device to perform an action or produce a result.

Referring again to at process block modification of an events queue using at least one parser plug in module begins with initialization of at least one parser plug in module. In one embodiment such initialization may be include memory allocation and initialization of structures for the parser plug in module. In addition callbacks of event handlers may be initialized. Callbacks of parser plug in modules enable association of an XML event with a parser plug in module.

Referring again to at process block a parser pipeline collects events in a queue referred to herein as an initial event queue. During the collection of events in initial event queue an event may be detected having an associated parser plug in module. In response to such detection a non validating parser may pass control the parser plug in module so that the parser plug in module may perform SAX events queue processing.

Table 3 illustrates pseudo code for enabling or providing functions to enable a plug in to process events. Representatively a process event callback function is provided which includes parameters such as a plug in defined SAX callback context a pointer to the event structure and a handle to the plug in s info set for the event.

Referring again to at process block the plug in processes SAX events and reports back information about skipped events. In one embodiment the parser plug in module may as well as call functions to insert new events either before or after a skipped event as shown in Table 4.

Table 4 illustrates pseudo code for inserting new events for generation of a modified events queue. In one embodiment insertion or deletion of events within the event queue as performed at process block may be provided using the pseudo code of Table 4 which illustrates functions for inserting new events and modifying the events queue which allows insertion of event before or after a selected event. Pointers for the insert event function include a pointer to the parser context pCtx a new event ID newEventID and a pEvent which indicates an event after the new event which will be inserted.

Referring again to control is returned from the plug in to the parser pipeline for post processing and calls to user callback function according to the modified event queue. At process block it is determined whether an end of XML stream is reached. Until the end of the XML stream is reached process blocks are repeated.

Accordingly at process block process block is repeated until the included XML document has been successfully parsed. Once successfully parsed activation of the original XML document parsing is performed. Accordingly in one embodiment as shown in inclusion can be detected and processed in a plug in branch. New events from inclusion can be easily inserted into the queue of the main XML document. As a result XML processing followed by an XML SAX parser automatically supports XInclude functionality according to one embodiment.

In some situations usually when an XML file has a very large size it is important to build document object model DOM representations that excludes some portion of the XML data referred to herein as lazy DOM. For example a lazy DOM document may refer to a DOM document that has a limitation of the nesting level of the result tree or to build a sub tree of XML data according to a specified path. Conventionally generation of lazy DOM documents requires a special SAX handler mechanism to skip unneeded information from the SAX processor. In one embodiment a lazy DOM plug in module can be implemented that filters information not required for building a lazy DOM document according to the specific limitation required by an end user application handler.

In some situations it is necessary to make transformations of XML documents during the parsing stage for example to extract information from XML and report such information to an end device by a specified format such as Resource Description Framework RDF . Conventionally such functionality requires a special XSL document and execution to an XSLT mechanism to build another XML representation. In one embodiment an XSLT parser plug in module can insert new events and skip some unneeded events in the initial events queue during SAX parsing and report functions can update the initial XML document.

Accordingly in one embodiment a SAX events queue mechanism enables extensible functionality at an initial stage of XML processing. In one embodiment the mechanism can be implemented as a set of plug ins to a main parsing pipeline with special functionality to insert new events and skip unneeded events from the initial events queue. In one embodiment the initial events queue is generated by a non validating SAX parser and is modified according to a parser plug in module to generate a modified events queue.

In any representation of the design the data may be stored in any form of a machine readable medium. An optical or electrical wave modulated or otherwise generated to transport such information a memory or a magnetic or optical storage such as a disk may be the machine readable medium. Any of these mediums may carry the design information. The term carry e.g. a machine readable medium carrying information thus covers information stored on a storage device or information encoded or modulated into or onto a carrier wave. The set of bits describing the design or a particular of the design are when embodied in a machine readable medium such as a carrier or storage medium an article that may be sealed in and out of itself or used by others for further design or fabrication.

It will be appreciated that for other embodiments a different system configuration may be used. For example while the system includes a single CPU for other embodiments a multiprocessor or multicore processor system where one or more processors may be similar in configuration and operation to the CPU described above may benefit from parser plug in modules for extending an XML processor s feature set of various embodiments. Further different type of system or different type of computer system such as for example a server a workstation a desktop computer system a gaming system an embedded computer system a blade server etc. may be used for other embodiments.

Elements of embodiments may also be provided as a computer readable medium for storing the machine executable instructions. The computer readable medium may be a computer readable storage medium including but is not limited to flash memory optical disks compact disks read only memory CD ROM digital versatile video disks DVD ROM random access memory RAM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM magnetic or optical cards. A computer readable transmission medium may include propagation media or other type of computer readable transmission media suitable for transferring electronic instructions. For example embodiments described may be downloaded as a computer program which may be transferred from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a carrier wave or other computer readable propagation medium via a communication link e.g. a modem or network connection .

It should be appreciated that reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore it is emphasized and should be appreciated that two or more references to an embodiment or one embodiment or an alternative embodiment in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined as suitable in one or more embodiments.

In the above detailed description of various embodiments reference is made to the accompanying drawings which form a part hereof and in which are shown by way of illustration and not of limitation specific embodiments in which the invention may be practiced. In the drawings like numerals describe substantially similar components throughout the several views. The embodiments illustrated are described in sufficient detail to enable those skilled in to the art to practice the teachings disclosed herein. Other embodiments may be utilized and derived therefrom such that structural and logical substitutions and changes may be made without departing from the scope of this disclosure. The following detailed description therefore is not to be taken in a limiting sense and the scope of various embodiments is defined only by the appended claims along with the full range of equivalents to which such claims are entitled.

Having disclosed embodiments and the best mode modifications and variations may be made to the disclosed embodiments while remaining within the scope of the embodiments as defined by the following claims.

