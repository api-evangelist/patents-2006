---

title: Apparatus and method for live loading of version upgrades in a process control environment
abstract: A method includes comparing a first layout of data elements associated with a first version of a class and a second layout of data elements associated with a second version of the class. The first and second versions of the class are associated respectively with first and second versions of assembly code. The method also includes updating method information in an existing object instance associated with the first version of the class if the first and second layouts are identical. In addition, the method includes creating a new object instance associated with the second version of the class and transferring one or more values of one or more data elements from the existing object instance to the new object instance when the first and second layouts are not identical.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08286154&OS=08286154&RS=08286154
owner: Honeywell International Inc.
number: 08286154
owner_city: Morristown
owner_country: US
publication_date: 20060322
---
Ser. No. 11 175 848 entitled DETERMINISTIC RUNTIME EXECUTION ENVIRONMENT AND METHOD filed on Jul. 6 2005 and

Ser. No. 11 175 703 entitled APPARATUS AND METHOD FOR DETERMINISTIC GARBAGE COLLECTION OF A HEAP MEMORY filed on Jul. 6 2005 

This disclosure relates generally to computing systems and more specifically to an apparatus and method for live loading of version upgrades in a process control environment.

Processing facilities are often managed using process control systems. Example processing facilities include manufacturing plants chemical plants crude oil refineries and ore processing plants. Among other operations process control systems typically manage the use of motors valves and other industrial equipment in the processing facilities.

In conventional process control systems various controllers are often used to control the operation of the industrial equipment in the processing facilities. The controllers could for example monitor the operation of the industrial equipment provide control signals to the industrial equipment and generate alarms when malfunctions are detected.

Conventional controllers often include function block algorithms or other control logic implementing the desired control functionality. Conventional controllers also often include a scheduler which schedules or drives the execution of the control logic. For example a scheduler could invoke or schedule execution of a function block algorithm once every twenty milliseconds. In general the scheduler is often written by a manufacturer or vendor of a controller while the control logic can be written by the manufacturer or vendor of the controller or by end users of the controller such as industrial plant engineers .

For various reasons it may become necessary or desirable to upgrade or improve the control logic in a conventional controller after installation in a process control system. This becomes challenging when an old version of the control logic is being executed by the conventional controller to control a process in a processing facility. For example simply shutting down a conventional controller to load a new version of the control logic onto the controller would likely require shutting down an entire industrial process a complex time consuming and expensive operation . Also a switch over from an old version of the control logic to a new version of the control logic often needs to occur within a short amount of time such as tens of milliseconds . In addition the switch over often must include a transfer of data from object instances associated with the old version of the control logic to object instances associated with the new version of the control logic.

This disclosure provides an apparatus and method for live loading of version upgrades in a process control environment.

In a first embodiment a method includes comparing a first layout of data elements associated with a first version of a class and a second layout of data elements associated with a second version of the class. The first and second versions of the class are associated respectively with first and second versions of assembly code. The method also includes updating method information in an existing object instance associated with the first version of the class if the first and second layouts are identical. In addition the method includes creating a new object instance associated with the second version of the class and transferring one or more values of one or more data elements from the existing object instance to the new object instance when the first and second layouts are not identical.

In particular embodiments the existing object instance represents one of a plurality of existing object instances. Also an executable program associated with the first and second versions of assembly code or a garbage collection process identifies the plurality of existing object instances.

In a second embodiment an apparatus includes at least one memory capable of storing an existing object instance associated with a first version of a class. The first version of the class is associated with a first version of assembly code. The apparatus also includes at least one processor capable of comparing a first layout of data elements associated with the first version of the class and a second layout of data elements associated with a second version of the class. The second version of the class is associated with a second version of assembly code. The at least one processor is also capable of updating method information in the existing object instance if the first and second layouts are identical. In addition the at least one processor is capable of creating a new object instance associated with the second version of the class and transferring one or more values of one or more data elements from the existing object instance to the new object instance when the first and second layouts are not identical.

In a third embodiment a computer program is embodied on a computer readable medium and is operable to be executed by a processor. The computer program includes computer readable program code for comparing a first layout of data elements associated with a first version of a class and a second layout of data elements associated with a second version of the class. The first and second versions of the class are associated respectively with first and second versions of assembly code. The computer program also includes computer readable program code for updating method information in an existing object instance associated with the first version of the class if the first and second layouts are identical. In addition the computer program includes computer readable program code for creating a new object instance associated with the second version of the class and transferring one or more values of one or more data elements from the existing object instance to the new object instance when the first and second layouts are not identical.

Other technical features may be readily apparent to one skilled in the art from the following figures descriptions and claims.

In this example embodiment the process control system includes one or more process elements . The process elements represent components in a process or production system that may perform any of a wide variety of functions. For example the process elements could represent motors catalytic crackers valves and other industrial equipment in a production environment. The process elements could represent any other or additional components in any suitable process or production system. Each of the process elements includes any hardware software firmware or combination thereof for performing one or more functions in a process or production system.

Two controllers are coupled to the process elements . The controllers control the operation of the process elements . For example the controllers could be capable of providing control signals to the process elements periodically. Each of the controllers includes any hardware software firmware or combination thereof for controlling one or more of the process elements . The controllers could for example include one or more processors and one or more memories storing data and instructions used by the processor s . As particular examples the processors could include processors of the POWERPC processor family running the GREEN HILLS INTEGRITY operating system or processors of the X86 processor family running a MICROSOFT WINDOWS operating system.

Two servers are coupled to the controllers . The servers perform various functions to support the operation and control of the controllers and the process elements . For example the servers could log information collected or generated by the controllers such as status information related to the operation of the process elements . The servers could also execute applications that control the operation of the controllers thereby controlling the operation of the process elements . In addition the servers could provide secure access to the controllers . Each of the servers includes any hardware software firmware or combination thereof for providing access to or control of the controllers . The servers could for example represent personal computers such as desktop computers executing a MICROSOFT WINDOWS operating system. As another example the servers could include processors of the POWERPC processor family running the GREEN HILLS INTEGRITY operating system or processors of the X86 processor family running a MICROSOFT WINDOWS operating system.

One or more operator stations are coupled to the servers and one or more operator stations are coupled to the controllers . The operator stations represent computing or communication devices providing user access to the servers which could then provide user access to the controllers and the process elements . The operator stations represent computing or communication devices providing user access to the controllers without using resources of the servers . As particular examples the operator stations could allow users to review the operational history of the process elements using information collected by the controllers and or the servers . The operator stations could also allow the users to adjust the operation of the process elements controllers or servers . Each of the operator stations includes any hardware software firmware or combination thereof for supporting user access and control of the system . The operator stations could for example represent personal computers having displays and processors executing a MICROSOFT WINDOWS operating system.

In this example at least one of the operator stations is remote from the servers . The remote station is coupled to the servers through a network . The network facilitates communication between various components in the system . For example the network may communicate Internet Protocol IP packets frame relay frames Asynchronous Transfer Mode ATM cells or other suitable information between network addresses. The network may include one or more local area networks LANs metropolitan area networks MANS wide area networks WANs all or a portion of a global network such as the Internet or any other communication system or systems at one or more locations.

In this example the system includes two additional servers . The servers execute various applications to control the overall operation of the system . For example the system could be used in a processing or production plant or other facility and the servers could execute applications used to control the plant or other facility. As particular examples the servers could execute applications such as enterprise resource planning ERP manufacturing execution system MES or any other or additional plant or process control applications. Each of the servers includes any hardware software firmware or combination thereof for controlling the overall operation of the system .

As shown in the system includes various redundant networks and single networks that support communication between components in the system . Each of these networks represents any suitable network or combination of networks facilitating communication between components in the system . The networks could for example represent Ethernet networks.

In one aspect of operation control logic is implemented by the controllers to control the process elements . The control logic could represent function block algorithms or any other suitable logic. A function block algorithm represents an application having associated sub applications formed from function blocks where the application cycles through the function blocks and causes them to execute. The function block algorithm or other control logic may be associated with classes that are used to create object instances. The object instances are typically associated with both data elements and methods or behaviors. The current value s of data element s in an object instance may be referred to as the state of the object instance.

The controllers also implement a mechanism to upgrade from an old version of the control logic to a new version of the control logic. The new version of the control logic could make various changes to the classes that define the object instances compared to the classes that were defined by the old version of the control logic. For example the new version of the control logic could add modify or remove data elements in a class. In this document the phrase data element refers to any individual unit of data such as an integer floating point value character or string or combination of units such as an array or data structure . The new version of the control logic could also add modify or delete methods in a class.

The mechanism for upgrading the control logic in the controllers supports the live loading of the new version of the control logic. This means that the controllers are capable of creating and or updating object instances so that they are suitable for use with the new version of the control logic. For example if the field or class layout of a class its data elements remains unchanged the controllers may be capable of updating an object instance to identify new methods defined by the new version of the control logic. If the layout of a class changes the controllers may be capable of creating new object instances and transferring state data from old object instances to the new object instances. In addition the controllers may be capable of initializing new data elements in the new object instances and or using conversion rules to transform data values from the old object instances prior to storage in the new object instances. The conversion rules represent logic identifying how data is transformed during a transfer which may be useful in situations like when data is being transferred between two data elements that have somewhat different structures.

In this way the controllers support the upgrading of control logic without the need to actually shut down the controllers or an entire industrial process. Also the controllers may be capable of switching over from the old version of the control logic to the new version of the control logic within a relatively short amount of time such as tens of milliseconds . In addition the controllers may be capable of effectively transferring state data from old object instances to new object instances. The controllers may do this without requiring users to actually write program code to perform the state data transfers. The controllers may also do this without requiring classes to be compiled with specific attributes enabled such as is required for techniques like serialization deserialization which means that users need not decide whether a live load will be necessary when they are writing programs.

In some embodiments the controllers execute support or otherwise provide access to an execution environment. The execution environment provides support for various features that managed applications may use during execution. As examples the execution environment could provide support for mathematical functions input output functions and communication functions. The phrase managed application refers to an application executed in the execution environment where the execution of the application is managed by the execution environment. A managed application could include the control logic needed to control one or more process elements 

In particular embodiments the execution environment used in the controllers to execute the managed applications is deterministic. A deterministic execution environment is an execution environment whose behavior is predictable or that can be precisely specified. The execution environment could be implemented in any suitable manner such as by using NET programming based on the Common Language Interface CLI specification as ratified by ECMA 335 and support both the Kernel and Compact profiles. In these embodiments the deterministic execution environment may support the live loading of a new version of control logic in a deterministic fashion. Additional information about an example deterministic execution environment may be found in the two patent applications incorporated by reference above.

Although illustrates one example of a process control system various changes may be made to . For example a control system could include any number of process elements controllers servers and operator stations. Also illustrates one operational environment in which the live loading of version upgrades could be used. The live loading mechanism could be used in any other suitable process control or non process control device or system.

In this example embodiment the execution environment includes a global assembly cache GAC . The global assembly cache represents a memory capable of storing different assembly code programs to be executed in the execution environment . The assembly code programs could represent assembly code versions of function block algorithms or other control logic for controlling one or more of the process elements of . The assembly code version of a function block algorithm or other control logic may be referred to as assembly control logic. The global assembly cache could store multiple assembly code programs and or different versions of the same assembly code program. The global assembly cache represents any suitable storage and retrieval device or devices. Assembly control logic could include program code and possibly metadata that describes one or more attributes of the assembly control logic and its program code. In some embodiments an application may register in the execution environment and receive a notification whenever assembly control logic is stored in a specified location in the global assembly cache .

An assembly loader loads assembly code into the execution environment for execution. For example the assembly loader may retrieve new assembly code downloaded into the global assembly cache . The assembly loader may then load the identified assembly code into a compiler for compilation and use in the execution environment . The assembly loader includes any hardware software firmware or combination thereof for loading assembly code for compilation. The assembly loader could for example represent a software thread executed in the background of the execution environment .

An ahead of time AOT compiler compiles the assembly code loaded by the assembly loader . The AOT compiler represents a load time compiler that compiles assembly code when the assembly code is loaded. For example the AOT compiler may convert assembly code from an intermediate language to native executable code capable of being executed in the execution environment . Also the AOT compiler could insert instructions into the native executable code to ensure proper execution of the code in the execution environment . The AOT compiler includes any hardware software firmware or combination thereof for compiling assembly code. The AOT compiler could for example represent a software thread executed in the background of the execution environment .

The AOT compiler produces native executable code such as native executable codes . The native executable codes represent executable code capable of being executed in the execution environment . The native executable codes could provide any suitable functionality in the execution environment . For example the native executable codes could represent executable versions of assembly control logic used to control one or more process elements of . The native executable codes could provide any other or additional functionality in the execution environment .

One or more application domains represent the domains in which the native executable codes are executed in the execution domain . Each application domain represents any suitable domain for executing one or more native executable codes . While shown as a single application domain in multiple application domains could be used.

The assembly codes and native executable codes in the execution environment are managed by a code manager . For example the code manager may control the loading and unloading of assembly code into and out of the execution environment . As a particular example the code manager could cause the assembly loader to load assembly code into the AOT compiler which generates native executable code that is loaded into the application domain . The code manager could also unload native executable code from the application domain . The code manager includes any hardware software firmware or combination thereof for managing assembly code and or compiled code used in the execution environment . The code manager could for example represent a software thread executed in the background of the execution environment .

The execution environment also includes a memory manager . The memory manager manages the use of memory such as a heap memory. For example the memory manager could allocate blocks of memory to managed applications being executed in an application domain . The memory manager could also use garbage collection information to release blocks of memory that are no longer being used by the managed applications. The garbage collection information could for example be generated by a garbage collection process provided by the memory manager and executed in the background of the execution environment . Additional information about an example garbage collection process may be found in the two patent applications incorporated by reference above. In addition the memory manager could support a defragmentation process for the memory. The defragmentation process could be used to combine unused blocks of memory into larger blocks. The memory manager includes any hardware software firmware or combination thereof for managing memory. The memory manager could for example represent a deterministic memory manager. The memory manager could also represent a software thread executed in the background of the execution environment . In some embodiments an application may register in the execution environment and receive a notification whenever the memory manager completes an operation such as a garbage collection process.

The execution environment further includes an exception table which stores exception information . The exception information identifies various problems experienced in the execution environment . Example problems could include attempting to load assembly code that does not exist in an explicitly specified location or in the global assembly cache an error during compilation of loaded assembly code or attempting to unload assembly code not previously loaded. An application or process being executed in the execution environment could generate an exception identifying a detected problem. The exception is identified by the exception information which is stored in the exception table for later use such as during debugging or for use by the application or process for automatic recovery at runtime.

In addition the execution environment includes a live load controller . The live load controller supports the updating of existing object instances and or the creation of new object instances for a new version of control logic executed in the execution environment . For example the live load controller could determine if old and new versions of control logic define a class having the same class layout meaning both versions define the same data elements for the class. If so the live load controller could determine that only the methods in the class have changed and the live load controller could update existing object instances to identify the new methods. If not the live load controller could create new object instances and transfer the state data from the old object instances to the new object instances. The live load controller includes any hardware software firmware or combination thereof for supporting the live loading of control logic. The live load controller could for example represent a software thread executed in the background of the execution environment . In some embodiments assembly control logic could represent a dynamic link library a DLL or .dll or other file and an application that executes or uses the assembly control logic could represent an executable .exe or other file. In particular embodiments updating the control logic could involve updating the .dll file without altering the .exe file.

A scheduler is used to schedule execution of the control logic and other managed applications. The scheduler may also be used to schedule execution of housekeeping tasks in the execution environment . The housekeeping tasks include among other things memory management assembly loading and unloading assembly compilation and live loading. For example the scheduler could support time slicing to allow multiple threads to be executed where the threads represent the housekeeping tasks and the managed applications. The scheduler includes any hardware software firmware or combination thereof for scheduling the execution of applications and other tasks. In particular embodiments a single scheduler could be associated with one or multiple dynamic link libraries .dll files or other control logic.

In some embodiments the various components shown in operate over a platform operating system abstraction layer. The platform operating system abstraction layer logically separates the execution environment from the underlying hardware platform or operating system. In this way the execution environment may be used with different hardware platforms and operating systems without requiring the execution environment to be specifically designed for a particular hardware platform or operating system.

Although illustrates one example of an execution environment various changes may be made to . For example the functional division shown in is for illustration only. Various components in could be combined or omitted and additional components could be added according to particular needs.

The controller executes one version of assembly control logic at step . This may include for example the controller executing one or more native executable codes that correspond to a current version of assembly control logic stored in the global assembly cache . The one or more native executable codes may represent an executable program an .exe program that operates using one version of a DLL assembly.

A new version of the assembly control logic is placed into a designated live load location at step . The designated live load location may represent a location in a file system such as a directory that is designated to receive code to be used during a live load. As a particular example this could include a user downloading the new version of the assembly control logic into a specified location in the global assembly cache .

An event is generated at step . In some embodiments an internal thread monitors the designated live load location and raises an event when assembly code is loaded into the designated live load location. As noted above the executable program may register with the execution environment to receive this event. In particular embodiments the event identifies the name and version number of the new version of the assembly control logic.

The controller captures information about the new version of the assembly control logic at step . This may include for example the executable program receiving the name and version number of the new version of the assembly control logic via the event. This information may be captured in any suitable manner such as by receiving this information as parameters in a callback to the executable program.

The controller initiates a loading of the new version of the assembly control logic at step . This may include for example the executable program using an application programming interface API call to invoke loading of the new version of the assembly control logic. As a specific example the API call could cause the code manager to initiate a load of the new version of the assembly control logic into the execution environment . The API could be synchronous or asynchronous and could take the assembly name and version information as parameters.

The controller determines whether the new version of the assembly control logic has already been loaded at step . This may include for example the code manager determining if assembly control logic with the same name and version number has already been loaded into the execution environment . If so the controller raises an exception and the method ends. Any suitable actions can take place at this point such as removing the new version of the assembly control logic from the live load location.

Otherwise the controller loads the new version of the assembly control logic at step and compiles the new version of the assembly control logic at step . This may include for example the assembly loader loading the new version of the assembly control logic into the compiler which compiles the new version of the assembly control logic into native executable code. Any suitable actions can take place at this point such as informing the executable program that loading and compilation are complete.

Although illustrates one example of a method for preparing for a live load of a version upgrade in a process control environment various changes may be made to . For example any other suitable technique could be used to load and compile a new version of assembly control logic. Also while shown as a series of steps various steps in could occur in parallel or could be performed in a different order.

The steps in the method may occur after the steps of the method have been completed. In this example the executable program itself decides which object instances should undergo a live load based on its own application logic. The executable program typically holds references to its own object instances and therefore no search typically needs to be performed to locate references to these object instances. Moreover in particular embodiments the executable program migrates all object instances associated with the old version of assembly control logic to object instances associated with the new version of the assembly control logic.

The controller initiates a live load at step . This may include for example the executable program issuing an appropriate API call to the live load controller . As parameters the API could take the assembly control logic s name an old version number a new version number and a list of object instances on which live load has to be performed to migrate to a new version of the assembly control logic.

The controller replaces the compiled code for the old version of the assembly control logic with the compiled code for the new version of the assembly control logic at step . This may include for example the live load controller causing the execution environment to begin executing the native executable code for the new version of the assembly control logic in place of the native executable code for the old version of the assembly control logic.

The controller selects the next object instance to be migrated at step . This may include for example the live load controller selecting the next object instance from the list of object instances provided as a parameter to the API.

The controller compares a first class layout for the selected object instance as defined by a class in the old version of the assembly control logic to a second class layout for the selected object instance as defined by a class in the new version of the assembly control logic at step . This may include for example the live load controller determining whether the data elements defined by the class in the new version of the assembly control logic are the same as the data elements defined by the class in the old version of the assembly control logic.

If the class layouts are identical the controller updates the method information for the selected object instance at step . In this case the only changes made to the class associated with the selected object instance may relate to the object instance s methods or behaviors. Therefore only the method information for the selected object instance is updated so that the object instance now identifies the updated methods.

Otherwise if the class layouts are different a new object instance is created for the selected object instance at step . This may include for example the live load controller creating a new object instance using the appropriate class in the new version of the assembly control logic. The data elements in the new object instance are initialized at step . This may include for example providing each data element with a user specified default value or a default value based on the data type of that data element. The current value of each data element in the selected object instance is transferred into the corresponding data element in the new object instance at step . This may include for example the live load controller reading data from the selected object instance and writing that data to the new object instance.

The controller determines if additional object instances remain to be processed at step . This may include for example the live load controller determining if any additional object instances remain to be processed in the list of object instances provided as a parameter to the API. If so the controller returns to step to select another object instance.

Otherwise the controller returns all new object instances to the executable program which replaces the old object instances with the new object instances at step . In some embodiments switching from an old object instance to a new object instance can be performed within two execution cycles. During the first execution cycle the executable program takes the old object instance off line by marking it as inactive. During the second execution cycle the executable program places the new object instance on line by marking it as active. In particular embodiments the old object instances may not be referenced by any code in the controller and they may be reclaimed during a later garbage collection process or other process.

The controller marks the old version of the assembly control logic as inactive at step . This may include for example the executable program making an appropriate API call to mark the old version of the assembly control logic as inactive. From this point any additional object instances are allocated using the new version of the assembly control logic.

The controller receives a notification from a heap memory manager at step . This may include for example the memory manager providing an indication that there are no more existing object instances that were allocated using the old version of the assembly control logic. This may occur after any existing object instances are reclaimed during garbage collection. The executable program may have previously registered to receive this notification.

The controller then unloads the old version of the assembly at step . This may include for example the executable program calling the appropriate API to cause the code manager to unload the old version of the assembly control logic. This may also include the code manager removing the native executable code for the old version of the assembly control logic from the application domain .

Although illustrate one example of a method for live loading of a version upgrade in a process control environment various changes may be made to . For example while shown as a series of steps various steps in could occur in parallel and could be performed in a different order.

The steps in the method may occur after the steps of the method have been completed. In this example the executable program is not aware of which object instances should undergo a live load.

The controller sets a live load ready flag at step . This may include for example the executable program setting the live load ready flag to the appropriate value indicating that a live load is desired. The live load ready flag could represent any suitable type of flag or other indicator. The executable program then continues with its normal execution.

At some point the controller initiates a heap manager garbage collection process at step . The garbage collection process is designed to recover unused memory that has been allocated to executing programs. If the live load ready flag was not set the garbage collection process would occur as usual. However because the live load ready flag is set the garbage collection process operates as follows. The controller scans a memory block that is in use at step and determines if that memory block contains an old object instance at step . This may include for example the memory manager scanning a block of memory and using a header of the block to determine if the block contains a valid object instance. If the block contains an object instance the memory manager may determine whether the object instance was created using an old version of assembly control logic or a new version of the assembly control logic. If created using the old version of the assembly control logic the controller records the address of that object instance and any address such as a stack address or an address of another object instance that references this object instance.

The controller determines whether more memory blocks remain to be scanned at step . If so the controller returns to step to scan the next memory block. Otherwise the garbage collection process is complete and the controller sends a notification indicating that the garbage collection process is complete to the executable program at step . The executable program may have previously registered to receive this notification.

At this point the garbage collection process has been used to identify a set of object instances and the method continues by migrating these object instances over to new object instances if necessary during a live load. The remaining steps in are similar to the steps shown in .

The controller initiates a live load at step . The controller replaces the compiled code for the old version of the assembly control logic with the compiled code for the new version of the assembly control logic at step . The controller selects the next object instance recorded during the garbage collection process at step . This may include for example the live load controller selecting the next object instance from the set of object instances identified by the memory manager during the garbage collection process.

The controller compares first and second layouts of the selected object instance as defined by classes in the old and new versions of the assembly control logic at step . If the layouts are identical the controller updates the method information for the selected object instance at step . Otherwise a new object instance is created for the selected object instance at step the data elements in the new object instance are initialized at step and the current value of each data element in the selected object instance is transferred into the appropriate data element in the new object instance at step .

The controller updates references to the selected object instance at step . This may include for example the live load controller using the addresses the ones that reference the selected object instance that were recorded in step . These recorded addresses are used to update references from the selected object instance to the new object instance. As a result no references may remain to the old object instance and the memory occupied by the old object instance may be reclaimed during a later garbage collection process or other process.

If more recorded object instances remain to be processed the controller returns to step . Otherwise the controller marks the old version of the assembly control logic as inactive at step receives a notification from the heap memory manager that there are no more object instances allocated using the old version of the assembly control logic at step and unloads the old version of the assembly control logic at step .

Although illustrate another example of a method for live loading of a version upgrade in a process control environment various changes may be made to . For example while shown as a series of steps various steps in could occur in parallel and could be performed in a different order.

In some embodiments various functions described above are implemented or supported by a computer program that is formed from computer readable program code and that is embodied in a computer readable medium. The phrase computer readable program code includes any type of computer code including source code object code and executable code. The phrase computer readable medium includes any type of medium capable of being accessed by a computer such as read only memory ROM random access memory RAM a hard disk drive a compact disc CD a digital video disc DVD or any other type of memory.

It may be advantageous to set forth definitions of certain words and phrases used throughout this patent document. The term couple and its derivatives refer to any direct or indirect communication between two or more elements whether or not those elements are in physical contact with one another. The term application refers to one or more computer programs sets of instructions procedures functions objects classes instances or related data adapted for implementation in a suitable computer language. The terms include and comprise as well as derivatives thereof mean inclusion without limitation. The term or is inclusive meaning and or. The phrases associated with and associated therewith as well as derivatives thereof may mean to include be included within interconnect with contain be contained within connect to or with couple to or with be communicable with cooperate with interleave juxtapose be proximate to be bound to or with have have a property of or the like. The term controller means any device system or part thereof that controls at least one operation. A controller may be implemented in hardware firmware software or some combination of at least two of the same. The functionality associated with any particular controller may be centralized or distributed whether locally or remotely.

While this disclosure has described certain embodiments and generally associated methods alterations and permutations of these embodiments and methods will be apparent to those skilled in the art. Accordingly the above description of example embodiments does not define or constrain this disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure as defined by the following claims.

