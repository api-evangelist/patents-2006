---

title: Method, system, and program storage device for generating a retry message when a thread in a real-time application is unavailable to process a request to utilize the real-time application
abstract: A method, system and program storage device for preventing a real-time application from running out of free threads when the real-time application receives a device interface request. A set of special data packets for the main user application is provided. Shared functions are provided as part of the device interface to indicate the error condition when there is no more free thread and for a utility program to recognize a retry is needed. Thus, the retry mechanism is embedded in the shared functions running on both the main user application and all utility programs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07962926&OS=07962926&RS=07962926
owner: International Business Machines Corporation
number: 07962926
owner_city: Armonk
owner_country: US
publication_date: 20060405
---
This invention relates in general to a computer programming and more particularly to a method system and program storage device for preventing a real time application from running out of free threads when the real time application receives a device interface request.

In a highly competitive market environment time to market with superior quality is the key focus in developing a new product. For a well established development team with years of experience in software development the reusability of existing software is the very key to achieving the goals of delivering a new product in the most efficient way with superior quality. Given the stiff competition in the market environment what a new product is required to do is constantly increasing and how much it is allowed to cost is reducing. For a software product development the demanding requirements and pressure of lowering cost are translated into the need for the reuse of existing software functions in various hardware platforms. One of the focus items to achieve high software reusability is to develop the software functions with the encapsulation of a platform they are operating upon. The platform includes the actual hardware and the operating systems.

One key consideration in selecting a platform for a product is whether the software can best perform in privileged mode or user mode. In contrast kernel mode or privileged mode is the mode in which the operating system kernel runs. Code running in this mode has unlimited access to the system memory and external devices.

The traditional thinking is software can best perform in privileged mode. However given the advancing technology in hardware platform development operating in user mode may be a much better choice given different product requirements. The built in protection provided by all modern operating systems for a software running in user mode the ease of managing a program in a user mode and the improved system stability with new software functions isolated from kernel are significant benefits of implementing a software project in user mode.

For a software product family to maintain high reusability across a range of products that may be operating in various platforms a consistent device interface is a key for the software functions it provides to be invoked consistently. A software product consists of a set of key software components and software applications which may be implemented as collaborating privileged and user mode applications to provide the functionality intended by the software product. In a user mode implementation of a real time software application the software product also provides a user mode device interface using socket interface.

For a real time user application to run on a particular platform that has a relatively small run time memory constraints one design is to create a finite number of threads in a thread pool to handle all incoming device interface requests from other utility programs. The number of threads in a thread pool may be predetermined. Each device interface request to the real time user application is handled by a thread in the pool that is free i.e. not busy. Once a request is completed the thread returns to the free thread pool waiting for the next incoming request.

However the real time application can run out of free threads upon the receipt of a new request because there are only a finite number of threads in the pool and because many utility programs can be making device interface requests to the real time user application at the same time. A typical solution is to increase the number of the free threads in the pool. Unfortunately the solution causes the real time application to allocate demand more from the limited total resource for a condition that is rarely reached. Another typical solution to the same problem is to return an error condition to a utility program to indicate it is temporarily unable to handle such request. A big issue with this error reporting approach is it would cause utility program to implement additional error handling for a temporary resource contention.

A better solution to this problem is needed so the real time application does not keep increasing its allocation for resource to support more free threads and at the same time utility programs do not have to implement additional error handling for a temporary unavailability of threads to handle device interface requests.

There is a need for a method system and program storage device for preventing a real time application from running out of free threads when the real time application receives a device interface request.

To overcome the limitations in the prior art described above and to overcome other limitations that will become apparent upon reading and understanding the present specification the present invention discloses a method system and program storage device to implement an embedded retry mechanism at the device interface level to avoid error handling at the utility level and to avoid excess allocation of resource on an already constrained system

The present invention solves the above described problems by incorporating an embedded retry mechanism in the user mode interface. As an enhancement to the device interface a set of special data packets for the main user application is provided. Shared functions are provided as part of the device interface to indicate the error condition when there is no more free thread and for a utility program to recognize a retry is needed. Thus the retry mechanism is embedded in the shared functions running in both the main user application and all utility programs.

A user mode device interface according to an embodiment of the present invention includes a retry mechanism for generating a new retry response to a request initiated by a device open packet when a thread for processing the request is unavailable.

In another embodiment of the present invention a computing system is provided. The computer system includes a processor having a user mode and a protected kernel mode and a memory coupled to the processor the memory including program code executing in the processor for providing a user mode device interface. The user mode device interface includes a retry mechanism for generating a retry response to a new request initiated by a device open packet when a thread for processing the request is unavailable.

In another embodiment of the present invention a program storage device including program instructions executable by a processing device to perform operations for preventing a real time application from running out of free threads when the real time application receives a device interface request is provided. The operations include generating by a utility program a device request by calling a shared function sending to a main user application a device open data packet making a device request searching for a free thread at the main user application determining whether a free thread is available and sending a retry needed packet to the utility program when a free thread is unavailable.

In another embodiment of the present invention a method for preventing a real time application from running out of free threads when the real time application receives a device interface request is provided. The method includes generating by a utility program a device request by calling a shared function sending to a main user application a device open data packet making a device request searching for a free thread at the main user application determining whether a free thread is available and sending a retry needed packet to the utility program when a free thread is unavailable.

These and various other advantages and features of novelty which characterize the invention are pointed out with particularity in the claims annexed hereto and form a part hereof. However for a better understanding of the invention its advantages and the objects obtained by its use reference should be made to the drawings which form a further part hereof and to accompanying descriptive matter in which there are illustrated and described specific examples of an apparatus in accordance with the invention.

In the following description of the embodiments reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration the specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized because structural changes may be made without departing from the scope of the present invention.

The present invention provides a method system and program storage device for preventing a real time application from running out of free threads when the real time application receives a device interface request. A set of special data packets for the main user application is provided. Shared functions are provided as part of the device interface to indicate the error condition when there is no more free thread and for a utility program to recognize a retry is needed. Thus the retry mechanism is embedded in the shared functions running on both the main user application and all utility programs.

The computer system and the allocation of system resources to the computer system are controlled by operating system . For the purpose of the present discussion it is assumed that operating system is resident within primary memory although those skilled in the art will appreciate that certain infrequently utilized segments of operating system may be swapped out to secondary memory by memory manager . Operating system includes kernel which comprises the lowest layer of operating system that interacts most directly with the computer system . Kernel dispatches kernel threads to processors for execution provides services to device drivers interfacing with hardware within computer system and implements system services memory management network access and the file system utilized by computer system . In addition to kernel primary memory also stores frequently utilized segments of application software . As is well known to those skilled in the art application software communicates with operating system through an Application Programming Interface API .

Computer system also includes bus interface through which multiple nodes can interface to system resources available within computer system . As will be appreciated by those skilled in the art computer system may also include additional hardware coupled to system bus that is not necessary for an understanding of the present invention and is accordingly omitted for simplicity.

Processes that run in kernel mode can directly access system data and hardware and are not restricted like processes running in user mode . Performance sensitive drivers and services run in kernel mode to interact with hardware more efficiently. All components for processes running in kernel mode are fully protected from applications running in user mode . Processes that run in user mode are effectively isolated from processes running in kernel mode and other processes running in user mode .

In a thread for a process running in user mode is characterized as having its own context including registers and user stack . A user stack is a data structure that includes a series of memory locations and a pointer to the initial location. All processors provide instructions for placing and retrieving values to and from the user stack . The user memory is a block of memory that is dedicated to the use of a current process running in user mode . A complete user state of a thread is maintained in user registers .

The kernel operates in its own protected address space and includes its own registers and kernel stack . The kernel maintains the integrity of its own data structures and that of other processes. The kernel stack includes information used by the kernel. Kernel memory is generally shared by all processes but is only accessible in kernel mode . Context switches from one task to another happen on the kernel stack of the current process.

As shown in the first application wants to use software functions of the second application i.e. the main user application . According to an embodiment of the present invention the user mode device interface enables software functions of the main user application to be reused and re implemented. The user mode device interface provides a consistent interface to invoke the functions of the main user application . The user mode device interface provides an embedded retry mechanism as an enhancement to the device interface. The retry mechanism introduces a set of special data packets for the main user application to indicate the error condition when there a free thread is unavailable and for the first application to recognize that a retry is needed. Because there is a set of shared functions provided as part of the device interface the retry mechanism is embedded in the shared functions running on both the main user application and the first application .

When the first application makes a request to the main user program the first application has to call one of the shared functions to make such a request. A device open data packet is sent to the main user program . The main user program then looks for a free thread for processing the request. If a free thread is not available a retry needed packet is returned to the first application . The retry is completely transparent to the first application when it is in progress which means the first application does not have to worry about implementing any error handling.

The utility program merely experiences a longer delay to the completion of a request while a retry is in progress. The delay does not cause a problem because the device interface is always expected to be a synchronous interface i.e. a utility program making a request has to wait for the completion of a request before it can proceed with its own processing.

In when utility program on the client side makes a request to a main user application on the server side a shared function is called. A Device Open data packet is first sent to the server side which signals the server side that a device interface request has been received. In response to receipt of the device open packet the server side of socket communication state machine looks for available threads . When the server side of socket communication state machine finds all available threads are currently busy handling request the server side of socket communication state machine responds to the device open packet with a retry needed data packet . If a thread is available the server side of socket communication state machine returns the results with a request completed packet .

When a retry needed packet is received the client side of socket communication state machine suspends the process for a period time. Since the shared function at this point is still running in the context of a utility program making a request to the server side of socket communication state machine the client side of socket communication state machine has all the information it needs to retry the same device request. Once the sleep time expires the shared function retries the same device open again to the server side of socket communication state machine and only proceeds when a request completed packet is received. The client side of socket communication state machine includes a retry count to prevent infinite retry attempts. Once a maximum number of attempts to retry the device open has been executed the next retry needed packet from the server side of socket communication state machine causes the shared function to surface the error back to the utility program. On the server side of socket communication state machine there is no need to keep track of what request is being retried. Once a retry needed response is sent back to a utility program the server side of socket communication state machine considers it as a completion to handle such a request and simply tells the client to try again later.

For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The medium may be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly to the system or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the system to become coupled to other data processing systems remote printers or storage devices through intervening private or public networks not shown . Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

Accordingly the computer program comprise instructions which when read and executed by the system of causes the system to perform the steps necessary to execute the steps or elements of the present invention

The foregoing description of the embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not with this detailed description but rather by the claims appended hereto.

