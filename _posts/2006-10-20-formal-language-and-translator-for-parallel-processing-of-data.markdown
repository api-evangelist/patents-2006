---

title: Formal language and translator for parallel processing of data
abstract: The present invention, in an example embodiment, provides a special-purpose formal language and translator for the parallel processing of large databases in a distributed system. The special-purpose language has features of both a declarative programming language and a procedural programming language and supports the co-grouping of tables, each with an arbitrary alignment function, and the specification of procedural operations to be performed on the resulting co-groups. The language's translator translates a program in the language into optimized structured calls to an application programming interface for implementations of functionality related to the parallel processing of tasks over a distributed system. In an example embodiment, the application programming interface includes interfaces for MapReduce functionality, whose implementations are supplemented by the embodiment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07921416&OS=07921416&RS=07921416
owner: Yahoo! Inc.
number: 07921416
owner_city: Sunnyvale
owner_country: US
publication_date: 20061020
---
The present invention relates in general to formal languages and translators such as preprocessors and interpreters and in particular to a formal language and a translator that in some embodiments might be used to effectuate the parallel processing of multiple large databases using a distributed system e.g. a computing network with a distributed file system.

Some computer programs such as search engines must process extensive amounts of data. In the course of this processing these programs often create huge files which tend to take the form of a flat file database e.g. a table of entries which are separated by delimiters but which lack the structural relationships one would find in a relational or object database. Colloquially one might refer to a flat file database as a spreadsheet or a log file.

In order to express a computation over large databases programmers must either develop simple non parallel scripts which take a long time to run or complex parallel scripts which take a long time to implement debug and maintain. Consequently there has been considerable effort to develop systems that allow programmers to create computational expressions which are relatively simple and which are processed in parallel over a distributed system possibly comprising a high availability cluster of commodity servers.

In this regard the Apache Software Foundation has developed a collection of programs called Hadoop named after a toddler s stuffed elephant which consists of a a distributed file system see U.S. Pat. No. 7 065 618 whose disclosure is incorporated herein by reference and b an application programming interface API and corresponding implementation of the MapReduce functionality developed by Jeffrey Dean and Sanjay Ghemawat. As to the latter functionality see Scalable Computing with MapReduce by Doug Cutting Aug. 3 2005 OSCON . While an improvement over what went before programmers using Hadoop must still implement debug and maintain relatively complex computational expressions in the form of structured calls to the interfaces in the Hadoop API and or significantly extend Hadoop s implementation and possibly also its API in order to efficiently process large databases in parallel using a distributed system.

Formal languages and their corresponding translators enable computational expression. A formal language might comprise a programming language or a scripting language. Some programming languages are procedural or imperative such as C and Java. These languages typically require that the programmer specify an algorithm in terms of instructions to be executed or run by a computing platform.

Other programming languages are declarative and allow the programmer to specify the result to be achieved leaving the implementation for achieving the result to other supporting software. An example of a declarative programming language is Structured Query Language SOL which is ordinarily used to process data in a relational database. A scripting language might be a general purpose language such as Perl or a special purpose or application specific language such as Game Maker Language. To specify a formal language one might create a formal grammar for that language such as a context free grammar.

A translator is a program that takes another program as its input. A translator might be a preprocessor or pre compiler such as a C preprocessor a compiler such as a C compiler or a Java JIT Just In Time compiler or an interpreter such as a Perl interpreter. Typically a preprocessor runs before a compiler and performs textual substitution on source code programs. In the case of embedded SQL the SQL preprocessor or pre compiler substitutes procedure calls to an API for declarative SQL statements embedded in a host source code program written in a procedural language such as C or COBOL. In Java embedded SQL often involves the use of an API called Java Database Connectivity JDBC which in turn makes use of an API called Open Database Connectivity ODBC .

The difference between a compiler and an interpreter is that a compiler is a pure translator that translates its input program into a program in another language typically byte code or executable machine code. An interpreter ordinarily executes its input program on the interpreter s computing platform.

One might think of a translator such as an interpreter as having a front end parser and a back end interpreter. Typically the front end parser will translate an input program into an intermediate representation such as an abstract syntax tree while detecting any lexical syntactic or semantic errors dictated by the language specification. Then the back end interpreter will execute the intermediate representation e.g. by walking the abstract syntax tree.

Likewise one might think of a translator such as a compiler as having a front end parser and a back end code generator. Typically the front end parser will translate a source code program into an intermediate representation and the back end code generator will generate optimized code e.g. executable machine code from the intermediate representation.

In some embodiments the present invention provides a formal language and a translator for that language. The formal language is a special purpose formal language that facilitates the expression of parallel computations processing large databases over a distributed system. In particular embodiments the formal language builds upon the commands found in the SQL language and allows the declarative co grouping of tables each with an arbitrary alignment function.

Also in some embodiments of the present invention the formal language includes features which are characteristic of a procedural rather than a declarative language. Thus for example the formal language supports the specification of procedural operations to be performed on a co grouping of tables.

In some embodiments of the present invention the formal language s translator comprises a preprocessor or parser which translates statements in the formal language into optimized calls to an API providing interfaces to implementations of functionality for the parallel processing of tasks over a distributed system. In particular embodiments the translator further provides supplemental implementations to existing parallel processing functionality. In some embodiments the parallel processing functionality includes a distributed file system and procedures to process a job divided into tasks on a plurality of network nodes.

The following detailed description together with the accompanying drawings will provide a better understanding of the nature and advantages of the present invention.

The following example embodiments are described and illustrated in conjunction with apparatuses methods and systems which are meant to be examples and illustrative not limiting in scope.

Multiple nodes also facilitate the parallel processing of large databases. In some embodiments of the present invention a master server such as receives a job from a client such as and then assigns tasks resulting from that job to slave servers or nodes such as servers which do the actual work of executing the assigned tasks upon instruction from the master and which move data between tasks. In some embodiments the client jobs will invoke Hadoop s MapReduce functionality as supplemented by the present invention.

Likewise in some embodiments of the present invention a master server such as server governs the distributed file system needed to support parallel processing of large databases. In particular the master server manages the file system s namespace and block mapping to nodes as well as client access to files which are actually stored on slave servers or nodes such as . In turn in some embodiments the slave servers do the actual work of executing read and write requests from clients such as and perform block creation deletion and replication upon instruction from the master server. Here again in some embodiments the distributed file system might be the file system provided by Hadoop. In this regard see the documentation for Hadoop maintained by the Apache Software Foundation including the FrontPage to the Lucene hadoop Wiki.

The elements of hardware system are described in greater detail below. In particular network interface provides communication between hardware system and any of a wide range of networks such as an Ethernet e.g. IEEE 802.3 network etc. Mass storage provides permanent storage for the data and programming instructions to perform the above described functions implemented in the RF coverage map generator whereas system memory e.g. DRAM provides temporary storage for the data and programming instructions when executed by processor . I O ports are one or more serial and or parallel communication ports that provide communication between additional peripheral devices which may be coupled to hardware system .

Hardware system may include a variety of system architectures and various components of hardware system may be rearranged. For example cache may be on chip with processor . Alternatively cache and processor may be packed together as a processor module with processor being referred to as the processor core. Furthermore certain embodiments of the present invention may not require nor include all of the above components. For example the peripheral devices shown coupled to standard I O bus may couple to high performance I O bus . In addition in some embodiments only a single bus may exist with the components of hardware system being coupled to the single bus. Furthermore hardware system may include additional components such as additional processors storage devices or memories.

In particular embodiments the translating and processing functionality described herein is implemented as a series of software routines run by hardware system . These software routines comprise a plurality or series of instructions to be executed by a processor in a hardware system such as processor . Initially the series of instructions are stored on a storage device such as mass storage . However the series of instructions can be stored on any suitable storage medium such as a diskette CD ROM ROM EEPROM etc. Furthermore the series of instructions need not be stored locally and could be received from a remote storage device such as a server on a network via network communication interface . The instructions are copied from the storage device such as mass storage into memory and the accessed and executed by processor .

An operating system manages and control the operation of hardware system including the input and output of data to and from software applications not shown . The operating system provides an interface between the software applications being executed on the system and the hardware components of the system. According to one embodiment of the present invention the operating system in the LINUX operating system. However the present invention may be used with other suitable operating systems such as the Windows 95 98 NT XP operating system available from Microsoft Corporation of Redmond Wash. the Apple Macintosh Operating System available from Apple Computer Inc. of Cupertino Calif. UNIX operating systems and the like.

The first step of the process involves lexical analysis of the input program s text. In this step an embodiment of the present invention might break that text up into a sequence of small pieces called tokens which sequence becomes the input for the second step . Tokens include keywords in the formal language. Lexical analysis might also involve detection of errors such as the use of a textural character or symbol which is invalid in the formal language for example the at sign character .

The second step of the translation process involves syntactic and semantic analysis of the input program. In this step a particular embodiment of the present program might check the token sequence for compliance with the formal language s grammar an example of which is shown in and and emit errors in the event of noncompliance. Also during this step a particular embodiment might create an intermediate representation and a symbol table which associates each symbol such as an identifier with a location data type and other attributes.

The third step of the process involves the generation of optimized structured calls to an API for implementations of functionality for parallel processing over a distributed system. The structure in these structured calls will ordinarily flow from the intermediate representation. In some embodiments the structure of these structured calls will be optimized e.g. by folding multiple statements in the formal language into a single API call whenever possible. As indicated above in some embodiments the API might be the Hadoop API whose API Docs are maintained by the Apache Software Foundation. In such embodiments the process might fold multiple say k statements in the formal language into a single Map Reduce command if the first k 1 statements in the formal language do not request grouping or co grouping. Generally speaking this type of optimization during translation is referred to as query optimization .

The fourth step of the process is the generation of supplemental implementations for the API in particular embodiments. Some embodiments where this might be necessary are embodiments which use the interfaces in the Hadoop API and the corresponding Hadoop implementations. In these embodiments the present invention generates custom implementations for the Map Reduce InputFormat and OutputFormat interfaces. The present invention then submits the custom implementations of these interfaces to Hadoop as part of a client s job. Here recall the above description of master and slave servers. In particular embodiments the custom implementations of these interfaces might extend Hadoop functionality to allow for multiple inputs input specific functions null reduces during the Reduce phase without identity partitioning correlation of records to inputs during the Reduce phase of processing and function pipelines in the Map and Reduce phases of processing.

The fifth step of the process is the actual execution of the API calls using the corresponding implementations of functionality for disturbed parallel processing. In particular embodiments these implementations might be the Hadoop implementations as supplemented by the custom implementations just described.

More technically speaking co grouping is a primitive that takes two or more input relations and assigns tuples of the relations to groups. The output is one tuple per group where the tuple has the form where denotes boundaries of the tuple and denotes a set. The advantage of this construct is that it gives a convenient and compact representation of data that belongs to each group and allows highly flexible within group post processing.

As indicated above in a typical EVAL OVER statement in the formal language there is arbitrary user code in only two places which in turn provides opportunities for optimization of the implementation of the computations expressed in the statement. First the per group computation is arbitrary but the translator in some embodiments may generate the groups and assign them to particular machines in any way it chooses. Second the computation of the grouping key for each record of a table is arbitrary but once the key has been computed the translator may compute the groups using any technique it chooses.

In particular embodiments the database tables upon which the formal language operates need not be the relational database tables that one sees in a standard SQL database system they can be flat file databases or tables. That is to say the formal language requires no pre registration of data so that when the user specifies a particular input table he she can specify in one shot the file containing the data and the representation of the data. Stored schema are optional in some embodiments.

Returning to it will be appreciated that the formal language builds and improves upon the declarative SQL language. Thus the first column of the first table is called Select expr the first column of the second table is called From Group expr the second column of the second table is called output format i.e. what goes into Select clause and the first column of the third table is called Group expr . Further the entries in the latter column include various forms of GROUP BY expressions SELECT FROM and GROUP BY are all SQL keywords which might be used in a SQL expression such as SELECT books.title FROM books GROUP BY books.author. Indeed one might regard declarative co grouping as a generalization of SQL functionality e.g. the GROUP BY command and join operations wherein the predicate relating groups drawn from different tables is implicit and always equality.

Further in this regard it will be appreciated that SQL has constructs for 1 scanning and grouping of data and 2 custom logic to be applied to groups of tuples . In contrast the formal language only has constructs for declarative scanning and co grouping and defers to user defined functions for custom logic. This separation makes the formal language very simple enabling the programmer to more easily make the connection between the query statements he she writes and the underlying method of evaluation. In particular each OVER statement translates to one pass over the designated relation or relations. Such statements allow for group wise processing with no state carried across group boundaries.

In fact many programmers do not like SQL because it forces them to do acrobatics with their program logic just to get it into declarative form. That is to say they prefer writing in a procedural language which is specifically enabled by the language constructs in the formal language. Additionally it is in general difficult to convert complex SQL statements into efficient parallel programs. This process is called parallel query optimization and tends to work better on paper than in practice. See U.S. Pat. No. 6 112 198. By contrast the formal language does not have any declarative constructs that cannot be evaluated efficiently in parallel.

Specifically the declarative scanning and co grouping of large relations can be done in parallel using the formal language. And as noted above all computations carried out on individual tuples or small groups of tuples are handled via user defined functions. Since groups tend to be small it is typically not important that these computations be transparent or parallelizable. That is to say the formal language s support for procedural computation within a group or co group allows for single node execution assuming that the groups or co groups are small.

Indeed in some embodiments a program in the formal language may be implemented efficiently in parallel using only a sort operator per table and then a global scan of all the tables. Thus the program s computation may be performed without either random access to the data or an unbounded number of passes.

A hypothetical example will illustrate the formal language s grammar and features which might be used with a particular embodiment. The hypothetical example involves data which might be generated by a search engine and assumes two separate databases named QueryResults and Pages where QueryResults has a table with columns labeled Query Position and URL and Pages has a table with columns labeled URL and PageRank see U.S. Pat. No. 6 285 999 as shown below. Note that a query can appear more than once in the column labeled Query if it returns multiple URLs and that PageRank is an absolute ranking independent of any query.

Following is an example program for solving this problem written in SQL where the SQL keywords are in all capital letters. The example SQL program assumes that QueryResults and Pages are relational databases which require a substantial effort to create update and maintain using a relational database management system RDBMS . The example SQL program is purely declarative though it might be embedded in a surrounding procedural program in a host language such as C.

Below is an example program for solving the problem written in the formal language which might be used in particular embodiments. Here again the language keywords are in all capital letters. The program below will work on flat file databases it does not require relational databases though some embodiments of the formal language might operate on such databases. The example program combines features of both declarative languages and procedural languages. Thus the first EVAL statement assigns its resulting tuple to the variable T through the use of an assignment operation . And the second EVAL statement makes use of an algorithm set out in the procedure identified as checkTop5 Tuple t . The example program also illustrates co grouping in the first EVAL statement which includes an OVER clause that declaratively co groups the QueryResults table and the Pages table on the basis of url .

In particular embodiments the present invention might run on client in . Also in some embodiments the present invention might translate the statements in a formal language program into a job consisting of both structured calls to the Hadoop API and custom implementations of the API and transmit the job to the master server in for assignment of tasks to slave servers such as which actually execute the tasks.

Then as shown in the middle of the diagram the data for a particular URL is repartitioned again on the basis of query which was a column in only the QueryResults table. It will be appreciated that this repartitioning places on a single logical node all the data needed to run the procedure check Top5 in the example program on a particular query. At this point in the process each logical node can execute that procedure in parallel and determine a solution to the problem which in this problem would include the query news . Note that www.wsj.com did not appear in the top five positions for the query despite having the highest absolute PageRank .

The example formal language program simply expresses which relations are to be scanned and how they are to be co grouped. The details of what processing to apply to each group occurs inside the user specified procedure check Top5 . This formal language program can be evaluated by performing two passes over the data first jointly partition the two relations on url and then repartition the result on query .

The example SQL program requires more passes over the data if evaluate directly as expressed. In principle a cleverly written query optimizer might restructure the computation to be closer to the form given in the example formal language program but query optimization often fails to produce an efficient rewriting in practice.

In some embodiments of the present invention the formal language s support for co grouping facilitates parallel processing using hashing methods. See generally U.S. Pat. No. 7 085 769.

As discussed above the invention s functionality in some embodiments might be comprised of instructions that are stored on storage media. The instructions might be retrieved and executed by a processing system. The instructions are operational when executed by the processing system to direct the processing system to operate in accord with the present invention.

Some examples of instructions are software program code firmware and microcode. Some examples of storage media are memory devices tape disks integrated circuits and servers. The term processing system refers to a single processing device or a group of inter operational processing devices. Some examples of processing devices are integrated circuits and logic circuitry. Those skilled in the art are familiar with instructions storage media and processing systems.

Those skilled in the art will appreciate variations of the above described embodiment that fall within the scope of the invention. In this regard it will be appreciated that the formal language and its translator might be used with all types of databases not just flat file databases and all types of distributed systems with all types of communication protocols not just the master servant communication protocol. Further it will be appreciated that the translator for the formal language might be any type of translator e.g. a preprocessor a pre compiler a compiler an interpreter etc. with any type of front end parser and any type of back end. As a result the invention is not limited to the specific examples and illustrations discussed above but only by the following claims and their equivalents.

