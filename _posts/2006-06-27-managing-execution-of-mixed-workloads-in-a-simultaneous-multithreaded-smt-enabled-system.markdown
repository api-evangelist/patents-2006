---

title: Managing execution of mixed workloads in a simultaneous multi-threaded (SMT) enabled system
abstract: A SMT enabled processor system, having multiple processors each activated to interleave execution of multiple hardware threads on each processor, for ST workload, includes a kernel. The kernel of the SMT enabled processor system facilitates construction of an exclusive set of processors to simulate an ST mode for handling the tasks of the ST workload, wherein the ST workload runs more efficiently on single threaded processors. The kernel schedules the ST workload on the exclusive set of processors by selecting one hardware thread per processor within said exclusive set of processors to handle a separate one of the tasks of the ST workload, while requiring the remaining hardware threads per processor within the exclusive set to idle. The ST workload is executed on the SMT enabled processor system as if the exclusive set of processors run in ST mode, but without actually removing the remaining idle hardware threads per processor within the exclusive set of processors.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08136111&OS=08136111&RS=08136111
owner: International Business Machines Corporation
number: 08136111
owner_city: Armonk
owner_country: US
publication_date: 20060627
---
The present invention relates generally to processors and computing systems and in particular to a simultaneous multi threaded SMT processor. Further the present invention relates to managing execution of single threaded ST workloads and SMT workloads in a SMT enabled system without switching the processors of the system between ST mode and SMT mode.

Improvement of computing technology requires improving the performance characteristics of computer systems that operate under dynamically changing load requirements. One method of improving the performance of a computer system is through use of multiple processors that share the processing load by executing portions of a computer program or separate computer programs in parallel. Another method of improving the performance of a computer system is by enabling multiple hardware threads to execute on each processor where each thread processes a different workload or a different portion of one or more workloads. In a processing system where multiple hardware threads are active an operating system may support simultaneous multi threading SMT where multiple threads run simultaneously on each processor. For a workload to run across the multiple threads an operating system activates the multiple hardware threads for each processor in a SMT mode.

However while enabling the SMT mode improves the execution time for some types of workloads there are other types of workloads for which activating only one hardware thread per processor would be more efficient. For example high performance computing HPC workloads which require jobs to proceed at the same speed through each processor perform more efficiently where only one hardware thread is active on each processor. To accommodate workloads that run more efficiently where only one hardware thread is active on each processor the operating system may facilitate switching all the processors in the system from running in a SMT mode to a single threaded ST mode. In an ST mode there is only one hardware thread active on each processor. Therefore to switch from SMT mode to ST mode all but one hardware thread on each processor is removed at the processor level.

One limitation of an operating switching between SMT mode and ST mode based on the mode most efficient for the type of workload is that each mode switch requires a dynamic reconfiguration event per hardware thread being removed or activated at the processor level. A dynamic reconfiguration event is time consuming because hardware threads are represented by the operating system as logical processing units. Thus removal or activation of each hardware thread requires separate interrupts at the hardware operating system and application levels to actually disable hardware threads at the hardware level to dynamically reconfigure the available logical processors to only one logical processor per physical processor and to adapt all kernel extensions and applications to only bind to the reconfigured logical processors. Performing a dynamic reconfiguration event on each processor is further limited as the number of processors increases. For example if each dynamic reconfiguration event takes three seconds per processor and there are 64 processors each switch of the SMT enabled processors from ST mode to SMT mode or SMT mode to ST mode could take about 3 minutes.

Another limitation of an operating system switching between SMT mode and ST mode based on the mode most efficient for the type of workload is that the operating system runs all the processors in a system either in SMT mode or ST mode. Because the system operates in one mode or the other when the system is enabled in SMT mode even though processors may sit idle an ST workload will wait until the workload processed in SMT mode is complete and the operating system switches from SMT mode to ST mode.

Therefore in view of the foregoing there is a need for a method system and program for running SMT workloads and ST workloads on a SMT enabled system without switching between modes but with comparable performance to running ST workloads in ST mode. In addition there is a need for a method system and program for running mixed workloads of both SMT workloads and ST workloads concurrently on a SMT enabled system running in SMT mode.

Therefore an embodiment of the invention provides improved management of a SMT enabled processing system. In particular one embodiment of the invention provides a method system and program for managing execution of mixed ST workloads and SMT workloads in a SMT enabled system without switching the processors of the system between ST mode and SMT mode.

In one embodiment of the invention in a SMT enabled processor system for an ST workload the kernel of the SMT enabled processor system facilitates construction of an exclusive set of processors to handle the tasks of the ST workload wherein the ST workload runs more efficiently on single threaded processors. In addition the kernel sets a separate dispatcher for each hardware thread of the exclusive set of processors to only execute work on each local run queue associated with each hardware thread of the exclusive set of processors. The kernel drains any tasks waiting one each local run queue associated with each hardware thread of the exclusive set of processors. Responsive to each hardware thread being placed in an idle mode without any tasks to perform the kernel sets each hardware thread of the exclusive set of processors in a snooze mode wherein only an interrupt awakens each hardware thread placed in snooze mode to search an associated local run queue for waiting tasks. The kernel schedules the ST workload on the exclusive set of processors by selecting one hardware thread per processor within said exclusive set of processors to handle a separate one of the tasks of the ST workload while requiring the remaining hardware threads per processor within the exclusive set to idle. The ST workload is executed on the SMT enabled processor system as if each selected one hardware thread of each of the exclusive set of processors is running in ST mode without removing the remaining idle hardware threads per processor within the exclusive set of processors. The kernel applies each separate task of the ST workload to a separate local run queue of each selected one hardware thread per processor within the exclusive set of processors. The kernel sends an interrupt to wake up the selected one hardware thread per processor.

For an exclusive set of processors the kernel instructs the processors to only search for tasks from local run queues and not to search global run queues for more tasks. The kernel then drains all non bound tasks from the local run queues of the exclusive set of processors to the global run queue and all bound work is completed and each hardware thread in the exclusive set of processors is placed in an idling mode. The kernel places the tasks of the ST workload across the local run queues of the selected one hardware thread per processor in the exclusive set of processors and blocks placement of tasks on the remaining hardware threads of the exclusive set of processors.

In one embodiment the hypervisor upon receiving a ceded hardware thread sets the hardware thread to a snooze more where in snooze mode the hardware thread does not use processor resources and only wakes up and is returned to the idle process responsive to particular interrupts. When the kernel schedules a task on one of the hardware threads of an exclusive processor the kernel triggers an interrupt to wake up the selected one hardware thread per processor. Then the idle process detects the scheduled task for the hardware thread and triggers the dispatcher for the hardware thread to perform the task. The remaining hardware thread per processor continues to remain in snooze mode within minimal use of processor resources such as when periodically awoken by a timer interrupt and passed to the idle process which detects that the remaining hardware thread per process is still without a task to perform.

In another embodiment the hypervisor detects when all the hardware threads for a particular processor are idle and automatically returns the idle hardware threads to the idle process instead of placing each hardware thread in snooze mode. By immediately returning the hardware threads in an exclusive set to the idle process the idle process is constantly checking for a task to be placed on the local run queues of the hardware threads of the exclusive set of processors and quickly begins execution of ST workload tasks once scheduled. Once the hypervisor detects one hardware thread ceded from the idle process but the other hardware thread for the processor no longer set to idle because the ST tasks are being processed the hypervisor places the remaining hardware threads in snooze mode and limits the types of interrupts that trigger waking up the remaining hardware threads of an exclusive set of processors.

Concurrent with managing execution an ST workload on the SMT enabled processing system the kernel handles management of SMT workloads on the SMT enabled processing system on processors not included in an exclusive set. In addition when a ST workload is completed the processors included in the exclusive processor set are freed for use by the kernel in handling management of SMT workloads.

In another embodiment of the invention a SMT enabled processor system includes multiple processors each enabled for simultaneous execution of multiple hardware threads and a memory for storing a kernel for controlling application of workloads to the multiple processors. The kernel of the SMT enabled processor system is operative to facilitate construction of an exclusive set of processors to handle the tasks of the ST workload wherein the ST workload runs more efficiently on single threaded processors. In addition the kernel is operative to set a separate dispatcher for each hardware thread of the exclusive set of processors to only execute work on each local run queue associated with each hardware thread of the exclusive set of processors. The kernel is operative to drain any tasks waiting one each local run queue associated with each hardware thread of the exclusive set of processors. Responsive to each hardware thread being placed in an idle mode without any tasks to perform the kernel is operative to set each hardware thread of the exclusive set of processors in a snooze mode wherein only an interrupt awakens each hardware thread placed in snooze mode to search an associated local run queue for waiting tasks. The kernel is operative to schedule the ST workload on the exclusive set of processors by selecting one hardware thread per processor within said exclusive set of processors to handle a separate one of the tasks of the ST workload while requiring the remaining hardware threads per processor within the exclusive set to idle. The kernel is operative to apply each separate task of the ST workload to a separate local run queue of each selected one hardware thread per processor within the exclusive set of processors. The kernel is operative to send an interrupt to wake up the selected one hardware thread per processor.

In another embodiment of the invention a computer program product manages a SMT enabled processor system including multiple processors each activated to simultaneously execute multiple hardware threads. The computer program product includes one or more computer readable tangible storage devices. The computer program product includes program instructions stored on at least one of the one or more storage devices to facilitate construction of an exclusive set of processors to handle the tasks of the ST workload wherein the ST workload runs more efficiently on single threaded processors. The computer program product includes program instructions stored on at least one of the one or more storage devices to set a separate dispatcher for each hardware thread of the exclusive set of processors to only execute work on each local run queue associated with each hardware thread of the exclusive set of processors. The computer program product includes program instructions stored on at least one of the one or more storage devices to drain any tasks waiting one each local run queue associated with each hardware thread of the exclusive set of processors. The computer program product includes program instructions stored on at least one of the one or more storage devices responsive to each hardware thread being placed in an idle mode without any tasks to perform to set each hardware thread of the exclusive set of processors in a snooze mode wherein only an interrupt awakens each hardware thread placed in snooze mode to search an associated local run queue for waiting tasks. The computer program product includes program instructions stored on at least one of the one or more storage devices to schedule the ST workload on the exclusive set of processors by selecting one hardware thread per processor within said exclusive set of processors to handle a separate one of the tasks of the ST workload while requiring the remaining hardware threads per processor within the exclusive set to idle. The computer program product includes program instructions stored on at least one of the one or more storage devices to apply each separate task of the ST workload to a separate local run queue of each selected one hardware thread per processor within the exclusive set of processors. The computer program product includes program instructions stored on at least one of the one or more storage devices to send an interrupt to wake up the selected one hardware thread per processor.

Referring now to the drawings and in particular to there is depicted one embodiment of a multi processor computer system in which the present invention may be implemented. It will be understood that while depicts one embodiment of a system the present invention may be executed in a variety of systems including a variety of computing systems and electronic devices. In addition it will be understood that does not imply structural limitations but is merely illustrative of the types of components that may be included in a multiprocessor computing system.

As depicted a computer system includes a bus or other communication device for communicating information within computer system . Bus preferably includes low latency and high latency paths that are connected by bridges and adapters and controlled within computer system by multiple bus controllers.

Coupled to bus are multiple processors such as processors a mass storage device interface an input output I O interface a main memory and a communication interface . It will be understood that alternate and additional components may be connected to bus in computer system .

Mass storage interface is used to connect mass storage devices such as a direct access storage device DASD to computer system . It will be understood that multiple types of mass storage devices may be connected to computer system and viewed logically as a single logical disk or multiple logical disks of data storage.

Processors may be general purpose processors such as IBM s PowerPC processors that during normal operation process data under the control of operating system middleware not depicted application software not depicted and other code accessible from main memory mass storage devices or other data storage mediums. In one embodiment operating system includes a multithread controller and other controllers containing machine executable instructions for managing use of the hardware threads of each of processors that when executed on processors carry out the operations depicted in the flowcharts and other operations described herein. Alternatively the steps of the present invention might be performed by specific hardware components that contain hardwired logic for performing the steps or by any combination of programmed computer components and custom hardware components.

Main memory preferably stores data and operating system . Main memory may include dynamic storage devices such as random access memory RAM and static storage devices such as Read Only Memory ROM . Data represents any data that serves as input to or output from any program in computer system . It will be understood that computer system may implement logical addressing that organizes all the available memory of the system into logical disks instead of individual memory component such as main memory and DASD . Therefore while data and operating system are depicted as residing in main memory those skilled in the art will recognize that these components are not necessarily contained in main memory at the same time. It should also be noted that the term memory is used herein to generically refer to the entire logical memory of computer system and may include the logical memory of other computer systems coupled to computer system .

In one embodiment operating system includes multithread controller which adjusts the multithreading characteristics for processors . Multithread controller activates the multiple hardware threads on each of processors when running processors in a SMT mode. In addition multithread simulates an ST mode on selected processors from among processors and runs a workload designed to run more efficiently on single threaded processors on the selection of processors with a similar performance efficiency as if the selection of processors were reconfigured to an ST mode but without using the time to actually reconfigure each processor to operate in an ST mode.

I O interface is used to connect input and output interfaces to computer system . Examples of input interfaces include but are not limited to a keyboard a mouse a touch screen and a microphone. Examples of output interfaces include but are not limited to displays speakers and printers. The interfaces such as a display connected to computer system via I O interface may be used to allow system administrators and users to communicate with computer system . It is important to note that while I O interface provides one way to communicate with computer system a user may also communicate with computer system via communication interface as will be further described.

It is important to note that the present invention may also be provided as a computer program product included on a machine readable medium having stored thereon the machine executable instructions used to program computer system to perform a process according to the present invention. The term machine readable medium as used herein refers to any data storage medium that participates in providing instructions to processors or other components of computer system for execution. Such a data storage medium may take many forms including but not limited to non volatile media and volatile media. Common forms of non volatile media include for example a floppy disk a flexible disk a hard disk magnetic tape or any other magnetic medium a compact disc ROM CD ROM or any other optical medium punch cards or any other physical medium with patterns of holes a programmable ROM PROM an erasable PROM EPROM electrically EPROM EEPROM a flash memory any other memory chip or cartridge or any other data storage medium from which computer system can read and which is suitable for storing instructions. In the present embodiment an example of a non volatile medium is mass storage device which as depicted is an internal component of computer system but will be understood to also be provided by an external device. Volatile media include dynamic memory such as RAM.

Moreover the present invention may be downloaded as a computer program product wherein the program instructions may be transferred to operating system from a remote computer such as a server to requesting computer system by way of data signals embodied in a carrier wave or other propagation medium via a network link e.g. a modem or network connection to a communications interface coupled to bus . Communications interface provides a two way data communications coupling to network link that may be connected for example to a local area network LAN wide area network WAN or directly to an Internet Service Provider ISP . In particular network link may provide wired and or wireless network communications to one or more networks such a network . Network may refer to the worldwide collection of networks and gateways that use protocols such as Transmission Control Protocol TCP and Internet Protocol IP to communicate with one another. Network uses electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information. Further although not depicted communication interface may include software such as device drivers hardware such as adapters and other controllers that enable communication.

Those of ordinary skill in the art will appreciate that the hardware depicted in may vary. Furthermore those of ordinary skill in the art will appreciate that the depicted example is not meant to imply architectural limitations with respect to the present invention.

With reference now to there is depicted a block diagram illustrating an example of a SMT enabled processing system for running both SMT and ST workloads where the ST workload runs on processors simulating an ST mode without switching to ST mode but with comparable performance as if the workload were running on processors switched to ST mode. In a SMT enabled processing system from a hardware perspective each processor such as processors and supports multiple hardware threads such as hardware threads and of processor and hardware threads and of processor . In one example each hardware thread represents a separate execution unit or central processing unit CPU within a processor where each execution unit within a processor shares resources of the processor such as resources and where the shares resources may include but are not limited to cache translation look ahead buffers TLBs registers and controllers.

From a kernel perspective to enable SMT mode on processors and the hardware threads of each processor such as hardware threads and of processor and hardware threads and of processor must be activated. The kernel views an activated hardware thread as a logical processor represented in the figure as logical processors and representing hardware threads and and logical processors and representing hardware threads and . For example multithread controller activates each of hardware threads and and configures the operating system to process workloads on logical processors and .

During normal operation a dispatcher for each hardware thread such as dispatchers and of hardware threads and and dispatchers and of hardware threads and reads the hardware thread s local run queue to access a next task to process. For example local run queues and and are respectively associated with hardware threads and and local run queues and are respectively associated with hardware threads and . If the local run queue is empty then the dispatcher may search a global run queue for a next job. If no jobs are available in the global run queue or if a flag is set for the dispatcher to only search the local run queue and the local run queue is empty then the processor thread calls an idle process. In one embodiment as will be further described the idle process may cede an idle processor to a hypervisor application programming interface where the hypervisor provides additional control over idle hardware threads. In one example during normal operation the hypervisor sets an idle hardware thread to snooze. A hardware thread set to snooze does not use processor resources and the dispatcher does not use processor cycles but the hardware thread can be woken up by an interrupt. It will be understood that additional or alternate application programming interfaces or processes may control an idle hardware thread.

In addition during normal operation set controller may designate a selection of processors or logical processors from among the total processors in a set of processors to handle the tasks of the workload. Each set of processors is associated with a respective workload in queue . As scheduler creates the tasks for each workload in queue scheduler applies each task of the workload to the local run queues of the selected logical processors. For example a set of logical processor could include logical processors and where scheduler applies tasks of the workload to each of local run queues and . In another example a set may be designated as global run queue wherein scheduler may distribute the tasks of the workload to a global run queue and the tasks are then load balanced and distributed from global run queue to local run queues available to receive the tasks. It will be understood that the kernel may implement multiple types of scheduling policies and options.

When the kernel detects an ST workload such as ST workload passed from the application layer in the SMT enabled processing system multithread controller controls the selection of an exclusive set of processors and directs scheduling of ST workload on the exclusive set of processors by scheduler according to a policy that requires selecting only one logical processor for each processor to receive each task of a ST workload.

First in controlling a selection of an exclusive set of processors set controller enables declaring a selection of processors as exclusive. In one example when a processor is declared in an exclusive set both hardware threads and thus both logical processors of the processor are automatically declared exclusive in an exclusive list . In another example each hardware thread of a processor may be separately declared as exclusive however to simulate an ST mode for running a ST workload both hardware threads of the processor must be declared as exclusive.

When a hardware thread is declared exclusive multithread controller automatically drains any non bound waiting tasks from the hardware thread s local run queue to global run queue . Next when a hardware thread is declared exclusive the dispatcher for the hardware thread is set through a bit selection or process to only search for and access new tasks for the hardware thread s local run queue. For example if hardware threads and are declared exclusive then dispatchers and would only look to local run queues and respectively for new tasks. Since all tasks are drained from local run queues and dispatchers and detect hardware threads and are idle and an idle process may cede each idle hardware thread to the hypervisor.

Second in controlling scheduling of ST workload on the exclusive set of processors scheduler detects that the processor set associated with a workload in queue is declared exclusive and implements ST policy in distributing the tasks of the workload to the processors in the set. In one example ST policy requires scheduler to dynamically create from the exclusive set of processors a set of one logical processor per processor represented and to place the tasks for the workload on the local run queues of new set of logical processors.

Once scheduler selects the logical processors according to ST policy scheduler places the tasks of ST workload on the local run queues of the selected logical processors. Next scheduler triggers an interrupt to wake up the hardware threads for the selected logical processors if the selected logical processors are still ceded to the hypervisor. As one hardware thread per processor is woken up the dispatcher for each processor is still set to only select tasks from the local run queue for the hardware thread. For example if an exclusive set includes processor then scheduler selects only one of logical processors and such as logical processor . Scheduler places a task on local run queue and sends an interrupt to wake up hardware thread if necessary. Dispatcher detects that hardware thread is woken up and accesses tasks only from local run queue . No work is placed on local run queue and hardware thread continues to snooze while processor is marked exclusive and hardware thread processes the task of the ST workload.

Thus when processor or any other processor is marked as exclusive multithread controller controls operation of that processor in a simulated ST mode without requiring deactivation of a hardware thread at the hardware layer and dynamic reconfiguration of the logical processors at the kernel and application layers. Further advantageously multithread controller controls operation of processors marked as exclusive in the simulated ST mode at a performance level that is comparable to the performance achieved by running an ST workload in ST mode where in ST mode all but one hardware thread activated on each processor.

It will be understood that when a processor is not marked as exclusive multithread controller controls normal operation of that processor in SMT mode. For example if processor is included in an exclusive set assigned to ST workload ST workload runs on one hardware thread of processor with the other hardware thread maintained in an idling state concurrently an SMT workload passed from the application layer is scheduled by scheduler and runs on both hardware threads of processor .

From the application perspective a user or application may specify a workload as an ST workload and specify the exclusive set of processors through a set application programming interface API . In one example a user defines an exclusive set of processor through set API by designating the number of processors required for processing an ST workload and directs set API to run a particular workload as an ST workload on the exclusive set. The workload is added to queue as an ST workload. Set controller receives the set specification for the workload from API and searches for and selects a set of processors of the number requested that are available to be included in the exclusive set. In another example an application requests through set API for a listing of processors available to be included in an exclusive set. API returns a listing of processors available to be included in the exclusive set. The application then defines a specific range of the available processors in the exclusive set and directs API to run a particular workload as an ST workload on the specific processors defined in the exclusive set. In another example API may run the workload to detect the number of threads included in the workload and define an exclusive set of processors for running the workload equal to the detected number of threads.

In the embodiment when a processor is included in an exclusive set the processor is included in exclusive list . When a processor is included in exclusive list set controller may block any other workloads from binding work to any of the logical processors of the processor. For example set API may reject a set creation request from an application that includes a specific binding to a particular logical processor of a processor marked as exclusive in exclusive list . In addition set API will not include processors included in exclusive list as processors available for a new set. It will be understood that exclusive list may also implement a queue or other management tool to facilitate dynamic scheduling of processors as exclusive or non exclusive.

It is important to note that while the present invention is described with reference to simulating an ST mode the kernel may also controlling switching a processor to ST mode and running a ST workload on processors running in ST mode. In addition it is important to note that while the present invention is described with reference to each processor running in a SMT mode the kernel may also run selections of processors in ST mode. Further while the present invention is described with reference to SMT enabled processors selections of processors managed by the kernel may only provide a single threaded option.

Referring now to a block diagram depicts one example of a SMT enabled processing system with a software layer for facilitating hardware thread snooze. In the example when a dispatcher for a hardware thread such as dispatcher for hardware thread detects a local run queue is empty and dispatcher is set to only search local run queue for tasks dispatcher calls an idle process such as idle process . In the embodiment depicted idle process is a function controlled by the kernel however in alternate embodiments each processor or hardware thread may include a separate idle process or the idle process may run separate from the kernel in another application layer.

Idle process searches the local run queue for a hardware thread for waiting jobs and if there is no job waiting sets the idle bit for the hardware thread and cedes the hardware thread to hypervisor . For example idle process sets idle bit for hardware thread and idle bit for hardware thread . While in the embodiment idle bits and are illustrated in the hardware layer it will be understood that in alternate embodiments idle bits may be set in alternate layers such as the kernel layer.

In one example when an idle bit for a hardware thread is set hypervisor maintains the hardware thread in a snooze mode. When in snooze mode hypervisor blocks the hardware thread from using dispatch cycles or controlling any processor shared resources and only awakens the hardware thread when an interrupt is received. Thus when a hardware thread is set in snooze mode hypervisor waits for an interrupt from the kernel or a timer interrupt and when an interrupt is detected hypervisor returns a hardware thread to idle process . Idle process checks for tasks in the local run queue of the awakened hardware thread and if tasks are waiting in the local run queue the idle process resets the idle bit for the awakened hardware thread and triggers the dispatcher to run the task on the awakened hardware thread. If idle process does not detect a waiting task then the idle bit for the awakened hardware thread remains set and the hardware thread is ceded again to hypervisor .

Thus in the example in one embodiment where hypervisor maintains idle hardware threads in snooze mode when scheduler places a task on one of hardware threads and and processor is marked as exclusive scheduler sends an interrupt to hypervisor to trigger hypervisor to return control of the selected hardware thread to idle process . For example scheduler may place the task on local hardware queue and send an interrupt to hypervisor to awaken hardware thread and return control of the hardware thread to idle process . Idle process detects the task on local hardware queue and calls dispatcher to handle the task. Hardware thread remains in snooze mode as controlled by hypervisor and set controller prevents other applications from binding a task to either of hardware threads and while processor is marked as exclusive such that hardware thread runs in simulated ST mode.

According to an advantage in one embodiment to more efficiently manage hardware threads in a simulated ST mode hypervisor may provide additional functions according to idle policy . In particular to more efficiently implement a simulated ST mode idle policy may include instructions for controlling hardware threads when both hardware threads are idle and then when one hardware thread is active and one remains idle.

First idle policy may direct hypervisor when all hardware threads for a processor are set as idle to return a hardware thread to idle process as soon as hypervisor receives the ceded hardware thread. By immediately returning a hardware thread from hypervisor to idle process when both hardware threads for a processor remain idle when processor is marked as exclusive and scheduler places a task on the local run queue of one of hardware threads and such as local run queue of hardware thread it is more likely that the idle process will already have receive hardware thread from hypervisor will be searching local run queue for new jobs and thus idle process will more efficiently call dispatcher to run the task. In addition if scheduler detects that hardware thread is still ceded to hypervisor when placing the task on local run queue scheduler may send an interrupt to hypervisor to immediately awaken hardware thread . In one example idle process may set a bit when it cedes a hardware thread to hypervisor and unset the bit when the hardware thread is returned from hypervisor so that scheduler may efficiently detect whether a hardware thread is currently ceded to hypervisor .

Second idle policy may direct hypervisor once one hardware thread is no longer set to idle and the other hardware thread is idle to place the remaining idle hardware thread in snooze mode that is only interruptible by timer interrupts and a specified kernel interrupt. By limiting the types of interrupts that wake up a snoozing hardware thread when a processor is marked exclusive the idle thread is awoken fewer times triggering the idle process fewer times and using fewer processor resources. In particular in one example when processor is declared exclusive and scheduler places a task on local run queue when idle process receives hardware thread from hypervisor idle process detects the waiting task unset idle bit and calls dispatcher to handle the task. In the example however idle process will continue to detect no task waiting in local run queue and cede control of hardware thread to hypervisor . According to idle policy when hypervisor detects idle bits and both set and then receives control of hardware thread with idle bit no longer set hypervisor places hardware thread in snooze mode with limited triggers for interrupts. In one example idle policy allows a timer interrupt such as a timer interrupt each 10 milliseconds which triggers hypervisor to return hardware thread to idle process every 10 ms.

It is important to note that using hypervisor to control idle hardware threads in the process of simulating an ST mode is one way for multithread controller to simulate an ST mode in a processor. It will be understood that other SMT enabled processing systems may implement other types of functions among the layers of the system for placing a hardware thread in a state where it does not use processor resources or dispatch cycles until a particular type of interrupt is detected. In addition it will be understood that other types of idle policies may be implemented to minimize the amount of time it takes for an exclusive hardware thread to detect a waiting task and once an exclusive hardware thread is processing a task to minimize the number of times the remaining hardware thread searches for waiting tasks.

With reference now to an illustrative diagram depicts a SMT enabled system running mixed workloads. As illustrated a SMT enabled system includes processor with active hardware threads and processor with active hardware threads and processor with active hardware threads and and processor with active hardware threads and .

Queue includes a ST workload set to run on exclusive set and a SMT workload set to run on non exclusive set . In the example exclusive set includes logical processors LP LP LP and LP corresponding with hardware threads and . Non exclusive set includes logical processors LP LP LP and LP correspondence with hardware threads and .

In the example scheduler distributes the tasks of SMT workload across LP LP LP and LP to run on hardware threads and by placing the tasks on the local run queues of each of hardware threads and . In the example an R indicates a hardware thread running tasks from local and global run queues. In particular although not depicted particular tasks of SMT workload may be bound to particular logical processors or scheduler may load balance the tasks across the selected logical processors.

In addition in the example set controller detects exclusive set and drains any tasks off the local run queues for hardware threads and . In turn each of hardware threads and are set to idle as illustrated by the I and ceded to the hypervisor. In one example the hypervisor maintains each of the hardware threads in a snooze mode interruptible by the kernel and timer interrupts. In another example since both hardware threads of each exclusive processor are idle the hypervisor may immediately return the hardware threads to the idle process until one hardware thread for each exclusive processor is no longer idle.

Next scheduler applies ST policy to exclusive set and selects LP and LP to receive the tasks of ST workload . Scheduler places the tasks of ST workload on the local run queues of hardware threads and and triggers hardware threads and to return from the hypervisor. As illustrated at reference numeral hardware threads and return from the hypervisor and process the tasks on their local run queues as indicated by the R . Hardware threads and are placed in or continue in snooze mode as illustrated by the S until ST workload is complete and scheduler triggers hardware threads and to wake up. In particular once ST workload is complete scheduler removes processors and from exclusive list so that processors and are available for receiving SMT workload tasks or for inclusion in another exclusive set for another ST workload.

As illustrated SMT enabled system runs mixed workloads of ST and SMT workloads concurrently by setting aside a selection of the processors for running an ST workload as exclusive and controlling only one thread for each exclusive processor to run and access tasks from a local run queue. It will be understood that although the example is described with reference to all the processors in SMT enabled system with all hardware threads activated to enable SMT on each processor in other examples a SMT enabled system may include selections of processors that are not SMT enabled but only run a single thread and exclusive sets may include the single hardware thread of the ST processor.

Referring now to a high level logic flowchart depicts a process and program for running a ST workload in a SMT enabled system. As illustrated the process starts at block and thereafter proceeds to block . Block depicts a determination whether a kernel receives a ST workload. An ST workload may be indicated by a bit set in the workload request a designated processor set for the workload marked as exclusive or other indication that the workload should run in a simulated ST mode on the SMT enabled system. In addition a user or application may interface with the kernel and send ST workload requests via a set API. When an ST workload is detected the process passes to block .

Block depicts setting the number of processors required to process each of the tasks of the ST workload as exclusive where the local run queues for the exclusive processors are cleared and the hardware threads of an exclusive processor are set to idle. In one example the processor set assigned to the ST workload indicates the number of processors required and in another example the process set assigned to ST workload specifies particular processors to set as exclusive.

Next block illustrates selecting a new set of one logical processor of each exclusive processor according to ST policy. Thereafter block depicts applying the ST workload tasks to the local run queues of the selected logical processors and triggering the selected logical processors to run the ST workload tasks. Thereafter block illustrates blocking placement of any tasks on the local run queues of non selected logical processors of the exclusive processors. Next block depicts a determination whether the ST workload is completed. If the ST workload is completed the process passes to block . Block illustrates removing the exclusive setting from the selected processors and the process ends.

With reference now to a high level logic flowchart illustrates a process and program for simulating an ST mode using a hypervisor function to control idling hardware threads in an SMT enabled system. As illustrated the process starts at block and thereafter proceeds to block . Block depicts a determination whether a kernel detects an exclusive processor set. If the kernel detects an exclusive processor set then the process passes to block . Block illustrates setting the dispatcher of each hardware thread in the exclusive set to only access local run queues. Next block depicts draining the local run queues of the hardware threads in the exclusive processor set. Thereafter block illustrates selecting one logical processor per processor in the exclusive set. Next block depicts applying the tasks to the local run queues of the selected processors. Thereafter block illustrates sending an interrupt to the hypervisor to wake up the selected thread per exclusive processor if selected thread is not currently returned from the hypervisor to the idle process. Next block depicts a determination whether the ST workload is completed. If the ST workload is completed the process passes to block . Block depicts unflagging the dispatchers of the exclusive hardware threads to only read from a local run queue. Next block illustrates sending an interrupt to the hypervisor to wake up the non selected threads per exclusive processor.

Referring now to a high level logic flowchart depicts a process and program for a set controller automatically creating a set of exclusive processors for an ST workload. As illustrated the process starts at block and thereafter passes to block . Block illustrates a determination whether the kernel receives an ST workload with a processor set defined by the number of exclusive processors required. If the ST workload with a processor set number is received then the process passes to block . Block depicts searching for available processors to specify in the exclusive set. In searching for available processors the set controller may redistribute bound jobs from one processor to another to free up a sufficient number of processors to run only the ST workload tasks. Next block illustrates creating an exclusive set of processors of the number of required processors. Thereafter block depicts attaching the exclusive set to the workload and the process ends.

With reference now to a high level logic flowchart illustrates a process and program for a set API interfacing with an application layer to facilitate creating a processor set for an ST workload. As illustrated the process starts at block and thereafter proceeds to block . Block depicts a determination of what command request is received. If the command request is for the available processors for an exclusive set then the processor passes to block . Block illustrates triggering the set controller to search for the available processors to include in an exclusive set. Next block depicts returning the list of available processors to include in an exclusive set to the requesting application and the process ends.

Returning to block if the command request is to create an exclusive processor set with a selection of the listed processors then the process passes to block . Block illustrates checking whether the processors are available for the exclusive set. If the processors are not available then the process passes to block which depicts sending an error message to the application and the process ends. If the processors are available then the process passes to block . Block depicts returning an indicator that the set is created and the process ends.

Returning to block if the command request is to process a workload as an ST workload with an exclusive processor set then the process passes to block . Block depicts the set API passing the workload request with attached processor set to the set controller and the scheduler queue with directions to process the workload as an ST workload with an exclusive processor set and the process ends.

While the invention has been particularly shown and described with reference to a preferred embodiment it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention.

Referring now to a high level logic flowchart depicts a process and program for a hypervisor to control idling hardware threads to facilitate efficient simulation of an ST mode. In the example the process starts at block and thereafter passes to block . Block depicts a determination whether the hypervisor receives a ceded hardware thread from the idle process. If the hypervisor receives a ceded hardware thread from the idle process then the process passes to block . Block depicts a determination whether all other hardware threads for the same process are idle. If all other processor threads for the same processor are not idle then the process passes to block . Block depicts placing the hardware thread in snooze mode. Next block depicts a determination whether the hypervisor detects a triggerable interrupt for the hardware thread. If the hypervisor detects a triggerable interrupt for the hardware thread then the process passes to block . Block depicts returning the snoozing hardware thread to the idle process and the process ends.

Returning to block if the hypervisor detects that all other hardware threads for the same process are idle then the process passes to block . Block depicts returning the hardware thread immediately to the idle process. Next block illustrates a determination whether the hypervisor detects the same hardware thread ceded again to the hypervisor. If the hypervisor detects the same hardware thread ceded to the hypervisor then the process passes to block . Block depicts a determination whether one other hardware thread for the same process is no longer idle. If one hardware thread for the same processor is no longer idle then the process passes to block and continues as previously described. If both hardware threads for the same processor are still idle then the process returns to block .

While the invention has been particularly shown and described with reference to a preferred embodiment it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention

