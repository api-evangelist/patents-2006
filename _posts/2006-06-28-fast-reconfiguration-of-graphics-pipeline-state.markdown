---

title: Fast reconfiguration of graphics pipeline state
abstract: Techniques and technologies are provided for binding resources to particular slots associated with shaders in a graphics pipeline. Resource dependencies between resources being utilized by each shader can be determined, and, based on these resource dependencies, common resource/slot associations can be computed. Each common resource/slot association identifies a particular one of the resources to be associated with a particular one of the slots.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08111260&OS=08111260&RS=08111260
owner: Microsoft Corporation
number: 08111260
owner_city: Redmond
owner_country: US
publication_date: 20060628
---
Rendering and displaying three dimensional 3 D graphics on screen typically involves many calculations and computations. In a simple graphics system such computations occur according to some level of cooperative or shared processing by the central processing unit CPU and the graphics processing unit GPU . In an exemplary scenario after instructions are processed and some initial computations occur in the CPU a set of coordinate points or vertices that define the object to be rendered are stored in video memory for further processing by the GPU in the graphics pipeline. When graphics programmers develop graphics applications via a set of available graphics APIs the programmer generally indicates a set of vertices to be operated upon by a set of algorithmic elements. This data is sent into the graphics pipeline and each vertex is streamed through a fixed set of GPU subunits in the graphics pipeline. One of these subunits called a tesselator breaks the graphics data down into simple polygons according to predetermined algorithms designed to efficiently cover the surface of the object being represented. Thereafter one or more programmable shader units sometimes referred to as shaders or shader programs can operate on the data and perform specialized operations on graphics data. Shaders can include for example vertex shader s geometry shader s and pixel shader s .

A single shader can receive different combinations of shader constants and depending on the combination of particular shader constants that are provided the output generated by the shader will vary. These shader constants can specify for example how pixels are combined how data is read in and out and in the case of a texture how values are extracted from that texture. The process of shading is a computation intensive and complex process. When these specific shaders operate in a graphics pipeline there are regular bottlenecks due to the operations that occur in each stage.

 State refers to resources being interpreted by the shader program. At any given instance the graphics pipeline contains a tremendous amount of dynamic state rendering state shaders shader constant variables resource memory bindings etc. . Different combinations of state enable various simulated materials and visual effects.

One component of this state is a set of shader constants that need to be bound to the GPU before executing a shader program. Because the hardware used to implement the graphics pipeline can be in only one configuration at any given instance it is desirable to reduce time spent setting state e.g. shader constants and issuing commands to the GPU.

Some shaders utilize constant buffers as opposed to constant registers which hold groups or aggregations of shader constants. Constant buffers can allow shader constants to be set to the GPU more rapidly since the aggregations of shader constants are grouped together. Notwithstanding these advances it would be desirable to efficiently manage state to avoid redundant evaluation and device state modification. For example it would be desirable to provide techniques for efficiently arranging constant buffers or other resources used at different shaders to more efficiently set state to the GPU.

Techniques are provided for reconfiguring a dependency tree comprising a number of resources. The dependency tree keeps track of the relationships or dependencies between different shader resources. Each specific resource is bound to a slot of a parent object in the dependency tree. According to these techniques each of the dependencies in the dependency tree is scanned and a cost associated with each different reconfiguration remapping or rebuilding of shaders of the dependency tree is computed. Each reconfiguration of the dependency tree changes the particular slots certain resources CBs are bound to. The particular reconfiguration of the dependency tree can then be selected that reduces or minimizes the amount of device reconfiguration to transition between higher level states. In other words the particular reconfiguration of the dependency tree which minimizes the number of slots that would need to be re bound in order to transition switch between currently loaded shaders can then be selected. In one implementation these techniques can be performed for offline content generation and storage e.g. if the shader set is known ahead of time shaders are analyzed dependencies are remapped and then the shaders are saved back to disk . In an alternative implementation the method is performed dynamically at application run time load time e.g. if the shader set is not known ahead of time .

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The following detailed description is merely exemplary in nature and is not intended to limit the invention or the application and uses of the invention. As used herein the word exemplary means serving as an example instance or illustration. Any implementation described herein as exemplary is not necessarily to be construed as preferred or advantageous over other implementations. All of the implementations described below are exemplary implementations provided to enable persons skilled in the art to make or use the invention and are not intended to limit the scope of the invention which is defined by the claims. Furthermore there is no intention to be bound by any expressed or implied theory presented in the preceding background brief summary or the following detailed description.

As used herein the term shader can be used to generically to refer to either the hardware subunit of the GPU that performs the shading or to refer to the set of instructions or tokens downloaded to the GPU that are subsequently loaded into memory e.g. register storage used by the shader hardware to perform the shading. The term shader can also refer to both working together. Where the term subunit is also used in connection with the term shader the term shader should be construed to refer to the subunit of the GPU that performs the processing associated with the shading. The term shader program can generally refer to computer programs or processes that reside and run in the graphics pipeline which can be used to help determine define the final on screen surface properties of an image or object in a 3D on screen environment. Shaders can perform billions of computations a second in order to perform their specific tasks.

As used herein the term resources can refer to inputs used by a shader program and can encompass for example textures samplers constant buffers or any other resource used by shader programs.

As used herein the term shader constant can refer to different parameters or variables that are fed into a shader program that allow the shader program to produce different results based on the particular shader constants that are used. Shader programs can receive a range of different values for each shader constant. Shader constant variables to not change values during the invocation of that shader.

Techniques are provided for tracking runtime usage patterns of shader constants and then generating usage pattern data regarding usage patterns of shader constants. This usage pattern data can then be fed into an optimization algorithm to efficiently lay out the data for maximal performance given certain heuristics. Factors considered include for example frequency of client update of the values usage by certain shaders and size and number of the resulting buffers.

One of ordinary skill in the art can appreciate that the invention can be implemented in connection with any computer or other client or server device which can be deployed as part of a computer network or in a distributed computing environment. In this regard the present invention pertains to any computer system or environment having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes which can be used in connection with processes for a non limiting implementation of a graphics pipeline in accordance with the present invention. The present invention can apply to an environment with server computers and client computers deployed in a network environment or distributed computing environment having remote or local storage. The present invention can also be applied to standalone computing devices having programming language functionality interpretation and execution capabilities for generating receiving and transmitting information in connection with remote or local services. In a gaming environment a graphics pipeline is particularly relevant to those computing devices operating in a network or distributed computing environment and thus graphic pipeline techniques in accordance with the present invention can be applied with great efficacy in those environments.

Distributed computing provides sharing of computer resources and services by exchange between computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for files. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices can have applications objects or resources that can implicate the graphics pipeline processes of the invention.

It can also be appreciated that an object such as can be hosted on another computing device etc. or etc. Thus although the physical environment depicted can show the connected devices as computers such illustration is merely exemplary and the physical environment can alternatively be depicted or described comprising various digital devices such as PDAs televisions MP3 players etc. software objects such as interfaces COM objects and the like.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems can be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many of the networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks. Any of the infrastructures can be used for exemplary communications made incident to a graphics pipeline according to the present invention.

In home networking environments there are at least four disparate network transport media that can each support a unique protocol such as Power line data both wireless and wired voice e.g. telephone and entertainment media. Most home control devices such as light switches and appliances can use power lines for connectivity. Data Services can enter the home as broadband e.g. either DSL or Cable modem and are accessible within the home using either wireless e.g. HomeRF or 802.11B or wired e.g. Home PNA Cat 5 Ethernet even power line connectivity. Voice traffic can enter the home either as wired e.g. Cat 3 or wireless e.g. cell phones and can be distributed within the home using Cat 3 wiring. Entertainment media or other graphical data can enter the home either through satellite or cable and is typically distributed in the home using coaxial cable. IEEE 1394 and DVI are also digital interconnects for clusters of media devices. All of these network environments and others that can emerge as protocol standards can be interconnected to form a network such as an intranet that can be connected to the outside world by way of the Internet. In short a variety of disparate sources exist for the storage and transmission of data and consequently moving forward computing devices will require ways of sharing data such as data accessed or utilized incident to program objects which make use of the graphics pipeline in accordance with the present invention.

The Internet commonly refers to the collection of networks and gateways that utilize the TCP IP suite of protocols which are well known in the art of computer networking. TCP IP is an acronym for Transmission Control Protocol Internet Protocol. The Internet can be described as a system of geographically distributed remote computer networks interconnected by computers executing networking protocols that allow users to interact and share information over the network s . Because of such wide spread information sharing remote networks such as the Internet have thus far generally evolved into an open system for which developers can design software applications for performing specialized operations or services essentially without restriction.

Thus the network infrastructure enables a host of network topologies such as client server peer to peer or hybrid architectures. The client is a member of a class or group that uses the services of another class or group to which it is not related. Thus in computing a client is a process i.e. roughly a set of instructions or tasks that requests a service provided by another program. The client process utilizes the requested service without having to know any working details about the other program or the service itself. In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the example of computers etc. can be thought of as clients and computers etc. can be thought of as the server where server etc. maintains the data that is then replicated in the client computers etc. although any computer can be considered a client a server or both depending on the circumstances. Any of these computing devices can be processing data or requesting services or tasks that can implicate the graphics programming techniques specific to an implementation of the graphics pipeline in the invention.

A server is typically a remote computer system accessible over a remote or local network such as the Internet. The client process can be active in a first computer system and the server process can be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server. Any software objects utilized pursuant to the graphics programming techniques of the graphics pipeline can be distributed across multiple computing devices or objects.

Client s and server s communicate with one another utilizing the functionality provided by protocol layer s . For example HyperText Transfer Protocol HTTP is a common protocol that is used in conjunction with the World Wide Web WWW or the Web. Typically a computer network address such as an Internet Protocol IP address or other reference such as a Universal Resource Locator URL can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium e.g. client s and server s can be coupled to one another via TCP IP connection s for high capacity communication.

Thus illustrates an exemplary networked or distributed environment with a server in communication with client computers via a network bus in which the present invention can be employed. In more detail a number of servers etc. are interconnected via a communications network bus which can be a LAN WAN intranet the Internet etc. with a number of client or remote computing devices etc. such as a portable computer handheld computer thin client networked appliance or other device such as a VCR TV oven light heater and the like in accordance with the present invention. It is thus contemplated that the present invention can apply to any computing device in connection with which it is desirable to implement a graphics interface employing a graphics pipeline of the invention.

In a network environment in which the communications network bus is the Internet for example the servers etc. can be Web servers with which the clients etc. communicate via any of a number of known protocols such as HTTP. Servers etc. can also serve as clients etc. as can be characteristic of a distributed computing environment. Communications can be wired or wireless where appropriate. Client devices etc. can or can not communicate via communications network bus and can have independent communications associated therewith. For example in the case of a TV or VCR there can or can not be a networked aspect to the control thereof. Each client computer etc. and server computer etc. can be equipped with various application program modules or objects and with connections or access to various types of storage elements or objects across which files or data streams can be stored or to which portion s of files or data streams can be downloaded transmitted or migrated. Any one or more of computers etc. can be responsible for the maintenance and updating of a database or other storage element such as a database or memory for storing data processed according to the invention. Thus the present invention can be utilized in a computer network environment having client computers etc. that can access and interact with a computer network bus and server computers etc. that can interact with client computers etc. and other like devices and databases .

Although not required the invention can be implemented via an operating system for use by a developer of services for a device or object and or included within application software that operates in connection with the graphics programming techniques for a graphics pipeline in the invention. Software can be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules can be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention can be practiced with other computer system configurations and protocols. Other well known computing systems environments and or configurations that can be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs appliances lights environmental control elements minicomputers mainframe computers and the like. The invention can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network bus or other data transmission medium. In a distributed computing environment program modules can be located in both local and remote computer storage media including memory storage devices and client nodes can in turn behave as server nodes.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer can include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus can be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media can comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer can also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user can enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown can include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but can be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A graphics interface such as Northbridge can also be connected to the system bus . Northbridge is a chipset that communicates with the CPU or host processing unit and assumes responsibility for accelerated graphics port AGP communications. One or more graphics processing units GPUs can communicate with graphics interface . In this regard GPUs generally include on chip memory storage such as register storage and GPUs communicate with a video memory wherein the application variables of the invention can have impact. GPUs however are but one example of a coprocessor and thus a variety of coprocessing devices can be included in computer and can include a variety of procedural shaders such as pixel and vertex shaders. A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which can in turn communicate with video memory . In addition to monitor computers can also include other peripheral output devices such as speakers and printer which can be connected through an output peripheral interface .

The computer can operate in a networked or distributed environment using logical connections to one or more remote computers such as a remote computer . The remote computer can be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but can also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which can be internal or external can be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof can be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.

Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web enabled interface for applications and computing devices making computing activities increasingly Web browser or network oriented.

For example MICROSOFT s managed code platform i.e. .NET includes servers building block services such as Web based data storage and downloadable device software. Generally speaking the NET platform provides 1 the ability to make the entire range of computing devices work together and to have user information automatically updated and synchronized on all of them 2 increased interactive capability for Web pages enabled by greater use of XML rather than HTML 3 online services that feature customized access and delivery of products and services to the user from a central starting point for the management of various applications such as e mail for example or software such as Office .NET 4 centralized data storage which increases efficiency and ease of access to information as well as synchronization of information among users and devices 5 the ability to integrate various communications media such as e mail faxes and telephones 6 for developers the ability to create reusable modules thereby increasing productivity and reducing the number of programming errors and 7 many other cross platform and language integration features as well.

While some exemplary embodiments herein are described in connection with software residing on a computing device one or more portions of the invention can also be implemented via an operating system application programming interface API or a middle man object a control object hardware firmware intermediate language instructions or objects etc. such that the methods can be included in supported in or accessed via all of the languages and services enabled by managed code such as .NET code and in other distributed computing frameworks as well.

The CPU can generally be any processor such as a single chip multi core processor running multiple cores e.g. processors such as a simultaneous multithreading SMT processor which can process or execute several e.g. one or more threads at the same time. As used herein the term thread refers to an individual sequence of instructions. As such simultaneous multithreading refers to the ability for a single processor to handle several threads at the same time. Each core in the CPU can have a Single Instruction Multiple Data SIMD unit as an extension to the processor instruction set. The extension can contain special instructions that help to speed up integer and floating point intensive applications when specially coded to take advantage of these instruction sets. Calculations involved in rendering 3D graphics can be mathematically intensive and rather taxing on the CPU . To alleviate the burden on the CPU the GPU is provided to help the computer run more efficiently.

Before graphics are output to a raster display device e.g. a computer monitor the information used to generate those graphics goes through the GPU and its graphics pipeline . The GPU implements the graphics pipeline in hardware to perform billions of geometry calculations per second.

The GPU is very efficient at manipulating and displaying graphics and its highly parallel structure makes it more effective than typical CPUs for a range of complex algorithms. The GPU implements a number of graphics primitive operations in a way that makes running them much faster than drawing directly to the screen with the host CPU . Lifting this burden from the CPU means that the computer s CPU doesn t have to work as hard to process graphics data e.g. frees up cycles that can be used for other jobs . By offloading most of the graphics functions to the GPU the CPU can perform even more calculations in order to achieve an immersive real time graphics environment. The GPU is responsible for accelerating the display of graphical elements e.g. polygons with texture and shading applied to them on the raster display device e.g. a computer monitor . The GPU processes raw geometry data to ultimately represent that information as pixels on the monitor . The graphics pipeline receives a representation of a 3D scene efficiently processes that representation by running the representation through a number of processing stages and renders 3D scenes as 2D raster images at the monitor .

The GPU can be implemented as one or more stand alone microprocessors which are configured to process real time 2D and 3D graphics. The GPU can sit on a separate graphics card from the motherboard for processing for 2D and or 3D computer graphics and then rendering 2D or 3D images. The GPU can access high performance VRAM directly on the graphics card. Alternatively the GPU can be implemented by integrating it into one of the chips on a PC motherboard so that the GPU can use the main memory as a frame buffer and the CPU to aid in frame rendering. The GPU can be used for example as a dedicated graphics video rendering device for a personal computer or game console.

In 3D graphics rendering the graphics pipeline refers to the various stages of processing e.g. the sequence of steps that the GPU carries out to transform three dimensional image data e.g. the vertices textures and other data from an application into an actual image that is displayed on a two dimensional screen. The properties provided per vertex can include for example x y z coordinates RGB values translucency texture reflectivity and other characteristics.

The different stages in the graphics pipeline are responsible for processing information that is initially provided as properties at the end points vertices or control points of the geometric primitives to generate the image that is eventually rendered. As used herein the term primitive can refer to a collection of vertices that form a single 3D entity. The simplest primitive is a collection of points in a 3D coordinate system which is called a point list. The typical primitives in 3D graphics are lines and triangles. Other types of primitives can include for example a line line list line strips a triangle triangle lists triangle strips and triangle fans. Often 3D primitives are polygons. A polygon is a closed 3D figure delineated by at least three vertices. The simplest polygon is a triangle. Triangles can be used to compose most polygons because all three vertices in a triangle are guaranteed to be coplanar. Triangles can be used to form large complex polygons and meshes.

Within the graphics pipeline all stages are working in parallel. By reconfiguring the graphics pipeline different visual effects can be achieved. For example the graphics pipeline might receive the geometry to be displayed e.g. list of triangles and then perform the necessary geometric transformations on it e.g. rotations translations etc. calculate the color for the geometry to be displayed and then render the geometry to be displayed.

In general the graphics pipeline can comprise the following logical stages input assembler IA vertex shaders and a geometry shader having an associated stream output the rasterizer a pixel shader and the output merger OM . The graphics pipeline can be configured to optimize the use of resources balance the workload in the graphics pipeline allow access to calculated information with IEEE compliant integer or floating point values and provide additional programmability.

The exemplary non limiting embodiment of the graphics pipeline employs dynamically configurable common shader core s comprising a number of units or processing cores that can be configured in various configurations. The common shader core allows simplified optimization as identical hardware units for the different shaders provide load balancing by reconfiguring or disabling a shader as part of the pipeline when it is not needed thus freeing up resources for stages that remain active.

These processing cores can be read into memory and write out from memory in various patterns depending upon the particular application being executed. Depending on its configuration each of the units can be used to perform a vertex shader stage a geometry shader stage and or a pixel shader stage. This allows the common shader cores to be scheduled to different stages or functional blocks of the graphics pipeline on demand to allocate pixel shaders geometry shaders and vertex shaders in a manner that is best suited for the tasks being requested of the pipeline . Any stage can be dynamically enabled or disabled and configured or reconfigured thereby freeing and respecializing resources for stages that are active. As such the underlying resources of the graphics chip can be optimized for the tasks being asked of the graphics chip.

The particular configuration of the graphics pipeline shown in includes a plurality of shared programmable cores or common core elements such as vertex shaders and a geometry shader having an associated stream output and a pixel shader . These different functional stages operate in parallel serving as separate special purpose processors. Depending upon that particular implementation there can be additional or fewer pipeline stages that are shown in . Moreover during the processing of certain vertex and primitive data only some of the pipeline stages shown can actually process that data before an output is displayed on a computer monitor.

The graphics pipeline receives incoming primitive data from and vertex data from an application and passes it through the various pipeline stages before an output is displayed on a computer monitor or screen. The input assembler IA introduces vertex data such as triangles lines or points into the graphics pipeline by pulling source geometry data out of vertex memory buffers and index memory buffers.

 Non indexed or indexed rendering can be used to produce addresses from which to fetch vertex data in memory and subsequently assemble the results into vertices and primitives.

 Non indexed rendering refers to the sequential traversal of vertex buffer s containing vertex data originating at a start offset at each buffer binding. Vertex memory buffers not shown in can receive untransformed model vertices from an application and store them as vertex data. The buffers are each bound to an individual input slot. The layout of data across all the buffers is specified by an input declaration in which each entry defines an element with an input slot a structure offset a data type and a target register for the first active shader in the pipeline . The vertex memory buffers can contain any vertex type. Vertex data can come from multiple buffers accessed in an Array of Structures fashion from each buffer. A given sequence of vertices is constructed out of data fetched from buffers. Various primitive topologies are available to make the sequence of vertex data represent a sequence of primitives. Example topologies are for example point list line list triangle list triangle strip.

 Indexed rendering refers to the sequential traversal of a single buffer containing scalar integer indices originating at a start offset into the buffer. The data to be processed by the graphics pipeline can also be assigned an index. Index memory buffers not shown in receive raw indexed geometric primitive data from an application including points lines triangles and polygons. These geometric primitives can be referenced in the vertex data with index memory buffers. Each index indicates where to fetch data out of buffer s containing vertex data. The index memory buffers contain index data or indices which are integer offsets into vertex memory buffers and are used to render primitives using techniques which draw indexed primitives from a current set of data input streams. Because an index buffer contains indices an index buffer can not be used without a corresponding vertex buffer. Indexing can be useful in a number of situations. For instance an index value can be used for example as part of a video memory addressing scheme while processing data e.g. the index can signify where and when to retrieve and or write to portions of video memory for processing . The programs downloaded to the shader can thus programmatically use the index values associated with the graphics data while retrieving or writing to video memory and also while processing graphics data.

The input assembler IA sends data to the first common core . In this embodiment the first common core is configured as a vertex shader stage. The vertex shader stage operates on or processes streams of vertices from video memory of the graphics pipeline that are specified for algorithmic transformation via a program from the host. Among other things a vertex shader can receive a variety of inputs such as uniform variables and vertex attributes. Uniform variables are constant values for each shader invocation. By contrast vertex attributes are per vertex data a special case of variant variables such as vertex position.

Vertex shaders generally operate on a single input vertex and produce a single output vertex where a vertex refers a point of intersection in 3D space usually defined by its location using x y and z coordinates. The vertex shader stage can allow each geometric vertex to be processed by a short program before it is projected onto the screen. For instance the vertex shader stage can manipulate an object s position in 3 D space by defining techniques to compute vector space transformations and other linearizable computations. For example the vertex shader stage can apply computations of positions colors and texturing coordinates to individual vertices and can perform operations such as transformations skinning and lighting. Some examples of vertex shader s functionalities include arbitrary mesh deformation and vertex displacements in general computing linearizable attributes for later pixel shaders such as texture coordinate transformations.

The data can then be sent to a tessellator which performs tessellation on the data. It will be appreciated by those skilled in the art that the tessellation step is optional as indicated by the dashed line rectangle and in some practical implementations does not occur at all. Tesselation generally refers to a process which involves covering of a bounded geometric region without gaps or overlaps by congruent plane figures of one type or a few types. Following the tessellator there is another common core in the pipeline which can be used to perform post tessellation vertex shading on the data. The tessellator steps in this embodiment are optional.

The second common core is followed by a third common core that is configured as a geometry shader . The geometry shader allows for programming primitives as well as the generation of new geometry. The geometry shader can operate on different types of primitive input including vertices points lines sets of two vertices and triangles sets of three lines and generate new geometry inside the pipeline based on the primitives being input. The geometry shader s inputs are the vertices for a full primitive two vertices for lines three vertices for triangles or single vertex for point plus the vertex data for the edge adjacent primitives an additional two vertices for a line an additional three for a triangle . For example the geometry shader can receive one primitive and output either zero one or multiple primitives. The geometry shader can output multiple vertices forming a single selected topology. Some examples of the output include topologies like a triangle strip a line strip or a point list. The number of primitives emitted can vary within any invocation of the geometry shader .

The geometry shader take in one primitive and output multiple primitives optionally processing adjacent primitives such as adjacent vertices. In other words the geometry shader enables operations on the entire primitive not just by itself but also in the context of some additional nearby vertices. One line segment in a polyline for example can be processed with the ability to read the vertices before and after that segment. One application of this capability e.g to process adjacent vertices of a primitive is that the geometry shader is capable of taking information about neighboring points in 3 D geometric space into account in current calculations.

Algorithms that can be implemented in the geometry shader can include point sprite or wide line tessellation fur fin generation shadow volume generation single pass rendering to multiple texture cube faces and set up barycentric coordinates as primitive data so that the pixel shader can perform custom attribute interpolation .

To perform point sprite tessellation the shader would take a single vertex and generate four vertices or two output triangles representing four corners of a quadrilateral while performing wide line tessellation the shader receives two line vertices and generates four vertices for a quadrilateral representing a widened line. Additionally the geometry shader can utilize adjacent line vertices to perform mitering on the line end points.

The geometry shader can also be used to generate fur or fins this is not limited to fur or fin generation but encompasses any additional vertices added in a third direction of a single topology. Examples include hair scales grass etc. where primitives describing a geometry are fed to the geometry shader and the geometry shader grows the geometry arbitrarily to supplement the shape. Thus with hair for instance based on triangles input to a geometry shader the geometry shader can add a few vertices that represent hair at each vertex. Advantageously because a stream of triangles to the geometry shader includes information about the neighbors of a vertex the proximity and properties color depth etc. of the geometry of the vertex s neighbors can be taken into account during processing. Another exemplary non limiting use of the geometry shader includes shadow volume generation where the adjacency information is used to decide whether to extrude. Furthermore an application can want to generate some geometry like a fin or fur and extrude shadow volumes out of that. In such cases multi pass functionality of the geometry shader would be employed using the ability output a data stream and circulate it back through the use of the stream output.

In this exemplary non limiting embodiment the output from a geometry shader goes to either the rasterizer for rendering and or to a buffer via stream output SO . Turning the stream output SO on does not stop the rasterization functions of the graphics graphics pipeline it merely amplifies the power of the graphics pipeline by providing more programmatic power to the developer.

The stream output SO serves like a tap in the graphics pipeline which can be turned on and off even as data continues to flow down to the rasterizer . The stream output SO can be tapped into anywhere inside the graphics pipeline prior to the data reaching the frame buffer for rasterization.

When the stream output SO is off the stream output SO has no effect on the pipeline. In other words the stream output SO is optional an application can merely allow the pipeline to send the data through without reading the data to a stream output buffer. Furthermore the stream output buffer is one example of the type of memory that can be used to store the streamed data. There can be times when different types of memory can be used for such functionality like cache memory in a microprocessor.

When turned on the stream output SO allows programmers to tap into the pipeline while the data is inside the pipeline and provide that data to another location.

For instance the stream output SO can stream primitives to one or more output buffers for re use elsewhere in the pipeline enabling the application of recursive programmatic algorithms inside the pipeline. Data sent out via stream output SO can be concatenated to buffer s . The data in the buffer s can then be recirculated to graphics pipeline inputs on subsequent passes. For example the data received at the stream output SO can be written to a buffer or memory for retrieval by the host or other operation.

Alternatively the data received at the stream output SO can be recirculated e.g. fed back or fed forward to another entity within the pipeline such as the input assembler IA vertex shaders and geometry shader or the pixel shader to perform recursive or looping functionality. The stream output SO can allow data to be recirculated to other parts of the graphics pipeline programmatically e.g. the programmer can download a program to the GPU which performs recursive operations on the data recircling data through the same algorithms recursively or otherwise loop through the data a pre fixed number of times . For instance the stream output SO can be used to recirculate the data to the shader itself thereby allowing multi pass operations to be performed on the given data. This can enable programmatic recursive and looping algorithms on graphics data. Another way to recirculate data is to send it through the pipeline again inputting the data to the input assembler IA again.

Furthermore if necessary the information can be streamed out while the same data goes to the rasterizer thus not slowing down the rendering of data or enabling the display of the image as it undergoes a transformation based on recursive algorithmic elements operating on the data.

The next component of the graphics pipeline is a rasterizer . The rasterizer is not necessarily a stage in the graphics pipeline but rather an interface between various pipeline stages. The rasterizer assumes input positions are provided in clip space and performs a significant set of fixed function operations which can include clipping perspective divides viewport or scissor selection primitive setup and determining how to invoke pixel shader . Many of these functions can be adjusted by software developers.

Following the rasterizer is a fourth common core and it functions as a pixel shader where it takes one pixel and outputs the pixel at a position. A pixel shader can allow each pixel to be processed by a short program that can include for example image textures or texture data as inputs. A pixel shader can allow developers manipulate colors textures or even shapes by altering the lighting color and surface at a pixel level. Pixel shaders can be used to alter the lighting color and surface of each pixel. This in turn affects the overall color texture and shape of 3 D objects built from these pixels.

Input data available to the pixel shader includes vertex attributes that can be chosen on a per element basis to be interpolated with or without perspective correction or be treated as constant per primitive. Outputs generated by the pixel shader can be one or more 4 vectors of output data for the current pixel location or no color if pixel is discarded . A partial list of effects that pixel shaders make possible includes per pixel reflections per pixel lighting using Phong style shading or DOT effects and procedural textures.

At the output merger OM the final step in the logical graphics pipeline other pixel processing functions can be performed to render the final pixels. These functions can include for example binding of output resources render targets modifying pixel color values with a scissor test visibility determination through depth bias and or stencil buffer techniques or applying functions such as alpha blending or fog shadowing bump mapping environment mapping antialiasing writing or blending of output s to render target s which can be one of many resource types and multiple element textures. After performing these functions on the data the data is ultimately processed further and eventually displayed on a monitor .

The common shader core receives the input data from either the input assembler IA unit a previous stage which can be from anywhere in the graphics pipeline or in some cases from a specialized input source.

The input data can then be temporarily stored in input register s . The input register s can be for example a dynamically indexable array. In the case of a geometry shader the input register s can be a two dimensional 2D array which arranges the inputs for example as vertex element pairs.

The input data is then sent to the shader code . The shader code provides flow control mechanisms an arithmetic logic unit ALU that handles vector floating point and integer arithmetic memory fetch or sample operations and a shader function or program that specifies the particular transformations to be performed on the input data. The shader code can also receive a number of other inputs or resources such as information from the samplers the textures and the constant buffers . The shader code also has two way communication with the temporary registers and the subroutine return address stack .

The shader code receives samples from the samplers that define how to sample textures. However memory can also be read without filtering and the sampler is not necessary in every embodiment. Because sampler objects are statically created it enables the hardware to maintain references of multiple samplers in the flight of the pipeline without having to track changes or flush the pipeline because the sampler objects maintain their definitions and are not modified .

The shader code receives texture information from the textures . The textures work with the shader code to provide texture sampling.

The CPU generates shader constants that can be used to reconfigure a particular shader program. The shader code receives shader constants from the constant buffers . Constant buffers are provided to aggregate or group certain variables or shader constants in memory on the GPU. In other words instead of using an array of constant registers c . . . cN to store constant input values constant buffers can be used to group numeric shader constant values together. The constant buffers are optimized for lower latency access and more frequent updates than textures . The constant buffers can allow a developer to set a particular group of constants all at the same time. The constants can be arranged in any particular order that the developer desires. Grouping shader constants together in a constant buffer can result in certain performance benefits. For example if two shader constants are typically modified and used together at the same time e.g. have the same state in each scenario then those shader constants can be put into a particular constant buffer.

A particular shader program can require a certain number of constant buffers that are bound to specific slots. In one implementation for each stage in the graphics pipeline there are 15 slots for constant buffers that can be active. In shader code a cb register is a placeholder for a constant buffer at slot . A constant buffer is accessed in a shader using cb index as an operand to shader instructions where index can be either a non indexable r or statically indexed x containing a 32 bit unsigned integer an immediate 32 bit unsigned integer constant or a combination of the two added together e.g. mov r0 cb3 x3 0 .x 6 represents moving Element from the ConstantBuffer assigned to slot into r0 assuming x3 0 .x contains 1 . Applications are able to write shader code that reads constants in whatever pattern and quantity desired while still allowing different hardware to easily achieve the best performance possible.

The temporary registers serve as temporary storage. In an exemplary non limiting embodiment the temporary registers can hold any non indexable or indexable arrays of any size and quantity that are needed up to the limit of the temporary storage.

The subroutine return address stack in this particular non limiting exemplary embodiment is a fixed height. Furthermore the stack is hidden from direct shader access and transparently stores return addresses only. It also permits the definition of recursive algorithms.

After the code has passed through the shader code the data goes to output registers . The output registers in this exemplary non limiting embodiment are made of a dynamically indexable array of four vector outputs. Furthermore some stages can have additional specialized outputs.

Depending on which stage the common shader core is being implemented at in the graphics pipeline the output data can then be output to the next shader stage if present as a stream output SO to memory or other location or to an output merger OM or rendering stage.

The data structures listed can be changed from a 1D array to a 2D array or a list. All data structures can change depending on the size and storing capabilities of the GPU. Within the GPU changes to the storage limits and fixed heights can occur due to dynamic allocation and application of compression algorithms to information to conserve space. The samplers and constant buffers can behave like the textures however as resources change the definitions of these components can be modified. If textures are redefined both samplers and constant buffers can change and are not limited to just the texture functions. Furthermore all the data structures can implement new optimization algorithms for speed and utility purposes. The various embodiments described herein are mere examples of graphics pipeline using common cores which can be dynamically configured to provide functionality of a vertex shader a pixel shader and a geometry shader.

As noted above different combinations of state can enable various visual effects. A state management system in the pipeline tracks device state and abstracts device state into high level effects which are composed of multiple elements with complex interdependencies. Effects are defined as a series of techniques techniques depend on passes passes depend on state objects and shaders and state objects and shaders depend on constant buffers and textures. Effects require certain shader programs to be executing on specific constant sets with specific textures as input bound at specific input slots also referred to as bind points in the pipeline. The state management system can utilize a dependency tree to keep track of the relationships or dependencies between various types of different shader resources. Each specific resource e.g. a constant buffer texture sampler is bound to a slot of the parent object in the dependency tree. In this context a slot refers to a slot in the dependency tree for a particular shader. Each shader will have different dependencies and thus separate trees with independent slots.

Referring again to the common shader core also has a number of input slots not shown . The resources individual constants constant buffers textures and samplers etc. used by shader can be bound to specific input slots of the shader . In one particular implementation a shader might have for example 128 input resource slots associated with it 16 different constant buffer slots associated with it and 16 sampler slots associated with it. For example a particular shader might fill the slots with 16 different constant buffers 16 different textures and 16 different samplers. The order in which particular resources are assigned or bound to particular slots of each shader does not necessarily need to follow a particular pattern and can be determined by the compiler. The shader program will do something different with each of these particular resources. For instance a shader program could accept an input constant buffer another input sampler and another input texture etc. and then generate a particular output depending on those inputs.

For simplicity of illustration the example provided in shows four 4 shader programs A N and five 5 possible constant buffers CB A . . . CB E associated with each of the particular shaders A N. However it will be appreciated that in most practical implementations of a pipeline there can be many more shaders in the pipeline and that each of the particular shaders A N will typically have a larger number e.g. sixteen or more of constant buffers than shown in . For example depending on the complexity of a particular application there can be hundreds of different shaders and application developers can specify a virtually unlimited number of constant buffers. In one practical implementation up to 16 of these constant buffers can be bound at different slots of each shader at any given time. Importantly the order in which particular constant buffers are assigned or bound to particular slots at each shader does not necessarily need to follow a particular pattern and can be determined by the compiler.

When two shader programs are compiled independently of each other the order in which resources are bound to particular slots can be different. For instance when shader A is executed constant buffers CB CB are set to slots to render shader A. However when it is time for shader B to be executed the same constant buffers CB CB can be bound or reassigned to different slots to execute shader B. For example when shader A executes CB is bound to slot CB is bound to slot CB is bound to slot CB is bound to slot and CB is bound to slot but when the next shader B executes the same five constant buffers can also be used again but this time at different slots e.g. CB at slot CB at slot CB at slot CB at slot and CB at slot . In such cases the constant buffers have to be unbound from one slot and rebound to a new slot during the transition between executing shader A and shader B. As such the same five constant buffer need to be re bound in different orders. There is a performance cost every time the bindings need to be readjusted since a call must be made to the driver to set up the video card etc. There is no automatic mechanism to mitigate this disagreement between shaders thus resulting in unnecessary reconfiguration of the pipeline as transitions occur between shaders and binding cycles are wasted.

It would be desirable to reduce and or minimize the amount of reconfiguration that is needed in the graphics card when switching between shaders e.g. reduce and or minimize state changes which would typically occur in re binding slots . For example it would be desirable to provide a way to avoid or reduce the need to reassign particular resources to different slots. By placing the resources in the same slots consistently less binding cycles are wasted and or binding cycles are saved.

Techniques are provided for optimally binding resources e.g. constant buffers textures and samplers to certain slots to reduce minimize the amount of binding reconfiguration that is needed in the graphics card when switching between shaders e.g. reduce and or minimize state changes which would typically occur in re binding slots . According to these techniques common dependencies between each shader program can be determined and particular resources can be bound to particular slots based on this determination. A dependency tree keeps track of the relationships or dependencies between different shader resources. Each specific resource is bound to a slot of a parent object in the dependency tree. These disclosed techniques involve scanning dependencies and reconfiguring the dependency tree so that shaders can change their expectation for where resources are bound. As a result the number of slots that would need to be rebound in order to transition between currently loaded shaders can be reduced and or minimized.

According to one embodiment of these techniques each of the dependencies in the dependency tree is scanned and a cost associated can be computed for each different reconfiguration remappings or rebuilding of shaders of the dependency tree. Each reconfiguration of the dependency tree changes the particular slots certain resources are bound to. Using these costs the particular reconfiguration of the dependency tree can then be selected that reduces or minimizes the amount of device reconfiguration to transition between higher level states. In other words the particular reconfiguration of the dependency tree which minimizes the number of slots that would need to be re bound in order to transition switch between currently loaded shaders can then be selected. In one implementation these techniques can be performed for offline content generation and storage e.g. if the shader set is known ahead of time shaders are analyzed dependencies are remapped and then the shaders are saved back to disk . In an alternative implementation the method is performed dynamically at application run time load time e.g. if the shader set is not known ahead of time .

Accordingly the particular shader programs are modified to expect certain resources in the same order. This can allow for example for optimization of the way constant buffers are associated with particular slots. This reduces the amount of work that needs to be done by reducing the amount of reorganization that occurs when switching between different shaders.

At step resource dependencies between resources being utilized by each shader can be determined. In one embodiment step can involve two sub steps . At sub step a particular resource slot arrangement for each shader can be determined. The particular resource slot arrangement for each shader specifies which resources are used in each of the particular slots of each shader. At sub step based on the particular resource slot arrangements resource dependencies e.g. different common between resources being utilized by each shader can be determined.

At step based on the resource dependencies common resource slot associations can be computed. Each common resource slot association identifies a particular one of the resources to be associated with a particular one of the slots such that a number of transitions state changes amount of reconfiguration of resources is reduced minimized when switching between shaders. At step at each of the shaders the resources bound to each slot can then be reorganized according to the common resource slot associations. At this point each shader has the same common resource slot associations such that at each shader the same particular resource is associated with the same particular one of the slots. At step each of the particular resources can be bound to the particular slot as specified by the common resource slot associations.

This calculation can be repeated for each resource e.g. cost associated with binding each one of the resources to the first slot . At step it can be determined if a cost has been calculated for binding each of the resources to the first slot. If not then the process proceeds to step where the next particular one of the resources in a resource list or dependency tree is selected. Steps can then be repeated for the next resource e.g. cost associated with binding the next resource to the first slot . The process repeats until it is determined at step that the cost has been calculated for binding each of the resources to the first slot. At this point the process ends or returns to step . Because steps through are embedded within step of it will be appreciated that steps will be repeated until a cost for binding each resource to each of the slots to be bound has been determined.

Thus in the example shown in the techniques described above could be used to remap the layout of constant buffers used in shader B. For instance all dependencies would be scanned and if it is determined that the optimal constant buffer layout is that shown in shader A then at shader B CBs and would be remapped to be bound to slots and while CB would be remapped to slot and CBs and would be remapped to slots and respectively. This way the switch between shaders A and B requires no additional work beyond the initial binding of all CBs to slots shown in shader A. Similar remapping could also take pace at shaders C and shader N. As such the number of slots that would need to be rebound in order to switch between currently loaded shaders would be minimized.

There are multiple ways of implementing the present invention e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to use the systems and methods of the enhanced graphics pipeline invention. The invention contemplates the use of the invention from the standpoint of an API or other software object as well as from a software or hardware object that receives any of the aforementioned techniques including techniques of the common core the geometry shader or the stream output in accordance with the invention. Thus various implementations of the invention described herein can have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

As mentioned above while exemplary embodiments of the present invention have been described in connection with various computing devices and network architectures the underlying concepts can be applied to any computing device or system in which it is desirable to employ a GPU with an enhanced graphics pipeline. For instance the algorithm s and hardware implementations of the invention can be applied to the operating system of a computing device provided as a separate object on the device as part of another object as a reusable control as a downloadable object from a server as a middle man between a device or object and the network as a distributed object as hardware in memory a combination of any of the foregoing etc. While exemplary programming languages names and examples are chosen herein as representative of various choices these languages names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code and nomenclature that achieves the same similar or equivalent functionality achieved by the various embodiments of the invention.

As mentioned the various techniques described herein can be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof can take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that can implement or utilize the enhanced graphics pipeline techniques of the present invention e.g. through the use of a data processing API reusable controls or the like are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language can be a compiled or interpreted language and combined with hardware implementations.

The methods and apparatus of the present invention can also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer etc. the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of the present invention. Additionally any storage techniques used in connection with the present invention can invariably be a combination of hardware and software.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiment for performing the same function of the present invention without deviating therefrom. For example while exemplary network environments of the invention are described in the context of a networked environment such as a peer to peer networked environment one skilled in the art will recognize that the present invention is not limited thereto and that the methods as described in the present application can apply to any computing device or environment such as a gaming console handheld computer portable computer etc. whether wired or wireless and can be applied to any number of such computing devices connected via a communications network and interacting across the network. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate.

While exemplary embodiments refer to utilizing the present invention in the context of a graphics pipeline the invention is not so limited but rather can be implemented to provide a second processing unit. For instance if the programmer wants to render a display to the screen and process the computational mathematics while performing another function using the CPU the processing units can need to be utilized to their fullest whether or not the graphical display is included in the final output. Still further the present invention can be implemented in or across a plurality of processing chips or devices and storage can similarly be effected across a plurality of devices. Therefore the present invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

