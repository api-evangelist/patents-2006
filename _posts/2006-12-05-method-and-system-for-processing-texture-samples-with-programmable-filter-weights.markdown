---

title: Method and system for processing texture samples with programmable filter weights
abstract: A texture unit of a graphics processing unit provides the ability to switch among different filter modes depending upon shader program instructions that are received by the texture unit. One filter mode has the capability to extract filter weights that have been specified in a received shader program instruction rather than calculating the weights within the texture unit itself.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07623136&OS=07623136&RS=07623136
owner: NVIDIA Corporation
number: 07623136
owner_city: Santa Clara
owner_country: US
publication_date: 20061205
---
The present invention generally relates to computer graphics and more particularly to a method and system for processing texture samples with programmable filter weights.

Unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

Conventional graphics systems use texture mapping to add realism to a computer generated scene. During a texture mapping operation a texture lookup is generally performed to determine where on a texture map each pixel center falls. One pixel usually does not correspond only to one texture map element also referred to as a texture sample or a texel. Thus to calculate the optimal color for the pixel some form of filtering involving multiple texels is performed.

One technique commonly used in this texture filtering operation is bilinear interpolation which interpolates among four texels to generate the final color value for a pixel. To illustrate in prepresents a texture coordinate on the texture map . Suppose pis surrounded by four nearby texels p p p pwith the colors C C C and C respectively one can calculate the texel color at pby performing a bilinear interpolation as follows 1 calculating the filter weights w w w wfor the four surrounding texels based on their distance to p 2 applying the filter weights to the colors of the texels and 3 summing up the weighted average colors. Here the interpolated color at pis referred to as C.

A prior art approach where the aforementioned steps are performed using the hardware shown in has certain limitations. This first approach involves issuing a single TEX shader program instruction from pixel shader engine to texture unit to trigger the bilinear interpolation. However in this approach texture unit calculates all the filter weights internally based on the positions of the four texels in the texture map relative to the pixel and does not afford the user any opportunity to specify the filter weights. For example suppose the instruction issued by the shader program running on pixel shader engine is TEX R p texture where Ris the placeholder for the computed color value at texture coordinate pon texture map as shown in . In response to this TEX instruction texture unit issues four separate read requests to memory to fetch the texel colors Cfor each of the four texels used in the bilinear interpolation i.e. C C C and C . After having received the requested texel colors C texture unit computes the color value Rby performing the steps 1 3 described above. Here texture unit calculates the filter weights based on fixed formulae using the distances between the location of pin texture map and the location of each of the four texels p p pp. In other words this first approach relies solely on hardware generated filter weights to carry out the bilinear interpolation and provides neither the flexibility nor the image quality associated with filtering schemes that implement programmable filter weights.

Although the first approach may be relatively simple to implement it can produce poor results in certain graphics applications. For example in real time applications that magnify a texture the first approach may yield exceedingly blurry images. To alleviate this problem Pradeep Sen in his article Silhouette Maps for Improved Texture Magnification discusses a filtering method where discontinuity information in a texture map the second approach is specified. illustrates a scenario in which the benefits of the second approach over the first approach can be demonstrated. In the first approach even though the screen pixel Rresides in the region of a texture map that is entirely red the colors of the four texels C C C and C would still contribute to the final texture value for p. This resulting texture value therefore would not be exactly red and this imprecise color would be especially noticeable under magnification. In the second approach on the other hand boundary edge delineating a color discontinuity separating between red on the right side of the edge and blue on left side of the edge can be specified. Boundary edge breaks up texture map into different regions. The samples located on the same side of the boundary are grouped together in a filtering operation. So because presides on the same red side as pand p only Cand Care fetched and filtered to compute the texture value at p. The resulting texture value unlike the first approach would contain the precise red color in this example. It is worth noting that by specifying discontinuity such as a boundary edge the filter weights are also specified. For instance by specifying boundary edge the filter weights for Cand Cwould be programmed to zero because they do not contribute at all to the calculation of the texture value for R.

Even though the second approach supports a programmable and a more intelligent filtering method than the first approach the second approach implemented using the hardware shown in still has some shortcomings. In particular texture unit no longer computes the final color value C but rather transmits the color values of the four texels C C C and C to pixel shader engine for processing. This distribution of processing may lead to inefficient use of memory . To illustrate implementing the second approach using the hardware of and operating on texture map shown in would require the following instructions 

The shader program issues the first four TEX shader program instructions to texture unit to essentially retrieve the four texel colors C C C and C. Then the shader program issues the next four MAD instructions to pixel shader engine with the used specified filter weights w w w and w to compute the final output color stored in C . So even though the filter weights would be programmable via the MAD instructions performing bilinear interpolation with these user specified filter weights would require eight instructions. The first four instructions are executed by texture unit and the second four instructions are executed by pixel shader engine . Moreover because of the multi threaded nature of pixel shader engine even though the texture cache may have in anticipation of cache access locality prefetched C C and Cin the cache after instruction 1 is executed these values very likely would have been flushed out of the cache by other intervening threads before instruction 2 is executed. With cache misses memory would need to be more frequently accessed adding even more clock cycles to the already high number of clock cycles that would be needed to execute the eight instructions resulting in performance inefficiencies and increased power consumption for the GPU.

As the foregoing illustrates what is needed in the art is a more efficient technique for processing texture samples with programmable filter weights.

A method and system for processing texture samples with programmable filter weights are disclosed. Specifically one embodiment of the present invention sets forth a method which includes the steps of switching to a data path for receiving one or more programmable filter weights based on a first filter mode receiving a first programmable filter weight corresponding to a first texel over the data path wherein the first texel is associated with a screen pixel mapped to a texture map fetching the first texel from the texture map and computing a texture value for the screen pixel by applying the first programmable filter weight to the first texel.

At least one advantage of the present invention disclosed herein is the ability to compute texture samples with user specified filter weights within a single cycle so that more effective filtering mechanisms can be implemented without negatively impacting the overall system performance.

A method and system for processing texture samples with programmable filter weights are disclosed. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details.

Throughout this disclosure the term user broadly refers to a user or a developer of software program executing on a computing device. In addition the terms user specified and programmable can be used interchangeably to qualify filter weights as being specified by a user through shader programming. Also some examples of a computer readable medium referred to herein include without limitation non volatile media e.g. optical or magnetic disks and volatile media e.g. dynamic memory .

System memory includes an application program high level shader programs an application programming interface API and a GPU driver . Application program may invoke one or more instances of high level shading program . The high level shading programs are typically source code text of high level programming instructions that are designed to operate on one or more processing engines within GPU . High level shader programs may be translated into executable program objects by a compiler and assembler included in GPU driver or alternatively by an offline compiler and or assembler operating either on computer device or other computer devices.

GPU local memory includes an executable shader program a texture buffer and a frame buffer . Executable shader program when executed by pixel shader engine in GPU issues instructions to different components of rendering pipeline . Texture buffer typically stores texture maps. Frame buffer includes at least one two dimensional surface that is used to drive the display .

GPU includes a rendering pipeline used to process data. Rendering pipeline includes a pixel shader engine which further includes a texture unit . As mentioned above pixel shader engine executes executable shader program and issues instructions to components within rendering pipeline such as pixel shader engine and texture unit . Texture unit is capable of retrieving requested texel attributes from texture buffer processing filter weights and performing requested texture filtering operations. Subsequent paragraphs will further detail the structure and functions provided by texture unit .

 is a schematic diagram of a portion of GPU shown in configured to perform a texture filtering operation according to one embodiment of the present invention. To illustrate suppose the texture filtering operation is to bilinearly interpolate four texel colors C C C and C with user specified filter weights w w w and w for a pixel at texture coordinate pshown in to generate a final color value Cx . As pixel shader engine executes executable shader program such execution causes pixel shader engine to issue a single shader program instruction herein referred to as the TEXW instruction to texture unit . According to one embodiment of the present invention the semantics of this instruction include an output argument and multiple input arguments such as TEXW C p w texture n . Here texture n corresponds to a particular texture map stored in texture buffer such as texture map . With p w and texture n as inputs texture unit sends a read request to texture buffer to fetch the texel colors C and use the fetched texture colors and the corresponding user specified filter weights w to derive the final texture value C . Texture unit then returns this the final color value to pixel shader engine . It is worth noting that although the discussions above mainly focus one texture attribute color it should be apparent to a person with ordinary skill in the art to recognize that other texture characteristics such as lighting and transparency values are also within the scope of the claimed invention.

In addition to supporting a shader program instruction like TEXW one embodiment of texture unit also supports conventional shader program instructions for example the shader program instruction TEX. To enable this backward compatibility feature texture unit is shown in with a programmable switch . If the incoming texture instruction is a conventional TEX instruction without user filter weights programmable switch is configured to switch to path shown in a dotted line in . Weight calculator receives input arguments pand determines the filter weights based on a set of fixed formulae. For a bilinear interpolation operation these fixed formulae include equations for deriving the distances between the location of pon the input texture n and the location of each of its surrounding texel grids. The derived distances correspond to the filter weights. Then weigh calculator provides the calculated filter weights denoted as w to texture filter unit . If on the other hand the incoming instruction provides texture unit with user specified filter weights then programmable switch is configured to switch to path . Alternatively another embodiment of texture unit may support two separate inputs each connecting to either path or path to support one of the two filter modes described above.

However if executable shader program invokes the TEXW instruction then pixel shader engine causes the operation mode of texture unit to be set to a programmable weight mode in step . In one implementation this involves configuring programmable switch to switch to path . Once texture unit is in this programmable weight mode texture unit accepts the filter weights specified in the TEXW instruction in step . After the relevant texel attributes are fetched from the texture map specified in the TEXW instruction in step texture filter unit of texture unit applies the user specified filter weights in computing a texture value in step .

In one implementation the TEXW instruction or any other instruction offering the similar functionality as TEXW detailed above may be a part of API shown in so that it can be invoked by any application program developed using API regardless of the hardware platform such application program executes on. Also the TEXW instruction in conjunction with texture unit shown in enable a developer to design intelligent filtering methods such as Pradeep Sen s proposed approach requiring far less clock cycles to execute than the conventional approaches some of which are discussed in the Background section. Lastly although bilinear interpolation has been used throughout the disclosure to illustrate one or more aspects of the present invention it should be apparent to a person skilled in the art to recognize that the TEXW instruction can also be implemented in texturing hardware using trilinear interpolation which involves blending or averaging bilinear interpolations performed on mipmaps with different levels of details. In essence texture filter unit and weight calculator can be of any type of filtering schemes based on weight sums and there can be arbitrarily many user specified interpolation weights w.

The above description illustrates various embodiments of the present invention along with examples of how aspects of the present invention may be implemented. The above examples embodiments instruction semantics and drawings should not be deemed to be the only embodiments and are presented to illustrate the flexibility and advantages of the present invention as defined by the following claims.

