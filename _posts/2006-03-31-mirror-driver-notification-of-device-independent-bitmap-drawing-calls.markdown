---

title: Mirror driver notification of device independent bitmap drawing calls
abstract: Described is a technology including a mechanism that when activated, detects a call to a device independent bitmap. An appropriate mirror driver, such as one or more registered as an accessibility driver, may then be notified of the call. The mechanism may be activated upon creation or selection of the device independent bitmap, and may comprise a wrapper/driver that, from the perspective of the mirror driver, simulates a call to a device dependent bitmap. The notification may be performed by having the driver communicate a function call that emulates a drawing primitive to the mirror driver.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07567253&OS=07567253&RS=07567253
owner: Microsoft Corporation
number: 07567253
owner_city: Redmond
owner_country: US
publication_date: 20060331
---
A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Contemporary computer systems offer users assistive technology typically for providing visually impaired users with better accessibility to computers. For example screen readers can be used to output text to speech and Braille while screen magnification programs can be used to make displayed screen content more viewable.

Previous assistive programs worked by inserting a driver in the video path above the main display driver essentially in a serial display driver chain to intercept graphics primitives processing the primitives to build an off screen model and then outputting the off screen model in some way. An improvement in assistive technology includes mirror drivers which unlike chained drivers are not inserted into the video path of the main display driver. Instead a mirror driver essentially receives graphics primitives as a peer to the main display driver.

A recent accessibility technology that provides an alternative to or a complement to driver based magnifiers is described in U.S. patent application Ser. No. 11 180 859 filed Jul. 12 2005 assigned to the assignee of the present invention and hereby incorporated by reference. This technology is among its aspects generally directed towards a magnification engine and API application programming interface that magnifier applications can leverage and that renders a magnifier in software and or hardware.

Among the requirements of assistive technology programs is that they correctly reflect what is on the display screen. This causes problems with device independent bitmaps DIBs because for such bitmaps the display driver is not called with the instructions that modify the bitmap. For example application calls to GDI the graphics device interface of Microsoft Windows may result in a device independent bitmap being drawn to a separate surface. GDI itself also may not forward all such calls to drivers at the driver level. In general the driver can only see the bits but not the calls that drew the bits.

As a result an accessibility display driver whether chained or mirrored is never aware of drawing calls made to such bitmaps via the usual rendering path and only sees the resultant bits. However there is a lot of information in these calls that an accessibility driver needs to see. For example a text to speech or text to Braille converter wants to see the actual text that is to be drawn rather than the bits that resulted from the text being drawn.

Approaches to solving this problem include patching operating system components e.g. Win32k.sys in memory or calling undocumented kernel interface entry points in order to populate off screen models with information about drawing calls to off screen device independent bitmaps DIBs . These approaches are particularly volatile with respect to system stability and integrity and as such are not desirable.

Another way to capture calls to device independent bitmaps DIBs in a serial display driver chain model is to modify surface data structures in order to associate a surface with the display driver that wants to capture the calls. As a result of the association any drawing to this surface DIB is sent to the chained display driver that performed the modification. When this occurs the chained display driver is able to disassociate the real display driver from the surfaces before forwarding the call e.g. by resetting flags in the surface data structure and calling support functions if the source and destination bitmaps are both device independent bitmaps. Note that when this condition is not fulfilled the call is forwarded to the real display driver.

However with a mirror driver this same technique cannot be used without potentially crashing other mirror drivers because once the surface association is made all mirror drivers will get calls in parallel including for bitmaps for which they have not allocated a device dependent bitmap. As a result specific methods involving surface association calls are incompatible when multiple accessibility mirror drivers are on the system.

This Summary is provided to introduce a selection of representative concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used in any way that would limit the scope of the claimed subject matter.

Briefly various aspects of the subject matter described herein are directed towards a technology including a mechanism that when activated detects a call to a device independent bitmap. An appropriate mirror driver such as one or more registered as an accessibility driver may then be notified of the call.

The mechanism may be activated upon creation or selection of the device independent bitmap and may comprise a wrapper driver that from the perspective of the mirror driver simulates a call to a device dependent bitmap. The notification may be performed by having the driver communicate a function call that emulates a drawing primitive to the mirror driver.

Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices tablet devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in local and or remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media described above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a tablet or electronic digitizer a microphone a keyboard and pointing device commonly referred to as mouse trackball or touch pad. Other input devices not shown in may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . The monitor may also be integrated with a touch screen panel or the like. Note that the monitor and or touch screen panel can be physically coupled to a housing in which the computing device is incorporated such as in a tablet type personal computer. In addition computers such as the computing device may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface or the like.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

An auxiliary display subsystem may be connected via the user interface to allow data such as program content system status and event notifications to be provided to the user even if the main portions of the computer system are in a low power state. The auxiliary display subsystem may be connected to the modem and or network interface to allow communication between these systems while the main processing unit is in a low power state.

Various aspects of the technology described herein are directed towards a technology that provides notifications for drawing calls to device independent bitmap DIB sections which can be considered equivalent to monochrome bitmaps for purposes of notification monochrome bitmaps are generally not referred to herein . As will be understood the notification model provides an alternative to kernel patching and other solutions and also works in conjunction with accessibility mirror drivers.

In one example implementation described herein a notification model is described in the example context of a Windows based operating system architecture. However as will be understood the present invention is not limited to Windows based operating systems let alone any particular implementation or examples described herein. Instead numerous ways to implement the present invention are feasible. Further while an example notification model is described with reference to accessibility mirror drivers numerous other arrangements may benefit from the technology described herein including for example a serial chained driver model. As such the present invention is not limited to any of the particular examples used herein but rather may be used various ways that provide benefits and advantages in computing in general.

As represented in GDI the graphics device interface of Microsoft Windows provides intermediary support between a Windows based graphics display or printer driver and application programs. In general a user mode program and other such programs may call Win32 GDI functions to make graphics output requests whereby these requests are provided to a kernel mode GDI engine . For example a GetDC function call retrieves a handle to a display device context DC for the client area of a specified window or for the entire screen. The returned handle may be used with subsequent GDI functions to draw in the device context.

In turn the kernel mode GDI engine sends these requests to an appropriate graphics driver such as a display driver or printer driver . In general GDI communicates with the graphics driver through a set of graphics device driver interface graphics DDI functions which may be identified by their Drv prefix the driver supports certain DrvXxx functions for GDI to call . Information is passed between the GDI engine and the driver through appropriate input output parameters. The driver supports the GDI engine s requests by performing the appropriate operations on its associated hardware before returning to the GDI engine .

In general the GDI includes graphics output capabilities eliminating the need for a driver to support such capabilities. The GDI also exports service functions that the driver can call further reducing the amount of support the driver needs to provide. GDI provided service functions are identified by an Eng prefix and functions that provide access to GDI maintained structures have names in the form XxxOBJ Xxx.

Note that in the example of it is shown that the combined screen reader magnifier uses the magnification API engine as well as accessibility mirror driver technology such as via the mirror driver. The other user mode programs and likewise use one of the other mirror drivers e.g. . Mirror drivers are also described in copending United States patent application entitled Selective Rendering for Driver Classes assigned to the assignee of the present invention filed concurrently herewith and hereby incorporated by reference.

Rendering paths are also represented in . By way of example consider rendering content in a magnification window. As shown in there are alternative rendering paths from the magnification API engine to the kernel mode display driver that may be used. In general the magnification API engine checks to see if it can open the graphics stream which is essentially an LPC channel to the media integration layer MIL composition engine . If a connection to the graphics stream cannot be opened magnification is implemented via the Win32k.sys system driver e.g. via GetDC null and StretchBlt .

If a connection to the graphics stream can be opened magnification is implemented using the composition engine in either software or hardware rendering mode. More particularly hardware rendering may occur when the magnifier window is not a layered window and other hardware requirements to compose in hardware are met. If so the magnifier window will be rendered in hardware as a windowed Dx application. The composition engine uses DxgKernel interfaces to draw to the kernel mode display driver .

Software rendering is instead used by the composition engine when the magnifier window is a layered window or other hardware requirements to compose in hardware are not met. In such a situation the magnifier window is rendered in software to a surface which is composited by a GDI sprite layer in the system driver e.g. Win32k.sys .

In a situation where a connection to the graphics stream cannot be opened the system driver e.g. Win32k.sys calls DrvXXX functions implemented by a canonical display driver CDD . The canonical display driver essentially implements a Windows XP type device driver interface calls GDI support services in the system driver Win32k.sys to render and then draws to the display driver via DxgKernel . Note that the canonical display driver DxgKernel and the display driver are a secure path. Further note that the canonical display driver essentially insulates other e.g. Windows Vista type driver model display drivers from having to implement the Windows XP type device driver interface and eliminate the need to avoid modifying Win32k.sys to work with a Dx interface which other e.g. Windows Vista type driver model display drivers support.

In general the technology described herein extends the scope of which bitmaps drivers are involved with namely relevant e.g. mirror drivers are notified of the calls to device independent bitmaps as well as to device dependent bitmaps. To this end when an application selects a bitmap into a drawing context DC the GDI can make a device independent bitmap behave similarly to a device dependent bitmap DDB .

In one implementation this is accomplished via a pseudo DDB entity that essentially wraps the device independent component such that calls will be made to the device independent bitmap as if it was a DDB. A pseudo DDB driver BmpDrvBitBlt is also implemented and because of the wrapper will receive GDI calls whenever GDI attempts to draw to the device independent bitmap.

When a call comes in that is received at the pseudo DDB driver the pseudo DDB driver knows that the bitmap is actually regarding a device independent bitmap and notifies the registered mirror drivers e.g. providing them with the details of the calls as if they were receiving DDB information. Note that mirror drivers already receive call information for DDBs as represented by the solid arrows in . The dashed lines in represent the communication related to device independent bitmaps that takes place between the pseudo DDB the pseudo DDB driver and the registered mirror drivers e.g. including the notifications that are sent.

The pseudo DDB mechanism may be triggered by creation of the bitmap and or by its selection into a drawing context. In the example notification model bitmap notifications apply to device independent bitmaps that are created by GDI APIs which may be by using one of the following functions 

Note that CreateCompatibleBitmap is an over constraint as mirror drivers are automatically called for drawing to device compatible bitmaps or DDBs. Further note that another notification will be provided to indicate when GDI will no longer draw to a surface eliminating the need to walk the GDI handle table structure to determine the lifespan of a surface.

While the create bitmap calls encompass all bitmaps that are created including system created bitmaps applications often create bitmaps that are only used for temporary purposes. For efficiency an alternative is to implement the pseudo DDB notification mechanism for applications only when a bitmap is selected into a drawing context. In this way an application program s creation of temporary and otherwise unused bitmaps need not trigger the pseudo DDB notification mechanism.

In the example of notifications are provided to the mirror drivers for any surface that is registered for having calls thereto sent. A gbMirrorInclude flag indicates whether a surface is registered for redirection of drawing calls to mirror drivers. In one implementation each registered accessibility mirror driver e.g. receives a notification via a function call that emulates a GDI DDI drawing primitive to that surface. Because the mirror driver will already receive drawing calls to device dependent bitmaps the mirror driver should only have to determine that the new calls are now destined for a device independent bitmap.

As described above in one implementation notifications will be provided only to drivers that register as accessibility mirror drivers which may be accomplished using existing registration mechanisms alternative implementations may allow notifications to other drivers . One such registration mechanism is generally related to the registration mechanism described in the aforementioned application entitled Selective Rendering for Driver Classes and is performed by the mirror driver by setting a GCAPS2 EXCLUDELAYERED attribute e.g. a flag to an appropriate value which is part of an HWND filtering mechanism for accessibility mirror drivers. The flag specifies that the driver is an accessibility mirror driver setting this flag is equivalent to a mirror display driver self identifying as an accessibility mirror driver define GCAPS2 EXCLUDELAYERED 0x00000800

With respect to drawing calls made via standard DDI calls that is via DrvXXX the accessibility mirror driver receives notifications of drawing calls made to a surface via calls to GDI DDI primitives. Such calls include DrvTextOut DrvLineTo and so forth as set forth below. To identifying drawing calls as non DDB drawing calls note that normally a mirror display driver will only receive calls to DDBs this applies to the canonical case of a standard display driver as well. Because the mirror driver is now receiving calls for non DDB GDI API created bitmaps it needs to handle these calls without failing unexpectedly.

These drawing calls can be distinguished by checking a flag in a surface data SURFOBJ structure to determine if the destination of the call is to a device independent bitmap or to the screen. Note that this logic already exists because while display drivers today did not receive drawing calls for DIB sections they still had to render both DIB and DDBs. This logic required some conditions namely that if the SURFOBJ structure represents a DDB then the driver needs to be able to locate the device handle for the surface and if the SURFOBJ structure represents a GDI bitmap DIB then the driver needs to be able to determine the format of the bitmap and locate the bitmap bits.

Before any rendering can happen to a bitmap the application needs to call a standard GDI function named SelectObject to insert a Bitmap object into the current device context as in the following example 

As described above the DIB Bitmap driver component BmpDrvBitBlt represented as the block in corresponds to the psudeo DDB driver in and comprises a layered DIB bitmap driver that traps rendering to GDI API bitmaps. In this manner registered mirror drivers are called when any redirection to bitmaps occur. Note that a devlock operation e.g. and occurs for every drawing call between SelectObject calls devlocks and SelectObject calls are thus serialized. The devlock is used to synchronize the surface and Devlock makes the surface opaque. The devunlock operation e.g. and occurs after every drawing call between SelectObject has completed devunlock operations are thus serialized with respect to SelectObject and Devlock operations and Devunlock makes the surface non opaque. Note that in the steps represented by the arrows labeled with circular numerals one 1 to three 3 are repeated for each GDI drawing primitive.

The BmpDrvXXX functions are implemented in the pseudo driver that hooks the standard GDI drawing calls whereby its implementation of the drawing calls BMDDrvXXX are called whenever the MirrorInclude SURFOBJ bit is set and drawing is redirected to GDI API bitmaps. These calls include TextOut StrokePath CopyBits BitBlt LineTo FillPath StrokeandFillPath StretchBlt AlphaBlend TransparentBlt GradientFill PlgBlt.

As also represented in the VMirrorIncludeNotify function VOID vMirrorIncludeNotify XDCOBJ dco SURFACE pSurf BOOL bEnable marks a DC and a GDI API bitmap such that registered mirror drivers will be notified of rendering calls to the bitmap as they occur. When a gbMirrorInclude global variable is set then this function synchronizes access to the surface and sets an inclusion flag on the surface for mirror drivers. If the condition is false then this function resets the flag. As mentioned above the VMirrorIncludeNotify function is called from SelectObject twice once when the surface is selected into the hdc and once when the default surface is selected back into the hdc.

The bHookBmpDrv function BOOL bHookBmpDrv XDCOBJ dco sets up the function pointers to the BmpDrvXXX drawing calls that are now called for standard drawing operations to a GDI API bitmap. This function makes the surface referenced inside the specified dco device context object opaque DIBs are normally meant to be opaque to display drivers and sets a reference in the dco to the Bitmap driver s private data structure PDEV so that calls are now sent to this driver note that a PDEV comprises a private driver defined data structure containing the information and data that represents an associated physical device .

The bUnHookBmpDrv function BOOL bUnHookBmpDrv XDCOBJ dco makes the surfaced referenced inside dco non opaque and resets the reference to a PDEV to the default object. The bBmpMakeOpaque function BOOL bBmpMakeOpaque PSURFACE ps makes the surface opaque by setting various flags in the surface structure.

The bBmpUndoMakeOpaque function BOOL bBmpUndoMakeOpaque PSURFACE ps makes the surface non opaque or transparent by resetting flags set by BmpMakeOpaque.

As also represented in The BMPDEVOPEN function BMPDEVOPEN SURFOBJ pso is a constructor. If the surface has been marked to be included for notification bMirrorInclude TRUE to mirror drivers then bBmpUndoMakeOpaque is called by the BMPDEVOPEN constructor. The BMPDEVOPEN function BMPDEVOPEN is a destructor that calls bBmpMakeOpaque. This function makes the bitmap opaque again since DIBs are normally meant to be opaque to display drivers.

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

