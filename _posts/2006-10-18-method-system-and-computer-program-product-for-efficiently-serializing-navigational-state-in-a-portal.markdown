---

title: Method, system, and computer program product for efficiently serializing navigational state in a portal
abstract: The inventive stream-based serialization method is efficient because it minimizes the overall processing time needed to generate a URL and also effective because it makes sure that the serialization result is as short as possible to meet the requirements regarding URL length and markup size.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08301783&OS=08301783&RS=08301783
owner: International Business Machines Corporation
number: 08301783
owner_city: Armonk
owner_country: US
publication_date: 20061018
---
This application is a Submission Under 35 U.S.C. 371 for U.S. National Stage Patent Application of International Application Number PCT EP2006 067533 filed 18 Jun. 2006 and entitled A METHOD SYSTEM AND COMPUTER PROGRAM PRODUCT FOR EFFICIENTLY SERIALIZING NAVIGATIONAL STATE IN A PORTAL which is related to and claims priority to European Patent Application Serial Number EP20050112112 filed 14 Dec. 2005 the entirety of which are incorporated herein by reference.

This application is a Submission Under 35 U.S.C. 371 for U.S. National Stage Patent Application of International Application Number PCT EP2006 063289 filed 16 Jun. 2006 and entitled AUTOCOMPLETION METHOD AND SYSTEM which is related to and claims priority to European Patent Application Serial Number EP20050112043 filed 13 Dec. 2005 the entirety of which are incorporated herein by reference

The present invention relates to a method system and computer program product for efficiently serializing navigational state in a Portal application and in particular to reduce the markup size of portal pages reduce URL length and reduce processing time needed to generate the URLs being part of the Portal page.

Navigational state as used by the present invention describes the current view of the portal that is the result of all navigational interactions of a particular client . The client can request query different views by interacting with the Portal page e.g. by navigating to a new page. This type of user interaction does not change server side state but only requests a new view of the server it is therefore a safe operation in terms of HTTP. The nature of this user interaction is such that the client can navigate back and forward through its recent views using the back and forward button of his browser and that clients can bookmark views and get back to them at a later point in time by invoking a browser bookmark.

One of the main features of HTTP is that it is a stateless protocol i.e. the notion of a session spanning multiple request response interactions does not exist in HTTP. But as nearly all application scenarios require some mechanism to save their state across requests some mechanisms have emerged that allow for creating logical stateful sessions and that can be certainly considered as state of the art nowadays. The two most popular state saving mechanisms are Cookies RFC 2109 and Hidden Input Fields.

However both approaches have some major drawbacks with regard to bookmarkability caching back forward button and indexing by search engines crawlability . Therefore a new navigational state saving approach has emerged which encodes the navigational state into the URL. Different navigational states result in different URLs. Being formerly form based applications only today s Web applications become more and more complex in particular in the portal environment where many components portlets are combined into a larger portal application.

This leads to the problem that the navigational state describing a certain view of a portal becomes quite voluminous because the portal must aggregate the navigational state of all portlets the user interacted with. The capability of efficiently serializing and de serializing respectively navigational state into a URL must therefore be considered a key capability to meet the today s performance requirements being forced up from release to release faster less memory .

In portal applications navigational state is typically represented as a hierarchical tree like document that contains the entire information describing the current navigational state. The valid structure of the hierarchical document is defined in a state model typically a document type definition DTD or XML schema definition XSD . In order to be able to encode navigational state into a URL or into the header of a new portal page e.g. in the HTML base tag it is necessary to serialize this hierarchical state document.

Prior art techniques for serializing hierarchical object structures are typically based on either XML serialization techniques or Java object serialization. In the field of portals these techniques are not sufficient because they do not consider the characteristics of portal specific navigational state. Portals combine several applications so called portlets into a larger portal application. Therefore the portal needs to manage the navigational state of all those portlets as well. In other words the navigational state describing a particular portal view needs to comprise the navigational states of all portlets.

The navigational state of a portlet is typically expressed by means of so called render parameters that are defined by the portlet programmer. Therefore the portal is not able to control the navigational state of portlets. Portlet programmers are free to arbitrarily define as many and as complex render parameters as they want. Neglecting this fact during navigational state serialization will most likely result in too long URLs that even exceed the HTTP specific URL length limit of 2 KB. In addition to portlet specific state the navigational state of a portal has to also include the state of page navigation controls administrative toolbars and any other elements of the portal user interface. Thus the navigational state of a certain portal view becomes extraordinarily complex.

It is object of the present invention to provide a method system and computer program product for efficiently serializing navigational state of a Portal avoiding the disadvantages of the existing prior art.

The present invention uses a completely stream based serialization which transforms the hierarchical object representation of navigational state input into a flat character based representation of minimum length output .

The first stream based serialization sub process which is hierarchy oriented uses the hierarchical object representation of the navigational state and transforms it into a series of events. The events serve as the input for various strategies for compacting information that is associated with these events. At the end of the sub process the compacted navigational state information carried by the received events is transformed into a character based representation and the hierarchical structure of the navigational state is derived from the order of the received events and transformed into an additional character based representation both being directly streamed to the second sub process.

The second stream based serialization sub process which is hierarchy independent uses the result of the first sub process and applies further compression and character encoding strategies before streaming the compressed and character encoded information into a URL or the header of said new Portal page. Both sub processes are seamlessly linked together.

The inventive stream based serialization is efficient because it minimizes the overall processing time needed to generate a URL and also effective because it makes sure that the serialization result is as short as possible to meet the requirements regarding URL length and markup size.

In a preferred embodiment of the present invention the hierarchy oriented first sub process is based on an event based filter chain which is responsible for the mentioned compaction of the navigational state information. Each of these filters applies a certain strategy on the received events generated at the beginning of this sub process. After processing an event the filter passes the event including the associated now compacted state information to the next filter being part of the filter chain.

The hierarchy independent second sub process is preferably realized using a character based writer chain. This allows for directly streaming the state information that has been compacted in the scope of the first serialization sub process to that writer chain in order to immediately compress the received information.

The inventive serialization method allows for adding arbitrary strategies either filters that are included into the event based filter chain or writers that are included into the character based writer chain.

In a preferred embodiment of the present invention the event based filter chain consists of two filters implementing the following two strategies 

The so called render parameter mapping strategy focuses on the navigational state of portlets in particular on the render parameters of portlets. The render parameter mapping strategy monitors the complexity of render parameters of a particular portlet in terms of the length of the parameter names and values. If a parameter name or value exceeds a certain pre defined threshold the strategy will map the complete parameter to a short key consisting of one character only. This strategy is put into practice by filtering the events representing render parameters and processing them accordingly.

The so called token mapping strategy is responsible for handling pre defined portal specific state tokens names state values that can be directly derived from the navigational state model either the mentioned DTD or XSD . It maps all those names and values to a short one character representation. This strategy is put into practice by filtering each and every event and subsequently processing the associated information the names and values mentioned above accordingly.

The serialization method is divided into two sub processes which are both stream based. The first stream based serialization sub process which is hierarchy oriented uses the hierarchical object representation of the navigational state and transform it into a series of events wherein the events serve as the input for various strategies for compacting the information that is associated with these events wherein at the end of said sub process the compacted navigational state information carried by the received events is transformed into a character based representation and the hierarchical structure of said navigational state is derived from the order of the received events and transformed into an additional character based representation both being directly streamed to said second sub process.

The second stream based serialization sub process which is hierarchy independent uses the result of said first sub process and applies further compression and character encoding strategies before streaming the compressed and character encoded information into a URL or header of said new Portal page.

In a preferred embodiment the first hierarchy oriented sub process is realized using an event based filter chain that consists of a set of filters F. . . Fbeing responsible for compacting the state information contained in the hierarchical object representation to be serialized. Each filter Fimplements a certain strategy that contributes to fulfilling this objective.

The filter chain obtains a series of events that reflects the hierarchical structure of the input navigational state. Each event carries the concrete state information of a particular node in the hierarchical structure i.e. the node s name value and attributes. Thus the filters are able to examine the state information retrieved from the respective event and react accordingly. Typically a filter concentrates on one specific aspect of state information e.g. portlet specific navigational state. In other words the filter intercepts the events it is interested in for example by means of their name processes these events accordingly and then passes them on to the next filter in the chain. All other events that do not match the required criteria are delegated unchanged to the next filter.

Before executing the filter chain the serialization component has to generate the series of events that corresponds with the given hierarchical object representation to be serialized. The component being responsible for this translation step is a so called serialization mediator see .

As shown in the serialization mediator traverses the hierarchical state document using a breadth first search algorithm as illustrated by means of the dotted arrows in order to initiate the event stream. For each visited node the serialization mediator creates a startNode event populated with the node name as well as node attributes if any a nodeValue event populated with the node value if any and an endNode event to indicate that the processing of the node is completed. Note that the order of the generated events in particular the nesting of startNode events reflects the hierarchy of the input document.

After its creation the serialization mediator sends the event to the first event processing filter Fin the chain. also shows the event stream that corresponds with the depicted exemplary navigational state document. The names that are used to denote the various events go back to terms that are related to XML processing techniques e.g. the Java SAX API .

By means of the information that is associated with an event e.g. the node name that is transmitted along with a startNode event each filter is able to intercept the sort of events it is interested in and modify the carried information e.g. the node value or even the node name before passing the event to the next filter.

After an event has passed all filters it reaches the so called serialization handler see which is responsible for transforming the received events carrying the compacted state information into a flat character representation. In order to achieve that the serialization handler gradually appends the names values and attributes to a character based representation and then passes the resulting character string to the second serialization sub process for further compression and character encoding. After all events have been processed the serialization handler hands over an additional piece of information that reflects the hierarchy of the navigational state document. This piece of information is needed to restore the hierarchy of the state document during de serialization later on. To encode the hierarchy information the serialization handler simply encodes a bit representation that corresponds with the nesting of the formerly processed startNode events.

The second sub process which is also completely stream based processes the received character strings by means of the mentioned character based writer chain W. . . W see . Each writer applies a specific compression or character encoding strategy to the received character strings before passing them to the next writer in the chain. Note that these writers cannot make any assumptions about the received character strings neither about the semantics of the contained information nor about its internal structure. Therefore they can only apply generic character compression and encoding techniques e.g. state of the art compression techniques such as GZIP. After the various writers have applied their compression e.g. GZIP and character encoding e.g. UTF 8 strategies the resulting character representation is written to a certain data sink. The data sink is typically a URL which then carries the serialized form of the navigational state. When clicking on such a URL the navigational state portion has to be retrieved from that URL for state de serialization. During de serialization all serialization strategies have to be revoked as explained in the following section.

The preferred embodiment of the event based filter chain and character based writer chain is shown in . The colour gradient emphasizes the seamless transition from the event based filter chain on the left to the character based writer chain on the right.

As illustrated the event based filter chain consists of two filters in addition to the system specific serialization mediator and serialization handler that have been outlined in the invention summary. The first event processing filter implements the portlet render parameter mapping strategy whereas the second filter applies a generic mapping of all pre defined tokens names and values contained in the navigational state document. For details on these concrete filters please refer to the section following the de serialization section. The character based writer chain consists in addition to the sink writer which just streams the result to a particular data sink of a writer that performs a GZIP compression and another writer that performs a base character encoding.

The counterpart de serialization process is responsible for transforming a given flat character representation of navigational state back to the original hierarchical tree like object representation of navigational state. The de serialization process is shown in .

As illustrated the input data processed by the inventive de serialization method is the flat character representation of minimum length. The de serialization result is the hierarchical object representation of navigational state that is equivalent to the navigational state before serializing it.

As being the counterpart to serialization the de serialization process is also divided into two sub processes. First a character based reader chain revokes the compression and character encoding strategies applied during serialization by applying the counterpart decompression and character decoding techniques R . . . R . After that sub process the hierarchy of the navigational state document is restored before applying again an event based filter chain F . . . F in order to revoke the information compaction strategies done during serialization. Note that F denotes the filter that applies the inverse strategy that corresponds with filter F. The following paragraphs describe the de serialization in detail as shown in .

The first component that is involved in de serialization is the so called source reader. The source reader is a character reader that operates on a given data source. In our case it reads the serialized navigational state from a URL and submits the read character strings to the reader chain R . . . R . The reader chain revokes the character encoding and compression performed during serialization by applying the corresponding character decoding and decompression techniques. Acting as the adapter between the character based reader chain and the event based filter chain the serialization parser buffers the received character strings in order to finally transform it back to a series of events that is equivalent to the event stream during serialization. In order to achieve that it has to take the encoded hierarchy information into account to generate the events in the right order with the right nesting. Note that the serialization parser can easily execute this task because it is the counterpart component of the said serialization handler thus having the required knowledge about how to interpret the serialized hierarchy information.

Thereafter the stream of events passes the event based filter chain F . . . F reversing the information compaction done during serialization. At the end of the event based filter chain the so called de serialization mediator the counterpart component of the serialization mediator directly maps the received events to controller operations in order to restore the hierarchical object representation by creating the nodes and connecting them to each other. After all the entire original navigational state document has been restored. This step concludes the de serialization process.

The render parameter mapping filter focuses on the navigational state of portlets in particular on the render parameters of portlets. The strategy implemented by this filter monitors the complexity of render parameters of a particular portlet in terms of the length of the parameter names and values. If a parameter name or value exceeds a certain pre defined threshold the strategy will map the event representing the complete parameter to an event carrying a short key consisting of one character only whereas the concrete parameter names and values are serialized into the user s HTTP session.

First the filter checks whether the received startNode event indicates a portlet render parameter by means of the node name parameter . If the filter detects such an event the yes branch it passes it to an internal parameter mapper component that performs the complexity check. Otherwise the no branch it just delegates the event to the next filter in the filter chain.

The parameter mapper performs the complexity check by evaluating the name and value of the render parameter in terms of their length. If the configured length threshold is exceeded it maps the parameter to a short key a character and sends an event carrying this key only to the next filter. The actual render parameter as well as the generated key is serialized into the HTTP session. Note that this procedure takes the risk of too large HTTP sessions. Therefore the key parameter mappings have to be managed using an expiration policy that evicts the stored mappings on a least recently used LRU strategy.

The token mapping filter implements a generic strategy that aims at compacting as many tokens as possible. Therefore it does not intercept events that match a certain criteria e.g. a specific node name but tries to map all tokens i.e. the name value and attributes of each received event. In order to perform this mapping it reuses the information retrieved from the state model definition. As already mentioned before the state model definition specifies the valid structure i.e. the relationships between node names as well as the data types of node values and attribute values of a navigational state document and is typically described in a DTD or XSD file. Based on that definition the token mapping filter derives a mapping table which assigns each pre defined token contained a one character substitute. Pre defined tokens include the names of nodes and attributes which are completely specified in the state model definition as well as all node and attribute values that are explicitly specified in the state model definition.

All node and attribute values that are not specified in the state model definition cannot be mapped to a short one character representation. This applies in particular to the names and values of portlet render parameters.

The portal structure preferably comprises function components which are already part of each prior art portal and those components which are newly added in order to provide the inventive functionality.

The Servlet is the front controller that receives the incoming HTTP requests. It typically prepares the request processing engine for processing the received HTTP request by initializing the components involved. After that the servlet delegates the processing of the request to the request processing engine .

The request processing engine is also part of the front controller being responsible for controlling the processing of the incoming requests. Typically it defines a request processing lifecycle that is made up of several request processing phases. In a Portal a request has to walk through four phases. First the init phase performs request specific initialization tasks followed by the action phase being responsible for authentication and action execution Portlet actions as well as commands . After the action phase the render phase is executed by invoking the aggregation process. The terminal phase concludes request processing by performing request specific cleanup tasks.

The aggregation component is invoked during the render phase of the request processing lifecycle. It is responsible for transforming the layout model describes how portlets are arranged on the page of the requested page into a presentation tree as well as writing the markup that corresponds to this presentation tree to the response.

The authentication component is responsible for verifying the identity of the user. Each incoming request has to pass authentication. The Portal uses the user identity to determine the content the user is authorized to access as well as the commands to execute.

The Portlet container provides unified access to the Portlets. In particular it allows for gathering the markup of a certain Portlet or executing a Portlet action. The Portlet container invokes Portlets by means of the Portlet API.

The command API application programming interface provides an abstraction layer for Portal specific commands. In particular it allows for executing commands via a unified interface. Commands may be used to perform administrative tasks such as creating and or deleting portal pages adding and or removing Portlets to and or from portal pages arranging Portlets on existing pages and so on.

defining a lifecycle for navigational state as well as providing an interface that enables the request processing engine to incorporate the defined state processing tasks into the overall request processing lifecycle 

defining an object model to represent navigational state as well as providing an application programming interface API that allows for reading and writing modifying navigational state 

providing a framework that allows for efficiently serializing the object representation of navigational state into a URL as well as de serializing navigational state from an incoming URL to restore the internal object representation. The framework needs to include interfaces that can be invoked by the URL generation component to create URLs carrying navigational state 

The URL generation API provides as the name implies an API that allows for creating URLs for a variety of use cases. It enables the programmer to associate navigational state with the created URL as well as to write the URL to a given destination stream. This write operation involves serializing the navigational state that has been associated with the created URL. In addition to creating URLs programmatically the URL generation API typically offers some URL tags to create URLs within JSPs.

By default a created URL is initialized with the request specific navigational state to make sure that the navigational state of previous interactions does not get lost. To determine the specific semantics of the URL this navigational state may be changed for this particular URL only.

The newly added function component that provides the inventive functionality refines the navigational state management component 

The state serialization framework A is a subcomponent of the navigational state management component that puts the invented stream based serialization method. It is in particular responsible for providing 

a first stream based serialization sub process being hierarchy oriented that uses the hierarchical object representation of said navigational state and transform it into a series of events wherein said events serve as the input for various strategies for compacting the information that is associated with these events wherein at the end of said sub process the compacted navigational state information carried by said received events is transformed into a character based representation and the hierarchical structure of said navigational state is derived from the order of said received events and transformed into an additional character based representation both being directly streamed to said second sub process 

a second stream based serialization sub process being hierarchy independent that uses the result of said first sub process and applies further compression and character encoding strategies and finally streaming the compressed and character encoded information into a URL or header of said new Portal page wherein both sub processes are seamlessly linked together assembling multiple serialization strategies as well as the counterpart de serialization strategies to a

providing an application programming interface API that allows for executing the assembled serialization chain during URL generation as well as executing the de serialization chain during URL decoding.

The input data of the component is either a hierarchical navigational state document for serialization or a serialized character representation of navigational state for de serialization.

