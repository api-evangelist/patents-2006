---

title: Methods and systems for processing a geometry shader program developed in a high-level shading language
abstract: Methods and systems for processing a geometry shader program developed in a high-level shading language are disclosed. Specifically, in one embodiment, after having received the geometry shader program configured to be executed by a first processing unit in a programmable execution environment, the high-level shading language instructions of the geometry shader program is converted into low-level programming language instructions. The low-level programming language instructions are then linked with the low-level programming language instructions of a domain-specific shader program, which is configured to be executed by a second processing unit also residing in the programmable execution environment. The linked instructions of the geometry shader program are directed to the first processing unit, and the linked instructions of the domain-specific shader program are directed to the second processing unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07958498&OS=07958498&RS=07958498
owner: NVIDIA Corporation
number: 07958498
owner_city: Santa Clara
owner_country: US
publication_date: 20061130
---
The current application claims the benefit of U.S. Provisional Application No. 60 833 978 filed on Jul. 28 2006 and having the title API Extensions for Advanced Graphics Processing Units. This related application is hereby incorporated by reference in its entirety. The current application also is a continuation in part of U.S. application Ser. No. 10 883 893 filed on Jul. 2 2004 now U.S. Pat. No. 7 426 724 and having the title Optimized Chaining of Vertex and Fragment Programs. This additional related application is also hereby incorporated by reference in its entirety.

Embodiments of the present invention relate generally to graphics processing and more specifically to processing of a geometry shader program developed in a level high shading language.

Over the past decade the cost of adding on chip logic to processors has substantially decreased. Consequently certain types of processors such as advanced graphics processing units GPUs now include functionality not previously available in earlier GPU designs. For example the newest GPUs are now able to perform geometry processing operations whereas such operations traditionally had been left to the central processing unit CPU . One benefit of this shift in responsibilities is that more graphics processing may now be performed on the GPU instead of the CPU thereby reducing performance bottlenecks in the graphics pipeline.

To fully realize additional processing capabilities of advanced GPUs as much GPU functionality as possible needs to be exposed to application developers. Among other things doing so enables application developers to tailor their shader programs to optimize the way GPUs process graphics scenes and images. Exposing new GPU processing capabilities like geometry processing to application developers requires that the application programming interface API be configured with new calls and libraries that make new features and functionalities directly accessible by developers.

With GPU driver supporting compiler GPU microcode assembler and GPU microcode assembler specialized application such as vertex shader program or fragment shader program can be written in a high level shading language e.g. the High Level Shader Language for Direct3D or the OpenGL Shading Language tailored to one of these programmable processing units. Vertex shader program is generally constructed using unified program instructions and with self contained variables and functions. Likewise fragment shader program is constructed using unified program instructions and also with self contained variables and functions. Compiler optionally translates these high level shading programs into distinct software objects of vertex shader assembly code and fragment shader assembly code . Based on the translated assembly code GPU microcode assemblers and then generate vertex shader microcode and fragment shader microcode respectively for GPU . It should be noted that compiler may reside outside of GPU driver in other prior art programming models.

One drawback of the aforementioned programming model is the lack of programmability for certain components in rendering pipeline . For instance since rendering pipeline lacks a programmable processing unit in between vertex processing unit and fragment processing unit application is unable to manipulate or process the output data of vertex processor unit until that data reaches fragment processing unit . Another drawback of programming model is the potential inefficiencies relating to developing and deploying separate domain specific shader programs because application developers need to rationalize the various shader programs they develop.

As the foregoing illustrates what is needed in the art is a programming model that exposes new programmability and processing capabilities of GPUs such as the ability to program and perform geometry processing operations and enables efficient development of the various shader programs that execute within the different domains of the rendering pipeline.

Methods and systems for processing a geometry shader program developed in a high level shading language are disclosed. Specifically in one embodiment after having received the geometry shader program configured to be executed by a first processing unit in a programmable execution environment the high level shading language instructions of the geometry shader program are converted into low level programming language instructions. The low level programming language instructions are then linked with the low level programming language instructions of a domain specific shader program which is configured to be executed by a second processing unit also residing in the programmable execution environment. The linked instructions of the geometry shader program are directed to the first processing unit and the microcode instructions of the domain specific shader program are directed to the second processing unit.

One advantage of the disclosed methods and systems is that a geometry shader program or other domain specific shader programs can be efficiently developed using a high level shading language for programmable processing units in a rendering pipeline.

Methods and systems for processing a geometry shader program developed in a high level shading language are described. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details.

Throughout this disclosure a domain specific shader program generally refers to a shader program specifically constructed to operate in a particular stage in a rendering pipeline. For instance vertex shader program shown in is executed during the vertex processing stage of rendering pipeline . Likewise geometry shader program is executed during the primitive processing stage and fragment shader program is executed during the fragment processing stage. A shader program broadly refers to a software program that operates on the individual elements in a stream of elements. A shader engine on the other hand refers to a programmable processing unit which performs the processes defined in a shader program. Thus primitive processing unit of is a shader engine because it is configured to perform the processes defined in geometry shader program . Some examples of the types of elements that may be operated on by a shader program include without limitation vertices pixels and fragments. Varying variables provide the interface between a vertex shader and a geometry shader and also between a geometry shader and a fragment shader. A low level programming language generally refers to a programming language that provides little or no abstraction from a processing unit. Some examples of this low level programming language include without limitation assembly code and microcode. Also some examples of the computer readable medium referred herein include without limitation volatile memory and non volatile storage media e.g. optical or magnetic disks .

Moreover in programming model GPU driver which is the device driver for GPU supports compiler linker . Compiler linker which includes code generator and unified instruction set library provides cross domain linking capabilities. Specifically compiler linker translates the shader programs designated for different domains e.g. vertex shader program geometry shader program and fragment shader program which are written in high level shading language into distinct compiled software objects in the form of assembly code. Further instead of sending these compiled objects of assembly code individually to separate GPU microcode assemblers as shown in compiler linker also links the compiled assembly code to generate a collection of up to three separate chunks of assembly code with the inputs outputs of each chunk lined up as described below. This collection is referred to as compiled linked program object . To link multiple compiled objects from different domains also referred to as to rendezvous compiler linker needs to reconcile the use of symbols across the domains. Specifically there are generally two types of symbols the first type being defined or exported symbols and the second type being undefined or imported symbols. The first type of symbols broadly refers to functions or variables that are present in one compiled object e.g. vertex shader assembly code and should be made available for use by other compiled objects e.g. geometry shader assembly code and or fragment shader assembly code . The second type of symbols broadly refers to functions or variables that are called or referenced by one compiled object e.g. vertex shader assembly code but are not internally defined within this compiled object. The compiler linker and optimizations related to linking shader programs for concurrent execution are discussed in greater detail in the patent application titled Optimized Chaining of Vertex and Fragment Programs filed on Jul. 2 2004 and having U.S. patent application Ser. No. 10 883 893. The subject matter of this patent application is hereby incorporated by reference in its entirety.

Additionally compiler linker supports two types of linking linking by name and linking by semantics. To illustrate linking by name suppose Color is the name of a variable containing color values to be passed from the vertex shader program to the fragment shader program. Suppose also that Color is defined in this vertex shader program. In programming model compiler linker facilitates the establishment and maintenance of the input output relationship between vertex shader program and for example geometry shader program without requiring any explicit variables to hardware mappings in the shader programs so long as the two shader programs use the name Color consistently. To link by semantics on the other hand the variable names are not required to be the same. Suppose vertex shader program declares a variable with the name of Vertex Color for storing the color type X to be passed to geometry shader program and geometry shader program declares a variable with the name of Geometry Color for receiving the color type X. In this scenario compiler linker is still capable of establishing and maintaining the input output relationship between vertex shader program and geometry shader program so long as Vertex Color and Geometry Color are assigned the same semantics corresponding to the color type X. Alternatively instead of explicitly assigning semantics as discussed above for GLSL well defined names corresponding to specific semantic meaning such as gl TexCoord 0 corresponding to texture coordinate zero and gl FrontColor corresponding to a front facing color value are utilized to interface not only with other GLSL shaders but also with OpenGL fixed function processing or separate programs written in assembly code.

In addition to cross domain linking compiler linker also supports error reporting and optimization capabilities. Using the linking by name example above if geometry shader program uses a different variable name than Color then compiler linker is configured to generate a linking error to indicate the inconsistent usage of the variable name. In addition if Color were declared in a different manner in geometry shader program than in vertex shader program for example then a linking error would occur. If the input of geometry shader program does not have a corresponding output a linking error would also occur. This error reporting mechanism enables application developers to efficiently identify any programming mistakes and as a result improve the robustness of their programs. Also compiler linker searches for and removes programming inefficiencies across domains. For example suppose vertex shader program generates multiple output variables destined for geometry shader program . Compiler linker is capable of identifying the output variables that are not used by geometry shader program and then excluding these unused output variables from compiled linked program object .

Further details about compiler linker may be found in the patent application Ser. No. 10 883 893 previously referred to herein. Compiled linked program object generated by compiler linker is optionally directed to a single GPU microcode assembler which generates three software objects of domain specific microcode for GPU to execute vertex shader microcode derived from vertex shader program geometry shader microcode derived from geometry shader program and fragment shader microcode derived from fragment shader program . GPU microcode assembler further directs each of these three objects of microcode to an appropriate programmable processing unit. More particularly GPU microcode assembler directs vertex shader microcode geometry shader microcode and fragment shader microcode to vertex processing unit primitive processing unit and fragment processing unit respectively. Vertex shader microcode executes on vertex processing unit to process the attributes of the received vertex typically associated with a geometric primitive. Similarly fragment shader microcode also executes on fragment processing unit to process fragment data which may include raster position depth or interpolated vertex attributes such as texture coordinates opacity and other relevant per pixel data to produce final pixel values. It should be apparent to a person with ordinary skill in the art that the various examples given above relating to compiler linker are for illustrative purposes only and should not be construed to limit the scope of the claimed invention.

As also shown in and previously mentioned herein another programmable processing unit in rendering pipeline includes a programmable primitive processing unit which can be configured to execute geometry shader microcode . Execution of geometry shader microcode generally takes place after the transformation of vertices but prior to color clamping and flat shading and clipping. As discussed above geometry shader microcode is derived from geometry shader program which broadly refers to a program developed in a high level shading language to operate on geometric primitives. In one implementation geometry shader program accepts geometric primitives such as points lines triangles lines with adjacent vertices and triangles with adjacent vertices shown in as input and generates new geometric primitives such as points line strips or triangle strips shown in as output. Geometry shader program is capable of receiving a set of vertices making up the input geometric primitive reading the attributes of any of these received vertices and emitting zero or more vertices making up the output geometric primitive. Geometry shader program can even emit vertices making up multiple disconnected geometric primitives. To emit a vertex geometry shader program collects all the output values places the collected data in a packet and transmits the packet as one vertex with certain attributes. A detailed description supporting the processing of the different input and output primitive types by a geometry shader program is set forth below in the next section of the present application.

Step determines when all the output values have been collected and the collected data are written out as a vertex with its attributes in step . In one implementation EmitVertex is called to specify the completion of processing on this vertex and to add this vertex to the current output geometric primitive. Step determines if a geometry shader has requested to terminate its current primitive built up from the vertices emitted in step . If so step sends the current primitive to rasterizer and starts a new empty primitive of the same type. In one implementation EndPrimitive is called in step to specify the end of the current primitive. Step identifies the end of the geometry shader execution. When the geometry shader finishes as in step the current primitive is sent to the rasterizer in step and a new geometry shader may be invoked with new input vertices. EndPrimitive does not need to be called under certain conditions. One condition is if the declared output type for geometry shader program is a point and the other condition is if geometry shader program generates only a single output geometric primitive.

System memory includes an application program one or more high level shader programs such as vertex shader program geometry shader program and fragment shader program shown in an API and GPU driver as shown in . Application program generates calls to the API in order to produce a desired set of results typically in the form of a sequence of graphics images. Application program also transmits one or more high level shading programs to API for processing within GPU driver . The high level shading programs are typically source code text of high level programming instructions that are designed to operate on one or more shaders within GPU . In one implementation the source code text is written in GLSL and API is the OpenGL API. GPU driver includes compiler linker GPU microcode assembler vertex shader microcode geometry shader microcode and fragment shader microcode as shown in and discussed above.

GPU driver transmits the aforementioned microcode shader programs to GPU local memory to be stored as microcode . In addition GPU local memory also includes a uniform storage buffer a texture buffer and a frame buffer . Uniform storage buffer stores one or more uniform variables also called uniforms. A uniform variable is held constant during a given invocation of the associated shader but may be altered between invocations. Texture buffer stores data elements typically organized in one dimensional two dimensional or three dimensional structures. Frame buffer includes at least one two dimensional surface that is used to drive display .

GPU includes vertex processing unit primitive processing unit and fragment processing unit as discussed above. The execution of microcode e.g. vertex shader microcode geometry shader microcode and fragment shader microcode on the programmable processing units e.g. vertex processing unit primitive processing unit and fragment processing unit imparts specific processing behavior according to specific requirements and specifications of application program .

Display is an output device capable of emitting a visual image corresponding to an input data signal. For example the display may be built using a cathode ray tube CRT monitor a liquid crystal display or any other suitable display system. The input data signal to display is typically generated by scanning out the contents of one or more frames of image data that is stored in frame buffer .

Extensions to the OpenGL Shading Language GLSL and related APIs to support a geometry shader are discussed in this section. Persons skilled in the art will appreciate that the information in this section should be considered in conjunction with the current OpenGL 2.0 specification.

A geometry shader can operate on one of five input primitive types. Depending on the input primitive type one to six vertices are available when the shader is executed. Each input primitive type supports a subset of the primitives provided by the GL. If a geometry shader is active Begin or any function that implicitly calls Begin will produce an INVALID OPERATION error if the parameter is incompatible with the input primitive type of the currently active program object as discussed below.

The input primitive type is a parameter of the program object and must be set before linking by calling ProgramParameteriNV with set to GEOMETRY INPUT TYPE NV and set to one of POINTS LINES LINES ADJACENCY NV TRIANGLES or TRIANGLES ADJACENCY NV. This setting will not be in effect until the next time LinkProgram has been called successfully. Note that queries of GEOMETRY INPUT TYPE NV will return the last value set. This is not necessarily the value used to generate the executable code in the program object. After a program object has been created it will have a default value for GEOMETRY INPUT TYPE NV.

The supported input primitive types are 1 POINTS Geometry shaders that operate on points are valid only for the POINTS primitive type. There is only a single vertex available for each geometry shader invocation 2 LINES Geometry shaders that operate on line segments are valid only for the LINES LINE STRIP and LINE LOOP primitive types. There are two vertices available for each geometry shader invocation. The first vertex refers to the vertex at the beginning of the line segment and the second vertex refers to the vertex at the end of the line segment 3 LINES ADJACENCY NV Geometry shaders that operate on line segments with adjacent vertices are valid only for the LINES ADJACENCY NV and LINE STRIP ADJACENCY NV primitive types. There are four vertices available for each program invocation. The second vertex refers to attributes of the vertex at the beginning of the line segment and the third vertex refers to the vertex at the end of the line segment. The first and fourth vertices refer to the vertices adjacent to the beginning and end of the line segment respectively 4 TRIANGLES Geometry shaders that operate on triangles are valid for the TRIANGLES TRIANGLE STRIP TRIANGLE FAN QUADS QUAD STRIP and POLYGON primitive types. For QUADS QUAD STRIP and POLYGON primitives individual polygons are decomposed into one or more triangles where the orientation of each triangle is consistent with the orientation of the original primitive. For such primitives the shader is executed once for each triangle in the decomposition. There are three vertices available for each program invocation. The first second and third vertices refer to attributes of the first second and third vertex of the triangle respectively and 5 TRIANGLES ADJACENCY NV Geometry shaders that operate on triangles with adjacent vertices are valid for the TRIANGLES ADJACENCY NV and TRIANGLE STRIP ADJACENCY NV primitive types. There are six vertices available for each program invocation. The first third and fifth vertices refer to the first second and third vertices of the triangle. The second fourth and sixth vertices refer to adjacent vertices on the other side of the triangle edge connecting the neighboring vertices.

A geometry shader can generate primitives of one of three types. The supported output primitive types are points POINTS line strips LINE STRIP and triangle strips TRIANGLE STRIP . The vertices output by the geometry shader are decomposed into points lines or triangles based on the output primitive type. If the number of vertices emitted by the geometry shader is not sufficient to produce a single primitive nothing is drawn.

The output primitive type is a parameter of the program object and can be set by calling ProgramParameteriNV with set to GEOMETRY OUTPUT TYPE NV and set to one of POINTS LINE STRIP or TRIANGLE STRIP. This setting will not be in effect until the next time LinkProgram has been called successfully.

Geometry shaders can access the transformed attributes of all vertices for its input primitive type through input varying variables. A vertex shader writing to output varying variables generates the values of these input varying variables. This includes values for built in as well as user defined varying variables. Values for any varying variables that are not written by a vertex shader are undefined. Additionally a geometry shader has access to a built in variable that holds the ID of the current primitive. This ID is generated by the primitive assembly stage that sits in between the vertex and geometry shader.

Additionally geometry shaders can write to one or more varying variables for each primitive it outputs. These values are flat shaded if enabled and clipped then the clipped values interpolated across the primitive if not flat shaded . The results of these interpolations are available to a fragment shader if one is active. Furthermore geometry shaders can write to a set of built in varying variables defined in the OpenGL Shading Language that correspond to the values required for the fixed function processing that occurs after geometry processing.

The OpenGL Shading Language specification describes the set of built in variables that are available as inputs to the geometry shader. This set receives the values from the equivalent built in output variables written by the vertex shader. These built in variables are arrays each element in the array holds the value for a specific vertex of the input primitive. The length of each array depends on the value of the input primitive type as determined by the program object value GEOMETRY INPUT TYPE NV and is set by the GL during link. Each built in variable is a one dimensional array except for the built in texture coordinate variable which is a two dimensional array. The vertex shader built in output gl TexCoord is a one dimensional array. Therefore the geometry shader equivalent input variable gl TexCoordIn becomes a two dimensional array.

Some examples of the built in variables include 1 gl FrontColorIn gl BackColorIn gl FrontSecondaryColorIn and gl BackSecondaryColorIn hold the per vertex front and back colors of the primary and secondary colors as written by the vertex shader to its equivalent built in output variables 2 gl TexCoordIn holds the per vertex values of the array of texture coordinates as written by the vertex shader to its built in output array gl TexCoord 3 gl FogFragCoordIn holds the per vertex fog coordinate as written by the vertex shader to its built in output variable gl FogFragCoord 4 gl PositionIn holds the per vertex position as written by the vertex shader to its output variable gl Position 5 gl ClipVertexIn holds the per vertex position in clip coordinates as written by the vertex shader to its output variable gl ClipVertex 5 gl PointSizeIn holds the per vertex point size written by the vertex shader to its built in output varying variable gl PointSize even if the mode VERTEX PROGRAM POINT SIZE is disabled and 6 gl PrimitiveIDIn is not an array and has no vertex shader equivalent. It is filled with the number of primitives processed since the last time Begin was called directly or indirectly via vertex array functions .

Similarly to the built in varying variables user defined input varying variables need to be declared as arrays. If no size vertex count is specified it will be inferred by the linker from the input primitive type. If a size is specified it has to be of the size matching the number of vertices of the input primitive type otherwise a link error will occur. The built in variable gl VerticesIn if so desired can be used to size the array correctly for each input primitive type. User defined varying variables can be declared as arrays in the vertex shader.

In one implementation a geometry shader is limited in the number of vertices it may emit per invocation. Providing this limit allows the hardware to manage its internal buffers more efficiently. The maximum number of vertices a geometry shader can possibly emit needs to be set as a parameter of the program object that contains the geometry shader. This limit needs to be set before executing the geometry shader. To do so call ProgramParameteriNV with set to GEOMETRY VERTICES OUT NV and set to the maximum number of vertices the geometry shader will emit in one invocation. There are two implementation dependent limits on the value of GEOMETRY VERTICES OUT NV. First the total number of vertices may not exceed the value of MAX GEOMETRY OUTPUT VERTICES NV. Second the product of the total number of vertices and the sum of all components of all active varying variables may not exceed the value of MAX GEOMETRY TOTAL OUTPUT COMPONENTS NV. If it does ProgramParameteriEXT will generate the error INVALID VALUE.

A geometry shader can write to built in as well as user defined varying variables. These values are expected to be interpolated across the primitive it outputs unless they are specified to be flat shaded. In order to seamlessly be able to insert or remove a geometry shader from a program object the rules names and types of the output built in varying variables and user defined varying variables are the same as for the vertex shader.

 1 gl FrontColor gl BackColor gl FrontSecondaryColor and gl BackSecondaryColor hold the front and back colors for the primary and secondary colors for the current vertex 2 gl TexCoord is an array and holds the set of texture coordinates for the current vertex 3 gl FogFragCoord is used as the c value as described in section 3.10 Fog of the OpenGL 2.0 specification 4 gl Position is intended to hold the homogeneous vertex position 5 gl ClipVertex holds the vertex coordinate used in the clipping stage 6 gl PointSize if written holds the size of the point to be rasterized measured in pixels and 7 Additionally a geometry shader can write to the built in special variables gl PrimitiveID and gl Layer whereas a vertex shader cannot. The built in gl PrimitiveID provides a single integer that serves as a primitive identifier. This written primitive ID is available to fragment shaders. If a fragment shader using primitive IDs is active and a geometry shader is also active the geometry shader must write to gl PrimitiveID or the primitive ID number seen by the fragment shader is undefined. The built in variable gl Layer is used in layered rendering.

More specifically layered rendering allows an application to bind an entire complex texture to a framebuffer object and render primitives to arbitrary layers computed at run time. For example this mechanism can be used to project and render a scene onto all six faces of a cubemap texture in one pass. The layer to render to is specified by writing to the built in output variable gl Layer. Layered rendering requires the use of framebuffer objects. When a geometry shader using layered rendering is active rasterizer shown in selects a provoking vertex from each point line or triangle emitted by the geometry shader. When rendering that primitive the layer of the complex texture used is given by the value of gl Layer for the provoking vertex.

The above description illustrates various embodiments of the present invention along with examples of how aspects of the present invention may be implemented. The above examples embodiments and drawings should not be deemed to be the only embodiments and are presented to illustrate the flexibility and advantages of the present invention as defined by the following claims.

