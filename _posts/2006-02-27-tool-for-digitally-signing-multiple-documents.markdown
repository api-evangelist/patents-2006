---

title: Tool for digitally signing multiple documents
abstract: A software tool for digitally signing multiple documents is disclosed. When a user wishes to sign multiple documents containing embedded executable code for purposes of authenticating the code, the user launches this software tool. The user specifies the documents which he or she wishes signed. Thereupon, the tool automatically signs each of the documents and displays the results.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08205087&OS=08205087&RS=08205087
owner: Microsoft Corporation
number: 08205087
owner_city: Redmond
owner_country: US
publication_date: 20060227
---
Documents created running and displayed on computers contain user information. For example spreadsheet documents contain financial information word processing documents contain alpha numeric textual information presentations can contain image graphic chart information etc. In some cases application programs enable software to be embedded within the documents. The software runs in the background and is used to execute an explicit programmed set of instructions or commands corresponding to that document. For example one or more instructions can be executed to create a shortcut . Rather than individually executing a series of instructions a user can simply invoke the shortcut which then automatically executes the programmed series of instructions. In this manner a user can hot button one or more macros to expeditiously execute functions which would otherwise have to be repeated manually over and over again each time that function is to be performed. This facilitates the creation editing and manipulation of the documents. Another way by which software can be used is for automatically filling out templates or forms. For example software can read data entered in one field and automatically forward this information so that it is appropriately written to other parts of the document. The information can even be used to fill in the relevant parts of other documents. Moreover software can be embedded within certain documents to manipulate data or to trigger external events. There are numerous ways by which software can be embedded in documents to achieve desired results or to streamline a business process. Thus embedding software in documents offer a clear cut way to improve worker productivity minimize redundancy automate and thereby cut costs.

However as the software embedded in various documents are created updated or otherwise edited it becomes critical to track the changes so that the corresponding documents contain the latest versions of the embedded software. Otherwise the software embedded within the documents may become corrupted or obsolete. More ominously software can be compromised or otherwise hacked by malicious third parties. Each time software is embedded in a document there is an opportunity for a third party to maliciously exploit that software. Consequently it is imperative that the embedded software is authenticated to ensure that it is indeed a clean unadulterated and most up to date version.

One way to ensure the authenticity of software embedded in a document entails attaching a digital signature to the software. A digital signature is used to ensure that the corresponding software has not been changed or edited since the digital signature was created. This significantly minimizes the chances of running any malicious code in the documents and informs users of the effective date of the software.

Presently embedded software is digitally signed by first launching the application that created the document opening the document then launching some type of editor program to actually create and attach the digital signature to the embedded software. With this process the embedded software has to be individually digitally signed one at a time. Given that an organization company or institution can have thousands upon thousands of documents containing embedded software it can be quite time consuming and cumbersome to generate digital signatures on an individual basis. Further complicating matters is the fact that a digital certificate is required to digitally sign the embedded software. Due to its sensitive function the digital certificate is kept in a secure location and access to the digital certificate might intentionally be limited to a small group of trusted employees. These two factors impede the rate by which software can be digitally signed. Thus digitally signing software for authentication purposes acts as a bottleneck and impedes the distribution of software embedded within documents.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

A software tool designed to digitally sign software embedded in multiple documents is disclosed. A user identifies one or more documents which have embedded software which need to be digitally signed. The software tool accesses a certificate one time for generating a number of digital signatures. The digital signatures are attached to the software. Thus the software tool enables a user to efficiently quickly and effortlessly sign software embedded in a number of different documents by launching a single cohesive process.

A software tool for digitally signing any number of documents is described. Referring to a flowchart of one embodiment of a signing tool is shown. Initially in step a user such as an information technology IT administrator identifies one or more documents which need to be digitally signed. Documents may also be automatically identified. For example change dates of the documents or other signs of modification can be used to identify the documents. Or the documents may be identified by their inclusion of a reference to a program project add in etc. that has been updated. In one embodiment the software embedded in a document may need to be digitally signed in order to allow authentication of the document and any software corresponding to contained in or embedded within the document. Each time embedded software is updated edited or otherwise changed all documents having this software embedded therein need to have their embedded software re signed. In one embodiment the certificate for generating the digital signatures is specified through user configuration input. In step the user specifies an appropriate certificate which can then be verified. At step the certificate is then accessed one time and used to generate digital signatures for the software embedded in each of the documents. In one embodiment the certificate is stored in non volatile memory such as a hard disk drive. The certificate is read from the non volatile memory and temporarily stored in cache memory such as SRAM memory. The certificate is repeatedly accessed from the cache memory to generate digital signatures until all the software and or documents are digitally signed as shown in steps and . In one embodiment the certificate and the private key are stored separately. And in step the signing tool generates the results which are reported to the user. Thus the signing tool can be launched once to sign any number of documents. The user can specify a single hundreds or even thousands of documents which need to be signed. The signing tool then automatically generates the digital signatures for signing the software embedded in each of the documents. This highly automated process is much more efficient and less labor intensive than requiring a user to execute a software program to sign a single document and then having the user re execute that software program to sign another document and then having the user repeatedly execute the software program to separately sign each document on an individual basis. In one embodiment there is no need to have the software application that created the documents open or running in order for the documents to be signed. In the past users typically had to sign software embedded in their documents by launching the application the document belongs to opening the document then launching the VB Editor and signing through the editor. This means that only one document can be signed at a time and it required the application to be running on the machine. Rather than signing through an application one can now sign without the hosting application. This is accomplished through the use of the application library code signing modules of the operating system. These pre registered modules contain the logic for signing a document format and storing the signature. These modules are used indirectly through calls to operating system cryptography APIs and therefore it eliminates the need for an originating application to be running or even installed on the machine in order to digitally sign software embedded in documents. Furthermore in one embodiment the user interface is implemented as a command line tool. In other embodiments a graphical user interface GUI tool can be used to facilitate the signing process.

In process block the .ini document settings are configured. The .ini document enables administrators to add options or otherwise configure or tailor the operation of the signing tool. For example an administrator can specify the common name of a valid code signing certificate e.g. CertName in the .ini document. The certificate should be stored on the same computer upon which the signing tool is running. Typically administrators run the signing tool on their computers so there should not be any permission or security concerns with accessing the certificates. If this option is selected the signing tool signs all documents using the certificate with the common name in the certificate store e.g. the My certificate store . Certificates located in other stores such as Trust and Root are not supported for use in signing the documents in one embodiment. Alternatively an administrator can specify the name of a .PFX formatted document. The relative or absolute path to the local computer to an external drive or to a UNC path can be specified. It should be noted that one of either a CertName argument or a CertPFXFile argument should be specified but not both.

The .ini document can also include a Verify argument. This argument indicates that the signing tool should verify whether the signature on the software is valid. If both signing and verification options are selected the signing operation occurs before the verification so that the new signature is verified. This Verify option can be selected independent of the signing options. In effect the signing tool can verify signatures on a document sign and then verify run antivirus scans and verify that the document is signed successfully but not sign or perform all three operations. Running an antivirus scan before signing results in a higher level of confidence in the integrity of the documents being signed. Optionally a Timestamp argument e.g. TimestampURL can specify a time stamp server if an administrator wishes to add a time stamp to the signature. Documents can be signed without a time stamp. If this Timestamp option is selected the signing tool attempts to use the TimestampURL. If it fails a timeout is generated and the failed Timestamp operation is noted. Another option entails specifying one or more log files e.g. Logfile . The results of processing the documents are written to these log files. One log file can contain documents which were processed successfully. Another log file can contain documents which failed to process successfully. In addition when a folder name is specified the administrator can specify an option e.g. Searchsubfolder indicating whether the signing tool should process documents in subfolders within the specified folder. It should be noted that the signing tool is not limited to the above examples of how the .ini document can be configured.

Once the documents have been properly identified and the .ini document has been set the signing tool prepares the documents for signing in process block and performs the actual signing in process block . These two process blocks are responsible for finding the software embedded in the document extracting it signing it and writing the signature of the software back to the document. During operation the signing tool either copies the documents listed in the specified input document or if a folder name is provided the signing tool traverses the folder and sub folders to access and copy the documents. In both cases the documents are copied from their location to the user s TEMP folder on the computer where the signing tool is running. The documents are then signed and re copied to the original folder overwriting the original document if one exists. When signing a document the signing tool locks the original document from writing and deleting so other processes cannot access or otherwise change it while the tool processes the temporary local document. The tool releases the lock as it replaces the original document with the temporary document if the signing was successful. The signing tool then deletes the temporary documents. The signing tool uses temporary documents does not process documents in place so as to reduce the risk of corrupting the documents should an error occur during the tool operation.

As the signing tool runs it displays progress on the console. For example documents that are successfully processed are displayed in green documents that generate warning are displayed in yellow and those that fail processing are displayed in red. The signing tool displays summary information at the end of the run. The results are analyzed and reported back to the administrator in process block . The signing tool can optionally include detailed error reporting and error handling functions. Consequently the administrator has an opportunity to correct errors if any . The signing tool can be re run as many times as necessary to sign all of the requisite documents as shown in process block . In one embodiment the success and failure information pertaining to the signing of the embedded software is separated into two log files. Once can easily identify the documents that failed look through the reasons for failure and possibly re run the signing tool based on the information in the failure log file. One can also look through the warnings and decide if they want to re run the signing tool on the flagged documents.

Once all antivirus scans have been executed or in the case whereby no antivirus scan was specified the process proceeds to step . Step determines whether a certificate is specified in the .ini document. If a certificate was specified the document is signed in step . As part of step the operating system determines the particular tool or module which is registered to handle the particular document type. For example if the tool has requested storing a digital signature in a Microsoft PowerPoint document the operating system determines which of the registered modules is designated as processing Microsoft PowerPoint documents and accordingly invokes that particular module. The operating system makes a determination as to whether a registered module has been found to handle the designated document type of the application document. If not a failure status is returned. Otherwise the operating system issues a request to determine the hash value for the document. The tool parses the particular application document to determine the location of the embedded portion of code using the appropriate module for the particular format of the document being processed. The tool returns the hash value to the operating system. The operating system constructs a digital signature using the hash value certificate specified in step and the associated private key. The signing tool stores the signature in the document in accordance with the particular structure format of that document. The tool parses the document and stores the signature in accordance with the document s structured format using the appropriate application specific library. In one embodiment a single application library may be utilized in connection with processing all the document types of a particular application program associated with the library.

Next the process checks in step whether the signing operation was successful. If the signing operation is not successful this fact is logged in the output failure log of step . Otherwise if the signing was successful or if there was no specified certificate then the process proceeds to execute step . In step a determination is made as to whether the Verify option was specified in the .ini document. If verification was not specified the process logs a successful signing in the output success log of step . However if the verify option was specified the process verifies the document in step . Thereupon it checks whether the verification operation succeeded in step . A successful verification is logged in the output success log of step . An unsuccessful verification is logged in the output failure log of step . Upon completion of either step or step the process determines in step whether there are more documents which need to be signed. If there are additional documents to be signed or if the user wishes to verify additional documents the process proceeds to step and the flow proceeds from step as described above. Otherwise if no more documents are to be signed or verified the process ends.

Referring now to an example of a suitable computing environment in which embodiments utilizing the techniques described herein may be implemented is shown. The computing environment illustrated in is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the techniques described herein. Those skilled in the art will appreciate that the techniques described herein may be suitable for use with other general purpose and specialized purpose computing environments and configurations. Examples of well known computing systems environments and or configurations include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like. The techniques set forth herein may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Included in are a user computer a network and a server computer . The user computer may be a commercially available computer or a special purpose computer that may be used to execute one or more program modules. Described in more detail elsewhere herein are program modules that may be executed by the user computer . The program modules are used in connection with digital signature and verification techniques to provide a signature for embedded code within an application document in an automated fashion for a variety of different structured document formats. The user computer may operate in a networked environment and communicate with a server computer to perform requests made by the user computer . It will be appreciated by those skilled in the art that although the user computer is shown in the example as communicating in a networked environment the user computer may communicate with other components utilizing different communication mediums. For example the user computer may communicate with one or more components utilizing a network connection and or other type of link known in the art including but not limited to the Internet an intranet or other wireless and or hardwired connection s .

Referring now to an example of components that may be included in a user computer as may be used in connection with performing the various embodiments of the techniques described herein is shown. The user computer may include one or more processing units memory a network interface unit storage one or more other communication connections and a system bus used to facilitate communications between the components of the computer . Depending on the configuration and type of user computer memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. Additionally the user computer may also have additional features functionality. For example the user computer may also include additional storage removable and or non removable including but not limited to USB devices magnetic or optical disks or tape. Such additional storage is illustrated in by storage . The storage may include one or more removable and non removable storage devices having associated computer readable media that may be utilized by the user computer . The storage in one embodiment may be a mass storage device with associated computer readable media providing non volatile storage for the user computer . Although the description of computer readable media as illustrated in this example may refer to a mass storage device such as a hard disk or CD ROM drive it will be appreciated by those skilled in the art that the computer readable media can be any available media that can be accessed by the user computer .

By way of example and not limitation computer readable media may comprise computer storage media and communication media. Memory as well as storage are examples of computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by user computer . Communication media typically embodies computer readable instructions data structures program modules or other data. Combinations of any of the above should also be included within the scope of computer readable media. The user computer may also contain communications connection s that allow the user computer to communicate with other devices and components such as by way of example input devices and output devices. Input devices may include for example a keyboard mouse pen voice input device touch input device etc. Output device s may include for example a display speakers printer and the like. These and other devices are well known in the art and need not be discussed at length here. The one or more communications connection s are an example of communication media. In one embodiment the user computer may operate in a networked environment using logical connections to remote computers through a network. The user computer may connect to the network of through a network interface unit connected to bus . The network interface unit may also be utilized in connection with other types of networks and or remote systems and components.

One or more program modules and or data documents may be included in storage . During operation of the user computer one or more of these elements included in the storage may also reside in a portion of memory such as for example RAM for controlling the operation of the user computer . The example of illustrates various components including an operating system a digital signature API an application code signature and verification tool a hash generator a signature generator one or more application programs one or more application documents a signing tool and other components . The ways by which these components operate in conjunction to sign embedded software to perform the steps in the processes shown in the flowcharts of are described below. The operating system may be any one of a variety of commercially available or proprietary operating system. The operating system for example may be loaded into memory in connection with controlling operation of the user computer. One or more application programs may execute in the user computer in connection with performing user tasks and operations. It should be noted that although the program modules and or data documents included in storage are illustrated in this example as being included on user computer an embodiment may also include some or all of these elements in the storage of another computer such as the server computer which may perform the techniques described herein.

Application documents may be used with particular application programs . In one example an application program may be for example a word processing application such as Microsoft Word or other Microsoft Office application program. The application program may access an application document. The application document may be stored in an application specific document format that may vary with the particular application program. Included within the application document may be a code portion which can executed at any point in time when the document is open for processing by the application program. The code portion included in the document may be for example code included in a Visual Basic for Applications or VBA project area. The code may be characterized as embedded within the application document for use in connection with performing processing operations on the document by the application program. Depending on the application code may be generated by the application program as the result of for example macro processing operations. A user may also provide code which may be included in the VBA project area.

The techniques described in following paragraphs may be used in connection with locating the particular code portion such as for example the VBA project area of a document forming a digital signature for the code portion optionally verifying the digital signature and then storing the digital signature in the document in accordance with the structure of a particular application s document format. One embodiment of the techniques for digital signature formation and verification is described in more detail in U.S. patent application Ser. No. 11 364 403 filed Feb. 27 2006 entitled Techniques for Digital Signature Formation and Verification which is incorporated by reference herein.

It should be noted that although the techniques described herein store the signature as part of the application document the signature may be stored elsewhere. Additionally although specific reference for illustration purposes herein refer to code portions the techniques described herein may also be used in connection with one or more portions of a structured document format in which each portion may include source code executable code scripts including instructions in a human readable form and the like which may be used in connection with the application program associated with the particular structured document format. The examples herein may also refer to Microsoft Office documents but as will be appreciated by those skilled in the art may also be used in connection with other documents for digitally signing code portions associated therewith or for signing document content other than executable code.

The techniques described herein provide for automated formation and or verification of a digital signature for such code portions without utilizing the application program. In other words the digital signature may be formed and or verified without requiring the particular application to be installed on the user computer or other computer such as the server computer which may be servicing a request for digital signature formation and or verification. The digital signature API may include a select set of application programming interfaces or APIs used in connection with digital signature and encryption functionality. In one embodiment the digital signature API may include an API which in turn results in making one or more underlying calls utilizing functionality included in the operating system . For example a digital signature API may result in one or more Win 32 APIs being invoked in an embodiment utilizing a Microsoft Windows operating system.

The application code signature and verification tool may be registered with the operating system as the particular tool used to parse and process particular document formats such as for example Microsoft Office document formats. As will be described in more detail in following paragraphs one embodiment of the tool is capable of processing a variety of different application document formats associated with Microsoft Office applications. The tool searches for a single VBA project in each of the document formats and generates and or verifies a single digital signature for all of the code included in a single VBA project for an application document. Each of the different application document formats may store the VBA project and or signature at different locations in accordance with each of the different formats.

The hash generator may be used in connection with generating a hash value for a particular code portion included an application document. It should be noted that in connection with the techniques described herein any one of a variety of different publicly available or proprietary hash generation techniques may be used in connection with the processing described herein.

The signature generator may be used in connection with generating a digital signature using a hash such as produced by the hash generator a digital certificate and a corresponding private key. Any one of a variety of different techniques may be used in connection with generating a digital signature in accordance with a particular hash and digital certificate. In one embodiment the SHA 1 algorithm may be used to generate a digital signature used in connection with the techniques described herein. The signing tool may be used in connection with forming a digital signature and or performing verification of the digital signature for one or more application documents in one or more different document formats for various application programs. In other words the signing tool may be used in connection with forming digital signatures for multiple documents in which each of the documents is in a different structured format. In one embodiment the signing tool may invoke the application code signature and verification tool in connection with digital signature formation and verification for an application document. In one embodiment the certificate is stored locally in memory . Thereby rather than having to read the certificate from a remote device or from storage the signing tool accesses memory to obtain the certificate to sign the document. Accessing the certificate from memory is faster than accessing the certificate from storage or from a remote location over a network.

Referring now to a block diagram illustrating how components in one embodiment communicate with each other in connection with performing the techniques described herein is shown. In particular the example illustrates how components previously described in connection with may interact in connection with performing the techniques described herein for signature generation and verification. In one embodiment the signing tool may utilize one or more APIs included in the digital signature API to form and or verify a digital signature in connection with one or more application documents. It should be noted that although the tool is shown as accessing the application document one or more other components may also access application documents.

In one embodiment invocation of a digital signature layer or service may result in invocation of one or more operating system calls such as for example one or more calls using the Win32 API to routines included in the operating system . The digital signature layer may be characterized as a software layer used to invoke one or more processing steps to perform a particular operation in connection with digital signature processing. Use of a software layer such as the digital signature layer facilitates performing a particular task for a calling program such as the signing tool since the tool may make a single API call resulting in performance of one or more underlying operating system calls. Subsequently the operating system queries one or more registered modules each having a predefined interface to determine which of the registered modules can process a particular document type associated with an application document. In one embodiment the application code signature and verification tool is registered as capable of processing Microsoft Office documents. In an embodiment each document type may correspond to a different document format or variation of a document format associated with an application.

When the signing tool is processing a Microsoft Office document the operating system interacts with the tool for formation and verification of the digital signature associated with the document. The tool makes calls to application specific libraries such as libraries and in connection with parsing and performing processing for the different document formats. In other words the tool invokes a specific application library for processing application documents in a first format as may be used by a first application program. For example the tool may utilize application library when processing Microsoft Word application documents. The tool may also utilize application library when processing Microsoft PowerPoint application documents. Similarly there may be a distinct and separate application library for processing application documents utilized by each different application program included in Microsoft Office . The foregoing use of application specific libraries provides for modularized coding techniques. It should be noted that in one embodiment the tool may be implemented as a DLL and the application specific libraries may be included as static libraries therewith. The application specific libraries may include a predefined interface utilized by the tool in connection with parsing the document in accordance with a particular structured format to perform operations on certain portions of the document as well as store information into the document in accordance with the structured format. As described herein the tool may invoke an application specific library to locate a code portion of a document and for storing a digital signature to the document in accordance with the document s defined structure.

The tool may also interact with the hash generator when determining the hash for a particular code portion such as a VBA project included in a document. The tool may communicate the hash value for a particular code portion to the operating system which may in turn use the generated hash value and a digital certificate for generating a digital signature by invoking the signature generator . Once the digital signature has been formed the operating system may interact with the tool to store the digital signature in the document. The tool may then utilize the particular application library to store the digital signature in the appropriate location in the particular document format.

Although the subject matter above has been described in a language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

