---

title: Flexible constraint propagation engine for combinatorial optimization applications
abstract: The present disclosure describes a computer-implemented constraint propagation system that supports a variety of different constraint propagation and/or constraint retraction algorithms, including monotonic and/or non-monotonic algorithms. In one embodiment, the system selects particular constraint propagation and/or retraction methods based on the nature of the combinatorial optimization problem (COP) being solved and the attributes of the particular COP application involved. The system may also enable new methods for constraint propagation and/or retraction to be added with relatively little disruptive effect on other components of the system. Embodiments of the system allow the propagation of constraints to be tuned to the semantics of each constraint, the likelihood of significant variable domain reduction, and other problem specific properties. The constraint propagation system is capable of being used as part of a reconfigurable search engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07606776&OS=07606776&RS=07606776
owner: Actenum Corporation
number: 07606776
owner_city: Vancouver, BC
owner_country: CA
publication_date: 20060928
---
The present application claims benefit under 35 U.S.C. 119 e of U.S. Provisional Patent Application No. 60 721 201 filed Sep. 28 2005 entitled FLEXIBLE CONSTRAINT PROPAGATION ENGINE FOR COMBINATORIAL OPTIMIZATION APPLICATIONS which is hereby incorporated by reference herein in its entirety.

The present disclosure relates to search engines for solving combinatorial optimization problems and more particularly relates to computer implemented methods and software architectures for implementing constraint propagation and retraction algorithms.

Constraint Programming CP methods are applicable to solving hard combinatorial optimization problems such as scheduling planning configuration routing resource allocation timetabling and rostering. Constraint propagation which is a central technology employed in many CP systems uses the constraints defined in a given problem model to greatly reduce the size of the search space that is searched to find solutions to a combinatorial optimization problem. Since the size of the search space for combinatorial problems is generally exponential in the size of the problem e.g. the number of variables in the problem model reducing the size of this search space using constraint propagation algorithms is frequently essential for solving large problems where a significant fraction of the points in the search space may need to be visited in order to find a solution.

An effective approach for speeding up search is to reduce the search space as much as possible after every step of the search. Constraint propagation enforces a certain level of constraint consistency that results in a smaller search space. Typically in constraint programming constraint propagation is intermixed with a search method that is used to derive new constraints. These new constraints are then propagated by the constraint propagation algorithm. The intended result is to reduce the search space as the search method explores those regions of the search space which remain after constraint propagation.

Many constraint propagation methods use variants and enhancements of the arc consistency A C algorithm see e.g. Mackworth77 . It is known that use of the A C algorithm mathematically guarantees that every value in the domain of a variable is allowed by the constraints on this variable given the current domains of the other variables in the problem model. Values removed by the A C algorithm are not part of any feasible assignment of the variables under the constraints of the problem model. However not every value remaining in the domain after use of A C is necessarily part of a feasible complete solution. Accordingly a search must still be performed to find actual feasible solutions from within the reduced search space.

Arc consistency defined for constraints that involve more than two variables is called generalized arc consistency. A Constraint Satisfaction Problem CSP is generalized arc consistent or hyper arc consistent if 

In the CP literature the A C enforcing mechanism variously consists of activating a constraint and computing an arc consistent state after one or several value removals and hence the global propagation loop is directed by constraints constraint centered . Alternatively the global propagation loop is driven by domain reductions variable centered .

Traditional monotonic constraint propagation such as arc consistency and its variants is an important part of a CP system and well understood and efficient algorithms are known see e.g. Bessi re01 . Monotonic constraint methods typically remove values from the domains of variables that do not satisfy the constraints on these variables.

Non monotonic constraint propagation methods like monotonic constraint propagation methods can remove values that do not satisfy the constraints. However unlike monotonic methods non monotonic methods are also able to put back values into variable domains if the constraints on those variables are retracted. Non monotonic constraint propagation is less well developed and the complexity of non monotonic algorithms generally is greater than monotonic constraint propagation algorithms. Combinatorial optimization applications in which a problem changes dynamically as well as Mixed Initiative MI applications in which the user interacts with the system can be equivalent to the addition and or retraction of constraints in the problem model. The run time performance and search memory needed for constraint propagation and or retraction can vary greatly for different implementations of non monotonic methods.

Constraint retraction is a widely used technique in non monotonic constraint propagation methods. Constraint retraction may occur in a search during backtracking and user interaction and in dynamic problems. If a constraint is retracted domain reduction that has occurred directly or indirectly due to the presence of the retracted constraint is undone by the system. Different dynamic constraint retraction algorithms have different implementation difficulty memory requirements and running efficiency see e.g. Neveu94 and Bartak04 . Each algorithm has particular advantages and disadvantages and can be selected for use by the constraint propagation engine to suit specific requirements of a combinatorial optimization application.

The CHOCO algorithm for example utilizes an event based constraint propagation algorithm see e.g. Laburthe00 . During propagation each time a variable domain is reduced called a variable event the constraints involving that variable are processed and in turn these constraints generate new variable events thus removing more values from the domains of their argument variables. The CHOCO algorithm considers the following propagation events for finite domain variables 

All variable events in the CHOCO algorithm have the same life cycle they are first generated then the domain modification is applied then they are stored in an event queue and finally they are removed from the queue and executed by awakening the corresponding constraints except the one that caused the event . At run time this life cycle can stop at the domain modification step if the event does not add new information to the current status of the domain i.e. does not change it . When a constraint is awakened it can either be immediately propagated or delayed until all variable events have been processed. Thus propagation can be either variable directed or constraint directed.

There are different strategies for performing constraint propagation. For example in a Depth First Search when a variable event is executed all children variable events resulting from the constraint propagation are propagated before other pending variable events. In contrast in a Breadth First Search variable events are propagated by generation. The choice of the CP strategy will depend on the combinatorial optimization application. For example in the CHOCO algorithm all INSTANTIATE events are stored in a Last In First Out LIFO queue all REMOVAL events are stored in a separate First In First Out FIFO queue and all INCINF and SUPINF events are stored in another FIFO queue. The order of propagation then is defined as follows 0 all INSTANTIATE events 1 all REMOVAL events 2 all INCINF and DECSUP events 3 all touched constraints defined explicitly as feasible tuples 4 all delayed constraints with linear runtime 5 all delayed constraints with sub quadratic runtime 6 all delayed constraints with quadratic runtime and 7 all delayed constraints with higher complexity runtime. Since global constraints are often awakened after several variable events have occurred such constraints need to take a global view of what has changed hence global constraints consider the changes as an abstract event e.g. something has changed . Some global constraints have special abstract events which contain more detailed information.

Previous constraint programming systems have selected a particular constraint propagation architecture and have hardwired it into a search engine also known as a reasoning engine . Some systems use constraint centered methods and others use variable centered methods. Naive implementations of the CP architecture may be very inefficient. Recent work on the CHOCO constraint programming system takes some advantage of propagating constraints in an intelligent order depending on their domain reduction power see e.g. Laburthe00 . Researchers have studied the effectiveness of implementing different constraint propagation strategies see e.g. Schulte04 however these strategies also have been hard coded into the search engine.

When new propagation strategies are added the internal code of the search engine at the very lowest levels must be reprogrammed. For example this was the experience of researchers who implemented the PALM system on top of the CHOCO kernel see e.g. Jussein00b . The PALM extension to CHOCO incorporated non monotonic propagation To integrate new functionality into CHOCO to support non monotonic propagation the researchers needed to extend all variable classes to include explanations. In addition the behavior of all constraints in CHOCO needed to be specialized in order to add explanation computation code and to add a method that provides an explanation for every domain modification that the constraint performs.

The present disclosure describes a computer implemented constraint propagation system that supports a variety of different constraint propagation and or constraint retraction algorithms including both monotonic and non monotonic algorithms. In one embodiment the system selects particular constraint propagation and or retraction methods based on the nature of the combinatorial optimization problem COP being solved and the attributes of the particular COP application involved. The system may also enable new methods for constraint propagation and or retraction to be added with relatively little disruptive effect on other components of the system. Embodiments of the system allow the propagation of constraints to be tuned to the semantics of each constraint the likelihood of significant variable domain reduction and other problem specific properties.

Embodiments of the constraint propagation system provide a flexible reconfigurable propagation engine that can support at least several alternative constraint propagation and or retraction methods. For example embodiments of the system support a variety of constraint propagation and retraction algorithms that can depend on the needs of the application at hand. In some embodiments the constraint propagation system supports an efficient non monotonic flexible constraint propagation engine. Non monotonic constraint propagation methods which may be used for dynamic constraint optimization problems COPs and Mixed Initiative MI applications may be implemented with the constraint propagation system. The constraint propagation system disclosed herein is capable of being used with a reconfigurable search engine.

The constraint propagation system may provide other benefits as well. For example the constraint propagation and or retraction methods can be selected to reduce memory storage requirements and to improve processor performance. Additionally by supporting integration of new propagation retraction techniques with minimal re programming of existing system architecture the constraint propagation system increases system reliability and reduces the likelihood of security vulnerabilities.

An embodiment of a constraint propagation system for use with a search engine configured to search for solutions to a combinatorial optimization problem is disclosed. The system comprises a constraint system configured to store in a computer memory information related to at least one constraint of a combinatorial optimization problem and to provide at least one message related to the at least one constraint. The message comprises at least one of an add constraint message and a retract constraint message. The combinatorial optimization problem comprises variables and constraints that specify a relationship among one or more of the variables. The constraint propagation system also comprises a propagator system configured to receive the at least one message from the constraint system and to execute in a computer processor constraint propagation instructions in response to the received message. The constraint propagation instructions include instructions for processing at least one of a variable event and a constraint event. A variable event represents a change to a value or a domain of a variable and a constraint event represents a change to a value or a domain of a variable associated with the constraint.

An embodiment of a method for constraint propagation in a search engine configured to search for a solution of a combinatorial optimization problem is disclosed. The constraint propagation method comprises communicating to a propagation processor information relating to an event associated with a solution of a combinatorial optimization problem. The event comprises at least one of a variable event and a constraint event. A variable event represents a change to a value or a domain of a variable and a constraint event represents a change to a value or a domain of a variable associated with the constraint. The method also comprises in response to the information executing instructions related to the event by the propagation processor wherein the instructions comprise at least one of variable event instructions and constraint event instructions. A computer readable medium may comprise computer executable instructions embodying the method.

An embodiment of a computer implemented method for configuring a constraint propagation engine comprises receiving combinatorial optimization problem COP information relating to a COP model. The COP model comprises a COP type variables and constraints. The method further comprises receiving a performance benchmark relating to a constraint propagation method that is usable with a search engine configured to search for a solution to the COP model. The method also comprises configuring a constraint propagation engine for use with the search engine using at least the COP information and the performance benchmark. An embodiment of a search engine is provided that comprises a constraint propagation engine configured according to the method. A computer readable medium may comprise computer executable instructions embodying the method.

Neither this summary nor the following detailed description of preferred embodiments is intended to limit the scope of the disclosed invention. The invention is defined by the claims and their equivalents.

Reference symbols are used in the figures to indicate certain components features and aspects shown therein with reference symbols common to more than one figure generally indicating like components features or aspects.

Certain specific embodiments of the invention will now be described in detail with reference to the drawings listed above. These drawings and description of the disclosed embodiments are presented by way of example only and do not limit the scope of the invention which extends to alternative embodiments and uses of the invention and to obvious modifications and equivalents thereof. Thus the scope of the invention is not to be limited to the preferred embodiments described below.

In any method or process described herein the acts or operations of the method process are not necessarily limited to any particular disclosed sequence. Also for purposes of contrasting different embodiments and the prior art certain aspects and advantages of these embodiments are described herein where appropriate. It should be understood that not necessarily all such aspects and advantages need be achieved in any one embodiment. Thus it should be recognized that certain embodiments may be carried out in a manner that achieves or optimizes one advantage or group of advantages without necessarily achieving other aspects or advantages that may be taught or suggested herein.

For purposes of providing one example of a search engine system in which the constraint propagation systems and methods of the present disclosure may be used a Reconfigurable Search Engine will be described with reference to and . As will be apparent the disclosed constraint propagation systems and methods are not limited to the Reconfigurable Search Engine shown but rather are applicable to a wide range of other search engine systems including systems that are capable of using only a particular type of search method.

A mathematical model of a combinatorial optimization problem COP is a formulation of the variables constraints and optionally one or more objectives to be optimized. A solution for the COP problem may be found by searching a search space to determine allowed values of the variables that satisfy the constraints and optionally that optimize the objectives. schematically illustrates a representation of the Reconfigurable Search Engine that can be used to find a solution to a COP Model . The Reconfigurable Search Engine comprises a Problem Model Compiler a Search Engine Instance a Constraint Store and a library of Reconfigurable Components . A solution is represented by Answers . In some embodiments of the Reconfigurable Search Engine the COP Model is analyzed by the Problem Model Compiler which assembles a Search Engine Instance that is customized to the particular COP Model . The Search Engine Instance is compiled from the library of Reconfigurable Components so as to implement one or more suitable search methods. The Constraint Store comprises a network of constraints and variables compiled by the Problem Model Compiler . The network of constraints and variables in the Constraint Store may be compiled using data structures compatible with the internal algorithms of the Search Engine Instance . The Search Engine Instance is then run e.g. executed on a computer or other suitable machine for manipulating data and instructions using the compiled Constraint Store to produce the Answers to the input COP Model .

In some embodiments the COP Model is represented in a suitable syntactic format such as for example an extensible markup language XML document. XML advantageously provides the ability to accurately describe very complex relationships among the variables constraints and objectives which appear in scheduling planning configuration and other COPs. The XML document specifies the variables appearing in the COP Model and their domains of allowed values. The XML document also specifies the constraints between subsets of variables in the COP Model and optionally specifies one or more objectives of the COP to be optimized. Although XML is a convenient and powerful way to specify the COP Model other languages or metalanguages can be used. For example as an alternative to providing an XML representation of the COP Model a graphical user interface GUI may be used that permits a user to provide an input description of the COP to be solved. Alternatively a customized input language can be defined for a specific application of the Reconfigurable Search Engine .

The Answers may also be represented in a suitable syntactic format such as for example XML. The Reconfigurable Search Engine does not require XML format and many other suitable input data representations may be used. For example the Answers may be displayed in a graphical user interface or used as an input to some other output or display system.

The Reconfigurable Search Engine may be used to solve a COP using one or more search methods including the search methods described above such as for example constructive search methods hybrid search methods or a combination thereof. A particular Search Engine Instance is composed of reusable and or reconfigurable components taken from the library of Reconfigurable Components . The components in the library may be precompiled. A complete representation of the Search Engine Instance is assembled from this component library for the type of COP being solved. In some embodiments an Application Programmer s Interface API is also provided so that users can optionally define their own reconfigurable components for the Reconfigurable Search Engine . Thus the Reconfigurable Search Engine can easily be extended and the new components reused in other applications.

The Problem Model Compiler analyses the input COP Model in order to determine how to select components from the library and to assemble a customized Search Engine Instance and a compatible Constraint Store that can be used to solve the given COP. In some embodiments the Problem Model Compiler assembles the Search Engine Instance and the Constraint Store in a semi automated manner with relatively minimal input from the user. An advantage of such embodiments is that the user does need not to understand the details of the assembled components or the internal representation of the Constraint Store . Because the Problem Model Compiler substantially handles the compilation of components needed to find the Answers users not versed in the art of constraint programming beneficially can use the Reconfigurable Search Engine to solve difficult COPs and to build customized applications using e.g. the optional API.

The Reconfigurable Search Engine may provide a broad spectrum of user control over the compilation process. For example in a novice embodiment or mode the user may simply utilize the Search Engine Instance which implements a default search method and variable constraint configuration for the given type of input COP. Alternatively in a custom embodiment or mode the user may specify one or more desired search methods and components from the library of Reconfigurable Components to create the Search Engine Instance . And in an expert embodiment or mode the user may add new components to the library of Reconfigurable Components using the API provided so as to implement a novel Search Engine Instance . These embodiments and modes are intended as examples only and are not intended to limit the range of possible user control over the compilation process.

The Problem Attributes also include attributes of the variables constraints and objectives if provided of the COP Model . The variables of the input COP Model may be characterized by various attributes including for example their type e.g. Boolean integer real etc. and the domain of possible values that each variable can assume in a feasible solution to the COP. The constraints are characterized by various attributes including their type and the set of variables which they constrain called their arguments in the given COP Model . The constraints limit the values that can be assigned to the variables in their arguments. Further each constraint specifies the allowed combinations of values that the argument variables can take on simultaneously. These allowed combinations of values may be represented for example syntactically in a table or specified intentionally via a logical formula comprising the argument variables e.g. a formula in conjunctive normal form . Alternatively the allowed combinations of values can be computed by a Boolean procedure that returns true if the current assignment of values to the argument variables is consistent under the constraint and false otherwise. In some embodiments an application programmer s interface API is provided and permits a user to define new constraints. These new constraints can then be added to the library of components e.g. the Constraint Store and or the Reconfigurable Components shown in and reused in subsequent applications. In some embodiments the API advantageously permits a user to define new constraint propagation and or retraction methods that can be used with the Constraint Store the library of Reconfigurable Components and or other suitable components in the Reconfigurable Search Engine .

In some COP Models the COP Model may include one or more objectives to be optimized. An objective can be characterized by various attributes including for example its type and whether its value should be minimized or maximized by the solution of the COP. The Problem Attributes described above are not intended to be limiting and in other embodiments the Problem Attributes can include other attributes features and characteristics of the COP Model that are not described herein.

In various embodiments the Reconfigurable Search Engine is configured for varying ranges of user input and control. For example in the embodiment of the Problem Model Compiler shown in a User can enter or otherwise input through the Obtain User Preferences module a set of user preferences. User preferences can for example specify custom components or parameters that the User desires the Problem Model Compiler to account for in assembling a Search Engine Instance and or a Constraint Store . For example in Mixed Initiative applications where the user and the system interact during the search to find a solution for the given COP user preferences may specify the types and amount of interactions desired with the user. For example in some embodiments the User may ask for and be provided with explanations of decisions made by the Search Engine Instance or the User may direct the Search Engine Instance into various regions of the search space during the search. In other embodiments the User may freeze particular aspects of the solution e.g. the Answers while directing the Search Engine Instance to search the remaining portions of the search space. The user preferences may include user overrideable default data for various functions methods and or parameters. Many other interactions between the User and a Search Engine Instance are possible.

As shown in the Problem Model Compiler analyzes the Problem Attributes of the COP Model in the Analyze Problem Attributes module . Together with the user preferences if any obtained in module the Problem Model Compiler selects an appropriate search method in a Choose Search Method module . Having determined an appropriate search method the Problem Model Compiler in module assembles appropriate components from the library of Reconfigurable Components to produce the Search Engine Instance . Many variations of existing search methods and or new search methods can be realized by the Problem Model Compiler by using existing components or components added by a user via the API in the library of Reconfigurable Components either automatically or under a degree of user control. The choice of search method in module determines at least partially which data structures are suitable for use in assembling the Constraint Store which is built by the Compiler in module .

The Analyze Problem Attributes module shown in can be realized in many possible ways. In one embodiment the module associates a default rule for each type of COP Model . The Problem Model Compiler in module assembles a suitable Search Engine Instance according to the default rule for that particular class of COP Model . For example if the type of the COP Model is an oversubscribed resource scheduling problem the Compiler can assemble a Constraint Store and Search Engine Instance using for example a permutation scheduling algorithm e.g. as described in Barabalescu04 . In another example if the type of the COP Model is a job shop scheduling problem the Compiler can assemble a Search Engine Instance using an implementation of a Tabu search algorithm see e.g. Glover93 . In this example the Compiler in module can assemble a Constraint Store to represent precedence constraints inherent in the job shop scheduling problem. Besides the examples above many other customized Search Engine Instances can be compiled by the Problem Model Compiler based on the type of the COP Model and user preferences input in module .

In one embodiment the Analyze Problem Attributes module utilizes a decision tree algorithm for choosing which search method to use. Branches of the decision tree correspond to the problem attributes of the COP Model determined in module and leaves of the decision tree correspond to specific search methods appropriate for these attributes. The Choose Search Method module uses the leaves decision tree to select a search method. The decision tree may be represented in a suitable syntactic formalism such as for example XML to facilitate development extension and maintenance of the Problem Model Compiler .

Another embodiment of the Problem Model Compiler uses an Analyze Problem Attributes module that implements one or more Artificial Intelligence AI techniques such as for example rule based systems machine learning methods and many other suitable AI techniques. For example a rule based system can be used to analyze the problem attributes of the COP Model and the user preferences. In one embodiment a customized search method is specified by the rule that best matches these attributes and user preferences. The rule based system can be represented in a suitable syntactic formalism such as for example XML to facilitate development extension and maintenance of the Problem Model Compiler .

Based on the particular attributes of the input COP Model and User Preferences the Problem Model Compiler may select from various possible constraint propagation and retraction algorithms provided by the constraint propagation systems disclosed herein. For example if the application requires Mixed Initiative MI interaction with the user then a constraint propagation and retraction algorithm which supports explicit explanations for each domain reduction e.g. as described by Jussein00b may be chosen by the Problem Model Compiler . Alternatively for applications not requiring MI interaction the Problem Model Compiler may select a non monotonic constraint propagation and retraction algorithm e.g. as described in Bartak04 . The constraint propagation systems described herein may be used in the Build Constraint Store component of the Problem Model Compiler in order to generate a realization of the Constraint Store see .

The Problem Model Compiler and the modules shown and described with reference to are not limited to these preferred embodiments described above. Many other implementations are also possible.

Certain embodiments of the Reconfigurable Search Engine use the algorithmic concept of iterative improvement in which a current search state is improved until a satisfactory solution is obtained or no solution can be found. In certain such embodiments a method by which a Search Engine Instance moves through the search space is controlled by the Neighborhood component . The method by which the Neighborhood component systematically avoids repeatedly visiting inconsistent or inferior regions of the search space is mediated by a Search Memory component . In some embodiments the Search Memory component implements one or more nogood maintenance methods to keep track of regions of the search space that have already been visited and that contain infeasible and or inferior solutions to the COP Model . In certain embodiments nogood maintenance methods are implemented in other components or are omitted. The Search Engine Instance evaluates each state in the search using the Objective Function component and determines when to return a solution or halt execution by the Termination Criterion component . The Search Engine Instance regulates the flow of control among these and other components by the Control Module component . By combining these components in various ways the Reconfigurable Search Engine can construct a Search Engine Instance that implements constructive and or local search methods using systematic and or non systematic search algorithms.

The library of Reconfigurable Components may include the above components as well as others . The library may include one or more versions of these components where each version for example may have different features or advantages or may implement different methods or techniques. The components and versions of components may be implemented using a common interface or protocol which provides interoperability among the components and substitutability for different versions of components. For example the components and versions may be compiled from a common API such as the API in Appendix A . The common interface may provide common messaging protocols memory access protocols common data structures etc. The components and versions of components in the library may be provided as e.g. source code modules precompiled modules dynamic link libraries etc.

The Reconfigurable Search Engine is modular and can be configured to provide a suitable search method for a particular COP. The Problem Model Compiler can select components and or versions of components from the library of Reconfigurable Components that are interoperable and can be readily assembled into a Search Engine Instance and Constraint Store . Components and versions of components may be reused by the Problem Model Compiler to assemble new Search Engine Instances . The components and versions may be modified and reconfigured for the particular COP application or to implement new features and methods. Users can utilize existing components and versions to create new components. The components and versions of components in the library of Reconfigurable Components accordingly may provide plug and play capability allowing them to be reused and or reconfigured as needed.

In some embodiments the Search Memory component implements a Nogood Maintenance Method to efficiently track and constrain searches in the search space. Embodiments of the Nogood Maintenance Method can be used with many different Search Engine Instances and in connection with a wide range of different search methods that record regions of the search space inferred to contain no or relatively few acceptable solutions to the input COP Model . Examples of Nogood Maintenance Methods that can be used are found in U.S. Provisional Patent Application No. 60 719 368 filed Sep. 22 2005 titled Nogood Maintenance Methods for Efficiently Tracking and Constraining Searches of a Search Space and U.S. patent application Ser. No. 11 526 163 filed Sep. 22 2006 titled Nogood Maintenance Methods for Efficiently Tracking and Constraining Searches of a Search Space the disclosure of each of which is hereby incorporated by reference herein in its entirety.

The systems and components shown in including the Constraint Store component can be implemented on a variety of types of computing systems including systems that are distributed on a local or wide area network. In some embodiments the Search Memory component comprises all or a portion of a computer memory such as for example a disk drive a solid state memory array or an optical drive such as a CD or DVD drive . It is contemplated that embodiments of the Search Memory component can be implemented in any type of machine readable storage medium. Some or all portions of such storage devices may be local or remote to the computer system on which the Reconfigurable Search Engine is implemented. The Search Memory component can also include a processing system which communicates with computer memory and which executes computer program instructions.

The Flexible Constraint Propagation Engine and the Reconfigurable Search Engine including the methods described herein may be implemented in software code modules executed by one or more general or special purpose computers or processors. These code modules may be stored by any type of computer readable medium or computer storage device. Some or all of the disclosed methods and components may alternatively be implemented in whole or in part using special purpose hardware including but not limited to application specific integrated circuits ASICs field programmable gate arrays FPGAs and or programmable logic devices PLDs . The Reconfigurable Search Engine and the FCPE may utilize additional and or different components than described herein. For example in some embodiments several components may be combined so that their functions and processes are implemented in a single processor or software module while in other embodiments their functions and processes may be shared among several different processors and or software modules.

In certain embodiments the constraint propagation system and methods described herein are implemented as a Flexible Constraint Propagation Engine FCPE included in the Reconfigurable Search Engine described above. The FCPE may be used to define the method utilized by the Constraint Store component see to realize the propagation and or retraction of constraints. The FCPE is capable of managing the search space represented by the constraints and variables contained in the compiled Constraint Store component by employing various combinations of constraint propagation and constraint retraction algorithms. However many algorithms have various desirable and undesirable properties which depend on the type of the Problem Model being solved and its particular representation in the Constraint Store component . The FCPE advantageously can be reconfigured to use the most appropriate constraint propagation algorithm and or retraction algorithm for a given application and given input COP Model . Some embodiments of the FCPE are modular and can use different search algorithms alternatively or in combination. In some embodiments the FCPE uses a flexible event based architecture.

In some embodiments new components of the Propagator can be defined using an API provided with the FCPE. An example API that may be used with the FCPE shown in is included in Appendix A which forms part of the disclosure of this specification. The example API in Appendix A includes main interface classes CWAcPropagationEngine and CWAcNonmonotonic PropagationEngine. The API also includes subclasses CWAcPropagationEvent with implementing classes CWAcConstraintEvent and CWAcVarEvent and with related classes CWJustification and CWExplanation. Embodiments of the constraint propagation system that include an API advantageously allow a user who is unfamiliar with data structures and search algorithms to create new instances of the FCPE.

In the embodiment shown in the Propagator accepts Add Constraint messages and Retract Constraint messages from the Constraint Store component of the Reconfigurable Search Engine see . When the Propagator receives an Add Constraint message it adds a Constraint Event to a queue which represents that the new constraint is to be evaluated in the Constraint Store component . This Constraint Event will then be executed in turn with other events by the Propagator . Other embodiments of the Propagator may be configured to accept different constraint messages from the Constraint Store component .

If the Propagator receives a Retract Constraint message its actions depend on the particular propagator component implemented in the FCPE. Some embodiments of the FCPE support non monotonic constraint propagation and or retraction methods. Based on its event based architecture the Propagator has well defined behavior for many constraint propagation retraction methods and a particular implementation of the Propagator can utilize one or more of these methods. Certain embodiments of the invention permit the Reconfigurable Search Engine to select the propagation and or retraction methods depending upon the characteristics of the COP the characteristics of the COP Problem Model the characteristics of the constraints associated with the COP and or other suitable information including e.g. run time performance and storage device requirements of the propagation retraction methods. The choice of which algorithm or combination of algorithms is appropriate may be made by the Problem Model Compiler based on a set of rules and user preferences if provided . Since there may be relatively significant differences in performance of various algorithms depending on the application the FCPE shown in can select a suitable algorithm in order to improve a performance benchmark related to for example computational run time performance or search memory requirements. Accordingly the FCPE disclosed herein provides flexibility in selecting an appropriate monotonic non monotonic and or other constraint propagation algorithm for a particular application.

In the embodiment shown in the Propagator accepts postings of events of two types Constraint Events and Variable Events . These events may be posted for example by evaluation of constraints or by the addition and or retraction of constraints in the Constraint Store component as described below . In block the Propagator determines whether there are any events that have not been processed. If there are no more events in block control returns to the Constraint Store component . If there are more events the Propagator selects an event either a Constraint Event or a Variable Event to be executed. Some embodiments of the Propagator are configured to accept postings of just a Constraint Event or just a Variable Event while other embodiments are configured to accept postings of both a Constraint Event and a Variable Event . The Propagator may also be configured to accept other types of events e.g. as described above . Many variations are possible.

In some embodiments the execution of a Variable Event signals an Argument Change to every Constraint whose argument variables are associated with the Variable Event . A Variable Event typically records changes to the Variable Domain such as for example whether an interval lower bound is refined whether a value is removed whether an interval upper bound is refined or some combination of these changes. schematically illustrates an example Variable Event comprising two Argument Changes however fewer or more Argument Changes may occur in other situations. Information related to Variable Events may allow some Constraints to efficiently process the change. For example if a constraint between variables A and B is the inequality A B then some argument changes such as e.g. refinement of the lower bound of the variable A do not require further processing.

If a Variable Event signals an Argument Change to a Constraint in block the Constraint determines whether this Variable Event is relevant to the Constraint . A Variable Event is relevant if and only if the changes recorded within the Variable Event could cause the Constraint to modify the Variable Domains of the its argument variables in the Constraint Store component . If the Variable Event is relevant then in block the Constraint updates its Constraint Event which in block is then posted back to the Propagator for execution. If in block the Variable Event is determined to be irrelevant to the Constraint no further constraint processing occurs for this event and in block the process returns to the Propagator to process any remaining events.

When the Propagator selects a Constraint Event for execution the Constraint Event signals Propagation to its associated Constraint . Constraint Events typically comprise information regarding whether an argument variable of the associated Constraint has been changed by the Constraint Store component . If only a single argument variable changes the Constraint Event remembers the particular Variable Event . In this case it is preferred but not necessary for every Constraint in the Constraint Store component to implement an efficient procedure which can take advantage of the details of the Variable Event to evaluate the domain change of only the single argument variable.

However if more than a single argument has changed the Constraint may apply the above described single variable procedure for each changed variable or it may apply a global procedure taking all the variable changes into account. The signaled Constraint applies its internal algorithm to reduce or prune some of the Variable Domains of its argument variables in the Constraint Store.

Each type of Constraint may have a specialized internal algorithm for updating the Variable Domains of its argument variables. In the embodiment shown in when a Constraint reduces or prunes a Variable Domain corresponding to an argument variable the FCPE provides Justifications that represent a reason that the Variable Domain has been reduced by constraint propagation. A Justification may be represented by a data structure which specifies the reason for the Variable Domain reduction. The contents of the Justifications generally are specific to the Propagator implemented in the embodiment of the FCPE. Although two Justifications are shown in fewer or more Justifications may be used in other instances. In some methods the Variable Domain records the Justification which contains sufficient information about the reduction so that the effects of the constraint evaluation advantageously can be later removed if some or all of the information contained in the Justification becomes invalid. Related techniques may be used see e.g. Laburthe00 . If the constraint evaluation algorithm modifies a Variable Domain the FCPE in block updates the Variable Event corresponding to the appropriate variables. After the Variable Event is updated in block the event in block is posted back to the Propagator . In some embodiments the Propagator executes the Variable Event soon after its posting while in other embodiments the Propagator adds the Variable Event to a queue for later execution. In embodiments utilizing a queue the Processor may select the Variable Event from the queue for execution in order to improve or maximize efficiency of the constraint propagation process.

In some embodiments the Propagator maintains one or more queues for efficiently processing Variable Events Constraint Events or both types of events. The Propagator can select either a Variable Event or a Constraint Event for execution as described above. Various heuristics for making this selection are known and may be implemented in embodiments of the FCPE. For example a constraint centered FCPE can be implemented in which Variable Events are executed immediately by the Propagator while Constraint Events are queued for execution. Additionally or alternatively Constraints can be queued according to a priority corresponding to for example their expected computational complexity their importance in the search and or their domain reduction power. For example it may be advantageous to process cheaper and or stronger Constraints first. Embodiments of the FCPE using heuristic propagation order can improve the run time performance of the constraint propagation system see e.g. Schulte04 .

Various constraint retraction algorithms may be provided by embodiments of the FCPE shown in . For example in one embodiment the FCPE delegates creation of Justifications for Variable Domain changes to the implemented Propagator . In some embodiments Justifications are used that contain no recorded information about changes to the Variable Domain. Upon constraint retraction all Variable Domains that are transitively dependent on the retracted constraint are restored. This transitive dependency generally is a function of the particular instance of the Constraint Store component . In such embodiments there may be a tradeoff between using fewer memory resources and using more computational power.

In another embodiment the FCPE uses an AC DC 2 retraction algorithm see e.g. Bartak04 . This algorithm represents the Justification for a change of Variable Domain according to the Constraint that reduced the Variable Domain . Thus on constraint retraction a Propagator using the AC DC 2 algorithm can restore only changes to the Variable Domain that were caused by the retracted Constraint or by some or all of the dependent Constraints . This alternative algorithm advantageously requires only constant memory space for every Variable Domain change. To realize the AD DC 2 constraint retraction method some embodiments of the Propagator add a new Variable Event for each argument variable of the Constraint in the Constraint Store component . When executed each such added Variable Event is able to fully restore the Variable Domain of its corresponding variables.

In another embodiment Justifications are stored as complete explanations for Variable Domain changes. For example in one such method transitively all Constraints that contributed to causing this change are processed see e.g. Jussien00b . Typically additional memory is required by this method but upon Constraint retraction only the Variable Domain changes which have Justifications that contain the retracted Constraint need to be restored. A benefit of such embodiments is that they generally require substantially little additional computational processing.

Additional approaches can also be easily implemented using the Flexible Constraint Propagation Engine described herein. For example different constraint propagation methods may be desirable for Mixed Initiative MI systems than for stand alone optimization systems. For example MI systems typically explain to the user choices including but not limited to the causal justification for a particular decision the reason a particular answer to a COP is infeasible or the set of assumptions made during a particular search. Such explanations may be provided by the constraint propagation system. The construction and maintenance of explanations may be computationally expensive but important for MI reasoning. However there generally is little need for explanations in stand alone optimization systems. In such systems it is advantageous to use a more efficient but less informative non monotonic constraint propagation algorithm. An advantage of the FCPE described herein is that it may be configured to use many different constraint Propagators within a particular architecture.

The present disclosure provides constraint propagation systems and methods which can include a Flexible Constraint Propagation Engine. Embodiments of the Flexible Constraint Propagation Engine described herein can advantageously be used with a Reconfigurable Search Engine. Various embodiments of the constraint propagation systems and methods and the FCPE provide some or all of the following features and benefits as well as others.

1. Modular constraint propagators. Different types of constraint propagation algorithms can be specified depending on the requirements of the application. Computationally expensive or memory intensive algorithms may be avoided if their functionality is not required by the application.

2. Extensible propagation framework. New propagation algorithms can be easily coded using an API such as for example the API included in Appendix A. Newly developed propagation algorithms can be incorporated into embodiments of the FCPE without redesigning the kernel of the FCPE.

3. Efficient customized propagation. Many types of constraint propagation methods can be implemented. For example both variable centered and constraint centered propagation methods can be implemented and freely intermixed. Specialized constraint propagators that process constraints in priority order and or that avoid processing constraints which will not reduce the search space can be implemented. Constraint propagation efficiency is thereby improved in many combinatorial optimization applications.

The technical disclosures of the following references are hereby incorporated by reference herein in their entirety.

Although the invention s have been described in terms of certain preferred embodiments and certain preferred uses other embodiments and other uses that are apparent to those of ordinary skill in the art including embodiments and uses which do not provide all of the features and advantages set forth herein are also within the scope of the invention s . For example in any method or process described herein the acts or operations of the method process are not necessarily limited to any particular disclosed sequence. Also for purposes of contrasting different embodiments or the prior art certain aspects and advantages of these embodiments are described where appropriate. It should be understood that not necessarily all such aspects and advantages need be achieved in any one embodiment. Thus it should be recognized that certain embodiments may be carried out in a manner that achieves or optimizes one advantage or group of advantages without necessarily achieving other aspects or advantages that may be taught or suggested herein. Accordingly the scope of the invention s is defined by the following claims and their obvious modifications and equivalents.

Appendix A which forms part of the disclosure of this specification provides an example Application Programmer s Interface API usable with the Flexible Constraint Propagation Engine.

