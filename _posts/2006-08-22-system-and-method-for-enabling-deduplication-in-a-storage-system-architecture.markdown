---

title: System and method for enabling de-duplication in a storage system architecture
abstract: A system and method enables de-duplication in a storage system architecture comprising one or more volumes distributed across a plurality of nodes interconnected as a cluster. De-duplication is enabled through the use of file offset indexing in combination with data content redirection. File offset indexing is illustratively embodied as a Locate by offset function, while data content redirection is embodied as a novel Locate by content function. In response to input of, inter alia, a data container (file) offset, the Locate by offset function returns a data container (file) index that is used to determine a storage server that is responsible for a particular region of the file. The Locate by content function is then invoked to determine the storage server that actually stores the requested data on disk. Notably, the content function ensures that data is stored on a volume of a storage server based on the content of that data rather than based on its offset within a file. This aspect of the invention ensures that all blocks having identical data content are served by the same storage server so that it may implement de-duplication to conserve storage space on disk and increase cache efficiency of memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07747584&OS=07747584&RS=07747584
owner: NetApp, Inc.
number: 07747584
owner_city: Sunnyvale
owner_country: US
publication_date: 20060822
---
The present invention is directed to storage systems and in particular to enabling de duplication in a storage system architecture comprising one or more volumes distributed across a plurality of storage systems interconnected as a cluster.

A storage system typically comprises one or more storage devices into which information may be entered and from which information may be obtained as desired. The storage system includes a storage operating system that functionally organizes the system by inter alia invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including but not limited to a network attached storage environment a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array wherein the term disk commonly describes a self contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive HDD or direct access storage device DASD .

The storage operating system of the storage system may implement a high level module such as a file system to logically organize the information stored on volumes as a hierarchical structure of data containers such as files and logical units. For example each on disk file may be implemented as set of data structures i.e. disk blocks configured to store information such as the actual data for the file. These data blocks are organized within a volume block number vbn space that is maintained by the file system. The file system may also assign each data block in the file a corresponding file offset or file block number fbn . The file system typically assigns sequences of fbns on a per file basis whereas vbns are assigned over a larger volume address space. The file system organizes the data blocks within the vbn space as a logical volume each logical volume may be although is not necessarily associated with its own file system.

A known type of file system is a write anywhere file system that does not over write data on disks. If a data block is retrieved read from disk into a memory of the storage system and dirtied i.e. updated or modified with new data the data block is thereafter stored written to a new location on disk to optimize write performance. A write anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. An example of a write anywhere file system that is configured to operate on a storage system is the Write Anywhere File Layout to WAFL file system available from Network Appliance Inc. Sunnyvale Calif.

A plurality of storage systems may be interconnected to provide a storage system environment configured to service many clients. Each storage system may be configured to service one or more volumes wherein each volume stores one or more data containers. Yet often a large number of data access requests issued by the clients may be directed to a small number of data containers serviced by a particular storage system of the environment. A solution to such a problem is to distribute the volumes serviced by the particular storage system among all of the storage systems of the environment. This in turn distributes the data access requests along with the processing resources needed to service such requests among all of the storage systems thereby reducing the individual processing load on each storage system. However a noted disadvantage arises when only a single data container such as a file is heavily accessed by clients of the storage system environment. As a result the storage system attempting to service the requests directed to that file may exceed its processing resources and become overburdened with a concomitant degradation of speed and performance.

One technique for overcoming the disadvantages of having a single file that is heavily utilized is to stripe the file across a plurality of volumes configured as a striped volume set SVS where each volume is serviced by a different storage system thereby distributing the load for the single file among a plurality of storage systems interconnected as a cluster. A technique for data container file striping is described in U.S. patent application Ser. No. 11 119 278 of Kazar et al. entitled STORAGE SYSTEM ARCHITECTURE FOR STRIPING DATA CONTAINER CONTENT ACROSS VOLUMES OF A CLUSTER. File striping improves raw performance and reliability across the cluster of storage systems by distributing data among different storage systems generally based on an offset within the file at which the data is located. Each storage system is configured to serve an underlying physical volume embodied as an aggregate comprising one or more groups of disks.

It is generally desirable to eliminate duplicate data on storage resources such as disks and to ensure the storage of only a single instance of data to thereby achieve storm age compression. Such elimination of data duplication de duplication also results in a more efficient use of cache memory. De duplication in the exemplary file system ensures that if two blocks contain the same data and thus have the same content only one copy of the block is maintained on disk and two references pointers are directed to i.e. share that block. Low level indirect blocks typically include vbn pointers to data blocks which vbns are mapped to disk block numbers dbns on disk. In the case of de duplication different vbns refer to the same dbn. For example if data stored at vbn and vbn were identical that data would be retrieved from disk from the same location and therefore cached at the same location in memory. This enables not only a reduction of storage space consumption but also a performance improvement since a data block that is shared by many files is more likely to be resident in cache when needed again.

An example of a technique for eliminating duplicate data is described in U.S. patent application Ser. No. 11 105 895 filed on Apr. 13 2005 entitled METHOD AND APPARATUS FOR IDENTIFYING AND ELIMINATING DUPLICATE DATA BLOCKS AND SHARING DATA BLOCKS IN A STORAGE SYSTEM by Ling Zheng et al the contents of which are hereby incorporated by reference. Here data de duplication operations are performed on fixed size blocks. When a new block is to be stored a hash value is computed as a fingerprint of the block. The fingerprint is then compared with a hash table containing fingerprints of previously stored blocks. If the new block s fingerprint is identical to that of a previously stored block there is a high degree of probability that the new block is identical to the previously stored block. In such a case the two blocks are compared to test whether they are indeed identical. If so the new block is replaced with a pointer to the previously stored block thereby reducing storage resource consumption.

However de duplication generally takes place at the aggregate level that is for sharing to occur all references to that data must occur within the same aggregate. As noted file striping across a storage system cluster typically distributes data among the different storage systems based on an offset within a file not based on the content of the data. As a result a data access request directed to a first block of a first file may be forwarded to a first storage system whereas an access request to a second block of that file may be forwarded to a second storage system. Thus despite the content of the data the access requests are directed to different systems. Accordingly the efficiency of de duplication is compromised because only a portion of the data is available to search for a duplicate there is no attempt to route identical blocks of data onto a single storage system. The present invention is directed to ensuring that a block of data is stored on a stores age system based on the content of that data block rather than based on its offset within a file.

The present invention overcomes the disadvantages of the prior art by providing a system and method for enabling de duplication in a storage system architecture comprising one or more volumes distributed across a plurality of nodes interconnected as a cluster. The volumes are organized as a striped volume set SVS and configured to store content of data containers such as files served by the cluster in response to multi protocol data access requests issued by clients. Each node of the cluster includes i a storage server adapted to service one or more volumes of the SVS and ii a multi protocol engine adapted to redirect the data access requests to any storage server of the cluster. The content of each file may be apportioned among the volumes of the SVS to improve the efficiency of storage service provided by the cluster.

According to the invention de duplication is enabled through the use of data container e.g. file offset indexing in combination with data content redirection. File offset indexing is illustratively embodied as a Locate by offset function while data content redirection is embodied as a novel Locate by content function. In response to input of inter alia an offset into a data container file the Locate by offset function provides a file index that is used to determine the storage server that is responsible for a particular region of the file. The Locate by content function is then invoked to determine the storage server that actually stores the requested data on disk. Notably the content function ensures that data is stored on a volume of a storage server based on the content of that data rather than based on its offset within a file. This aspect of the invention ensures that all blocks having identical data content are served by the same storage server so that it may implement de duplication to conserve storage space on disk and increase cache efficiency of memory.

In the illustrative embodiment the storage server of each node is embodied as a disk element D module configured to serve a physical volume embodied as an aggregate and the multi protocol engine is embodied as a network element N module . The N module executes the Locate by offset function to identify a first D module to which the data access request should be forwarded and the first D module then executes the Locate by content function to determine a second D module that actually serves the requested data. Notably the second D module may be different i.e. remote from the first i.e. local D module nevertheless the local D module maintains responsibility for the region of the file identified by the Locate by offset function regardless of where the data is actually stored. In the event a remote D module serves the requested data the local D module marks the lowest level indirect block associated with the data of the file with an identifier ID of the constituent volume i.e. aggregate of the SVS served by the remote D module e.g. a de dup marker value rather than marking that indirect block with a pointer referencing a block location of the data on the aggregate served by the local D module. Marking of the indirect block with the de dup marker value specifies that the requested data block is present on the aggregate of the remote D module.

Advantageously the novel Locate by content function provides a secondary hash that modifies a primary hash provided by the Locate by offset function. That is the primary hash identifies a first D module that is responsible for a region of a file while the secondary hash identifies the D module that actually serves the requested data block to enable de duplication. The Locate by content function is thus a subservient hash to the Locate by offset function that augments the primary hashing system to ensure that identical blocks of data are stored on the same aggregate served by a storage server D module . Once identical blocks of data are written to the same aggregate the D module may implement de duplication to thereby efficiently ensure that only one copy of that data is actually stored on the aggregate.

The clients may be general purpose computers configured to interact with the node in accordance with a client server model of information delivery. That is each client may request the services of the node and the node may return the results of the services requested by the client by exchanging packets over the network . The client may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over the Transmission Control Protocol Internet Protocol TCP IP when accessing information in the form of data containers such as files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of data containers such as blocks.

Each node is illustratively embodied as a dual processor storage system executing a storage operating system that preferably implements a high level module such as a file system to logically organize the information as a hierarchical structure of named data containers such as directories files and special types of files called virtual disks hereinafter generally blocks on the disks. However it will be apparent to those of ordinary skill in the art that the node may alternatively comprise a single or more than two processor system. Illustratively one processor executes the functions of the N module on the node while the other processor executes the functions of the D module .

The memory illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system portions of which is typically resident in memory and executed by the processing elements functionally organizes the node by inter alia invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the invention described herein.

The network adapter comprises a plurality of ports adapted to couple the node to one or more clients over point to point links wide area networks virtual private networks implemented over a public network Internet or a shared local area network. The network adapter thus may comprise the mechanical electrical and signaling circuitry needed to connect the node to the network. Illustratively the computer network may be embodied as an Ethernet network or a Fibre Channel FC network. Each client may communicate with the node over network by exchanging discrete frames or packets of data according to pre defined protocols such as TCP IP.

The storage adapter cooperates with the storage operating system executing on the node to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks of array . The storage adapter comprises a plurality of ports having input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance FC link topology.

Storage of information on each array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.

To facilitate access to the disks the storage operating system implements a write anywhere file system that cooperates with one or more virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named data containers such as directories and files on the disks. Each on disk file may be implemented as set of disk blocks configured to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module s allow the file system to further logically organize information as a hierarchical structure of data containers such as blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such where the term ONTAP is employed it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.

In addition the storage operating system includes a series of software layers organized to form a storage server that provides data paths for accessing information stored on the disks of the node . To that end the storage server includes a file system module in cooperating relation with a volume striping module VSM a RAID system module and a disk driver system module . The RAID system manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations while the disk driver system implements a disk access protocol such as e.g. the SCSI protocol. The VSM illustratively implements a striped volume set SVS of the present invention. As described further herein the VSM cooperates with the file system to enable storage server to service a volume of the SVS. In particular the VSM implements a Locate by offset function to compute the location of data container content in the SVS volume to thereby ensure consistency of such content served by the cluster as described further below.

The file system implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules illustratively embodied as e.g. a virtual disk vdisk module not shown and a SCSI target module . The vdisk module enables access by administrative interfaces such as a user interface of a management framework see in response to a user system administrator issuing commands to the node . The SCSI target module is generally disposed between the FC and iSCSI drivers and the file system to provide a translation layer of the virtualization system between the block lun space and the file system space where luns are represented as blocks.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as disks. That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as mirroring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte KB blocks and using index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . The file system uses files to store meta data describing the layout of its file system these meta data files include among others an mode file. A file handle i.e. an identifier that includes an mode number is used to retrieve an inode from disk.

Broadly stated all modes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other modes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The mode of the inode file may directly reference point to data blocks of the inode file or may reference indirect blocks of the inode file that in turn reference data blocks of the inode file. Within each data block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

Operationally a request from the client is forwarded as a packet over the computer network and onto the node where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . Here the file system generates operations to load retrieve the requested data from disk if it is not resident in core i.e. in memory . If the information is not in memory the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in memory for processing by the node. Upon completion of the request the node and operating system returns a reply to the client over the network .

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by node in response to a request issued by client . Moreover in another alternate embodiment of the invention the processing elements of adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer to perform a storage function that manages data access and may in the case of a node implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel an application program operating over a general purpose operating system such as UNIX or Windows NT or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the invention described herein may apply to any type of special purpose e.g. file server filer or storage serving appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system the teachings of the present invention may be utilized with any suitable file system including a write in place file system.

In the illustrative embodiment the storage server is embodied as D module of the storage operating system to service one or more volumes of array . In addition the multi protocol engine is embodied as N module to i perform protocol termination with respect to a client issuing incoming data access request packets over the network as well as ii redirect those data access requests to any storage server of the cluster . Moreover the N module and D module cooperate to provide a highly scalable distributed storage system architecture of the cluster . To that end each module includes a cluster fabric CF interface module adapted to implement intra cluster communication among the modules including D module to D module communication for data container striping operations described herein.

The protocol layers e.g. the NFS CIFS layers and the iSCSI FC layers of the N module function as protocol servers that translate file based and block based data access requests from clients into CF protocol messages used for communication with the D module . That is the N module servers convert the incoming data access requests into file system primitive operations commands that are embedded within CF messages by the CF interface module for transmission to the D modules of the cluster . Notably the CF interface modules cooperate to provide a single file system image across all D modules in the cluster . Thus any network port of an N module that receives a client request can access any data container within the single file system image located on any D module of the cluster.

Further to the illustrative embodiment the N module and D module are implemented as separately scheduled processes of storage operating system however in an alternate embodiment the modules may be implemented as pieces of code within a single operating system process. Communication between an N module and D module is thus illustratively effected through the use of message passing between the modules although in the case of remote communication between an N module and D module of different nodes such message passing occurs over the cluster switching fabric . A known message passing mechanism provided by the storage operating system to transfer information between modules processes is the Inter Process Communication IPC mechanism. The protocol used with the IPC mechanism is illustratively a generic file and or block based agnostic CF protocol that comprises a collection of methods functions constituting a CF application programming interface API . Examples of such an agnostic protocol are the SpinFS and SpinNP protocols available from Network Appliance Inc. The SpinFS protocol is described in the above referenced U.S. Patent Application Publication No. US 2002 0116593.

The CF interface module implements the CF protocol for communicating file system commands among the modules of cluster . Communication is illustratively effected by the D module exposing the CF API to which an N module or another D module issues calls. To that end the CF interface module is organized as a CF encoder and CF decoder. The CF encoder of e.g. CF interface on N module encapsulates a CF message as i a local procedure call LPC when communicating a file system command to a D module residing on the same node or ii a remote procedure call RPC when communicating the command to a D module residing on a remote node of the cluster . In either case the CF decoder of CF interface on D module de encapsulates the CF message and processes the file system command.

A data container e.g. a file is accessed in the file system using a data container handle. is a schematic block diagram illustrating the format of a data container handle including a SVS ID field an inode number field a unique ifier field a striped flag field and a striping epoch number field . The SVS ID field contains a global identifier within the cluster of the SVS within which the data container resides. The inode number field contains an inode number of an inode within an inode file pertaining to the data container. The unique iffier field contains a monotonically increasing number that uniquely identifies the data container handle . The unique iffier is particularly useful in the case where an inode number has been deleted reused and reassigned to a new data container. The unique iffier distinguishes that reused inode number in a particular data container from a potentially previous use of those fields. The striped flag field is illustratively a Boolean value that identifies whether the data container is striped or not. The striping epoch number field indicates the appropriate striping technique for use with this data container for embodiments where the SVS utilizes differing striping techniques for different data containers.

In the illustrative embodiment a data container is represented in the write anywhere file system as an inode data structure adapted for storage on the disks . is a schematic block diagram of an inode which preferably includes a meta data section and a data section . The information stored in the meta data section of each inode describes the data container e.g. a file and as such includes the type e.g. regular directory vdisk of file its size time stamps e.g. access and or modification time and ownership i.e. user identifier UID and group ID GID of the file. The meta data section also includes a generation number and a meta data invalidation flag field . The meta data invalidation flag field is used to indicate whether meta data in this inode is usable or whether it should be re acquired from a meta data volume MDV . The contents of the data section of each inode may be interpreted differently depending upon the type of file inode defined within the type field . For example the data section of a directory inode contains meta data controlled by the file system whereas the data section of a regular inode contains file system data. In this latter case the data section includes a representation of the data associated with the file.

Specifically the data section of a regular on disk inode may include file system data or pointers the latter referencing 4 KB data blocks on disk used to store the file system data. Each pointer is preferably a logical vbn to facilitate efficiency among the file system and the RAID system when accessing the data on disks. Given the restricted size e.g. 128 bytes of the inode file system data having a size that is less than or equal to 64 bytes is represented in its entirety within the data section of that inode. However if the length of the contents of the data container exceeds 64 bytes but less than or equal to 64 KB then the data section of the inode e.g. a first level inode comprises up to 16 pointers each of which references a 4 KB block of data on the disk.

Moreover if the size of the data is greater than 64 KB but less than or equal to 64 megabytes MB then each pointer in the data section of the inode e.g. a second level inode references an indirect block e.g. a first level L1 block that contains 1024 pointers each of which references a 4 KB data block on disk. For file system data having a size greater than 64 MB each pointer in the data section of the inode e.g. a third level L3 inode references a double indirect block e.g. a second level L2 block that contains 1024 pointers each referencing an indirect e.g. a first level L1 block. The indirect block in turn that contains 1024 pointers each of which references a 4 KB data block on disk. When accessing a file each block of the file may be loaded from disk into the memory .

When an on disk inode or block is loaded from disk into memory its corresponding in core structure embeds the on disk structure. For example the dotted line surrounding the inode indicates the in core representation of the on disk inode structure. The in core structure is a block of memory that stores the on disk structure plus additional information needed to manage data in the memory but not on disk . The additional information may include e.g. a dirty bit . After data in the inode or block is updated modified as instructed by e.g. a write operation the modified data is marked dirty using the dirty bit so that the inode block can be subsequently flushed stored to disk. The in core and on disk format structures of the WAFL file system including the inodes and inode file are disclosed and described in U.S. Pat. No. 5 819 292 titled METHOD FOR MAINTAINING CONSISTENT STATES OF A FILE SYSTEM AND FOR CREATING USER ACCESSIBLE READ ONLY COPIES OF A FILE SYSTEM by David Hitz et al. issued on Oct. 6 1998.

A file system layout is provided that apportions an underlying physical volume into one or more virtual volumes or flexible volume of a storage system such as node . An example of such a file system layout is described in U.S. patent application Ser. No. 10 836 817 titled EXTENSION OF WRITE ANYWHERE FILE SYSTEM LAYOUT by John K. Edwards et al. and assigned to Network Appliance Inc. The underlying physical volume is an aggregate comprising one or more groups of disks such as RAID groups of the node. The aggregate has its own physical volume block number pvbn space and maintains meta data such as block allocation structures within that pvbn space. Each flexible volume has its own virtual volume block number vvbn space and maintains meta data such as block allocation structures within that vvbn space. Each flexible volume is a file system that is associated with a container file the container file is a file in the aggregate that contains all blocks used by the flexible volume. Moreover each flexible volume comprises data blocks and indirect blocks that contain block pointers that point at either other indirect blocks or data blocks.

In one embodiment pvbns are used as block pointers within buffer trees of files such as file stored in a flexible volume. This hybrid flexible volume embodiment involves the insertion of only the pvbn in the parent indirect block e.g. inode or indirect block . On a read path of a logical volume a logical volume vol info block has one or more pointers that reference one or more fsinfo blocks each of which in turn points to an inode file and its corresponding inode buffer tree. The read path on a flexible volume is generally the same following pvbns instead of vvbns to find appropriate locations of blocks in this context the read path and corresponding read performance of a flexible volume is substantially similar to that of a physical volume. Translation from pvbn to disk dbn occurs at the file system RAID system boundary of the storage operating system .

In an illustrative dual vbn hybrid flexible volume embodiment both a pvbn and its corresponding vvbn are inserted in the parent indirect blocks in the buffer tree of a file. That is the pvbn and vvbn are stored as a pair for each block pointer in most buffer tree structures that have pointers to other blocks e.g. level 1 L1 indirect blocks inode file level 0 L0 blocks. is a schematic block diagram of an illustrative embodiment of a buffer tree of a file that may be advantageously used with the present invention. A root top level mode such as an embedded mode references indirect e.g. level 1 blocks . Note that there may be additional levels of indirect blocks e.g. level 2 level 3 depending upon the size of the file. The indirect blocks and mode contain pvbn vvbn pointer pair structures that ultimately reference data blocks used to store the actual data of the file.

The pvbns reference locations on disks of the aggregate whereas the vvbns reference locations within files of the flexible volume. The use of pvbns as block pointers in the indirect blocks provides efficiencies in the read paths while the use of vvbn block pointers provides efficient access to required meta data. That is when freeing a block of a file the parent indirect block in the file contains readily available vvbn block pointers which avoids the latency associated with accessing an owner map to perform pvbn to vvbn translations yet on the read path the pvbn is available.

Whereas the aggregate is analogous to a physical volume of a conventional storage system a flexible volume is analogous to a file within that physical volume. That is the aggregate may include one or more files wherein each file contains a flexible volume and wherein the sum of the storage space consumed by the flexible volumes is physically smaller than or equal to the size of the overall physical volume. The aggregate utilizes a physical pvbn space that defines a storage space of blocks provided by the disks of the physical volume while each embedded flexible volume within a file utilizes a logical vvbn space to organize those blocks e.g. as files. Each vvbn space is an independent set of numbers that corresponds to locations within the file which locations are then translated to dbns on disks. Since the flexible volume is also a logical volume it has its own block allocation structures e.g. active space and summary maps in its vvbn space.

A container file is a file in the aggregate that contains all blocks used by a flexible volume. The container file is an internal to the aggregate feature that supports a flexible volume illustratively there is one container file per flexible volume. Similar to a pure logical volume in a file approach the container file is a hidden file not accessible to a user in the aggregate that holds every block in use by the flexible volume. The aggregate includes an illustrative hidden meta data root directory that contains subdirectories of flexible volumes 

Specifically a physical file system WAFL directory includes a subdirectory for each flexible volume in the aggregate with the name of subdirectory being a file system identifier fsid of the flexible volume. Each fsid subdirectory flexible volume contains at least two files a filesystem file and a storage label file. The storage label file is illustratively a 4KB file that contains meta data similar to that stored in a conventional raid label. In other words the storage label file is the analog of a raid label and as such contains information about the state of the flexible volume such as e.g. the name of the flexible volume a universal unique identifier uuid and fsid of the flexible volume whether it is online being created or being destroyed etc.

In addition to being embodied as a container file having level 1 blocks organized as a container map the filesystem file includes block pointers that reference various file systems embodied as flexible volumes . The aggregate maintains these flexible volumes at special reserved inode numbers. Each flexible volume also has special reserved inode numbers within its flexible volume space that are used for among other things the block allocation bitmap structures. As noted the block allocation bitmap structures e.g. active map summary map and space map are located in each flexible volume.

Specifically each flexible volume has the same inode file structure content as the aggregate with the exception that there is no owner map and no WAFL fsid filesystem file storage label file directory structure in a hidden meta data root directory . To that end each flexible volume has a volinfo block that points to one or more fsinfo blocks each of which may represent a snapshot along with the active file system of the flexible volume. Each fsinfo block in turn points to an inode file that as noted has the same inode structure content as the aggregate with the exceptions noted above. Each flexible volume has its own inode file and distinct inode space with corresponding inode numbers as well as its own root fsid directory and subdirectories of files that can be exported separately from other flexible volumes.

The storage label file contained within the hidden meta data root directory of the aggregate is a small file that functions as an analog to a conventional raid label. A raid label includes physical information about the storage system such as the volume name that information is loaded into the storage label file . Illustratively the storage label file includes the name of the associated flexible volume is the online offline status of the flexible volume and other identity and state information of the associated flexible volume whether it is in the process of being created or destroyed .

The VLDB is a database process that tracks the locations of various storage components e.g. SVSs flexible volumes aggregates etc. within the cluster to thereby facilitate routing of requests throughout the cluster. In the illustrative embodiment the N module of each node accesses a configuration table that maps the SVS ID of a data container handle to a D module that owns services the data container within the cluster. The VLDB includes a plurality of entries which in turn provide the contents of entries in the configuration table among other things these VLDB entries keep track of the locations of the flexible volumes hereinafter generally volumes and aggregates within the cluster. Examples of such VLDB entries include a VLDB volume entry and a VLDB aggregate entry .

The VLDB illustratively implements a RPC interface e.g. a Sun RPC interface which allows the N module to query the VLDB . When encountering contents of a data container handle that are not stored in its configuration table the N module sends an RPC to the VLDB process. In response the VLDB returns to the N module the appropriate mapping information including an ID of the D module that owns the data container. The N module caches the information in its configuration table and uses the D module ID to forward the incoming request to the appropriate data container. All functions and interactions between the N module and D module are coordinated on a cluster wide basis through the collection of management processes and the RDB library user mode applications .

To that end the management processes have interfaces to are closely coupled to RDB . The RDB comprises a library that provides a persistent object store storing of objects for the management data processed by the management processes. Notably the RDB replicates and synchronizes the management data object store access across all nodes of the cluster to thereby ensure that the RDB database image is identical on all of the nodes . At system startup each node records the status state of its interfaces and IP addresses those IP addresses it owns into the RDB database.

In the illustrative embodiment of the present invention the storage system architecture illustratively comprises two or more volumes distributed across a plurality of nodes of cluster . The volumes are organized as a SVS and configured to store content of data containers such as files and luns served by the cluster in response to multi protocol data access requests issued by clients . Notably the content of each data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster. To facilitate a description and understanding of the present invention data containers are hereinafter referred to generally as files .

The SVS comprises a meta data volume MDV and one or more data volumes DV . The MDV is configured to store a canonical copy of meta data including access control lists ACLs and directories associated with all files stored on the SVS whereas each DV is configured to store at least data content of those files. For each file stored on the SVS one volume is designated a container attribute volume CAV and to that end is configured to store cache certain rapidly changing attribute meta data associated with that file to thereby offload access requests that would otherwise be directed to the MDV. In the illustrative embodiment described herein determination of the CAV for a file is based on a simple rule designate the volume holding the first stripe of content data for the file as the CAV for the file. Not only is this simple rule convenient but it also provides an optimization for small files. That is a CAV may be able to perform certain operations without having to communicate with other volumes of the SVS if the file is small enough to fit within the specified stripe width. Ideally the first stripes of data for files are distributed among the DVs of the SVS to thereby facilitate even distribution of CAV designations among the volumes of the SVS. In an alternate embodiment data for files is striped across the MDV and the DVs.

In contrast each DV stores only file F inodes and ACL inode . According to the inventive architecture a DV does not store directories or other device inodes constructs such as symbolic links however each DV does store F inodes and may store cached copies of ACL inodes that are arranged in the same locations as their respective inodes in the MDV . A particular DV may not store a copy of an inode until an I O request for the data container associated with the inode is received by the D module serving a particular DV. Moreover the contents of the files denoted by these F inodes are periodically sparse according to SVS striping rules as described further herein. In addition since one volume is designated the CAV for each file stored on the SVS DV is designated the CAV for the file represented by inode and DV is the CAV for the files identified by inodes . Accordingly these CAVs cache certain rapidly changing attribute meta data M associated with those files such as e.g. file size as well as access and or modification time stamps .

According to another aspect of the invention the SVS is associated with a set of striping rules that define a stripe algorithm a stripe width and an ordered list of volumes within the SVS. The striping rules for each SVS are illustratively stored as an entry of VLDB and accessed by SVS ID. is a schematic block diagram of an exemplary VLDB SVS entry in accordance with an embodiment of the present invention. The VLDB entry includes a SVS ID field and one or more sets of striping rules . In alternate embodiments additional fields may be included. The SVS ID field contains the ID of a SVS which in operation is specified in data container handle .

Each set of striping rules illustratively includes a stripe width field a stripe algorithm ID field an ordered list of volumes field and in alternate embodiments additional fields . The striping rules contain information for identifying the organization of a SVS. For example the stripe algorithm ID field identifies a striping algorithm used with the SVS. In the illustrative embodiment multiple striping algorithms could be used with a SVS accordingly stripe algorithm ID is needed to identify which particular algorithm is utilized. Each striping algorithm in turn specifies the manner in which file content is apportioned as stripes across the plurality of volumes of the SVS. The stripe width field specifies the size width of each stripe. The ordered list of volumes field contains the IDs of the volumes comprising the SVS. In an illustrative embodiment the ordered list of volumes includes a plurality of tuples comprising a flexible volume ID and the aggregate ID storing the flexible volume. Moreover the ordered list of volumes may specify the function and implementation of the various volumes and striping rules of the SVS. For example the first volume in the ordered list may denote the MDV of the SVS whereas the ordering of volumes in the list may denote the manner of implementing a particular striping algorithm e.g. round robin.

As noted a Locate by offset function is provided that enables the VSM and other modules such as those of N module to locate a D module and its associated volume of a SVS in order to service an access request to a file. The Locate by offset function takes as arguments at least i a SVS ID ii an offset within the file iii the inode number for the file and iv a set of striping rules and returns a file index that specifies the volume on which that offset begins within the SVS . For example assume a data access request directed to a file is issued by a client and received at the N module of a node where it is parsed through the multi protocol engine to the appropriate protocol server of N module .

To determine the location of a D module to which to transmit a CF message the N module may first retrieve a SVS entry to acquire the striping rules and list of volumes associated with the SVS. The N module then executes the Locate by offset function to identify the appropriate volume to which to direct an operation. Thereafter the N module may retrieve the appropriate VLDB volume entry to identify the aggregate containing the volume and the appropriate VLDB aggregate entry to ultimately identify the appropriate D module . The protocol server of N module then transmits the CF message to the D module .

The present invention relates to a storage system architecture comprising one or more volumes distributed across a plurality of nodes interconnected as a cluster. The volumes are organized as a SVS and configured to store content of data containers such as files and logical units served by the cluster in response to multi protocol data access requests issued by clients. Each node of the cluster includes i a storage server adapted to service a volume of the SVS and ii a multi protocol engine adapted to redirect the data access requests to any storage server of the cluster. Notably the content of each data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster.

As noted the SVS is associated with a set of striping rules that define a stripe algorithm a stripe width and an ordered list of volumes within the SVS. The stripe algorithm specifies the manner in which data container content is apportioned as stripes across the plurality of volumes while the stripe width specifies the size width of each stripe. Moreover the ordered list of volumes may specify the function and implementation of the various volumes and striping rules of the SVS. For example the ordering of volumes in the list may denote the manner of implementing a particular striping algorithm e.g. round robin.

According to an aspect of the invention each data container stored within a SVS is implemented as a sparse data container. Each data container stored within the SVS comprises one or more stripes of data stored on each constituent volume of the SVS in accordance with the stripe algorithm associated with the SVS. A region of each constituent volume that is not currently storing a stripe of data is implemented as a sparse region with no assigned back end storage. By utilizing regions of sparseness each data stripe of a data container within a SVS is located at a predetermined offset. Illustratively the predetermined offset is equal to the stripe number minus 1 multiplied by the stripe size as the first stripe is located at offset zero e.g. the fifth stripe of data begins at an offset four times the stripe width.

The use of sparse data containers facilitates processing of re striping operations by moving a stripe of data from a current location on a volume to an intended offset destination of an appropriate destination volume. The destination is thus sparse at the destination volume thereby enabling easy re striping operations. Additionally if metadata associated with the SVS is damaged to an extent that it is impossible to identify the striping algorithm the data container may be efficiently reconstructed by examining each of the constituent volumes of the SVS and noting that the first stripe of data is located at offset zero the second stripe of data located at an offset equal to the striped width etc. Thus the use of sparse data containers also improves data availability and protection.

In accordance with an illustrative round robin striping algorithm volume A contains a stripe of file content or data D followed in sequence by two stripes of sparseness S another stripe of data D and two stripes of sparseness S . Volume B on the other hand contains a stripe of sparseness S followed in sequence by a stripe of data D two stripes of sparseness S another stripe of data D and a stripe of sparseness S . Volume C continues the round robin striping pattern and to that end contains two stripes of sparseness S followed in sequence by a stripe of data D two stripes of sparseness S and another stripe of data D . By utilizing the sparse file implementation of the present invention each stripe of data is located at the appropriate offset within the SVS i.e. D located in the first stripe D at the second etc.

The present invention is directed to a system and method for enabling de duplication in a storage system architecture comprising one or more volumes distributed across a plurality of nodes interconnected as a cluster. According to the invention de duplication is enabled through the use of data container e.g. file offset indexing in combination with data content redirection. File offset indexing is illustratively embodied as the Locate by offset function while data content redirection is embodied as a novel Locate by content function . In response to input of inter alia an offset into a data container file the Locate by offset function provides a file index that is used to determine the storage server that is responsible for a particular region of the file. The Locate by content function is then invoked to determine the storage server that actually stores the requested data on disk. Notably the content function ensures that data is stored on a volume of a storage server based on the content of that data rather than based on its offset within a file. This aspect of the invention ensures that all blocks having identical data content are served by the same storage server so that it may implement de duplication to conserve storage space on disk and increase cache efficiency of memory.

As noted the storage server of each node is illustratively embodied as a D module configured to serve a physical volume embodied as an aggregate. Requests to read and write data are received by an N module that applies the Locate by offset function to decide which D module should service that request. The Locate by offset function is illustratively implemented as a primary file offset indexing hashing system given a file inode number an index within an inode file and an offset within that file as well as a SVS ID and a set of striping rules the hash function selects an appropriate D module as responsible for that region of data. Given the same inputs i.e. the same offset of the same file the hash function always returns the same results. Therefore if one client attempts to write a particular region of a file and a second client attempts to read that same region of the file the second client reads the data written by the first client.

The present invention augments this primary hashing system to ensure that identical blocks of data are stored on the storage served by the same D module. Once identical blocks of data are written to the same aggregate a de duplication technique may be invoked to eliminate duplicate data and ensure that only one copy of that data is actually written to disk. An example of a technique for eliminating duplicate data that may be advantageously used with the present invention is described in the above incorporated U.S. patent application Ser. No. 11 105 895 filed on Apr. 13 2005 entitled METHOD AND APPARATUS FOR IDENTIFYING AND ELIMINATING DUPLICATE DATA BLOCKS AND SHARING DATA BLOCKS IN A STORAGE SYSTEM by Ling Zheng et al.

To enable de duplication in the illustrative storage system architecture the invention provides a second complementary hashing system. The Locate by content function is illustratively a mathematical construct that performs a checksum of the data within a full 4 KB block and then selects a constituent volume within the SVS based on that checksum. This checksumming may be performed using a conventional hashing algorithm such as the well known MD 5 technique however it is expressly contemplated that other checksumming techniques may be utilized. As an example consider a SVS with six constituent volumes DVs if a 4 KB block has a checksum value of 0x12308A4B then the selected DV is 3 0x12308A4B 6 . In other words as a result of hashing the content of the data block to a hash value 0x12308A4B modulo 6 the block is stored on the D module responsible for serving DV of the SVS. Thus all blocks that hash to this same hash value i.e. have identical content end up on the same D module that serves DV.

Broadly stated the N module executes the Locate by offset function to identify a first D module to which the data access request should be forwarded and the first D module VSM then executes the Locate by content function to determine a second D module that actually serves the requested data. Notably the second D module may be different i.e. remote from the first i.e. local D module. That is in a fraction of the cases average of 1 N where N is the number of constituent DVs in the SVS the Locate by content function will indicate that the local D module should store the data on a local constituent volume of the SVS however in the majority N 1 N cases the hash will indicate that a remote D module serving a remote constituent volume should store the data. Notwithstanding where the data is actually stored the local D module maintains responsibility for the region of the file identified by the Locate by offset function .

For example assume offset 2 MB to 4 MB of a particular file is owned by the local D module. As a result the striped version of that file i.e. across all other remote D modules of the SVS is empty sparse from offset 2 MB to 4 MB. Each remote D module of the SVS has a 2 MB hole at that offset because only the local D module is responsible for that region. However as a result of de duplication the local D module may choose to delegate the storage of a particular block or a series of blocks within that region to another remote D module. As noted all of the remote D modules have a sparse region between 2 MB and 4 MB therefore when the local D module instructs a remote D module to store a particular block at offset 3 MB the remote D module has a sparse hole at that location offset of the file and thus can store it there.

In the event a remote D module serves the requested data the local D module marks the lowest level indirect block associated with the data of the file with an identifier ID of the constituent volume i.e. aggregate of the SVS served by remote D module rather than marking that indirect block with a pointer e.g. vbn referencing a block location of the data on the aggregate served by the local D module. According to the invention the constituent volume ID is illustratively a special hash value embodied as a de dup marker. is a schematic block diagram of an exemplary inode buffer tree illustrating use of a de dup marker in accordance with an embodiment of the present invention. The inode buffer tree includes an inode having a plurality of pointers each of which points to references one or more indirect blocks . The pointers illustratively reference lowest level level 1 indirect blocks that in turn directly reference level 0 data blocks. Each indirect block contains a plurality of pointers either a data D pointer that points to a level 0 data block or a de dup marker DDM that references a constituent volume of the SVS that stores the data. Marking of the indirect block with the de dup marker value specifies that the requested data block is present on the aggregate served by e.g. the remote D module.

In Step the VSM of the local D module obtains acquires a range lock for the affected region of the file i.e. for the entire size length of the write data associated with the operation. In Step the local D module determines whether the write data of the operation fits onto a single stripe the first stripe by examining the length of the data the stripe width and the location within the stripe at which the write operation begins. If the write data fits within the stripe the procedure branches to Step where a write operation is performed. Such a write operation is described in U.S. patent application Ser. No. 11 119 278 entitled STORAGE SYSTEM ARCHITECTURE FOR STRIPING DATA CONTAINER CONTENT ACROSS VOLUMES OF A CLUSTER.

After the data has been modified and written to disk at DV the de duplication technique may be initiated to eliminate duplicate data for the affected file. Note that the local D module serving DV retains a copy of the data in its memory so that it can perform the novel Locate by content function . In Step the local D module exec cutes the Locate by content function to calculate a checksum for each modified 4 KB block of data in order to generate a de dup marker hash value. As noted the de dup marker comprises a special hash value that determines as a result of the Locate by content function the constituent volume of the SVS that should be selected to store the data i.e. whether the data should be stored locally on the volume served by the local D module Step . If the de dup hash value indicates that the data should be locally stored the local D module performs the de dup technique in Step i.e. by freeing the duplicate data block.

If the de dup hash value indicates that the data should be remotely stored on another constituent SVS volume the local D module sends the modified data to a remote D module serving that volume Step instructing it to store the write data at the corresponding offset within the affected file. On the local D module a de dup marker is written at the corresponding lowest level indirect block of the affected data Step to indicate where the data can be found. For example assume the local D module hashes a modified block in accordance with the Locate by content function and determines that the block should be stored remotely e.g. on DV . The local D module thus forwards the block of data to the remote D module serving DV specifying the offset at which to write the data within the file and records a de dup marker on its local disk. The remote D module then performs the de dup technique in Step . Note that as part of this operation the remote D module could determine that considering the content of the block the data should be stored by yet another remote D module on e.g. DV. As a result the remote D module sends the block to the D module serving DV and records a de dup marker indicating that it received the data and stored it on DV and furthermore that it acknowledged back to the local D module that the write operation was successful.

However if the write data does not fit within the stripe Step then in Step the VSM of the local D module records a persistent reminder e.g. a persistent marker denoting that a cross stripe write operation is in progress. Such a cross stripe write operation is described in U.S. patent application Ser. No. 11 119 279 entitled SYSTEM AND METHOD FOR IMPLEMENTING ATOMIC CROSS STRIPE WRITE OPERATIONS IN A STRIPED VOLUME SET which application is hereby incorporated by reference. In the illustrative embodiment the persistent marker may be stored on local storage of the local D module. In the event of a crash or other failure condition to the node and or cluster the persistent marker reminds the VSM that a cross stripe write operation is in progress and thus enables the VSM to subsequently recover and complete the operation.

In Step the local D module then stores writes the entire data associated with the cross stripe write operation on data volume DV. In Step a determination is made as to which data is directed to the first stripe. Specifically the local D module modifies and writes that portion of the data directed to the first stripe of the file to its proper stripe location on DV in accordance with a write operation Step . The remaining portion of the data is stored in an area of DV that is otherwise sparse in accordance with the striping algorithm employed by the SVS. By storing the remaining portion of the data i.e. the excess data on the sparse area of DV the cross stripe write operation is atomically performed and considered committed to persistent storage.

After the data directed to the first stripe has been written to disk of DV the de duplication technique may be initiated to eliminate duplicate data for the affected file. As noted above the local D module serving DV retains a copy of the data in its memory i.e. a content identifier so that it can perform the novel Locate by content function . For those blocks for which it is responsible the local D module executes the Locate by content function to calculate a checksum for each modified 4 KB block of data in order to generate a de dup marker hash value Step . In Step the de dup marker value determines the constituent volume of the SVS that should be selected to store the data i.e. whether the data should be stored locally on the volume served by the local D module. If the de dup hash value indicates that the data should be locally stored the local D module performs the de dup technique in Step . If the de dup hash value indicates that the data should be remotely stored on another constituent SVS volume the local D module sends the modified data to remote D module serving that volume Step and the procedure continues as described above.

In Step the local D module forwards the remaining data to another remote D module serving a second constituent SVS volume e.g. DV which in Step performs the cross stripe operation for a second stripe affected by the operation i.e. the next data volume storing the next stripe in accordance with the file striping algorithm associated with the SVS. Once the operation of Step as well as Steps 1920 and 1926 completes the local D module removes the range lock in Step and the procedure continues to Step where the local D module returns success to the N module which in turn returns an indication of success back to its caller client . The procedure then ends at Step .

It should be noted that a potential race condition may arise if a subsequent read or write request is directed to the same region of the file during the write operation. Such a race condition is addressed in the same manner as during a cross stripe write operation the write operation is performed in its entirety against the local D module as if de duplication were disabled and then the de duplication technique is performed. The range lock is invoked over the affected region and the persistent marker is set to ensure restartability in the event of transient failure as a result the write operation can be performed safely while guaranteeing de duplication efficiency.

In an alternate embodiment the invention may be extended to improve performance. As part of the cross stripe write operation the local D module DV first commits writes the data to its local disk and then examines those written blocks to decide whether they need to be forwarded to a remote D module for de duplication. If so the local D module forwards the data and frees the corresponding local block s and records pointer s indicating that the data is actually stored on a remote disk DV served by the remote D module. If the completion notification returned to the N module ensures that the data is successfully and safely written to disk that has been achieved as soon as DV committed the data to its local disk. Thus the local D module may return success at that point and the de duplication technique could be run as a background thread thereby reducing latency at a client. Accordingly a successful write operation can be acknowledged to the N module as soon as the data is written to the local disk i.e. even before de duplication is performed.

Upon receiving the request the selected D module accesses loads the inode corresponding to the file from the aggregate in Step and in Step iteratively loads indirect blocks in order to find the data block that contains the requested data. In Step the D module examines the lowest level indirect block or possibly the inode itself if there are no indirect blocks to determine whether the indirect block contains a de dup marker instead of a pointer to a block number within the aggregate Step . If the indirect block does not contain a de dup marker the D module retrieves the requested data block from the aggregate in Step and returns the data in a response to the N module in Step . The N module then returns the data to the caller client and the procedure ends at Step .

However if the indirect block does contain a de dup marker the local D module examines the marker to determine to which remote D module the request should be forwarded for serving the request Step . As noted the de dup marker comprises a special value that represents the result of the Locate by content function . For example the value of the de dup marker may indicate that the data block is not stored on DV and serviced by the local D module but rather is stored on DV of the SVS and serviced by a remote D module. In Step the local D module forwards the request to the remote D module to retrieve the data block. In Step the remote D module forwards the requested data to the local D module which in Step returns the requested data to the N module. The procedure then ends at Step .

In yet an alternate embodiment performance of the invention may be improved by allowing the N module rather than the D module to perform the Locate by content function . Here the N module performs the hash of Locate by content function and possibly sends two requests to two different D modules instead of just one D module . That is a first request is sent to a first D module that is responsible for the affected region according to the Locate by offset function this request notifies first D module that the N module is sending the write data to a second D module. The second request is sent directly to the second D module instructing that module to write the data at the appropriate location. These requests are preferably synchronized so that they happen at the same time. This alternate embodiment may be effective for database and LUN based applications where a substantial number of write requests are fixed size e.g. 4 KB and aligned to a natural e.g. 4 KB boundary and where there are a substantial number of identical blocks often zero or pattern filled .

Advantageously the novel Locate by content function provides a secondary hash that modifies a primary hash provided by the Locate by offset function . That is the primary hash identifies a first D module that is responsible for a region of a file while the secondary hash identifies the D module that actually serves the requested data block to enable de duplication. The Locate by content function is thus a subservient hash to the Locate by offset function that augments the primary hashing system to ensure that identical blocks of data are stored on the same aggregate served by a storage server D module . Once identical blocks of data are written to the same aggregate the D module may implement de duplication to thereby efficiently ensure that only one copy of that data is actually stored on the aggregate.

It should be further noted that identical blocks of data are often stored within the same volume and not simply within the same aggregate. This means that a particular constituent volume can be moved from one aggregate to another without losing any of the benefits of de duplication. The encoding of the de dup markers is also independent of the identities and or locations of the constituent volumes only their indices within the SVS are recorded. In this way moving a constituent volume has no impact on the data stored within the volume and as such moving a constituent volume does not require any special handling.

While there has been shown and described illustrative embodiments of a system and method for enabling de duplication in a storage system architecture comprising one or more volumes distributed across a plurality of nodes interconnected as a cluster it is to be understood that various other adaptations and modifications may be made within the spirit and scope of the invention. For example in another embodiment of the invention data hashing as provided by the Locate by content function can be disabled where appropriate. Such disabling may be performed by an administrator entering a command into a user interface such as a graphical user interface and or a command line interface. For example data hashing can be enabled when writing large quantities of data to disk and then disabled for typical day to day operations that do not want to incur added latency for new write accesses. By disabling the Locate by content function new write operations are not redirected to other D modules. Thus the invention can be selectively enabled for new write requests operations at any time.

The foregoing description has been directed to particular embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. Specifically it should be noted that the principles of the present invention may be implemented in non distributed file systems. Furthermore while this description has been written in terms of N and D modules the teachings of the present invention are equally suitable to systems where the functionality of the N and D modules are implemented in a single system. Alternately the functions of the N and D modules may be distributed among any number of separate systems wherein each system performs one or more of the functions. Additionally the procedures processes and or modules described herein may be implemented in hardware software embodied as a computer readable medium having program instructions firmware or a combination thereof. Accordingly this description is to be taken only by way of example and not to otherwise limit the scope of the invention. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

