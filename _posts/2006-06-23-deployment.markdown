---

title: Deployment
abstract: A method is provided. The method develops code for an enterprise module in an enterprise module development environment. Further, the method modifies the code to output customized code that runs in an enterprise module production environment. In addition, the method deploys the customized code to the enterprise module production environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09075596&OS=09075596&RS=09075596
owner: Oracle International Corporation
number: 09075596
owner_city: Redwood Shores
owner_country: US
publication_date: 20060623
---
This application claims the benefit of and priority to U.S. Provisional Application Ser. No. 60 693 572 filed Jun. 24 2005 the contents of which are incorporated by reference herein in its entirety.

Computer systems form the backbone of modern business. Computer systems are used in virtually every step of a business chain. For example computer systems are used to purchase source materials track production monitor inventory levels monitor quality set pricing maintain customer relationships provide accounting services maintain a payroll provide employee benefits track inbound outbound shipments track customer satisfaction or complaints and perform countless other tasks to run a business.

A number of enterprise software applications have been created to allow a business to perform many of these business support functions with a single integrated software application. These enterprise software applications have provided the businesses that employ these applications with a competitive advantage. However such enterprise software applications tend to be expansive applications that require significant computer resources to run and knowledgeable technicians to maintain. Furthermore enterprise software applications tend to be expensive programs to purchase or lease. Thus enterprise software applications have mainly been used only by very large corporations that are able to afford such infrastructure investments and continue to pay for their continued use.

Even very large corporations can have some difficulties with large enterprise software applications. For example a large corporation may already have a legacy software application that the large corporation wishes to continue using. Thus integrating the legacy software application with a new enterprise software application can be difficult and require very skilled application integrators.

Furthermore corporations in different business segments often have very different needs from their enterprise software applications. Therefore a corporation using with a one size fits all enterprise software application may find that the one size fits all enterprise software includes many unnecessary features. These unnecessary features needlessly cost the corporation money and consume valuable computer resources. The enterprise software application may also be missing a number of desired industry specific features for each different corporation. These corporations must develop these missing features internally or find another software application that provides the needed features. If an additional software application that provides the missing features is located then the corporation must integrate that additional application with the enterprise software application.

Due to these difficulties with large enterprise software applications it would be desirable to find a way to make such enterprise software applications more flexible. Specifically it would be desirable to allow small businesses to be able to afford some of the features provided by enterprise software applications. Similarly it would be desirable to allow large corporations to easily select and install only the needed features. And finally it would be desirable to have an ability to easily integrate the enterprise software application with other customized applications.

In one aspect of the disclosure a method is provided. The method develops code for an enterprise module in an enterprise module development environment. Further the method modifies the code to output customized code that runs in an enterprise module production environment. In addition the method deploys the customized code to the enterprise module production environment.

In another aspect of the disclosure a system is provided. The system has a unit that develops code for an enterprise module in an enterprise module development environment. Further the system has a unit that automatically modifies the code without user interaction to output customized code that runs in an enterprise module production environment. In addition the system has a unit that deploys the customized code to the enterprise module production environment.

In yet another aspect of the disclosure a machine readable medium has stored thereon a set of instructions which when executed perform a method. The method develops code for an enterprise module in an enterprise module development environment. Further the method modifies the code to output customized testing code that is customized to run in an enterprise module testing environment. In addition the method tests the customized testing code in the enterprise module testing environment. Further the method modifies the customized testing code to output customized production code that is customized to run in an enterprise module production environment. In addition the method deploys the customized production code to the enterprise module production environment.

A method and apparatus for implementing a portable and open standards based business application platform are disclosed. In the following description for purposes of explanation specific nomenclature is set forth to provide a thorough understanding of the present disclosure. However it will be apparent to one skilled in the art that these specific details are not required in order to practice the method and apparatus disclosed herein. For example although reference is made to the J2EE and .Net application platforms the same techniques can easily be applied to other types of application platforms.

Certain computer application tasks require very large and complex computer software applications. For example running an entire business operation requires a very large application an enterprise application that can handle many different tasks. Providing such large and complex enterprise software applications to a customer can be a great challenge to the enterprise software application developer.

The enterprise application can be an expensive application to purchase or lease which utilizes significant computer resources. Further installing and maintaining the enterprise software application may require knowledgeable technicians. Thus a smaller business might not want to use the large and complex enterprise application .

Even large corporations with significant computer resources and budgets may have difficulties with the large enterprise application. For example a large corporation may already have a legacy software application that the corporation wishes to continue using. Thus integrating the legacy software application with a new enterprise application can be difficult and require very skilled application integrators.

The enterprise application can include a variety of components which form the building blocks of the enterprise application . An example of a component is a module which is a collection of computer code that can be written to provide a service.

The enterprise application may consist of many different individual modules. For example as illustrated in the enterprise module can be composed of four individual enterprise modules enterprise module A enterprise module B enterprise module C and enterprise module D . A customer may need some of the enterprise modules while not needing others. For instance a corporation may have use for the enterprise module A and the enterprise module B but may have no use for the enterprise module C and the enterprise module D . Further the corporation may need an additional module that is not provided in the enterprise application . In those situations the customer develops internally or purchases an additional application that provides the features of the additional module. If an additional application that provides the missing features is located then the corporation must integrate that additional application with the enterprise application . illustrates the additional application being integrated with the enterprise application . Such development is expensive because technical skills are needed to locate or develop the additional application and then integrate the additional application with the enterprise application . Accordingly the corporation may not find the one size fits all enterprise application to be an optimal solution for its needs.

As an alternative to the monolithic enterprise software applications discussed above enterprise application services can be provided to customers over the Internet. illustrates an on line or hosted infrastructure that can be utilized to provide an enterprise application over the Internet . Specifically an enterprise application provider hosts the enterprise application on a server and allows customers to access the server on line. The server can be located at the enterprise application provider s facility. The enterprise application mainly uses computer system resources provided by the enterprise application provider . Enterprise application includes enterprise module A enterprise module B enterprise module C and enterprise module D . Customers such as customer X customer Y and customer Z can access the enterprise application over the Internet . Each of the customers can have a database. For instance the customer X may have a customer X database the customer Y may have a customer Y database and the customer Z may have a customer Z database . The enterprise application provider keeps track of the different customer data using different database services in the enterprise application data sources such as enterprise database service X for customer X enterprise database service Y for customer Y and enterprise database service Z for customer Z .

Accordingly the infrastructure of allows small businesses to enjoy enterprise application services without needing to install and maintain a large enterprise application. Customers can access and pay for only portions of the enterprise application . For example the customers X and Y send and receive data to and from all of the computer resources thereby accessing the entire enterprise application and all the enterprise modules while customer Z sends and receives data to and from only the enterprise module C thereby accessing only enterprise application module C .

A customer that prioritizes having the enterprise application on the customer s premises may purchase the one size fits all enterprise application of . Further a customer that prioritizes maintaining low costs e.g. a small business may purchase individual modules of the enterprise application of to obtain limited enterprise application services at a lower cost than purchasing the entire one size fits all enterprise application .

In one embodiment the enterprise module assembly system breaks up an enterprise application into individual enterprise modules. The enterprise application can be a large complex computer application e.g. an enterprise application or an even larger complex application program. The customer can then select the individual enterprise modules that the customer would like to utilize. Each of the enterprise modules can provide a different service. For instance the enterprise application may provide an enterprise module A for purchasing source materials an enterprise module B for tracking production an enterprise module C for monitoring inventory levels an enterprise module D for monitoring quality an enterprise module E for setting pricing and an enterprise module F for maintaining customer relationships. The customer may then select which of these enterprise modules it would like to purchase. For instance in the customer has selected the enterprise module A the enterprise module B and the enterprise module C but has not selected the enterprise module D the enterprise module E or the enterprise module F. The customer may not have selected the enterprise module D because the customer may already have existing software for monitoring quality. Further the customer may not have selected the enterprise module E because in the context of its business the customer does not need any software for setting pricing. Finally the customer may not have selected the enterprise module F because the customer plans on internally developing an additional application for maintaining customer relationships.

The enterprise modules can be provided to the customer in a variety of ways. For instance technicians can physically install the enterprise modules which the customer has selected at the customer site . Alternatively the enterprise modules can be transmitted through a network such as the Internet to the customer site .

In another embodiment the enterprise module assembly system creates the enterprise modules as opposed to breaking up an existing enterprise application . In other words the enterprise module assembly system can create a collection of enterprise modules each corresponding to a particular service and allow a customer to select the enterprise modules that it would like to utilize.

In addition the customer site has an enterprise application database that is hosted on a database server . The enterprise application database can store information related to each of the enterprise modules and the additional application so that particular enterprise modules and or the additional application can be searched for. In addition the customer site has a computer network through which the enterprise module A the enterprise module B the enterprise module C the additional application and the enterprise application database service can all communicate with one another. For instance although the enterprise module A is stored on a different server than the additional application the enterprise module A and the additional application can still communicate with one another.

Accordingly a customer can utilize some or all of the individual enterprise modules from the enterprise application . The customer site as illustrated in can provide an open standards platform that has many tools and services for application development application integration and application management. Thus a customer can easily create new application programs e.g. the additional application integrate the new application programs with the enterprise modules and manage the enterprise modules and the new applications.

A discussion shall now be provided regarding how an enterprise module is generated. For ease of discussion the enterprise module A as seen in shall be utilized as an example of an enterprise module.

The enterprise module A is constructed so that it 1 is portable and 2 utilizes an open standards platform. By being portable the code utilized to create the enterprise module A can compile and run on more than one application platform. For ease of discussion examples shall be provided herein that utilize J2EE and .Net which are well known platforms to one of ordinary skill in the art. However other platforms known to one of ordinary skill in the art can easily be utilized. By being open as discussed above the enterprise object code included in the enterprise module A is platform dependent so that the enterprise module A can be easily integrated with other applications e.g. the additional application that have object code for the same platform that the customer utilizes.

Initially a developer determines what components of the enterprise module are platform independent and what components are platform dependent. In other words in order for the enterprise module to eventually become native to a customer s system some components of the enterprise module will require data specific to the individual customer s platform while other components of the enterprise module will not require data specific to the individual customer s platform.

The main algorithms utilized by the enterprise module A are mostly not specific to the actual platform on which the enterprise module A is being implemented. Accordingly a large portion of these algorithms can be coded in platform independent source code . The platform independent source code can be a subset of the syntax language of one or more platform independent languages. Accordingly the platform independent source code can be compiled on any of the compilers that support one of the platform independent languages utilized for the subsets. For instance the platform independent source code can be a subset of the syntax language for .Net and J2EE. If the function for concatenate is concat in both .Net and J2EE then the subset includes the function concat . If the compiler supports .Net then the use of the function concat is accepted by the compiler. Similarly if the compiler supports J2EE then the use of the function concat is also accepted by the compiler. An example of a subset of syntax language is a subset of the Java 1.1.4 computer language. The subset can be compiled on either a .Net or J2EE compiler.

However some services are platform specific. For instance the security policy for the enterprise module A may vary significantly from one platform to another. The high level abstract languages provide the developer with a way of coding the plurality of platform dependent components in a portable manner. In other words the developer does not have to actually code each of the platform dependent components according to the individual customer s native platform. The developer can utilize the same high level abstract language to code a particular platform dependent component for different customers with different native platforms.

An example of a developer utilizing high level abstract languages would involve the developer utilizing XML to code the platform dependent component A for Security Policy and Java to code the platform dependent component B for Exception Handling. In other words the security policy on different customer systems may be significantly different but the developer can utilize XML to code the platform dependent component A for Security Policy customers with different platforms. Further the developer can utilize Java to code the platform dependent component B for Exception Handling for different customers. While a different high level abstract language could potentially be utilized to code each platform dependent component one high level abstract language could also be used for all of the platform dependent components . In addition a set of high level abstract languages can be utilized so that each high level abstract language may be utilized to code more than one of the platform dependent components . For example XML and Java can be utilized for the plurality of platform dependent components so that half of the platform dependent components are coded in XML and half of the platform dependent components are coded in Java. In an alternative embodiment some of the platform dependent components illustrated in may not be native to an individual customer s platform and the developer may choose to classify those components as platform independent components.

The enterprise module production environment provides the platform dependent components coded in the high level abstract language to a component transmogrifier . Further the component transmogrifier has data regarding the platform specifics of the particular customer for which the enterprise module A is being developed. Accordingly the component transmogrifier can automatically convert the code written by the developer for the platform dependent components into platform dependent source code . In other words the developer can utilize the same high level abstract language to generate platform dependent source code for different platforms. The developer does not have to waste the resources that would be needed to become familiar with the computer languages utilized for each customer s platform.

The component transmogrifier can output a plurality of platform dependent artifacts . For example the platform dependent source code is a platform dependent artifact. Metadata is also an example of a platform dependent artifact. The metadata can be any data associated with the enterprise module A . For instance the metadata can provide information for a graphical user interface such as field names. Other examples of platform dependent artifacts are deployment descriptors XML Schema Definition XSD Web Services Description Language WSDL Bytecode and International resources . The International resources include mainly localizable artifacts such as localized strings dialogs screens etc.

Further the plurality of platform dependent artifacts such as the platform dependent source code are provided to the compiler and linker so that the platform dependent source code can be compiled and linked with the platform independent source code . As a result enterprise object code is generated.

In order to help facilitate software development the module construction system provides libraries of pre constructed code that the developer can utilize when programming in the native platform computer languages. As the module construction system is portable a developer can access pre constructed routines for any of the native platform computer languages that are utilized. Further an intersection library includes the set of routines that is commonly available in each of the native platform computer language libraries. An intersection occurs when the same name of a function appears through each of the native computer language libraries that are being utilized. For instance a function to change the orientation of an object may be called reorient in both C and Java. Even though the underlying code for the function reorient may be different in C than in Java a compiler that supports either C or Java can be utilized to change the orientation of the object. However if the name of the function in C is reorient and the name of the function in Java is rotate the two functions may be found in the portable library . Further if there is a function in C called reorient but no function in Java then a function is composed in Java and placed in the portable library . In one embodiment the newly written function has the same name as the corresponding function in C . In an alternative embodiment the newly written function has a different name than the corresponding function in C . The intersection library and the portable library are provided to the compiler and linker so that the routines that are called from the developer s code can be found during the compilation and linkage phase.

The enterprise object code is platform specific so that the enterprise object code can be run on the customer s computer network . Further as illustrated in the enterprise object code is provided to a packaging system which adds additional information to the enterprise object code to generate the enterprise module A . Accordingly the enterprise module A can now be utilized for the specific platform at the customer site and can also be seamlessly integrated with other software at the customer site .

Some of the platform dependent artifacts are provided after the compiling and linking phase. For instance metadata may be provided to the compiler and linker the enterprise object code and the packaging system . The metadata can include information specific to the customer s platform. Accordingly the metadata can help compile link and package the code for the enterprise module A so that the enterprise module A can run on the customer s native platform. Further the metadata can be provided to the enterprise module A at run time so that the enterprise module A can execute according to customer specific information.

In addition the deployment descriptors XSD WSDL Bytecode and Intl resources can also be added to the enterprise object code and to the packaging system . These additional platform dependent artifacts may provide additional information and or code that assists the enterprise module A .

The discussion above explains how an individual enterprise module A is generated so that the enterprise module can be easily integrated with the additional application at the customer s site as seen in . In one embodiment the enterprise module A can work in concert with the other enterprise modules to optimize efficiency. Accordingly dependency relationships can be established between the enterprise modules.

As seen in the intersection library and the portable library provide pre constructed code that can be utilized for the enterprise module A . Further the intersection library and the portable library can provide routines for either or both of the plurality of the platform dependent artifacts and the platform independent source code . In one embodiment all of the pre constructed code that is utilized by the enterprise module A does not have to be stored in the libraries for the enterprise module A . For instance if the enterprise module B utilizes similar pre constructed code to the enterprise module A the pre constructed code can be stored in a library for the enterprise module B . The enterprise module A can then access the pre constructed code by depending on the enterprise module B . Accordingly the enterprise module A does not have to inefficiently repeat storage of the same pre constructed code. Further the pre constructed code can be stored by the enterprise module B even if the enterprise module B does not actually need to utilize that pre constructed code. For instance if the enterprise module A needs to utilize a large amount of pre constructed code and the enterprise module B only needs to utilize a small amount of pre constructed code the enterprise module B has extra capacity and can thereby store some of the pre constructed code that the enterprise module A needs to utilize.

In the example of the pre constructed function reorient discussed above the enterprise module A may wish to utilize the function reorient but may not actually have the code stored in the library collection . Further in order for the enterprise module A to be portable the code it utilizes has to be able to be run on multiple platforms. For instance the code that supports reorient in the .Net platform may be found in the library collection of the enterprise module B while the code that supports reorient in the J2EE platform may be found in the library collection of the enterprise module C .

As will be discussed further the code in the enterprise module A may include libraries and or executables. In one embodiment a dependency declaration is provided at the level of the library or executable. Tags can be used to indicate the dependencies. For instance a tag can be utilized to indicate a dependency relationship. In the context of the following code is provided as an example to illustrate the dependency of the portable library A of the enterprise module A to the portable library of the enterprise module B and the portable library of the enterprise module C .

When the portable library A of the enterprise module A is compiled on a Java platform the portable library A will have a dependency to the portable library B of the enterprise module B . On the other hand when the portable library A of the enterprise module A is compiled on a .Net platform the portable library A will have a dependency to the portable library C of the enterprise module C .

In another embodiment the portable library A of the enterprise module A may be able to rely on at least a portion of its own code thereby allowing the portable library A to rely less or possibly not at all on the portable library B of the enterprise module B and the portable library C of the enterprise module C . Accordingly an analysis is performed to determine what dependencies are needed or whether any dependencies are needed at all.

The intersection library includes code for native platform computer languages from Application Programming Interfaces APIs that have common syntax names across platforms where as the portable library may include code from different platforms that have different syntax names or even code that is constructed to provide functionality for a platform that is missing from one platform yet present in another. Accordingly the code with common syntax names is designated for the intersection library and the code without common syntax names is designated for the portable library . As a result any code that is missing for a particular platform in the portable library can be composed.

Further the platform independent source code can be compiled and linked with the intersection library and the portable library . In addition the portable library can be compiled with the platform independent source code .

A portability tree can be constructed to determine what code is portable and what code is non portable. Routines for the portable code can be placed in the platform independent source code while routines for the non portable code can be placed in the portable library . Since a subset of platform independent languages is utilized for the platform independent code only one routine for a particular task is placed into the platform independent source code . On the other hand multiple routines for the same task may need to be placed into the portable library to ensure that the same task can be performed by platform dependent code on any of the intended platforms at the customer site as seen in .

The root of the portability tree is the most portable virtual platform where as the leaflets are the most specific and non portable. For instance if the code included in the enterprise module A is written according to a portable node the code can be utilized on any of the intended actual platforms for which the leaflets store code. At the next level of the portability tree the code in the enterprise module A is written in code for either the .Net node or the Java node . If the code is written for the .Net node then the code may not be compatible with the Java node and vice versa. At the next level of the portability tree the code in the enterprise module A is written for the dotnet client node the aspnet node the j2se node or the j2ee node . Code written in the dotnet client node or the aspnet node is compatible with the .Net node . Further code written in the j2se node or j2ee node is compatible with Java . At the next level of the portability tree the code in the enterprise module A is written for the wls node or the was node . Further code written for the wls node or the was node is compatible with j2ee node . One of ordinary skill in the art will be familiar with these different platforms. Accordingly the portability tree can be utilized to classify the different pieces of code in the enterprise module A .

For instance after performing a portability tree analysis on the code of the enterprise module A it may be determined that the enterprise module A has a library and or executable with code written and or generated at the portable node code written and or generated for .Net and code written and or generated for the was node . With respect to the code for the portable node the enterprise module A can run this code on any platform. During a build code can be generated for each of the platforms in the leaflet nodes. Accordingly a downward propagation can be performed to build code for each of the platforms at a lower level. A downward propagation is intended to mean a traverse down to the leaflets of a position in the portability tree .

With respect to the code for .Net node the enterprise module A can run this code on any .Net platform. Further a downward propagation can be utilized to generate code on any of the platforms that are leaflets from the .Net node e.g. the dotnet client node and the aspnet node . However this code cannot be run on any of the leaflet nodes of the Java node e.g. the j2se node or the j2ee node or any of the leaflets from the j2ee node e.g. the wls node or the was node . The code at the leaflet nodes needs to be compiled with the intersection library and the portable library to ensure that the platform specific routines needed by the platform dependent code is available.

The portability tree as seen in is not limited in the number of levels that the portability tree can utilize. In other words the portability tree can have many sub levels. Further any of the sub levels can be utilized as the first sub level or the second sub level as long as the root level is not utilized and the second sub level is below the first sub level. For instance the first sub level does not necessarily have to be the level below the root level. Further the second sub level does not have to be the last level. In addition there can be levels in between the first sub level and the second sub level. Accordingly a platform on the first sub level is compatible with a platform on the second sub level thereby allowing for downward propagation. However it is not necessarily the case that a platform on the second sub level is compatible with a platform on the first sub level thereby preventing upward propagation. Therefore supplementation is needed for the platforms included in the upward propagation. Further supplementation is needed for the platforms in between the first sub level platform and the second sub level platform.

In one embodiment dependency relationships can be established without utilizing the portability tree . illustrates a process of generating a portable enterprise module. At a process block the process determines a plurality of platforms on which a first enterprise module is intended to run. Further at a process block the process determines a first set of code included in the enterprise module that is compatible with at least one of the platforms and is incompatible with at least one of the other platforms. The first set of code is prepared to accomplish a task. In addition at a process block the process establishes a dependency relationship with a second enterprise module to obtain a second set of code that is compatible with the platform that the first set of code is incompatible with. The second set of code is prepared to accomplish the task.

In order to help facilitate the type of platform that a particular library is associated with a declaration can be provided for each executable and or library to indicate the type of platform that the executable and or library can run on. Accordingly an analysis to determine the need for dependency relationships can be performed on the platform declaration of the code in the enterprise module A to determine what platforms are present and what platforms are missing. Further an analysis can be performed on the platform declarations of the code in the other enterprise modules to determine if other enterprise modules have code for the missing platform thereby facilitating the identification of enterprise modules to which dependency relationships can be created. In one embodiment a declaration file can be written to describe the enterprise module. Accordingly the declaration file can be placed into the subdirectory for the enterprise module. The declaration file can begin with a tag to indicate which library is being referred to e.g. the intersection library or the portable library . Further a tag can be provided to indicate what platform the library supports. In addition a tag can be utilized to tell the system what computer language to utilize to build the source files. The following code is illustrative of a declaration file 

As an example with respect to the Portable Library A the code above indicates that the build system is to look under the dotnet subdirectory and search for all the files with the .java extension. An excludes attribute can be utilized to exclude certain files. For example the following code will find all of the .java files except for bad.java . Further multiple types of platforms can be designated. For instance the following code utilizes multiple masks . Accordingly the build system will find all the files with the .java and .jsl extensions. In addition a tag can indicate what platforms are not supported. For instance the following code provided in the above example indicates that Portable Library A should not be built on a java platform .

In one embodiment a code propagation policy can ensure that if a declared platform is unsupported all of its descendents are also unsupported. In another embodiment this aspect of the code propagation policy can be overwritten by specifically declaring the descendent platform.

In another embodiment dependency relationships are created to avoid circular dependency relationships. In other words a first enterprise module does not have a dependency relationship direct or indirect to a second enterprise module that has a dependency relationship direct or indirect to the first enterprise module. A circular dependency relationship can potentially lead to a situation in which two enterprise modules are depending on one another for code without either of the enterprise modules actually having the code.

By establishing dependency relationships at the enterprise module level the complexity of maintaining the dependency relationships is significantly reduced. In other words the dependency relationships do not have to be tracked at the file level or at the library level. For instance when packaging an enterprise module the other enterprise modules from which it depends can be easily deduced by performing a recursive walk through the dependency declarations of each enterprise module. As a result a list of dependency relationships can be compiled.

In yet another embodiment an enterprise module can include a library executable repository and or a module interface. The library can include a collection of classes working together. Further the executable provides an entry point for execution. In addition the repository provides a collection of configuration files. For instance the repository can contain XML files describing object types and object definitions. A dependency relationship between repositories of two enterprise modules essentially creates a dependency relationship between the two enterprise modules. Further the module interface exposes a set of interfaces that can be utilized by other enterprise modules.

Examples are now provided for different module interfaces. The module interfaces can include strings exceptions XSD based types web service proxy web service skeleton and configuration. Further these different module interfaces can include generated code. Strings are classes that help manage string resources. Further Exceptions are classes generated based on an exception message and group which a particular exception belongs to. In addition XSD based types are classes or types described by XML Schema. The XSD based types provide the ability to serialize to streams and files. Further the XSD based types allows the association of the generated type to a subclass instead of the basic generated class skeleton. As a result the developer can permanently augment a generated base class without losing added functionality each time a class is regenerated. In addition a Web service proxy is a strongly typed proxy class for accessing a web service. The generated proxy classes are portable so that they can be utilized for all of the intended platforms. Accordingly separate versions of the proxy are not needed for the different platforms. Further a web service skeleton class provides the infrastructure needed for a web service. In addition a configuration type provides a framework to work with a set of name value pairs of configuration information.

In one embodiment the code for an enterprise module can be provided in a subdirectory. For instance the code in a system can be partitioned into code for applications build system core and other categories. Further each of these subdirectories can have more partitions that can be utilized to logically group and organize the code base. Accordingly a subdirectory can be allocated for the enterprise module. The subdirectory can be identified by the presence of a module declaration file that defines the contents of the enterprise module and declares the relationship dependencies of the enterprise module. For instance the module declaration file can be denoted as module.dcl. 

Conventions can be utilized for the structure of the subdirectories under the module subdirectory. One convention may be that the enterprise module s subdirectory should have the same name as the enterprise module s name. For instance the enterprise module build system may have a subdirectory build system in which the module.dcl file is located. Another convention can be that for each library and executable in the enterprise module a subdirectory is created under the enterprise module directory with the same name as that of the library or executable. For instance the library buildgen in the build system enterprise module may have its code stored under the subdirectory build system buildgen. Yet another convention can be that under each library or executable a subdirectory is created for each platform that holds the code for the library. For instance the buildgen library may have code whose portability category is portable. The code for the portable platform can be stored in build system buildgen portable. Another convention involves creating package subdirectories once the correct platform subdirectory is created. The package subdirectories can follow the convention utilized by Java so that each subdirectory corresponds to a part in the package name separated by the . character.

The actual build process for an enterprise module shall now be described. A first build file generation process has two main phases. The first phase iterates through a list of subdirectory locations and recursively scans for module.dcl files. When an instance of the module.dcl file is found the location of the where the module.dcl file is found gets recorded as the location of the enterprise module described in the module.dcl file. The collection of these enterprise modules makes up all the enterprise modules that the build system knows about until the first build file generation process is run again. In the second phase each module.dcl file is serialized into memory and processed further. The dependency relationships declared in each enterprise module as well as information about the libraries and executables that will eventually be generated or built are recorded in a properties file. Further a collection of build.xml files can be generated. The build.xml files contain instructions to invoke the proper tools to generate compile and package the libraries and executables that make up an enterprise module. A module.dcl file is generated for each enterprise module in its location alongside the module.dcl file. An additional build file can be generated at a root location. The build file at the root location is the main build file that will call the individual build files. This allows a single invocation .xml build files to build all the modules detected by the build file generation process.

A second build file generation process is code generation and compilation. If the second build file generation process is invoked at the root location where the main build file is generated then the main build file simply traverses through a list of build files that make up all the enterprise modules and builds each one as the main build file goes through the list. At the end of the traverse all the enterprise modules known to the build system are built. If the second build file generation process is invoked at one of the enterprise module s locations then that particular enterprise module and all of its dependencies are built. For example if an enterprise module has a dependency on the infrastructure enterprise module for example then building the enterprise module will also build the infrastructure enterprise module. Therefore a developer does not need to be concerned about the sequence of the build in that a prerequisite library may not have been built yet. As each enterprise module is built all of its dependencies are built. This is based on the assumption that the enterprise module is properly declared in the module.dcl file.

The code generation will invoke a code generator to generate the source files implementing the declared items for the enterprise module. The platform that is utilized for generating the source code is determined by how the declared item is declared in the module.dcl file.

The compilation involves feeding source code through the appropriate compiler to emit binary components. The binary components can take the form of a library or an executable. The form of the binary component is declared in the module.dcl file. For example a JAR file can be built for a Java platform while an EXE or DLL file can be built for a .Net platform.

The enterprise modules are designed so that there is the ability to support continuous change in the business logic enterprise topology or underlying technology. Accordingly customers can avoid the painful downtime that is often seen when enterprise applications undergo a modification or update. In addition dependency relationships are updated if there is a modification or update.

The term deployment is intended to mean the support provided for a comprehensive enterprise application lifecycle. The support is provided for stages for requirements gathering feature tracking development testing staging and production. Further the support is also provided for multiple degrees of coupling and sovereignty including informal linkages between environments partitioned groups of users in a single environment and a flexible versioning system which reduces the effort and impact of change. A specific usage pattern for the deployment technologies shall be referred to as a deployment methodology.

The enterprise module development environment includes resources . Further the resources include an application server a repository a directory and a database . In one embodiment a Software Configuration Management SCM system can also be provided. The application server hosts the code that is being developed for the enterprise module. Further the repository includes a metadata representation of the user interface business logic services functionality and behavior of one or more enterprise applications. In addition the directory can hold files for the code. Further the database can hold additional data. A developer can utilize the enterprise module development environment to develop code. Further the enterprise module development environment can share the resources with the enterprise module testing environment and the enterprise module production environment . For instance as illustrated in the enterprise module development environment shares the resources with the repository in the enterprise module testing environment . Further as illustrated in the enterprise module development environment shares the resources with the database in the enterprise module production environment in the enterprise module production environment .

The enterprise module testing environment includes resources . Further the resources include an application server a repository a directory and a database . In one embodiment an SCM system can also be provided. The application server hosts the code that is being developed for the enterprise module. Further the repository includes a metadata representation of the user interface business logic services functionality and behavior of one or more enterprise applications. In addition the directory can hold files for the code. Further the database can hold additional data. A developer can utilize the enterprise module testing environment to test the code that was developed in the enterprise module development environment. Further the enterprise module testing environment can share the resources with the enterprise module development environment and the enterprise module production environment . In addition the enterprise module testing environment may utilize resources from another environment. For instance as illustrated in the enterprise module testing environment shares the resources with the directory in the enterprise module production environment .

The enterprise module production environment includes resources . Further the resources include an application server a repository a directory and a database . In one embodiment an SCM system can also be provided. The application server hosts the code that is being developed for the enterprise module. Further the repository includes a metadata representation of the user interface business logic services functionality and behavior of one or more enterprise applications. In addition the directory can hold files for the code. Further the database can hold additional data. A developer can utilize the enterprise module production environment to produce the code that was developed in the enterprise module development environment and tested in the enterprise module testing environment . Further the enterprise module production environment may utilize resources from another environment.

Accordingly a system is provided that includes a plurality of environments. A change to one of the environments is migrated to the other environments through an automated deployment process without user interaction to reduce the likelihood of creating a problem as a result of the migration. In other words a modification to a piece of code in one environment may require multiple changes to code in a different environment. For example a single logical change may encompass changes to the user interface compiled code metadata database schemas third party applications runtime parameters seed data operating system settings application data user and group definitions in a directory message queue names cryptographic key stores business processes office documents image files etc. The automated deployment process helps ensure that all of the necessary changes are made in the environment to which code is migrated because forgetting a change or making changes in the wrong order can result in a non functional environment. In another embodiment the deployment process can be implemented through user interaction without an automated process. In yet another embodiment the deployment process can be implemented through a combination of an automated process and user interaction.

The automated deployment process can be implemented through an installer packager deployer and artifacts. The installer is an executable responsible for offloading files which make up the enterprise modules and for configuring the packager and deployer applications to the point where the first business application could be deployed to an applications server. Further the packager is an executable responsible for understanding the configuration of a workspace and creating releases based on that workspace. For example the packager could be pointed at directories containing repository and code artifacts as input and generate environment agnostic packaged applications releases ready for the deployer. In other words the packager can configure code for the different enterprise modules that will be part of a release. For example in J2EE earfiles would be generated. As a further example in .NET vdirs would be generated. In addition the packager can create related non application server items like database schemas system parameters or directory entries for both J2EE and .Net. In addition the deployer is an executable responsible for customizing sequencing and executing the deployment of a release into an environment. The deployer is responsible for creating a working application. Finally the deployment automated process includes packaging artifacts which are the output of the packager after the packager has herded all of the raw files and other source data into the correct locations. Once created the packaging artifacts are modified by the deployer for the target environment and then deployed in the proper sequence.

The packager essentially creates a set of standard configuration information for the release i.e. for the enterprise modules to be deployed. For instance the packager can create standardized deployment descriptors for an enterprise module to run on J2EE or web.config and Metabase vdir settings for an enterprise module to run on .Net. However the package will not likely be deployable to a target environment because the package has not been customized for the target environment. For instance the package lacks needed information such as which database pool to utilize what URLs the web services should live on which application server particular deployment descriptors and settings should be applied to etc. The deployer fills in this information.

Further the packager can handle more constructs than application packages. For instance the packaging may consist of metadata needed by a specific deployment function.

In addition the packager can create a preliminary dependency set which includes dependencies that the repository knows about. The deployer can thereafter generate a final dependency set by merging the packager generated dependencies with the deployer s knowledge of the target environment. The final dependency set can be utilized to determine the ordering of operations in a deployment script. For instance a final dependency set may include a Service A depending on a Service B which depends on a Service C. Accordingly the deployment order may be Service C Service B and Service A to ensure that Service C is present for Service B and Service A and that Service B is present for Service A.

The deployer may operate in two stages. In a first stage the packages are customized for the target environment deployment dependencies are calculated and a deployment script is generated. The deployment script contains the sequence of operations which will be performed in a second stage . The deployer can copy everything from the packaging directory into a deployment directory so that the packaging directory can be reused for another deployment without re running the packager.

In another embodiment the deployer can be run in single stage mode. This allows the opportunity to manually tweak both the customized packages and the deployment ordering.

As an example a package may contain a schema for a database table. For instance in the first stage the deployer modifies the schema to add information indicating that the target environment is an Oracle environment the owner of the database table is Scooby Oracle specific indexes need to be created and optimized sql needs to be generated. In the second stage the deployer connects to the database and reads the existing schema to determine if the table already exists and if so whether the existing schema is the correct schema. If the table needs to be created or updated the deployer attempts to perform the modification while connected to the database and then verifies that the table now has the correct schema.

In one embodiment the deployer matches artifacts with resources. Further the deployer can match artifact resource combinations to deployment functions. Further for inter environment deployments the artifacts can also be processed by mapping functions. These mapping functions can also be utilized for straight deployments.

Many changes may be necessary to update an application to a new release. The packager and deployer collaborate to determine the ordering of changes. The ordering is determined so as to avoid or minimize application interruptions. In order to achieve this the packager and deployer need to know about the types of changes which are possible and the effects of those changes on applications as well as the dependencies among application components and the usage of underlying framework libraries.

A change set is the complete set of changes needed to move to a new state. The change set is encapsulated by a deployment script which can be autogenerated by the packager and the deployer. In one embodiment the deployment script is customized by the user. An individual change will be referred to as a breaking change or a non breaking change. Further each individual change can be referred to as a replacing change or a non replacing change. These characteristics can be applied to changes to interfaces behavior metadata code patches etc. The deployer is aware of and provides support for the desired characteristics of each change in a change set.

A breaking change is a change that leads to an after state that is mutually exclusive with the before state. Accordingly a transitional state cannot occur. For example if a change set includes a database schema change introducing a new required field with no default and a new service version which knows about the required field then the old service cannot continue operations while the change set is being deployed i.e. once the database change has been made .

A non breaking change is a change where the before and after states are not mutually exclusive. Accordingly a transitional state can occur. For example a new optional field can be added to a table definition in a database schema without breaking anything above it.

A replacing change is a change that adds new material and renders the old material obsolete. For a non breaking replacing change the old material can exist while the new material is being deployed. The old material is removed as soon as possible after the new material has successfully deployed. For a breaking replacing change the old material must be removed before the new material can be deployed.

Further a non replacing change is a change in which the new material and old material may peacefully co exist indefinitely. The new material either augments or deprecates the old material. Deploying a non replacing change indicates a preference but not a requirement that the new material is utilized instead of the old material. There are no breaking non replacing changes since it is not possible to have both versions simultaneously for a breaking change.

Interface changes are any changes which affect WSDL PortType elements including changes to the names or signatures of operations and also changes to the schemas of input output and fault messages.

Non breaking changes to interfaces are defined as any changes which can be made without causing clients built on previous versions of the WSDL to break. More specifically any message instance valid per the old schema must also be valid in the new schema. Interface non breaking changes can be replacing changes.

All other interface changes are breaking changes. Further breaking changes to an interface can be disallowed. A requirement may exist for a new service to be created for the new interface instead and the semantics of the deployment of the new service will be impacted by whether the implementation differences are breaking or non breaking.

In addition breaking changes to a service s implementation are defined as those which render the effects of a message received by the old implementation incompatible with those of the new implementation. For example if data persisted by the new implementation were unusable by the old implementation or vice versa.

Further non breaking changes are all other changes to an implementation and may be replacing or non replacing. Most configuration metadata changes should be non breaking replacing changes.

Internal API changes in general should not be visible to customers. One situation where internal API changes may be visible to customers is breaking changes especially in J2EE which lacks features like NET s Strong Name support where the packaging options available may be influenced by system library version dependencies. For example if service X and service Y are released far apart in time they may use underlying libraries which are incompatible. Both services may be used in an environment but if the differing libraries are shared the services may not be grouped into a single J2EE application.

In one embodiment the enterprise modules can be deployed as a group of modules. Further the dependency relationships of each of the modules in the group are also deployed.

In general routines executed to implement the embodiments can be implemented as part of an operating system or a specific application component program object module or sequence of instructions referred to as computer programs. The computer programs typically comprise one or more instructions set at various times in various memory and storage devices in a computer and that when read and executed by one or more processors in a computer cause the computer to perform operations to execute elements involving the various aspects.

While some embodiments have been described in the context of fully functioning computers and computer systems those skilled in the art will appreciate that various embodiments are capable of being distributed as a program product in a variety of forms and are capable of being applied regardless of the particular type of machine or computer readable media used to actually effect the distribution.

Examples of computer readable media include but are not limited to recordable and non recordable type media such as volatile and non volatile memory devices read only memory ROM random access memory RAM flash memory devices floppy and other removable disks magnetic disk storage media optical storage media e.g. Compact Disk Read Only Memory CD ROMS Digital Versatile Disks DVDs etc. among others. The instructions can be embodied in digital and analog communication links for electrical optical acoustical or other forms of propagated signals such as carrier waves infrared signals digital signals etc.

A machine readable medium can be used to store software and data which when executed by a data processing system causes the system to perform various methods. The executable software and data can be stored in various places including for example ROM volatile RAM non volatile memory and or cache. Portions of this software and or data can be stored in any one of these storage devices.

In general a machine readable medium includes any mechanism that provides i.e. stores and or transmits information in a form accessible by a machine e.g. a computer network device personal digital assistant manufacturing tool any device with a set of one or more processors etc. .

Some aspects can be embodied at least in part in software. That is the techniques can be carried out in a computer system or other data processing system in response to its processor such as a microprocessor executing sequences of instructions contained in a memory such as ROM volatile RAM non volatile memory cache magnetic and optical disks or a remote storage device. Further the instructions can be downloaded into a computing device over a data network in a form of compiled and linked version.

Alternatively the logic to perform the processes as discussed above could be implemented in additional computer and or machine readable media such as discrete hardware components as large scale integrated circuits LSI s application specific integrated circuits ASIC s or firmware such as electrically erasable programmable read only memory EEPROM s .

In various embodiments hardwired circuitry can be used in combination with software instructions to implement the embodiments. Thus the techniques are not limited to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by the data processing system.

In this description various functions and operations are described as being performed by or caused by software code to simplify description. However those skilled in the art will recognize what is meant by such expressions is that the functions result from execution of the code by a processor such as a microprocessor.

Although some of the drawings illustrate a number of operations in a particular order operations which are not order dependent can be reordered and other operations can be combined or broken out. While some reordering or other groupings are specifically mentioned others will be apparent to those of ordinary skill in the art and so do not present an exhaustive list of alternatives. Moreover it should be recognized that the stages could be implemented in hardware firmware software or any combination thereof.

In the foregoing specification the disclosure has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications can be made thereto without departing from the broader spirit and scope of the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

