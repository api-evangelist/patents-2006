---

title: Processing large sized relationship-specifying markup language documents
abstract: Embodiments of the present invention address deficiencies of the art in respect to processing markup language documents and provide a method, system and computer program product for processing large relationship-specifying markup language documents. In an embodiment of the invention, a method can be provided for processing large relationship-specifying markup language documents. The method can include generating an index of nodes each node corresponding to a clause in the markup language document, processing the index in lieu of the markup language document, identifying clauses referenced within the index to be written to a database and extracting the identified clauses from the markup language document and writing the extracted clauses to the database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08131728&OS=08131728&RS=08131728
owner: International Business Machines Corporation
number: 08131728
owner_city: Armonk
owner_country: US
publication_date: 20060623
---
The present invention relates to the field of markup processing and more particularly to processing large sized relationship specifying markup language documents.

The Extensible Markup Language XML is a markup language specification widely credited with improving the functionality of the World Wide Web by allowing the identification of information in a more accurate flexible and adaptable way. XML is referred to as extensible because XML is not a fixed format like the hypertext markup language HTML which is a single predefined markup language. Rather XML is a meta language that describes other languages. As such XML allows for the design of other markup languages for limitless different types of documents. XML can act as a meta language because XML is written according to the standardized general markup language SGML the international standard meta language for text document markup.

There are several methods for processing an XML document. In one method every clause in the XML document is accounted for and a hierarchical model can be constructed reflecting the interrelationships between the clauses of the XML document. Referred to as a document object model DOM the DOM tree once in memory can be traversed at will in order to manipulate the XML document. Another method provides for the event driven serial parsing of clauses in an XML document. Referred to as SAX parsing an acronym for simple application programming interface API for XML consumes a significantly smaller memory footprint than DOM processing as an entire hierarchical model in the form of a DOM tree need not be constructed prior to processing the XML document.

XML documents have proven particularly effective in representing the state and content of an enterprise computing architecture. Specifically XML documents have been utilized to import content into and export content from a configuration management database CMDB . A CMDB is a unified or federated repository of information related to all the components of an information system. A CMDB provides a view to the information technology manager of an organization in order to understand the relationships between the components of the information system. The CMDB further facilitates the monitoring and management of the configuration of the components of the information system.

Component and relationship information imported from information technology IT management systems into a CMDB can be provided in XML documents. Examining the content of an XML document used to import information from an IT management system into a CMDB will reveal that subsets of components are linked together by relationships. Furthermore in examining all of the components linked by a set of relationships a set of data graphs can be constructed where the nodes of the graphs represent the components and the connectors represent the relationships.

One requirement of a conventional CMDB is that data graphs are to be written to the database. Data graphs generally include a single object or multiple objects. Data graphs to be loaded into the CMDB generally are loaded by an XML parsing program that processes an XML document. The XML document generally contains descriptions of the data objects to be loaded into the CMDB as well as the relationships between the data objects. In order to load the data from the XML document into the CMDB database the data graph represented in the XML document must be reconstructed in memory as objects and the relationships between the objects must be understood.

Loading the data graph reflected in the XML document has proven inefficient particularly where the XML document is very large in size as can be the case with configuration management data. As it will be understood using a DOM tree to process a very large XML document can consume an inordinate amount of memory. Likewise SAX parsing a very large XML document still requires the creation in memory of the objects reflected in the XML document and the stitching together of the relationships between the objects. Also in SAX parsing multiple passes through the large XML document can be required as there is no guaranteed order in which components and relationships will appear that are needed to construct the data graphs. Accordingly conventional techniques for bulk loading a large relationship specifying markup language document into a database have proven inadequate.

Embodiments of the present invention address deficiencies of the art in respect to processing markup language documents and provide a novel and non obvious method system and computer program product for processing large relationship specifying markup language documents. In an embodiment of the invention a method can be provided for processing large relationship specifying markup language documents. The method can include generating an index of nodes where each node corresponding to a clause in the markup language document processing the index in lieu of the markup language document identifying clauses referenced within the index to be written to a database and extracting the identified clauses from the markup language document and writing the extracted clauses to the database.

In one aspect of the embodiment generating an index of nodes can include reading small chunks of the markup language document into a rolling buffer and expression matching on the small chunks to identify individual clauses. Responsive to identifying an individual clause in the rolling buffer a node can be added to the index with both an identifier for the individual clause and a position in the markup language document of the individual clause. Additionally extracting the identified clauses from the markup language document and writing the extracted clauses to the database can include seeking to respective positions in the markup language document for different ones of the identified clauses extracting the different ones of the identified clauses from the markup language document and writing the extracted different ones of the identified clauses to the database.

In another embodiment of the invention a markup language processing data processing system can be provided. The data processing system can include a rolling buffer in memory index generation logic coupled to the rolling buffer multiple regular expressions accessible by the in memory index generation logic and a database. Notably the in memory index generation logic can include program code enabled to generate an index as a surrogate for a corresponding markup language document. As such the index can include multiple nodes each referencing a clause in the markup language document. Each of the nodes further can include a position in the markup language document for a referenced clause.

Additional aspects of the invention will be set forth in part in the description which follows and in part will be obvious from the description or may be learned by practice of the invention. The aspects of the invention will be realized and attained by means of the elements and combinations particularly pointed out in the appended claims. It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention as claimed.

Embodiments of the present invention provide a method data processing system and computer program product for the efficient processing of large relationship specifying markup language documents in uploading content to a database for instance a CMDB type database. In accordance with an embodiment of the invention small chunks of a relationship specifying markup language document can be read into a window buffer. Regular expression pattern matching can be applied to the content in the window buffer in order to identify clauses in the markup language document. For each identified clause the identity of the clause and the position of the clause within the markup language document can be stored in a node in an index for the markup language document. In this way the index can provide a lightweight representation of the clauses in the markup language document and the relationship between the clauses in the markup language document.

The index can be processed in lieu of the markup language document in order to recognize relationships between the different clauses in the markup language document. Whenever clauses are to be written to a database for instance a CMDB type database the position within the markup language document for each of the clauses can be retrieved for example a byte offset. Thereafter the clauses can be retrieved and written to the database along with the relationships between the clauses. In this way the entirety of the markup language document can be processed without first requiring the construction of a DOM tree for the document the loading of the entire document into memory or multiple scans of the document to locate related nodes. Optionally different portions of the markup language document can be processed as described herein concurrently in different threads of execution in order to more efficiently process the markup language in a single pass while consuming a minimum of memory.

In further illustration is a schematic illustration of a markup language data processing system configured to efficiently process large relationship specifying markup language documents. The data processing system can include a host computing platform coupled to a database such as a CMDB . In memory index generation logic can be coupled to the host computing platform and can be operatively connected to a rolling buffer and one or more regular expressions for pattern matching content in the rolling buffer .

The in memory index generation logic can include program code enabled to process a large markup language document such as an XML document to produce an index . The index in turn can include a plurality of nodes each node including an identifier for an object represented within the large markup language document and an offset or position into the large markup language document . The index can link different ones of the nodes according to the relationships between the objects represented by the nodes.

Notably the program code of the in memory index generation logic can be enabled to load only small chunks of the large markup language document into the rolling buffer and to apply the regular expressions to the small chunks in the rolling buffer in order to identify clauses within the large markup language document . Exemplary clauses can include component object clauses and relationship clauses such that component object clauses relate to component objects whereas relationship clauses define a relationship between component objects.

Whenever a clause can be identified through pattern matching by the regular expressions the program code of the in memory index generation logic can yet be further enabled to add the position of the identified clause and an identifier or data relating to the identified clause into a node in the index . In this way a lightweight representation of the large markup language document can be maintained without requiring the construction of a DOM tree for the large markup language document . Additionally relationships between the clauses of the large markup language document can be readily determined by reference to the index without requiring the creation in memory of the DOM tree for the large markup language document .

Notably a SAX parser can be coupled to the host computing platform . The SAX parser can be enabled to process the nodes of the index in order to determine when and how to write portions of the large markup language document to the database . Whenever it is determined to write a clause to the database the node in the index referring to the clause can be processed to determine a position within the large markup language document of the clause. Subsequently the actual clause can be retrieved from the large markup language document and written to the database . Yet the entirety of the markup language document need not be loaded in memory in order to determine the clause to be added to the database . Rather only the entirety of the index need be loaded thereby consuming a substantially smaller memory footprint.

Turning now to a flow chart is shown that illustrates the operation of the in memory index generation logic of . Beginning in block a relationship specifying markup language document can be opened for reading and in block a small chunk of the document can be read into a rolling buffer for analysis. In block expression matching can be performed on the small chunk and in decision block if a component clause is identified in consequence of the expression matching in block an identifier or other related data can be added to a node in the index along with a position of the clause within the markup language document. Otherwise in block if a relationship clause is identified in consequence of expression matching in block a pointer can be established in the index between the nodes implicated by the relationship clause.

In either case in decision block if additional chunks can be read from the markup language document the process can return through block . Otherwise the process can end in block where the index can be saved for later access. Finally referring to a flow chart is shown illustrating a process for accessing the index in lieu of the markup language document in order to recognize relationships between clauses in the markup language document and to process the markup language document for instance by bulk loading the markup language document into a database. Beginning in block the index can be loaded into memory and in block the index can be processed as a surrogate for the markup language document. In block if it is determined that a clause is to be written from the markup language document to the database in block the identifier for the clause can be obtained from the index as can an associated file position in block .

In block the obtained position can be used to seek to the file position in the markup language document. Thereafter in block the desired clause can be extracted from the markup language document in block the clause can be written to the database along with the other nodes to which it is related. In decision block if the index is not to be processed further in block the index can be closed. Otherwise the process can repeat through block until no further processing remains.

Notably the processing that takes place using the in memory index can construct objects in a data graph that must be written to the database at the same time. Consequently the bare minimum of actual component objects are actually held in memory and those component objects can be held only for a short time when preparing to write the data to the database. Additionally by building the in memory index and having the byte offset to every node in a particular data graph the data graphs can be processed separately in parallel by different threads of execution.

Embodiments of the invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode and the like. Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system.

For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution. Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

