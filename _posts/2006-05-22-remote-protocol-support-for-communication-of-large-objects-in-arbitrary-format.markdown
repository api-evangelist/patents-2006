---

title: Remote protocol support for communication of large objects in arbitrary format
abstract: A server computer provides objects such as bitmaps representing graphics image for processing by a client computer or device. The object may be of any arbitrary size or format, and is converted to a data structure that can be received by the client computer. Synchronized metadata may be included in the data structure, where such metadata data is used by an application in the client computer or device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07653749&OS=07653749&RS=07653749
owner: Microsoft Corporation
number: 07653749
owner_city: Redmond
owner_country: US
publication_date: 20060522
---
The present application claims priority under 35 U.S.C. 119 e to U.S. Provisional Application No. 60 712 993 filed Aug. 31 2005 the disclosure of which is incorporated herein.

An application program or application may create and provide a graphics image. The graphics image may be represented by a bitmap which can be passed on to other applications. Since graphics images can vary in complexity or size the bitmaps representing graphics images can also vary in complexity or size.

In a server and remote client system where a server computer supports one or more client computers a bitmap from the server computer may be broken down into smaller pieces and communicated to the client computer. The client computer may individually display or process each of the smaller bitmap pieces. In other words to display the larger graphics image each of the smaller bitmap pieces is processed. A problem for relatively large size bitmaps that are changing or updating at a high rate is a tearing effect seen at the client computer. The tearing effect takes place as the client computer displays each bitmap piece.

If the bitmap is sent at one time i.e. not broken into the smaller pieces to the client computer the client computer may decide how the bitmap may be displayed giving specific constraints e.g. high update rate seen at the client computer however if the bitmap is sent in its entirety it may have to be compressed. Compression typically is used to support relatively large size bitmaps. An application running at the server computer may compress the bitmap based on a particular compression format. The compression formats may be lossy meaning that some information or data is degraded or lost when a bitmap i.e. graphics image is compressed.

The bitmap may be communicated or transmitted to the client computer using a particular communication protocol such as Remote Desktop Protocol or RDP. Typically when a communication protocol is used the compressed bitmap is further decompressed into a standardized uncompressed format to allow a communication protocol encoder to compress the bitmap for transmission to the client computer. This may involve significant and redundant work for the server computer and result in lower compression ratios than were already present in the pre compressed bitmap i.e. further degradation of the original bitmap .

Furthermore when a communication protocol such as RDP is implemented a separate channel or virtual channel may be implemented to provide metadata information related to the bitmap or bitmaps. This separate or virtual channel typically is not synchronous with the bitmaps or graphics stream that includes the bitmaps. It is typical that the bitmaps or the graphics stream are transmitted over a channel separate from the virtual channel in which metadata is transmitted. This can be a limitation in scenarios where synchronizing the graphics stream with some metadata is desired or required. A specific example of such a limitation with RDP is the lack of information at the client side about window positions and dimensions. If the display of the graphics stream was to be directly affected by window placement it might be important for changes in window placement to be carefully synchronized with the graphics stream.

In addition the reassembly of arbitrarily large objects at the client side creates a memory management issue at the client computer. For example as bitmaps and or bitmap pieces are received by a client computer they may be placed in a buffer then reassembled and processed. However the buffer at the client computer may not be sufficiently large enough to accommodate the bitmaps and or bitmap pieces.

A method and apparatus is provided that enables a client computer or device of server client system to provide information to server computer as to the ability to receive a bitmap or other object structuring the object so it may be received by the client computer and adding client computer application metadata to the data representing the bitmap or object.

This Summary is provided to introduce a selection of concepts in a simplified form that are her described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Any metadata describing or associated with the graphics images objects and or bitmaps may be included with the graphics images objects and or bitmaps as they are communicated from server computer . This allows the metadata to be synchronized with the graphics images objects and or bitmaps. Although a server client system is described in this example it is contemplated that other implementations such as intra device systems e.g. stand alone computing devices may make use of the techniques and methods described herein.

Server computer includes a central processing unit or one or more processors as represented by processor . Processor may control or access a storage device or a memory . In this exemplary implementation server computer further includes an operating system which may reside in memory . The server computer includes one or more application programs or application s that are controlled by the processor . In particular applications include applications that generate or provide the graphics images objects and or bitmaps that are communicated to client computer .

A dynamic link library or DLL is included with server computer . In particular the DLL includes routines accessed through application program interface s that allow application s to pass the graphics images objects and or bitmaps. Examples of such routines include a DrvEscape call from a user mode e.g. application level into a display driver rdpdd.dll the display driver typically is in kernel operating system mode or level to pass an arbitrary encoded bitmap to be re encoded as a particular protocol data unit or PDU referred to in this example as a SuperBlt or super bit block which is eventually passed on or communicated to the client computer . It is expected that graphics images objects and or bitmaps that are passed through the application program interface s may be in any arbitrary format including formats that support per pixel alpha transparency information. This is an exemplary implementation in which metadata may be sent to client computer such that the metadata is synchronized with a graphics stream where the bitmaps may come through standard calls such as through a Win32 graphics stream by using known and existing BitBlt routines.

The super bit block is a single PDU that is split into multiple data blocks by lower layers in a communication protocol such as remote desktop protocol or RDP. In certain implementations super bit block is part of other protocol data units . An encoder may be implemented to compress and package the super bit block into a packet or graphics stream where the packet and or graphics stream is sent over a single channel. In particular the encoder is configured to implement a specific communication protocol such as RDP and or transmission protocols such as TCP IP. In other implementations separate components may be used to provide the functions of the encoder . In certain cases the encoder or other component at the server computer may break down any graphics images objects and or bitmaps that are too large into smaller and more manageable graphics images objects and or bitmaps. The smaller graphics images objects and or bitmaps are then reassembled at the client computer .

Client computer includes a central processing unit or one or more processors as represented by processor . Processor may control or access a storage device or a memory . In this exemplary implementation client computer further includes an operating system which may reside in memory . The client computer includes one or more application programs or application s controlled by processor . In particular application s include applications that process graphics images objects and or bitmaps received from server computer . In specific the graphics images objects and or bitmaps are received by applications through applications program interfaces s which access routines or drivers in a dynamic link library DLL . A specific application program interface may be a bit block type interface based on preexisting bit block conventions and protocols where such an interface is used to pass reassembled bitmap data i.e. graphics images objects bitmaps along with corresponding metadata to application s . The routines or drivers of dynamic link library are particularly used to pass the graphics data or information from applications to the operating system .

The client computer includes a decoder . Decoder may decompress received PDUs such as super bit blocks i.e. graphics images objects and or bitmaps which may or may not be in a data or graphics stream. Other functions of decoder may include decoding the received graphics images objects and or bitmaps based on a particular communication protocol e.g. RDP and or transmission protocol e.g. TCP IP .

In specific cases a received object such as a super bit block may be treated as a stream instead of a discrete object that is reassembled at the client computer . In an exemplary implementation the decoder may be used to keep track of decode state of a data stream or graphics stream that includes the super bit block that describes the graphics images objects and or bitmaps. By tracking the decode state of the graphics stream the graphics stream may be interrupted and client computer is made aware where to continue when interruption occurred. A specific implementation is to provide the decoder as a state machine which explicitly stores context of received data e.g. super bit blocks in the graphics stream . In another implementation the decoder runs on a separate thread to server computer such that decoder reads from the graphics stream. When the decoder needs to wait for more data e.g. super bit blocks the decoder is suspended . When suspended the state of the decoder is implicitly saved on a thread stack of the separate thread from which the decoder runs. In other words the state of the decoder is implicitly held on a stack of a decoder thread while the decoder is suspended such that the decoder knows where to continue when it becomes unblocked i.e. not suspended .

A reassembly buffer may be included in client computer . The reassembly buffer particularly stores smaller pieces of a super bit block i.e. graphics images objects and or bitmaps prior to passing an application program interface in application interface s . In particular implementations wherein the super bit block is not broken up into smaller pieces the reassembly buffer is not included in client computer . In certain implementations a separate buffer not shown may be used to temporary store super bit blocks i.e. graphics images objects and or bitmaps before further processing by the client computer .

As discussed above client computer may implement a communication protocol such as RDP and may be referred to as an RDP client As an RDP client client computer receives through an application program interface a super bit block that includes a set of protocol data units . Furthermore the super bit block that is split into multiple data blocks. The super bit block may be included with other protocol data units . The data in super bit block which includes data describing a particular graphics image object or bitmap may be used by the application s to generate or render a graphics image on a display .

The multi fragment PDU may be of any specific size however compression may be needed to support the multi fragment PDU if resources e.g. receiving buffers at the client computer are limited. In such cases the client computer may inform the server computer as to specific size limitations. As an example the multi fragment PDU may originally be 1 or 2 MB in size and the client computer may only support 64 KB. An implementation may involve breaking down the super bit block or multi fragment PDU into smaller pieces. In another implementation the entire super bit block or multi fragment PDU is sent where selective data of the super bit block or multi fragment PDU is compressed and effectively decreasing the size of the entire super bit block or multi fragment PDU .

The multi fragment PDU may include a header metadata and payload or bits . The header may include information as to the bitmap or graphics image or object such as color depth and compression type. Furthermore the header may describe the size of the succeeding metadata and the bits . In certain cases the super bit block or multi fragment PDU may be conveyed or communicated from the server computer with just metadata information i.e. payload is not sent or is empty . The metadata may include any additional information directed to the information in the payload . The information in metadata is particularly directed to be application level data used by applications s of client computer . By providing the metadata with the payload the metadata is synchronized with the payload . As an example synchronization of metadata is particularly beneficial in synchronizing audio with display actions and associating timing information to improve quality of steady frame rate video.

The multi fragment PDU may be split up into multiple fragments as represented by a first fragment next fragments and a last fragment . RDP protocol provides an update PDU mechanism. In this example the update PDU mechanism is extended to support multi fragment PDUs such as multi fragment PDU which include first fragment next fragments and last fragment . In particular a communication protocol such as RDP through lower layers of the protocol is able to split up the multi fragment PDU into multiple data blocks or fragments such as first fragment next fragments and last fragment .

The multi fragment PDU may be used to send any resource such as a bitmap. In other words multi fragment PDU is not limited to any specific object type. By providing multiple fragments and that are identified with first next and last a layer of a decoder e.g. decoder knows whether additional fragments are to be received before passing data to an upper layer of the decoder where the upper layer of the decoder has knowledge as to the actual resource or object type in the PDU or multi fragment PDU .

At block a server computer receives information as to the availability of one or more client computers devices to receive object or bitmap data that may describe or be associated with a graphics image. For example the object may be represented as a multi fragment PDU e.g. multi fragment PDU . The graphics image may be provided by an application or application program running at the server computer. In addition to the availability of the client computer or computers the server computer may receive information as to the resource capabilities of specific client computers. The resource capabilities may include buffer capacities at the client computer including receiving buffers and reassembly buffers. The information may he conveyed through a channel in which data is sent from the server computer to the client computers or a separate channel.

At block a determination is made at the server computer whether to send the object or bitmap or data e.g. multi fragment PDU that represents the object or bitmap as a whole. A factor in the determination is the resource capabilities of the client computer. Alternatively the object or bitmap data may be broken up into smaller pieces. The smaller pieces are eventually received and reassembled by the client computer. The determining or determination may be based on the resource capabilities of the client computer.

At block header and metadata information may be added with object or bitmap data. The metadata is particularly directed to be used by an application or applications resident at the client computer where such application or applications consume or process the object or bitmap data. The metadata may further describe or provide additional information as to the object or bitmap data. The object may be represented by the multi fragment PDU which may include multiple fragments as described in above. In particular the multiple fragments may be sequenced and include an identifier with each fragment as to where in the sequence a particular fragment is located e.g. first next and last .

At block the header metadata and object or bitmap data may be structured into a particular data format such as the multi fragment PDU described in and sent to client computers. The header metadata and object or bitmap data i.e. multi fragment PDU or super bit block may be further compressed and encoded based on a particular communication protocol such as RDP and or a particular transmission protocol such as TCP IP. Discrete multi fragment PDUs or super bit blocks may be included in or be part of a data stream that is communicated intra device i.e. within the same machine such that there is a producer i.e. application of the data stream and a consumer i.e. application of the data stream.

At block a client computer receives objects such as super bit blocks in a graphics or data stream. The data stream may originate from a server computer and be transmitted over one or more networks as described by the exemplary system as shown . The data stream may be sent through a particular thread or channel.

A decoder or similar component at the client computer may receive and process the objects in the data stream. If the decoder does not receive the data stream in a separate thread from the thread in which the data stream is communicated or sent i.e. following the NO branch of block for a particular implementation at block the decoder may track the decode state of the data stream and particularly the decode state of objects in the data stream.

At block the decoder acting as a state machine may store context or decode state of received objects in the data stream. At block if the data stream is interrupted i.e. decoder stops receiving the data stream then decoding may continue based on the decode state of the received objects.

If the decoder runs on a separate thread from which the data stream is received i.e. following the YES branch of block in another implementation at block the decoder reads from the data steam on the separate thread.

At block if more or additional data objects in the data stream are needed by the decoder the decoder is suspended. At block the state of the decoder is saved. In particular if the decoder runs on a separate thread the thread stack of the separate thread implicitly saves the state of the decoder when the decoder is suspended. At block decoding may continue based on the state of the decoder e.g. state on thread stack when interruption occurred.

The above described methods and devices describe communicating arbitrary sized objects such as bitmaps of a graphics image to a client device for processing. Although the invention has been described in language specific to structural features and or methodological acts it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claimed invention.

