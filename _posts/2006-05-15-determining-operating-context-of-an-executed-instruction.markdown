---

title: Determining operating context of an executed instruction
abstract: Determining operating context of an executed instruction. At least some of the illustrative embodiments are a computer-readable medium storing a debug-trace program that, when executed by a processor, causes the processor to display trace data on a display device (the trace data comprising a plurality of addresses of instructions executed by a target processor), enable a user of the debug-trace program to select an address of the plurality of addresses to create a selected address, and display data based on an operating context proximate in time to when the instruction of the selected address was executed on the target processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07987393&OS=07987393&RS=07987393
owner: Texas Instruments Incorporated
number: 07987393
owner_city: Dallas
owner_country: US
publication_date: 20060515
---
This application claims the benefit of Provisional Application Ser. No. 60 681 427 filed May 16 2005 titled Debugging Software Controlled Cache Coherence and Provisional Application Ser. No. 60 681 561 filed May 16 2005 entitled Debugging Application with Overlays Run Time Relocatable Code and Multi Task both of which are incorporated by reference herein as if reproduced in full below.

In order to look for errors in software programs an activity referred to as debugging some software development tools provide the ability to record the sequence of operations that a processor performed while executing a program. This is referred to as tracing the execution of the program and the information that is captured is referred to as trace data The trace data may comprise data such as the addresses of operational codes opcodes executed by the processor and values of various processor registers at each executed instruction.

Some software programs operate in multi tasking systems. That is the processor of the system may execute multiple tasks in a time slice fashion each task appearing to the computer system user to be simultaneously executing. However when debugging software programs executed in a multi tasking system it is difficult to determine the operating context of a particular task even when one has trace data for the task. For example looking at the trace data alone it is difficult to determine which channel of a multi channel system to which the particular code section applies the event log entries written contemporaneous with execution of the particular code section the overall processor utilization in the time frame contemporaneous with the particular code section and the power usage by the processor contemporaneous with the particular code section to name a few.

The problems noted above are solved in large part by method of determining operating context of an executed instruction. At least some of the illustrative embodiments are a computer readable medium storing a debug trace program that when executed by a processor causes the processor to display trace data on a display device the trace data comprising a plurality of addresses of instructions executed by a target processor enable a user of the debug trace program to select an address of the plurality of addresses to create a selected address and display data based on an operating context proximate in time to when the instruction of the selected address was executed on the target processor.

Other illustrative embodiments are a computer readable medium storing an operating system program that when executed by a processor causes the processor to write an entry to a log buffer each time a task switching portion of the operating system program makes a task switch to a first task the entry comprising operating context data and write a value indicative of the entry of the log buffer to a predetermined memory location which value becomes a part of trace data associated with the first task and wherein the trace data gathered by a trace system associated with the processor .

Yet still other embodiments are a computer readable medium storing an operating system program that when executed by a processor causes the processor to write a value to a predetermined memory location each time an application programming interface API portion of the operating system dealing with semaphores is called the value indicative of the state of a semaphore . The predetermined memory location becomes a part of trace data associated with a task executed on the processor that called the API portion of the operating system.

Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function.

In the following discussion and in the claims the terms including and comprising are used in an open ended fashion and thus should be interpreted to mean including but not limited to . . . . Also the term couple or couples is intended to mean either an indirect or direct electrical connection. Thus if a first device couples to a second device that connection may be through a direct connection or through an indirect connection via other devices and connections.

 Operating context of a particular instruction shall mean an indication of one or more selected from the group comprising the real time or substantially real time task to which the instruction belongs the channel of a multi channel system to which the instruction belongs the processor or thread to which the instruction belongs the processor utilization proximate in time to execution of the instruction which dynamically loaded library DLL programs are loaded in memory allocation and de allocation of heap memory proximate in time to execution of the instruction memory defragmentation events proximate in time to executing the instruction direct memory access DMA events proximate in time to execution of the instruction interrupts received by the processor proximate in time to execution of the instruction the powered state of various systems on the integrated circuit with the processor proximate to execution of the instruction the state of power usage and or battery state proximate to execution of the instruction the current security level of the processor e.g. supervisory secure kernel unsecure user transitions between secure and unsecure modes proximate in time to execution of the instruction exceptions regarding accesses to protected memory asserted proximate in time to execution of the instruction the state of inter process synchronization variables e.g. semaphores locks pipes and queues proximate in time to execution of the instruction the state of inter process communication proximate in time to execution of the instruction exceptions task overruns watchdog timer timeouts and unexpected or invalid inputs proximate in time to execution of the instruction.

The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred the embodiments disclosed should not be interpreted or otherwise used as limiting the scope of the disclosure including the claims. In addition one skilled in the art will understand that the following description has broad application and the discussion of any embodiment is meant only to be exemplary of that embodiment and not intended to intimate that the scope of the disclosure including the claims is limited to that embodiment.

The host computer and target system couple by way of one or more interconnects such as cables. In some embodiments the host computer couples to target system by way of a multi pin cable such as a Mictor cable available from Tektronix Texas LLC of Richardson Tex. The multi pin cable enables transfer of trace data files from the target system to the host computer . In other embodiments the host computer also couples to the target system by way of a serial cable across which the host computer communicates with the joint test action group JTAG communication system or other currently existing or after developed serial communication system. In order to reduce the number of cables required to couple the host computer with the target system the multi pin cable may have two or more pins dedicated to serial communication and thus the host computer and target system may communicate using multiple protocols yet over the same multi pin cable . Other embodiments comprise sending data over optical interconnect to the host computer or logging the captured trace data in memory or disk that is accessible by the target processor where it can be accessed by an embedded software debugger. In yet still other embodiments the trace data may be captured on the target system and transferred to the host computer by any of a variety of now existing or after developed transport protocols which allow the host computer to interact over a distance such that the host computer and target system need not be co located e.g. Ethernet transmission control protocol internet protocol TCP IP institute of electrical and electronic engineers IEEE 1391 protocol RS 232 and peripheral components interconnect PCI .

Still referring to in some embodiments the integrated circuit SOC may further comprise an event trigger system . The event trigger system couples to the data flattener and receives a least a portion of the serialized data. In response to various pre programmed triggers where such triggers may be communicated to the event trigger system by way of JTAG based communications through the debug port the event trigger system asserts a trigger signal to the trace system . In response the trace system accumulates trace data in its FIFO buffer and sends the trace data to the debug trace program.

Referring simultaneously to a user of the host computer system wishing to debug a software program executable on the target system enables the event trigger system possibly by JTAG based communication over the serial cable . Thereafter the user initiates the target program on the target system . The processor executes the target program while the data flattener gathers pertinent information serializes the information and forwards it both the event trigger system and the trace system . At points in time before the trace system is enabled by the event trigger system the data supplied to the trace system by the flattener may be ignored discarded or collected such that the trace data comprises events just prior to the trigger. At a point in execution of the target or traced program the trigger events occur and the trigger events are identified by the event trigger system . The event trigger system asserts the trigger signal to the trace system .

In response to assertion of the trigger signal the trace system collects the trace data in the FIFO buffer possibly together with events that occur prior to the trigger . Simultaneously with collecting the trace system sends the trace data to the to the debug trace program . In some embodiments the trace system sends the trace data over the relatively high bandwidth multi pin cable . Other embodiments comprise sending trace data over an optical interconnect to the host computer over a local area network LAN or the internet or the logging the captured trace data in memory or to a disk that is accessible by the target processor e.g. an embedded debugging program .

The debug trace program creates a trace data screen such as trace data screen illustrated in . However it is difficult to determine the operating context of a particular task even when one has trace data screen . For example looking at the addresses of the executed instructions column and disassembly information such as opcodes alone it is difficult to determine which channel of a multi channel system to which the code section shown on the trace data screen applies the event log entries written contemporaneous with execution of the particular code section the overall processor utilization in the time frame contemporaneous with the particular code section the power usage by the processor contemporaneous with the particular code section whether a particular task was still operational when its time slice expired task overrun to name a few.

In order to assist the user of the debug trace program in determining operating context in some embodiments of the invention the trace system is configured to insert into the trace data values indicative of the operating context in which the processor of the target system is operating. The debug trace program executing on the host computer or as an embedded debugger extracts the values indicative of the operating context. Still referring to the trace system obtains the values indicative of the operating context from a target state register TSR . In some embodiments the target state register is a hardware register located within the processor such as target state register . Although the hardware register version of the target state register is shown to couple to the trace system by way of a dashed line it will be understood that the value of the target state register may in actuality be supplied to the trace system after passing through the data flattener . A hardware register in the processor may be equivalently referred to as an opcode addressable register. In alternative embodiments the target state register may be a register outside the processor. For example and referring briefly to the SOC may couple to a memory subsystem which implements the target state register . In these alternative embodiments the target state register may be readable by a memory operation to an assigned address and thus target state register may be referred to as a memory addressable register. In yet still other embodiments the memory subsystem may be integrated with other devices of the SOC .

The trace system is configured to send the value in the target state register to the host computer when the value in the target state register or a portion thereof is newly written. Once the target state register has been newly written the target state register becomes the highest priority data item for the trace system in some cases preempting other data until the target state register has been read by the trace system . The trace system is configured to monitor the value in the target state register and send the value to the host computer system in a message wrapping protocol that identifies to the host computer that the information is the value of the target state register . The values in the target state register are sent across the high bandwidth cable along with other trace data e.g. direct memory access DMA trace data cache memory trace data addresses of opcodes executed by the processor the program counter values the value of hardware registers in the processor and interrupts received by the processor . In some embodiments the operating context is written directly to the target state register . For example inter process synchronization variables such as semaphores may be read and placed in the target state register . In embodiments where the various desired points of the operating context are too numerous too large or do not lend themselves well to being written to the limited space of the target state register in some embodiments 30 bits alternative methods are used.

In alternative embodiments the operating system writes operating context to an event or log buffer. A log buffer may be equivalently referred to as a data table data array and or data structure. In some embodiments data from the log buffer is read out by the host computer after execution of the target or traced program has stopped. In situations where the log buffer does not contain a sufficient number of storage locations to store all the log data written during a trace period e.g. log buffer has too few locations or the log buffer is circular and the number of entries expected will overwrite earlier entries during the trace period the log buffer may be read and cleared by the debug trace program one or more times during the trace period to ensure all the entries generated are available to the debug trace program. In some embodiments the trace system in addition to the FIFO buffer implements a series of memory locations to be the log buffer. In alternative embodiments the log buffer is located in RAM either on the SOC or in the memory subsystem or in main memory. Regardless of the precise location of the log buffer the host computer has access to the log buffer and can read data from the log buffer as described above.

The logical construction of the log buffer may take many forms. In some embodiments the log buffer is implemented as a plurality of equivalently sized data fields. In alternative embodiments the log buffer is implemented as a plurality of arbitrary sized data fields. In yet still other embodiments the log buffer is a table having a plurality of rows and columns. Regardless of the logical construction of the log buffer in accordance with embodiments of the invention at least some entries in the log buffer comprise an indication of the operating context proximate in time to writing of the entry and an index value. The index value is an index into the log buffer that identifies a particular entry in the log buffer. The index value could be for example a pointer packet number sequence number row number or any other value indicative of the location of the entry. In some embodiments the index value is an inherent part of the entry and in other embodiments the index value is generated and written by the operating system.

In addition to writing the indication of the operating context and possibly the index value in the log buffer the operating system in accordance with embodiments of the invention also places the index value in the target state register . Writing the index value into the target state register contemporaneously with writing the log buffer ensures that the index value is present in the trace data associated with the traced program. The debug trace program reads the index value from the trace data indexes into the log buffer data based on the index value and thus obtains the indication of the operating context. The debug trace program then associates the indicated operating context with subsequent trace data up to the next target state register value or index value that is stored in the trace stream. In alternative embodiments the debug trace program associates the indicated operating system context with preceding trace data up to the previous target state register value or index value that is stored in the trace stream. The process of associating operating context with trace data is repeated for each index value stored in the trace stream. Attention now turns to how the debug trace program uses the information regarding the operating system context.

Referring again to illustrates addresses of executed instructions along with the opcodes of each instruction and other information. The opcodes pertaining to each instruction may be determined by the debug trace program by correlating the addresses from the trace data to object files of the traced program. In accordance with embodiments of the invention the debug trace program enables a user viewing the trace data screen to select a particular instruction or group of instructions and based on the one or more selected instructions the debug trace program displays operating context proximate in time to when the selected instruction was executed. For example a user may select the instruction having address 00008CCC to further investigate the operating context of the instruction.

In order to implement the embodiments discussed with respect to the operating system of the target system and in particular the task manager or task switcher of the operating system is configured to write an indication of the operating context to the trace data stream each time a new task is instantiated or re instantiated if previously preempted on the processor . For example each time the task switcher instantiates the instructions associated with the task one channel one encoder the task switcher writes an indication of the identity of the instructions to the trace data stream. As discussed above writing the indication of the identity could be writing the identity of the instructions directly to the target state register . In alternative embodiments the task switcher writes the information to a log buffer and writes an index value of the location in the log buffer to the target state register . Using the particular information written by the task switcher as well as similar information for other task channels applications executed contemporaneously with the selected instruction the debug trace program builds and displays the tree structure and highlights the particular portion to which the selected instruction belongs . In alternative embodiments the writing of the indication of the identity is initiated by the traced program calling an operating system function for example an event logging function instead of or in addition to the operating system task switcher writing the indication of the identity.

In addition to or in place of the tree structure of display other embodiments may also produce an indication of processor utilization proximate in time with execution of the selected instruction. In particular shows an illustrative processor utilization display . In accordance with these embodiments when a user selects a particular instruction from a trace data screen the debug trace program generates and displays a processor utilization display similar to display with the utilization of the processor proximate in time to execution of the selected instruction indicated such as by vertical line .

In order to implement the embodiments discussed with respect to the operating system of the target system is configured to periodically write an indication of the processor utilization e.g. number of cycles spent in the idle process to the trace data stream. The nature of the writing could take many forms. In some embodiments the processor is periodically interrupted and an interrupt service routine reads the data indicative of processor utilization and places the data in the trace stream. In alternative embodiments the task switcher of the operating system writes the data indicative of the processor utilization each time a task is instantiated or re instantiated on the processor. As discussed above in some embodiments writing the indication of processor utilization to the trace data stream involves writing the indication directly to the target state register . In alternative embodiments the data indicative of processor utilization is written to a log buffer and the index value of the location in the log buffer is written to the target state register . Using the data indicative of processor utilization written proximate in time to execution of the selected instruction as well as similar information written contemporaneously with the selected instruction the debug trace program builds and displays the processor utilization display and highlights the processor utilization proximate in time to execution of the selected instruction .

In addition to or in place of the tree structure of display and the processor utilization display other embodiments may also produce an indication of processor power consumption proximate in time with execution of the selected instruction. In particular shows an illustrative processor power consumption display . In accordance with these embodiments when a user selects a particular instruction from a trace data screen the debug trace program generates and displays a processor power utilization display similar to display with the utilization of the processor proximate in time to execution of the selected instruction indicated such as by vertical line .

In order to implement the embodiments discussed with respect to the operating system of the target system is configured to periodically sample hardware dedicated to measuring current draw for the processor by way of its power pins for example. The data collected by the operating system thus provides a record in time of the current drawn by the processor as it executes. The power draw values can then optionally be converted into percentages of a maximum rated power consumption figure. The operating system then writes an indication of the processor power consumption to the trace data stream. The nature of the writing could take many forms. In some embodiments the processor is periodically interrupted and an interrupt service routine reads the data indicative of processor power consumption and places the data in the trace stream. In alternative embodiments the task switcher of the operating system writes the data indicative of the processor power consumption each time a task is instantiate or re instantiated on the processor. In yet other alternative embodiments the traced program reads the data indicative of processor power consumption and calls an operating system function to place the data in the trace stream. As discussed above in some embodiments writing the indication of processor power consumption to the trace data stream involves writing the indication directly to the target state register . In alternative embodiments the data indicative of processor power consumption is written to a log buffer and the index value of the location in the log buffer is written to the target state register . Using the data indicative of processor power consumption written proximate in time to execution of the selected instruction as well as similar information written contemporaneously with the selected instruction the debug trace program builds and displays the processor power consumption display and highlights the processor power consumption proximate in time to execution of the selected instruction .

In addition to or in place of the tree structure of display the processor utilization display and the processor power consumption display other embodiments may also produce a display that shows the state of inter process communication proximate in time execution of the selected instruction. In particular shows an illustrative display of messages passed between processors. In these embodiments when a user selects a particular instruction from a trace data screen the debug trace program generates and displays an indication of the state of inter process communications such as display . The illustrative messages could be the messages passed by pipes queues shared memory buffers serial communication links and the like. The message or messages written proximate in time to execution of the selected instruction may be indicated such as by highlighting some or all the message such as illustrative message . Inasmuch as the messages illustrated in may be written to a log buffer is thus also illustrative of showing log buffer entries made proximate in time to execution of the selected instruction.

In order to implement the embodiments discussed with respect to the operating system of the target system is configured to write an index value to the target state register each time a new log entry is written. Using the index value for log entries written proximate in time to execution of the particular instruction the debug trace program builds and displays log information and highlights the particular message s proximate in time to execution of the selected instruction . In some alternative embodiments the operating system of the target system is configured to write an index value of a message queue or some other message passing data structure to the target state register each time a new message entry is written. In these embodiments the debug trace program reads the messages directly from the message queue or message passing data structure.

In addition to or in place of the tree structure of display the processor utilization display the processor power consumption display and the inter process communication display other embodiments may also produce a display that shows the state of preemption in the processor and or the state of semaphore flags. In the case of preemption a first lower priority task is halted in favor of a higher priority task e.g. needs to be activated . A semaphore flag is a flag used for activities such as synchronizing tasks and or for a boolean form of inter process communication. Referring again to the display of in addition to showing trace data such as addresses of executed instructions and disassembly information also illustrates showing the state of preemption in the processor and the state of a semaphore flag. In particular column shows an alternative form of an indication of to which task each exemplary instruction belongs by the solid dark line e.g. line . also shows when preemption has taken place by having the column associated with the task changing from solid to crosshatch. For example task is the active task associated with instructions through . At instruction task is preempted by task . The activation of task is illustrated by the solid line and the preemption of task is shown by crosshatch . Thus illustrates the preemptive state of task . Column of alternatively illustrates the situation of a task failing to complete during its allotted time slice. That is if task was assigned a particular time slice in which to complete a task and yet task was still executing at the end of the time slice and was stopped in favor of task for the next time slice the crosshatch shading may show that the task failed to finish its desired work and thus the programmer may need to further debug and or optimize task to ensure the task completes in its time slice.

In order to implement the embodiments discussed with respect to task preemption and or a task failing to complete during its allotted time and with respect to the operating system of the target system and in particular the task manager or task switcher of the operating system is configured to write an indication of the operating context to the trace data stream each time the a new task is instantiated on the processor . Further if the task switcher preempts another task for a higher priority task or if the task switcher preempts a task that should have completed during the time slice the task switcher is configured to write an indication of such to the trace data stream. As discussed above writing the indication could be writing the indications directly to the target state register . In alternative embodiments the task switcher writes the information to a log buffer and writes an index value of the location in the log buffer to the target state register . Using the particular information written by the task switcher the debug trace program builds and displays the column in the display .

Still referring to column illustrates indicating the state of a semaphore flag. In particular the semaphore flag illustrated by column is pending until instruction . At instruction the state of the semaphore flag changes as illustrated by the solid line changing to an outlined line . In the particular illustration of the the change of state of the semaphore flag may trigger the preemption of task by task but this is merely illustrative. Any action waiting or synchronizing with respect to the semaphore flag may trigger based on the change of state.

In order to implement the embodiments discussed with respect to displaying the state of a semaphore flag and with respect to the operating system of the target system and in particular the application programming interfaces that enable assertion and de assertion of the semaphore flags are configured to write an indication of the state of the semaphore flag s to the trace data stream each time there is a change of state. As discussed above writing the state of the semaphore flag s could be writing the states directly to the target state register . In alternative embodiments the application programming interfaces for controlling the semaphore flags write the states to a log buffer and write an index value of the location in the log buffer to the target state register . Using the particular information written by the task switcher the debug trace program builds and displays the column in the display .

From the description provided herein those skilled in the art are readily able to combine software created as described from the methods with appropriate general purpose or special purpose computer hardware to create a computer system and or computer subcomponents embodying the invention to create a computer system and or computer subcomponents for carrying out the method of the invention and or to create a computer readable medium for storing a software program to implement the method aspects of the invention. The computer readable medium could be for example a volatile memory a non volatile memory a compact disc read only memory CDROM an electrically erasable programmable read only memory EEPROM a hard drive and the like.

The above discussion is meant to be illustrative of the principles and various embodiments of the present invention. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

