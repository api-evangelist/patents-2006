---

title: File folding technique
abstract: A method for reducing duplicate data of an active file system, where the data is stored on a storage device of a storage system, is disclosed. A persistent image of the active file system is generated at a first point in time. At a later time, a sequence of steps to compare the active file system with the persistent image is initiated. Then, if a block of data of the active file system is identical to the data in the persistent image, the active file system is directed to refer to the persistent image for data of the file. Alternatively, if the block of data of the active file system is not identical to the data in the persistent image, the active file system is directed to refer to the data of the active file system. A file folding command may be issued to start the comparison.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07444361&OS=07444361&RS=07444361
owner: Network Appliance, Inc.
number: 07444361
owner_city: Sunnyvale
owner_country: US
publication_date: 20060328
---
This application is a continuation of U.S. Ser. No. 10 104 694 filed on Mar. 22 2002 entitled FILE FOLDING TECHNIQUE now issued as U.S. Pat. No. 7 072 910 on Jul. 04 2006.

The present invention relates to file systems and more specifically to a technique for efficiently reducing disk space consumption of a file server configured to generate persistent images of its active file system.

A file server is a computer that provides file service relating to the organization of information on writeable persistent storage devices such as memories tapes or disks. The file server or filer may be embodied as a storage system including a storage operating system that implements a file system to logically organize the information as a hierarchical structure of directories and files on e.g. the disks. Each on disk file may be implemented as set of data structures e.g. disk blocks configured to store information such as the actual data for the file. A directory on the other hand may be implemented as a specially formatted file in which information about other files and directories are stored.

A filer may be further configured to operate according to a client server model of information delivery to thereby allow many clients to access files stored on a server e.g. the filer. In this model the client may comprise an application executing on a computer that connects to the filer over a computer network such as a point to point link shared local area network wide area network or virtual private network implemented over a public network such as the Internet. Each client may request the services of the file system on the filer by issuing file system protocol messages in the form of packets to the filer over the network.

A common type of file system is a write in place file system wherein the locations of the data structures such as inodes and data blocks on disk are typically fixed. An inode is a data structure used to store information such as meta data about a file whereas the data blocks are structures used to store the actual data for the file. The information contained in an inode may include e.g. ownership of the file access permission for the file size of the file file type and references to locations on disk of the data blocks for the file. The references to the locations of the file data are provided by pointers which may further reference indirect blocks that in turn reference the data blocks depending upon the quantity of data in the file. Changes to the inodes and data blocks are made in place in accordance with the write in place file system. If an update to a file extends the quantity of data for the file an additional data block is allocated and the appropriate inode is updated to reference that data block.

Another type of file system is a write anywhere file system that does not over write data on disks. If a data block on disk is retrieved read from disk into memory and dirtied with new data the data block is stored written to a new location on disk to thereby optimize write performance. A write anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations particularly for sequential read operations directed to the disks.

Both the write anywhere file system and the write in place file system may be implemented on a file server configured to generate a persistent image of its active file system at a particular point in time for e.g. storage on disk. The disk storage may be implemented as one or more storage volumes that comprise a cluster of physical storage devices disks defining an overall logical arrangement of disk space. Each volume is generally associated with its own file system. The persistent image of the active file system is useful in that it may be used in many applications including asynchronous mirroring or other automated file system replication facilities.

Assume a client stores files organized as its home directory on a file server configured to generate a persistent image of its active file system. Some time after storing those files the server generates the persistent image of its active file system. Assume the client thereafter performs a backup operation to again store all of the files in its home directory on the server. Since the persistent image was generated before the files were overwritten the file system s notion of the files contains old contents. However the old contents are in the persistent image overwriting the old data blocks with new data results in allocating new blocks and writing the new data to the new blocks.

Accordingly the majority of data in the home directory is identical to that stored during the previous backup operation and the effective behavior is that the old contents of each file are replaced with new contents that happen to be the same as the previous contents. Unfortunately if those previous file contents already reside in the persistent disk image the file system may be unaware of the fact that the new contents are identical and therefore writes the new data to new locations on the disk. This results in two copies of the same data for the same file and hence duplication and inefficient disk storage of the file data.

One solution to this problem is to disable generation of persistent images of an active file system on the server volume. However this may be undesirable because those features benefits and applications that rely on such persistent images will no longer be available to the client. Another solution is to check the contents of the file in all persistent images at the time the file is overwritten. This may not always be possible because at write time the client may send less than one block of data per write operation i.e. a partial write operation . Also there could be multiple write operations before an entire block is full. These actions can result in numerous unnecessary and inefficient block comparison operations. The present invention is directed to solving the inefficiencies associated with file servers configured to generate persistent images of their active file systems.

The present invention comprises a file folding technique that reduces the number of duplicate data blocks of a file consumed on a storage device of a file server configured to generate a persistent image of its active file system at a point in time. According to the file folding technique if old data blocks of the file are over written with new data and that new data is identical to the data of the persistent file image the old data blocks are freed and the file is directed to refer to the persistent image for its data. Advantageously the invention reduces disk space consumption in a file server configured to generate persistent images of its active file system and in particular reduces overall persistent image disk usage.

In the illustrative embodiment the technique is preferably implemented via a command issued to the file system that invokes a novel file folding process to investigate folding of a file. Execution of the file folding command results in scanning of the file in the active file system and comparing the contents of its data blocks with the contents of the data blocks of the same file in the most recent newest persistent image. If a block is identical the new block from the active file system is freed and the file is updated to refer to the old block in the persistent image.

In the illustrative embodiment the memory comprises storage locations that are addressable by the processor and adapters for storing software program code and data structures associated with the present invention. A portion of the memory may be further organized as a buffer cache for storing other data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system portions of which are typically resident in memory and executed by the processing elements functionally organizes the filer by inter alia invoking storage operations in support of a file service implemented by the filer. It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the inventive technique described herein.

The network adapter comprises the mechanical electrical and signaling circuitry needed to connect the filer to a client over a computer network which may comprise a point to point connection or a shared medium such as a local area network. The client may be a general purpose computer configured to execute applications . Moreover the client may interact with the filer in accordance with a client server model of information delivery. That is the client may request the services of the filer and the filer may return the results of the services requested by the client by exchanging packets encapsulating e.g. the Common Internet File System CIFS protocol or Network File System NFS protocol format over the network .

The storage adapter cooperates with the storage operating system executing on the filer to access information requested by the client. The information may be stored on the disks or other similar media adapted to store information. The storage adapter includes input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance Fibre Channel serial link topology. The information is retrieved by the storage adapter and if necessary processed by the processor or the adapter itself prior to being forwarded over the system bus to the network adapter where the information is formatted into a packet and returned to the client .

Storage of information on the filer is preferably implemented as one or more storage volumes that comprise a cluster of physical storage disks defining an overall logical arrangement of disk space. Each volume is generally associated with its own file system. To facilitate access to the disks the storage operating system implements a write anywhere file system that logically organizes the information as a hierarchical structure of directories and files on the disks. Each on disk file may be implemented as set of disk blocks configured to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored.

In the illustrative embodiment described herein the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate file system including a write in place file system configured to generate a persistent image of the active file system at a particular point in time can be used. As such where the term WAFL is employed it should be taken broadly to refer to any file system that is otherwise adaptable to the teachings of this invention.

Bridging the disk software layers with the network and file system protocol layers is a WAFL layer that preferably implements the WAFL file system. The on disk format representation of the WAFL file system is block based using e.g. 4 kilobyte KB blocks and using inodes to describe the files. The WAFL file system uses files to store meta data describing the layout of its file system these meta data files include among others an inode file. A file handle i.e. an identifier that includes an inode number is used to retrieve an inode from disk.

Broadly stated all inodes of the WAFL file system are organized into the inode file. A file system FS info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each volume file system has an FS info block that is preferably stored at a fixed location within e.g. a RAID group of the file system. The inode of the root FS info block may directly reference point to blocks of the inode file or may reference indirect blocks of the inode file that in turn reference direct blocks of the inode file. Within each direct block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

Operationally a request from the client is forwarded as e.g. a conventional CIFS or NFS protocol packet over the computer network and onto the filer where it is received at the network adapter . A network driver of the media access layer processes the packet passes it onto the network protocol layers and CIFS or NFS layer for additional processing prior to forwarding to the WAFL layer . Here the WAFL file system generates operations to load retrieve the requested data from disk if it is not resident in core i.e. in the buffer cache . If the information is not in the cache the WAFL layer indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical volume block number VBN . The WAFL layer then passes the logical VBN to the disk storage RAID layer which maps that logical number to a disk block number and sends the latter to an appropriate driver e.g. SCSI of the disk driver layer . The disk driver accesses the disk block number from disk and loads the requested data block s in buffer cache for processing by the filer. Upon completion of the request the filer and operating system returns a reply to the client over the network .

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the filer may alternatively be implemented in hardware. That is in an alternate embodiment of the invention the storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the file service provided by filer in response to a file system request packet issued by client . Moreover in another alternate embodiment of the invention the processing elements of network and storage adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the file service provided by the filer. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer that manages data access and may in the case of a filer implement file system semantics such as the Data ONTAP storage operating system which is implemented as a microkernel. The storage operating system can also be implemented as an application program operating over a general purpose operating system such as UNIX or Windows NT or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the inventive technique described herein may apply to any type of special purpose e.g. file serving appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems.

In the illustrative embodiment a file is represented in the WAFL file system as an inode data structure adapted for storage on the disks . is a schematic block diagram illustrating an inode which preferably includes a meta data section and a data section . The information stored in the meta data section of each inode describes the file and as such includes the type e.g. regular or directory of file the size of the file time stamps e.g. creation access and or modification for the file and ownership i.e. user identifier UID and group ID GID of the file. The contents of the data section of each mode however may be interpreted differently depending upon the type of file inode defined within the type field . For example the data section of a directory inode contains meta data controlled by the file system whereas the data section of a regular inode contains user defined data. In this latter case the data section includes a representation of the data associated with the file.

Specifically the data section of a regular on disk inode may include user data or pointers the latter referencing 4 KB data blocks on disk used to store the user data. Each pointer is preferably a logical VBN to thereby facilitate efficiency among the file system and the disk storage RAID layer when accessing the data on disks. Given the restricted size e.g. 128 bytes of the inode user data having a size that is less than or equal to 64 bytes is represented in its entirety within the data section of that inode. However if the user data is greater than 64 bytes but less than or equal to 64 KB then the data section of the inode e.g. a first level inode comprises up to 16 pointers each of which references a 4 KB block of data on the disk.

Moreover if the size of the data is greater than 64 KB but less than or equal to 64 megabytes MB then each pointer in the data section of the inode e.g. a level 2 inode references an indirect block e.g. a level 1 block that contains 1024 pointers each of which references a 4 KB data block e.g. a level 0 block on disk. For user data having a size greater than 64 MB each pointer in the data section of the inode e.g. a third level inode references a double indirect block e.g. a level 2 block that contains 1024 pointers each referencing an indirect level 1 block. The indirect block in turn contains 1024 pointers each of which references a 4 KB direct level 0 data block on disk. Each data block is loaded from disk into the buffer cache in order to access the data.

When an on disk inode or block is loaded from disk into buffer cache its corresponding in core structure embeds the on disk structure. For example the dotted line surrounding the inode indicates the in core representation of the on disk inode structure. The in core structure is a block of memory that stores the on disk structure plus additional information needed to manage data in the memory but not on disk . The additional information may include e.g. a dirty bit . After data in the inode or block is updated modified as instructed by e.g. a write operation the modified data is marked dirty using the dirty bit so that the inode block can be subsequently flushed stored to disk.

The WAFL file system is adapted to freeze frame itself at any point in time and make that frozen versions of the file system available via special subdirectories that appear in the current active file system. Each freeze framed version of the file system is called a snapshot . The snapshot operates at the block level of the WAFL file system and represents a persistent image of the active file system at a particular point in time e.g. at a consistency point CP transition. Rather than discarding the old copy of the file system at the CP the WAFL file system saves it as a snapshot. Thus snapshots enable the filer to save copies of its file system state at various times. The in core and on disk format structures of the WAFL file system including snapshots inodes and the inode file are disclosed and described in U.S. Pat. No. 5 819 292 titled Method for Maintaining Consistent States of a File System and for Creating User Accessible Read Only Copies of a File System by David Hitz et al. issued on Oct. 6 1998 which patent is hereby incorporated by reference as though fully set forth herein.

It should be noted that snapshot is a trademark of Network Appliance Inc. It is used for purposes of this patent to designate a persistent CP image. A persistent CP image PCPI is a point in time representation of the storage system and more particularly of the active file system stored on a storage device e.g. on disk or in other persistent memory and having a name or other identifier that distinguishes it from other PCPIs taken at other points in time. A PCPI can also include other information meta data about the active file system at the particular point in time for which the image is taken. The terms PCPI and snapshot shall be used interchangeably through out this patent without derogation of Network Appliance s trademark rights.

Various processes within the WAFL layer cooperate to service a client request in core and thereafter dirty the appropriate inodes and blocks prior to storing writing them to disks. is a schematic block diagram illustrating the various processes within the WAFL layer of the storage operating system . These processes include a CP process a cleaner process a scanner process and a WAFL process . In general the WAFL process performs all the work in the WAFL layer e.g. loading blocks into the buffer cache setting dirty bits of the blocks and acquiring blocks for cleaning . The WAFL process is preferably implemented as two processes WAFL LoPri and WAFL HiPri only one of which can run at a time and which are interchangeable except for the priority level at which they run. The scanner CP and cleaner processes are essentially administrative processes that manage the work performed by the WAFL process. To that end the administrative processes send messages to the WAFL process instructing that process to execute particular functions with particular data supplied by the administrative processes. The WAFL process then processes manipulates the data structures in the buffer cache and sends messages to the RAID layer for purposes of loading storing data on disks.

For example the CP process manages write allocation operations including the generation of a snapshot during a CP operation of the file system whereas the cleaner process manages cleaning of the buffer cache . These processes cooperate to provide dirtied blocks from the cache to a write allocator of the WAFL process. The write allocator interacts with the RAID layer to obtain information about the layout of the disks. In addition the write allocator interacts with other processes of the WAFL layer including the scanner to obtain information relating to the optimal order of which data for files should be written to the disks. The write allocator then writes the data to disk one file at a time in accordance with a write allocation algorithm. To invoke write allocation the cleaner process sends a message to the WAFL process requesting a write allocation function for a particular structure e.g. inode .

It should be noted that all write operations in the file system are performed to free space blocks on disks. A free space block represents an available location e.g. data block on disk that is not currently used to store valid information. When storing a file to disk the write allocator of the WAFL layer writes into these free blocks at a write allocation point. The write allocator generally writes only a certain number of blocks to a given disk prior to moving to a next disk so as to spread the data across multiple disks. Notably the write allocator writes the file data in generally the same area of the disk during a CP operation.

The present invention comprises a file folding technique that reduces the number of duplicate data blocks of a file consumed on a storage device of a file server configured to generate a persistent image of its active file system at a point in time e.g. a snapshot. Broadly stated each file of the active file system is compared with its corresponding file in the snapshot and if their data contents are identical the file of the active file system is folded into i.e. updated to refer to the file in the snapshot. In other words if old data blocks of the file are over written with new data and that new data is identical to the data of the snapshot the old data blocks are freed and the file is directed to refer to the snapshot for its data. The inventive technique thus reduces disk space consumption in a file server configured to generate snapshots and in particular reduces overall persistent image disk usage.

In the illustrative embodiment the WAFL file system is capable of generating a plurality of e.g. thirty one 31 snapshots or persistent images of the file system at various points in time. Although folding of files against any snapshot would be flexible and useful it would disrupt a data block usage snapshot invariant of the file system. Therefore file folding as described herein is preferably invoked only with respect to a most recent snapshot.

The novel technique illustratively comprises a first stage for determining files that may be candidates for folding into corresponding files of the most recent snapshot and a second stage that actually folds the files into the snapshot files. It should be noted that the file folding technique is not specific to any particular protocol e.g. CIFS or NFS and in fact may be invoked in response to either a command line interpreter CLI inter face command from an administrator a predetermined volume operation or a client request to fold a particular file. Invocation of the file folding stages generally requires only passing of message containing a full pathname i.e. a pathname and filename of a file in a volume to the file system.

For example the administrator may employ a script e.g. a UNIX find command that traverses all files of a volume to produce full path names of those files. The administrator may then call into the file system via the CLI using e.g. a Remote SHell RSH command to pass each full pathname. Alternatively any file system protocol supported by the filer may utilize a front end engine that produces full pathnames of files which are then individually passed to the file system using e.g. a predetermined application programming interface API call. Each of these calls is then passed to the file system in a message having a predetermined format.

In response to receiving the message for a file that may be a candidate for folding various processes of layer hereinafter the WAFL layer determine whether inodes for the pathname directory and filename file exist within its on disk file system structure so that it may retrieve the inode of the file. Assume that the full pathname of the candidate file is dir foo. The inode of the candidate file foo is retrieved via a series of full pathname lookup operations into an on disk inode tree structure of the active file system. is a schematic block diagram illustrating the hierarchical on disk inode structure of the illustrative file system. Specifically the WAFL layer parses the first preceding the pathname dir1 and maps it to a root inode structure of its file system. The root inode is a directory having a plurality of entries each of which stores a name of a directory or a file and its corresponding inode number. Armed with a name and inode number the operating system can construct a file handle to retrieve the block inode from disk.

Broadly stated a name is an external representation of an inode data structure i.e. a representation of the inode as viewed external to a file system. In contrast the file handle is a unique representation of the data structure i.e. a representation of the inode data structure that is used internally within the file system. The file handle generally consists of a plurality of components including a file ID inode number a snapshot ID a generation ID and a flag. The file handle is exchanged between the client and server filer over the network to enable the filer to efficiently retrieve the corresponding file or directory. That is the file system may efficiently access a file or directory by mapping its inode number to a block on disk using the inode file. Use of the file handle thus obviates the need to exchange pathnames and perform lookup operations to retrieve the appropriate file or directory inode from disk. The filer returns to the client a file handle corresponding to a file upon completion of an operation.

Accordingly the WAFL layer loads the root directory inode from disk into buffer cache such that the root inode is represented as an incore inode and loads any data blocks referenced by the incore root inode. The WAFL layer then searches the contents of the root inode data blocks for a directory name dir . If the dir directory name is found in those data blocks the WAFL layer uses the corresponding inode number to retrieve the dir directory inode from disk and loads it and its data blocks into cache as incore inode structure s . As with the root inode the directory inode has a plurality of entries here however each entry stores a name of a regular file and its corresponding inode number. The WAFL layer searches the entries of the dir directory inode data blocks to determine whether the regular inode file name foo exists and if so obtains its corresponding inode number and loads the regular inode from disk into the buffer cache.

Once the inode for the file in the active file system is obtained the WAFL layer retrieves the corresponding inode of the file from the most recent snapshot. In general when a snapshot is generated a new root inode similar to the active file system root inode is created for that snapshot. This new inode forms the root of an on disk inode tree structure of the snapshot and is called the snapshot root inode. The on disk snapshot inode tree structures are preferably stored in the inode file.

In the illustrative embodiment the most recent snapshot inode tree can be identified from among all of the 31 snapshot inode trees by examining the time stamp of when the snapshot root inode was created. This time stamp is contained in a time stamp field similar to field of the snapshot root inode. The snapshot root inodes of all snapshots are preferably sorted in order by time stamp when the volume is mounted. The most recent snapshot inode is thus stored first e.g. at a head of a queue. Once the most recent snapshot inode tree structure is identified the snapshot inode of the file corresponding to the inode of the file in the active file system is retrieved using the process described above. If there is no corresponding snapshot inode the file is not in the most recent snapshot and no folding can occur. However if there is a snapshot inode corresponding to the active file then that inode is loaded into the buffer cache and a determination is made as to whether the file is a candidate for folding.

In Step as the level 1 blocks are loaded the VBN of each level 1 block from the active file system is compared with the VBN of the corresponding level 1 block from the most recent snapshot and a determination is made in Step as to whether those VBNs are equal. If the VBNs match then the level 1 blocks refer to a common level 0 data block and their children i.e. all level 0 data blocks are identical as well. Hence further processing of the current indirect block is skipped aborted the sequence returns to Step and the next one is loaded. However if the VBNs are not equal and the VBN of the buffer from the snapshot is not already used in the active file system then the level 0 data blocks for the active file system and the most recent snapshot are loaded into the buffer cache Step . It should be noted that loading of the level 1 blocks is not required and doing so is an optimization of the present invention. The alternative is to load only the level 0 blocks. As noted the VBNs pointing to the level 0 blocks are stored as data in the level 1 blocks .

As these blocks are loaded the file folding process compares the data contents of the active file system and snapshot level 0 blocks on a block by block basis Step . In Step a determination is made as to whether the contents of each data block are identical. If not it is resolved that the block is not a candidate for folding and the sequence ends at Step . If the data contents are equal the candidate level 0 data block of the active file system may be folded into its corresponding snapshot data block and the first stage of the technique transitions to the second stage. It should be noted that the comparison operations described in connection with the file folding technique are preferably performed using a kernel level routine e.g. buffer compare.

In Step the VBN of the level 0 data block in the snapshot is allocated by e.g. updating a bit of the active map corresponding to the snapshot block to indicate that the block is being used i.e. is allocated. Thereafter in Step the block pointer of the parent buffer either the indirect block e.g. level 1 block or inode of the data block in the active file system is updated to point to reference the VBN of the level 0 block in the snapshot. Thereafter the parent buffer is marked as dirty to ensure that it and all its ancestors are written out to disk on the next CP. The sequence then ends at Step .

While there have been shown and described an illustrative embodiment for reducing the number of duplicate data blocks of a file consumed on a storage device of a file server configured to generate a persistent image of its active file system at a point in time it is to be understood that various other adaptations and modifications may be made within the spirit and scope of the invention. For example an alternate embodiment for folding a file may comprise simply marking the buffer as being folded. Thereafter during the write allocation phase of a CP any buffer marked as being folded can be skipped and a new block need not be allocated for it.

In addition an optimization for the illustrative file folding technique described herein may arise after loading the level 0 data blocks of the active file system and snap shot in the buffer cache. Instead of immediately comparing the data contents of respective level 0 blocks RAID checksums associated with these blocks may be compared. If the checksums do not match the contents of the data blocks are different and a comparison operation between those contents may be avoided since the active file system block is not a candidate for file folding. This optimization conserves processing resources of the filer while improving the efficiency of the overall file folding process. Of course if the checksums are equal then the contents of the data blocks are compared as described herein. An example of a RAID checksum comparison technique that may be advantageously used with the present invention is described in U.S. patent application Ser. No. 09 642 062 titled by Sundaram et al. filed Aug. 18 2000 which application is hereby incorporated by reference as though fully set forth herein.

Moreover it should be noted that while a file is being folded other snapshot operations are still allowed. That is the novel file folding process described herein does not impede or prevent other snapshot operations. Specifically new snapshots can be created and snapshots can be deleted. Creating a new snapshot while a file is being folded results in in progress folds never folding another block. This happens because the newly created snapshot will now contain whatever blocks are in the file. The folding process thus traverses through the rest of the file and finds that each block has the same VBN in both the active file system and the most recent snapshot. Deleting the most recent snapshot results in in progress folds using the next most recent snapshot to fold against. If there are no more snapshots after deleting the most recent snapshot folding stops. Deleting any other snapshot other than the most recent snapshot has no effect on in progress folds.

The foregoing description has been directed to specific embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

