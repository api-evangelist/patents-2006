---

title: System and method for transferring a multidimensional array of data to a non-contiguous buffer
abstract: A system and method for storing a multidimensional array of data, such as a two dimensional (2-D) array of video data, in a non-contiguous memory space. The system and method maps individually indexed elements of a multidimensional array of data from a source device into blocks of non-contiguous memory available in a destination memory system, even when the destination blocks are small and/or their size does not correlate in any way to the dimensions of a source buffer. In particular, the blocks of non-contiguous memory may be as small as a single element of the data indexed in the 2-D array.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07822891&OS=07822891&RS=07822891
owner: Broadcom Corporation
number: 07822891
owner_city: Irvine
owner_country: US
publication_date: 20060613
---
The invention is generally related to systems and methods for transferring data to memory. In particular the present invention is related to systems and methods for transferring a multidimensional array of data to a non contiguous buffer.

Very often in computer systems it is necessary to transfer large multidimensional arrays of data such as two dimensional 2 D arrays of raw video data from a source device to a destination memory system. Certain conventional source devices will not transfer the source data to the destination memory system unless a requisite amount of contiguous memory space is available at the destination. For example the ATI Theater 550 Pro a product of ATI Technologies Inc. of Markham Ontario requires that a driver allocate a contiguous buffer in the destination memory space that is large enough to hold the contents of the entire source buffer. The driver must then copy the data into the sparse memory area for an application to use. This approach is rather inefficient as the data transfer is delayed if there is not a large enough contiguous block of destination memory space currently available to store the array.

The Rockwell Bt878 879 a product of Rockwell Semiconductor Systems of Newport Beach Calif. transfers video data over a PCI bus to a personal computer PC system. The Rockwell Bt878 879 does not require a complete contiguous destination buffer but it does require that each line of video data be transferred to a linear contiguous area of memory. This essentially changes the problem to transferring data into a series of one dimensional buffers. For long high definition scan lines this may require larger contiguous blocks of memory than are currently available.

In some systems the receiving system provides a table that identifies a series of blocks of available memory which may be scattered throughout the destination memory space. The source devices mentioned above cannot use any of these blocks of available memory unless they each exceed a predetermined amount of contiguous memory. In the case of the ATI Theater 550 Pro a block must be large enough to hold the entire source buffer whereas in the case of the Rockwell Bt878 879 a block must be large enough to hold at least one line of video data.

What is desired then is a system and method for transferring a multidimensional array of data such as a 2 D array of video data from a source device to a destination memory system that addresses the foregoing shortcomings of conventional solutions. In particular the desired system and method should be able to map the elements of a large multidimensional array of data from a source device into blocks of contiguous memory available in a destination memory system even when the destination blocks are small and or their size does not correlate in any way to the dimensions of the source buffer. Additionally the desired system and method should be able to gracefully handle situations where an arbitrary number of samples in the stream of data being transferred from the source device to the destination memory system are skipped. Such jumps in the data stream may occur if there is an overflow of the source buffer as a result of latency in a system where the data transfer takes place over a variable speed interface.

The present invention provides an improved system and method for storing multidimensional arrays of data such as a two dimensional 2 D array of video data in a non contiguous buffer. In particular a system and method in accordance with an embodiment of the present invention is able to map the elements of a large multidimensional array of data from a source device into blocks of contiguous memory available in a destination memory system even when the destination blocks are small and or their size does not correlate in any way to the dimensions of a source buffer. In particular the blocks of contiguous memory may be as small as a single element of the data indexed in the 2 D array. Thus the present invention handles data transfers more efficiently than conventional implementations. Additionally a system and method in accordance with an embodiment of the present invention gracefully handles situations where an arbitrary number of samples in the stream of data being transferred from the source device to the destination memory system are skipped. As a result any degradation resulting from delivery of the data to an end user may be minimized.

A method in accordance with a particular embodiment of the present invention may be used for transferring a multidimensional array of data to a destination memory space. The method includes reading an element indexed in the multidimensional array. It is then determined whether a first block of memory within the destination memory space includes sufficient space to store the element. If the first block of memory includes sufficient space to store the element then the element is stored in the first block of memory. Alternatively if the first block of memory does not include sufficient space to store the element the element is stored in a second block of memory. In a further embodiment the element is stored within either the first or second block of memory at a location that is determined based on the indices at which the element is indexed within the multidimensional array.

A system in accordance with a particular embodiment of the present invention includes a source device a source memory and a destination memory system. The source memory is accessible by the source device and stores a multidimensional array of data. The destination memory system is coupled to the source device and includes a destination memory space. The source device is configured to access the source memory and read an element indexed in the multidimensional array. The source device is further configured to determine if a first block of memory within the destination memory space includes sufficient space to store the element. The source device is still further configured to transfer the element to the destination memory system for storage in the first block of memory responsive to a determination that the first block of memory includes sufficient space to store the element and to transfer the element to the destination memory system for storage in a second block of memory responsive to a determination that the first block of memory does not include sufficient space to store the element.

In a further embodiment the source device is configured to transfer the element to the destination memory system for storage at a location within either the first block of memory or that second block of memory that is determined based on the indices at which the element is indexed within the multidimensional array.

Further features and advantages of the invention as well as the structure and operation of various embodiments of the invention are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art s based on the teachings contained herein.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit s in the corresponding reference number.

As shown in video processing system includes various software elements including an application an application programming interface API and a driver . These software elements are executed on a host computer system and interact with video hardware elements such as a video stream controller to obtain video content from an external video source and transfer the video content to system memory . Video stream controller resides on a video capture card that is installed on the host computer system. The individual elements of system will now be described in more detail.

Application is a software program that permits an end user to obtain video content such as digital video content from an external video source and to view the video content via display . Application communicates with API to perform these tasks. Several APIs are available for use in the video processing context. APIs were developed as intermediaries between application software such as application and video hardware on which the application software runs. APIs prevent applications from having to be too hardware specific. The application can output commands to the API in a standardized format rather than in a proprietary format dictated by the video hardware. DirectShow is an example of an available API. API can be any one of the available APIs for managing video content.

API communicates with driver . Driver is typically written by the manufacturer of the video hardware and translates standard code received from API into a native format understood by the video hardware.

The video hardware includes a video capture card that is installed in a PCI or PCI Express slot of the host computer. This enables the video capture card to communicate over a PCI or PCI Express bus with other elements of video processing system such as driver and system memory . Video capture card is adapted to receive video input from an external video source and to transfer video data to system memory for viewing by the end user. System memory is intended to represent any memory within the memory map of the host system including but not limited to main system memory or the frame buffer of a display adapter .

Video input processing path includes a tuner demodulator and a video stream controller . Tuner demodulator extracts a stream of encoded video data received via video input interface and provides it to video stream controller . Among other processing tasks video stream controller passes the video data to other elements of video processing system . Video stream controller is coupled to a local memory that is used by video stream controller for storing video data and other data associated with performing its processing tasks. In an embodiment video stream controller is included in an application specific integrated circuit ASIC although the invention is not so limited.

When an end user instructs application to obtain video content from video source for display on display a call is placed to API to perform these tasks. API in turn communicates with driver which sends appropriate commands to video stream controller . Responsive to such commands video stream controller begins sending frames of video data which are stored as large 2 D arrays of data in local memory to system memory where they are accessible to driver and API . From system memory the frames of video data can then be sent for output to display .

The present invention is directed to a more efficient method of performing the aforementioned function of transferring large 2 D arrays of video data from local memory to system memory . However the present invention is not limited to the operating environment described with respect to . Rather persons skilled in the art will readily appreciate that the present invention is applicable to any system in which a multidimensional array of data is stored in a non contiguous memory space.

B. Transfer of Multidimensional Array to a Non Contiguous Memory Space in Accordance with an Embodiment of the Present Invention

The manner in which video stream controller uses the table to transfer elements of the 2 D array of video data into the non contiguous blocks of available system memory will now be described with respect to . Although these methods will be described with respect to the transfer of a 2 D array of video data from local memory of video stream controller to system memory of video processing system persons skilled in the art will readily appreciate that each of these methods are generally applicable to any system that transfers a multidimensional array of data from a source to a non contiguous memory space.

Each of the methods described below with respect to differ from conventional methods in that they transfer data from the 2 D array on an element by element basis rather than transferring the data on a line by line basis or the array as a whole. As used herein the term element of an array refers to the smallest atomic units that are indexed within the array whatever those units may be. For example if the video data in the 2 D array is 4 2 2 coded video data each element of the 2 D array could comprise a pair of pixels that are represented by two luminance samples and two chrominance samples. The number of bits or bytes that make up each element are determined by the precision of the data used to represent each element. Thus if 8 bits were used to represent each of the two luminance and two chrominance samples the size of each element would be 4 bytes. However this example is not intended to be limiting and persons skilled in the art will readily appreciate that elements of any type and size may be used in the 2 D array.

In an embodiment video stream controller implements the methods of or in dedicated hardware although the invention is not so limited. Persons skilled in the relevant art will readily appreciate that these methods could also be implemented in software or as a combination of software and hardware.

At step video stream controller uses the table provided by driver to identify a current block of available system memory and ascertains whether or not the end of the current block of available system memory has been reached. If the end of the current block has not been reached video stream controller transfers or copies the element of the 2 D array into the current block of available system memory as shown at step . If however the end of the current block has been reached then video stream controller uses the table provided by driver to ascertain the destination address of the next block of available system memory and transfers or copies the element of the 2 D array into that block as shown at step . The next block then becomes the current block for the purposes of subsequent processing steps.

In either case the method then proceeds to step in which a determination is made whether or not there are more elements to be read from the 2 D array. If there are more elements then control returns to step otherwise the data transfer ends as indicated at step .

As can be seen from the foregoing description of flowchart one solution for transferring the 2 D array is for video stream controller to sequence through the 2 D array in local memory on an element by element basis and copy the elements into each destination address identified in the table. Whenever the end of one destination block is reached video stream controller reads the first destination address of the next block from the table and continues copying elements in order. This works well as long as there are no gaps in the source data. However sometimes video stream controller can encounter buffer overflows due to insufficient available buffer space in local memory . In that case it may be necessary to jump ahead in the data sequence. If the element by element sequencing approach described above with reference to is being used a complex calculation is required to determine the number of elements that have been skipped and then to skip that number of locations in the destination sequence.

A second approach in accordance with an embodiment of the present invention is to derive the destination address directly from the indices of the 2 D array. This has the benefit of eliminating the problem of a gap in the source data stream. For the sake of explanation these indices will be referred to hereinafter as the X and Y indices of the 2 D array although any nomenclature could be used.

At the beginning of the 2 D array the destination address is simply the address of the first available block of system memory as identified in the table provided by driver plus an offset implied by the X and Y coordinates of the current data element. In other words DEST ADDR BLOCK0 ADDR Pitch Pitch wherein DEST ADDR is the destination address BLOCK0 ADDR is the address of the first block of available system memory X and Y are the X and Y coordinates respectively of the current data element and XPitch and YPitch are the number of bytes between elements in each dimension of the 2 D array. In a 2 D video processing system this would typically be the number of bytes per pixel and the number of bytes per line of video respectively. However any desired numbers may be used.

The foregoing simple computation works until the first block of available system memory is filled or until a gap in the data sequence causes the computed address to be outside of the first block. At this point video stream controller must determine how to map the next element in the 2 D array which may have an arbitrary X Y value into the destination memory space. As will be described in more detail below in order to do this video stream controller keeps track of the cumulative total size of each block of available system memory and subtracts that from the X Y offset to obtain the relative offset in the current block of data. This method assumes that the table provided by driver provides an address for each available block of system memory as well as the size of the available block at that address. Furthermore the method assumes that the size of each available block is a multiple of the size of the element that is being transferred.

An implementation of this method will now be fully described with reference to flowchart of . In particular illustrates a flowchart of a second method by which video stream controller uses the table from driver to transfer elements of a 2D array of video data into non contiguous blocks of available system memory.

As shown in the beginning of the data transfer process is indicated at step . At step video stream controller initializes variables CUR BLOCK ADDR and CUR BLOCK SIZE with values based on the first entry in the table provided by driver wherein CUR BLOCK ADDR holds the address of the current block of available system memory and CUR BLOCK SIZE holds the size of the current block of available system memory. At step video stream controller sets the variable SIZE OF PREV BLKS to zero wherein SIZE OF PREV BLKS holds a value indicating the cumulative size of all the previously populated blocks of available system memory.

At step video stream controller determines whether the buffer storing the elements of the 2 D array is empty. If the buffer is empty then the data transfer is complete as indicated at step . If the buffer is not empty then control passes to step .

At step video stream controller calculates the variable DEST ADDR which holds the destination address at which the next element in the 2 D array is to be stored. Video stream controller calculates DEST ADDR as the sum of CUR BLOCK ADDR plus X XPitch plus Y YPitch less SIZE OF PREV BLKS. X denotes the X coordinate of the next element in the 2 D array and Y denotes the Y coordinate of the next element in the 2 D array. XPitch and YPitch are the number of bytes between elements in each dimension of the 2 D array. Thus XPitch is equal to the size in bytes of each element in the 2 D array while YPitch is equal to the number of bytes between the start of one line in and the start of the next line the 2 D array. This step effectively subtracts the cumulative size of all the previously populated blocks of available system memory from the X Y offset to obtain the relative offset in the current block of available system memory.

At step video stream controller compares the value of DEST ADDR to the sum of CUR BLOCK ADDR plus CUR BLOCK SIZE. If DEST ADDR is not greater than or equal to the sum of CUR BLOCK ADDR CUR BLOCK SIZE then the relative X Y offset in the current block of available system memory does not extend beyond the end of the block. Accordingly video stream controller copies or transfers the next element of the 2 D array to the current block as shown at step and control is then returned to step .

However if DEST ADDR is greater than or equal to the sum of CUR BLOCK ADDR CUR BLOCK SIZE then the relative X Y offset in the current block of available system memory does extend beyond the end of the block. In other words the current block is full. As a result video stream controller increments SIZE OF PREV BLKS by the value of CUR BLOCK SIZE as shown at step and loads CUR BLOCK ADDR and CUR BLOCK SIZE with new values based on the next sequential entry in the table provided by driver as shown at step . Once these additional steps have occurred processing then returns to step in which video stream controller recalculates DEST ADDR based on the updated values of SIZE OF PREV BLKS and CUR BLOCK ADDR. Assuming now that DEST ADDR is not greater than or equal to the sum of CUR BLOCK ADDR CUR BLOCK SIZE then video stream controller copies or transfers the next element of the 2 D array to the current block as shown at step and control is then returned to step .

The following is a pseudo code representation of the foregoing processing steps described in reference to 

The present invention is advantageous in that it facilitates the transfer of a multi dimensional array from a source buffer to a destination buffer regardless of whether the destination buffer is a block of contiguous memory or alternatively fragmented in some defined or arbitrary manner. In the simplest case there is only a single contiguous destination block and all the source data must fit into the destination block. This case is depicted in in which the source data is indicated as the large block and the destination buffer is indicated as block . In a video processing application it is possible that the destination may include overscan samples i.e. the number of samples per line in the destination could be larger than the number of samples in the source per line but the destination can never have a smaller number of samples per line than the source. In the case of overscan the memory for the overscan is allocated but not written to since there is no source data and there will be a gap in the destination data.

In another example the destination buffer may be comprised of multiple blocks wherein each block is defined to hold a single scan line of the source array. This example is illustrated in in which the source data is indicated as the large block and the destination buffer is shown as comprising a series of equally sized blocks .

Many more complex cases can exist and are handled by the present invention. illustrates an example in which the source data must be transferred to a highly fragmented series of blocks of destination memory wherein each block may be of an arbitrary size. The worst case scenario would be for each destination block to contain only a single source sample. It is unlikely that a case this severe would occur but due to memory fragmentation it is conceivable to have some blocks that are smaller than a line and other blocks that are multiple lines possibly with overlap onto other lines .

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not limitation. It will be understood by those skilled in the relevant art s that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined in the appended claims. Accordingly the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

