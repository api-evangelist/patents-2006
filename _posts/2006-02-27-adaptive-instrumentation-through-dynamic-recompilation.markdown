---

title: Adaptive instrumentation through dynamic recompilation
abstract: A system and method for instrumenting program instructions. A processing system includes a compiler and a profiler. The profiler is configured to instrument an application by inserting one or more instrumentation instructions in the application. During execution of the application, execution is monitored and a particular condition is detected. Responsive to the condition, a portion of the code which corresponds to the detected condition is identified. A request is conveyed for recompilation of code which corresponds to code. Prior to recompilation of the code, the profiler instruments the portion of code. Execution and monitoring of the execution continue, and instrumentation/recompilation may be repeated. Initially, relatively little of the application code may be instrumented. As execution and monitoring continues, more and more of the application code may be dynamically instrumented during execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08176480&OS=08176480&RS=08176480
owner: Symantec Operating Corporation
number: 08176480
owner_city: Mountain View
owner_country: US
publication_date: 20060227
---
This invention relates to computer processes and more particularly to the instrumentation of computer application code.

In order to better understand the operation of software processes it is common to employ any of a variety of monitoring profiling and or analysis techniques in conjunction with the software processes to be understood. Such monitoring profiling and analysis techniques which for simplicity may collectively be referred to as profilers are available from many vendors or may be custom made for specific applications. As part of a profiling or monitoring process application code may be instrumented by adding instructions i.e. code sometimes referred to as probes to an application s original code. These probes may then generate additional data concerning the operation of the application during runtime.

Traditionally there have been two general approaches to the instrumentation of application code. One approach is static instrumentation and the other approach is dynamic instrumentation. However both of these approaches have disadvantages. Static instrumentation generally involves replacing an application s original executables with instrumented executables. However such an approach can be difficult to manage. One difficulty with managing statically instrumented applications is the user needs to know which executables make up their application and which executable are instrumented and non instrumented. Another problem with static instrumentation is that digitally signed code generally cannot be instrumented. If a digitally signed assembly library or other code is instrumented the process which loads the instrumented code may reject it due to a failed signature verification.

In dynamic instrumentation application code e.g. intermediate code may be instrumented at the time the code is actually loaded for execution. For example in the Microsoft .NET framework bytecodes may be instrumented when a method or assembly is loaded for just in time JIT compilation. Alternatively code may be instrumented when a class is loaded in a Sun Microsystems Java environment. While the dynamic approach may avoid the need for replacing deployed executables on disk it may also entail significant performance implications due to the overhead involved. Further it may also be very difficult to support and maintain code while using a dynamic instrumentation approach because no instrumented files are generated that can be sent to support.

In addition to the above one of the issues with profiling code concerns the generation of too much data or information regarding the operation of a particular application. As a general matter those analyzing the operation of various applications may not necessarily be interested in every part of the application. Consequently various efforts may be undertaken to reduce the amount of superfluous data which is generated. One such technique for reducing the generation of unneeded data involves providing switches for probes which allows the probes to either be enabled or disabled. By selectively enabling or disabling probes more or less probe data may be generated. While such a technique may reduce the production of unwanted data the instrumentation of the code itself may cause a reduction in performance of the application. For example while a probe may be disabled it may generally be necessary to execute instructions in order to determine whether or not the probe is to be enabled or disabled. Therefore instrumenting the code may in and of itself result in undesirable overhead irrespective of whether or not probes are enabled or disabled.

Another alternative for reducing the amount of data generated by probes is to simply instrument less of the application code. However utilizing this approach various performance characteristics may never be captured during execution and diagnosis of a corresponding problem may be rendered overly difficult.

In view of the above an effective and efficient method and mechanism for instrumenting application code is desired.

A processing system is contemplated which includes a compiler and a profiler. The system is configured to support registration by various components for notification of events including notification of compilation events from the compiler. The profiler is configured to instrument application code and monitor execution. During execution of an application a particular event or condition may be detected by the profiler. Responsive to detecting the event or condition a portion of code which corresponds to the detected condition is identified. The profiler may then convey a request for recompilation of the identified code. Prior to recompilation of the code the profiler is configured to instrument the code which is to be recompiled. Subsequent to recompilation execution and monitoring of the code continues. In one embodiment relatively little of the application code may be instrumented initially. As execution and monitoring continues more and more of the application code may be dynamically instrumented during execution.

In one embodiment the system comprises a framework including a just in time compiler. A configuration file may be utilized to configure the profiler upon load of a given application. The configuration file may include an indication as to a select number of methods of the application code which are to be initially instrumented. During execution of the application a condition such as a relatively long performance latency may be detected for a given portion of code or service. In response the profiler may examiner the application code associated with the detected condition. Methods which are identified as being called by the associated application code may then be identified as requiring instrumentation. The profiler then coveys a recompilation request to the underlying framework and stores an instrumentation indication for the code identified as requiring instrumentation. When a recompilation event corresponding to the code is detected the profiler instruments the code prior to recompilation.

These and other embodiments will become apparent upon reference to the following description and accompanying figures.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed descriptions thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

The following description is presented to enable one of ordinary skill in the art to make and use the invention. Descriptions of specific embodiments and applications are provided only as examples and various modifications will be readily apparent to those skilled in the art. The general principles described herein may be applied to other embodiments and applications without departing from the scope of the invention. Thus the present invention is not to be limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features described herein.

Processor may be configured to execute instructions and to process data according to a particular instruction set architecture ISA . In one embodiment processor may be configured to implement an x86 compatible ISA although in other embodiments it is contemplated that any desired ISA may be employed such as the SPARC V9 ISA PowerPC compatible ISAs or MIPS compatible ISAs for example. SPARC is a registered trademark of Sun Microsystems Inc. PowerPC is a registered trademark of International Business Machines Corporation MIPS is a registered trademark of MIPS Computer Systems Inc. .

In various embodiments memory may comprise any suitable type of system memory as described above such as FB DIMM DDR DDR2 SDRAM or RDRAM for example. Memory may include multiple discrete banks of memory. Also in some embodiments memory may include multiple different types of memory.

In some embodiments computer may include more than one instance of the devices shown such as more than one processor for example. In various embodiments computer may be configured as a rack mountable server system a standalone system or in any other suitable form factor. In some embodiments computer may be configured as a client system rather than a server system.

In one embodiment processor may be configured to run operating system software such as Microsoft Windows IBM AIX or Sun Microsystems Solaris. Operating system software may in turn provide an environment in which processor may execute additional software modules in the form of applications programs or processes designed to perform specific functions. Running operating system software or software modules may comprise executing instructions that are stored in memory .

Software modules that may be executed by processor may include in one embodiment client server software such as a web server or a web browser. Alternatively or in addition processor may execute software modules comprising network management software office productivity tools e mail programs etc. Many other types of software may be executed such as a virtual machine runtime environment a database an application server and diagnostic monitoring profiling or analysis software. Furthermore while executing such software processor may retrieve data from and store data in non volatile storage or in memory . In one embodiment one or more software processes may perform the function of profiling other software processes during operation gathering and storing data indicative of the operation of one or more of the other software processes.

Turning now to one embodiment of various components of a computing system are depicted. In the illustrated embodiment software processes are shown to include an application process event detection process code translator and profiler . Also shown is uninstrumented application code which may be stored on a storage device or medium. The storage device medium may generally comprise non volatile storage such as a hard disk s . However those skilled in the art will appreciate that numerous types of storage devices and technologies volatile or non volatile may be utilized to store data. Further as used herein application code may refer to any instructions executable by a processing device and is not limited to end user type application code.

Generally speaking provides a high level view of a system which is configured to support the instrumentation of application code for monitoring profiling or any other desired purpose. In one embodiment a computing system s runtime environment is configured to support dynamic translation of application code at the time of loading or execution. For example in one embodiment uninstrumented application code may comprise an application s original uninstrumented code which is stored on a disk. Such code may comprise an intermediate representation such as a bytecode representation or some other representation which is generally portable across computing platforms. Some examples of systems configured to use intermediate representations include Microsoft s .NET framework and some versions of Sun Microsystems Java language. Other embodiments may utilize computing platform specific representations whether intermediate or not.

In an embodiment wherein the application code is an intermediate representation compilation of the application code from the intermediate representation to a native code or language which is specific to a given platform may be performed at the time the application code is loaded for execution. Generally speaking when the application code is loaded for execution a code translator or compiler may be invoked to translate the application code to the native language. Code translator may for example comprise a just in time JIT compiler or similar component. The translated or compiled application code may then be executed. In some embodiments when an application is loaded for execution all code of the application may be translated compiled or otherwise made ready for execution. However in other embodiments certain portions of the application code may not be translated or compiled until needed. For example in one embodiment particular functions or methods of an application may not be translated until such functions or methods are encountered e.g. called or invoked during execution of the corresponding application code . In such an embodiment when the application code is initially loaded only the calls to such functions or methods themselves are translated. When the function or method is required during execution the corresponding code is located translated by the translator and executed.

In one embodiment profiler is configured to instrument application code by inserting additional code or otherwise modifying existing code of an application. Such a profiler may be configured to instrument the application code on disk prior to the application being loaded. Alternatively or in addition to the above profiler may be configured to instrument application code dynamically at the time the code is loaded for execution.

In one embodiment profiler may be configured to register with the underlying software subsystem to receive notification of various events. When such an event is detected by an event detection process the profiler is notified of the event s occurrence. Upon notification of a particular event the profiler may then take some action. In one embodiment the profiler registers to be notified when code translator is preparing to translate or compile application code. Notification of the compilation event may also include some identification of the application code e.g. function or method which is to be compiled. In response to the notification profiler may be configured to retrieve the identified application code and instrument or modify the intermediate code prior to the code being translated by code translator . After instrumenting the code the profiler is configured to direct the translator to the instrumented version of the code. The translator may then translate or compile the instrumented version of the code which may then be executed.

In the embodiment of the original application code may generally remain on disk in an unmodified form. However in various embodiments instrumented versions of the code may also be created and stored on disk or other non volatile media. Accordingly application code may be instrumented in a dynamic manner while also having stored versions of the instrumented code. Having the stored instrumented versions available may facilitate debug or other diagnostic efforts when problems arise with the computing system.

Upon detection of the compilation start event decision block a determination may be made as to whether the particular code is to be instrumented decision block . Numerous alternative approaches may be utilized for making this determination. For example a developer or user may create a configuration file which identifies selected portions of code for instrumentation. The profiler may then access the configuration file data at the time of execution or during execution to determine whether particular code is to be instrumented. If the detected compilation event decision block corresponds to code which is not identified as code which is to be instrumented then the code may simply be passed to the compiler block . It is noted that this code may or may not already include instrumentation. If the detected compilation event decision block corresponds to code which is identified as code to be instrumented then the profiler or other process may then obtain the code which is to be compiled and instrument the obtained code block . Subsequent to instrumenting the code the profiler may then provide the instrumented version to the compiler block . It is noted that in an embodiment wherein previously instrumented versions of code may also be stored the profiler may check for such a version before instrumenting the application code. Should an instrumented version already exist the profiler may forego re instrumenting the application code and simply pass the previously instrumented version to the compiler. All such alternatives and combinations of the above are contemplated.

As discussed above instrumentation and profiling mechanisms may sometimes generate either too much or too little data. Further identifying code to be instrumented in a manner which provides the right balance and mix of data for useful analysis can be very difficult. Accordingly in one embodiment an instrumentation and profiling mechanism is provided which may respond in a dynamic manner to the execution of application code. Often times evaluation of application code performance and behavior involves an iterative approach wherein processing layers are successively peeled away in order to identify code which contributes to a given behavior. For example an initial evaluation may reveal that excessive latencies are being experienced with a particular service e.g. servicing http requests . However in order to determine why such latencies are occurring it may be necessary to begin examining particular methods functions which are utilized by the given service. Analysis of these methods functions may reveal a particular method function is experiencing significant latencies. Accordingly a more detailed analysis of this particular method function may be undertaken and so on. As can be seen analysis may involve peeling away higher levels layers i.e. drilling down of the code to determine a root cause s of a given behavior. While excessive latency is used as an example of a behavior any condition or behavior may serve as a basis for further analysis.

Turning now to one embodiment of a method is shown which enables dynamic instrumentation of code. In the example shown a profiler may be configured to profile selected code and or processes block . In one embodiment the code initially selected for profiling may correspond to fairly high level services e.g. root methods of a web server . This initially identified set of code may then be instrumented to provide profiling data block . In one embodiment the initially identified set of code may be instrumented at the time of compilation as described above. However in other embodiment the initial set of code may be instrumented statically prior to application execution. All such alternatives are contemplated.

Subsequently the application code execution is monitored block . During execution particular behaviors of the code may be monitored. For example servicing http requests may be monitored for latencies. Should the latency meet and or exceed some threshold or meet any other suitable condition the profiling mechanism may then identify additional code for profiling block . For example a root method for servicing http requests may have been initially instrumented. During execution the profiler may determine that this root method is experiencing a condition such as long latencies. Responsive to detecting this condition the profiler may then examine the root method to identify block other methods which are called by the root method. The profiler may then generate an indication which indicates these other methods are to be recompiled block . Further the profiler may store an indication that these other methods are to be instrumented. In response to the recompile indication the underlying code translator e.g. JIT compiler may recompile these other methods. Recompilation of one of these other methods may occur the next time a call to the other method is made or the recompilation may be scheduled for any other suitable time.

Similar to that discussed in relation to above the profiler may be notified of the compilation start event for one of these other methods. In response the profiler may instrument the corresponding code and pass the instrumented version to the compiler block . Subsequently monitoring block may continue. As one or more other methods code have been instrumented new profiling data may be available for behavior analysis and may form the basis for additional modifications to instrumentation.

It is noted that one or more of these other methods identified in block may not have been previously compiled. For example no call to a given other method may not have been made during execution. In such a case a recompilation indication for the given method may not have any effect. Rather compilation of the given method may occur as usual according to the corresponding system. Whether or not the given method is instrumented may be configurable within the profiler. For example in certain embodiments it may be assumed that identified other methods of a given service which have not be called have not contributed to a particular behavior or condition. Accordingly the profiler may not select such a method for instrumentation. Alternatively the profiler may be configured to instrument such a method. All such alternatives are contemplated.

It is noted that the above monitoring and recompilation method and mechanism may be configured to operate without user interaction. For example responsive to determining a particular service is latency deemed high with respect to a predetermined threshold or relative to other processes the instrumentation and recompilation may be performed automatically. Alternatively or in addition to an automatic approach the profiler may be responsive to user interaction during execution of the application as well. For example a user interface for viewing and analyzing profiling data may be provided. By viewing the data a user may manually select a particular portion of code service or method for instrumentation. An indication corresponding to the selected portion may then be conveyed to the profiler. The profiler may then treat this indication as though it had been generated by the profiler itself e.g. as described in . In a similar manner the user interface may enable a user to remove previously provided instrumentation. For example the user may indicate a method is to be recompiled without instrumentation. Numerous such alternatives are possible and are contemplated.

Following the general approach described in and only an initial set of services may be instrumented for profiling. Services which are instrumented are depicted with a rectangle. For example instrumentation of these services is denoted by rectangles A C respectively. During execution it may be determined that service is experiencing a particular behavior of interest. In response services which are utilized by service may be identified. In this example service utilizes services and . Accordingly services and may be identified for instrumentation and recompilation A B . Further monitoring may reveal that service is experiencing a behavior of interest. Services are identified as being utilized by service and are identified for instrumentation and recompilation A C . Finally service may be identified as exhibiting an interesting behavior. Therefore services and may be identified for instrumentation and recompilation A C . In this manner the method and mechanism drills down into the code and provides additional profiling data in a dynamic manner.

Turning now to one embodiment of a software system is illustrated which includes components based on a Microsoft Windows operating system and Microsoft .NET framework. While a Microsoft Windows operating system and .NET framework are utilized for purposes of discussion the methods and mechanisms described herein may be applied in other environments as well. In the illustrated embodiment a process and a profiler are shown coupled to a .NET framework which may be supported by a Microsoft Windows operating system Windows . Profiler is shown to include a monitor and recompile unit . Process may be for example an active server page ASP conforming to the ASP.NET specification. Operating system may be one of Windows 98 Windows 2000 Windows XP or any other version of the Windows operating system with which .NET framework is compatible. In one embodiment .NET framework includes a .NET profiling application programming interface API . Profiler may be an application written to use the functionality provided by the .NET profiling API 655 and configured to instrument application code.

In addition to the above illustrates original application code and metadata . In one embodiment original code may be stored on non volatile storage such as a disk but other storage mechanisms are possible and are contemplated. Also illustrated is a compiler or translator . Compiler may comprise a just in time JIT compiler configured to compile from a portable intermediate code to a native code of a device on which the code is to be executed. As further illustrated in operating system may include environment variables envars a User32.dll and a list of AppInit DLLs . Envars may comprise environment variables used by operating system to establish an operating environment for each process that is launched. User32.dll is a dynamic link library that may be linked to user defined processes at the time of launch such as process that utilize the Windows user interface functionality.

In one embodiment during the launch of process Windows may load various files or libraries into process using a procedure referred to as dynamic linking. Specifically in one embodiment Windows may load User32.dll into process . As part of the loading procedure for a windows process operating system may execute a function in User32.dll known as DLLMain with an argument of DLL PROCESS ATTACH. This function may execute a LoadLibrary function to load and initialize DLLs that are listed in AppInit DLLs . AppInit DLLS may include user specified DLLs etc. that .may be dynamically linked to a process during initialization. In the illustrated embodiment one of the AppInit DLLs is an injector.dll . Injector.dll may be configured to read a set of values for environment variables from a configuration file and set the environment variables for process according to these values.

Three environment variables in particular may be used for profiling of process es . The first COR ENABLE PROFILING enables or disables profiling of process . For example setting COR ENABLE PROFILING may enable profiling and clearing COR ENABLE PROFILING may disable profiling. The second COR PROFILER may be used to identify a particular profiler such as profiler which itself may comprise a one or more DLLs to be used for instrumenting and profiling code. The third environment variable depicted is COR PRF ENABLE RREJIT which may allow JIT recompilation of methods using calls to ICorProfilerInfo SetFunctionReJIT.

Library injector.dll may retrieve and set values for environment variables COR ENABLE PROFILING COR PROFILER and COR PRF ENABLE RREJIT that apply to process during the launch procedure. In one embodiment child processes which are spawned by a parent process may inherit the environment including environment variable settings of the parent process. Accordingly in one embodiment injector.dll may be configured to establish particular environment settings for an application upon initialization of the application. Such settings may then be applied to all processes of the application throughout the life of the application i.e. until all of the application processes are terminated . In one embodiment injector.dll may consult a configuration file not shown to determine whether a particular application is to be instrumented. In order to avoid the delay of reading from non volatile storage a copy of the configuration file may be maintained in memory for faster access. In addition the configuration file may identify a particular set of services which are to be initially instrumented.

Generally speaking operation of the system depicted in may be as follows. During installation or configuration of code corresponding to the profiler the profiler may be configured to register various software components with the underlying framework and or operating system . Such registration may include the registering of particular DLLs such as profiler . In addition profiler may be configured to register to be notified of particular events as discussed above. In one embodiment profiler registers to be notified of compilation events corresponding to the JIT compiler . In particular profiler may be notified upon the occurrence of an event which indicates JIT compiler is requesting or otherwise preparing to compile application code .

Upon detection of such an event profiler may determine e.g. via a configuration file whether the code which is to be compiled is to be instrumented. If the event corresponds to the initial loading of an application profiler may make such a determination based on an initial set of services identified in a configuration file. Alternatively if the event does not correspond to the initial loading of an application e.g. a method is being invoked profiler may determine whether the method has been identified for instrumentation as discussed above.

In the event of an initial loading of an application uninstrumented application code is retrieved for compilation. In one embodiment application code may comprise one or more assemblies suitable for use within a .NET framework . Generally speaking an assembly may comprise a distributable library of related classes and a definition of their scope. Included with an assembly may also be a manifest which contains metadata describing the exported classes in the assembly external dependencies required by the classes various permissions for using the assembly versioning information and so on. In addition to the above in one embodiment application code comprises an intermediate code such as byte code which has already gone through a compilation process from an original source language.

In one embodiment JIT compilation occurs at the assembly level whenever an assembly is first loaded. Methods or functions encountered during compilation of the assembly are not themselves compiled. Rather an identifier e.g. a stub may be inserted for each such function or method. Only when a particular method is invoked is the body of the method compiled from the intermediate code to the native language of the machine. Upon initiation of code compilation JIT compiler or the underlying runtime notifies the profiler . In one embodiment compiler may notify the profiler via the IcorProfilerCallback JITCompilationStarted method of the .NET framework . Included in the notification to the profiler is an identifier which may be utilized to identify the particular code to be compiled. In response profiler intercepts the compilation process and invokes the instrumenter which may be part of the profiler or maintained as separate code to instrument a body of code which may comprise a superset of the code which is to be compiled using intermediate language instructions. In various embodiments profiler may be configured to only instrument selected methods of functions of a given assembly. In such a case profiler may not instrument application code upon initial loading. However even in such a case profiler may still generate and store metadata corresponding to the application. Such metadata may include the identification of various methods and functions of an application but may also indicate such methods and or functions have not yet been instrumented.

In response to detecting a JITCompilationStarted event corresponding to a method or function profiler may utilize a received identifier to identify the method or function to be compiled. The profiler may then determine whether the corresponding method or function has been instrumented e.g. by accessing corresponding metadata . If the method has not be instrumented the profiler may then access code containing the body of the method to be compiled. For example by accessing the assembly containing that code. Once instrumented code has been acquired by the profiler various approaches may be used to modify the method body including using the SetILFunctionBody method provided by the .NET framework . In one embodiment profiler may use the GetILFunctionBody method to obtain the method body. The profiler may then instrument the method body prior to allowing the compilation process to continue.

It is noted that the JIT compiler may not generally have any idea that the code being compiled is an instrumented version rather than an original version. Rather the JIT compiler simply proceeds with the compilation of the instrumented version of the code. In various embodiments application code may include metadata which includes offsets to methods and functions included therein. When profiler instruments code such offsets may generally be changed. Therefore the instrumented code metadata generated by the profiler may include a mapping of original offsets to new offsets.

During execution a monitoring component of the profiler may monitor the execution of processes for behavior of interest e.g. latencies . Should a particular service be identified as one exhibiting a given behavior profiler may then identify other services utilized by the particular service for recompilation. In one embodiment one or more calls similar to ICorProfilerInfo SetFunctionReJIT may be made with an identification of the corresponding functions in order to cause the desired recompilation. In addition the profiler may store an indication that the corresponding functions are to be instrumented. For example recompile unit may be configured to determine whether or not a given function method is to be instrumented. Recompile unit may further maintain a list of those which have already been instrumented. Depending upon the particular configuration those which have already been instrumented may or may not be removed from the recompile instrument list. Responsive to the recompilation indication the profiler may receive a compilation started indication. The profiler then determines whether the particular method is to be instrumented. If instrumentation is indicated the profiler instruments the code and the instrumented version is passed to compiler as described above. Monitoring may then continue with further recompilations as necessary.

In one embodiment the profiler may first allocate new space for the method body which is to be modified block . However other embodiments may be configured to work directly on the method body itself rather than a copy. The profiler may then retrieve the method body e.g. using GetILFunctionBody and instrument the retrieved code block . The profiler may further set a pointer e.g. via SetILFunctionBody to the method body to point to the newly modified version block . Setting a pointer in this manner may have the effect of directing the compiler to the instrumented code for compilation. In addition the profiler may modify corresponding metadata to identify the location of the instrumented version block . It is to be understood that the activities depicted in may occur in an order other than that depicted and one or more may occur concurrently. In addition other embodiments may utilize more or fewer activities as appropriate.

In one embodiment a separate configuration file may be utilized by the profiler which indicates how and when instrumentation may be performed. For example static instrumentation could be performed for specified DLL s while dynamic instrumentation could be reserved for only those DLL s in a global assembly cache GAC . All such combinations of static and dynamic instrumentation and use of configuration files are contemplated. In addition to the above a mode is contemplated wherein a profiler or instrumenter may observe operation of a specified code. During the observation made data may be stored which identifies various characteristics of the code being observed. Based upon the gathered characterizing data decisions may be made as to what portions of code may be instrumented. Such decisions could be made manually i.e. by a person viewing the gathered data and making corresponding entries in a configuration file or automatically. For example in one embodiment the decision as to whether a portion of code is to be instrumented could be made automatically based upon the nature of the code itself i.e. certain types of called functions or methods may have a higher priority for purposes of instrumentation the behavior of code during execution i.e. some methods are called a relatively large number of time and so on.

It is noted that the above described embodiments may comprise software. In such an embodiment the program instructions which implement the methods and or mechanisms may be conveyed or stored on a computer readable medium. Numerous types of media which are configured to store program instructions are available and include hard disks floppy disks CD ROM DVD flash memory Programmable ROMs PROM random access memory RAM and various other forms of volatile or non volatile storage.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

