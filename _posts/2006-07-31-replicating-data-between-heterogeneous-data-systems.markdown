---

title: Replicating data between heterogeneous data systems
abstract: A method and apparatus for replicating data between heterogeneous databases is provided. Data is replicated between two heterogeneous databases with the use of a volatile storage queue, enabling the rapid replication of data across databases provided by different vendors or operating on different platforms. According to one embodiment, an in-memory queue is used to queue change operations to be performed on a target data repository. The change operations may be operations that were applied to a source data repository. An apply process retrieves the change operations from in-memory queue and commits the change operations to persistent storage. When the change operations have been committed, the apply process notifies the source platform that the particular change operation has been stored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07668878&OS=07668878&RS=07668878
owner: Oracle International Corporation
number: 07668878
owner_city: Redwood Shores
owner_country: US
publication_date: 20060731
---
The present invention relates to data storage and replication. In particular embodiments of the present invention relate to replicating data between heterogeneous data systems.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

One use of a database management system DBMS is to ensure the security and integrity of mass amounts of data. Data repositories such as databases and file systems contain critical data for both individual users and enterprise businesses. Therefore ensuring the security and integrity of such data is a primary concern for individuals and enterprises alike.

Typically backup databases and file systems are created in order to ensure that data is not lost in the event of a failure of a database system. However when data is manipulated on a source database the change may not be immediately propagated to the backup database. Further many database platforms are available from different vendors. Users may wish to communicate data between databases provided by different database vendors. This is more commonly known as heterogeneous database replication. For example vendors may wish to replicate data between an Oracle database and a non Oracle database.

One drawback of existing database platforms is their inability to communicate with each other. Typically different database vendors engineer database management systems differently. As such it is not easy to replicate changes made on a database from one vendor to a database supplied by another vendor.

One replication approach involves taking the changes from the source database and storing them in some persistent storage such as a hard disk drive or other type of non volatile storage medium before applying them to the target database. However this approach has numerous drawbacks. First storing changes in persistent storage is a very slow process and limits the maximum data replication rate. For example persistent storage may only allow changes on the order of one operation per millisecond. If a large amount of data needed to be replicated from one database to another the process is even slower.

What is desired is a method for heterogeneous data replication that does not suffer from the drawbacks of previous approaches.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

An embodiment of the present invention is a method for replicating data between heterogeneous data systems. According to one embodiment data is replicated between two heterogeneous databases with the use of a volatile storage queue enabling the rapid replication of data across databases provided by different vendors or operating on different platforms. A platform provides the underlying operating system and components that allow database and file systems to operate on particular hardware such as servers or personal computers. For example such platforms include typical operating systems as provided by Microsoft Oracle and Linux.

According to one embodiment an in memory queue in volatile memory is used to queue change operations to be performed on a target data repository. The change operations may be operations that were applied to a source data repository. An apply process retrieves the change operations from the in memory queue and commits the change operations to persistent storage. When the change operations have been committed the apply process notifies the source platform that the particular change operation has been stored.

A source data repository is located on a source platform which includes a source capture agent. The source capture agent monitors a source journal which maintains a listing of any changes that have been made to the source data repository. The source capture agent queries the source journal to determine if a change has been made to the source data repository. Change data includes change transactions in the source journal and also includes any information necessary to replicate the change on a target repository. Further the source capture agent assigns a correlation ID for each data operation. Changes from a source repository are communicated to a target platform through intermediate components which perform data translation and normalization.

In order to apply the changes the change operation data is enqueued into an in memory queue on the target platform. The in memory queue is implemented within a volatile storage medium and thus allows for data to be replicated at a faster rate than persistent storage.

The target platform performs transactions against the target repository by reading the in memory queue. For example an apply process consumes changes from the in memory queue and applies them to persistent storage. However because the in memory queue is volatile if a crash occurs all change data in the in memory queue might be lost. However in order to avoid the loss of change data a correlation ID is associated with each change operation that has been enqueued into the in memory queue. Thus the target platform will keep track of all correlation IDs corresponding to changes that have been successfully applied to the target repository.

Further the source platform keeps data pertaining to the change transactions until the source platform receives an acknowledgment that the target platform has applied the change to the target repository or other type of persistent storage. Although the method has been described in relation to the replication of data between heterogeneous data systems the method is not limited to such an embodiment and may be applied to other uses such as for example auditing change data capture and asynchronous event notification.

Referring now to a system for replicating data between heterogeneous data systems is shown in accordance with one embodiment. The system includes a source platform and a target platform . According to one embodiment both source platform and target platform are database managements systems provided by different database vendors. Further source platform and target platform are used to manage source repository and target repository respectively.

Heterogeneous replication system replicates relevant changes in source repository to target repository . In order for replication to occur between the heterogeneous platforms components are located at source platform and Target Platform .

Source platform includes a Source journal and a source Capture Agent . According to one embodiment source platform is a Database Management System DBMS provided by a particular vendor. Source platform may be an interface for communicating to and editing a source repository . In other embodiments source platform may be a database server for managing source repository through the Internet.

Source platform keeps track of changes made to source repository through use of source journal . Source journal tracks incremental changes to source repository . Thus each time a change is made to data within Source repository an entry is made into source journal identifying the change the location of the change and any operation that may have completed to institute the change. In other embodiments other data may be communicated to source journal . Further source journal may query source repository to determine what changes if any have been made. Source journal keeps track of changes made to source repository in an incremental manner. For example changes made to source repository may be made in step by step incremental changes such that each change is a sequence of operations performed against source repository .

According to one embodiment source journal is a redo log of a typical database system. Redo logs are common in database systems. Redo logs record all changes made to a database as a sequence of operations to be performed against the database. When performed in sequence the operations cause the identified changes to be committed to the database. Redo logs are used where a database encounters a failure before a change has been completed on a database. Thus if data is lost the database system can consult the redo log to determine which operation it should perform next to recover the lost data. However the invention is not limited to database systems and source journal may be used to keep track of any changes made to any type of file system such as a hard disk drive. For example in one embodiment source repository may be a file system containing a log of changes. In such an embodiment the file system log would be equivalent to source journal . Examples of such file systems include but are not limited to the Reiser File System ReiserFS and the third extension file system EXT3 both well known in the art.

Thus source journal keeps track of changes made to source repository in sequence. In order to maintain the sequence of change operations through transfer of data from source platform to Target Platform each operation performed against source repository to institute a change is assigned a change sequence identifier. According to one embodiment the change sequence identifier is a monotonically increasing value assigned to each change operation within source journal .

When source Capture Agent transfers this change operation data to Target Platform the change sequence identifiers for each change operation remain intact. Therefore even though the format of the data may change the change sequence identifier for each change operation allows Target Platform to apply change operations in sequence to Target repository to perform error handling and to reduce data redundancy.

According to one embodiment the change sequence identifier is referred to herein as the correlation ID. Each change operation includes a correlation ID. Therefore the sequential order of each operation applied to source repository is kept intact when communicated to Target Platform . Further Target Platform may use the correlation ID of each operation to acknowledge that the operation has been applied to Target repository . Further when source platform communicates the change transaction data to Target Platform the data includes the correlation ID of each transaction in order for Target Platform to correctly apply the transactions in sequence. In order to ensure that Target Platform does not apply the same change more than once or in some cases miss a change entirely a single change maintains the same correlation both before and after a restart or crash event. Because the same change maintains the same correlation ID Target Platform can ensure that target platform has not applied the same change twice. Further according to one embodiment the correlation ID may be represented as binary data. In order to ensure consistency across the source and target platforms both the target and source agree on the sorting order of the binary data representing the correlation ID of each change. One such method is to use platform independent binary sort or numeric based comparison. In this manner organization of change transactions by correlation ID is achieved ensuring that changes are applied to Target repository in the desired order.

Source Capture Agent monitors source journal for changes. When a new entry is placed into source journal source Capture Agent can determine that a change has been made to the source data repository. However unlike source journal source Capture Agent does not need to keep track of every change made to source repository . Instead when source Capture Agent detects that source journal has changed source capture agent can extract relevant data. Thus source capture agent may act as a filter for determining which change operation data should be accounted for during replication of data between source repository and target repository . According to other embodiments source capture agent periodically queries source journal to determine if any changes have been made to source repository .

Further as described above to ensure that change operation data is fully accounted for source Capture Agent associates a correlation ID to each change operation in order to track the progress of changes on target platform . For example when target platform actually applies the transaction that the correlation ID represents source capture agent can purge the change data which represents the transaction from source journal . In this manner the storage of duplicated or unneeded data is avoided.

At first the format of the data in source journal may be native to source platform . In order to ensure that change data can be communicated to target platform source capture agent is responsible for converting the format of the change operation data into a non native or open format which target platform understands. According to one embodiment the open format is an intermediate data format known as the Attunity Change Format. In another embodiment the intermediate format of the change data is in the Extensible Markup Language XML . XML is a platform independent language for communicating structured and non structured data. The XML data may contain a number of fields some which may be used for communicating the change transaction data between the source and target data repositories. For example in order to preserve the order of change transactions across the source and target databases the XML data may include an operation sequence identifier such as a correlation ID.

Source platform can communicate data to target platform or a Change Router A discussed below using an open format such as XML. Source platform can communicate the change operation data to target platform in a non native format.

According to one embodiment source capture agent communicates change operation data to change router A which may be located on target platform . Change Router A is responsible for receiving change operation data from source capture agent and assembling change transactions. Using the correlation ID associated with each change operation change router A produces transaction based change data for committed changes in transaction commit order.

Eventually heterogeneous capture agent C will format the change transactions for consumption by target platform . According to one embodiment source capture agent and change router A communicate via any appropriate communications interface such as an Ethernet interface connected to a network such as the Internet. Source capture agent communicates change operation data to source platform which forwards the data to change router A for processing. In other embodiments change router A may query source capture agent periodically to retrieve data that change router A has not yet processed. Accordingly source capture agent and change router A may operate under a pull or push model for communicating data.

Transformer B is responsible for performing normalizations of data for data that may not transfer identically from a source to a target repository. One example would be when a non relational to relational mapping is performed. In other embodiments change operation data may not need to be normalized and therefore the Transformer B may be bypassed.

According to one embodiment change router A transformer B and heterogeneous capture agent C are all part of target platform . However in other embodiments change router A transformer B and heterogeneous capture agent C may be part of an intermediate component operating between source platform and target platform and may be independent from either system.

Change router A produces the transaction based change data. According to one embodiment only committed changes are recorded in transaction commit order. Therefore the integrity of the data is kept at both ends.

Heterogeneous capture agent C receives change transaction data from change router A. The change transaction data may initially be in an intermediate format and heterogeneous capture agent C converts the data into a format native to target platform . According to one embodiment heterogeneous capture agent C gets the change transaction data from change router A performs any necessary data format and data type conversions and constructs Logical Change Records LCRs representing the change transactions. According to one embodiment an LCR is a type of message included as part of the Oracle Call Interface OCI . The OCI allows developers to program components to call upon Oracle processes through the OCI Application Programming Interface API . Thus the OCI allows comprehensive access to Oracle database operations. LCR messages identify change operations to be performed as part of a change transaction on a repository and include a correlation ID for referencing each change operation.

Once heterogeneous capture agent C has formatted the change operation data into LCRs heterogeneous capture agent C pushes the LCRs into an in memory queue using an enqueue operation which is an operation available to heterogeneous capture agent C through the Oracle OCI API. In another embodiment heterogeneous capture agent C can enqueue non LCR messages. For example heterogeneous capture agent C may enqueue control messages for indicating important events from source journal . These control messages may be passed on to an apply process such that when apply process consumes the message from queue apply process can determine that such an event has occurred. For example one such event may be a crash reset or any other type of event that may have occurred on source repository .

For each LCR that is enqueued into In memory queue heterogeneous capture agent C keeps track of the unique correlation ID associated with the LCR. Thus heterogeneous capture agent C can store both the correlation ID of the last enqueued LCR and the correlation ID of the last consumed LCR in memory. Alternatively the correlation ID for the latest consumed LCR may be stored on persistent storage. This way the system may maintain knowledge of the last LCR to be committed to target repository even after a failure or crash of target platform .

As described above heterogeneous capture agent C pushes LCRs into In memory queue . In memory queue acts as a staging area for changes that have yet to be consumed by apply process or applied to target repository . Because In memory queue is a queue each change transaction is consumed in a sequential order. Further LCRs in queue may collectively represent an entire transaction to be applied to target repository . Each transaction may have an ordered list of LCRs and may be represented by a correlation ID. Further each transaction may have an associated transaction ID. According to one embodiment the last LCR in each transaction is a commit LCR which when processed by apply process causes the entire transaction to be committed to target repository . In other embodiments other methods may be used to indicate the end of a transaction. For example an LCR may include a certain number of bits. In order to indicate the end of transaction the last bit within an LCR may be set to indicate the end of the transaction. Further in another embodiment apply process can detect changes in the correlation IDs for the subsequent LCRs. Because LCRs within the same transaction are bound to a particular correlation ID the LCRs will not be applied until all changes of the particular transaction have been consumed or processed by apply process . Further in some situations it may be advantageous to artificially advance the restart point for enqueueing LCRs. Thus heterogeneous capture agent C can send empty transactions to In memory queue so that the correlation ID can be advanced. Because the correlation ID has been advanced the restart time for enqueueing LCRs will be set at a later correlation ID and source journal may be purged of all transactions associated with preceding correlation IDs. When heterogeneous capture agent C enqueues any given LCR heterogeneous capture agent C stores the correlation ID of the last enqueued LCR into memory. Source platform can use this information to determine which changes have been queued for consumption in target platform .

Further the enqueueing of LCR in the in memory queue may be monitored for flow control. If the enqueueing of the LCRs is taking up too many resources then heterogeneous capture agent can be forced to wait and or given an error which will trigger heterogeneous capture agent C to control the flow of LCRs enqueued into Queue . Flow control is typically associated with situations where the consumption of messages is slower than the corresponding production of the same messages. Thus in such cases if the producer such as source journal is not slowed down by such a flow control mechanism then heterogeneous capture agent C may receive more messages than heterogeneous capture agent C can handle causing an overflow of system resources which can deter performance. Therefore a flow control mechanism may be used to control the flow of messages from source platform to target platform . Alternatively another process which may be used to reduce pressure on system resources involves spilling particular LCRs to persistent storage. When spilled to persistent storage the messages may be acknowledged to heterogeneous capture agent C without affecting the performance of in memory queue .

LCRs in in memory queue are consumed by apply process . Apply process is responsible for retrieving LCRs from in memory queue determining whether to ignore or commit the change operations to target repository and keeping track of the correlation IDs for the last consumed LCRs. When apply process commits a change operation represented by an LCR the change becomes part of persistent storage and the change has been replicated from source repository to target repository . Because the LCRs are located in in memory queue as opposed to persistent storage apply process can consume more change operations in a relatively short time frame. Therefore the quick replication of data between heterogeneous repositories is enabled. Further besides or in addition to apply process in memory queue can have multiple apply subscribers. Thus changes on source repository may be applied against multiple databases. For example heterogeneous capture agent C may recognize that a particular message is to be applied to a second target repository. Therefore such a message may be enqueued in a different in memory queue reserved for the second target repository. In this manner messages in in memory queue may be moved to other queues on the same or different platforms. Hence the system may be used to delegate LCRs among multiple subscribers or platforms.

Essentially apply process will selectively consume a large number of LCRs commit transactions to disk and acknowledge to source platform that apply process has consumed LCRs up to a particular correlation ID. Further in another embodiment apply process has the intelligence to compute the dependency for LCRs within in memory queue and to apply independent transactions in parallel.

However in memory queue is volatile by nature. Therefore if a failure happens at any stage change transaction data may be lost. In order to provide a safeguard against the duplication of change transactions after a failure apply process will acknowledge all transactions that apply process has processed by sending an acknowledgement ACK that includes the correlation ID of the last consumed LCR. However although apply process will consume each LCR apply process does not necessarily need to commit or perform the transaction represented by the LCR. As such apply process may ignore the LCR and merely acknowledge that apply process has encountered the change operation but decided to ignore the change operation. For example if the transaction is one that is not needed to institute the change on target repository then apply process may ignore the LCR in this manner.

Referring now to a flow chart depicting a process for replicating data between two heterogeneous databases is shown in accordance with one embodiment. At step source capture agent detects a change in source journal . As discussed earlier source capture agent may be notified each time a change occurs within source journal or may alternatively poll source journal periodically to detect any changes. At step source capture agent filters through entries in source journal and converts the data into change operation data. The change operation data is in an intermediate format and includes a correlation ID for each operation. At step source capture agent then provides the change operation data to change router A located on target platform . Next at step change router A and heterogeneous capture agent C assemble change transactions from the change operation data and create LCRs representing each transaction. Each LCR is a message identifying an operation to be performed against target repository and each LCR has an associated correlation ID.

Once LCRs are created heterogeneous capture agent C pushes the LCRs into queue at step . According to one embodiment heterogeneous capture agent C pushes each LCR according to that LCR s correlation ID in an appropriate sequence into Queue . When each LCR has been placed into queue heterogeneous capture agent C acknowledges the correlation ID of the last LCR to be placed into the queue at step . According to one embodiment heterogeneous capture agent C stores information identifying the last enqueued LCR in memory.

Next at step apply process consumes LCRs from the queue . According to one embodiment apply process consumes LCRs by performing the appropriate transaction and committing the changes to target repository . In other embodiments apply process may ignore particular LCRs. For example apply process may ignore LCRSs if those LCRs are redundant or irrelevant.

Once apply process has consumed an LCR at step an acknowledgment of correlation ID for the last consumed LCR is sent from apply process to heterogeneous capture agent C which stores the acknowledgement in persistent storage. Because the information regarding the last consumed correlation ID is stored in persistent storage if a failure occurs any component can retrieve the last correlation ID from storage and begin re enqueing LCRs from that point.

In order to reduce the redundancy of data across both source platform and target platform source platform can periodically query target platform to determine which transactions have been processed and or applied to target repository .

Referring now to a flow chart depicting a process for purging change operation data from a source journal is shown in accordance with one embodiment. At step source platform queries target platform for the correlation ID of the last consumed change operation. In response at step source platform receives the correlation ID of the last consumed change operation. Although the change operation on target platform is in the form of an LCR the correlation ID allows source platform to locate the corresponding change operation within source journal . Using the last consumed change operation s correlation ID as a guide at step source capture agent can determine which correlation IDs have been consumed by target platform . Specifically because correlation IDs are assigned in sequence to each change transaction source platform can assume that all previous change transactions with correlation ID s lower in sequence have been consumed on target platform .

At step once it has been determined which correlation IDs have been consumed by target platform source capture agent purges all entries in source journal occurring at or before the last consumed correlation ID.

Although volatile storage enables enqueued transactions to be processed and applied more efficiently than those in persistent storage transaction data may be lost upon a failure of the target platform or source platform . Therefore according to one embodiment the system includes the ability to recover transaction data.

Two different correlation IDs may be used to institute a recovery during data replication. One is the last enqueued correlation ID which represents the last correlation ID to be enqueued into Queue . Another correlation ID which is provided back to source platform is the last correlation ID to be acknowledged by apply process . The last acknowledged correlation ID represents the last transaction which was either applied by apply process to persistent storage or the last correlation ID to be processed by apply process . Thus the last acknowledged correlation ID indicates that all changes associated with a correlation ID preceding the last acknowledged correlation ID have been either applied or spilled to storage. With this information heterogeneous capture agent C can determine that those change LCRs do not need to be resent upon restart.

In order to reduce the possibility of redundancy after a crash or failure of either platform the correlation ID of the last consumed LCR is stored in persistent storage. Therefore both platforms can be assured that at least those LCRs up to the last consumed LCR have been either committed to target repository or ignored by apply process . In the case of target platform crashing the correlation ID of the last enqueued LCR will be null because that LCR was stored in volatile memory. Therefore target platform can rely on the correlation ID of the last consumed LCR to begin re enqueing LCRs into in memory queue . Once the appropriate LCRs have been re enqueued target platform will have recovered and may continue with replication.

However in the case that source platform crashes during replication. Target platform may receive change operation data with a correlation ID for an LCR that target platform has already enqueued. Because target platform maintains the correlation ID of the last enqueued LCR target platform can determine that source platform has crashed and can discard any change operation data with correlation IDs occurring before the correlation ID for the last enqueued LCR.

Referring now to a flow diagram depicting a restart and recovery process is shown in accordance with one embodiment. For example target platform might crash during the replication of data to target repository . Under these circumstances the LCRs would have been in volatile Queue and the crash would wipe out LCRs that have not been a applied or consumed by apply process or b spilled into persistent storage. Therefore at step target platform restarts. When target platform restarts queue will be empty. In order to re enqueue LCRs that have been lost due to the crash target platform determines from which correlation ID to begin re enqueueing LCRs. Thus at step target platform determines the last correlation ID to be enqueued by the heterogeneous capture agent C. As described above if target platform crashes all volatile memory will become null and therefore the correlation ID of the last enqueued LCR will also be null. Therefore in order to determine where to begin re enqueueing LCRs at step target platform determines the last consumed correlation ID to be processed by apply process . At step heterogeneous capture agent C computes the reset point for the recovery. The reset point is a correlation ID from which to begin re enqueing LCRs. From the reset point any LCRs with a correlation ID after the reset point will be re enqueued by heterogeneous capture agent C into queue . In order to retrieve change data that might have been lost on target platform due to a failure change router A can ask source capture agent to resend back to change router A for processing any change operation data with correlation IDs that occur on or after the reset point. At step heterogeneous capture agent C requests the re delivery of LCRs that have correlation IDs at or after the reset point. Once LCRs have been re enqueued into in memory queue the recovery process is complete.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable medium as used herein refers to any medium that participates in providing data that causes a machine to operation in a specific fashion. In an embodiment implemented using computer system various machine readable media are involved for example in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications. All such media must be tangible to enable the instructions carried by the media to be detected by a physical mechanism that reads the instructions into a machine.

Common forms of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

