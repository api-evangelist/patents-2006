---

title: Leveraging back-off grammars for authoring context-free grammars
abstract: A system and method of refining context-free grammars (CFGs). The method includes deriving back-off grammar (BOG) rules from an initially developed CFG and utilizing the initial CFG and the derived BOG rules to recognize user utterances. Based on a response of the initial CFG and the derived BOG rules to the user utterances, at least a portion of the derived BOG rules are utilized to modify the initial CFG and thereby produce a refined CFG. The above method can carried out iterativey, with each new iteration utilizing a refined CFG from preceding iterations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08108205&OS=08108205&RS=08108205
owner: Microsoft Corporation
number: 08108205
owner_city: Redmond
owner_country: US
publication_date: 20061201
---
In general speech recognition applications allow users to interact with a system by using their voice. Typical command and control C C speech applications allow users to interact with a system by speaking commands and or asking questions restricted to fixed grammar containing pre defined phrases. While speech recognition applications have been commonplace in telephony and accessibility systems for many years only recently have mobile devices had the memory and processing capacity to support not only speech recognition but a whole range of multimedia functionalities that can be controlled by speech.

Furthermore the ultimate goal of the speech recognition technology is to be able to produce a system that can recognize with 100 accuracy all of the words that are spoken by any person. However even after years of research in this area the best speech recognition software applications still cannot recognize speech with 100 accuracy. For example most commercial speech recognition applications utilize context free grammars CFGs for C C speech recognition. Typically these grammars are authored to try to achieve broad coverage of utterances while remaining relatively small for faster performance. As such some speech recognition applications are able to recognize over 90 of the words when speakers produce utterances that fit within the constraints of the grammars.

Unfortunately despite attempts to cover all possible utterances for different commands users occasionally produce expressions that fall outside of the grammars e.g. out of grammar OOG user utterances . For example suppose the grammar is authored to anticipate the expression What is my battery strength for reporting device power. If the user forgets that expression or simply does not read the instructions and utters Please tell me my battery strength the speech recognizer will either produce a recognition result with very low confidence or no result at all. This can lead to the speech recognition application failing to complete the task on behalf of the user. Further if users unknowingly believe and expect that the speech recognition application should recognize the utterance the user would conclude that the speech recognition application is faulty or ineffective and cease from using the product.

In general due to the above noted problems a relatively long development cycle which typically involves a complex and costly grammar authoring process is required to get an application that utilizes CFGs to a relatively high speech recognition accuracy level.

The discussion above is merely provided for general background information and is not intended to be used as an aid in determining the scope of the claimed subject matter.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The claimed subject matter is not limited to implementations that solve any or all disadvantages noted in the background.

A method for relatively efficiently refining context free grammars CFGs in a CFG authoring process is provided. The method includes deriving back off grammar BOG rules from an initially developed CFG and utilizing the initial CFG and the BOG rules to recognize user utterances. Based on a response of the initial CFG and the derived BOG rules to the user utterances at least a portion of the derived BOG rules are utilized to modify the initial CFG and thereby produce a refined CFG. One example of how the BOG rules can be used to modify the initial CFG involves collecting data related to the manner in which the BOG rules handle out of grammar OOG utterances and selectively transcribing the collected data. The selectively transcribed data is then utilized to alter the initial CFG.

The above method can be carried out iterativey with each new iteration utilizing a refined CFG from preceding iterations. A speech recognition system that is capable of carrying out the above method is also provided.

Disclosed here are embodiments that provide improved techniques for authoring context free grammars CFGs which are utilized for speech recognition. Before providing descriptions of specific example embodiments a brief description that relates to certain general features of the present embodiments is provided.

As indicated earlier typically a CFG defines grammar rules which specify words and patterns of words to be listened for and recognized. Developers of CFG grammar rules attempt to cover all possible utterances for different commands a user might produce. Unfortunately despite attempts to cover all possible utterances for different commands users occasionally produce expressions that fall outside of the grammar rules e.g. out of grammar OOG utterances . When processing these OOG user utterances the CFG typically returns a recognition result with very low confidence or no result at all. Accordingly this could lead to the speech recognition application failing to complete the task on behalf of the user.

Generating new grammar rules to identify and recognize the OOG user utterances is desirable. By recognize it is meant that the OOG user utterance is correctly mapped to its intended CFG rule. Thus for augmenting a CFG s ability to process OOG utterances the present embodiments utilize a back off grammar BOG in combination with the CFG for speech recognition. The BOG can be a collection of grammar rules that are generated by combining slots and keywords for example from rules of the CFG. The default case is to generate back off rules for all CFG rules. Alternatively back off rules can be selectively generated based on a user model and or heuristics. It should be noted that more than one back off rule can be generated for a CFG rule depending on the number of constituent parts i.e. keywords or slots .

The CFG rules generally recognize user utterances with better performance e.g. speed than the BOG rules but can have difficulty processing OOG user utterances. Specifically the CFG rules constrain the search space of possible expressions such that if a user produces an utterance that is covered by the CFG rules the CFG rule can generally recognize the utterance with better performance than BOG rules with filler tags for example which generally have a much larger search space. However unrecognized user utterances e.g. OOG user utterances can cause the CFG rules to produce a recognition result with lower confidence or no result at all as the OOG user utterance does not fall within the pre conscribed CFG rules. Whereas the BOG rules employing the re written grammar rules can typically process the OOG user utterance and produce a recognition result with much higher confidence. Thus example embodiments utilize the CFG rules to process the user utterance as a first pass since as noted above the CFG rules generally perform better on computationally limited devices. If the user utterance is an OOG user utterance it is processed with the BOG rules as a second pass.

In the above example two pass approach in addition to being able to take advantage of the BOG for handling OOG expressions it is also possible to collect data related to utterances that different BOG rules were able to capture and to utilize this data to modify CFG rules. In general a BOG generated from a CFG can be used within an iterative authoring process to improve refine the CFG. which a described below are example embodiments for refining a CFG using a BOG.

In general the present embodiments utilize BOG rule statistics to selectively transcribe user utterances. The BOG rule statistics used can relate to how frequently different BOG rules were considered as a top recognition i.e. which BOG rules handled the most utterances . Alternatively the BOG rule statistics can relate to how successful or unsuccessful different BOG rules were in handling particular OOG user utterances.

As indicated above the BOG rule statistics or the portion of user utterances selected for transcription can either be manually or automatically transcribed. The automatic transcription of selected user utterances can be carried out using any suitable automatic transcription method such as by employing a dictation grammar denoted by reference numeral in . It should be noted that instead of a dictation grammar any other wider coverage language model relative to the CFG can be employed.

Similarly the CFG may either be manually or automatically altered using the selectively transcribed user utterances. Automatic adjustment of the CFG can be carried out using minimal edit distance techniques denoted by reference numeral in for example. In general any suitable method for automatically adjusting the CFG based on selectively transcribed user utterances can be employed. An example illustrating the formation of an initial CFG the generation of a BOG from the initial CFG and the subsequent modification of the initial CFG is provided below. This example builds on the earlier example related to grammar rules for reporting device power.

As noted above CFG rules can define grammar rules which specify the words and patterns of words to be listened for and recognized. In general the CFG rules can include at least three constituent parts carrier phrases keywords and slots. Carrier phrases are text that is used to allow more natural expressions than just stating keywords and slots e.g. what is tell me etc. . Keywords are text that allow a command or rule to be uniquely identified or distinguished from other commands or rules. The keyword represents a semantic attribute or concept for the grammar rule. For example the keyword battery appears only in the grammar rule or concept for reporting device power. Slots are dynamically adjustable lists of text items such as etc. where the list represents a semantic attribute and the items represent a semantic value for the attribute.

Although all three constituent parts play an important role for recognizing the correct utterance only keywords and slots are critical for selecting the appropriate command. For example knowing that a user utterance contains the keyword battery is more critical than whether the employed wording was What is my battery strength or What is the battery level Keywords and slots can be automatically identified by parsing the CFG rules. Typically slots are labeled as rule references and keywords can be classified using heuristics such as keywords are words that only appear in one command or only before a slot. Alternatively besides automatic classification slots and keywords can be labeled by the grammar authors themselves.

As noted earlier developers of the CFG rules attempt to cover all possible utterances for different commands a user might produce. Unfortunately despite attempts to cover all possible utterances for different commands users occasionally produce expressions that fall outside of the grammar rules e.g. OOG utterances . For example if the CFG rules are authored to anticipate the expression What is my battery strength for reporting device power then a user utterance of Please tell me my battery strength. would not be recognized by the CFG rules and would be delineated as an OOG utterance. Generally the CFG rules can process the user utterances and produce a recognition result with high confidence a recognition result with low confidence or no recognition result at all.

A fist stage in developing a BOG can involve identifying keywords and or slots of the CFG by parsing the CFG rules. After the keywords and or slots are identified filler tags can be added before and or after the keywords and or slots to create new grammar rules. Filler tags can be based on both garbage tags and or dictation tags. Garbage tags e.g. or . . . in a speech API look for specific words or word sequences and treat the rest of the words like garbage. For example for a user utterance of What is my battery strength the word battery is identified and the rest of the filler acoustics are thrown out. Dictation tags e.g. or in a speech API SAPI match the filler acoustics against words in a dictation grammar. For example a CFG rule for reporting device power What is my the battery strength level can be re written as . . . battery . . . or battery in a new grammar rule. Alternatively new grammar rules can also be based on phonetic similarity to keywords instead of exact matching of keywords e.g. approximate matching . Accordingly BOG rules can be generated based at least in part on the combination of these new grammar rules. The new grammar rules comprising the BOG rules can then be employed for identifying and recognizing OOG user utterances.

For example the above CFG rule What is my the battery strength level can fail to recognize the utterance Please tell me how much battery I have left. Whereas the re written grammar rules . . . battery . . . and battery of the BOG rules can produce a recognition result with much higher confidence. In fact the dictation tag rule of the BOG rules can also match the carrier phrase Please tell me how much and I have left. The OOG utterance and the matched carrier phrases can be saved and in accordance with the present embodiments utilized to modify the CFG by selective incorporation into the initial CFG. A very simple example can involve selecting the carrier phrases Please tell me how much and I have left from the saved data and directly adding these phrases to the initial CFG. Of course most applications require much more complex selective transcription of data and incorporation of the selectively transcribed data for modifying a CFG.

In summary the above example embodiments generate and utilize BOGs keep statistics on how BOG rules handle failed utterances examine the statistics to selectively transcribe most frequently occurring utterances for example and adjust the CFG either manually or automatically. As noted above this process typically involves iteratively adjusting the CFG.

It should be noted that the above embodiments provide only a few examples for choosing utterances for transcription. However one skilled in the art should recognize that there are numerous possible ways of deciding which utterances to selectively transcribe.

The above described embodiments allow developers to deploy applications relatively quickly allow applications to handle OOG utterances that would otherwise have been dropped and reduce transcription cost by facilitating selective annotation of failed utterances based on BOG statistics.

The present embodiments operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the present embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

The present embodiments may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The present embodiments are designed to be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules are located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the present embodiments include a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer is operated in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Memory is implemented as non volatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is preferably allocated as addressable memory for program execution while another portion of memory is preferably used for storage such as to simulate storage on a disk drive.

Memory includes an operating system application programs as well as an object store . During operation operating system is preferably executed by processor from memory . Operating system in one preferred embodiment is a WINDOWS CE brand operating system commercially available from Microsoft Corporation. Operating system is preferably designed for mobile devices and implements database features that can be utilized by applications through a set of exposed application programming interfaces and methods. The objects in object store are maintained by applications and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

Communication interface represents numerous devices and technologies that allow mobile device to send and receive information. The devices include wired and wireless modems satellite receivers and broadcast tuners to name a few. Mobile device can also be directly connected to a computer to exchange data therewith. In such cases communication interface can be an infrared transceiver or a serial or parallel communication connection all of which are capable of transmitting streaming information.

Input output components include a variety of input devices such as a touch sensitive screen buttons rollers and a microphone as well as a variety of output devices including an audio generator a vibrating device and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition other input output devices may be attached to or found with mobile device within the scope of the present embodiments.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

