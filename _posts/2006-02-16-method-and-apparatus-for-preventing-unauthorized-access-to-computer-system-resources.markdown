---

title: Method and apparatus for preventing unauthorized access to computer system resources
abstract: A system is provided to prevent unauthorized access to computer system resources. The system operates by receiving a section of programming language code to execute on a computer system. This programming language code includes a pragma that defines a set of resources that the programming language code has permission to access. The system analyzes the pragma to determine the set of resources. After analyzing the pragma, the system processes the programming language code in accordance with the pragma. The system can further process the program in accordance with the pragma involves creating a sandbox that includes the set of resources defined by the pragma. The system then executes the programming language code within the boundaries of the sandbox.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07702692&OS=07702692&RS=07702692
owner: Oracle International Corporation
number: 07702692
owner_city: Redwood Shores
owner_country: unknown
publication_date: 20060216
---
The present invention relates to computer system security. More specifically the present invention relates to a method and an apparatus for preventing unauthorized access to computer system resources.

Databases commonly store highly sensitive data such as salaries corporate financial data and even classified military secrets. Consequently database systems are typically designed to prevent unauthorized accesses to sensitive data. This problem is compounded by the fact that middle tier applications often access a database on behalf of various users. Consequently the database system must often rely on applications to provide access control mechanisms. Although applications that access databases typically ensure that a given query originates from an authorized user many of these applications are vulnerable to a form of attack known as SQL injection. 

During a Structured Query Language SQL injection attack a hacker provides an input to an application which includes an SQL statement. In doing so the hacker knows that the application will incorporate this input which includes the SQL statement into a query and that the SQL statement will cause the query to retrieve data which is different from the data that the application intended to retrieve.

SQL injection attacks come in many forms. In a common SQL injection technique a hacker inserts code into a SQL statement which is intended to return a set of rows R in a set of tables T. However because of the inserted code instead of returning R the database returns a set of rows R in a set of tables T where T is a superset of T.

Another technique employed by hackers to gain control of a system is a buffer overflow attack. The buffer overflow attack is typically aimed at programs written in the C or C programming languages. During a buffer overflow attack a hacker causes a buffer overflow by sending more information to a program than the program can handle. After the buffer overflow occurs the hacker can then use various tricks to gain control of a computer system. For example buffer overflow attacks are commonly used by a hacker to invoke arbitrary programs such as a shell program as a privileged user.

Hence what is needed is a method and an apparatus for preventing unauthorized access to computing resources without the problems listed above.

One embodiment of the present invention provides a system that facilitates preventing unauthorized access to computer system resources. The system operates by receiving a section of programming language code to execute on a computer system. This programming language code includes a pragma that defines a set of resources that the programming language code has permission to access. Note that a pragma is an instruction to a system or a compiler that enables special features or provides processing help to the system or compiler while processing associated bits of code. Since pragmas are ignored by systems that do not understand them pragmas are extremely useful because they provide additional flexibility and functionality while not breaking systems that do not understand the pragmas. The system analyzes the pragma to determine the set of resources. After analyzing the pragma the system processes the programming language code in accordance with the pragma.

In a variation on this embodiment processing the program in accordance with the pragma involves creating a sandbox that includes the set of resources defined by the pragma. The system then executes the programming language code within the boundaries of the sandbox.

In a further variation executing the programming language code within the boundaries of the sandbox involves determining if the programming language code is attempting to access a resource outside of the boundaries of the sandbox. If so the system throws an exception.

In a variation on this embodiment processing the programming language code involves interpreting the programming language code at run time.

In a variation on this embodiment processing the programming language code involves compiling the programming language code into executable code. In doing so the system compiles the executable code in a manner such that the executable code can only access the set of resources defined by the pragma.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus the present invention is not intended to be limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. This includes but is not limited to magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs and DVDs digital versatile discs or digital video discs .

Computer can generally include any type of computer system including but not limited to a computer system based on a microprocessor a mainframe computer a digital signal processor a portable computing device a personal organizer a device controller and a computational engine within an appliance.

Network can generally include any type of wired or wireless communication channel capable of coupling together computing nodes. This includes but is not limited to a local area network a wide area network or a combination of networks. In one embodiment of the present invention network includes the Internet.

Database can include any type of system for storing data in non volatile storage. This includes but is not limited to systems based upon magnetic optical and magneto optical storage devices as well as storage devices based on flash memory and or battery backed up memory. Database includes tables and .

As mentioned previously Structured Query Language SQL injection is a common technique that allows hackers to subvert access control mechanisms and to access confidential data stored in a relational database such as database . Most existing solutions for dealing with SQL injection techniques are only aimed at detecting whether a SQL injection attack has already been executed. They typically do not prevent the attack. With the sensitive nature of many data sets this is simply unacceptable.

Another approach for detecting SQL injection is to store audit logs generated by a good workload and to compare these audit logs with audit logs generated during other execution sequences. Discrepancies are flagged as injection attempts.

Not only are these methods not sufficient to prevent SQL injection attacks but they also suffer from the following drawbacks 

Some existing systems and solutions have been designed to prevent SQL injection attacks but these solutions have drawbacks as well. The drawbacks of some of the solutions are listed below 

Note that dynamic SQL statements unlike static SQL statements are not embedded into the source code of a program. Instead dynamic SQL statements are stored in character strings input to or built by the program at run time. Dynamic SQL statements can be entered interactively or read from a storage medium.

As mentioned previously another technique employed by hackers is a buffer overflow attack. During such an attack the hacker can cause a buffer overflow by sending more information than a program can handle. The hacker can then use some tricks to gain control of a computer system.

There has been a lot of previous work aimed at detecting buffer overflows. This work can be broadly classified into two categories 1 static analysis and 2 run time solutions.

In static analysis systems a compiler analyses the source code perhaps with the assistance of annotations made by the programmer and flags potential flaws. These annotations are usually hints to the compiler about the semantics of a function or the validity of pointers.

In one example of a run time solution a StackGuard generates machine code that includes built in tests that verify that the program stack has not been corrupted. Note that StackGuard is a compiler that generates binaries that incorporate code designed to prevent buffer overflow attacks. More information can be found at http citeseer.ist.psu.edu cowan98stackguard.html This incurs a run time overhead because the check is performed at every function call. Furthermore it can only catch a certain class of buffer overflow attacks.

Another approach involves modifying the operating system to prevent instructions from being executed from the data segment which is mapped read write and can hence be modified by the hacker . This solution is not comprehensive because a hacker can still modify the program flow to execute code that is already in the code segment. Other techniques which are less accurate analyze system call traces and look for anomalous patterns.

In one embodiment of the present invention SQL applications are sandboxed by constraining the set of database tables or more generally the database objects that can be accessed in a given scope. The narrowest scope is an SQL cursor. Some examples of broader scopes include an SQL procedure a package of procedures an application module that accesses multiple packages or ultimately a database session. Optionally each scope can be bracketed by the list of database tables that can be accessed within that scope. If a list is not specified the list of tables is simply inherited from the parent scope. In one embodiment of the present invention if the list of tables is not specified anywhere then the list is the set of all tables that the user has permission to access. Thus the default behavior when a list is not specified under any scope is the same as the current behavior which means that the database session can access all tables that the user has permission to access. As the scope narrows constraints are shifted from manual requirements supplied by a programmer to run time constraints handled by an embodiment of the present invention.

One embodiment of the present invention combines two existing ideas meta compilation and sandboxing to prevent an important subset of SQL injection and buffer overflow attacks. Meta compilation and sandboxing have been used to solve other unrelated problems. For example meta compilation of a programmer s annotations has been used in several program checkers. These checkers try to automatically identify bugs in source code. Sandboxing has traditionally been used to prevent code from accessing memory outside the boundaries of the sandbox.

For example in the PL SQL case the sandbox is checked when the system compiles a SQL cursor. Compiling a SQL cursor generates an execution plan for the SQL statement. The execution plan includes among other information a list of database objects that are accessed to execute the SQL statement. At this point the system compares the list of objects to the list specified in the pragma. The system then starts the check from the narrowest scope and expands the check to the broader scope. While doing so the system looks for the pragma in the SQL statement itself or if the pragma is not specified in the statement checks the pragma in the procedure that is calling the statement or if the procedure does not have a pragma the package that contains this procedure and so on. A dynamic SQL statement is compiled once but during execution the system may access the objects hundreds or thousands of times. Because the system performs the pragma check during cursor compilation and not when the object is accessed the overhead is reduced.

Note that PL SQL is Oracle Corporation s procedural wrapper over SQL. While PL SQL is described in detail in one embodiment of the present invention embodiments of the present invention can use any procedural wrapper over SQL such as Transact SQL T SQL .

In one embodiment of the present invention meta compilation is used to generate a set of objects that can be accessed within a given scope. At run time an access error is generated if an object that does not belong to this set is accessed within the given scope. Thus the program is sandboxed and the boundaries of the sandbox are determined by the scope and the set generated by the meta compilation. Unlike StackGuard the access check is performed only when accessing coarse granules of data such as database objects or tables and operating system files. Hence the run time overhead is negligible.

For example in the operating system case the system needs a new interface to register the pragma with the OS kernel or the OS system call interface. This registration can be a new system call or an extension to an existing system call such as ioctl . The registration is performed after the OS has loaded dynamic linked libraries DLLs from the privileged directories but before the program s main routine is about to execute. The OS can then associate the pragma with this process and any child process that may be forked by the process. When the program issues a file system open call the OS can check the complete path for the file being opened against the path specified in the registration. Because the system performs the check only during file open and not when the file is accessed the overhead is reduced.

Note that in one embodiment of the present invention the pragma is interpreted at run time by an interpreter. In another embodiment of the present invention the pragma is a compilation directive that instructs a compiler to handle appropriate permissions of the application at compile time.

In one embodiment of the present invention it is sufficient to place the sandbox for an entire package where a package is a collection of procedures. This is illustrated in . Allowing wildcard expressions makes it easier to specify a sandbox including multiple tables. For example a programmer may specify a pragma that allows access to all objects in a particular schema. For example the following pragma creates a sandbox of all tables in the APPS schema 

In one embodiment of the present invention a package may have a particular sandbox for the scope of the package but a specific procedure may need access to an additional table. In this instance the system allows additional objects to be added to the sandbox for the duration of the scope of this procedure. The following adds the customer table to the sandbox 

The previous examples have illustrated the idea using PL SQL procedures. However note that the present invention can be easily extended to any programming language by creating an Application Programming Interface API to push and pop sandboxes. In one embodiment of the present invention this API is implicitly invoked from the PL SQL run time engine. By contrast a middle tier application such as a Java DataBase Connectivity JDBC application can use the push and pop APIs to establish sandboxes explicitly. The disadvantage with this approach when compared to the implicit PL SQL approach is that a programmer may incorrectly not pop the sandboxes when the scope is exited abnormally.

As mentioned previously it is theoretically possible to achieve the same access control by switching roles dynamically. In this technique the programmer uses the SET ROLE command to dynamically switch roles. However the drawback of this technique is that the number of roles will quickly proliferate and become unmanageable. A new role should be created for every unique combination of tables that a procedure or cursor may need to access. The number of roles will be very large for a complex application. Consequently complex applications login to the database as super users and manage all access control within the application rather than relying on database users. Unfortunately this exposes the application to SQL injection because all the data is accessible by the super user.

In contrast sandboxes can be considered as lightweight roles which a programmer can easily annotate. The pragmas are added in the neighborhood of the code that is sandboxed and does not require administrator intervention.

Applications written in C C or other systems programming languages and that run on top of an Operating System OS can also be sandboxed. The difference between these applications and SQL applications is that the objects being sandboxed are operating system files and directories. In one embodiment of the present invention the pragmas for the list of files and directories that can be accessed by the application can either be specified in a configuration file or when the program is compiled into a binary. Most operating systems need access to system files before the application s main entry point. For example loader routines may be invoked before the main entry point of the application. Consequently the sandbox is effective only after the application s main function is called. Similarly the sandbox is deleted after the application s exit function is called because system cleanup routines may need access to privileged files. Fortunately the main entry and exit points are very well defined.

Unlike SQL applications sandboxes for OS applications are effective for the duration of the application code s execution. Typically finer scopes will not be useful. The reason for this is that non local GOTOs created by exceptions will make the sandbox restoration process error prone.

Sandboxing the set of directories and files that an OS application will access is useful because there are many applications that need to run as the OS root or super user. For example an OS application may need to access a privileged networking port less than 1024. However these OS applications typically do not need access to all the files in the system. For example the finger daemon needs access only to a user s profile files. There is no need for the finger daemon to access the bin sh file. Sandboxing the application will prevent a hacker from obtaining a shell as the root user.

A server needs access only to the files under the home directory and the root directory of the database files. All other files can be sandboxed for the oracle program. Like SQL applications wildcards will make it easier for the programmer to specify the sandbox. For OS applications the sandbox parameters are the designations of OS files and directories.

Note that in step the system may take additional measures besides terminating execution of the code. In one embodiment of the present invention the system throws a security exception and notifies an administrator such as user that a security exception has been thrown. In another embodiment of the present invention the program continues to execute in a more restrictive manner.

One advantage of the present invention is that it prevents an important class of injection and buffer overflow attacks where a hacker is able to access data that the program was not intended to access. There is no post mortem analysis for detection the problem is prevented before it occurs. The run time overhead is negligible because the sandboxes are set up at a coarse level and only need to be checked when a heavyweight operation such as compiling a cursor or opening a file is performed.

The foregoing descriptions of embodiments of the present invention have been presented for purposes of illustration and description only. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims.

