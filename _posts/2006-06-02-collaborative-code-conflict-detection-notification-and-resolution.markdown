---

title: Collaborative code conflict detection, notification and resolution
abstract: A computer code conflict notification and resolution technique that provides a collaborative programming environment for conflicts management is presented. The technique detects potential conflicts and provides facilities that allow programmers to work collaboratively to resolve the conflicts as they occur. This includes the ability to conduct a code session in which conflicting code elements are compared and changed as needed to resolve conflicts. In addition, in-place audio/video, text chat and application sharing is provided. This allows communication sessions to be conducted within the programming environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08407670&OS=08407670&RS=08407670
owner: Microsoft Corporation
number: 08407670
owner_city: Redmond
owner_country: US
publication_date: 20060602
---
Software is often developed by a team of programmers rather than an individual. This is especially true for complex software programs. In these team based development projects it is known that a large number of concurrent changes are often made to the same file and even the same line by different programmers over the course of the project. A correlation has been found between the amount of this concurrent activity and defects in a file despite the use of state of the art version control validation and testing mechanisms to find and fix conflicting changes.

One way of addressing this conflict issue is to foster an increase in collaboration and related communication among the members of the project team. However collaboration among team members is often difficult to achieve even for a team that is co located. It is even a greater challenge when the project team is geographically and or temporally dispersed as is often the case.

Collaboration between team members can be increased using a communication network and computer based integrated development environment IDE tools. These types of tools operate across a network in a distributed fashion on each team member s computer and allow the project team members to communicate with each other while working on a software project. However these existing tools have several limitations. For example conflicts are detected when a programmer checks in a set of changes not when the changes are made. In addition when two users make conflicting changes the person checking in later to a version control system is responsible for repairing the conflict even though it might be more efficient for the earlier person to make the required changes. Still further existing version control systems are typically text based and conflicts are detected and repaired at the line level.

The present computer code conflict notification and resolution technique detects potential conflicts and provides facilities that allow programmers to work collaboratively to resolve the conflicts in a network based environment at the time the conflicts occur. It is not necessary to wait until code is checked in to discover the conflicts if indeed they are even apparent at that point. In regard to conflict detection and notification a list of program elements associated with a software development project is maintained. More particularly this is a list of program elements that have been previously edited by a programmer. It is noted that a program element can be a file type e.g. either a class or interface or method. The network is monitored for incoming edit messages and they are input when received. An edit message is a message sent whenever a programmer begins changing a program element. It identifies the element being changed. When an edit message is received from another programmer it is determined if it identifies one of the program elements found in the list of edited elements. If it is found on the list the programmer receiving the edit message and the programmer who sent the message are both notified that a potential conflict exists.

In addition a list of program elements that are related to the elements found on the list of edited elements can be maintained. Program elements are considered related when a dependency exists between them and this dependency is not too far removed from the edited element. If the related elements list is maintained it is determined if a received edit message identifies a program element that is related to an edited program element. Whenever the edit message identifies a program element that is related to an edited program element the programmer receiving the edit message and the programmer who sent the message are notified that a potential conflict exists between these elements.

In regard to conflict resolution the present technique employs a graphical user interface GUI to display program elements to a programmer that have been deemed to be in a potential conflict with each other. In this way the programmer can work with the other remote programmer involved in the conflict to resolve the conflict. This is facilitated by in place communication tools and the ability to make changes to the displayed program elements during a code session. In a code session changes to the displayed program elements made by either programmer involved in a potential conflict can be input and used to update the elements.

It is noted that while the foregoing limitations in existing integrated development environment IDE tools described in the Background section can be resolved by a particular implementation of a computer code conflict notification and resolution technique according to the present invention this is in no way limited to implementations that just solve any or all of the noted disadvantages. Rather the present technique has a much wider application as will become evident from the descriptions to follow.

It should also be noted that this Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. In addition to the just described benefits other advantages of the present invention will become apparent from the detailed description which follows hereinafter when taken in conjunction with the drawing figures which accompany it.

In the following description of embodiments of the present invention reference is made to the accompanying drawings which form a part hereof and in which are shown by way of illustration specific embodiments in which the invention may be practiced. It is understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.

Before providing a description of embodiments of the present code conflict notification and resolution technique a brief general description of suitable computing environments in which portions thereof may be implemented will be described.

The present code conflict notification and resolution technique operates on a collaborative integrated development environment IDE system. This system when enhanced by the present technique combines presence information activity awareness information and interactive communication tools into a single environment that serves as a virtual software development complex for members of a development project team. The IDE system operates over a communications network such as an intranet or the Internet in a distributed fashion. Members of the project team perform their development activities using the IDE system.

In regard to the foregoing communications network is a diagram of a sample environment in which the present code conflict notification and resolution technique can be implemented. The exemplary communications network environment includes multiple programmers computers two of which are shown. One possible communication between programmer s computers may be in the form of a data packet adapted to be transmitted between two or more computer processes. The environment includes a communication network that can be employed to facilitate communications between the programmer s computers .

In regard to the foregoing computing devices used by project team members the present code conflict notification and resolution technique is operational with numerous general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Device may also contain communications connection s that allow the device to communicate with other devices. Communications connection s is an example of communication media. Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.

Device may also have input device s such as keyboard mouse pen voice input device touch input device camera etc. Output device s such as a display speakers printer etc. may also be included. All these devices are well know in the art and need not be discussed at length here.

The present code conflict notification and resolution technique may be described in the general context of computer executable instructions such as program modules being executed by a computing device. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The present code conflict notification and resolution technique may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

The exemplary operating environment having now been discussed the remaining parts of this description section will be devoted to a description of the program modules embodying the present code conflict notification and resolution technique.

The present code conflict notification and resolution technique generally provides a collaborative programming environment that supports conflict management. In a typical software development project the software design is architected into modules each module performing a particular set of functions related to the overall functionality of the product. Project team members are assigned responsibility to develop computer code that implements the functionality for each of the modules. In the development process team members write code compile and build the code test and debug the code and submit their code to a common source code control system SCCS . The process of submitting code into an SCCS is commonly termed checking in the code. At times during the development process multiple team members may unknowingly be working on the same or a related file type e.g. class or interface or method within a module. This can cause significant problems when for example the changes made by one programmer conflict with those made by another programmer.

As an example of such a conflict consider a software development project for a drawing tool. Assume that the current version of the project contains an abstract class AShapeWithBounds which represents a geometric shape with rectangular dimensions. The class declares four variables x y width and height which define the location and size of the shape. It also has the following constructor to initialize the variables 

Assume a first programmer is the one who created and checked in this class. A while after doing so the programmer realizes that the positions of the height and width parameters should be reversed. Therefore the first programmer has checked out the class from the SCCS and is about to correct the ordering. In the meantime a second programmer in the project team is adding a new subclass of AShapeWithBounds called ALine in a separate file. The constructor of the new subclass will call the constructor of the AShapeWithBounds class to initialize the coordinates and size of the bounding box of the line. As a result the two activities conflict with each other. It will be assumed that the programmers are unaware of each other s tasks and thus do not know they conflict. As the second programmer is unaware of the first programmer s change of mind the ALine constructor follows the parameter order of the base class constructor in the original version i.e. 

This code will not work correctly with the first programmer s new version of the base class constructor. When the version control system is relied upon to coordinate changes the earliest point at which a conflict can be detected is when a change is checked in for validation and testing. As the foregoing changes occur in two different files the version control system in fact cannot detect the conflict. In addition as the original and changed constructors have the same signature ALine will compile correctly with the new version of AShapeWithBounds and thus a build will also not catch the conflict. If appropriate testing is not done the error may not be detected prior to release of the code.

It is noted that this example is intended to aid in the understanding of the features provided by the present technique. However it is not intended to imply that the present technique is limited to the example scenario. Rather as will become apparent the present technique can be employed in any type of software development project.

The present code conflict notification and resolution technique provides a way to identify and collaboratively handle conflicts. More particularly the present technique detects potential conflicts and provides facilities that allow programmers to work collaboratively to resolve the conflicts prior to check in or testing. These facilities include but are not limited to providing awareness at granularity smaller than the file e.g. type and method using both method and type dependencies to determine if programmers are editing related code and allowing a programmer to view and import other programmers versions of a file type or method. In addition in place audio video text chat and application sharing can be provided. This allows communication sessions to be conducted within the programming environment. The foregoing features as well as others will now be described in more detail starting with the notification aspects followed the resolution aspects.

The technique continues by monitoring the aforementioned network for incoming edit messages and inputting any messages received . Edit messages are generated whenever another programmer begins changing a program element. Generally they identify the program element that is being changed. Whenever an edit message is received it is determined if the message indicates a change is being made to a program element previously edited by the first programmer . This is done using the aforementioned list of edited program elements. If the edit message indicates a change is being made to such an edited program element the first and second programmers are notified of a potential conflict . If not and related program elements are considered as well it is also identified whether the edit message concerns a program element that is related to an element previously edited by the first programmer . This is accomplished using the aforementioned related program elements list. If the edit message concerns a program element that is related to an edited program element then the first and second programmers are notified of a potential conflict between the edited program element and the program element identified in the edit message . It is next determined if the first programmer is still logged on the IDE system . If so actions through are repeated. Otherwise the technique comes to an end.

It is noted that in the case where a programmer is creating a new program element rather than editing an existing one an edit message is still sent.

It is also noted that the foregoing technique can also be implemented without related program elements being considered. In this alternate technique the actions associated with processing related program elements would be eliminated.

It is further noted that each programmer sets the granularity of detection. In other words the programmer chooses whether to be notified about potential conflicts in files types and methods types and methods only or methods only. Thus for example if a programmer chooses to be notified about potential conflicts in methods only and a conflict arises in a portion of a file or class that is not a method then no notification would be given. On the other hand if a programmer elects to be notified about potential conflicts in files types and methods the programmer would be notified about any potential conflict that might arise. However if more than one program element level is chosen and an edit causes a potential conflict at more than one granularity then the programmer is notified only about a potential conflict at the finest granularity level affected. Thus if the programmer has chosen to be notified of potential conflicts in all three program element levels and a potential conflict arises in a method within a class of a file the programmer would only be notified that a potential conflict exists in a method. In this way the system avoids multiple conflict messages for the same conflict.

In regard to notifying the programmers of a potential conflict the first programmer in the foregoing example is a local user i.e. the team member using a computing device performing the foregoing technique and so is notified directly. In the case of the remote second programmer in the foregoing example he or she is notified by sending a conflict message via the network. The conflict message identifies that a potential conflict exists between the first programmer s version of a program element and the other programmer s version of the program element when the other programmer is editing the same program element or if related program elements are considered that a potential conflict exists between the program element edited by the first programmer and a related program element identified in the edit message.

It is noted that if a conflict message associated with the program element identified in the edit message is not received then the new or modified element takes on the status of one of the aforementioned edited program elements for the programmer creating or editing it.

In regard to related program elements it was stated previously that elements relate to one another when a dependency exists between them and this dependency is not too far removed from the edited element. More particularly a type can depend on subtype or supertype and a method can depend on a method it is called by or calls. By way of an example of a type dependency consider three classes A B and C as defined below.

By way of an example of a method dependency consider a method that calls another. In this example the called method is defined as 

These dependencies can extend recursively beyond one level. For example a subtype may have another subtype of its own or a called method may in turn call another method. Thus there is a depth of dependency to consider when determining if an edited program element is related to another element. More particularly the present code conflict notification and resolution technique can include a function that sets the number of levels away from an edited program element that would still be considered a related element. This depth of dependency limit can be a default value or as will be described shortly set by a programmer.

At this point the programmers receiving notification of a potential conflict only know that a conflict might exist. To determine if an actual conflict exists a comparison must be made by one or both of the programmers involved in the conflict. The present code conflict notification and resolution technique facilitates this comparison by causing program elements involved in the conflict to be displayed to a programmer in a code session . The details of this display feature will be described in more detail later in connection with a description of an exemplary graphic user interface associated with the present technique. Generally each of the programmers involved in a potential conflict will be notified and each has the option of starting a code session to see a comparison of the program elements. Referring to procedurally the code session generally involves displaying program elements that have been deemed to be in a potential conflict to a programmer inputting changes made by the programmers to resolve any actual conflict in the displayed program elements and finally updating the displayed elements to reflect the inputted changes .

Displaying program elements that have been deemed to be in a potential conflict can be accomplished in different ways. In one embodiment of the present technique a programmer has the option of viewing the last updated version of the other programmer s program element involved in the conflict and comparing it to the latest version of that element available on the programmer s computer which may simply be the last checked in version of the program element . A programmer initiating a code session also has the option of viewing the latest version of the conflicting program elements that he or she is responsible for and comparing it to the version the other programmer is working with. It is noted that initially each of the programmers has a current copy of the program element that he or she is responsible for. However each will need a copy of the version of that program element that the other programmer is working with. In one embodiment of the present technique when a programmer initiates a code session the copy of the other programmer s version of the element under consideration is automatically obtained using a refresh feature. More particularly referring to in one implementation of this feature when a programmer initiates a code session a refresh message is sent to the other programmer requesting a copy of the latest version of the program element being compared that the other programmer has available . The network is then monitored for a reply message that includes a copy of the requested program element and it is input when received . The received copy of the program element is then displayed along with the latest version of that element available on the requesting programmer s computer .

Once the potentially conflicting program elements are displayed to the programmers they can collaboratively resolve any real issue that exists. As stated earlier several communication tools are available to accomplish this task such as in place audio video text chat and application sharing. In some cases a programmer may decide to change his or her program element to conform to the other programmer s element with or without employing any of the foregoing communication tools. As an example consider the drawing tool example described previously. The second programmer could change the constructor parameters of his or her program element to match the order change in the first programmer s earlier changed element. It is noted that when the edit message concerning this correction is received by the other programmer involved in a potential conflict a conflict notification is not generated as the conflict is already being addressed.

It is also noted that the other programmer may be changing the program element involved in the first programmer s code session at the same time perhaps as a result of a discussion in a concurrent communication session for example via the in place audio video text chat and application sharing tools and or after viewing the potentially conflicting program element in his or her own code session. Thus the first programmer will not be viewing the latest version of the program element being compared and may need to in order to correctly resolve the conflict. In addition the programmer may have made changes to his or her own version of the program element displayed in the code session. In such a case the programmer can retrieve the other programmer s latest version of the program element under consideration and display that current version as well as the latest version of his or her copy of the program element by manually initiating the aforementioned refresh feature.

As stated earlier each of the programmers involved in a potential conflict will be notified and has the option of starting a code session to see a comparison of the conflicting program elements. However an edit message will typically be sent before a programmer has finished creating or editing a program element. Thus a conflict notification could be sent prior to the programmer finishing the changes as well if the changes affect either directly or indirectly by dependency a program element previously edited by the other programmer. A code session cannot be initiated if the program element to be displayed and compared is the one still being worked on by a programmer. In one embodiment of the present technique this situation can be handled by delaying the sending of a conflict notification until after the programmer is finished creating or editing a program element that was the subject of an edit message. Thus the changes will be complete and a code session can be initiated. In one implementation of this delay feature the number of program elements a programmer edits is tracked and the conflict notification is delayed until a prescribed number of edits has been complete. For example if the prescribed number is one edit the notification would be delayed until after each edit is complete. The prescribed number of edits could be a default number or programmer specified.

In another embodiment of the present technique the early notification issue is handled by setting a watch. Generally the conflict notification is not delayed and instead a watch monitors the programmer who has yet to complete the edits on a program element involved in a potential conflict and informs the watching programmer when the edits are complete. More particularly referring to in one implementation of the watch feature after receiving a notification of the potential conflict caused by a change being made by the other programmer but which is not yet complete a watch message is sent to the other programmer requesting to be informed when the change is complete . The watching programmer s computer then monitors incoming messages for a reply to the watch message and determines if such a reply is received . If a reply message is received from the other programmer granting the request the watching programmer s computer then monitors incoming messages for a change complete message and determines if this message is received . When the change complete message is received a code session is initiated as described previously. It is noted that the present code conflict notification and resolution technique running on the other programmer s computer deems that the programmer has finished editing a program element when he or she begins editing a different element. However in an alternate implementation of the watch feature when a programmer sets a watch a prescribed amount of time is allowed to pass and then the programmer is informed that the watch period is over. The programmer can then attempt to initiate a code session assuming the other programmer is finished editing the program element under consideration.

Another feature of the present code conflict notification and resolution technique involves preparing a program element for testing. When a programmer wishes to test a modified program element the changes made to the element will typically assume the other programmer s program element is its most up to date form. However while the latest copy of the other programmer s program element may be displayed in a code session this version is generally not accessible for testing purposes and needs to be updated. Thus the changes have to be incorporated before any testing can take place. To handle this situation the present technique includes a feature whereby a programmer initiates a replacing or merging of the old version with the current changed version as seen in the code session. Replacing an outdated version of another programmer s program element with the current version displayed in the code session can be used when this action would have no effect on the changes made by the programmer initiating the replacement. For example a replacement action is appropriate when the two program elements involved are related but not the same element or when the programmer has not made any changes to his or her version of the program element during the code session. In the case where the elements are the same and changes have been made to the programmer s version of the program element being tested a replacement action may not be advantageous as any changes made by the programmer initiating the replacement could be lost. Instead a merge action is employed. This merge action replaces all the portions of the version of the program element being tested which will included any changes made by the testing programmer during the code session that have not been changed by that programmer. In this way the changes made by the other programmer are incorporated into the merged element without eliminating any changes to the element made by the programmer who initiated the merge action.

This section will describe an exemplary graphic user interface GUI that can be employed in conjunction with the present code conflict notification and resolution technique and will provide an operational example of the technique. It is noted that this GUI and operational example are intended to aid in the understanding of the features provided and is not intended to imply that the present invention is limited to the example.

In general the example GUI shown in is conflict notification and resolution window that includes a special panel referred to as a collaboration studio panel and a workspace sector where the text of program elements and various sub windows are displayed. The collaboration studio panel is divided into several sub panels or tiles. There is a user tile for each of the programmers involved in the software development project. A user tile shows the log in name of the programmer whether the programmer is online and the program element which the programmer is focusing e.g. the program element displayed in the workspace sector that the cursor currently appears in and status of the current activity e.g. editing viewing or debugging . Thus it can be seen in the example of that a programmer named Bob is viewing a method ALine of the class Shapes.ALine in the file ALine.cs while another programmer named Alice is editing the method AShapeWithBounds in the class Shapes.AShapeWithBounds in the file AShapeWithBounds.cs. A constructor of ALine calls a constructor of AShapeWithBounds to initialize the coordinates and size of the bounding box of a line. Assume that Alice has started changing the constructor parameters of AShapeWithBounds when Bob starts editing ALine . Bob could look at Alice s user tile to realize she is editing a method he intends to call. However Bob is not expecting a conflict so he does not look at it. As soon as he starts editing the constructor however a potential conflict is detected and a conflict notification may be sent to Bob and Alice in the manner described previously. It should be noted the roles of Bob and Alice could have been reversed if Bob had edited Aline before Alice edits the AShapeWithBounds constructor. In that case the conflict would be detected when Alice starts her edits.

Whether a conflict notification is sent will depend on the notification set up. As described previously it is possible to specify the granularity and depth of the conflict detection. This can be accomplished by initiating the granularity feature via a drop down menu list. A granularity pop up window would appear in the workspace sector and allow the programmer to select either file type and method type and method only or method only. The programmer can also choose none thereby disabling the conflict notification operation. In addition the programmer can specify the number of levels from a program element being edited that a related element would still be considered as conflicting. As described previously it is further possible to delay a conflict notification from being issued until a programmer has edited a prescribed number of elements. This can be accomplished by initiating the delay feature via a drop down menu list. A delay pop up window would appear in the workspace sector and allow the programmer to specify the number of edits. In the foregoing operational example assume the two programmers have not coordinated their activities. They have set the finest granularity to method only and have arranged for conflicts to be reported immediately i.e. delay 0 edits . Consequently Bob s first edit to the constructor causes both programmers to get notifications about the potential conflict.

Conflict notifications can be provided in multiple ways. For instance in the example GUI of a conflicts tile is included in the collaboration studio panel . When a conflict notification is received the conflicts tile is updated to list the potential conflict. Further the conflicts tile can list the last few potential conflicts space permitting. For each listed potential conflict the program element in which the potential conflict occurs is identified as is the other programmer involved. As it is possible for a programmer to miss the notification in the conflicts tile additional notification vehicles can be employed as well. For example a notification balloon that gradually fades away could be displayed in the conflict notification and resolution window . Clicking on the notification balloon double clicking on any potential conflict listed in the conflict tile or clicking on the conflicts inbox button takes the user to a conflict inbox so called because it can be considered a persistent collection of conflict messages regarding the current project. shows one possible configuration of the conflict inbox as it would appear in the workspace sector of the conflict notification and resolution window . Note that the inbox appears as a tabbed file overlaying other tabbed sub windows such as the program elements involved in the conflict. Clicking on a tab brings the associated sub window to the top. In this way a programmer can quickly go from on sub window to the next thereby facilitating the conflict resolution task. The conflict inbox provides a list of detected potential conflicts . Clicking on a listed conflict selects it. The selected conflict is highlighted and a pop up window appears which provides some details about the potential conflict such as the program element s involved their relationship and the identity of the other programmer. It is noted that clicking on a potential conflict listed in the conflict tile will also cause the same pop up window to appear.

To continue with the operational example once the programmers have been notified of the potential conflict Bob realizes from the notification that Alice is the middle of changing the called method. He has other changes to make and therefore decides he should delay editing his method until Alice has decided what she wants to do with the called method. Therefore referring to again he sets a watch on the conflict by selecting the conflict in the conflict inbox and clicking on the set watch button . This causes a request watch pop up window to appear not shown . The request watch window identified the other programmer involved i.e. Alice and the method she is currently editing. Bob can select the mode of the watch to be either by code context or time. If he chooses code context a message will be sent to Alice requesting that Bob be informed when she finished editing the method. However if Bob selects the time option he can designate an amount of time before he is reminded about the conflict. As described earlier if Bob selects the code context option and Alice grants the watch request he will be notified when Alice moves away from editing the designated method and starts editing a different program element. It should be noted however that the time option has an advantage in that if Alice makes a temporary movement from the method an erroneous notification that she is done editing it will not be sent assuming the amount of time specified is sufficient for Alice to complete the editing task. In this operational example Bob knows that the method Alice is working is simple and infers that any movement from it will probably be permanent. Therefore he chooses the code context option. Bob can also enter some text in the watch request window explaining to Alice why her actions must be tracked by him. This text will be added to the watch request message that is sent to Alice. Assume Alice accepts the watch and Bob gets a reply message to that effect. In this case the watch indicator in the watch column at the end of the potential conflict listing in both Bob and Alice s conflict inbox lights up red indicating an active watch. Once Alice finishes editing the method AShapeWithBounds Bob receives notification and the watch indicator for the corresponding potential conflict listing in the conflict inboxes changes to green.

As mentioned before the present technique only indicates that a potential conflict may exist between program elements to determine if it is an actual conflict Bob must actually see what Alice has done. To do so he selects the potential conflict listing in the conflict inbox . In addition Bob chooses whether to view the other programmer s conflicting program element i.e. Alice s modified method in this operational example compared to his version of that element by selecting the Remote Change option or to view his conflicting program element i.e. his modified method in this case compared to Alice s version of it by selecting the My Change option . In this example it will be assumed that Bob elected to go with the remote change option. Bob then initiates a code session by clicking on the start code session button . This command defines a session for viewing the contents of Alice s modified method in comparison to Bob s version of the method as the method is known to represent the context of the conflict. However Bob also has the ability to select a different program element by activating a 3 level code browser not shown which allows him to select any file type class or interface within a file or method within a class for viewing in the code session. It will be assumed that Bob did not specify a different program element. In response to Bob starting the code session a tabbed code session sub window is displayed in the workspace sector as shown in . The code session sub window has two sectors that show the remote version and local version of the program element side by side namely the My Code sector and the Remote Code sector . To locate the exact change causing the potential conflict Bob can click on a Show Difference button in the code session sub window . This command shows the difference between two program elements methods in this case by highlighting the lines that have changed.

Bob is now easily able to find the change and adjusts the parameters of his own method when he codes it. As described previously when Bob re edits his method he does not get a new conflict notification as the system suppresses a conflict between two program elements of different users if it has earlier flagged a conflict involving the same program elements and users. Once Bob finishes his edits he needs to test it. However the code he has written assumes Alice s version of the AShapeWithBounds method while his testing workspace has the old version. Thus he needs to incorporate Alice s changes in this version to test his code. To accomplish this Bob clicks on a Replace With Remote button found in the code session sub window . This command incorporates Alice s changes to the conflicting method as they are shown in the code session sub window in Bob s version of the method. It is noted that this action does not result in conflict notifications as explained previously.

It is also noted that the previously described refresh command can be initiated by clicking on a Refresh button in the code session window. This obtains and displays the latest local and remote versions of the program element being compared in the code session. So in this operational example Bob can wait till Alice finishes her changes then execute the refresh command followed by a replace with remote command to get Alice s changes into his code. Similarly the previously described merge feature can be initiated by clicking on a Merge button in the code session window .

If a programmer wishes to resolve a potential conflict with another programmer directly this can be done using the previously described communication session features such as in place audio video text chat and application sharing. For example assume that Bob cannot wait until Alice is finished editing the potentially conflicting method and so a code session is not available. Or assume that Bob wishes to communicate with Alice during a code session to aid in resolving the conflict. Referring to once again the in place communication channels can be initiated from an I Need tile in the collaboration studio panel . For example Bob could click on a Start A Audio Video Session and or a Start A Text Chat Session item listed in the I Need tile . In the example GUI for each communication channel selected a tile not shown is added to the collaboration studio panel to provide the desired communication session. There may also be situations where conflict resolution requires the two programmers to work together on some code. To accomplish this a programmer can initiate an application sharing session by clicking on a Start An Application Sharing Session in the I Need tile in the collaboration studio panel . In the application sharing session the two programmers can both control the conflict notification and resolution window one at a time.

It is noted that if a conflict is resolved by changing a program element outside a code session the program elements can still be compared replaced with the latest version merged and so on by initiating a code session afterwards.

In the foregoing description of embodiments for the present code conflict notification and resolution technique potential conflicts were detected for an edited program element that had not yet been checked in for validation and testing. However the technique can be extended to detect potential conflicts involving program elements that have already been checked in. In such a case the programmer will not be able to start a code session and so would use the version control system to view incorporate and adapt to the changes of the other programmer.

Further while the foregoing description of embodiments of the present invention referred to notification and resolution of computer code conflicts the technique has application beyond just this implementation. For example the present technique could be applied to a network based collaborative document preparation project. In such an implementation conflicts would be detected between some specified portion of the text e.g. line sentence paragraph and so on rather than the previously described program elements and the document preparers instead of programmers involved in the conflict would be notified accordingly. Generally all the features described above would be useful in this alternate implementation. Still further the present technique could generally be applied to any network based collaborative development project where developers may be working on the same or related element and where conflicts could occur.

It should also be noted that any or all of the aforementioned embodiments throughout the description may be used in any combination desired to form additional hybrid embodiments. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

