---

title: Method and apparatus for network services metering
abstract: Method and apparatus for metering network services, for example Web services. In embodiments, a network services metering system may collect network service usage information via an add usage interface and store the usage information in a database. In one embodiment, the usage information may be partitioned into two or more partitions. Once the usage information has been aggregated and stored, the metering system may be queried to obtain usage statistics such as aggregate usage over specific time intervals. In one embodiment, a pipeline mechanism that generates and processes batches of usage information may be implemented for adding usage information to the database. The pipeline mechanism may help to reduce or eliminate redundancy and loss of usage information, and may make the metering system linearly scalable in multiple dimensions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07908358&OS=07908358&RS=07908358
owner: Amazon Technologies, Inc.
number: 07908358
owner_city: Reno
owner_country: US
publication_date: 20060331
---
This invention relates to computer systems and networks and more particularly to metering usage of network services such as Web services.

A service provider may make a network service available for use by third parties. For example the field of utility computing involves a service provisioning model in which a service provider makes computing resources and infrastructure management available to the customer as needed and charges them for specific usage rather than a flat rate. However efficiently metering usage of network services can be problematic especially for large scale and or heavily used network services.

The conventional Web model allows users to access Web resources e.g. applications services and data via an HTTP client program such as a Web browser. A technology referred to as Web services has been developed to provide programmatic access to Web resources. Web services may be used to provide Web software developers programmatic access to Web resources including technology platforms e.g. applications and services and data e.g. product catalogs and other databases hosted on Web connected computers such as Web server systems via a Web service interface. Generally speaking a Web service interface may be configured to provide a standard cross platform API Application Programming Interface for communication between a client requesting some service to be performed and the service provider. In some embodiments a Web service interface may be configured to support the exchange of documents or messages including information describing the service request and response to that request. Such documents or messages may be exchanged using standardized Web protocols such as the Hypertext Transfer Protocol HTTP for example and may be formatted in a platform independent data format such as eXtensible Markup Language XML for example.

Web Services Description Language WSDL is an XML format for describing network services as a set of endpoints operating on messages containing either document oriented or procedure oriented information. The operations and messages are described abstractly and then bound to a concrete network protocol and message format to define an endpoint. Related concrete endpoints are combined into abstract endpoints services . WSDL is extensible to allow description of endpoints and their messages regardless of what message formats or network protocols are used to communicate.

Various embodiments of a method and apparatus for metering network services for example Web services are described. In embodiments a network services metering system may collect usage information from network service requests via an add usage interface and may provide a get usage interface for querying the metering system to obtain usage statistics from the collected usage information. In one embodiment the metering system may be integrated as a component of a Web services framework implemented by a Web services provider to expose one or more Web services to clients. Embodiments of the metering system may be used to aggregate and store usage information for Web services within the Web services framework. Once the usage information has been aggregated and stored the metering system may be queried to obtain usage statistics such as aggregate usage over specific time intervals. For example a Web services framework may use the metering system to track usage totals for bandwidth storage space and requests for one or more Web services over specified time intervals. The usage statistics may be used for any of a variety of purposes for example billing throttling or reporting.

In one embodiment a pipeline mechanism may be implemented for adding usage information to a usage database. In one embodiment usage information collected by an interceptor process running on each Web services frontend server may be added to the metering system via an add usage interface to a metering service component. Instances of the metering service component may unpack usage data received from the interceptors and collect the usage data into one or more usage batches. A metering service instance receives usage records one at time and serialized the records into strings and appends them to one of one or more in memory usage batches. A metering service instance collects a usage batch in memory until the batch gets to a certain size or to a certain staleness. Once a usage batch is ready the metering service instance feeds the batch into the queues of an appropriate pipeline of a partition. In one embodiment each usage batch may include a batch identifier ID that uniquely identifies the batch. Usage batches may be fed into the queues by the metering service instances and read from the queues and processed by aggregator processes in each queues pipeline. Each aggregator may aggregate usage information from the batches in memory and may periodically or aperiodically write the usage information to the usage database in the pipeline in a transactional operation. Once the in memory usage information has been successfully committed to the usage database in the pipeline the aggregator may flush its memory and dequeue the completed batches from the queue s .

The aggregators may be viewed as fault tolerant middlemen between the incoming and queued usage information and the store. In one embodiment after and only after a batch is committed to the store the batch may be dequeued from the queue and disposed of by the aggregator. Note that each partition may include one or more pipelines with each pipeline including at least one queue aggregator and database instance. These and other aspects of the metering system architecture may help to reduce or eliminate redundancy and loss of usage information and that also may make the metering system linearly scalable in multiple dimensions.

Usage information may be stored in one or more databases stored on one or more data storage devices and or data storage systems. In one embodiment the usage information may be partitioned into two or more partitions by the metering system. Each partition may include one or more systems or servers that each implement one or more instances of components of the metering system that support that particular partition. Note that in one embodiment the servers partitions and or data storage devices or systems may be distributed across two or more data centers.

An entity e.g. a billing service may query the metering system for usage statistics via a get usage interface provided by the metering service. In one embodiment the query may identify the usage statistics to be retrieved the time period for which the statistics are to be retrieved and the number of statistics to be returned. A metering service instance may receive the query and fetch usage records that satisfy the query from one or more database instances in the usage database. The metering service may merge or otherwise process the query results as necessary or desired to generate usage statistics. The usage statistics may then be returned to the querying entity.

While embodiments of the network services metering system are generally described herein in the context of metering Web services embodiments may be used for metering usage of other types of network services network applications programs systems etc.

While the invention is described herein by way of example for several embodiments and illustrative drawings those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . Similarly the words include including and includes mean including but not limited to.

Various embodiments of a method and apparatus for metering network services for example Web services are described. In embodiments a network services metering system may collect usage information from network service requests via an add usage interface and may provide a get usage interface for querying the metering system to obtain usage statistics from the collected usage information. The usage statistics may be used for example for determining network service usage for charging network service customers billing and for analyzing network service usage data. Note that while embodiments of the network services metering system are generally described herein in the context of metering Web services embodiments may be used for metering usage of other types of network services network applications programs systems etc.

In one embodiment the metering system may be integrated as a component of a Web services framework e.g. a Web services framework implemented by a Web services provider to expose one or more Web services to clients. Embodiments of the metering system may be configured to store aggregate and retrieve Web service usage information for various processes of the Web services framework and or for the Web services themselves. For example the metering system may be used to collect Web service usage information and to provide usage statistics from the collected usage information to Web Services billing throttling and reporting processes.

Embodiments of the metering system may be used to aggregate and store usage information for Web services within the Web services framework. Once the usage information has been stored the metering system may be queried to obtain usage statistics such as aggregate usage over specific time intervals. For example a Web services framework may use the metering system to track usage totals for bandwidth storage space and requests for one or more Web services over specified time intervals. The usage statistics may be used for any of a variety of purposes for example billing throttling or reporting.

Server may be coupled to Internet . Server may host a Web service client . Web service client may be configured to programmatically access application or service of server and or database via Web service interface . Note that Web service interface does not provide a Web browser interface but instead provides a programmatic interface via an API through which at least some functionality of application or service and or at least some data in database may be programmatically accessed by Web service client . Also note that server may provide a Web site accessible to client s via Web browsers and Web service client may be configured to access at least some functionality of application or service and or at least some data in database of server via Web service interface to provide access to at least some functionality of application or service and or at least some data in database via the Web site provided by server . Further note that Web service client may itself be another Web service.

To access an application service or data provided by the Web service provider Web service client may send a request message to Web service interface via Internet . This request message goes through the network and Internet infrastructures through the Web service client s local network routers switches firewalls etc. through the Internet backbone to the Web service provider s local network to Server and then to Web service interface . Web service provider may then process the request for example by performing an indicated function s of application or service or accessing indicated data in database . Note that application or service may access data storage for example to access database in the process of performing an indicated function. Web service interface may then return results of the processing to the Web service client in a response message via Internet back through the local networks and Internet backbone.

In one embodiment components of metering system may be implemented on one or more backend servers in the context of the Web services framework. Note however that one or more components of metering system may be implemented on one or more of the Web services frontend servers . However one or more backend servers in the context of the Web services framework that each implement one or more instances of one or more components of the metering service may be considered frontend servers of the metering system itself while one or more instances of one or more other components of the metering system may be implemented on backend servers in the context of the metering system . Embodiments of this architecture are further described in reference to the Figures below.

Usage information store may be implemented as one or more databases stored on one or more data storage devices and or data storage systems. In one embodiment usage information may be partitioned into two or more partitions by the metering system . Each partition may include one or more systems or servers that each implement one or more instances of components of the metering system that support that particular partition. Note that in one embodiment the servers partitions and or data storage devices or systems may be distributed across two or more data centers.

In one embodiment metering system may provide an add usage operation via an add usage interface to add Web services usage information to usage information store and a get usage operation via a get usage interface or query interface to get Web services usage information from usage information store . In one embodiment the metering system interface may be exposed to and used by one or more components or processes of the Web services framework such as a billing service. In one embodiment the metering system interface may be externally exposed to clients of the Web services framework .

In one embodiment the metering system may be exposed as a Web service via a Web Service interface. In this embodiment the metering system may be exposed via the Web service interface as a Web service that other entities may leverage to perform metering of services applications etc. An entity may implement functionality that intercepts calls to a service or other application that is being metered. The entity may then make calls through the Web service interface to the metering system to add usage information to and get usage statistics from a usage information store for the metered service.

Embodiments of the metering system as described herein may be implemented according to an architecture that is linearly scalable. Embodiments may be scaled quickly and easily with little or no risk of losing usage information with minimum or no downtime and without affecting the latency of the overall system. Partitioning the usage information store may help to make the metering system scalable. New partitions may be added to support increased volume and for load balancing. Frontend servers may be added as needed to send usage information into the metering system .

Embodiments of the metering system may be implemented according to an architecture that achieves a desired level of latency from the view of clients of the metering system. Components of the metering system may be added as needed as described above to help maintain the desired level of latency. Note that the metering system is linearly scalable and so may be scaled upwards without negatively affecting the latency of the overall system.

Embodiments of the metering system may be implemented according to an architecture that tends to reduce or eliminate redundancy in stored usage information while also reducing or eliminating the potential loss of usage information. In one embodiment a pipeline mechanism may be implemented for adding usage information to the store in which usage information is queued in usage batches which may also be referred to herein as batches in one or more queues by one or more instances of a metering service component. Each queue may be viewed as the head of a pipeline. In one embodiment each instance of a metering service may run on a separate server. In one embodiment two or more instances of a metering service may run on each server. A task of the instances of the metering service component is to unpack usage data received from the Web services frontend servers and to collect the usage data in strings or batches. A usage batch may be viewed as a serialized list of usage records. A metering service instance receives usage records one at time in some format and serialized the records into strings and appends them to an in memory batch. A metering service instance collects a usage batch in memory until the usage batch gets to a certain size i.e. reaches some predetermined size threshold or to a certain staleness i.e. the oldest entry is older than some predetermined period e.g. one minute . Once a usage batch is ready the metering service instance feeds the batch into the queues of an appropriate pipeline.

In one embodiment each usage batch may include a batch ID that uniquely identifies the batch. In one embodiment when the metering service needs to start a new usage batch it generates a batch ID for the batch. In one embodiment the batch ID may include a random 64 bit number a timestamp and a process ID for a process. Thus the batch ID may be unique for any given batch. Note that other embodiments may use other methods to generate unique batch IDs.

Usage batches may be fed into the queues by the metering service instances and read from the queues and processed by aggregator processes in each queues pipeline. Each aggregator may aggregate usage information from the batches in memory and may periodically or aperiodically write the usage information to the store in a transactional operation. In one embodiment each instance of an aggregator process may run on a separate server. In one embodiment two or more instances of an aggregator process may run on each server. In one embodiment the batches may be committed to the store transactionally. Once the in memory usage information has been successfully committed to the database in the pipeline the aggregator may flush its memory and dequeue the completed batches from the queue s .

The aggregators may be viewed as fault tolerant middlemen between the incoming and queued usage information and the store . In one embodiment after and only after a batch is committed to the store the batch may be dequeued from the queue and disposed of by the associated aggregator. Note that each partition may include one or more pipelines with each pipeline including at least one queue aggregator and database instance. These and other aspects of the metering system architecture that for example may help to reduce or eliminate redundancy and loss of usage information and that also may make the metering system linearly scalable in multiple dimensions are further described below in reference to and other Figures.

In one embodiment there may be one interceptor per Web services frontend server . In one embodiment the metering service instances may be organized into a single pool which may be shared by all instances of interceptor . In one embodiment the metering service instances may reside behind a virtual IP address VIP . Thus in this embodiment there may be a single server that acts as a load balancer to two or more servers each including at least one instance of metering service . Note that in one embodiment each metering service instance may be functionally identical and thus an incoming add usage or get usage requests may go to any instance of the metering service .

The remaining components may be organized into one or more metering pipelines . In one embodiment each pipeline may include a single queue instance that feeds batches of usage information received from metering service instances to an aggregator instance that aggregates the usage information and writes the usage information into a database instance. In one embodiment metering pipelines may be paired into one or more partitions . In this embodiment each metering service instance may feed usage information into both pipelines in a single partition .

In one embodiment each database instance may be owned by a single partition . In another embodiment a database instance may be shared by two or more partitions . In one embodiment database instances may be paired such that for each partition that writes to the pair of database instances one pipeline writes to one instance of the database and the other writes to the other instance of the database . This ensures that the two instances of the database in a pair receive the same usage information.

In three exemplary partitions and six exemplary database instances are shown. In this exemplary embodiment each partition includes a pair of database instances. Partition A includes database instances A and A partition B includes database instances B and B and partition C includes database instances C and C. In another embodiment instead of having two database instances for each partition there may be two database instances that are shared among all partitions with one pipeline in each partition feeding usage records into one of the database instances and the other pipeline in each partition feeding usage records into the other database instance. Using to illustrate this embodiment database instances A B and C would refer to one database instance and database instances A B and C would refer to the other database instance.

In one embodiment queues may be implemented as instances of a queue by a queue service that exposes a queue interface to the queues . In one embodiment each queue may be instantiated and maintained as a first in first out FIFO queue. Each queue may be persistent. The queue service may expose three interfaces an enqueue interface via which the metering service instances feed batches into one end of the queues a read interface via which aggregators read batches from the other end of the queues and a dequeue interface via which aggregators may dequeue batches from the end of the queues . Note that processing usage information in batches reduces the number of calls necessary to the queue service by both the metering service instances and the aggregators . The metering service instances queue batches of usage information into queues via the queue service interface. The batches may then be read and dequeued by the aggregator instances via the queue service interface. The queue service and queue instances may provide a high probability that after a batch is dequeued the batch will not be read again. However as embodiments may be implemented as distributed systems it is important to prevent batches from being read from the queues and committed to the database more than once. Thus embodiments may provide one or more mechanisms to help insure that the same batch will not be read from a queue and processed twice which might for example result in a customer being charged twice for one request to a Web service. Further embodiments may provide one or more mechanisms to detect duplicate usage records.

As previously mentioned each batch may be assigned a unique batch ID by the metering service . In one embodiment the batch ID may be stored to the database with the usage records. The batch ID may then be used to detect any duplicate usage records to prevent duplicate usage records from being written to the database . In one embodiment an aggregator instance reads a batch of usage records from a queue instance. Before committing the batch to the database the aggregator may then query the database to determine if the batch ID of the batch has already been written to the database . If the batch ID is already in the database the aggregator instance knows that the batch has already been committed to the database and thus does not commit the batch to the database . The aggregator instance may then dequeue the batch from the queue instance and may also flush the batch from memory if the batch has already been stored in memory.

In one embodiment each partition may include two queues one for each pipeline . In one embodiment the two queues of a partition may be implemented in different data centers. Each metering service instance is constantly generating a batch for each partition . Once a batch for a partition is ready to be enqueued the metering service instance simultaneously enqueues the batch to both queues of the partition . If either enqueue fails the metering service retries the enqueue. Having two queues for each partition provides redundancy. If either one of the queues fails for some reason e.g. if the data center in which the queue is implemented goes down there is still a complete pipeline via which batches can be fed into the database .

In one embodiment each queue may not necessarily be equivalent with a physical instance of a system in a particular data center. Instead the queues may be considered logical queues and may be instantiated anywhere the queue service decides to instantiate them. Note that the metering system is not concerned as to where the queues are instantiated as long as the queue service guarantees redundancy. If a metering service instance is brought down for any reason the metering service instance may flush all current batches in memory to the queues before shutting down. This may help to reduce or prevent the loss of usage information.

Once a batch is enqueued to the queues for a partition the metering service is done with the batch. Once the batch is enqueued to the queues the queue service persists the batch in the queues until the batch is dequeued.

An aggregator may read batches off the queue in its pipeline in sets of one or more batches. For example an aggregator may read ten batches from a queue at one time. In one embodiment once an aggregator has read a batch from a queue the aggregator may read the batch ID from the batch and then may query the database to find out if the batch ID is already in the database. If the batch ID is already in the database the aggregator may dequeue the batch from queue and dispose of the read batch without further processing. If the batch ID is not in the database the aggregator may check e.g. using the batch ID to see if the usage information in the batch has already been aggregated into its memory. If the usage information in the batch is already aggregated in memory then the aggregator may dispose of the read batch. Note that the batch is not dequeued in this case because it has not yet been committed to the database .

Thus throughout a pipeline the unit of processing is a batch. The metering service generates batches and enqueues them to queues . The aggregators read batches from the queues . If the batch is already in the database the aggregator dequeues the batch and disposes of it. If the batch is not in the database but is in the aggregator memory the aggregator ignores the batch but does not dequeue the batch. The batch is not dequeued by the aggregator until the batch is committed to the database in a transaction and the transaction is verified to have completed successfully. This pipeline processing of batches helps to protect against losing usage information and against duplicating usage information in the database . If a batch was dequeued before committing the usage information to the database the usage information in the batch may be lost for example if a system fails.

It is possible that some event or failure may occur that causes a batch to be committed to a database but not dequeued from the queue . This does not cause duplication of data because the aggregator may later read the batch from the queue and check to see if the batch is already in the database . Upon discovering that the batch has already been committed to the database the aggregator dequeues and disposes the batch. This protects against duplication of usage information in the database while not dequeuing a batch until committed to the database protects against losing usage information.

In one embodiment an aggregator may perform time aggregation of usage information for at least some usage metrics. For example for some usage metrics it may not be necessary or desired to maintain the usage metric at a fine grained time level e.g. at the nearest second minute or hour. Instead the usage information may be aggregated over larger intervals e.g. an hour or a day to produce an aggregate usage record for the metric. All usage information received by the aggregator that falls within the desired interval using the timestamp as the key may be aggregated added up into one usage record.

To help reduce the risk of losing usage information a time and or size limit may be set for batches. Batches may be limited to for example ten seconds of data and thus may be considered stale by the metering service after ten seconds and or a certain number of entries e.g. ten may be set as the size limit for batches wherein a batch with at least ten entries is considered full.

As another mechanism to help reduce the risk of losing usage information embodiments may employ multiple servers each running an instance of metering service . As mentioned the metering service instances may run behind a VIP that serves as a load balancer to the metering service instances. Thus over a time period for which batches are limited e.g. ten seconds each metering service instance may receive a fraction of the usage information for that time period. If one of the servers hosting an instance of metering service fails only that fraction of the usage information for the time period is at risk of being lost. For example if there are 18 servers each hosting an instance of metering service and one of the servers fails only 1 18th of ten seconds of usage information is at risk of being lost.

In one embodiment the metering service may provide an interface or API to add usage to the usage database . The add usage method may be invoked via this interface to inform the metering service of new usage. In one embodiment the interceptor instances on the Web services frontend servers call the add usage method to add usage to the usage database . The following describes parameters that may be passed to an exemplary add usage method via the add usage interface and is not intended to be limiting 

In one embodiment usage may be tracked in usage records each of which may represent a single activity. As usage data flows through the metering system fields may be added by different components of the mechanism. The following describes fields of an exemplary usage record and is not intended to be limiting. Note that Request object as used herein may refer to any object data structure or message that includes request information and that is maintained and used by the Web services framework to broker requests between clients and Web services .

In one embodiment metering service instances may collect usage records received from interceptors into usage batches. In one embodiment a usage batch may be an array of one or more usage records prefixed by a unique batch ID. In one embodiment the usage records may be ordered in the array in accordance with usage time. Note that the metering service instances may timestamp the usage records.

As indicated at an aggregator of a partition reads usage batches from a queue and aggregates the usage information in memory. The aggregator periodically or aperiodically updates the database with the aggregated usage information as indicated at . In one embodiment the update of the database may be performed via one transaction.

Each usage batch may be assigned a unique batch ID by the metering service . In one embodiment the batch ID may be stored to the database with the usage records. The batch ID may then be used to detect any duplicate usage records to prevent duplicate usage records from being written to the database . In one embodiment before committing a batch to the database the aggregator may query the database to determine if the batch ID of the batch has already been written to the database . If the batch ID is already in the database the aggregator instance knows that the batch has already been committed to the database and thus does not commit the batch to the database . The aggregator instance may then dequeue the batch from the queue instance and may also flush the batch from memory if the batch has been stored in memory.

Once the aggregated usage information has been successfully committed to the database the aggregator flushes the aggregated usage information from memory and dequeues the completed usage batch es from the queue s as indicated at . Note that the flushing of the aggregated information and the dequeuing of the batches from the queue are not performed until the transaction committing the usage information to the database has successfully completed. This may help to prevent the potential loss of usage information if a portion of the pipeline should fail.

As indicated at the metering service receives the usage passed by the metering interceptor creates a usage record to represent it and timestamps the usage record. The timestamp is assigned by the metering service so that requests in a batch are guaranteed to be time ordered and to avoid discrepancies in time configuration on the Web services frontend servers . The metering service assigns the usage to a partition and adds the usage record to a current usage batch for that partition as indicated at . At when a current usage batch is full or is sufficiently stale the metering service sends the batch simultaneously in one request to both queues for the assigned partition as indicated at . Otherwise the metering service may continue to receive usage from one or more of the interceptors . Note that the metering service assigns a unique batch ID to each usage batch it generates so that each usage batch sent to a queue includes a batch ID that uniquely identifies the batch.

As indicated at on both pipelines for that partition one of the metering aggregators reads the batch from a queue . After checking in memory and in the database to ensure that the batch has not been recorded already the aggregator accumulates the data in memory aggregated by usage type service operation and subscriber. The aggregator also records the batch ID in memory. At each metering aggregator may periodically or aperiodically update its pipeline s database by adding all of the usage information it has aggregated in memory as indicated at . The metering aggregator also records the batch IDs of the batches represented by the usage into the database . In one embodiment this may all be performed as a single database transaction.

As noted each usage batch may be assigned a unique batch ID by the metering service . In one embodiment the batch ID may be stored to the database with the usage records. The batch ID may then be used to detect any duplicate usage records to prevent duplicate usage records from being written to the database . In one embodiment before committing a batch to the database the aggregator may query the database to determine if the batch ID of the batch has already been written to the database . If the batch ID is already in the database the aggregator instance knows that the batch has already been committed to the database and thus does not commit the batch to the database . The aggregator instance may then dequeue the batch from the queue instance and may also flush the batch from memory if the batch has been stored in memory.

As indicated at once the transaction has committed to the database the batches are dequeued removed from the queue and the aggregator flushes the usage it has aggregated in memory. In one embodiment the dequeuing and flushing are only performed once the aggregator has verified that the usage records have been committed to the database. This helps to ensure that usage data are not lost.

Usage records may be stored in a usage database as UsageHistory records when transactionally committed by an aggregator . SubscriberID is the identifier of the entity e.g. a Web service subscriber that invoked the request that generated the usage record. UsageTypeID is the identifier of the type of usage described by this record for example bandwidth storage or requests. ResourceTypeID is the identifier of the Web service for which the usage was generated. OperationID is the identifier of the Web services operation invoked by the request that generated the usage. Time is the usage time for the usage record inserted by the metering service . PeriodTypeID is the identifier of the type of time period e.g. T day T hours T minutes etc . The period specifies the length of the time interval that statistic will be computed over. Value is the amount of usage incurred.

As previously mentioned the metering service may be partitioned with each partition including at least two databases and with each partition including at least two pipelines. Incoming usage information received from interceptors via the add usage interface may be unpacked and serialized into batches. Each batch may be targeted at a particular partition .

The metering service instances are aware of the partitioning configuration. Each metering service instance may collect usage information in batches for any of the partitions and may feed the batches into any of the partitions . Thus embodiments may provide a mechanism for dividing the incoming usage records among the partitions and the metering service may use this mechanism when serializing incoming usage information into batches.

In one embodiment the metering service may use a subset of the string generated by serializing an incoming usage record as a partitioning key. The metering service may hash the key and determine the modulus P of the hash to determine which partition this particular usage information is to be fed into and thus which batch to write the serialized usage record into where P is the number of partitions . From that each metering service instance may be generating P batches in memory. Each batch is to be fed into a particular one of the P partitions when ready. Thus the metering service as a whole is generating P sets of batches in memory. In the example illustrated in metering service may be generating three sets of batches batches that are to be fed into partition A batches that are to be fed into partition B and batches that are to be fed into partition C. Note that any one incoming usage record will be partitioned into one batch.

may be used as the key. Thus all requests for a particular entity subscriber of a particular usage type to a particular service will be written to a particular partition. If a usage record is received where at least one of the fields used in the key is different the record may go to a different partition .

Note that when the get usage interface is invoked to query for usage statistics the same key received as part of the query may be hashed and used to locate the partition s that include the usage record s that satisfy the query.

The above primarily describes adding usage information to the metering system. This section describes more fully the get usage operations and interface for retrieving usage statistics from the metering system.

In a billing service is provided as an example of a service application process or other entity that may query the metering system for usage statistics via the get usage interface. Note that other types of services applications or processes may query the metering system for usage statistics. Further note that in billing service is shown as invoking the get usage interface of the metering service directly. In one embodiment a service application or process may invoke the get usage interface of a metering service via the Web service frontend server s .

In one embodiment the metering service may provide an interface or API to get usage statistics from the usage database . The get usage method may be invoked via this interface to query the metering service for usage statistics. The following describes parameters that may be passed to an exemplary get usage method via the get usage interface and is not intended to be limiting 

The following are some definitions of terms that may be used in the discussion of usage statistics that may be requested via the get usage interface computed by the metering system from the database of usage records and returned to the requesting entity. Note that these terms may also be used elsewhere in this document.

Usage type refers to a label identifying the kind of resource being consumed. Resources may include one or more of but are not limited to requests bandwidth and storage.

Usage record refers to a record representing the incremental usage of a usage type for a single web service request. Usage records are further described above in the section titled Add Usage Operations. The usage record may be identified with a particular subscriber via a subscriber ID in the record. Usage records may be generated and added to the database by the add usage operations as described above.

A usage statistic refers to some statistical aggregation of usage records over some time period. In one embodiment there may be two types of usage statistics base statistics and derived statistics 

The following describes fields of an exemplary input statistic definition structure e.g. inputStatistic in the above exemplary parameter list for a get usage method that may be provided by an entity that is requesting a usage statistic via the get usage interface and is not intended to be limiting.

In one embodiment a rolling statistic may be computed over a sliding window of time and thus may have a moving start time relative to the current time. For example if at 12 00 the value of a rolling statistic with a period of 24 hours is requested the usage accumulated from 12 00 the previous day 24 hours ago will be computed and returned.

In one embodiment a fixed statistic may be computed from a fixed start time relative to the current time. In one embodiment the start time may be a multiple of the period past the anniversary time. For example if at 15 00 the value of a fixed statistic with a period of 24 hours and an anniversary time of 2004 09 01 12 00 00 is requested the usage accumulated since 12 00 the same day will be computed and returned.

In one embodiment one or more of the Service UsageType and Operation fields of the input statistic definition structure may be unspecified by the calling entity e.g. by inserting an or other wildcard indicator in the field . In this embodiment an output vector of one or more output statistics with all of these fields specified may be returned providing output statistics for all combinations of the fields left unspecified in the input statistic definition structure that satisfy the specified fields in the structure.

In one embodiment the get usage interface may accept arbitrary strings in one or more fields of the statistic definition structure for example to specify the storage units e.g. as bytes megabytes or gigabytes or bandwidth units. This may allow the requestor to arbitrarily specify the way the usage statistics are collected processed and or returned.

The following describes fields of an exemplary usage statistic value structure or record that may be returned to an entity that requested a usage statistic via the get usage interface and is not intended to be limiting.

Note that one or more usage statistic value structures may be returned to the requesting entity to satisfy one get usage request.

The following describes fields of an exemplary output statistic structure e.g. OutputStatistic in the above exemplary usage statistic value structure that may be returned to an entity that requested a usage statistic via the get usage interface as a field in a usage statistic value structure and is not intended to be limiting.

The following is an example of a get usage operation using an exemplary get usage interface. In this example the entity requesting a usage statistic makes a call to a get usage method of the metering service requesting some usage statistic s . The following is an example of what the call to the get usage method may look like and is not intended to be limiting 

where inputStatistic is a statistic definition structure such as the exemplary structure described above and statisticValue is a usage statistic value structure such as the exemplary structure described above. Note that getUsage may return a vector including one or more usage statistic value structures. Further note that getUsage may have one or more other parameters.

An exemplary output of the call to getUsage with the above inputStatistic structure may be a vector such as 

In other words the output was split over the Operation field since the input statistic left Operation unspecified and one output statistic for operation ADD with the value 114.5 and another output statistic for operation UPDATE with the value 2234.34 were returned in the vector. This indicates that these two operations were the only ones used in the given period by the entity with the given SubscriberID for the service XYZ and the storage usage type. Note that if the inputStatistic had specified ADD as the Operation then only outputStatistic1 would have been returned in the vector.

In one embodiment there may be three primary aspects or dimensions in scaling the metering system as described herein 

Growth in each of these dimensions may be managed differently. Note that a growth in detail throughput does not necessarily translate into a growth in aggregate throughput for instance a single subscriber that makes a large number of requests to the same service and operation generates a small amount of aggregate throughput and increasing the request rate will not increase the aggregate throughput required.

Note that the following discussion refers to . One embodiment of the metering system may support multiple partitions statically configured each writing to a single database pair. Another embodiment may support multiple database pairs per partition . This may allow scaling to be performed indefinitely in all three dimensions.

Increased detail throughput primarily affects the metering service layer of the metering system. The metering service layer may be scaled by adding more physical servers running instances of the metering service component. In one embodiment servers running instances of the metering service may sit behind a network load balancer. This may allow the metering service layer of the metering system to scale more or less linearly by adding hardware e.g. new servers each running one or more instances of the metering service .

It is possible that detail throughput may become high enough to exceed the capabilities of the metering partitions . The partition layer of the metering system may scale by adding a new partition which may share an existing database instance with an existing partition . Assuming that the partitioning is relatively even this layer scales linearly in the number of partitions .

Aggregate throughput primarily impacts the usage databases . In one embodiment databases may be implemented as MySQL databases. A MySQL database can only handle a certain amount of insert update traffic. Note that other embodiments may use other types of databases which may also be limited in the amount of insert update traffic that can be handled.

To increase aggregate throughput the number of database pairs may be increased. This may require more partitions to be added if all partitions already own a database pair rather than sharing with another partition . Assuming that the partitioning is relatively even this scales linearly in the number of database pairs.

Capacity growth may impact the usage databases . As with aggregate throughput capacity growth may be managed by adding more database pairs. Assuming that the partitioning is relatively even this scales linearly in the number of database pairs.

In one embodiment a Web server that implements one or more components of a network services metering system as described herein may include a general purpose computer system that includes or is configured to access one or more computer accessible media such as computer system illustrated in . In the illustrated embodiment computer system includes one or more processors coupled to a system memory via an input output I O interface . Computer system further includes a network interface coupled to I O interface .

In various embodiments computer system may be a uniprocessor system including one processor or a multiprocessor system including several processors e.g. two four eight or another suitable number . Processors may be any suitable processors capable of executing instructions. For example in various embodiments processors may be general purpose or embedded processors implementing any of a variety of instruction set architectures ISAs such as the x86 PowerPC SPARC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA.

System memory may be configured to store instructions and data accessible by processor s . In various embodiments system memory may be implemented using any suitable memory technology such as static random access memory SRAM synchronous dynamic RAM SDRAM nonvolatile Flash type memory or any other type of memory. In the illustrated embodiment program instructions and data implementing desired functions such as those methods and techniques described above for one or more components of Web services metering system are shown stored within system memory as code .

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the device including network interface or other peripheral interfaces. In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. In some embodiments the function of I O interface may be split into two or more separate components such as a north bridge and a south bridge for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computer system and other devices attached to a network . In particular network interface may be configured to allow communication between computer system and other computer systems hosting components of the Web services metering system. Network interface may commonly support one or more wireless networking protocols e.g. Wi Fi IEEE 802.11 or another wireless networking standard . However in various embodiments network interface may support communication via any suitable wired or wireless general data networks such as other types of Ethernet network for example. Additionally network interface may support communication via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fibre Channel SANs or via any other suitable type of network and or protocol.

In some embodiments system memory may be one embodiment of a computer accessible medium configured to store program instructions and data as described above for implementing one or more components of a Web services metering system. However in other embodiments program instructions and or data may be received sent or stored upon different types of computer accessible media. Generally speaking a computer accessible medium may include storage media or memory media such as magnetic or optical media e.g. disk or DVD CD coupled to computer system via I O interface . A computer accessible medium may also include any volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc that may be included in some embodiments of computer system as system memory or another type of memory. Further a computer accessible medium may include transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as a network and or a wireless link such as may be implemented via network interface .

Embodiments of the network services metering system as described herein may be used to meter any type of Web service. The following describes some types of Web services as examples of Web services for which embodiments of the network services metering system may be used.

Some Web service providers may provide Web service interfaces to collections of data such as product catalogs through which Web service clients may access the data to be used for example on Web sites provided by the Web service clients. The Web service interface may provide APIs to search retrieve and potentially even update the Web service provider s data. For example a Web service client may access product information in a product catalog through a Web services interface and display links to or advertisements for those products for sale through the Web service client s Web site. The Web service provider may for example pay a commission to the Web service client for each item sold.

Another exemplary Web service is a queue Web service. In this Web service a Web service provider may provide a Web service interface to an application that may allow Web service clients to create queues and to store data in and retrieve data from elements of the queues. The queues may be accessed and shared by two or more Web service clients allowing the clients to store and or exchange data via the Web service.

As an example a queue Web service may be used to decouple components of an application so that the components may run independently with the queue Web service easing messaging management between the components. Any component of a distributed application may store any type of data in a queue. Any other component or application may then later retrieve the data using queue semantics. The queue may serve as a buffer between a work producer that is saving the data and a work consumer that is retrieving the data for processing. Thus the queue Web service may resolve issues that would otherwise arise if the producer were producing work faster than the consumer can process the work or if the producer or consumer were only intermittently connected to the network.

Various embodiments may further include receiving sending or storing instructions and or data implemented in accordance with the foregoing description upon a computer accessible medium. Generally speaking a computer accessible medium may include storage media or memory media such as magnetic or optical media e.g. disk or DVD CD ROM volatile or non volatile media such as RAM e.g. SDRAM DDR RDRAM SRAM etc. ROM etc. As well as transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as network and or a wireless link.

The various methods as illustrated in the Figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software hardware or a combination thereof. The order of method may be changed and various elements may be added reordered combined omitted modified etc.

Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and accordingly the above description to be regarded in an illustrative rather than a restrictive sense.

