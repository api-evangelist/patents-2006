---

title: Method and system for instruction stuffing operations during non-intrusive digital signal processor debugging
abstract: Techniques for the design and use of a digital signal processor, including (but not limited to) for processing transmissions in a communications (e.g., CDMA) system. Stuffing instructions in a processing pipeline of a multi-threaded digital signal processor provides for operating a core processor process and a debugging process within a debugging mechanism. Writing a stuff instruction into a debugging process registry and a stuff command in a debugging process command register provides for identifying a predetermined thread of the multi-threaded digital signal processor in which to execute the stuff instruction. The instruction stuffing process issues a debugging process control resume command during a predetermined stage of executing on the predetermined thread and directs the core processor to perform the stuff instruction during the debugging process. The core processor may then execute the stuffed instruction in association with the core processor process and the debugging process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08380966&OS=08380966&RS=08380966
owner: QUALCOMM Incorporated
number: 08380966
owner_city: San Diego
owner_country: US
publication_date: 20061115
---
This application is related to the following United States patent application numbers application Ser. No. 11 560 217 filed Nov. 15 2006 entitled NON INTRUSIVE THREAD SELECTIVE DEBUGGING METHOD AND SYSTEM FOR A MULTI THREADED DIGITAL SIGNAL PROCESSOR U.S. patent application Ser. No. 11 560 323 now U.S. Pat. No. 7 657 791 filed Nov. 15 2006 entitled METHOD AND SYSTEM FOR A DIGITAL SIGNAL PROCESSOR DEBUGGING DURING POWER TRANSITIONS U.S. patent application Ser. No. 11 560 332 filed Nov. 15 2006 entitled METHOD AND SYSTEM FOR TRUSTED UNTRUSTED DIGITAL SIGNAL PROCESSOR DEBUGGING OPERATIONS U.S. patent application Ser. No. 11 560 339 filed Nov. 15 2006 entitled EMBEDDED TRACE MACROCELL FOR ENHANCED DIGITAL SIGNAL PROCESSOR DEBUGGING OPERATIONS.

The disclosed subject matter relates to data processing systems and processes such as may find use in data communications and similar applications. More particularly this disclosure relates to a novel and improved method and system for instruction stuffing operations during non intrusive digital signal processor debugging operations.

Increasingly telecommunications and other types of electronic equipment and supporting video complex audio videoconferencing and other rich software applications involve signal processing. Signal processing requires fast mathematical calculations and data generation in complex but repetitive algorithms. Many applications require computations in real time i.e. the signal is a continuous function of time which must be sampled and converted to digital signals for numerical processing. The processor must execute algorithms performing discrete computations on the samples as they arrive.

The architecture of a digital signal processor DSP is optimized to handle such algorithms. The characteristics of a good signal processing engine include fast flexible arithmetic computation units unconstrained data flow to and from the computation units extended precision and dynamic range in the computation units dual address generators efficient program sequencing and ease of programming.

One promising application of DSP technology includes communications systems such as a code division multiple access CDMA system that supports voice and data communications as well as text messaging and other applications between users over a satellite or terrestrial link. The use of CDMA techniques in a multiple access communication system is disclosed in U.S. Pat. No. 4 901 307 entitled SPREAD SPECTRUM MULTIPLE ACCESS COMMUNICATION SYSTEM USING SATELLITE OR TERRESTRIAL REPEATERS and U.S. Pat. No. 5 103 459 entitled SYSTEM AND METHOD FOR GENERATING WAVEFORMS IN A CDMA CELLULAR TELEHANDSET SYSTEM both assigned to the assignee of the claimed subject matter.

A CDMA system is typically designed to conform to one or more standards. One such first generation standard is the TIA EIA IS 95 Terminal Base Station Compatibility Standard for Dual Mode Wideband Spread Spectrum Cellular System hereinafter referred to as the IS 95 standard. The IS 95 CDMA systems are able to transmit voice data and packet data. A newer generation standard that may more efficiently transmit packet data is offered by a consortium named the 3Generation Partnership Project 3GPP and embodied in a set of documents including Document Nos. 3G TS 25.211 3G TS 25.212 3G TS 25.213 and 3G TS 25.214 which are readily available to the public. The 3GPP standard is hereinafter referred to as the W CDMA Standard.

Complex DSP operational software employing the W CDMA Standard for example requires robust development tools. Such development tools may include those for code generation integration testing debugging and evaluating application performance. In developing and operating software or complex DSP applications such as advanced telecommunications applications there is the need for sophisticated yet non intrusive debugging software. That is debugging software applications must be not only sufficiently robust to monitor test and support the correction of software defects and operational problems but also they may operate so as not to interfere with the core processor software during debugging operations. Otherwise any problems in the core processing software may not be detected or detected properly during the use of such debugging software.

Moreover during or in association with non intrusive debugging processes there is frequently the need to operate a variety of diagnostic analytical and other processes for determining various aspects of core processor operations. Such diagnostic analytical and similar programs may vary according to the specific type and amount of information a use may desire or an associated debugging process may need. Accordingly the ability to insert or stuff instructions into a debugging process dynamically could have significant advantages.

Presently however no known way to perform instruction stuffing operations exists for debugging core processes in association with a multi threaded digital signal processor as has been here described. Yet further no instruction stuffing process exists that may be thread selective by performing the functions of operating stuffed instructions on one two or more threads of a multi threaded digital signal processor. Moreover no instruction stuffing process or mechanism is known that allows a debugging process to execute instructions on the core processor in conjunction with or in association with both the core processing functions and the non intrusive debugging process.

Reasons for which instruction stuffing operations may be advantageous include for the purpose of reading and or writing core registers and memory. Also debugging process operations may be abstracted for user analysis including the use of various analytical application programs. Moreover instruction operations may allow a user to enter into the debugging process various instructions applicable to a specific type of debugging.

There is a need therefore for a debugging process and system for operation with a DSP which debugging process and system provides the ability for instruction stuffing operations during non intrusive digital signal processor debugging operations.

A need exists for an instruction stuffing process and mechanism that may be applicable to multi threaded digital signal processor debugging operations.

A need exists for an instruction stuffing process and mechanism that may be thread selective by providing the ability operate stuffed instructions on one two or more threads of a multi threaded digital signal processor.

Still a need exists for an instruction stuffing process or mechanism that allows a debugging process to execute instructions on the core processor in conjunction with or in association with both the core processing functions and the non intrusive debugging process.

Also a need exists for a non intrusive software debugging process instruction stuffing operations for processing instructions and data on a core process during non intrusive digital signal processor debugging operations.

Techniques for providing non intrusive thread selective debugging method and system for a digital signal processor including a multi threaded digital signal processor are disclosed which techniques provide for instruction stuffing operations during non intrusive debugging operations. The method and system here disclosed improve both the operation of a digital signal processor and the efficient use of digital signal processor instructions for increasingly powerful software applications including applications operating in personal computers personal digital assistants wireless handsets and similar electronic devices as well as increasing the associated digital processor speed and service quality.

According to one aspect of the disclosed subject matter a method and system for stuffing instructions in a processing pipeline of a multi threaded digital signal processor provide for improved software instruction debugging operations. The method and system provide for operating a core processor process within a core processor associated with the digital signal processor and a debugging process within a debugging mechanism of the digital signal processor. The debugging mechanism is associated with the core processor. The disclosed subject matter includes writing a stuff instruction into a debugging process registry associated with the debugging process and a stuff command in a debugging process command register associated with the debugging process registry in response to the stuff instruction. The stuff command provides for identification of a predetermined thread of the multi threaded digital signal processor in which to execute the stuff instruction. The present disclosure issues a debugging process control resume command from the core processor during a predetermined stage of executing on the predetermined thread and directs the core processor to perform the stuffed instruction during the debugging process. The present disclosure provides the stuffed instruction to the core processor for executing the stuffed instruction in association with the core processor process and the debugging process.

These and other advantages of the disclosed subject matter as well as additional novel features will be apparent from the description provided herein. The intent of this summary is not to be a comprehensive description of the claimed subject matter but rather to provide a short overview of some of the subject matter s functionality. Other systems methods features and advantages here provided will become apparent to one with skill in the art upon examination of the following FIGURES and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the accompanying claims.

The disclosed subject matter for a non intrusive thread selective debugging method and system for a multi threaded digital signal processor has application for multi threaded processing of any type for which the benefits here presented may be advantageous. One application appears in telecommunications and in particular in wireless handsets that employ one or more digital signal processing circuits. For explaining how a wireless handset may be used provides a simplified block diagram of a communications system that may implement the presented embodiments of the disclosed interrupt processing method and system. At a transmitter unit data is sent typically in blocks from a data source to a transmit TX data processor that formats codes and processes the data to generate one or more analog signals. The analog signals are then provided to a transmitter TMTR that modulates filters amplifies and up converts the baseband signals to generate a modulated signal. The modulated signal is then transmitted via an antenna to one or more receiver units.

At a receiver unit the transmitted signal is received by an antenna and provided to a receiver RCVR . Within receiver the received signal is amplified filtered down converted demodulated and digitized to generate in phase I and Q samples. The samples are then decoded and processed by a receive RX data processor to recover the transmitted data. The decoding and processing at receiver unit are performed in a manner complementary to the coding and processing performed at transmitter unit . The recovered data is then provided to a data sink .

The signal processing described above supports transmissions of voice video packet data messaging and other types of communication in one direction. A bi directional communications system supports two way data transmission. However the signal processing for the other direction is not shown in for simplicity. Communications system may be a code division multiple access CDMA system a time division multiple access TDMA communications system e.g. a GSM system a frequency division multiple access FDMA communications system or other multiple access communications system that supports voice and data communication between users over a terrestrial link. In a specific embodiment communications system is a CDMA system that conforms to the W CDMA Standard.

Output from execution data paths goes to register file write circuit also configured to accommodate individual threads T T for returning the results from the operations of DSP . Thus the data path from circuit and before to register file write circuit forms a processing pipeline . The present embodiment may employ a hybrid of a heterogeneous element processor HEP system using a single processor with up to six threads T T. Processor pipeline has six stages which matches the minimum number of processor cycles necessary to fetch a data item from circuit to registers and . DSP concurrently executes instructions of different threads T T within a processor pipeline . That is DSP provides six independent program counters an internal tagging mechanism to distinguish instructions of threads T T within processor pipeline and a mechanism that triggers a thread switch. Thread switch overhead varies from zero to only a few cycles.

DSP therefore provides a general purpose digital signal processor designed for high performance and low power across a wide variety of signal image and video processing applications. provides a brief overview of the DSP architecture including some aspects of the associated instruction set architecture for one manifestation of the disclosed subject matter. Implementations of the DSP architecture support interleaved multithreading IMT . In this execution model the hardware supports concurrent execution of multiple hardware threads T T by interleaving instructions from different threads in the pipeline. This feature allows DSP to include an aggressive clock frequency while still maintaining high core and memory utilization. IMT provides high throughput without the need for expensive compensation mechanisms such as out of order execution extensive forwarding networks and so on. Moreover the DSP may include variations of IMT such as those variations and novel approaches disclosed in the commonly assigned U.S. patent applications by M. Ahmed et al and entitled Variable Interleaved Multi threaded Processor Method and System and Method and System for Variable Thread Allocation and Switching in a Multi threaded Processor. 

Sequencer provides hybrid two way superscalar instructions and four way VLIW instructions to S Pipe unit M Pipe unit LD Load Pipe and LD ST Store Pipe unit all of which communicate with general registers . AXI Bus also communicates via Bus I F with shared data cache LD ST instructions to threads T T. Optional L2 Cache TCM signals include LD ST instructions with shared data TCM which LD ST instructions further flow to threads General Registers . From AHB peripheral bus MSM specific controller communicates interrupts with T T including interrupt controller instructions debugging instructions and timing instructions. Global control registers communicates control register instructions with threads T T.

DSP therefore includes six virtual DSP cores each containing global control registers and private supervisor control registers . Global control registers are shared between all threads. Each thread shares a common data cache and a common instruction cache. Load store and fetch operations are serviced by a common bus interface. High performance AXI bus and a lower performance AHB bus are used to connect the data and instruction traffic to off core memory and peripherals. An integrated level two memory cache and or TCM input is optional. Peripheral access may be through memory mapped loads and stores. The physical address partition between AHB and AXI may be configured at the MSM level.

Clearly the presented architecture for DSP may evolve and change over time. For example the number of instruction caches that DSP may use could change from six to one or other numbers of caches. Superscalar dispatch L1 data at TCM and other architectural aspects may change. However the present subject matter may have continued relevance in a wide variety of configurations and for a large family of modifications of DSP .

ISDB through JTAG interface provides a hardware debugging process for DSP . ISDB provides software debug features through JTAG interface by sharing system or supervisor only registers that are divided into supervisor control registers on a per thread basis as well as global control registers between all threads. The system control registers are used for per thread interrupt and exception control and per thread memory management activities. Global registers allow interacting with the ISDB for debugging operations.

ISDB enables software developers to debug their software while DSP operates. ISDB hardware in combination with a software debugging process program operating in ISDB may be used to debug the DSP operating system software. ISDB supports debugging hardware threads individually. Users may suspend thread execution view and alter thread registers view and alter instruction and data memory single step threads stuff instructions to threads and resume thread execution.

ISDB may interface with a debugging process interface card to communicate with ISDB debugging software residing on a program counter yet all through JTAG interface . Host debugging process software may interact with the ISDB by reading and writing ISDB control registers. Communication for example may be through a 40 bit packet which identifies the ISDB register to which read write is to occur as well as a 32 bit data payload. A packet format supporting this operation may be up to 64 control registers which may be 32 bits wide each.

ISDB interfaces with three domains host debugging software through JTAG DSP core through IU and CU and other cores present in the system through a Multi Core Debug MCD signal interface. The primary interface between the host debugging software and DSP core is a set of JTAG accessible registers referred to as ISDB registers. The host debugging software performs various debugging process tasks by executing a sequence of ISDB register reads and writes.

ISDB communicates with the test environment in this case a POD or debugging process interface card communicating with the debugging process software residing on a PC through JTAG interface . The host debugging process software interacts with the ISDB by reading and writing ISDB control registers. Communication occurs through a 40 bit packet which identifies the ISDB register in which to read and of write and a 32 bit data payload for the various ISDB command including the present instruction stuffing process.

ISDB provides hookups for multi core debug at the MSM level through MCD interface . The MCD interface consists of a pair of input signals which trigger break or resume of core processor and a pair of output signals which indicate that core processor is entering a debugging process or resuming program execution. The MCD break triggers may follow an edge based protocol such that when a rising edge is detected on an external breakpoint trigger the threads indicated in external breakpoint thread number mask suspend execution and enter debug mode. Similarly when a rising edge is detected on the MCD external resume trigger the threads indicated in external resume thread number mask if in debug mode resume normal program execution.

ISDB control logic is spread across two blocks ISDB controller in ISDB and CU ISDB controller in CU . ISDB controller handles the tasks of implementing ISDB enable ISDB version and ISDB general purpose register registers. MCD external break and resume triggers and ETM break trigger are synchronized to the core processor clock before they are forwarded to CU for further processing. ISDB controller also generates MCD break trigger and the MCD resume trigger based on debug mode status of core processor . ISDB controller adds a pipeline stage for signals sent out to DSP such as an ISDB interrupt break event and other signals. The rest of the control logic which includes breakpoint processing micro command generator mailbox and status logic is handled by CU ISDB controller .

CU includes circuitry and instructions capable of handling the tasks such as a processing breakpoints and generating break triggers to each thread b generating micro break and micro resume commands c maintaining ISDB status and mailbox registers and d implementing the certain ISDB registers. CU includes a breakpoint processing logic BPL block as appears in for processing all the breakpoints and generating a macro break request to a micro command generator of CU ISDB controller . The micro command generator processes the macro break request along with instruction stuff commands instruction step and resume commands and issues micro break and resume commands to CU for pipeline control.

CU ISDB controller maintains the state of ISDB based on the break and resume acknowledge signals received back. The mailbox functions of CU ISDB controller maintain mailbox registers used for communication between the host debug software and the DSP core processor. These mailbox functions also contain ISDB status registers.

To demonstrate illustrative circuitry for performing the presently disclosed instruction stuffing operations in association with non intrusive debugging operations includes ISDB JTAGSync circuit . ISDB JTAGSync circuit includes an ISDB test data register which DSP may use to read and write the ISDB control registers. ISDB JTAGSync circuit provides the synchronization logic between the ISDB test data register operating on DB tck and the ISDB control registers operating in the DSP clock domain. By reading and writing the ISDB control registers DSP performs various debugging process tasks as may be supported by the ISDB including the presently disclosed instruction stuffing operations.

In the implementation of ISDB JTAGSync circuit receives JTAG isdb chain in signal into ISDB Test Data Register to generate JTAG isdb chain out signal . ISDB Test Data Register includes read write R W bits Address bits 6 0 and Data bits 31 0 . Values in R W bits go to AND gate as do Sync circuit output and CU  trustedDebug input . JTAG isdb chain update tkl signal and ISDB CLK signal control the operation of Sync circuit . Address information from Address bits may be received by Address Decode circuit which feeds ISDB Registers . ISDB Registers transfer data with Data bits 31 0 in response to a write enable signal from AND gate .

ISDB JTAGSync circuit acts as the synchronization bridge between the TAP controller running on JTAG TCK in DB JTAG block and ISDB registers running on DSP core clock distributed in ISDB controller CU  ISDBCtrl and IU . The ISDB controller and CU ISDB controller contain the control logic of ISDB which consists of a micro command generator breakpoint processing logic and various ISDB registers configuration mailbox command etc. . These blocks execute different debugging process tasks initiated by host debugging software on the DSP core. The ISDB interrupt signal is sent out to the DSP subsystem where it is merged with other interrupt sources and sent back to the DSP core . Similarly an ISDB reset is merged with other reset sources power on reset software reset etc. to trigger a reset to the core. ISDB interfaces with external systems e.g. an MSM system external to DSP through an MCD signal interface. Two pairs of break and resume triggers are provided to support simultaneous debugging of DSP and other cores in external system.

The per thread mode state diagram of is supported by various instructions or events. These include Except or internal exception event an Int or external interrupt event an RTE or software return instruction from exception mode and SSR or update to SSR register instruction a Stop or software stop instruction that may be entered from any mode a Start or software Start Instruction that also may be entered from any mode a trap or software Trap Instruction a Wait or software wait Instruction a Resume or software Resume Instruction a DE or Debug Event and a DR or Debug Instruction. While the functions in different implementations of the claimed subject matter may vary slightly from those here presented the meanings of Start Wait Resume DE and or DR may be given their broadest interpretations consistent with the scope of the claimed subject matter.

Registers are available in DSP in both USER mode and SUPERVISOR mode . The user mode registers are divided into a set of general registers and a set of control registers. General registers are used for all general purpose computation including address generation scalar and vector arithmetic. Control registers support special purpose functionality such as hardware loops predicates etc. General purpose registers are 32 bits wide and may be accessed as single registers or as aligned pairs of two registers. The general register file provides all operands for instructions including addresses for load store data operands for numeric instructions and vector operands for vector instructions.

DEBUG mode provides a special state where the thread is waiting for commands from ISDB . Whenever an ISDB Debug Event occurs such as by the execution of a software breakpoint instruction a break command from ISDB or occurrence of a hardware breakpoint indicated threads may enter DEBUG mode . While in DEBUG mode the core is controlled by ISDB via commands from JTAG interface . When the ISDB releases the thread due to execution of a resume command the thread may resume operation according to their current mode settings. When a thread is in DEBUG mode it is controlled by ISDB and cannot be controlled by other threads. Such control may include the execution of various instructions as may be provided through the presently disclosed instruction stuffing operations. A Wait Resume Start or Stop instruction from a running thread targeting a thread in DEBUG mode may be ignored. Similarly a Non Maskable Interrupt NMI may be ignored by threads in DEBUG mode .

A HARDWARE RESET mode not shown in and DEBUG mode are global to all threads. Whenever the hardware reset pin is asserted regardless of any thread s processing state DSP may enter HARDWARE RESET Mode. In HARDWARE RESET mode all registers are set to their reset values. No processing may occur until the hardware reset pin is de asserted. When the reset pin is asserted the processor may transition into reset mode and all registers may be reset to their HARDWARE RESET values. After the reset pin is de asserted thread T may be given a soft reset interrupt. This may cause thread T to enter SUPERVISOR mode and begin executing at the reset vector location. All other threads may remain off. At this point the software is free to control mode transitions for each thread individually.

In it is seen that BPL circuit of CU ISDB controller includes break triggers from six different sources including hardware breakpoints HWBKPT and HWBKPT software breakpoint SWBKPT JTAG interface breakpoint JTAGBKPT ETM embedded trace macro breakpoint ETMBKPT and external breakpoint EXTBKPT . Break trigger through and debug mode status input go to encode break encoder to cause DSP to operate in DEBUG mode . Output from encoder includes three 3 breakpoint information bits and a breakpoint valid bit . Breakpoint information data enters breakpoint information circuit to cause a breakpoint information JTAG interface command . Breakpoint bit also generates OR gate input and reset circuit input. Reset circuit receives either a UCG resume thread number or a reset input to generate reset control output into OR gate . Either valid bit or reset output may cause OR gate to generate BPL breakpoint output .

The break triggers in BPL circuit are processed along with the corresponding thread number mask to generate macro break trigger to each of the threads. The macro break trigger bpl breakTnum ANY 0 is maintained until the corresponding thread is resumed. The number of pipeline stages that may be used in BPL circuit is driven by hardware breakpoints which are precise breakpoints i.e. the instruction that triggers hardware breakpoint match must not be executed. The thread switches to debug mode after executing the program until that instruction. The disclosed embodiment provides a macro break trigger one cycle after the break triggers arrive. For that reason the breakValid input is logically OR ed with its latched version input to generate bpl breakTnum ANY 0 output .

Through the use of breakpoints the six threads of DSP may individually enter and exit DEBUG mode . A breakpoint trigger may come from five sources which correspond to the five different types of breakpoints supported in ISDB . Upon hitting a breakpoint a thread transitions from its current mode e.g. WAIT RUN to DEBUG mode . In DEBUG mode the thread waits for commands from ISDB . A thread in OFF mode is powered down and may not accept any commands from ISDB . The latency of entering DEBUG mode is implementation defined such as in the present disclosure as relating to the event a power collapse. For example an implementation may choose to complete a given operation for example finish an outstanding load request before entering DEBUG mode . In one embodiment a thread identifier register contains an 8 bit read write field and is used for holding a software thread identifier. This field is used by the hardware debugging process to match breakpoints.

ISDB therefore has four operations break resume stuff instruction single step. From the micro architecture point of view there are two basic operations break and resume. The micro break command and micro resume command to refer to operations of break stuff instruction and single step. For example the stuff instruction operation may be viewed as a micro break command followed by micro resume command after the stuff instruction operations. Breakpoint operations may be triggered from five sources as herein described. Each break source may break multiple threads as specified in its corresponding tread number mask value.

The ISDB command register provides in the disclosed embodiment a 32 bit register whose value is output into DSP . The ISDB command register may be used to control external hardware and in an MSM specific manner. The ISDB control registers are accessed by the debugging process host software via JTAG interface and are distributed across three units ISDB IU and CU . Instead of placing all the registers in ISDB the registers are placed locally in the unit where the register values are used primarily.

The ISDB registers of are distributed among ISDB IU and CU the following way ISDB includes the ISDB enable register ISDB version register and ISDB general purpose register. The CU wherein are the ISDB control mailbox breakpoint logic and micro command generator blocks includes ISDB configuration registers ISDBCFG ISDBCFG the command register ISDBCMD breakpoint configuration registers BRKPTCFG BRKPTCFG breakpoint information register BRKPTINF breakpoint status register ISDBST breakpoint mailbox in register ISDBMBXIN ISDBMBXOUT . The IU register block includes breakpoint command registers BRKPTPC BRKPTPC breakpoint configuration registers BRKPTCFG BRKPTCFG and as is relevant to the present disclosure the stuff instruction register STFINST .

Instruction stuffing as here disclosed provides a method and system for ISDB to execute instructions on the core. Instructions are stuffed for various reasons. These may include for the reasons of reading and or writing core registers and memory as well as for debugging process operations abstracted for the user and user entered instructions. To stuff an instruction the user first programs the STFINST register of the ISDB command register with the 32 bit instruction to be executed. The ISDB command register is then written beginning with setting the command field to the STUFF code. Then the process sets the thread number field to the thread to receive the instruction. Preferably one bit in the thread number field may be set. The selected thread must be in DEBUG mode before the instruction may be stuffed. If more than one bit in thread number is set or the selected thread is not in debug mode the results are undefined. Then the instruction stuffing process includes setting the privilege level of the stuffed instructions either for use in USER mode or SUPERVISOR mode . After issuing the STUFF command the instruction may be executed on the chosen thread with the chosen privilege level. During instruction stuffing the program counter PC does not advance. Stuffed instructions which use the PC for branches or instructions that cause an exception may use the current PC value for the thread on which the stuffed instructions execute.

In the case that a stuffed instruction causes an exception the ISDB status register ISDBST may indicate that an exception occurred. The thread may remain in debug mode. The architected registers for the specific may reflect the exception state. For example if a LOAD instruction is stuffed that causes a TLB miss exception then an exception register ELR may be set to the current PC the PC may be changed to exception vector and a status register SSR may hold the correct cause code and status information. The debugging process software may query the ISDBST after stuffing an instruction that could cause an exception to see if an exception occurred. If it did then the SSR register may be read via stuffing a control register transfer instruction to determine the exception cause.

Once an exception has been recognized the debugging process has a number of choices as to how to handle the situation. For example the debugging process may choose to program a software or hardware breakpoint at the exception return point and resume the thread in order to run the handler. Also the debugging process could redirect a thread to an operating system helper function as well as to step through the handler using a single step function. Furthermore the debugging process may manually fix the problem e.g. reload the TLB . The exact strategy is left to the operating system and or debugging process implementation.

Registers cache and memory may be accessed by stuffing the appropriate instruction sequences. The debugging process software may read write thread registers by stuffing the appropriate control register transfer instruction to move data between a core register and the ISDB mailbox. This instruction may be stuffed using supervisor privilege level to ensure no exception occurs. Cache contents data and cache tag value may be read and or written by stuffing the appropriate cache maintenance and load instructions.

Memory may be read written by stuffing the appropriate LOAD STORE instruction. When the MMU is enabled Loads and Stores always execute using a virtual address. The MMU provides the information may be stored in a cache memory such as signaling as cacheable uncacheable etc. If it is desired to access memory from a particular source for example to read from a device in uncached memory then the debugging process software ensures that the MMU is properly configured for this access. For certain debug scenarios the debugging process software may engage the help of the operating system to configure a specific scenario.

Cache contents are affected as if the stuffed instruction came from normal program flow. For example a cacheable load that misses in the data cache may cause a line replacement. In the case that one thread is in debug mode and others are running the cache contents may change accordingly. In the case of a load that misses in the cache or an uncached load the stuff command may not be reported as complete in the ISDB status register until the load data returns and the operations completes normally.

To read instruction memory a similar procedure as reading data memory may take place. To write instruction memory for example to set software breakpoints the debugging process software may first stuff a STORE instruction to write the instruction memory. Then the process includes stuffing a data cache clean address instruction to force the data into external memory stuffing a barrier instruction to ensure that the change is observable in external memory and an instruction cache invalidate address instruction to remove the old entry from the instruction cache.

Instruction stuffing as herein disclosed may also be of use in association with resetting DSP . Note that executing an ISDB RESET command forces a hardware reset and causes the entire DSP i.e. all threads to reset. This may set all registers to initial values power off threads T T and send a reset interrupt to thread T. If on the other hand it is desired to reset just certain threads this can be done using instruction stuffing. The steps include stuffing a START instruction with appropriate mask settings. This may cause a reset interrupt to be pending to the indicated threads. Then the sequence includes executing an ISDB RESUME instruction on the desired threads. Performing such a sequence therefore makes possible an advantageous process of thread selective resetting without resetting all of DSP .

CU sends a stuff instruction request to IU in the following RF stage and asserts a CU next issue pointer instruction in the WB stage. Upon receiving the CU next issue point instruction IU provides the stuffed instruction to CU in a similar way as an UC instruction. It may be multiplexed with BU return data inside IU once instead of multiplexing on a per thread basis. This feature saves multiplexing cost as well as routes congestion over and instruction cache. The micro resume command is associated with a side band signal to indicate the privilege level of the stuffed instruction. This permits executing in either USER mode or SUPERVISOR mode .

While the stuffed instruction is being executed CU sends another instruction request to IU to restore the instruction buffer with the regular program instruction. When the stuffed instruction is committed CU needs to return micro resume status in the WB processing stage whether the resume status is success or not along with an acknowledgement. ISDB controller then issues a micro break command in the following RF stage to prevent CU from executing the next instruction. If the resume status is not success CU may instruction IU to handle the exception in normal ways. Note however that the only reason is that the stuffed instruction causes an exception. The current program counter may be pushed to ELR and then updated to the except handler entry point. The thread may be stopped due to the micro break command. After receiving micro break command acknowledge stuff instruction may be complete. Accordingly the micro break command status may be always success in this case.

In summary the disclosed subject matter provides a method and system for stuffing instructions into a processing pipeline of a multi threaded digital signal processor for improved software instruction debugging operations. The method and system provide for writing a stuff instruction into the debugging process registry. The disclosure includes writing a stuff command in a debugging process command register for executing the stuffed instruction. A predetermined thread of the multi threaded digital signal processor in which the execution of the stuff instruction is to be executed is identified by the stuff instruction. The process and system issue a CU debugging process control resume command during a predetermined stage i.e. the EX3 stage of executing the thread on the multi threaded digital signal processor and set the CU debugging process resume type to the predetermined stage of executing the thread for indicating that the issued resume command is to perform a stuff operation. The present disclosure also asserts a CU exception command in the WB stage of following cycle and clears off the old instruction buffer state upon assertion of the CU exception command. Then the method and system prepare to fetch from a new location similar to a regular exception while maintaining ELR notwithstanding a debugging process exception.

Also the present embodiment sends a stuff request from the CU to IU in a subsequent processing stage and asserts a CU next issue pointer the following cycle. The stuffed instruction is provided to the CU upon receiving the CU next issue pointer whereupon IU provides the stuffed instruction to CU in a similar way as an UC instruction. The stuffed instruction is then multiplexed with BU return data inside the IU only once instead of on a per thread basis. The micro resume command is associated with a side band signal to indicate the privilege level of the stuffed instruction execute in user supervisor mode . While the stuffed instruction is being executed CU sends another instruction request to IU to restore the instruction buffer with the regular program instruction. Then when the stuffed instruction is committed CU needs to return micro resume status in WB whether the resume status is success or not along with an acknowledgement. The CU ISDB controller then issues a micro break command in the following RF stage to prevent CU from executing the next instruction. If the resume status is not success i.e. when the stuffed instruction causes an exception the CU may control the IU to handle the exception in normal ways. Then the current PC may be stored in the ELR register of DSP and the PC may be updated to the except handler entry point. The thread may then be stopped due to the micro break command. After receiving micro break command acknowledge the stuff instruction is complete.

The processing features and functions described herein for instruction stuffing operations in association with non intrusive thread selective debugging in a multi threaded digital signal processor may be implemented in various manners. For example not only may DSP perform the above described operations but also the present embodiments may be implemented in an application specific integrated circuit ASIC a microcontroller a digital signal processor or other electronic circuits designed to perform the functions described herein. Moreover the process and features here described may be stored in magnetic optical or other recording media for reading and execution by such various signal and instruction processing systems. The foregoing description of the preferred embodiments therefore is provided to enable any person skilled in the art to make or use the claimed subject matter. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments without the use of the innovative faculty. Thus the claimed subject matter is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

