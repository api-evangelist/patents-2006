---

title: Methods and apparatus to tune intermediate representations in a managed runtime environment
abstract: Methods and apparatus are disclosed to tune intermediate representations in a managed runtime environment. An example method disclosed herein receives a bytecode at a virtual machine during runtime, determines a method of the received bytecode, identifies an optimized intermediate representation associated with the method, and imports the optimized intermediate representation from the memory into the virtual machine. Other embodiments are described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07793275&OS=07793275&RS=07793275
owner: Intel Corporation
number: 07793275
owner_city: Santa Clara
owner_country: US
publication_date: 20060331
---
This disclosure relates generally to just in time complier programs and more particularly to methods and apparatus to tune intermediate representations in a managed runtime environment.

Intermediate representations of programs that operate in a managed runtime environment MRTE may address specific platform characteristics platform dependent or exist in a platform neutral platform independent format. Platform independent code includes bytecode e.g. Java bytecodes or the Common Language Interface CLI by Microsoft. which is typically a high level programming representation that does not accommodate low level optimization opportunities. Bytecodes are typically generated from a high level programming language having a human readable format. The bytecodes are intermediate representations that are platform independent but much less abstract and more compact than the human readable format from which they are derived. The bytecodes are typically compiled by a just in time JIT compiler resulting in machine code specific to a computer platform. As such the high level bytecodes may be distributed to many target computers without regard to the variation of the target platforms because the JIT compiler manages the details associated with the platform variations.

Because human readable formats of code and or bytecodes are in a high level and platform independent format optimization of the code performance is very limited. Persons of ordinary skill in the art will appreciate an opportunity to program lower level operations which may include but are not limited to compare and swap operations and incrementing a garbage collection frontier pointer. Such low level operations are typically inlined by the JIT compiler into generated code for performance enhancement. However applying optimization at the bytecode level is usually inappropriate because either the platform neutral format of the bytecode would be destroyed or more importantly subsequent optimizations by the JIT compiler bytecode verifiability would be impeded. For example a bytecode level optimization may improve code performance for some platforms having a JIT compiler while hindering code performance in an alternate target JIT compiler.

Additionally or alternatively JIT compilers may employ what are commonly referred to as magic methods to optimize code performance on specific platforms. The JIT compiler may recognize certain desired methods to be executed via the bytecodes and subsequently ignore such bytecodes in favor of internally generated optimized intermediate representation code that is used to produce executable code for the method. The magic methods are stored on the target machine as a part of the JIT compiler and exist as a result of the JIT compiler designer s identifying relatively common and or popular methods for relatively common and or popular platforms e.g. mainstream methods and platforms . Thus in view of the limited optimization capabilities of high level bytecodes the compiler designer s provide optimized versions of such commonly used methods i.e. the magic methods to perform optimally on particular platforms used by a large percentage of the JIT compiler user base. When the JIT compiler identifies a bytecode that matches a magic method then the JIT compiler ignores the entire bytecode of the magic method or bytecode instruction that invokes it and instead generates optimized intermediate representations either high level or low level to produce executable code.

Although the use of magic methods allows optimized performance on specific platforms in response to platform independent bytecodes such magic methods are available if and when the designer of the JIT compiler creates them. Like many products targeted to a mass market product designers attempt to satisfy their largest contingency to a much higher degree than the users employing the product in a non standard and or unique manner. Furthermore even when the magic methods successfully optimize various methods of the largest user base the user s may be aware of additional and or alternate optimization techniques that the magic methods do not address. As such the users of typical JIT compilers often rely on the JIT compiler designers for optimization techniques.

In general example methods and apparatus for loading low level platform independent and low level platform dependent code into a managed runtime environment MRTE just in time JIT compiler are described herein. Typically a virtual machine VM is a part of an MRTE that includes among other things a JIT compiler. The JIT compiler may be an integral part of i.e. statically linked to the VM or a dynamically loaded library. The example methods and apparatus disclosed herein permit a user to develop hand tuned low level code that may address unique optimization techniques rather than rely upon canned magic methods or general code optimizations provided by JIT compiler designers. The example methods and apparatus further permit such hand tuned low level code to be loaded into the MRTE code transformation pipeline instead of the canned magic methods and or bytecodes.

As a result the user is provided with example methods and apparatus to express optimization techniques as high level intermediate representation HIR or low level intermediate representation LIR code that the JIT compiler can use for subsequent operations including but not limited to inlining and code generation instead of the bytecode. Users may be limited by high level bytecode optimization efforts thus dependent upon the magic methods. However users of the example methods and apparatus described herein may expose critical VM and system library operations to their own optimization techniques as needed. The optimization techniques may include but are not limited to synchronization functions native method invocation object allocation and array copying.

As described above reliance upon bytecode for all optimization efforts includes significant limitations. Benefits of bytecodes include platform and VM independence however they are typically high level languages with complex semantics of many instructions. As such support for lower level instructions and optimizations thereof is limited and would require that all VM implementations support such optimizations. While bytecodes may operate as a widely adopted standard on many different JIT implementers they allow less control as compared to intermediate representations which include more simplistic semantics and fine grained operations.

Referring to an example VM includes a class loading subsystem that among other things locates and imports binary data for classes subsequently forwarded to a JIT compiler . is described below with operations shown as various sized rectangles and data shown as various sized ovals. As discussed in further detail below if the user has created optimized HIR and or LIR then the class loading subsystem finds such stored binaries and forwards them to the JIT compiler instead of bytecodes . The JIT compiler may receive IR source code generated by a user e.g. HIR source code LIR source code IR source code from the class loading subsystem bytecodes and IR binaries from the class loading subsystem or directly from a library in an external storage as discussed in further detail below. Users may generate HIR and LIR source code as for example a text file. The example JIT compiler also includes an IR translator an IR loader and a JIT compiler pipeline . The JIT compiler pipeline includes in memory HIR in memory LIR a code selector a bytecode translator a code emitter and generated code . Additionally the JIT compiler pipeline include a high level optimizer H OPT and a low level optimizer L OPT .

The example VM may operate in either an ahead of time mode or a just in time mode. The ahead of time mode allows the user to translate hand tuned HIR and or LIR source code to a binary format for future use. For example dotted arrows indicate various VM components employed during the ahead of time mode and solid arrows indicate components that may be used during the just in time or runtime mode. In particular IR source code is provided to the IR translator to translate textual representations of an HIR and or LIR program to in memory HIR representations and or in memory LIR representations e.g. data structures . The in memory format is provided to the IR loader which contains an HIR serializer deserializer SERDES to convert the HIR in memory representations into a binary format and vice versa i.e. convert the HIR binary format to an HIR in memory representation . Similarly the IR loader contains an LIR SERDES to convert the LIR in memory representations into a binary format and vice versa i.e. convert the LIR binary format to an LIR in memory representation . The IR binaries resulting from the HIR and or LIR serializer are stored in the external storage in for example user defined attributes of class files or external libraries in proprietary formats.

During the run time mode IR binaries of the external memory are embedded into the JIT compiler pipeline . In particular the class loading subsystem determines if an IR binary of the method is represented in the external storage . If so rather than compiling the bytecode with the bytecode translator the IR binaries are retrieved from the class loading subsystem or directly from a library in an external storage and deserialized into IR in memory representations by the deserializers of the IR loader . HIR in memory representations of the JIT compiler pipeline are translated to in memory LIR by the code selector during run time as will be appreciated by persons of ordinary skill in the art. The code emitter produces machine code from the IR in memory representations that are suitable for a target machine. Persons of ordinary skill in the art will appreciate that the IR loader may check if the provided HIR LIR binary is consistent with the bytecode that it is supposed to replace. Consistency checking may include but is not limited to a verification that the IR binary was produced from the same bytecode b verification of IR binary type safety and c checking IR binary control flow graph structure instructions and operands for possible errors that may lead to platform crashes. When the class loading subsystem receives a bytecode during runtime and no corresponding HIR and or LIR binaries exist in the external storage then the class loading subsystem allows the bytecode to advance to the JIT compiler pipeline for compilation by the bytecode translator .

IR sources may also be used at runtime and are not limited to only such IR source code that was stored as a binary in the external storage while the example VM was in ahead of time mode. IR sources may be loaded by the VM during runtime and translated into HIR and or LIR in memory representations prior to platform specific machine code by the JIT compiler pipeline . Additionally the IR source may exist in a separate file and or a user defined class file attribute.

One particular advantage that the example methods and apparatus have over existing optimization approaches may include an opportunity for the user to override any managed method code with hand tuned low level as opposed to bytecode and highly optimized code. As such the user does not need to interfere with higher level aspects of the MRTE code. Further even if JIT compiler vendors employ an exhaustive list of magic methods in an attempt to satisfy a large portion of their customer base existing methods do not permit further user experimentation and or implementation of optimization techniques. Rather than leave users at the mercy of the JIT compiler vendors marketing plans competence and or thoroughness or lack thereof the users may proceed with varying degrees of experimentation to determine optimization techniques that work best for their systems. Such experimentation may further allow the user to thoroughly test the JIT compiler under a variety of situations thereby permitting an iterative test and review environment for IR optimization at a low level e.g. LIR .

The example methods and apparatus allow the users to re write any method that is traditionally represented as bytecodes and or magic methods compile the new methods in HIR and or LIR store such optimized HIR and or LIR methods as binaries and plug in such binaries during runtime. As described above plugging in the binaries during runtime may be handled by the class loading subsystem or any other module that passes a location e.g. a pointer of the optimized method to the VM and or the JIT compiler.

Benefits to VM helpers are also realized by the example methods and apparatus described herein. VM helpers for example are pieces of VM dependent native code that need to be executed by managed code. This code either generated by a JIT compiler or provided in some form by the VM performs some basic tasks that are highly VM dependent. Tasks may include but are not limited to allocating objects on a managed heap entering and or exiting a monitor and initializing a class. Because such VM helpers are typically called by the managed code the present example methods and apparatus permit the user to take control of this process by writing IR e.g. HIR and or LIR which is inlined into managed code. For example the user may develop a custom VM helper that prevents unnecessary deep calls resulting in a faster path of execution.

Because managed code may not be able to properly handle calling all native methods such calls may be handled through an application programming interface API such as the Java Native Interface JNI . JNI is a framework that allows code running in a VM to call and be called by native applications and libraries written in other languages. Similar to VM helpers the JNI may not always provide a user with low level control thus optimization is limited to capabilities built into the JNI. To help reduce the traditional bottleneck that occurs during the transition from managed code to native code users may develop HIR and or LIR as an alternative to JNI stubs that traditionally allow safe operation of managed entities. Rather than reliance upon the JNI for management of the formal parameters of the native call proper exception handling should it occur in the native method garbage collector safepoints and or other tasks associated with managed to native code transition which may depend on a particular JNI implementation the user is provided an opportunity to develop HIR LIR to handle such calls in any manner they chose.

Although the foregoing discloses example methods and apparatus including among other components firmware and or software executed on hardware it should be noted that such methods and apparatus are merely illustrative and should not be considered as limiting. For example it is contemplated that any or all of these hardware and software components could be embodied exclusively in dedicated hardware exclusively in software exclusively in firmware or in some combination of hardware firmware and or software. Accordingly while the following describes example methods and apparatus persons of ordinary skill in the art will readily appreciate that the examples are not the only way to implement such systems.

The IR translator assembles the HIR and or LIR source code into an HIR and or LIR in memory format block and the IR loader serializes the HIR and or LIR in memory format into a binary format block . The binary format may be stored to the external storage block for later retrieval and use at runtime.

The computer system of the instant example includes a processor . For example the processor can be implemented by one or more Intel microprocessors from the Pentium family the Itanium family the XScale family or the Centrino family. Of course other processors from other families are also appropriate.

The processor is in communication with a main memory including a volatile memory and a non volatile memory via a bus . The volatile memory may be implemented by Synchronous Dynamic Random Access Memory SDRAM Dynamic Random Access Memory DRAM RAMBUS Dynamic Random Access Memory RDRAM and or any other type of random access memory device. The non volatile memory may be implemented by flash memory and or any other desired type of memory device. Access to the main memory is typically controlled by a memory controller not shown in a conventional manner.

The computer system also includes a conventional interface circuit . The interface circuit may be implemented by any type of well known interface standard such as an Ethernet interface a universal serial bus USB and or a third generation input output 3GIO interface.

One or more input devices are connected to the interface circuit . The input device s permit a user to enter data and commands into the processor . The input device s can be implemented by for example a keyboard a mouse a touch screen a track pad a trackball isopoint and or a voice recognition system.

One or more output devices are also connected to the interface circuit . The output devices can be implemented for example by display devices e.g. a liquid crystal display a cathode ray tube display CRT a printer and or speakers . The interface circuit thus typically includes a graphics driver card.

The interface circuit also includes a communication device such as a modem or network interface card to facilitate exchange of data with external computers via a network e.g. an Ethernet connection a digital subscriber line DSL a telephone line coaxial cable a cellular telephone system etc. .

The computer system also includes one or more mass storage devices for storing software and data. Examples of such mass storage devices include floppy disk drives hard drive disks compact disk drives and digital versatile disk DVD drives.

As an alternative to implementing the methods and or apparatus described herein in a system such as the device of the methods and or apparatus described herein may alternatively be embedded in a structure such as processor and or an ASIC application specific integrated circuit .

Although certain example methods apparatus and articles of manufacture have been described herein the scope of coverage of this patent is not limited thereto. On the contrary this patent covers all methods apparatus and articles of manufacture fairly falling within the scope of the appended claims either literally or under the doctrine of equivalents.

