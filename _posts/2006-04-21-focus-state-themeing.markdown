---

title: Focus state themeing
abstract: Focus state themeing is accomplished by separating the processing of the focus state from the processing of an operative state of a control element. The operative states of the control element are entered or exited based upon the detection of input from a user or the detection of control availability by the operating system or by an application running on the operating system. Once an operative state is determined for a control element, the focus state of the control element is detected and merged with the operative state to generate a theme state for the control element. The theme state is a combination of the operative state and the focus state. There is one combined theme state for each operative-focus combination. Various display configurations may be used to represent a control element with a combined operative-focus state. The control element is then rendered on a display based on the operative state theme and the focus state theme.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08458608&OS=08458608&RS=08458608
owner: Microsoft Corporation
number: 08458608
owner_city: Redmond
owner_country: US
publication_date: 20060421
---
This application is a continuation of U.S. patent application Ser. No. 09 827 957 abandoned filed Apr. 5 2001 and entitled Focus State Themeing which is a continuation in part application of U.S. patent application Ser. No. 09 670 791 now U.S. Pat. No. 6 873 337 filed Sep. 27 2000 issued as U.S. Pat. No. 6 873 337 and entitled Application Programming Interface For Changing The Visual Style which claims the benefit of U.S. Provisional Application No. 60 195 593 filed Apr. 6 2000. This application further claims the benefit of U.S. Provisional Application No. 60 196 004 filed Apr. 7 2000 and entitled Focus State Themeing. 

The present invention relates to a computer system and more particularly to changing the theme of a focus state indicator for control elements in a graphical user interface.

Computer users in both the business and home environment have become accustomed to using a computer with a graphical operating system. For example many users operate computers having a Microsoft Corporation WINDOWS operating system thereon. Certain components of these graphical operating systems are known as controls. For example a control may be an OK button which is generally a rectangular button with OK written in it. By moving the cursor over the button and clicking on the mouse a known operation will begin that is associated with the control. Many other controls exist with examples including scroll bars dialog boxes and sliders. Beyond controls the graphical operating systems also draw or render other graphical components as needed on the display of the computer such as the frame the minimize box and the close box.

There are two general kinds of controls in WINDOWS standard and custom. Standard controls are provided by the operating system. The code to create draw and operate standard controls is contained in the common control library DLL a part of WINDOWS. Custom controls are all other controls. Custom controls may be created by the manufacturer of the operating system or by third parties. The code for custom controls is contained in a corresponding separate library DLL or within an application.

Currently when a graphical user interface component such as a control is used by an application the application requests that an instance of the component be created. Following this the operating system transmits a generic message to the component instructing the component to render itself. The application plays a role in routing the message from the main window to the targeted control but the control code performs the drawing. The application uses application programming interfaces API s to create and interact with the control. An API serves as a software interface to be used by other programs much as the keypad serves as an interface to a calculator. An API is a fundamental concept of high level programming. In high level programming a program often does not execute tasks by itself. Instead the program asks some other program to execute these tasks. For example programs frequently delegate various tasks to the underlying operating system. Continuing with the above example an application delegates the rendering of a control to the control s code.

In the prior art environment when a generic rendering message is received by a control to draw itself the control will draw itself using its own drawing software code. In this prior art environment the control knows what it is supposed to look like how it is supposed to behave and can effectuate such a display on the user interface of the computer. Thus the application may delegate all aspects of visual rendering to the controls avoiding the need to contain software code to support the visual rendering of the control within the host application itself.

By utilizing the standard controls defined and rendered by the operating system all controls will have the same appearance regardless of the application. Users of graphical operating systems can change only a limited number of characteristics of the controls. In the WINDOWS operating system a user can change the color scheme used to display the various controls and components on the monitor. The user can also select a small set of fonts to be used by the controls and components. The user can also specify a limited number of nonclient sizes that will control the sizing of the nonclient areas. Thus the colors fonts and a limited set of sizes of the controls and components may be changed. However the basic appearance of the controls and components is dictated by the rendering software code within the control library containing the particular graphical component or control. In the prior art environment to change the appearance of the controls or graphical components the rendering software code must be altered. For example if it is desired to change the appearance of the OK button the rendering software code within the operating system DLL file containing the button control must be altered and the DLL file reconstructed at the binary level. If it was desired to render the button as an oval with okay written inside the software code would have to be changed accordingly. Such an approach makes it difficult if not impossible for a computer user and for software manufacturers to easily alter the appearance of the controls and graphical components.

In order to enhance the user experience of the computer it would be desirable for the user to have the ability to change the overall look and feel of the graphical display by changing the overall visual appearance or theme of the various graphical components. In other words it would be desirable if the user could change not only the color and font of the graphical components appearing on the monitor but to change the appearance of those graphical components as well. For example it would be desirable to be able to alter and direct the layout of the parts of a control and to define the shape of a control or its parts. It would also be desirable to control all aspects of how a control or its parts are drawn. Because the controls and graphical components existing within the DLL file in the prior art environment are hard coded with their own rendering software code it is difficult and cumbersome to change the appearance of all of the controls and components. To do so would require recoding each of the controls to achieve the desired appearance. If multiple visual styles were required they would each have to be predefined and each hard coded into every control. Moreover the controls must also be recoded if a different rendering technology is to be used. For example if the controls are rendered using a bitmap and it is desired to utilize a vector based renderer each control must be altered.

Moreover existing techniques do not provide an interface through which software developers can design controls to accommodate versatility in visual appearance. The prior art approaches do not involve an architecture that allows a control author the flexibility to design a control that is theme aware. Control authors are therefore not allowed the freedom needed in authoring controls to create controls which can easily be visually altered.

As a part of changing the theme for controls it is desirable to also change the theme of focus state indicators associated with controls. Focus state indicators are used in keyboard access graphical user interfaces such as the user interface provided by the Microsoft Windows operating system. However these focus state indicators are currently apart of the image rendered for a given control. Therefore to change the theme of a focus state indicator for each control would require changing the rendering code for drawing each control.

In accordance with this invention the above and other problems are solved by separating the processing of the focus state from the processing of an operative state of a control element. The operative states may be disabled normal hot and active. These states are entered or exited based upon the detection of input from a user or the detection of control availability by the operating system or by an application running on the operating system. Once an operative state is determined for a control element the focus state of the control element is detected and merged with the operative state to generate a theme state for the control element. The theme state is a combination of the operative state and the focus state. There is one combined theme state for each operative focus combination. Various display configurations may be used to represent a control element with a combined operative focus state. The control element is then rendered on a display based on the theme state.

In accordance with other aspects the present invention relates to a system for themeing a focus state indicator separate from an operative theme for a control component in a graphical operating system. In the system an operative state module determines the operative state of the control component. A focus state detector tests whether or not the control component is in a focus state and indicates either focus condition or a non focus condition. A build combined state module in response to the focus condition merges the operative state and the focus state into a combined state indicating the control component may be rendered based on both a operative state theme and a focus state theme.

In accordance with another aspect of the invention a user interface with selectable focus indicators for control elements in a graphical user interface for a computing system is provided. The computing system has a display and a keyboard and a control element in a focus state is selectable with a keystroke on the keyboard. The user interface comprises the following operations. An operative state theme for rendering the display of an operative state for a control element is received. A focus state theme for rendering the focus state of the control element is also received. The control element is displayed in a combined operative focus state. The rendering of the control element in the combined state is based on the operative state theme and the focus state theme. In this way control elements in the user interface have selectable focus indicators.

In accordance with still other aspects the present invention relates to a method of changing visual styles of a focus state indicator in a control component in a graphical operating system running on a computing system. The method begins by receiving the operative state of the control component and detecting whether or not the control component is in a focus state. When the control component is not in a focus state the method draws the control component using an operative state theme. A combined state is created for the control component when the control component is in a focus state. The combined state is a single merged state representing the operative state and the focus state. The method draws the control component in the combined state using the operative state theme and a focus state theme whereby the visual style of a focus state indicator in the control component is changed by the focus state theme.

The invention may be implemented as a computer process a computing system or as an article of manufacture such as a computer program product or computer readable media. The computer program product may be a computer storage media readable by a computer system and encoding a computer program of instructions for executing a computer process. The computer program product may also be a propagated signal on a carrier readable by a computing system and encoding a computer program of instructions for executing a computer process.

Additional advantages and novel features of the invention will be set forth in part in a description which follows and in part will become apparent to those skilled in the art upon examination of the following or may be learned by practice of the invention.

At the beginning of the operational flow in operative state module as a part of the operating system generates an operative state or control state for a user interface element that is to be rendered or drawn on the display. The user interface elements having control states are typically control buttons menu selections icons tabs or any control element that may be user selected by mouse or key stroke. In this description the user interface elements having control states are variously referred to as controls control elements or control buttons. The operative state module is receiving input indicating availability or no availability for the control element and indicating user input relative to the control. The various operative states for the control are disabled normal hot and selected. The operation of module will be described in more detail hereinafter with reference to the state diagram shown in .

Focus state detect operation tests whether the control for which the operative state has been determined by module is also in a focus state. If the control is not in a focus state then operation flow branches from the focus state detection operation to the draw operative state operation for the control. Draw operative state operation receives the operative state theme data and draws the control in its operative state i.e. disabled normal hot or selected in accordance with a selected theme for the operative state.

If the focus state detection operation detects that the control is also in focus state as well as the operative state then the operation flow branches YES to the build combined state module . The build combined state module makes use of the operative state information and the focus state information to build a combined or merged theme state that represents in effect a combination of operative and focus. For example if the control operative state is normal and the control is also in a focus state then module will create a normal focus merged theme state. Draw combined state operation receives the operative state theme properties from operative state theme data and also receives the focus state theme properties from focus state theme data . These properties are used by the draw combined state operation to draw the control in the normal focus state and render the normal control in a focused state representation on the display. By separating the focus state out of the operative state for the control it is possible to apply different focus state themes to the control. Thus the focus state indicators for a control may be adjusted to various visual styles. The draw operations and will be described in more detail hereinafter with reference to .

The architecture of the themeing system in one embodiment of the present invention is illustrated in . describe in detail the operations and environment of the themeing system. If the reader is already familiar with the operations of the themeing system due to familiarity with the related patent application identified above then it is suggested that the reader proceed to the description of to understand embodiments of the present invention related to themeing with the focus state.

In operating system is a graphical operating system having graphically displayed controls and components associated therewith. In addition to controls discussed above controls also include but are not limited to such things as scroll bars push buttons and sliders. Other controls are within the scope of this invention and are known to those of skill in the art. Graphically displayed components include but are in no way limited to non client sections of the windows in the display such as the frame surrounding an application display on the user interface the minimize box and the close box.

In the basic architecture used in this embodiment of the present invention is illustrated. The architecture is illustrated with example applications that are open and running on the computer . As an application is running it often requires a control or graphical component to be rendered or displayed on the monitor of the computer .

In libraries and are linked to the applications through a fusion module . Fusion module enables the themeing of controls in applications without needing to change the applications themselves to request the themeable version of the controls. Fusion module enables each application to load the specific version of the DLL or at run time through the use of a manifest. The fusion manifest specifies the environment in which an application will run which allows multiples versions of a DLL to exist on one machine. Thus fusion module will map the request for a component so that it is rendered as a themeable element in DLL instead of a non themeable element from DLL . This allows an existing application to be themed without changing code of the application. Fusion module also allows the new themeable controls to be placed in a different DLL from the existing DLL which simplifies implementation and minimizes compatibility risks.

An example display of graphical control components having a variety of appearances is seen in . As shown in the controls may take the form of an OK button a Cancel button and an Apply button . The appearance of the controls and other components may be visually changed to better suit the desire of the computer user. The appearance of the controls may be altered beyond color and font selection. For example the layout of the parts of a control can be defined as desired. For example a scroll bar could be rendered with the up and down arrow buttons adjacent to each other at the bottom of the scroll bar instead of the up arrow and the top and the down arrow at the bottom. Further the shape of the control and its parts may be defined. As shown in four different overall appearances are shown for each of the buttons and . Each different appearance setting is coordinated and is called a theme. Each theme is represented by one of the rows of buttons in . While only four themes are shown in an unlimited variety of themes may be created for selection by the computer user. The theme is a collection or set of appearance characteristics relating to a particular subject or desired visual environment.

As an application is running it often requires a control or graphical component to be rendered or displayed on the monitor of the computer . For example with reference to the display of an OK button may be needed by the application on the monitor. Application requests that an instance of button be created. Following this the operating system transmits a generic message to the control instructing it to draw itself. This request would be routed to the dynamic link library DLL that contained the particular control. As an example the DLL in the WINDOWS operating environment would be called User32.dll or ComCtl32.dll V5 shown as and respectively in . Libraries and exist within graphical operating system . Libraries and are linked through fusion module with applications . The defined control within libraries and contains the drawing code needed to render the control on the monitor. Therefore to change the appearance of controls in libraries and the software drawing code must be changed for each control within libraries and .

An additional library DLL shown as in similar to library in that it contains a number of predefined controls and graphical components that may be used by application . Broadly DLL contains a number of components that are to be graphically displayed. In library however the controls are defined differently making them theme aware. Rather than containing all of the software code needed to render the control the controls are defined with certain basic information or values about the control for example the location parts and states of the controls.

The location is the position on the user interface where the control is desired. Parts are the different items that make up the control. For example OK button has a background part and a text part. As another example a scrollbar control has an elongated rectangular shaft part a smaller thumb part that slides within the shaft part and an arrow part at each end of the shaft part. The state of a control describes the current appearance and functional state. For example a button can be active such as normal hot selected pressed or inactive such as disabled or unavailable.

In the embodiment of the invention in libraries and are linked to the applications through a fusion module . Fusion module enables the themeing of controls in applications without needing to change the applications themselves to request the themeable version of the controls. Fusion module enables each application to load the specific version of the DLL or at run time through the use of a manifest. The fusion manifest specifies the environment in which an application will run which allows multiples versions of a DLL to exist on one machine. Thus fusion module will map the request for OK button so that it is rendered as a themeable element in DLL instead of a non themeable element from DLL . This allows an existing application to be themed without changing code in the application. Fusion module also allows the new themeable controls to be placed in a different DLL from the existing DLL which simplifies implementation and minimizes compatibility risks.

Controls existing within DLL are therefore used if they are available. As seen above the controls within DLL are defined as a series of parts and states. The controls within DLL also contain the drawing code needed to render the controls if no themes are selected as well as the theme aware paths through the code. DLL requests rendering or drawing services from a theme manager DLL . Theme manager provides the requested rendering services and draws the control on the display at the indicated location with the indicated parts in the indicated states.

Theme manager contains a series of APIs that allow library to interact and communicate with the theme manager. The APIs allow a control author to define a control within DLL as a series of parts and states without the need for software rendering code. These APIs are generally divided into three types drawing APIs information APIs and utility APIs . Drawing APIs are generally used to render and assist in the layout of the needed control parts and other components. Information APIs are generally used to obtain information about the current defined appearance of the controls to allow controls to be individually customized. Utility APIs are those APIs used by parts of the operating system other than the controls to control theme selection. Utility APIs include functions that can be used to enumerate an installed theme and load it.

Drawing APIs are a collection of theme aware drawing services. Each individual API within the set of drawing APIs is used to perform a different drawing service. Generally each API requires a specified part and state of the graphical component at hand. An API called DrawThemeBackground is provided that draws the theme specified border and fill for the specified part and state at the desired location. Similarly an API called DrawThemeText is provided that draws the specified text using the theme specified color and font for the specified part and state.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through an non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through a output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Although many other internal components of the computer are not shown those of ordinary skill in the art will appreciate that such components and the interconnection are well known. Accordingly additional details concerning the internal construction of the computer need not be disclosed in connection with the present invention.

Those skilled in the art will understand that program modules such as the operating system application programs and data are provided to the computer via one of its memory storage devices which may include ROM RAM hard disk drive magnetic disk drive or optical disk drive . Preferably the hard disk drive is used to store data and programs including the operating system and application programs .

When the computer is turned on or reset the BIOS which is stored in the ROM instructs the processing unit to load the operating system from the hard disk drive into the RAM . Once the operating system is loaded in RAM the processing unit executes the operating system code and causes the visual elements associated with the user interface of the operating system to be displayed on the monitor . When an application program is opened by a user the program code and relevant data are read from the hard disk drive and stored in RAM .

Returning now to the system architecture in and the example buttons in if an OK button was requested by an application the control within DLL would pass the part state and location information to drawing APIs through a function call such as DrawThemeBackground or DrawThemeText. As is more fully described below this part and state information is matched with appearance characteristics and theme manager draws the control on the monitor. Drawing APIs further include an API called GetThemeBackgroundContentRect. This API allows the control to obtain the size of the content for the theme defined background. Usually this is the area inside the borders or margins. By using this API a control can determine the available area within the background in which items may be placed. When using this API the control within DLL is requesting information regarding a graphical component with a specified part and state. This information is obtained by the theme manager and returned to the control. A similar API called GetThemeBackgroundExtent is provided that calculates the size and location of the theme specified background for the specified part and state given a content rectangle. This API may be used when the content is known and based upon that content the outer boundary for the theme background needs to be determined. Another API called GetThemePartSize is provided to retrieve the theme author specified minimum and normal sizes of a control part.

Drawing APIs further include an API entitled GetThemeTextExtent. This API is used to calculate the size of a specified text when rendered in the theme font. This API can therefore be used to determine the width and height of a given text string. The control author can thus specify a part and state having text associated therewith and use this API to obtain information from theme manager regarding the size of the text string. Similarly another API entitled GetThemeTextMetrics is available that can be used to obtain size information about the font being used. Therefore this API may be used to obtain information such as the width of an average font character. In other words this API is used to obtain from theme manager information that the control needs regarding the size of a theme specified font.

An API entitled GetThemeBackgroundRegion is also provided within drawing APIs . Within some operating systems a region is a way to describe a non rectangular shape. A region can also be thought of as an image with transparent parts. This API is used to compute the region for a regular or partially transparent theme specified background. In other words this API may be used to determine what is transparent and what is opaque within the framed background for a specified part and state. Thus this API supports the definition of non rectangular shapes of controls and parts. Similarly an API entitled HitTestThemeBackground is provided. This API is used to determine whether the point within the background for the specified part being clicked is in a transparent or an opaque area. This API is used by a control within DLL to obtain information from the theme manager . If the click is within a transparent area no action may be needed. Conversely if the click is within an opaque area an action may be required.

Another API contained within drawing APIs is entitled DrawThemeLine. This API allows a theme to define a generic style of a line. This generic style may be accessed and used for a specified part by calling the DrawThemeLine API. Similarly an API entitled DrawThemeBorder is provided that allows a theme defined border to be specified. The theme border may be drawn for a specified part utilizing this API.

An API entitled DrawThemelcon is provided that allows a theme defined icon to be rendered that may include theme specified special effects. For example a theme icon may have a different appearance when the mouse is directly over the icon such as a glowing appearance.

Drawing APIs also contain an API entitled IsThemePartDefined that may be used to determine if the theme has defined parameters for the specified part and state. If the part is not defined within the theme the control can draw this part itself. If the part is theme defined theme manager will render the part according to the theme defined information. Another API is provided entitled IsThemeBackgroundPartiallyTransparent. This API is used to determine whether or not the background is a rectangle or region that has a transparent part. This API may be used to simplify the control code. If there is no transparency within the background then there is no need to conduct any hit testing through the use of the HitTestThemeBackground API.

Importantly drawing APIs further include an API entitled OpenThemeData. This API is used to obtain the handle for a list of class names. A class name list identifies a set of graphical components and may be divided into parent class names and one or more child class names. For examiner a parent class name might be button. A child class name for that parent class might be start button. A handle is a reference to an internal structure detailing various information and properties of the object. Theme manager will search for each class name in the list and use the first matching theme information found. For example if the class names included both start button and button the start button theme information would be used if it existed. If start button theme information did not exist the theme information for a button would be used. If no value is found the old code will be used to render the control. If any non 0 value is returned a valid theme handle is established. This theme handle will be returned to DLL and used for all of the theme drawings.

Similarly another API provided is entitled CloseThemeData. This API is used when the control is closed such as a button no longer being needed or when the theme is changed as is more fully described below.

Another API provided is entitled IsThemeActive. This API allows a control within DLL to obtain a true or false answer as to whether there is a current theme in effect. This API can thus be used to determine whether to call the OpenThemeData API or merely use the existing drawing code where the controls will render themselves.

As described above theme manager also contains a set of information APIs . These information APIs allow controls to be individually customized. In other words these APIs are utilized in only certain instances and may be used to obtain information about specific controls. These information APIs are used to query theme manager for defined theme information regarding specified properties of the theme. Each API thus requests information which is provided by theme manager .

Within information APIs is an API entitled GetThemeColor. This API utilizes the specified part and specified state along with a specified color property identifier to obtain information about the theme color. The property identifier is the color property number that is desired. In other words the color API is used to ask for the color value corresponding to the property desired such as the background color. Another API called GetThemeMetric is provided that requests and receives a size value for a specified property identifier. This size value will be an integer. An API entitled GetThemeString is also provided within information APIs . This API is used to obtain the string for a specified property identifier. The string will include information regarding the number of characters in the string and where the string is terminated.

Another API is provided within information APIs entitled GetThemeBool that will return an integer that is either 0 or 1 for a given part state and property. The 0 and 1 correspond to a false or true state for that part state and property. Another API provided is entitled GetThemeInt. That will return an integer value for a specified part in a specified state with a specified property identifier. Similarly an API is provided entitled GetThemeEnumValue that will return the theme enum for the specified part state and property identifiers. An enum is merely a variable that holds numeric values which correspond to symbolic information. For example an enum for alignment might be left middle right corresponding to the numbers 0 1 2.

Another API entitled GetThemePosition is provided that will return two integer values corresponding to an x location and a y location for a specified part in a specified state with a specified property identifier. Another API provided within information APIs is entitled GetThemeFont. This API is used to obtain a logical description of the font theme used given a specified part state and property identifier.

Yet another API provided within information APIs is entitled GetThemeRect. This API will return four integers representing the left right top and bottom of the specified part state and property identifier. Similarly an API entitled GetThemeMargins is provided that will return four integers representing a left space right space top space and bottom space given a specified part state and property identified. There is also an API entitled GetThemeIntList which returns the value of a specified property whose type is a list of integer values. Finally an information API entitled GetPropertyOrigin is provided that returns the location from which the property originated. This API allows the control author to obtain information for the property origin. In other words the API allows the control author to determine whether the property was specified on the state part class global or was the property not found. This is needed because theme properties are specified by the theme author in a hierarchical fashion. For example if a property is not specified at the state level the theme manager will search the part level class level and finally the globals level for the property. Sometimes it is important for the control to know if a property was explicitly defined for the part state it is processing. There is also an API entitled GetThemeFilename which returns the string value of the specified filename property.

Another API provided within information APIs is entitled SetWindowTheme. This API allows a control author to redirect a control window to use a different set of theme information than its class would normally use. In other words this API allows a control to be used while giving the control a special look other than the standard look defined by the theme for that class. This API may use additional parameters to identify a particular application and class name. This allows a theme author to use the specified class but to change the appearance of that class. For example a button may be defined that has a given button appearance. Utilizing this API this button can be redirected to a different class name. For example OkayButton may be specified. The theme author will then be able to use a class called OkayButton and the OkayButton will have a different appearance from the standard button appearance.

There is also a subset of theme metrics APIs within the information API group that parallel the WINDOWS system metrics but which are specific to a theme. Unlike normal control based properties these properties are available to and shared by all controls. GetThemeSysColor returns the theme specified color value of the specified system color index. GetThemeSysColorBrush returns a handle to a drawing brush that is the color of the specified system color index. GetThemeSysSize returns the integer size of the specified theme size index. GetThemeSysBool returns a boolean 0 or 1 value for the specified theme boolean index. GetThemeSysFont returns a logical font structure for the specified theme font index. GetThemeSysString returns a string value of the specified theme string index.

There are also some application oriented API s within the information API group . IsAppThemed returns a boolean 0 or 1 value indicating if the application is being themed by the operating system. GetWindowTheme returns the most recent theme handle if any opened for the specified window. GetThemeAppProperties returns the flags that control which parts and types of windows are themeable within the application. SetThemeAppProperties allows the application to set these same flags.

Finally there are information API s for error handling. GetThemeLastErrorContext returns the error context including error code error code parameters filename and source line associated with the last reported theme error on the current thread of execution. FormatThemeMessage returns the error string for the specified error context in the specified language.

Theme manager includes not only drawing APIs and information APIs but also a set of utility APIs . These APIs may be used to achieve a variety of results.

Drawing APIs and information APIs allow the author or creator of controls within DLL to define the controls as a series of parts and states. The defined control is therefore abstracted from the rendering process of theme manager and is also abstracted from the theme defined appearance information or characteristics as is more fully described below. Using APIs and the control author can create controls that are theme aware and that are equipped to communicate with theme manager . This communication involves passing basic information or values to theme manager that allow the theme manager to render the desired control having the needed parts in the desired states.

Theme manager also contains the renderers needed to execute the drawing instructions. For example a border fill renderer could be used that allows different color themes to be applied to the controls. As another example a bitmap renderer could be used that defines the control parts as images. Other examples of renderers include using a vector definition language portable network graphics PNG files or portable document format files PDF . It should be understood that the present invention is not limited to a particular rendering technology. If a different renderer is desired or needed the drawing code of theme manager is revised to add the renderer to theme manager . The controls within DLL are therefore isolated or abstracted from the rendering technology within theme manager . This allows different renderers to be added to theme manager without having to revise the controls within DLL as is more fully explained below.

The renderer within theme manager renders the requested control according to an appearance theme that has been selected by the user of the computer. For example appearance themes and are shown in . As shown theme may be a consumer theme and theme may be a business theme. It should be understood however that other themes could be used and that the invention is in no way limited to the particular theme. For example other themes could include a cartoon theme a children s theme or a golf theme. As seen in business theme has been selected by the user as represented by the solid line . Consumer theme is available for selection as represented by the broken line .

Each theme and has similar architecture. As seen in business theme includes a series of image files . Image files are the image files that will be used by the particular theme. In this case image files are the image files that will be used by business theme . Business theme also includes a themes.ini file . File is a text file and can be created in either ANSI or UNICODE character sets. File specifies the available color schemes and sizes available for the theme. In the case of theme file specifies the available color schemes and sizes available for business theme . File therefore represents all of the variations of the theme to which it applies.

Theme file consists of one or more sections. The sections within theme file include a documentation section a size section a color scheme section and a file section . Documentation section is optional and may contain any property name. Size section specifies the size name such as default size very small or very large. Color scheme section is used to specify a simple color scheme name and an optional color scheme transformation associated with the color scheme name. File section is used to specify a unique name for the class data file. The file section will include a file name a color scheme from color scheme section for that file name and the sizes from the size section that the file will support.

Theme includes a second .ini file labeled in . File is a class data file that contains the theme data for a specific size and color theme. File may also contain defining sections. For example file may contain a globals section that defines the properties of the particular class of control. File may also contain a section that allows the system metrics to be obtained and used. Finally file may contain a group of class sections. Each class section name contains a class name an optional part name and an optional state name. Within the section are the property value pairs that define the appearance of the specified part or control. For example a class name would be slider for the slider control. A part specified for the slider would be track. States defined for the track part would be normal disabled and hot. The class section name can also include an application or group name which specifies that the section only applies to a specific application or group name as specified by the SetWindowTheme API .

Image files theme file including file are broadly grouped together to make up theme directory . Theme directory and a system schema file located within the theme manager are used to load business theme . The system schema file is the file that defines property numbers for all of the properties involved in a particular theme and is basically a master definition file that allows the themed properties to be assigned a number corresponding to a defined appearance.

Theme directory thus contains a theme.ini file a class data file and all of the image files used by the theme. The contents of theme directory can be packaged into a DLL file by packthem tool . Packthem tool processes the theme.ini file by parsing it against the schema file for syntax errors and adding the .ini file to the package being built. Recognized properties from documentation section are written to a package string table. Color scheme information from color scheme section and size information from size section is also written to a package string table. Each class data file is also processed. As the class data file is processed the file is parsed against the schema file for syntax errors. The class data file is also added to the package being built.

The DLL file produced by packthem tool is business theme file . File contains the theme data and this theme data is isolated from control library . This allows different themes to be created and selected without changing the controls defined within library . Thus control authors can create and define controls independently of the appearance or theme data. File is in binary format and is passed into a shared theme data file when business theme is selected by the computer user as best seen in . File is a shared memory map file that can be accessed by all processes. Thus when a theme is selected by the computer user theme manager will read the information for a defined theme file such as file and will place that information in a binary format in file where all running processes have access to the binary information.

As best seen in a theme switching control panel is provided that is in communication with theme manager . Panel cooperates with a user interface that displays the available themes from which the user can select. As shown in control panel would allow a user to select business theme or consumer theme . If as has been discussed above business theme is selected and the user of the computer switches to select consumer theme theme will be loaded into shared memory map file as binary data. Theme manager also sends a message to each theme aware control within DLL file that the theme has changed. Each theme aware control knows how to respond to this message.

When the theme aware control receives a message that the theme has changed the control will close the current theme handle that was received via the OpenThemeData API. The control will then attempt to open a new theme handle again using the OpenThemeData API. If a new theme handle cannot be opened the control knows that the theme has been switched off for that control and that the old drawing code is to be used by the control to draw itself. If a new theme handle is opened theme manager will look at the theme binary data and will start a new drawing routine so that all of the theme aware controls are redrawn utilizing the newly selected theme such as consumer theme . Any information that was cached regarding the previously selected theme is invalidated and that information must be recalculated.

In operation as is best seen in an application will request a graphic such as a control to be rendered on the user interface as represented at . This graphical request is routed through fusion . As represented by the fusion process will determine if the requested control is a theme aware control. If the control requested is not theme aware the old code is used and the control will draw itself using a control from DLL or as represented by in . If the control is theme aware the graphical request is processed in DLL as is represented by . The controls within DLL will pass basic information for the graphical request such as the part state and location for the requested control to the theme manager in a request for rendering services using APIs and . Thus the graphical request is processed in DLL without application of the appearance characteristics that are found by theme manager . Theme manager will then determine or apply the theme specific appearance characteristics for the given control part and state as shown by . This appearance data is retrieved from the shared memory map data file . Using the retrieved appearance data for the requested control part and state along with the location the theme manager will render the control on the display of the computer as represented by .

Referring now to one embodiment of operations of the operative state module are illustrated by a state diagram. A control element may be in four possible states disabled normal hot or selected. These operative states for the control are set by the operating system or by the application in working with the operating system if the control is in an application. If the control is in a normal operative state this indicates that the operation represented by the control is available. If the operating system or the application indicates the operation represented by the control is not available then a control not available condition switches the operative state to the disabled state . When the operating system or the application working with the operating system determines the operation is available then the control is available and the state of the control returns to normal state . If the cursor is positioned over the control indicating a mouse over condition then the state switches from normal to hot state . In the hot state a click or mouse down condition would change the control state from hot to selected state . A release of the mouse button indicating a mouse up condition would return the control state to the hot state . Likewise when the mouse is moved so that the cursor is outside the control element on the display then the mouse outside condition causes the hot state to revert to a normal state for the control. Thus in this embodiment of the invention an operating system or an application by monitoring the mouse or cursor conditions and the control availability will generate the operative state for use by the rendering operations in drawing the control on the display.

In another embodiment not illustrated of the operative state module movement between operative states of a control is accomplished with key strokes. For example if the control buttons are in an unfocused available state such as normal or hot the tab key may be successively pressed to move the focus state successively through the control buttons. When a control button enters a focused state it may then be selected by pressing the space key. Accordingly in this embodiment an operating system or an application monitors the state of the controls and the movement between controls by activation or pressing of the tab key. It will be appreciated that there are many ways in which the operative state module could be implemented to provide the operative state information used by other logical operations in .

If the operative state is normal the operational flow branches YES from normal state detector to set theme state operation. Set theme state operation sets the theme state to the normal focus state. Thereafter the operation flow returns to operation in through flow connector to draw the control in the theme state. Draw operation retrieves the properties for the normal focus theme state in rendering the control.

Similarly if hot state detector detects that the operative state was the hot state operation flow branches YES to set theme state operation . Operation sets the theme state to the hot focus state. The operation flow returns to draw operation in which retrieves the hot focus properties and draws the control in the hot focus state.

Disabled state detector detects whether the control is active or inactive. If a focus state has been identified for an inactive control such as disabled or unavailable this represents an error since a disabled control would not be properly in a focused state. Therefore the operation flow branches YES from the disabled state detector to an error handling routine . When the error handling operations are complete the return operation returns the operational flow to the main operating system flow rather than to the draw operation in . Alternatively this active or inactive operative state detect operation could be performed along with focus state detect operation in . If operation is performed in this manner it need not be performed in .

Alternative embodiments of the present invention will become apparent to those skilled in the art to which it pertains upon review of the specification including the drawing figures. Accordingly the scope of the present invention is defined by the appended claims rather than the foregoing description.

