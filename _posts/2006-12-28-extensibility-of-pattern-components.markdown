---

title: Extensibility of pattern components
abstract: Methods and apparatus, including computer program products, related to extensibility of pattern components in a visual modeling language environment. A pattern component may implement an interface, the pattern component may be received (e.g., by a compiler), and a determination may be made as to whether components of the interface are implemented by the pattern component. If so, a reference to the interface is bound to the pattern component (e.g., a function call referencing a function signature of an interface may be substituted with a call to a function having the same name of the pattern component). A role may be assigned to a pattern component of a visual modeling environment of an application development system and a behavior may be performed based on the role assigned to the pattern component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08689174&OS=08689174&RS=08689174
owner: SAP AG
number: 08689174
owner_city: Walldorf
owner_country: DE
publication_date: 20061228
---
The present disclosure relates to data processing by digital computer in a visual modeling language environment and more particularly to extensibility of pattern components in a visual modeling language environment.

Application programs sometimes referred to simply as applications are programs that an end user runs to accomplish certain tasks. Applications typically work in conjunction with one or more back end systems which store the data to be worked on e.g. business objects and other business data as well as logic for manipulating the data e.g. transactions or other business logic . Examples of back end systems include database systems enterprise resource planning ERP systems and customer relationship management CRM systems. A user interface UI is designed to work in concert with application programs and facilitates interaction between humans and computers by inviting and responding to user input.

A structured approach to developing applications includes a model driven tool such as VISUAL COMPOSER which is a visual modeling program manufactured by SAP AG of Walldorf Baden Germany SAP . A tool like the VISUAL COMPOSER allows a developer to compose applications in a flexible way by using patterns. A pattern graphically depicts functional components e.g. entities of a modeling language as drag and drop services and a data flow definition between them. A pattern sometimes referred to as a UI pattern is a configurable reusable unit designed to let users accomplish a specific but generically defined task such as searching for business objects and editing the objects that are retrieved. Generally each pattern has a specific semantic meaning and defined interaction behavior. In some implementations a pattern can include a predefined arrangement of UI elements. Using patterns promotes uniform design throughout an application or group of applications because similar tasks are represented and handled in the same manner. For example a user can always search in the same way whether searching for a sales order a business partner or a product. User interface patterns can be defined at various levels and can be nested within each other thus creating hierarchies of patterns. At the top level of the hierarchy a pattern can act as a floor plan for a user interface that is designed to help end users complete a specific business process.

A visual modeling language environment can have a separation between a designtime and a runtime version of an application. A designtime version of an application can include a combination of patterns and configuration of properties of those patterns that can define an application being developed. Underlying a designtime version of an application can be a model of the application which can be an implementation independent model e.g. a model in accordance with a Universal Modeling Language UML specification or a more implementation specific model e.g. a model in accordance with a programming language such as the JAVA programming language from SUN MICROSYSTEMS INC. of Santa Clara Calif. . A runtime version of an application can be generated by a visual modeling program based on a designtime version of the application with the use of a model underlying the designtime version of the application. For example a designtime version of an application can be used to devise a model with JAVA classes and the JAVA classes can be compiled to generate a JAVA runtime version of an application.

The subject matter disclosed herein provides methods and apparatus including computer program products that implement techniques related to extensibility of pattern components in a visual modeling language environment.

In one aspect input is received that characterizes a definition of pattern roles of a pattern component and a selection of a child component e.g. a child in the sense of a hierarchy of a model of an application being developed in a visual modeling language environment having parent components being higher than child components e.g. a component containing one or more sub components may be parent component and the sub components may be referred to as child components a determination is made as to which role is associated with an interface implemented by the child component if any and the role associated with the interface is associated with the child component. Each potential role may be associated with one or more interfaces and the pattern component may define a pattern of a component of an application in a visual modeling environment of an application development system. The role that is associated with the child component if any may be one of the potential roles.

In another aspect a role is assigned to a pattern component of a visual modeling environment of an application development system and a behavior is performed based on the role assigned to the pattern component.

In another aspect input is received that characterizes a definition of a pattern component and an interface implemented by the pattern component a determination is made as to whether components of the interface are implemented by the pattern component and if so a reference to the interface is bound to the pattern component e.g. a function call referencing a function signature of an interface may be substituted with a call to a function having the same name of the pattern component . The pattern component may be a pattern of a component for application development in a visual modeling environment.

The subject matter may be implemented as for example computer program products e.g. as source code or compiled code computer implemented methods and systems.

A pattern component may graphically depict an entity of a visual modeling language. A pattern component may be a configurable reusable unit corresponding to a task where the pattern component has a specific semantic meaning and defined interaction behavior.

Architecture of a modeling environment of a visual modeling program may include a first layer defining a technical platform a second layer defining a framework for implementing a modeling language in the technical platform a third layer defining designtime interfaces for modeling language entities and a fourth layer defining a layer for configuring the modeling language entities. Pattern components may be implemented in the third layer and roles may be assigned in the fourth layer.

A behavior may be associated with a child component where the behavior is associated with a role assigned to the child component. Associating the behavior may include generating a runtime version of the child component including the associated behavior.

A behavior may be associated with a pattern component where the behavior is associated with a role of the child component.

A pattern component may have one or more roles. A pattern component may implement one or more interfaces.

A second potential role may be determined to not be associated with a child component. Behaviors associated with the second potential role may be omitted from a runtime version of the child component.

Assigning a role may include assigning a role associated with an interface to the child component if a cardinality associated with the role allows the child component to be a child of the pattern component otherwise prohibiting the child component from being a child of the pattern component in a runtime version of an application.

Based on a cardinality of potential roles for child components of a pattern component pattern components maybe prohibited from being child components of the pattern component.

Input may be received that characterizes a selection of a second child component implementing at least interface. A second role associated with a second interface implemented by the second child component may be determined. The second role may be one of the potential roles e.g. potential roles of a pattern component that is a parent to the second child component . The second role associated with the second interface may be assigned to the second child component.

Input may be received that characterizes a definition of second potential roles for child components of a second pattern component where each potential role is associated with second one or more interfaces and a selection of a second child component implementing interfaces of a child component of a pattern component e.g. a pattern component not being the second pattern component . A second role associated with one of the interfaces implemented by the second child component may be determined where the second role is one of the second potential roles. The second role associated with the interfaces may be assigned to the second child component where the second role is distinct from the role of the child component based on the potential roles of the pattern component being different from the second potential roles of the second pattern component.

Assigning a role may include determining the role associated with an interface implemented by a pattern component. Assigning a role may include determining the role associated with the interface based on an association in a context of the component.

Binding may include generating a runtime version of a pattern component in lieu of the reference to the interface.

A role may be assigned to a pattern component based on a type of interface implemented by the pattern component.

The subject matter described herein can be implemented to realize one or more of the following advantages. Extensions to patterns may be provided that allow for dynamic or late binding including interfaces roles or both. Interfaces may allow for pattern components to be bound at runtime based on an interface implemented by a pattern component. Advantageously interface based code may allow for new pattern components that implement interfaces to be introduced into a system and changes to the interface based code need not occur. Roles may allow for a pattern component to have different behaviors based on a role of the pattern or a role of another pattern. Roles may be assigned based on a context of a pattern component e.g. based on information in a parent component of a model of an application and interfaces implemented by a pattern such that different behaviors are automatically adopted. For example two instances of a same component may be created and used in a different way depending on their context.

Details of one or more implementations are set forth in the accompanying drawings and in the description below. Further features aspects and advantages will become apparent from the description the drawings and the claims.

As an example use of patterns a floor plan for a user interface can specify that an application screen is to be divided into three sections with a top section for searching for and selecting business objects a middle section for showing the details of an object selected in the top section and a bottom section for showing the details of a sub object of the object in the middle section. More detailed lower level patterns can be used for each of the sections specified in a floor plan. For example that a section of the screen is to include a search bar with various text entry fields and buttons at the top and an area below the search bar where content i.e. the content returned as a result of a search is to be displayed. This process can continue with the definition and hierarchical nesting of even lower level patterns.

The user interface shown in illustrates an example of a pattern based user interface. The user interface has a floor plan that includes an object identification pattern OIP and two object data patterns ODPs and . Object identification pattern and object data patterns and are made up of embedded lower level patterns such as a data view a form pane a list pane or a chart pane. Each embedded pattern can include further embedded patterns including for example tool bars tables tab strips and other UI pattern elements. Object identification pattern is a pattern that provides an interface for searching for objects using zero or more selected criteria and for displaying objects found to meet those criteria. Like the floor plan pattern OIP is itself a pattern with several embedded elements. Object identification pattern includes a title bar a search bar a tool bar and a content area .

User interface of illustrates a particular application that is based on the patterns described above. Such an application can be referred to as a pattern based application a pattern application or simply an application. As explained above UI patterns are reusable user interface units designed for generic tasks for example an OIP pattern is designed for the task of searching for and selecting business objects stored in a back end system e.g. a database . In order to create a concrete user interface e.g. user interface with OIP UI patterns need to be configured. illustrates an example in which a UI pattern is configured shown using arrows and to create two UI applications and . Configuration one is used to create application one and configuration two is used to create application two .

Configuration is the process through which a UI pattern is developed into an actual user interface or portion thereof for an actual application. For illustrative purposes this might be compared to instantiating an object of a specified class the UI pattern comparable to a class specifies the general properties of a portion of a user interface and a configured pattern comparable to an instantiated object specifies the actual properties of the portion of the user interface for an actual application. UI pattern represents the general properties of the UI portion for example that a table is included in that UI portion and that the location of the table is under a title bar. Configuration one represents the process of specifying properties of the UI portion for example the specific columns that will be included in the table when the table is rendered so as to create an application for example application one that displays a UI with a table under the title bar with specific columns defined by configuration one . Similarly application two displays a table but with specific columns as defined by configuration two .

A configuration can also specify what back end systems and data are to be used for a pattern. For example configuration one can specify a particular back end system e.g. a local or remote database system and a particular service to use to access the data on that back end system that is to be displayed in the table in the UI pattern . Examples of services that can be used to access a host system include web services ENTERPRISE JAVA BEANS EJBs Business Application Programming Interfaces BAPIs developed by SAP and other business logic services.

As another example of a configuration an OIP might specify that a user interface is to include a search bar at the top of the interface and a content area below the search bar. The search bar is to include a drop down box for selecting a search field a text box for entering a query string and a Go button for executing searches. Configuring such a pattern is the process of providing specifics for the pattern for an actual application. For example to configure the OIP pattern an application developer can specify the search fields to be included in the drop down box the query to run when the Go button is pressed the back end system in which to run the query i.e. the system where the actual data is located and the columns from the returned results to display in the content area.

In some implementations a UI pattern can have a number of predefined layouts e.g. a grid layout and a flow layout and the application developer can decide which of the available layouts to use as part of the configuration process. Moreover each layout can be further configurable providing the application developer with further configuration options e.g. an option to create groupings of fields or other elements . In yet other implementations a pattern can be defined to have a fully configurable layout giving the application developer complete freedom to modify the arrangement of the elements in the pattern e.g. by using a graphical configuration tool to specify screen positions for each element in the pattern .

Thus the degree to which each UI pattern is configurable can vary. For example the degree to which the arrangement of elements in a pattern can be configured can vary across a spectrum for some patterns the arrangement of UI elements can be fully predefined leaving no configuration options for the application developer for some patterns the application developer can be given an option to choose between a handful of predefined arrangements and for other patterns the application developer can be given full freedom to define a custom arrangement of elements.

Other pattern properties can also be partially or fully configurable. For example a developer can be given no options or a few options regarding the actions to be performed by a UI element in a pattern. Or the developer can be allowed to define and associate a custom action with an element in a pattern.

As can be seen from the prior discussion the term configuration can be used in multiple ways. First configuration is the process by which a pattern is developed into a concrete user interface or portion thereof for a concrete application. A configuration also refers to the data that is produced as a result of the configuration process i.e. it is the set of data that defines a concrete user interface based on a pattern. Finally configuration can also be used to refer to the set of options provided during the configuration process. As used in this manner a selected option in a configuration produces a defined item of configuration data.

The use of patterns to develop applications creates two potential levels of re use. First of all patterns serve as re usable building blocks for building user interfaces. For example an OIP can be used to create two different user interfaces a first configuration can define a user interface for searching for business objects related to customers customer objects and a second configuration can define a second user interface for searching for business objects related to inventory inventory objects .

In addition configurations can be reused meaning that the configurations themselves can serve as re usable building blocks for building applications. Thus in the example above the OIP configuration that defines a user interface for searching for customer objects can be integrated and used in two different applications e.g. a customer relationship management application and a billing application .

The configuration of a UI pattern can be done through the use of a configuration application such as a visual modeling program. A configuration application facilitates the process of configuring a UI pattern. In one implementation the configuration application displays multiple configuration options for the application developer to select. The configuration options can include lists of the available back end systems queries query fields and query results.

Selections of configuration options can be stored as configuration data for a UI pattern. The configuration data can include associations between one or more of the UI elements in the UI pattern and one or more of the back end entities to be used with the UI pattern. As an example configuration data for the OIP described above can include a specification of the back end system to be used the query to be run in the back end system the query fields to show in the drop down box and the result fields to display in the content area.

Configuration data can also include customization data for one or more of the UI elements in a UI pattern. Customization data can specify local changes to the business objects associated with the UI elements. For example a drop down menu item might be associated with a back end query field called UID . The customization data may specify that the UID field should be displayed using a more user friendly label for example reference number . Such a customization applies only to the particular UI element in the particular application being configured and does not affect how the business object is represented in the back end system or how the business object is represented by other UI elements in other applications that use the same UI pattern.

The configuration data can be stored in a configuration repository. In one implementation the configuration data is stored in one or more files. Such files can be nested to reflect a hierarchical arrangement of further UI patterns. The configuration data can then be read by a pattern component which generates the implementation of the actual user interface for the application based on the configuration data.

The generation of a pattern based application based on a configuration can be done either immediately after the configuration has been completed or at a subsequent point in time such as when the pattern based application is executed.

In the composition language there are different types of entities that have different semantics and syntax as represented by different patterns and types of patterns in a visual modeling program. The illustration includes several different types of patterns including patterns for scenarios services states ports plugs and interactors i.e. different patterns for different types of entities including scenarios services etc. . Scenarios such as the Overview scenario are entities that represent a reusable user interface unit of an application being developed e.g. a tab in a user interface of a web application . Services such as the BO service are entities that need not have a visual representation in an end user application e.g. in an application developed in the visual modeling program and provide data to other components of an end user application e.g. a service that in response to receiving a selection of personal data as search criteria outputs personal data matching the search criteria . States such as the ESS state define visual states of a scenario by defining elements that are visible to an end user of an application being developed e.g. by encapsulating scenarios to be displayed . Ports such as the Personal data port can be connection points to and from entities in the modeling language e.g. a connection point between a service and an interactor . Plugs such as the Personal data plug can be external representations of ports of a component e.g. if the BO service were drilled down the Personal data plug can be a port . Interactors such as the Personal Data Form interactor can be an atomic unit of user interaction in the visual modeling program such that the visual representation can not be drilled down to another level of entities where an interactor can obtain and provide data by transforming input data into output data based on user interaction e.g. the interaction of an end user of an application being developed e.g. an interactor can be a form .

In the composition language as reflected in a visual modeling program the different types of entities have a different type of corresponding graphical representation. For example interactors can have a graphical representation of a box defined by solid lines and rounded corners. As another example a service can have a corresponding graphical representation of a cylinder.

The composition language can be defined to include certain entities that have associated semantics and syntax. For example the composition language can be defined to include the Overview scenario and the Edit scenario each of which can have different semantics and different syntax as defined by the composition language. The entities defined by the composition language can be referred to as base entities. These entities can be understood by the visual modeling program such that the visual modeling program can generate an associated runtime version of the entities. For example by having a special generator that interprets Edit scenarios a special generator can generate a runtime version of the Edit scenario .

Although certain types of entities are discussed with reference to additional different or fewer entities can be used in a visual modeling program to represent different semantics and syntax of components of an application being developed.

To enable applications to execute on different platform layers framework includes a platform independent component development and runtime layer . In this environment applications can be developed using modules known as components. Components can be stored in a component repository and reused that is each component can have more than one instance where the component instances are used in multiple applications or multiple times in the same application. Components can be embedded nested within other components and they can have zero or more visual representations. In one implementation each component provides three separate interfaces a programming interface a data binding interface and a visual interface. The programming interface can be used by an embedding entity a component embedder e.g. a higher level component or an application to interact with the embedded component. The visual interface can be used by a component embedder to access and use the visual representations of the embedded component for example to form the component embedder s own visual representation . The data binding interface can be used by the component embedder to exchange data with the embedded component.

The combination of components in the platform independent component development layer can be referred to as a framework layer as it can provide a framework for interfacing between patterns in the pattern layer and the technical platform in the platform layer . By defining this interface the platform independent component development layer can be used to define an implementation of a modeling language for a technical platform e.g. a translation of entities of a model to runtime entities whereas the pattern layer provides designtime interfaces e.g. patterns for the modeling language entities .

In one implementation platform independent layer provides a framework for defining application components in a declarative and or graphical manner without needing to program the components for a particular platform layer . Platform independent layer also provides interfaces tools services and other features to enable the application components to execute on a specific platform layer . In another implementation platform independent layer additionally provides functionality to enable application components to render user interfaces on a number of different clients with platform independent layer performing the appropriate transformations for specific clients.

Building on top of platform independent layer framework includes a pattern layer with one or more generic UI patterns. Each UI pattern is generic because it defines a particular pattern e.g. a floor plan pattern an OIP an ODP a GDP and the like but not the specific content that is included for a specific application that uses that pattern. The specific content for a specific application is created by configuring the pattern.

The top layer application layer contains the actual applications to be run by end users. In this framework an end user application is made up of one or more configured UI patterns. In an implementation where each UI pattern includes a pattern component an end user application is made up of one or more configured pattern components e.g. pattern components and their corresponding configurations . An end user application can be stored in a configuration repository in the form of configuration data and references to the associated pattern components.

Framework thus enables application developers to develop applications by configuring generic pattern components into components for specific applications e.g. components that display the actual fields illustrated in UI . In one implementation as described in more detail below configuration data e.g. data in a configuration repository or in one or more configuration files is used to configure a generic pattern component into a component for a specific application. The configuration data can be defined through the use of declarative and or graphical tools that are included for example in a configuration application thus dramatically simplifying the task of developing applications. If for example the configuration application has access to a meta data repository that specifies the fields available for a particular back end system for which an application is being developed the application developer can develop an application e.g. create a configuration by simply choosing the fields in the meta data repository to be included e.g. displayed in the application.

Framework can be thought of as creating a role based programming methodology where layers and correspond to different roles for different developers. Framework is illustrated as a triangle to represent graphically that complexity and difficulty decrease for each role as one moves from the base layer to the top layer. Thus a developer who is responsible for building and maintaining the platform independent layer has the most complex and difficult job and must be familiar with the programming languages tools and other intricacies of one or more platform layers . A developer who is responsible for building and maintaining UI patterns e.g. configuration applications and pattern components has a simpler job as he or she can take advantage of the features and functionality offered by the platform independent layer as described above. Finally an application developer a developer who is responsible for developing end user applications has the least complex job as he or she can create applications simply by configuring predefined UI patterns. Where the configuration process is as simple as using a configuration application to choose the desired fields from a set of available fields the application developer need not have advanced programming skills.

The interfaces for pattern components include basic interfaces and an advanced list interface . The basic interfaces are used as a basis from which further interfaces may be developed e.g. a basic set of interfaces deployed with a visual modeling environment . The basic interfaces may include a pattern interface IPattern pane interface IPane and list interface IList . The advanced list interface may be based on the list interface as indicated by the inheritance arrow .

In general interfaces for a pattern component may provide a description of computer methods that may be required to be implemented e.g. in source code by a pattern that implements the interface. For example interfaces for pattern components may be similar to JAVA interfaces except that interfaces for pattern components may be limited to methods and might not include use of variables.

As an example the list interface may include a method retrieveListItems which is specified to return a list of items of an instance of a designtime component. A pattern that implements the interface such as a pattern named pullDownMenu which has a pull down menu of choices may be required to implement a method named retrieveListItems and return a list of items as a consequence of implementing the list interface . If an instance of the pullDownMenu pattern is generated that pattern may be referred to by an instance of the list interface and methods of the interface may be called based on the reference to the interface name. For example for an instance of the IList interface named List List may be used to refer to the interface and an instance of the pullDownMenu may be referred to by the List instance e.g. if a method uses interfaces rather than objects that implement interfaces to refer to instances of components . Also the method retrieveListItems may be called from the List instance to call the method implemented by the pullDownMenu pattern e.g. List retrieveListItems may be used to call a retrieveListItems method implemented for the pullDownMenu pattern .

Advantageously interfaces may provide a mechanism for polymorphism in a visual modeling language such that late binding may be offered for pattern development which may assist application development. For example an interface and a first pattern that uses the interface to refer to patterns that implement the interface may be developed. The first pattern may refer to the patterns without having to refer to a specific type of pattern such that new patterns that implement the interface may be developed and the first pattern need not be changed to adapt to the new patterns.

Interfaces may be implemented by patterns that are inherited by other patterns. For example the SODP pattern component which may refer to a pattern component for Service Oriented Design Patterns e.g. patterns that implement services may be a pattern that is inherited by patterns that represent a service. The SODP pattern component may implement the pattern interface such that all methods of the pattern interface are implemented by the SODP pattern component . Service patterns that inherit the SODP pattern component may inherit methods that are implemented for the pattern interface . As an example if a service search service inherits the SODP pattern component the search service pattern may inherit methods referred to by the pattern interface and implemented by the SODP pattern component .

Although interfaces may be referenced in a user environment of pattern development the late binding of patterns that are referenced as interfaces may occur in response to an end user application developer causing a designtime version of an application to be compiled to a runtime version of the application. Thus application developers may have different configurations of visual modeling environments that include different patterns and the different patterns may be referenced by interfaces and methods of patterns may be referenced by methods of interfaces .

To implement interfaces in a JAVASCRIPT based modeling language prototypes may be used. For example one or more interfaces may be defined as prototypes and a pattern defined as a class may have one or more interfaces attached to the class.

The pattern components of include an SODP pattern component and an AdvancedList pattern component which have respective definitions . The SODP pattern component implements an interface named IPattern as shown by the first line of the definition of the SODP pattern component. In addition the SODP pattern component has two assigned roles including a role named Panes and a role named AdvancedList.

Each of the assigned roles includes cardinality information that characterizes a cardinality of child components of the pattern that may implement an interface. For example the Panes role includes information that characterizes that one or more child components may use the interface IPane as indicated by line including IPane C1 N where C1 N characterizes a cardinality of 1 to n. The cardinality information may act as a limit for an amount of components that may be a child of the pattern component. For example the AdvancedList role is indicated as having a cardinality of 0 or 1 for the interface IAdvancedList. Thus a number of components e.g. patterns that are children of an instance of the SODP pattern may be limited to 1 such that two components that implement the interface IAdvancedList might not be children of the instance.

A role may be assigned to a child component based on the assigned role of a parent pattern component. For example if an instance of the AdvancedList pattern component were a child of an instance of the SODP pattern component the instance of the AdvancedList pattern component may be assigned the AdvancedList role e.g. by setting the roleName property to include AdvancedList . This assignment may be based on the association of the AdvancedList role in the assigned roles of the SODP pattern component with the IAdvancedList interface which is implemented by the AdvancedList pattern as shown by the association of the AdvancedList pattern with the AdvancedList role .

Based on the assignment of a role semantic behavior may differ. For example functionality of the AdvancedList pattern component may differ based on whether an instance of the AdvancedList pattern component is assigned the AdvancedList role or another role. Roles may be assigned in ways that differ from an assignment based on assigned roles of a parent object. For example the assigned roles of the SODP pattern may be defined by default e.g. in source code of the pattern component as a default assignment of roles . As another example a series of dialogue boxes e.g. a wizard may be presented to a user developing an application using pattern components and the user may be able to select roles to assign to a component through the dialogue boxes. As another example a palette of a visual modeling tool from which a user may choose a pattern may have different roles of a pattern component visually separated e.g. a pattern having two potential roles may have a first representation for the first role and a second representation for the second role e.g. the palette may group patterns of a same assigned role together .

To implement semantic behavior associated with a role methods of a role may have functionality that depends on a role assigned to an instance of a pattern component. The differing functionality may be implemented by determining an assigned role of a pattern component and performing operations or not performing operations based on one or more assigned roles of an instance. For example the SODP pattern component may be include a method described with the pseudo code 

According to that pseudo code the method getConfigurationItemType may have a particular behavior if the role Panes is assigned to an instance of the SODP pattern component. In particular the code return NS CustomConfigltem may be executed whereas it might not otherwise be executed.

Roles may be advantageous as rather than having code that depends on specific pattern components the code may depend on a role of a pattern component and new pattern components may adopt those roles such that the code that depends on an assigned role need not change. For example the following pseudo code defines that if a pattern component that calls an event listener is a pattern referred to as an SODP OSP or PatternAttachment pattern the pattern cannot be detached e.g. certain functionality is prohibited 

In that code if a pattern component is introduced that should also not be detached the above code must be changed. However if roles are used the code may be adopted for roles such that the code need not change if new components are introduced that have a same role and a standard way to determine a role exists. For example the following pseudo code may perform similar functionality 

In that example in the method canDetachEment of an SODP pattern component the role Tabs determines whether a child pattern component is to be prohibited from being detached. If pattern components having the role Tabs are introduced into the visual modeling environment e.g. if a child component implements the interface IPlugin the same operations may be performed and the code need not be changed e.g. a role of the new pattern may also be determined from a method object.getProperty roleName . To ensure a compliant format for determining a role the interface to which a child component implements may include a standard function such as getproperty that returns a name of a role for a property roleName. 

A development framework that implements support for interfaces roles or both may be structured to support plug ins also referred to as kits. A kit may be a reusable module that includes information for pattern components such as designtime information for display and use of an item and information for generating a runtime version of a pattern component.

In such a framework all pattern components may be implemented as kits including all designtime visual information. This information may include as an example a configuration of a drilled down version of a pattern component. For example when a designtime pattern component is opened e.g. a scenario pattern component is drilled down the visual component may configure the associated design time environment. Advantageously this may simplify work for kit development and maintenance because where and how to make changes to reach a desired effect may be intuitively clear for a developer e.g. in a kit associated with a pattern component .

In addition to having kits that are specific for a pattern component separate kits may exist for initialization logic and context specific contstraints. For example default diagrams of a pattern component may be displayed if no pattern specific diagrams exist. As another example context specific constraints may be set for pattern component that is drilled down e.g. a restriction prohibiting dragging and dropping a component to a component drilled down may be set . Advantageously kits for default initialization logic and context specific constraints may be reused for different patter components. Similarly as pattern kits need not have initialization logic or logic for context specific constraints same kits may be used across various floor plans that have different initialization logic.

In addition a pattern base kit may be introduced between core classes and concrete kits. This layer may contain implementations of major superclasses and implementation of support for roles and interfaces. This layer may allow kits to remain less dependent on changes in a core and simply kits as it may contain implementations of many generic functions that may be used by kits.

In that diagram there exist various types of kits. These types are used for different purposes including a production kit internal kits and extension kits. For example there is a production kit referred to as the pattern base kit which may provide generic functions that can be used by various pattern components. It may be considered a production kit as it may be included for all visual modeling environments and may be relied upon to develop patterns. The internal kits include pattern components services e.g. the query service and the like. Other kits may include extension kits which may be used to support additional features e.g. a set of functionalities such as constraints.

Aspects of the structure of kits may include patterns being separated from features e.g. new features . For example pattern kits are separate from extension kits that include features such that a selection or de selection of features is not longer related to a kit implementing specific pattern internal functionality but rather each extension kit represents a set of features and constraints as a whole which can either be enabled or disabled. Other aspects may include an infrastructure kit dedicated to providing services to kits that are not directly related to services of pattern components.

To implement interfaces an interface kit may be used that is depended upon by pattern kits. For example all pattern kits may be required to implement an interface and interfaces may be provided through an interface kit. is a diagram of a development component structure including a pattern interface development component including interfaces between a pattern base kit and pattern kits . The pattern interface kit may be an internal kit that contains interfaces that correspond directly to runtime interfaces and design time interfaces that are required for designtime purposes. Runtime interfaces that are defined by other runtime components may be separated into another internal kit that is its own development component. The kit structuring allows pattern kit developers to separate initialization logic and context specific constraints logic into feature kits or its internal kits . Thus main logic of kits may remain reusable in other floor plans as there may be no dependency on external constrains introduced by floor plan where it is used and no dependency on internally used kits.

To implement additional features through feature kits the following separation of logic may be used. A feature kit may be used to define a set of kits required to allow modeling a specific feature. For feature kits the above described distinction between types of kits may be used including extension kits internal kits and production kits. In that distinction the extension kits may be used to add features such as a new floor plan e.g. by adding a new extension kit .

A production kit may represent a model type in a model creation dialog in visual modeling tool. For example only one model type may exist for modeling of a composed pattern. Consequently only one production kit may exist e.g. the pattern base kit . Once a model type is selected in the model creation dialog a list of features e.g. extension kits of the selected production kit may be displayed for selection. A user e.g. a developer of an application using pattern components may specify a list of features they plan to use without directly referencing internal kits.

Constraints may belong to extension kits such as feature kits and they may also be placed in separate internal kits. For example constraints may be placed in separate internal kits if they are planned on being reused for different model types e.g. different pattern components . An extension kit of constraints may be defined for each floor plan.

To deploy features individually extension kits may be defined in separate development components which might not contain internal kits. The extension kits may be similar to an envelope around kits that contain logic but no patterns. An internal kit may be used many times by different extension kits.

Dependencies between kits may be declared and conventions may be required to prevent implicit dependencies such as reacting to an event of a kit to which no dependency has been modeled . A feature kit might not contain any class of its own. It might simply work as an umbrella that bundles many internal kits together to one e.g. as a floor plan .

Initialization logic may be executed when an instance of a component e.g. a pattern is generated. As patterns are interrelated it might not be acceptable to simply put initialization logic in a class of a modeling language that defines a component. For example in some instance initialization may differ in different use cases e.g. in different floor plans . By bundling a feature kit with initialization features necessary for initialization may be available. Initialization may be separated by having a standard method call overridden in initialization logic and having that logic registered as an event handler. For example a method may have a standard name of create and that method may be registered with a system registry as an initialization handler for a floor plan object. Thus the method may be called when a new floor plan is to be initialized and the initialization logic that may be imported through a feature kit may be separated from the component that is to be initialized.

To define constraints on how elements may be connected e.g. how a search service pattern may be connected to search form but not to other components constraints based on roles may be defined in every element. This may be implemented as a constraint handler. For example the following pseudo code may show how a constraint handler is implemented to restrict connecting of items by roles 

Similar to initialization logic constraints handlers may be defined in kits that are separate from components such as patterns. To allow constraint handler logic to be handled constraint handlers may be registered with a system and the registry may be used to determine a proper constraint handler to call. A standard name for constraint handlers may be used such that an appropriate constraint handler may be referenced easily e.g. all constraint handlers may have a method name registerRoleConstraintHandler that takes an argument class name corresponding to a component to have constraint logic .

Input characterizing a pattern component and an interface may be received . The input may include source code defining a pattern component indicating that the interface is implemented by the pattern component and defining the interface. The interface may include one or more methods that are to be implemented by any pattern component implementing the interface.

A determination is made as to whether the components of the interface are implemented by the pattern component . For example the interface may include several methods and the determination may include determining whether those methods are implemented by source code of the pattern component e.g. having same names same arguments and the like .

If the components of the interface are implemented by the pattern component a reference to the interface is bound to the pattern component otherwise an error may be raised . Binding the reference to the interface to the pattern component may include compiling source code referencing the interface with the source code implementing the interface e.g. compiling the implementations of the pattern component in lieu of the references to the interface . An error may notify a user that an interface was not implemented.

A determination is made as to whether the role is assigned to a pattern component . For example a determination may be made as to whether a pattern component is assigned a role that is associated with the behavior of . For example an if conditional statement may indicate that if a child component has a role detachable a behavior allowing the component to be detached may be performed. Then a check may be made of a property assignedRole to determine if a child component has the role detachable. 

A combination of different types of support may be used to assign a role to a pattern component and a pattern component may be assigned any number of roles e.g. zero one or multiple roles . For example one type of support may include receiving a selection of a role in an end user application development environment in a dialogue box that allows for an assigned roles property to be set. As another example when compiling a pattern component an interface implemented by a pattern component may be used to determine a role to assign. For example if a pattern component is a child component of another component the child component s interface may be used to determine a role that may be assigned based on a listing of interfaces and associated roles to assign in the parent component e.g. as described above in example pseudo code .

If a role is assigned to a pattern component the behavior may be associated with the pattern component otherwise it might not be associated with the pattern component . For example a behavior may be associated with a pattern component by including code corresponding to the behavior in a runtime version of the pattern e.g. in a late binding of code to pattern components to be included in an application. Not associating the behavior may include doing nothing e.g. such that code corresponding to the behavior is not included in a runtime version of the pattern component setting a property to indicate the behavior is not to be performed and the like.

In variations additional different or fewer operations can be performed in the processes of . For example in the process of a pattern component may implement multiple interfaces and determinations may be made as to whether all the interfaces are implemented.

The subject matter described herein can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structural means disclosed in this specification and structural equivalents thereof or in combinations of them. The subject matter described herein can be implemented as one or more computer program products i.e. one or more computer programs tangibly embodied in an information carrier e.g. in a machine readable storage device or in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program also known as a program software software application or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file. A program can be stored in a portion of a file that holds other programs or data in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification including the method steps of the subject matter described herein can be performed by one or more programmable processors executing one or more computer programs to perform functions of the subject matter described herein by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus of the subject matter described herein can be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user the subject matter described herein can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The subject matter described herein can be implemented in a computing system that includes a back end component e.g. a data server a middleware component e.g. an application server or a front end component e.g. a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the subject matter described herein or any combination of such back end middleware and front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other in a logical sense and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

The subject matter described herein has been described in terms of particular embodiments but other embodiments can be implemented and are within the scope of the following claims. For example operations can differ and still achieve desirable results. In certain implementations multitasking and parallel processing may be preferable. Other embodiments are within the scope of the following claims.

