---

title: Generating and binding web services to application components
abstract: For each of a set of business application classes on an application server, a web service class consisting of a separate web service method for each of a set of actions is generated. Each web service method contains a call to an interface web service method stored on a web server. The interface web service method is capable of calling a method on the application server. Once generated, the web service classes are compiled into an assembly and are stored on the web server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07904880&OS=07904880&RS=07904880
owner: Microsoft Corporation
number: 07904880
owner_city: Redmond
owner_country: US
publication_date: 20060317
---
Distributed computing systems execute methods that are distributed across multiple computing devices. In early systems proprietary protocols were used to communicate between the distributed components. This limited the reuse of many components. To overcome this web services were created which use a standard eXtensible Markup Language XML based communication platform known as SOAP Simple Object Access Protocol together with standard formats for describing the component and for registering the component. By using this standardized communication and publication system components residing on different computers and different computing platforms become interoperable and loosely coupled such that code running on one platform can utilize methods exposed on another platform on another machine.

Most application platforms were developed prior to the emergence of web services. As a result the methods in those applications were not available to code running on other platforms or machines.

To overcome this some designers have manually written web service shells that provide a standard web services interface for remote code so that the remote code can invoke the logic in the applications. Writing such web service shells is time consuming since a separate web service method must be written for each application method. In addition writing such web service shells requires additional expertise in the formation of web services methods and as a result is difficult for programmers who are familiar with coding for a particular application but are not familiar with the coding for web services.

The discussion above is merely provided for general background information and is not intended to be used as an aid in determining the scope of the claimed subject matter.

For each of a set of business application classes on an application server a web service class consisting of a separate web service method for each of a set of actions is generated. Each web service method contains a call to an interface web service method stored on a web server. The interface web service method is capable of calling a method on the application server. Once generated the web service classes are compiled into an assembly and are stored on the web server.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The claimed subject matter is not limited to implementations that solve any or all disadvantages noted in the background.

Embodiments are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with various embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

Embodiments may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Some embodiments are designed to be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules are located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing some embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer is operated in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Memory is implemented as non volatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is preferably allocated as addressable memory for program execution while another portion of memory is preferably used for storage such as to simulate storage on a disk drive.

Memory includes an operating system application programs as well as an object store . During operation operating system is preferably executed by processor from memory . Operating system in one preferred embodiment is a WINDOWS CE brand operating system commercially available from Microsoft Corporation. Operating system is preferably designed for mobile devices and implements database features that can be utilized by applications through a set of exposed application programming interfaces and methods. The objects in object store are maintained by applications and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

Communication interface represents numerous devices and technologies that allow mobile device to send and receive information. The devices include wired and wireless modems satellite receivers and broadcast tuners to name a few. Mobile device can also be directly connected to a computer to exchange data therewith. In such cases communication interface can be an infrared transceiver or a serial or parallel communication connection all of which are capable of transmitting streaming information.

Input output components include a variety of input devices such as a touch sensitive screen buttons rollers and a microphone as well as a variety of output devices including an audio generator a vibrating device and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition other input output devices may be attached to or found with mobile device .

As shown in the block diagram of embodiments provide a mechanism for creating publishing and utilizing web services on a web server based on application classes on an application server . provides a flow diagram of a method for generating publishing and using the web services .

In step of application server and web server are configured. Configuring web server involves finding a virtual directory and installing an Aif integration processor in the virtual directory. Although a single web server is shown in the web services may be distributed across a plurality of web servers. In such cases Aif integration processor must be placed in a virtual directory in each web server. AIF integration processor handles communications between web server and application server as discussed more completely below.

The web servers are then configured to grant access to the virtual directory to application server . This access includes read access write access and delete access to allow application server to store and remove .NET assemblies and other files in virtual directory . Application server is configured to designate which web servers the web services are to be placed upon.

Once the servers have been configured application classes are written or augmented at step so that the classes support the AIFSERVICEABLE interface and so that the classes provide methods for performing one or more actions where the methods have a method signature pattern that matches a template signature discussed more fully below. In some embodiments an action is an operation performed on an application document such as receive send or query .

The AIFSERVICEABLE interface includes four methods that must be implemented by any application class that is to be exposed as a web service. These four methods include 

getName this method returns the name of a document which must match the root element name in the document s XML schema. This name is not localized. In other words it does not change depending on the language set for the computer.

getLabel this method returns a label for the document class. This is a user friendly name for the document class and is localized.

getActionList this method generates a collection of AifActionInfo objects. Each AifActionInfo object provides information on an action performed by a method in the document class that is to be exposed as a web method. The AifActionInfo class contains the following parameters 

Each of these action types is associated with a method signature pattern that consists of the class type to be returned by the method that implements the action and an ordered list of parameter types that the method takes as input. Specifically the six action types have the following signature patterns 

Although six action types are listed above additional action types may be added as those skilled in the art will recognize. For each action type a method signature pattern must be provided. The signature patterns allow for parsing of XML documents into the parameters of the method when invoking the application method as discussed further below.

After the application classes have been written or augmented at step a user interface is used to register actions at step . provide example user interfaces and that allow a user to register actions.

The user initiates registration at step by selecting scan and register button or re register button of or scan and register button or re register button of . These buttons invoke a method that registers the actions by generating XML schema for each class that has at least one action. provides a more detailed flow diagram of the process of registration.

Registration is performed by registration unit of which at step of identifies a list of classes that support the AifServiceable Interface.

At step one of the classes in the list is selected and an instance of the class is created at step . The getActionList method is then invoked on the instantiated class to load the AifActionInfo list by creating an AifActionInfo object for each action in the class.

At step an action in the AifActionInfo list is selected. At step the action ID and the external name returned for the action is validated to ensure that the action ID does not contain spaces and is unique and to ensure that the external name is unique and meets the requirements set for a web service method name.

At step registration unit validates the method signature of the action based on the action type. This is done using the name of the method and reflection to extract the method signature from the class. The extracted method signature is compared to a method signature stored for the action type listed in AifActionInfo. In particular the return type for the method and the data types and their order in the input parameter list of the method are compared to the expected method signature. If the method signature does not match the expected method signature for the action type an error is thrown for the action and the action is not registered.

At step registration unit determines if there are more actions to process. If there are more actions a new action is selected at step . Steps are then repeated for the new action.

When there are no more actions for the current class at step the getSchema method exposed by the current class is used to retrieve the schema for the current class at step . At step the schema is validated by determining whether the schema is well formed whether the schema contains a target name space whether the schema root element name and the name returned by the getName method of the class are the same and whether the schema root element namespace matches the complex type namespace. In addition the schema is validated to determine if it conforms to the restrictions imposed by a data policy component.

If the schema is not valid an exception is thrown. If the schema is valid the schema is stored at step in a schema repository .

At step the registration unit determines if there are more classes in the list of identified classes. If there is another class the process returns to step and selects the next application class . Once all of the classes have been processed a separate schema file will have been stored in repository for each class that has at least one action and the registration process ends at step .

The information stored in the AifAction table in database is then used to update the list of actions shown in user interface . For each action in the AifAction table a separate row is created in user interface that contains identifying information for the action. The identifying information is provided in a set of columns and includes the action ID the label name the action type and document class where the method that performs the action is defined. Each row also includes an enable check box and an enable web method check box . When checked enable check box indicates that the action is enabled and may be invoked on the application server. When checked enable web method check box indicates that the action should be published as a web service method. Enable check box must be checked before enable web method check box . For example in user interface the enable check box and the enable web method check box for the CreateSalesOrder action have been checked. When a user changes one of the check boxes that information is stored in the AifAction table entry for that action.

The user can view more information for a particular action by selecting the action and then selecting General tab . This produces user interface of .

User interface includes much of the same information as found in user interface of . In addition user interface includes the external identifier for the action the description of the action and the status of the action. External identifier is the external name for the web method that callers will use to invoke the web method. The external identifier is usually different from the internal name for the action since the internal name is normally chosen from the point of view of the application and the external name is usually chosen so that it makes sense from the point of view of a caller to a web service. For example if a caller wishes to read a sales order they would call a method named ReadSalesOrder. Internally in the application this action is named SendSalesOrder since the application will be sending the sales order to the caller.

At step of the developer uses user interface or user interface to designate which actions are to be published as web services using the enable web services check boxes. Web services are then generated at step . Under some embodiments generation of the web services is initiated by the user selecting button or button of respectively. shows a more detailed flow diagram of the generation process.

At step of web services preparation of receives the instruction to generate web services. Web services preparation checks web server at step to ensure that application server has read write and delete access to virtual directory on web server . At step web services preparation checks application server to determine if code used to compile code in the application server as part of web services generation is present on the server. Under one embodiment this code is found in IntegrationFramework.dll.

At step web services preparation deletes .ASMX .XSD and any .NET assemblies from the virtual directories on web server as well as generation artifacts such as CSharp files .CS files web services C Sharp files .ASMX.CS schemas .xsd files and .NET assemblies from temporary work space .

At step an artifacts generation unit searches for actions in the AifAction table stored in database that are enabled for web services. At step artifact generation unit groups the actions by application class and at step selects an application class.

For the selected class artifact generation unit retrieves the schema for the class from the schema repository and stores the schema in temporary work space as .XSD file at step . At step artifacts generation unit forms a c sharp document class shell for the application class. Details of forming the document class shell are shown in the flow diagram of .

In step of the name space for the class shell is set based on the name of the application class. At step the default IXmlSerializable interface methods writeXml readXml and getSchema are overridden. This is done to prevent the conversion of an inbound XML SOAP message into object types. Normally when a SOAP message is received the web server deserializes the parameters in the SOAP document using the default readXml method to form the equivalent object forms of the parameters. In many of the present embodiments the application classes work with XML data instead of object data. As such converting the XML data in the inbound SOAP message into object form would only require converting it back from object form to XML form before passing it to the application class. Overriding the writeXml readXml and getSchema methods of the IXmlSerializable interface causes these methods to return null without creating the object types thereby saving a great deal of memory overhead associated with forming the object types.

Overriding these methods will affect the web services description language WSDL that is normally formed from the c sharp class. To overcome this the attribute XmlSchemaProvider is set in the document class shell at step which can be used to provide the schema information to the runtime to produce the WSDL.

Note that with the exception of the name space the name of the class shell and the name of the schema the document class shell will be the same for all document classes.

The document class shell is stored in temporary work space as class shell which is named with the application class name followed by the .cs extension.

After the document class shell has been formed at step of a web services class shell is formed at step . A method for forming the web services class shell is shown in the flow diagram of .

At step of the name space is set for the web services class. Under one embodiment the same name space is used for all web services classes. Note that this is different from the document class where a separate name space is provided for each document class to avoid naming conflicts.

At step using statements are added to identify class libraries that are to be included within the web service. Under one embodiment these include System System.Xml.Serialization System.Web.Services System.Web and a reference to the document class shell for the class.

At step a class is written for the application class using the name of the application class followed by Service as the name of the class. For instances for a SalesOrder application class the web services class is named SalesOrderService .

At step one of the actions within the business class is selected. At step a web method is written for the action that consists of a call to AIF integration processor . A return statement is also written that returns a value of null. The name of the method is the external name set for the action in the AifAction table. At step the method determines if there are more actions in the current class. If there are more actions the process returns to step to write a new web method for the new action. When there are no further actions at step the process ends at step . An example of the source code that would be generated through the process of is shown below for an action of CreateSalesOrder within a class SalesOrderService.

When there are no more actions for the current class the web service class shell is stored to temporary work space with the name of the class followed by the .ASMX.CS extension at step .

After the web service class shell has been formed at step of an ASMX page is formed for the class at step and is stored in temporary work space . This page consists of a single line such as 

At step artifact generation unit determines if there are more classes. If there are more classes the process returns to step to select the next class and steps and are repeated for the new class to form a new set of artifacts. Each application class produces a different document class shell web service class shell and ASMX page .

When there are no more classes at step an assembly generation unit uses tools in .NET framework library to form a .NET assembly in temporary work space . Note that all of the class shells and web services class shells are compiled together by assembly generation so that a single .NET assembly is formed for all of the classes.

At step assembly copy unit copies .NET assembly as web .NET assembly in virtual directly of web server . Assembly copy also copies .ASMX pages and schemas as .ASMX pages and schemas in web server .

Once the web services have been automatically generated as shown in they may be called by an outside caller by passing a SOAP message to web server . shows the processing of a SOAP message that invokes a web service generated under the flow diagram of .

At step web server receives an HTTP request with a SOAP document. The SOAP document identifies the web services method and the external name of the action associated with the web services method. At step a web services processor authenticates caller to determine if it will accept the HTTP request. If the caller is authenticated web services processor invokes a SOAP extension which has been registered for the web services . Under one embodiment SOAP extension stores the SOAP message without processing it to form SOAP message request .

At step web services processor invokes web services identified in SOAP message . At step web services method invokes AIF integration processor . AIF integration processor acts as an interface method between the web services and application classes on application server . Once invoked AIF integration processor authenticates the user who is trying to perform the action at step . This is done by attempting to log into application server using the user s credentials found in SOAP message request . If the log on fails the AIF integration processor stops processing and returns an error message.

If the user is authenticated integration processor parses SOAP message request at step to form an AIF XML message document that includes a portion of the information in the SOAP headers and XML information in the payload of the SOAP message that is needed to invoke a method on application server . In particular the XML message includes the external name of the action associated with the web services method.

Where SourceEndpointUser is the Windows user account of the sender in the format DOMAIN USERNAME SourceEndpoint is used to identify the sender of the message DestinationEndpoint is used to determine which account the message is destine for Action is the ExternalAction not the ActionId and Body will contain an XML structure representing a key to a specific record in a table a list of keys to records in tables criteria for searching a table a document or an error message.

At step integration processor invokes AIF request processor which is a method on application server and passes the XML document formed from SOAP message request .

At step AIF request processor identifies the application class and the method associated with the action in the XML message. This is done by looking for the entry for the action in the AifAction table using the external name for the action provided in the XML message provided by integration processor . AIF request processor than creates an instance of the application class and maps the data in the XML message into parameters for the method associated with the action. In particular this mapping is done using the action type for the action and the method signature assigned to that action type to determine how the elements of the XML document should be assigned to the parameters of the method. Once the contents of the XML document have been mapped to parameters for the method the method in application class is invoked.

At step the method executes and returns a result to AIF request processor . At step AIF request processor packages the result in an XML format if the returned result is not already in an XML format. The XML document is then returned to AIF integration processor on web server .

At step AIF integration processor adds XML message response from AIF request processor to HTTPContext.items so that it is available to SOAP extensions .

At step AIF integration processor returns a null value to web method which also returns a null value to web services processor . At step web services processor invokes SOAP extension which adds the contents of HTTPContext.items to the return SOAP message prepared by web services processor at step . The SOAP response message is then returned to the caller at step .

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

