---

title: Physical simulations on a graphics processor
abstract: The present invention is directed to a method, computer program product, and system for performing physics simulations on at least one graphics processor unit (GPU). The method includes the following steps. First, data representing physical attributes associated with at least one mesh are mapped into a plurality of memory arrays to set up of a linear system of equations that governs motion of the at least one mesh depicted in a scene. Then, computations are performed on the data in the plurality of memory arrays using at least one pixel processor to solve the linear system of equations for an instant of time, wherein modified data representing the solution to the linear system of equations for the instant of time are stored in the plurality of memory arrays.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08666712&OS=08666712&RS=08666712
owner: ATI Technologies Inc.
number: 08666712
owner_city: Markham, Ontario
owner_country: CA
publication_date: 20060724
---
The present invention is generally directed to graphics processor units and more particularly to using graphics processor units to perform game physics simulations.

An application such as a video game running on a computer system may require both physics simulations and graphics rendering. For example depicts a block diagram of a typical pipeline for computing and displaying the motion of one or more characters depicted in a scene of a video game. In a step physics simulations are performed to determine the motion of the one or more characters depicted in the scene. Then in a step the results of the physics simulations are graphically rendered for visualization by an end user.

The physics simulations of step are typically performed by a physics engine that is executed on a central processing unit CPU or a dedicated device of the computer system. Then the graphics rendering of step is performed by a graphics processing unit GPU . Ultimately however the results produced by the physics engine are used to modify the graphics of the video game or more generally the application and therefore will be passed to the GPU in some form. Because the results from the physics engine must be passed to the GPU for rendering latency and bandwidth problems may arise. Furthermore as a general processing unit a CPU does not possess the parallel processing capabilities of a GPU.

Given the foregoing what is needed is a method computer program product and system for performing physics simulations on one or more GPUs.

Embodiments of the present invention which may include a method computer program product and system take advantage of the parallel processing capabilitites available on a GPU to enable faster frame rates as compared to physics simulations executed on a typical CPU. Furthermore such a method computer program product and system utilize an implicit integration technique in the performance of the physics simulations to avoid the relatively small time steps required in explicit integration techniques. Moreover procedural forces and torques can be represented as a shader program that executes on the GPU s . In addition a GPU based physics simulator can be able to automatically replace a conventional software dynamics solver that typically executes physics simulations on a computer system. Embodiments of the present invention meet the above identified needs by providing a method computer program product and system for performing physical simulations on one or more GPUs. Such a method computer program product and system for performing physics simulations on one or more GPUs takes advantage of the parallel processing capabilities available on the GPU s thereby enabling faster frame rates compared to physics simulations executed on a typical CPU. Furthermore such a method computer program product and system utilize an implicit integration technique in an embodiment to perform physics simulations thereby avoiding the relatively small time steps required in explicit integration techniques. Moreover in accordance with an embodiment of the present invention procedural forces and or torques are representable as a shader program that executes on the GPU s . In addition a GPU based physics simulator in accordance with an embodiment of the present invention may be used to automatically replace a conventional software dynamics solver that typically executes physics simulations on a computer system.

In accordance with an embodiment of the present invention there is provided a method for performing physics simulations on at least one GPU. The method includes the following steps. First data representing physical attributes associated with at least one mesh are stored in a plurality of video memory arrays to set up a linear system of equations that govern motion of the at least one mesh depicted in a scene. Then computations are performed on the data in the plurality of video memory arrays using at least one pixel processor to solve the linear system of equations for an instant of time wherein modified data representing the solution to the linear system of equations for the instant of time are stored in the plurality of video memory arrays.

In accordance with another embodiment of the present invention there is provided a computer program product comprising a computer usable medium having control logic stored therein for causing at least one GPU to perform physics simulations. The control logic includes a computer readable first and second program code. The computer readable first program code causes the at least one GPU to store data representing physical attributes associated with at least one mesh in a plurality of video memory arrays to set up a linear system of equations that governs motion of the at least one mesh depicted in a scene. The computer readable second program code causes the at least one GPU to perform computations on the data in the plurality of video memory arrays to solve the linear system of equations for an instant of time wherein modified data representing the solution to the linear system of equations for the instant of time are stored in the plurality of video memory arrays.

In accordance with a further embodiment of the present invention there is provided a system for performing physics simulations. The system includes a memory that stores a plurality of video memory arrays and at least one pixel processor coupled to the memory. The plurality of video memory arrays store data representing physical parameters associated with at least one mesh to set up a linear system of equations that governs motion of the at least one mesh depicted in a scene. The at least one pixel processor performs computations on the data in the plurality of video memory arrays to solve the linear system of equations for an instant of time resulting in modified data representing the solution to the linear system of equations for the instant of time.

Further features and advantages of the invention as well as the structure and operation of various embodiments of the invention are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art s based on the teachings contained herein.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit s in the corresponding reference number.

Embodiments of the present invention are directed to a method computer program product and system for performing physics simulations on one or more GPUs. Such physics simulations may be used for example for performing game computing of an application such as a video game . To perform physics simulations on one or more GPUs in accordance with an embodiment of the present invention physical parameters associated with a mesh are mapped directly into video memory. The mesh may represent any physical object such as a solid object a volume a fluid or a cloth. Presented in more detail herein is an example method for performing physics simulations of a cloth on one or more GPUs. After the mesh is mapped into the video memory at least one pixel processor of the GPU s performs computations on the data in the video memory using a compiled shader program. Performing physics simulations directly on the GPU s may reduce the latency and bandwidth issues associated with typical physics simulations performed on a CPU.

Throughout the specification methods computer program products and systems for performing physics simulations on one or more GPUs are described in terms of an example physics simulation software interface called FYSI and a physics scene description language called FYSL . The invention however is not limited to FYSI and FYSL. Based on the description herein a person skilled in the relevant art s will understand that methods computer program products and systems for performing physics simulations on one or more GPUs may be implemented using other types of physics simulation software interfaces and other types of physics scene description languages.

It is noted that references in the specification to one embodiment an embodiment an example embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the art to affect such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

Described in more detail below are embodiments of the present invention for mapping physics simulations onto one or more GPUs. In Section II an example interface for performing this mapping is described. Section III presents an example method for performing physics simulations on one or more GPUs including a particular implementation of the example method for simulating cloth on the GPU s . In Section IV an example computer system for implementing physics simulations on one or more GPUs is described. However before describing embodiments of the present invention in detail it is helpful to describe an overview of an example workflow for performing physics simulation on one or more GPU s and an example GPU for implementing physics simulations.

As shown in block diagram includes an application . Application is an end user application that requires graphics processing capability such as a video game application. Application invokes physics simulation software interface . In an embodiment physics simulation software interface is an interface called FYSI developed by ATI Technologies Inc. FYSI is described in more detail herein. However as mentioned above the invention is not limited to FYSI. Other physics simulation software interfaces may be used without deviating from the spirit and scope of the present invention as would be apparent to a person skilled in the relevant art s . Physics simulation software interface creates a simple extensible abstract machine SEAM on which physics simulations are performed.

Physics simulation software interface communicates with API . Several APIs are available for use in the graphics processing context. APIs were developed as intermediaries between application software such as application and graphics hardware on which the application software runs. With new chipsets and even entirely new hardware technologies appearing at an increasing rate it is difficult for application developers to take into account and take advantage of the latest hardware features. It is also becoming increasingly difficult to write applications specifically for each foreseeable set of hardware. APIs prevent applications from having to be too hardware specific. The application can output graphics data and commands to the API in a standardized format rather than directly to the hardware. Because physics simulation software interface communicates directly with API there is no need to modify available APIs. Examples of available APIs include DirectX or OpenGL . API can be any one of the available APIs for running graphics applications. As will be appreciated by those of ordinary skill in the art alternative embodiments of the invention could integrate physics simulation software interface into API thus enabling application to work with a single software interface. In such an embodiment driver would then be modified to comply with such a single interface combining aspects of physics simulation software interface with API .

API communicates with driver . Driver is typically written by the manufacturer of the graphics hardware and translates standard code received from the API into native format understood by the graphics hardware. Driver also accepts input to direct performance settings for the graphics hardware. Such input may be provided by a user an application or a process. For example a user may provide input by way of a user interface UI such as a graphical user interface GUI that is supplied to the user along with driver .

Driver communicates with first GPU and or second GPU . First GPU and second GPU are graphics chips that each includes a shader and other associated hardware for performing physics simulations and graphics rendering. In an embodiment physics simulations and graphics rendering are performed on a single GPU such as first GPU . In an alternative embodiment physics simulations are executed one GPU or core such as first GPU and graphics are rendered on another GPU or core such as second GPU . In a still further embodiment physics simulations and graphics rendering are performed by a plurality of GPUs. After the physics simulations rendered graphics are sent to display unit for display. GPU and GPU may each be implemented as described in the next section.

The architecture of a GPU in accordance with an embodiment of the present invention enables a single instruction multiple data SIMD technique to be employed resulting in data level parallelism. Such a GPU includes processors and textures or video memory . The processors perform operations on data in the textures. Results of the operations are written into a render target a portion of video memory . A render target may be reassigned as a texture or as a subsequent computation. The textures are arranged into arrays of memory such as 1D 2D or 3D arrays of memory. Shaders are small programs or sets of instructions that are written for the processors to perform specific computations on the data in the textures.

An example manner in which a mesh is represented in the GPU vertex processor is now described. A mesh is composed of a pair of one dimensional lists a vertex buffer and an index buffer. As illustrated in the vertex buffer retains vertex positions. The embodiment shown in illustrates seven vertex positions. is used for illustrative purposes only and not limitation. A different number of vertex positions may be stored in the vertex buffer as would be apparent to a person skilled in the relevant art s . As illustrated in the index buffer stores face indices. is used for illustrative purposes only and not limitation. A different number of face indices may be stored in the index buffer as would be apparent to a person skilled in the relevant art s . A face represents a triangle and the face indices point into the vertex buffer. For example a face stored in the index buffer may include three vertices labeled 0 1 and 2. Each of these labeled vertices points to a separate location in the vertex buffer.

An example manner in which a mesh is mapped into video memory is now described. This example manner is presented for illustrative purposes only and not limitation. Other manners for mapping a mesh into video memory will be apparent to a person skilled in the relevant art s based on the description contained herein. The vertex and index lists are each mapped onto an optimized N dimensional array in video memory to better exploit pixel engine parallelism. An optimized N dimensional array is such that the N dimensional array fits the maximum addressability of the GPU s used for performing physics simulations. The vertex buffer maps onto an array of n by m elements and the index buffer maps onto an l by k grid. Each element in video memory e.g. a pixel is composed of a four component vector. The first three components represent the x y and z components of position and the fourth component is a boundary tag which is described below .

In an embodiment the vertex and index lists are each mapped onto an optimized two dimensional array in video memory as shown in respectively. In this embodiment the vertex buffer maps onto an array of 3 by 3 elements and the index buffer maps onto a 3 by 2 grid.

In the case of multiple meshes in a scene all the meshes are coalesced into one two dimensional composite mesh in accordance with an embodiment of the present invention. The composite mesh records in video memory sub mesh boundaries by tagging each sub mesh with a unique identification id . The id is recorded as the fourth component of each of the grid element. Mesh compositing alleviates both the overhead associated with a small size mesh download to video memory and relieves hardware resource pressure of total number of textures usage.

As mentioned above with respect to physics simulation software interface allows an application to perform physics simulations on GPU GPU and or a plurality of GPUs. In this section an example physics simulation interface is described. First an example physics simulation software interface called FYSI is described. Then an example scene description language called FYSL for expressing the abstract concepts embodied in FYSI is described. Finally there is described an example manner for converting physical parameters and attributes into FYSL in order to perform physics simulations on one or more GPUs using FYSI and thereby by pass a conventional software dynamics solver. It is to be appreciated however that these embodiments are presented for illustrative purposes only and not limitation. Based on the description contained herein a person skilled in the relevant art s will understand how to implement other types of physics simulation software interfaces for performing physics simulations on one or more GPUs.

FYSI an example physics simulation interface software system is a vehicle for mapping traditional CPU based simulation related computation onto the GPU. By using FYSI higher interaction rates may be achieved compared to those commonly experienced in game physics. FYSI departs from the conventional occlusion query modality for mapping collision detection and resolution onto graphics hardware. Instead it proposes a global simulation solution leveraging ever increasing hardware programmable shading power.

In a rendering block the simulation results from the physics block are rendered for visualization. In general several physics simulation steps are performed for every rendering frame. Hence the cumulative frame rate of both the simulation and visual rendering tasks determine the final interactive rate to the user. FYSI is a software development environment for providing physics simulation requirements. Initially the FYSL input abstraction is parsed and converted onto a collection of internal scene data structures. Simulation then commences in a GPU. Simulation results are either passed directly to the visual rendering thread by means of shared textures or optionally are available to be read back by the programmer. Finally FYSI implements a compute abstraction layer CAL wrapper on top of a graphics hardware interface for ease of extensibility. In an embodiment FYSI interfaces with Microsoft DirectX versions 9.0 and 10.0 however a person skilled in the relevant art s will appreciate that FYSI can interface with OpenGL or some other API.

The physics simulation field in games is rather broad and covers a large gamut of topics. Amongst them is rigid body cloth fluid and in general deformable body simulation. The type of physics simulation implies the format of data passed from the simulation stage onto the visual rendering stage. In the case of rigid bodies FYSI passes to the visual thread transform data which represents the incremental state change of objects entered in a recent simulation session. Cloth models return perturbed original particle positions and for fluids or deformable bodies the resultant simulated shape is almost non related to its initial definition. Typically the physics simulation process is compute bound and bandwidth requirements from it onto the visual rendering thread is relatively limited.

At a fairly high level a generic pipeline can be formed and applied to most of the aforementioned physics simulation aspects as shown in . Pipeline includes a system setup stage a solver stage and a collision stage . In system setup stage input is either an initial scene description or an incremental state update of the scene. The role of system setup stage is to perform an integration of the physical model and arrive at a linear system of the form A x b wherein A is a matrix x is unknown and b is a known vector.

In solver stage the linear system is resolved and the state of a depicted scene is updated based on the solution to the linear system. The linear system is resolved using numerical techniques which are available to a person skilled in the relevant art s . In an embodiment the linear system is resolved using a modified conjugate gradient method described in more detail below and in David Baraff and Andrew Witkin Large Steps in Cloth Simulation Computer Graphics Proceedings pp. 43 54 Jul. 19 24 1998 hereinafter the Baraff reference the entirety of which is incorporated by reference herein.

In collision stage the updated model is tested for potential collisions. As a result of computed contacts the state of the scene is further modified. Collision detection is performed by checking whether pairs of points intersect. Collision detection techniques are well known to persons skilled in the relevant arts. See e.g. the Baraff reference at p. 50.

Physics pipeline is exercised repeatedly across its stages for each of the simulation steps. In general actors in the scene are considered either individually or on a group basis. Individual actors as in the case of rigid bodies pass through system setup stage and solver stage of pipeline and only perform collision stage . Cloth fluid and deformable entities in general are considered a collection of actors with an explicit interaction model. Hence they are intended to execute all the stages of pipeline in most cases. An example in which a cloth is passed through physics pipeline is described herein in Section III.

Input abstraction to the FYSI physics simulation interface library is expressed in a custom scene description format called FYSL. FYSL is expressed in an XML format and is composed of five sections scene simulation actors joints and feedback. Each of these FYSL sections includes schema tags and optional value assignments. The schema tags and optional value assignments are described below. Samples of FYSL programs are provided at the end of this sub section.

The first section of FYSL is the scene. In this section the scene to be depicted is defined. Example global scene tags are presented in Table 1.

The second section of FYSL is the simulation. The simulation process in FYSI is discrete and commences in steps. FYSL simulation properties include the type and the time interval between simulation steps.

In addition global fields that represent forces operating identically on all scene actors can be optionally added to the simulation definition. In the present embodiment FYSL provides three types of force field tags a drag field a directional field and a procedural field. The drag field is a vector composed of three scalar values one for each dimension that exerts a braking force based on actor s linear velocity. The directional field is a unary force that is constant throughout the simulation and that operates in the direction specified by the vector. An example directional field is gravity. The procedural field represents a more involved field that might be varying in both time and space. The string attached to the procedural field is a function that is further translated into code of a shader program that executes on the GPU.

The third section of FYSL is actors. A group of actors is typically constructed in a logical grid that can be of one two or three dimensions. The grid serves as means for deploying actors properties in GPU video memory. Grid tags include width height and depth values as shown in Table 4.

An actor is specified by global and specific shape and dynamics properties. Shapes are used to determine pair wise collision detection and dynamics properties facilitate physics behavior for resolving responses. FYSL and FYSI use a left handed coordinate system for the definition of shapes. Global actor tags include name type and id values as shown in Table 5 

Actor id identification is expected to be a positive integer unique across a group of actors of the same hierarchy. For the most part FYSI is expected to assign default scene properties for those missing in the FYSL description.

Shape definitions supported in the described FYSL embodiment include box axis aligned or oriented sphere mesh and tetrahedron. Actor shape is defined in a local reference frame. Box and sphere bounding volumes are represented as a pair of center and radius the latter is either a vector or a scalar respectively . Mesh and tetrahedron assume a collection of vertex positions for tetrahedron the number of vertices is fixed 4 and a set of face indices implicit for a tetrahedron . For a mesh faces are explicit whereas for tetrahedron faces are implicit. Shapes are associated with a matrix for specifying local frame to world coordinate space transformation refer to the discussion below . Table 6 through Table 10 illustrate shape specific tags.

Center of mass for bounding volumes is explicit by the definition of the shape. For mesh and tetrahedron FYSI will implicitly compute a center of mass unless it is provided in the linear kinetics property set. Mesh center of mass parameter need not necessarily provided by the user its presence though will override FYSI s internally computed one.

Simulation takes place in world coordinate space. Shape transform is a concatenation of translation and rotation components the effect of applying linear and angular motion to an actor respectively. The resultant matrix transforms a shape from local to world coordinate space. The transform matrix is used by a FYSI client for the visual rendering process.

A FYSL box shape may take inside FYSI either an axis aligned AABB or an oriented OBB computation path. The choice is rather dynamic and might vary from a simulation step to another e.g. based on contact response. In general the AABB path for collision detection is more efficient compared to the OBB one.

Dynamics attributes can be of any combination of linear angular and matter types. Dynamics attributes define kinematics properties that include mass velocity explicit center of mass position orientation and exerted forces. In addition they provide contact response matter attributes such as restitution and friction. Dynamics tags for linear angular and matter types are provided in Table 11 Table 12 and Table 13 respectively.

A rigid body assumes a point mass for FYSI underlying performed physics behavioral rules. Linear motion and external forces operate on body s center of mass angular motion is applied to the point of contact.

FYSL torques when present are applied to the vertices of any of a box or a mesh shape. Torques are also meaningful in the case of particles based actor where each particle is defined as a sphere with a zero radius. The torque depends on the position relative to the center of mass of the actor or a parent actor in the case of particles . The torque affects the resulting angular motion of the actor. FYSL torques is meaningful for a particle based actor such as a shapeless actor without spatial extent . The torque depends on the particle position relative to the virtual center of mass of the top level actor. The torque affects angular motion of the particle.

Orientation for an actor is expected to be an orthogonal matrix where rows and columns are of unit length.

The omega dynamics property is a vector of angles in radians. A positive angle for any axis results in counter clockwise rotation around an axis whereas a negative angle results in clockwise rotation around the axis.

Mesh and tetrahedron face indices are zero based and each represent a triangle of a counterclockwise sense.

Grid deployment of actors takes advantage of GPU inherent data parallel architecture. The grid also provides the final image resolution to be read back from the physics assigned GPU for transporting simulation results onto the CPU or to a peer GPU that performs visual rendering. A 1D grid is highly inefficient on the GPU and is usually not used. Usually actors are distributed onto a 2D grid. The use of a 3D grid may be used for example if the 2D grid addressability exceeds the limits of the GPU. The dimensions of the grid not required to be a power of 2. Finally number of actors might not necessarily match the number of grid cells e.g. the latter must be equal or greater than the number of actors in a hierarchy . As a result a 2D grid might have the last row not fully populated and the last slice of a 3D grid might not be fully inhabited. FYSI fills in any incurred sliver with dummy actors.

Actors may be made hierarchical and a collection of actors at each hierarchy level may share global attributes. A grid is expected to be attached to the collection of actors at each level. Shapes at a higher hierarchy level are assumed to be of coarser geometry representation. This is in line with commencing top down simulation for which early collision detection rejection improves overall process efficiency. Also dynamics properties of an actor can be made unique at each hierarchy level providing the freedom to exercise adaptable physics. Joints described hereafter can be optionally applied to a group of actors for simulating constraints. For example joints are used in the simulation of cloth as described in more detail in Section III below.

The fourth section of FYSL is joints. Joints define interaction constraints between a pair of actors. They essentially limit the movement of actors. Joints may have common parameters and or unique parameters based on type. The common parameters include the joint type and a handle for each of the pair actor members. Joints are at the same tag level as actors in a FYSL description format. As such they can be defined in both the top scene level and at any actor hierarchy. Example joint tags are provided in Table 14 Table 15 and Table 16.

The fifth section of FYSL is feedback. The feedback section of a FYSL description is only provided by FYSI for the return path of simulation results. In a multi step simulation session there is a feedback section per step. Example feedback tags are shown in Table 17.

While the exemplary embodiments may include the above tags other tag types could be used in alternative embodiments. Sample 1. Provided below is an example section of code written in FYSL. This section of code depicts a collision detection physics simulation scene with a pair of mesh shaped actors with angular and linear dynamics respectively.

Sample 2. Provided below is another section of example code written in FYSL. This section of code illustrates a two level hierarchy for particles based actor of a 2 by 2 grid layout. This is a basic structure for defining cloth and fluid entities 

C. An Example Manner in which Physical Parameters Associated with a Mesh May be Received and Converted into FYSL

Software dynamics solvers such as Maya Dynamics owned by Autodesk of San Rafael Calif. exist for performing physics simulations that are executed by the CPU. In accordance with an embodiment of the present invention a plug in is used to by pass such a software dynamics solver and thereby perform physics simulations on the GPU s as described herein. In this embodiment the plug in captures a scene and converts attributes and fields associated with actors depicted in the scene into FYSL so that physics simulations may be performed on the GPU s using FYSI. In another embodiment a user may choose whether physics simulations are performed by the GPU s or by the software dynamics solver. In a further embodiment the GPU s or the software solver is automatically selected to perform physics simulations based on a predetermined criterion such as GPU availability and or software support for a given feature. For example the GPU s may be used to perform physics simulations of rigid bodies and cloth but the software dynamics solver may be used to perform physics simulations of fluids. By allowing physics simulations to be performed by either the GPU s or the software dynamics solver faster frame rates may be achieved. An example plug in for by passing a particular software dynamics solver namely Maya Dynamics is described in this section but first an overview of Maya Dynamics is provided.

Maya Dynamics is a class of techniques that produce motion by simulating the physics of the real world. Dynamics in Maya is diverse powerful and owns a tool set positioned at an identical importance level with modeling animation and rendering. In general the Maya Dynamics concept entails simulation based animation without the use of key frames. The Maya Dynamics family includes rigid and soft bodies particle systems cloth fluid and hair members. Maya Dynamics is used in games for creating visually impressive effects that are based on physical principals.

Workflow begins at a step in which the scene exporter receives attributes and fields attached to scene objects by the artist. Attributes include initial velocity spin orientation and matter friction. Fields represent forces that influence motion and involve drag gravity or procedurally defined with the latter expressed in a GPU shader program. The user either selects all or a subset of scene objects for commencing GPU based simulation. The exporter converts object geometry shapes and dynamics properties onto a GPU oriented physics simulation format which in an embodiment is FYSL.

In a step physics simulations are performed on the GPU s using FYSI. The GPU based simulator replaces the software dynamics solver node such as Maya Dynamics integrated solver seamlessly once the appropriate FYSI plugin is present. The GPU simulator runs simulation recursively in multiple discrete frames. In the course of simulation the current scene state is resolved and collision detection amongst each pair of FYSL dynamic actors is sought. Colliding pairs are further processed to arrive at a contact response that is likely to affect the motion of an involved actor. FYSI GPU assisted physics simulation utilizes primarily the pixel engines that exploits a much higher degree of concurrency than the vertex processors. Physics simulation on the GPU is grid based where there are little or no communication barriers across lattice cells. Computational kernels involved have for the most part a high arithmetic intensity characteristic and are therefore favorable candidates for demonstrating improved speedup compared to an equivalent CPU implementation. The simulation process exploits the use of a single or multiple GPUs for enhanced efficiency all transparent to the artist interacting with the software dynamics solver. FYSI produces results in an identical FYSL representation format to the one the exporter emitted. FYSI results are cached internally for a full simulation session and are fully exposed for reuse in Maya Dynamics.

In a step simulator results per frame are imported back onto the Maya Dynamics scene graph. During step only geometry shapes and transformation data are of concern. FYSI provides both shape positional and transformation updates for every simulation step. Transform data is relative to the incoming scene positions and orientations. In the case of rigid bodies it suffices to update transformation scene graph nodes from Maya Dynamics. For deformed bodies such as cloth and fluid updates are performed on full mesh vertices and indices in scene primitive nodes provided by Maya Dynamics.

In a step the simulation results are rendered for visualization. Either the GPU or a software based renderer is invoked to visualize the simulation effects. In an embodiment the GPU for running the visual rendering task is physically apart from the GPU s performing physics simulation. This is again to facilitate parallelism at a higher level.

An example method for performing physics simulations on the GPU s using FYSI and FYSL is now described. depicts a block diagram illustrating an example method for performing game physics simulations on one or more GPUs in accordance with an embodiment of the present invention. Method begins at a step in which physical parameters associated with a mesh are mapped into video memory to set up a linear system of equations that governs motion of the mesh depicted in a scene. The video memory may comprise textures described above with reference to . The mesh may represent any type of physical object such as a solid object a volume a fluid a cloth or another type of physical object as would be apparent to a person skilled in the relevant art s .

In a step computations are performed on the data in video memory using at least one pixel processor to solve the linear system of equations for an instant of time. Modified data representing the solution to the linear system of equations for the instant of time are then stored in the video memory. In an embodiment the modified data is stored in textures and then another shader renders graphics corresponding to the modified data. In this embodiment a single GPU performs the physics simulations and the rendering of graphics. In another embodiment the modified data is provided as output of a first GPU and then written into the textures of a second GPU. In this embodiment the first GPU performs the physics simulations and the second GPU performs the rendering of graphics. Alternatively the first GPU could write the modified data to an area of memory accessible to the second GPU e.g. video memory of the first GPU or system memory .

Method may be implemented to simulate any type of physical object. Provided below is an example implementation for simulating cloth on one or more GPUs. This example implementation is provided for illustrative purposes only and not limitation. Based on the description contained herein a person skilled in the relevant art s will understand how to perform simulations of other types of physical objects on the GPU.

An implicit technique for simulating cloth on one or more GPUs is now described. First a physical model of cloth and two approaches to simulating that model in discrete time are presented. Second a three step process of an implicit discrete time simulation is described. Third a method for mapping this three step process onto the GPU s is presented.

Cloth may be simulated by an internally constrained particle system. Such an internally constrained particle system may be represented as an array of point masses subject to internal stretch and dampening forces. These forces are dependent on the relative displacement and velocity of neighboring points. Such an array of point masses is referred to herein as a point mesh. depicts an example point mesh .

M the Diagonal Mass Matrix defined by diag M mmmmmm . . . mmm where mis the mass of the i th particle. Alternatively M may be interpreted blockwise that is as an n n diagonal matrix with each element being a 3 3 diagonal matrix.

In order for Eq. 2 to be solved by a sequence of computer process e.g. processes performed by at least one pixel processor in a GPU Eq. 2 must be converted into a discrete time problem. In a discrete time problem a next state of a system is given by its previous state s . Specifically given the position and velocity of a system at time t i.e. given right arrow over x right arrow over x t and

Explicit methods compute the state at a next time step out of a direct extrapolation of previous states using the forward projection of derivatives. For example the first order Euler Forward Difference approximates

Note that the right hand side of the discrete time derivative is bound on the left hand side by a value in the previous time step. It follows that the future state may be rewritten as a function of state namely Eq. 3 .

Applying the form of Eq. 3 to point mesh the system of equations that governs motion of point mesh i.e. Eq. 2 may be rewritten as a set of simple independent update equations applied per time step given by

The primary draw back to explicit integration schemes is numerical stability. In general for the forward approximation to hold the function a t in Eq. 3 must not change too rapidly with respect to t. That is the product b t must be below a threshold. When bis large the system is termed stiff and t must be made proportionally small.

Implicit methods account for the second class of discrete time integration techniques. Implicit methods deduce the state at a next time step from a system of equations expressing some reversibility from the extrapolated results. In other words the backward derivatives of future state are simultaneously verified against previous state. For example the first order Euler Backward Difference approximates

Applied to point mesh the system s governing equations i.e. Eq. 2 reduce to a simultaneous system of 3n unknowns

In either the explicit integration method represented in Eq. 4 or the implicit integration method represented in Eq. 5 the net internal force vector right arrow over f must be evaluated. In general 

The implicit integration technique is not without its share of complications. In particular the implicit integration technique requires an expression for right arrow over f not right arrow over f . In this case an approximate is used. Specifically 

The first term in Eq. 6 is evaluated as in the explicit case whereas the second and third terms are dependent on Jacobean matrices right arrow over f right arrow over x and

As set forth above with reference to performing physics simulations on a GPU using FYSI includes three steps i a system setup step ii a solver step and iii a collision step.

The system setup step involves determining values for A right arrow over x right arrow over b in Aright arrow over x right arrow over b given a constant timestep t the diagonal mass matrix M and the present positions right arrow over x and velocities of the point mesh

A linear pair wise force model for rectangular point mesh is used. In the linear pair wise force model for point mesh an edge between points i and j is called a joint and represents a combined spring and dampener. Two joints are complimentary if ij ji in which case equal but opposite forces i.e. Newton s Third Law are applied to vertices i and j given by fand f f respectively. If a joint is not defined between vertices i and j or if i j it is evident that f 0. Finally an expression for the net internal force acting on the ith point and its Jacobeans with respect to right arrow over x and

In practice joints are only defined between neighboring points and exist in a regular pattern. For instance the joint topology shown in point mesh of includes up to 12 joints per point subject to boundary conditions .

Since per joint forces are only dependent on their vertices it can be shown that rows f right arrow over x and

On the diagonal i.e. j i the original expressions for f x f xand f dot over x f dot over x hold and the elements are non zero provided just one joint exists for point i. Therefore since off diagonal f x 0 and f dot over x 0 when ij is not a joint 

In order for the linear system of equations governing the motion of point mesh to represent a well formed system matrix A must be i sparse and ii symmetric. With respect to item i A is sparse because A is linearly dependent on the Jacobean matrices right arrow over f right arrow over x and

Referring to joint forces between points in point mesh may be grouped into three classes i stretch joints ii shear joints and iii bend joints . Defined between adjacent nodes stretch joints model the strongest of the internal forces. Stretch joints resist in plane changes in area. Defined between diagonal nodes shear joints model the second strongest internal force. Shear joints resist the tendency for cloth to pinch inwards when pulled at the corners. Finally defined between alternating nodes bend joints model the weakest internal force. Bend joints resist folding.

While more realistic definitions have been defined the pair wise per joint force model presented above is influenced by a mix of the aforementioned Baraff reference and a pair wise joint force model taught by Kwang Jin Choi and Hyeong Seok Ko Stable but Responsive Cloth In ACM Transactions on Graphics SIGGRAPH 2002 pp. 604 11 2002 the entirety of which is incorporated by reference herein. According to the model disclosed herein all joints are modeled by the same function but classes of joints i.e. stretch shear and bend can be globally parameterized with different values for a stiffness k a dampening k and a natural length L. Per joint the action of the spring parameterized by kand L and dampener parameterized by k are linearly independent and can be considered separately.

In general the per joint force ffor either a spring force or a damping force will satisfy two properties i the per joint force fwill act along the direction of the joint right arrow over r and ii the per joint force fwill be proportional to a condition function C x dot over x . These two properties may be written mathematically as follows 

Since right arrow over r x right arrow over r x the criteria for symmetry i.e. f x f xand f dot over x f dot over x only requires the following to be enforced for C x dot over x 

The spring component of the per joint force fis now described. An ideal linear translational spring is a reactive mechanical device that resists and stores energy during deformation and that exhibits a restitutive force acting to release stored energy. Translational refers to type of mechanical forces involved. In the model for cloth simulation described herein forces act along the direction of joints i.e. circumflex over r . Linear refers to a restitutive force being directly proportional to deformation i.e. change in x . Finally ideal means that no energy is lost between cycles of deformation and restitution.

A per joint spring condition function is defined that directly conforms to the canonical ideal linear translational spring i.e. f k x . C x depends only on present vertex positions satisfies the symmetry criteria for both right arrow over f right arrow over x and

The damping component of the per joint force fis now described. A damper is a passive mechanical device that resists deformation but in contrast to a spring does not store energy or exhibit a restitutive force. Instead dampers resist deformation by dissipating applied energy in the form of heat. This characteristic is produced by a purely resistive force proportional to changes in velocity.

In the model for simulating cloth described herein ideal linear translational dampers exhibit a resistive force along the direction of a joint circumflex over r which is directly proportional to relative changes in velocity of its vertices dot over x . More specifically it exhibits a resistive force proportional to relative changes in velocity in the direction of the joint i.e. circumflex over r dot over x . A per joint damper condition function C x dot over x parameterized by a dampening coefficient kis defined. This per joint damper condition function satisfies the symmetry criteria for both right arrow over f right arrow over x and

Response and effect of external forces on point mesh is now described. Examples of external forces include gravity wind and collisions both self and with the environment . Note that a clear distinction exists between the response and effect of external forces. Responses involve an immediate change to a present state i.e. position velocity

Several approaches for solving for the response and effect of external forces are known including approaches that use reduced coordinates penalty methods and or Lagrange multipliers. See e.g. the aforementioned Baraff reference. Another approach discussed in the Baraff reference places constraints on the mass of certain points in a point mesh being modeled. As set forth above the block wise interpretation of the Diagonal Mass Matrix M represents the mass of the i th particle as a 3 3 diagonal matrix 

The approach developed in the Baraff reference has implications on the symmetry and consequently the efficient solvability of the linear system. These issues may be resolved by using a Modified Conjugate Gradient modified CG Method that introduces a filtering operation for enforcing the mass based constraints. Another approach uses both mass based constraints and the modified CG method as described in Kwang Jin Choi and Hyeong Seok Ko Stable but Responsive Cloth In ACM Transactions on Graphics SIGGRAPH 2002 pp. 604 11 2002 the entirety of which is incorporated by reference herein.

Having described a model for implicitly simulating cloth a three step method for implementing a simulation of cloth for each discrete time step on a GPU is now described. depicts an example flow diagram for implementing a simulation of cloth on a GPU in accordance with an embodiment of the present invention. In other words represents a high level depiction of a particular implementation of physics simulation block described above with reference to . In the large circles represent textures or arrays of video memory which may be similar to textures described above with reference to . The particular mapping of data to textures is as follows i circles labeled M represent a texture containing data relating to the mass of each point in point mesh ii circles labeled P represent a texture containing data relating to the position of each point in point mesh iii circles labeled P represent a texture containing data relating to the velocity of each point in point mesh iv circles labeled F represent a texture containing data relating to the net force acting on each point in point mesh and v circles labeled J represent a texture containing data relating to the Jacobean matrices. Shaded circles represent kernel operations such as mathematical computations performed by one or more GPUs .

The first step for implementing a simulation of cloth on a GPU involves mapping physical parameters associated with a point mesh into textures i.e. video memory to set up a linear system of equations that governs motion of the point mesh as shown in . By applying an implicit integration technique it was set forth above that the linear system of equations that governs motion of the point mesh may be written as Aright arrow over x right arrow over b wherein 

The second step for implementing a simulation of cloth on a GPU involves solving the linear system for updated values of position and velocity i.e. 

The final step for implementing a simulation of cloth on a GPU involves collision detection as shown in . A kernel operation determines whether collisions occur based on input from textures and . The results of kernel operation are written into texture and . After these results are written the collision response step is complete for this time step.

A significant design challenge of a GPU implementation is the development of a texture representation of the system equations that is both compact and facilitates single instruction multiple data SIMD parallelization. An embodiment of the present invention utilizes 17 persistent textures with structures derived directly from the rectangular point mesh under consideration. However the invention is not limited to 17 textures. A person skilled in the relevant art s will understand how to perform physics simulations on the GPU using a different number textures without deviating from the spirit and scope of the present invention.

The textures used to simulate cloth as described herein are two dimensional textures of n texels with heights of rows and widths of cols corresponding to point mesh which is organized into rows and columns of rows and cols elements respectively. Accordingly each texel location of each texture maps one to one to a particular point of point mesh . Each texture is ordered left to right top to bottom. In general individual textures store different properties pertaining to the same point i at the same texture coordinate s t. For clarity this document depicts all texture coordinates as un normalized integers bound by a height rows and width cols . The mappings from a point s number to its texture coordinates and vice versa are given by mod and

Furthermore subject to boundary conditions the point offsets of the joint topology shown in also maps to two dimensional texture offsets as shown in Table 18.

The 17 textures are labeled P V F A B C and D wherein A and B are each collections of six textures. For each point itexel s t the contents of the 17 textures are then given by the following definitions. First textures P V and F represent

Having defined the 17 textures a two stage process for filling these textures i.e. for performing the system set up step of is now described. depicts a flow diagram of a two stage process for setting up a linear system of equations that governs motion of point mesh . Included in are input textures and corresponding to P right arrow over x and

The first stage of involves six identical sub passes represented by kernel operations that operate for complementary pairs of joints. In this first stage the net force vector right arrow over f i.e. texture F and the lower triangular off diagonal elements of right arrow over f right arrow over x and

The second stage of involves two identical sub passes represented by kernel operations and that determine the diagonal elements of right arrow over f right arrow over x and

The first stage of system setup involves determining the net force vector right arrow over f i.e. texture C and the lower triangular off diagonal elements of right arrow over f right arrow over x and

Second kernel labeled updateF updates the net force vector right arrow over f or texture C with the forces of the joint being analyzed. Second kernel updateF adds the contribution of per joint forces fnow stored in T to an input net force vector right arrow over f or texture C either coming from another sub pass or containing external forces . It takes particular advantage of the linear independence of joint forces and the symmetry provided by Newton s Third Law. Because each sub pass effectively calculates the forces of complementary pairs of joints second kernel updateF is responsible for addressing T to properly consider both contributions due to boundary conditions certain values per joint forces in T may be inordinate .

Referring again to the second and final stage of system setup involves determining the diagonal elements of right arrow over f right arrow over x and

As graphically depicted in the summation in Eq. 13a is evaluated by a kernel labeled evalDiagonalC and the summation in Eq. 13b is evaluated by a kernel labeled evalDiagonalD . Kernels and are independent and only differ in their inputs and outputs. Kernel takes as input the data from textures and which collectively represent the off diagonal elements of Jacobean matrix right arrow over f right arrow over x . The output of kernel is written to texture i.e. texture C . Kernel takes as input the data from textures . and which collectively represent the off diagonal elements of Jacobean matrix

Referring again to the second step in the simulation of cloth on a GPU is the system solver step. A dominant approach for the system solver step is to employ the Conjugate Gradient CG method for iteratively solving linear systems i.e. Aright arrow over x right arrow over b described in the aforementioned Baraff reference. Best suited to large sparse symmetric and positive definite systems the CG method involves procedurally approximating x until right arrow over b Aright arrow over x falls below a user defined threshold. Although the example method described herein uses the CG method for the system solver step other methods may be used without deviating from the spirit and scope of the present invention as would be apparent to a person skilled in the relevant art s .

Referring again to the third and final step in the simulation of cloth on a GPU is the collision response step. A collision detection scheme checks whether a collision has occurred by determining whether a pair of points from the mesh being simulated e.g. point mesh intersect with either i another pair of points from the mesh or ii a pair of points from another object being simulated e.g. a ball that is depicted in the same scene as point mesh . Collision detection schemes are well known to persons skilled in the relevant art s as illustrated by the aforementioned Baraff reference. Any collision detection scheme known to persons skilled in the relevant art s may be used without deviating from the spirit and scope of the present invention.

Provided below are example sections of code written in FYSL. In particular provided below are the following i a high level scene description written in FYSL ii a child actors expansion and iii a fabric joint prototype expansion.

Embodiments of the present invention may be implemented using hardware software or a combination thereof and may be implemented in one or more computer systems or other processing systems. However the manipulations performed by the present invention were often referred to in terms such as adding or comparing which are commonly associated with mental operations performed by a human operator. No such capability of a human operator is necessary or desirable in most cases in any of the operations described herein which form part of the present invention. Rather the operations are machine operations. Useful machines for performing the operation of the present invention include digital computers such as personal computers video game consoles mobile telephones personal digital assistants or similar devices.

In fact in one embodiment the invention is directed toward one or more computer systems capable of carrying out the functionality described herein. An example of a computer system is shown in .

The computer system includes one or more processors such as processor . Processor may be a general purpose processor such as a CPU or a special purpose processor such as a GPU . Processor is connected to a communication infrastructure e.g. a communications bus cross over bar or network . Various software embodiments are described in terms of this exemplary computer system. After reading this description it will become apparent to a person skilled in the relevant art s how to implement the invention using other computer systems and or architectures.

Computer system includes a display interface that forwards graphics text and other data from communication infrastructure or from a frame buffer not shown for display on display unit .

Computer system also includes a main memory preferably random access memory RAM and may also include a secondary memory . The secondary memory may include for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive an optical disk drive etc. The removable storage drive reads from and or writes to a removable storage unit in a well known manner. Removable storage unit represents a floppy disk magnetic tape optical disk etc. which is read by and written to by removable storage drive . As will be appreciated the removable storage unit includes a computer usable storage medium having stored therein computer software and or data.

In alternative embodiments secondary memory may include other similar devices for allowing computer programs or other instructions to be loaded into computer system . Such devices may include for example a removable storage unit and an interface . Examples of such may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an erasable programmable read only memory EPROM or programmable read only memory PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to computer system .

Computer system may also include a communications interface . Communications interface allows software and data to be transferred between computer system and external devices. Examples of communications interface may include a modem a network interface such as an Ethernet card a communications port a Personal Computer Memory Card International Association PCMCIA slot and card etc. Software and data transferred via communications interface are in the form of signals which may be electronic electromagnetic optical or other signals capable of being received by communications interface . These signals are provided to communications interface via a communications path e.g. channel . This channel carries signals and may be implemented using wire or cable fiber optics a telephone line a cellular link an radio frequency RF link and other communications channels.

In this document the terms computer program medium and computer usable medium are used to generally refer to media such as removable storage drive a hard disk installed in hard disk drive and signals . These computer program products provide software to computer system . The invention is directed to such computer program products.

Computer programs also referred to as computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Such computer programs when executed enable the computer system to perform the features of the present invention as discussed herein. In particular the computer programs when executed enable the processor to perform the features of the present invention. Accordingly such computer programs represent controllers of the computer system .

In an embodiment where the invention is implemented using software the software may be stored in a computer program product and loaded into computer system using removable storage drive hard drive or communications interface . The control logic software when executed by the processor causes the processor to perform the functions of the invention as described herein.

In another embodiment the invention is implemented primarily in hardware using for example hardware components such as GPUs. Implementation of the hardware state machine so as to perform the functions described herein will be apparent to persons skilled in the relevant art s .

In yet another embodiment the invention is implemented using a combination of both hardware and software.

It is to be appreciated that the Detailed Description section and not the Summary and Abstract sections is intended to be used to interpret the claims. The Summary and Abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventor s and thus are not intended to limit the present invention and the appended claims in any way.

