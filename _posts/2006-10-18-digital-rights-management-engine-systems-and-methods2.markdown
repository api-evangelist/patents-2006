---

title: Digital rights management engine systems and methods
abstract: Systems and methods are described for performing digital rights management. In one embodiment, a digital rights management engine is provided that evaluates license associated with protected content to determine if a requested access or other use of the content is authorized. In some embodiments, the licenses contain control programs that are executable by the digital rights management engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626667&OS=09626667&RS=09626667
owner: Intertrust Technologies Corporation
number: 09626667
owner_city: Sunnyvale
owner_country: US
publication_date: 20061018
---
This application claims the benefit of U.S. Provisional Application No. 60 728 089 filed Oct. 18 2005 U.S. Provisional Application No. 60 772 024 filed Feb. 9 2006 U.S. Provisional Application No. 60 744 574 filed Apr. 10 2006 U.S. Provisional Application No. 60 791 179 filed Apr. 10 2006 U.S. Provisional Application No. 60 746 712 filed May 8 2006 U.S. Provisional Application No. 60 798 925 filed May 8 2006 and U.S. Provisional Application No. 60 835 061 filed Aug. 1 2006. U.S. Provisional Application Nos. 60 728 089 60 772 024 60 744 574 60 791 179 60 746 712 60 798 925 and 60 835 061 are incorporated herein by reference in their entirety for any purpose.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

In modern computing systems it is often desirable to limit access to electronic content services and or processing resources and or to allow only certain entities to perform certain actions. A variety of techniques have been developed or proposed to enable such control. These techniques are often referred to as digital rights management DRM techniques because in general terms their goal is to manage the rights of various entities in digital or other electronic content services or resources. A problem with many prior art techniques is that they are overly complex overly restrictive relatively inflexible fail to enable certain natural types of relationships and processes and or are uninteroperable with other DRM systems.

Systems and methods are described herein that can be used to ameliorate some or all of these problems. It should be appreciated that embodiments of the presently described inventive body of work can be implemented in numerous ways including as processes apparatuses systems devices methods computer readable media and or as a combination thereof. Several illustrative embodiments are described below.

A detailed description of the inventive body of work is provided below. While several embodiments are described it should be understood that the inventive body of work is not limited to any one embodiment but instead encompasses numerous alternatives modifications and equivalents. In addition while numerous specific details are set forth in the following description in order to provide a thorough understanding of the inventive body of work some embodiments can be practiced without some or all of these details. Moreover for the purpose of clarity certain technical material that is known in the related art has not been described in detail in order to avoid unnecessarily obscuring the inventive body work.

Commonly assigned U.S. patent application Ser. No. 10 863 551 Pub. No. 2005 0027871 A1 the 551 application which is hereby incorporated by reference describes embodiments of a digital rights management DRM architecture and a novel DRM engine that overcome some of the weaknesses that characterize many previous DRM implementations. The present application describes enhancements extensions and modifications to as well as alternative embodiments of the architecture and DRM engine described in the 551 application as well as new components architectures and embodiments. It will thus be appreciated that the material described herein can be used in the context of an architecture and or DRM engine such as that described in the 551 application as well as in other contexts.

In the example shown in entity uses a packaging engine to associate a license with the packaged content . License is based on the policies or other wishes of entity and specifies permitted and or prohibited uses of the content and or one or more conditions that must be satisfied in order to make use of the content or that must be satisfied as a condition or consequence of use. The content may also be secured by one or more cryptographic mechanisms such as encryption or digital signature techniques for which a trust authority may be used to obtain the appropriate cryptographic keys certificates and or the like.

As shown in packaged content and licenses can be provided to end users by any suitable means such as via a network like the Internet a local area network a wireless network a virtual private network a wide area network and or the like via cable satellite broadcast or cellular communication and or via recordable media such as a compact disc CD digital versatile disk DVD a flash memory card e.g. an Secure Digital SD card and or the like. Packaged content can be delivered to the user together with license in a single package or transmission or in separate packages or transmissions received from the same or different sources.

The end user s system e.g. a personal computer a mobile telephone a television and or television set top box a portable audio and or video player an eBook reader and or the like contains application software hardware and or special purpose logic that is operable to retrieve and render the content. The user s system also includes software and or hardware referred to herein as a digital rights management engine for evaluating the license associated with the packaged content and enforcing the terms thereof and or enabling application to enforce such terms such as by selectively granting the user access to the content only if permitted by the license . Digital rights management engine may be structurally or functionally integrated with application or may comprise a separate piece of software and or hardware. Alternatively or in addition a user s system such as system may communicate with a remote system such as system e.g. a server another device in the user s network of devices such as a personal computer or television set top box and or the like that uses a digital rights management engine to make a determination as to whether to grant the user access to content previously obtained or requested by the user.

The digital rights management engine and or other software on the user s system or in remote communication therewith may also record information regarding the user s access to or other use of the protected content. In some embodiments some or all of this information might be communicated to a remote party e.g. a clearinghouse the content creator owner or provider the user s manager an entity acting on behalf thereof and or the like e.g. for use in allocating revenue such as royalties advertisement based revenue etc. determining user preferences enforcing system policies e.g. monitoring how and when confidential information is used and or the like. It will be appreciated that while shows an illustrative DRM architecture and a set of illustrative relationships the systems and methods described herein can be practiced in any suitable context and thus it will be appreciated that is provided for purposes of illustration and explanation not for purposes of limitation.

As shown in memory of computing device may include a variety of programs or modules for controlling the operation of computing device . For example memory will typically include an operating system for managing the execution of applications peripherals and the like a host application for rendering protected electronic content and a DRM engine for implementing some or all of the rights management functionality described herein. As described elsewhere herein DRM engine may comprise interoperate with and or control a variety of other modules such as a virtual machine for executing control programs and a state database for storing state information for use by virtual machine and or one or more cryptographic modules for performing cryptographic operations such as encrypting and or decrypting content computing hash functions and message authentication codes evaluating digital signatures and or the like. Memory will also typically include protected content and associated licenses as well as cryptographic keys certificates and the like not shown .

One of ordinary skill in the art will appreciate that the systems and methods described herein can be practiced with computing devices similar or identical to that illustrated in or with virtually any other suitable computing device including computing devices that do not possess some of the components shown in and or computing devices that possess other components that are not shown. Thus it should be appreciated that is provided for purposes of illustration and not limitation.

A digital rights management engine and related systems and methods are described herein that can be used to provide some or all of the rights management functionality of systems such as those shown in or in other types of systems. In addition a variety of other systems and methods are described below that could be used in the context of systems such as those shown in as well as in other contexts including contexts unrelated to digital rights management.

In one embodiment a relatively simple open and flexible digital rights management DRM engine is used to implement core DRM functions. In a preferred embodiment this DRM engine is designed to integrate relatively easily into a web services environment such as that described in the 551 application and into virtually any host environment or software architecture. In a preferred embodiment the DRM engine is independent of particular media formats and cryptographic protocols allowing designers the flexibility to use standardized or proprietary technologies as required by the particular situation. The governance model used by preferred embodiments of the DRM engine is simple but can be used to express sophisticated relationships and business models.

Some of the illustrative embodiments of a DRM engine that are described below relate to an example implementation referred to as Octopus however it will be appreciated that the present inventions are not limited to the specific details of the Octopus example which are provided for purposes of illustration not limitation.

In the example shown in DRM engine host application host services and web services interface are loaded onto a device such as an end user s personal computer PC . Device is communicatively coupled to a server from which content and license were obtained as well as a portable device to which device may forward content and or license . Each of these other devices may include a DRM engine that is similar or identical to DRM engine which can be integrated with the particular host application and host environment of the device. For example server might include a host application that performs bulk packaging of content and or licenses and makes use of a DRM engine to evaluate controls associated with the content that is being packaged in order to comply with any redistribution restrictions. Similarly device might include a host application that is capable of both rendering and packaging content while device might include a host application that is simply able to render content. As yet another example of the potential diversity of host environments device might not include a web services interface but may instead rely on communication with device and web services interface to the extent host application and or DRM engine require the use of any web services. is only one example of a system in which a DRM engine might be used it will be appreciated that embodiments of the DRM engines described herein can be implemented and integrated with applications and systems in many different ways and are not limited to the illustrative examples shown in .

In preferred embodiments content protection and governance objects are used to represent entities in a system to protect content to associate usage rules with the content and to determine if access can be granted when requested.

Node objects are used to represent entities in the system. In practice a node will usually represent a user a device or a group. Node objects will also typically have associated attributes that represent certain properties of the entity associated with the node.

For example shows two users Xan and Knox two devices PC and portable device and several entities that represent groups e.g. members of the Carey family members of the public library subscribers to a particular music service RIAA approved devices and devices manufactured by a specific company each having an associated node object.

In one embodiment node objects include attributes that define what the node represents. One example of an attribute is a node type. Besides representing users groups or devices the node type attribute could be used to represent other entities. In some embodiments a node object can also include cryptographic key information such as when an embodiment of the key derivation and distribution techniques described elsewhere herein is used.

In some embodiments node objects also include a confidentiality asymmetric key pair that is used for targeting confidential information to the subsystems that have access to the confidential parts of the node object. This could be the entity that the node represents for example the Music Service or some entity responsible for managing the node for example the end user e.g. Knox could be responsible for managing his or her portable device .

In a preferred embodiment link objects are signed objects used to show the relationship between two nodes. For example in the link from the PC node to Knox shows ownership. The link from Knox to the Carey family node shows membership as does the link from the Carey family node to the Music Service Subscribers node . In one embodiment link objects express the relationship between two nodes and thus the relationships shown in could be represented using ten links.

As shown in a graph can be used to express the relationship between nodes where link objects are the directed edges between nodes. For example in the relationship between the Carey family node and the Music Service node asserts that there exists a directed edge in the graph whose vertices are the Carey family node and the Music Service node . Knox and Xan are members of the Carey family . Because Knox is linked to the Carey family and the Carey family is linked to the Music Service there is said to be a path between Knox and the Music Service . A DRM engine considers a node to be reachable from another node when there is a path from that node to the other node. This allows a control to be written that allows permission to access protected content based on the condition that a node is reachable from the device where the application that requests access to the protected content is executing.

As described in more detail below link objects can also optionally contain some cryptographic data that allows derivation of content keys. Link objects may also contain control programs that define the conditions under which the link may be deemed to be valid. Such control programs can be executed or interpreted these terms are used interchangeably herein by a DRM engine s virtual machine to evaluate the validity of a link e.g. to determine whether the link may be used to reach a given node in an authorization graph .

In one embodiment links are signed. Any suitable digital signature mechanism can be used and in one embodiment the DRM engine does not define how the link objects are signed and does not evaluate any associated certificates instead it relies on the host system to verify any such signatures and or certificates. This allows the system architect or administrator to define the lifetime of a link object to revoke it and so on e.g. by using expiring keys or certificates revocation and or the like thus providing an additional layer of policy management and security on top of the policy management and security provided by the DRM engine s evaluation of control programs and DRM objects in the context of specific pieces of protected content and or links for example expiration of a link could alternatively or in addition be implemented by including an appropriate control program in the link object itself which when executed would enforce the expiration date or other validity period . In one embodiment the DRM engine is generic and works with any suitable encryption digital signature revocation and or other security scheme that is used by the host application and or environment. Thus for example if the DRM engine needs to determine if a particular link has been properly signed it might simply call the host application and or a host or system cryptographic service to verify the signature in accordance with the particular signature scheme chosen by the system designer the details of which the DRM engine itself may be unaware. In other embodiments the DRM engine itself performs the actual signature evaluation relying on the host simply to indicate the appropriate signature algorithm to use.

Referring once again to in a typical scenario a content provider uses an application that includes a packaging engine to encrypt or otherwise cryptographically secure a piece of electronic content and creates a license that governs access to or other use of that content. In one embodiment license comprises a set of objects that specify how content may be used and also includes the content s encryption key s and or the information needed to obtain them. In one embodiment content and license are logically separate but are bound together by internal references e.g. using object IDs . In many situations it may be convenient to store and or deliver the content and the license together however this is not required in preferred embodiments. In one embodiment a license can apply to more than one item of content and more than one license can apply to any single item of content.

As shown in when a host application running on a client device wants to perform an action on a particular piece of content it asks DRM engine to check if the action it intends to perform e.g. play is allowed. In one embodiment the DRM engine will from the information contained in the objects comprising content license load and execute a control program associated with content and permission to perform the action will be granted or denied based on the result returned by the control program. Permission will typically require that some conditions be met such as the condition that a node be reachable from the node representing the requesting entity device

As shown in in preferred embodiment a license is a collection of objects. In the example shown in license comprises a ContentKey object a protector object a controller object and a control object . As shown in ContentKey object includes encrypted key data e.g. an encrypted version of the key needed to decrypt encrypted content item and information regarding the cryptosystem used to encrypt the key data. Protector object binds ContentKey object to one or more content objects . As shown in control object includes and protects a control program that specifies how content object is governed. In a preferred embodiment control program is a piece of executable bytecode that runs on a virtual machine operated by the DRM engine. The control program governs whether certain actions can be performed on the content by checking for satisfaction of conditions specified in the control program such as whether certain nodes are reachable using valid link objects whether certain state objects have been stored whether the host environment has certain characteristics and or the like. Referring once again to controller object is used to bind one or more ContentKey object to control object .

License may also comprise additional objects such as metadata providing a machine or human readable description of the content access conditions required by the license. Alternatively or in addition such metadata can be included as a resource extension of one of the other objects e.g. control object . In the embodiment shown in control object and controller object are both signed so that the system can verify that the control information is from a trusted source before using it to make content access decisions. In one embodiment the validity of control object can also be checked through verification of a secure hash included in controller object . Controller object can also contain a hash value for each of the keys or other key data contained in the ContentKey object s that it references thereby rendering it relatively difficult for an attacker to tamper with the binding between the key data and the ContentKey object.

As shown in in one embodiment content is encrypted and is included in a content object . The decryption key that is used is included within or referenced by ContentKey object and the binding between the two is represented by the protector object . As shown in unique IDs are used to facilitate the binding between content object and ContentKey object . The rules that govern the use of key to decrypt content are included within control object and the binding between control object and ContentKey is represented by controller object again using unique IDs.

It will be appreciated that while shows the objects that comprise a license in one preferred embodiment the DRM systems and methods described herein are not limited to the use of this license structure. For example without limitation licenses could be used in which the functionality of the various objects shown in are combined in a smaller number of objects or spread out over additional objects or broken up between objects in a different manner. Alternatively or in addition embodiments of the systems and methods described herein can be practiced with licenses that lack some of the functionality enabled by the license structure shown in and or that provide additional functionality. Thus it will be appreciated that any suitable mechanism for associating licenses with content can be used in accordance with the principles described herein although in preferred embodiments the advantageous structure shown in is used.

In one embodiment the DRM engine includes or has access to a secure persistent object store that can be used to provide a secure state storage mechanism. Such a facility is useful to enable control programs to be able to read and write state information that is persistent from invocation to invocation. Such a state database can be used to store state objects such as play counts date of first use accumulated rendering times and or the like as well as membership status and or any other suitable data. In some embodiments a DRM engine executing on a first system may not have access to a local state database and may be operable to access a remote state database e.g. using web and or host services. In some situations it may be necessary for a DRM engine executing on a first system to access state information stored in a database on a remote system. For example the first system may not include a state database or may not have the information it needs in its own state database. In some embodiments when a DRM engine is faced with such a situation it might access a remote state database via a services interface and or by using agent programs as described in more detail below.

The systems and methods described herein make use of control programs in a variety of contexts. For example control programs contained in control objects can be used to express the rules and conditions governing the use of protect content. In addition control programs in link objects can be used to express the rules and conditions used to determine whether the link is valid for a given purpose e.g. a node reachability analysis . Such control programs are sometimes referred to herein as link constraints. Yet another context in which control programs may be used is in agent or delegate objects were the control code is used to perform an action on behalf of another entity in the case of agent control programs or on behalf of another control in the case of delegate control programs .

In one embodiment control programs are executed or interpreted by a virtual machine hosted by a DRM engine as opposed to being executed directly by a physical processor. It will be appreciated however that a physical processor or other hardware logic could be readily constructed to execute control programs. In one embodiment the control programs are in byte code format which facilitates interoperability across platforms.

In a preferred embodiment control programs are written in assembly language and converted into byte code by an assembler program. In other embodiments templates and or high level rights expression languages could be used to provide the initial expression of rights rules and or conditions and a compiler could be used to convert the high level expression into byte code for execution by an embodiment of the DRM engine described herein. For example rights expressions written in a proprietary DRM format could with an appropriate compiler be converted or translated into a functionally equivalent byte code expression for execution on an embodiment of the DRM engine described herein thus enabling a protected piece of content to be used in accordance with the conditions specified by the content provider on systems that understand the proprietary DRM format as well as systems that included a DRM engine such as that described herein. It should also be appreciated that the digital rights management engine systems and methods described herein are not limited to the use of byte code rights expressions interpreted by a virtual machine. Instead in some embodiments rights can be expressed in any suitable manner e.g. using a high level rights expression language REL a template etc. and the authorization graph and or other techniques described herein performed using an application program designed to recognize and evaluate such rights expressions.

As previously indicated control programs typically express one or more conditions that must be satisfied in order for a request to use a piece of content to be granted for a link to be deemed valid and or the like. Any suitable conditions can be used depending on the requirements of the content provider or system architect and or the functionality provided by the system.

In preferred embodiments the virtual machine used by the DRM engine supports arbitrarily complex programs that are capable of testing for conditions such as some or all of the following 

Using these or any other suitable conditions a control object can express rules that govern how content can be rendered transferred exported and or the like. It will be appreciated that the above list of conditions is illustrative in nature and that any suitable conditions could be defined and used by e.g. implementing a system call for use in testing for the desired condition. For example without limitation if it were desired to require that a device be located on a particular sub network a system call could be defined e.g. GetIPConfig that would be operable to return the host device s IPConfig information or a remote device s IPConfig information if the system call were run on a remote device using an agent which could be used by a control program to test for whether the device was located on the prescribed sub network.

Preferred embodiments of the DRM engine related systems and methods described herein provide support for independent objects that carry control programs. Such agents can be distributed to a DRM engine running on a remote system in order to accomplish specified functions such as writing into the remote DRM engine s secure state store. For example an agent could be sent as a consequence of contacting a remote service or executing a remote control program. An agent can also be used to effect a content move operation to initialize a counter to deregister a node and or the like. As yet another example an agent could be used to perform a reachability analysis from a remote node to another node. Such an agent could e.g. be useful in enforcing a policy that prohibited a device registered to a first user from being registered to a second user. If the second user requested registration an agent could be sent to the device by the second user or a registration service acting on his or her behalf to determine if the device was already registered to the first user in which case the second user s registration request would be denied.

For example the DRM system on system A may be evaluating enforcing a rule for performing a remote rendering of content from system A to system B and the rule might indicate that such an operation is permitted only if system B is part of a certain group of devices where the membership in that group is asserted by the presence of a state object in a secure state database accessible on system B .

A method used in a preferred embodiment to handle such situations makes use of agents. For example if system A needs information from system B system A prepares an agent which in one embodiment is a control program e.g. a sequence of instructions that can be executed by a DRM engine that is sent from system A to system B . In one embodiment system A sends agent code to system B over an authenticated communication channel so that system A can be confident that it is indeed on system B that agent will run. In some embodiments along with agent code system A may also communicates to system B one or more parameters that may be used by agent code to perform its work.

As shown in system B receives agent and any associated agent parameters and runs the agent code . When agent is run on system B it accesses system B s state database retrieves state information and or performs one or more computations therewith and sends the results back to system A preferably over authenticated communication channel . At this point system A has the information it needs to continue with its evaluation.

In one embodiment the set of routines that represent the rules that govern the performance of a certain operation such as play on a content item is called an action control . The set of routines that represent validity constraints on a link object is called a link constraint . Like action controls in preferred embodiments link constraints can express any suitable combination of conditions. Also like action controls link constraints can be evaluated locally and or remotely using a services interface or an agent.

In one embodiment certain actions when granted require further participation from the host application. Obligations represent operations that need to be performed by the host application upon or after the use of the content key it is requesting. Callbacks represent calls to one or more of the control program s routines that need to be performed by the host application upon or after the use of the content key it is requesting. Examples of obligations include without limitation a requirement that certain outputs and or controls be turned off while content is being rendered e.g. to prevent writing the content to an unprotected output or to prevent fast forwarding through certain important segments of the content a requirement that information regarding use of the content be recorded e.g. metering or audit information and or sent to a remote site e.g. a clearinghouse service provider or the like a requirement that an agent program be executed locally or remotely and or the like. Examples of callbacks include without limitation a requirement that the host call the control program back at a certain absolute time after a certain elapsed time e.g. an elapsed time of content usage after occurrence of a certain event e.g. the completion of a trial content rendering period when the content has stopped being used and or the like. For example a callback after a certain elapsed time could be used to increment or decrement budgets playcounts and the like e.g. only debiting the users budget if they use a piece of content for at least a certain amount of time thus protecting the user from having his or her account debited if he or she accidently presses the play button but immediately presses stop.

In one embodiment there are different types of obligations and callbacks and if an application encounters any critical obligation or callback that it does not support or does not understand for example because the obligation type may have been defined after the application was implemented the application is required to refuse to continue the action for which this obligation or callback parameter was returned.

As previously indicated the control code contained in control object specifies the conditions or other requirements that must be satisfied in order to make the requested use of content items and . The systems and methods described herein enable the specification of arbitrarily complex sets of conditions however for purposes of this example assume that the control program is designed to require that in order to play content items and a a given user s node must be reachable from the device on which the request to play the content was made and b the current date must be after a specified date.

The following is a more detailed description of illustrative embodiments of an application that consumes DRM protected content e.g. a media player a word processor an email client etc. such as applications and in and a packaging application such as application that packages content targeted to consuming applications.

A content consuming application will typically focus on accessing protected content or could be part of a general purpose application that also performs other functions such as packaging content. In various embodiments a content consuming application might perform some or all of the following 

In one embodiment a DRM client engine evaluates the licenses associated with content confirms or denies permission to use the content and provides decryption keys to the content consuming application. The DRM client engine may also issue one or more obligations and or callbacks to the content consuming application requiring the application to perform certain actions as a consequence of having been given access to the content.

In one embodiment the DRM engine does not interact directly with the multimedia content managed by the host application . The host application logically interacts with content services for accessing the multimedia content and passes on to the DRM engine only the portions of data that must be processed by the engine. Other interactions with the content are performed by the media rendering engine . For example in one embodiment content services are responsible for acquiring content from media servers and storing and managing the content on the client s persistent storage while media rendering engine is the subsystem responsible for accessing the multimedia content and rendering it e.g. on a video and or audio output . In one embodiment the media rendering engine receives some information from DRM engine such as content decryption keys but in one embodiment the DRM engine does not interact with media rendering engine directly but rather through the host application .

Some of the information needed by the DRM engine might be available in band with the multimedia content and can be acquired and managed through the content services but some of this information may need to be obtained via means of other services such as a personalization service or a membership service not shown .

In the embodiment shown in cryptographic operations e.g. encryption signature verification etc. are handled by crypto services block . In one embodiment the DRM engine does not interact directly with the crypto services block but instead interacts indirectly via the host using host services interface which forward its requests. Crypto services may also be used by e.g. the media rendering engine in order to perform content decryption

It will be appreciated that is provided for purposes of illustration and that in other embodiments the various components shown in could be rearranged merged separated eliminated and or new components could be added. For example without limitation the logical division of functionality between the DRM engine and the host application in is simply illustrative of one possible embodiment and in practical implementations variations can be made. For example the DRM engine could be integrated wholly or partially with the host application. Thus it will be appreciated that any suitable division of functionality between host application and DRM engine can be used.

The following provides an example of the functions that a packaging engine might perform for a host application that packages electronic content. In practice a packaging application may focus on packaging specifically or could be part of a general purpose application operating at a user system that also accesses protected content either packaged locally or elsewhere e.g. on a network .

In one embodiment a host application provides a user interface and is responsible for obtaining information such as content references and the action s the user typically a content owner or provider wants to perform e.g. to whom to bind content what content usage conditions to include in a license etc . User interface can also display information about the packaging process such as the text of the license issued and if a failure occurs the reason for the failure. In some embodiments some information needed by the host application may require the use of other services such as authentication or authorization services and or membership through a Service Access Point SAP . Thus in some embodiments the packaging application and or the host application may need to implement some or all of the following 

The following describes a key derivation system that fits naturally with preferred embodiments of the DRM engine and system architecture described herein and or can be used in other contexts. Some of the examples in the following section are taken from a reference implementation of a preferred embodiment of this key derivation system known as Scuba . Additional embodiments are described in the 551 application.

As shown in in some embodiments link objects are used to distribute keys in addition to their primary purpose of establishing relationships between nodes . As described above a control object can contain a control program that can be used to decide if a request to perform an action should be granted or not. To do this the control program may check whether a specific node is reachable via a chain of links. The key derivation techniques described herein take advantage of the existence of this chain of links to facilitate the distribution of a key such that the key can be made available to the DRM engine that is executing the control program.

In one illustrative embodiment each node object in a given deployment that uses the optional key distribution system has a set of keys that are used to encrypt content keys and other nodes keys. Link objects created for use in the same deployment contain some cryptographic data as a payload that allows key information do be derived when chains of links are processed by a DRM engine.

With nodes and links carrying keys in this manner given a chain of links from a node A to a node C C an entity e.g. the DRM engine of a client host application that has access to the secret sharing keys of node A also has access to the secret sharing keys of node C . Having access to node C s secret sharing keys gives the entity access to any content key encrypted with those keys.

In one embodiment of a DRM system nodes are data objects not active participants in the system. Active participants in this context are called entities. Examples of entities are media players devices a subscription service content packagers and the like. Entities typically have nodes associated with them. An entity that consumes content uses a DRM engine and manages at least one node object that constitutes its personality. In one embodiment an entity is assumed to have access to all the data of the node objects it manages including all the private information of those objects.

Node objects that participate in an illustrative embodiment of the key derivation system contain keys as part of their data. In one embodiment nodes may contain two general types of keys sharing keys and confidentiality keys. The following sections list the different key types that can be used in various embodiments. It will be appreciated however that a specific deployment may use only a subset of these keys. For example a system could be configured to work only with key pairs omitting the use of secret symmetric keys. Or a system could be deployed without provisioning nodes with confidentiality keys if it only needed to use the sharing keys.

Sharing keys are public private key pairs and or symmetric keys that are shared by a node N and all the nodes Px for which there exists a link from Px to N that contains key derivation extensions.

Kpub share N This is the public part of a pair of public private keys for the public key cipher. This key typically comes with a certificate so that its credentials can be verified by entities that want to cryptographically bind confidential information to it.

Kpriv share N This is the private part of the public private key pair. The entity that manages the node is responsible for ensuring that this private key is kept secret. For that reason this private key will generally be stored and transported separately from the rest of the node information. This private key can be shared downstream with other nodes through the key derivation extensions of links.

Ks share N This is a key that is used with a symmetric cipher. As with the private key this key is confidential and the entity that manages the node is responsible for keeping it secret. This secret key can be shared downstream with other nodes through the key derivation extensions of links.

Confidentiality keys are key pairs and or symmetric keys that are only known to the entity that manages the node to which they belong. The difference between these keys and the sharing keys described above is that they will not be shared with other nodes through the key derivation extensions in links.

Kpub conf N This is the public part of a pair of public private keys for the public key cipher. This key typically comes with a certificate so that its credentials can be verified by entities that want to cryptographically bind confidential information to it.

Kpriv conf N This is the private part of the public private key pair. The entity that manages the node is responsible for ensuring that this private key is kept secret. For that reason this private key will generally be stored and transported separately from the rest of the node information.

Ks conf N This is a key that is used with a symmetric cipher. As with the confidentiality private key this key is kept secret.

Preferred embodiments of the key derivation and distribution systems described herein can be implemented using a variety of different cryptographic algorithms and are not restricted to any specific choice of cryptographic algorithm. Nevertheless for a given deployment or profile all participating entities will generally need to agree on a set of supported algorithms where the term profile will generally refer to the specification of a set of actual technologies used in a particular implementation e.g. an RSA for key derivation XML for encoding objects MP4 for the file format etc. and or other representation of the semantic context that exists when objects are defined in a practical deployment .

In one embodiment deployments include support for at least one public key cipher such as RSA and one symmetric key cipher such as AES .

In a preferred embodiment two types of cryptographic targeting are used. Targeting a content key to a target node s sharing keys means making that key available to all entities that share the secret sharing keys of that target node. Targeting a content key to a node s confidentiality keys means making that key available only to the entity that manages that node. Targeting of a content key is done by encrypting the content key CK carried in a ContentKey object using one or both of the following methods 

In a preferred embodiment symmetric binding is used where possible as it involves a less computationally intensive algorithm and therefore makes it less onerous to the receiving entity. However the entity typically a content packager that creates the ContentKey object may not always have access to Ks N . If the packager does not have Ks N then it can use public binding since Kpub N is not confidential information and therefore can be made available to entities that need to do public binding. Kpub N will usually be made available to entities that need to target content keys accompanied by a certificate that can be inspected by the entity to decide whether Kpub N is indeed the key of a node that can be trusted to handle the content key in accordance with some agreed upon policy e.g. that the node corresponds to an entity running a DRM engine and host application that comply with the functional operational and security policies of the system .

To allow an entity to have access to the sharing keys of all the nodes reachable from its personality node in one embodiment link objects contain an optional key extension payload. This key extension payload allows entities that have access to the private secret keys of the link s from node to also have access to the private secret sharing keys of the link s to node. In this way an entity can decrypt any content key targeted to a node that is reachable from its personality node if the targeting was done using the target node s sharing keys .

In one embodiment when a DRM engine processes link objects it processes the key extension payload of each link in order to update an internal chain of keys to which it has access. In one embodiment the key extension payload of a link L from node F to node T comprises either 

The public derivation information is used to convey the secret sharing keys of node T Ks share T and Kpriv share T to any entity that has access to the private sharing key of node F Kpriv share F .

The symmetric derivation information is used to convey the secret sharing keys of node T Ks share T and Kpriv share T to any entity that has access to the symmetric sharing key of node F Ks share F .

As for targeting content keys to nodes the preferred payload to include in a link is the symmetric derivation information. This is possible when the link creator has access to Ks share F . If not then the link creator will fall back to including the public derivation information as the payload for the link.

Assuming that the DRM engine processing a link already had Ks share F and Kpriv share F in its internal key chain after processing the link L F T it will also have Ks share T and Kpriv share T .

Since in one embodiment links can be processed in any order the DRM engine may not be able to do the key derivation computations at the time a given link L is processed. This might be due to the fact that at that time the DRM engine s key chain might not yet contain the keys of the from node of that link. In this case the link is remembered and processed again when new information becomes available to the DRM engine such as after processing a new link P. If the to node of link P is the same as the from node of link L and the from node of link P is a reachable node then the from node of link L will also be reachable and the key derivation step adds the private sharing keys of the from node of link L to the key chain.

Several examples are provided below to illustrate how various embodiments of the systems and methods described herein could be applied in practice. The systems and methods described herein can enable a wide range of rights management and other functionality and thus it will be appreciated that the specific examples that are given here are not intended to be exhaustive but are rather illustrative of the scope of the inventive body of work.

Assume that you want to implement a DRM system that ties the right to play content to a particular user and you want to make it easy for the user to play content on all the playback devices that he or she owns. Assume that you decide that you are going to provide users with software that enables them to add playback devices as needed e.g. mobile players . Also assume however that you want to set some policy to limit the number of general purpose devices to which the user can transfer the content so that the user does not have the ability to act as a distribution agency.

Based on these system requirements it might for example make sense to tie the licenses you create to users and to establish relationships between users and the devices that they use. Thus in this example you might first decide what kinds of nodes you need to establish the sorts of relationships that you require. For example you might define the following types of nodes 

Each node object can include a type attribute that indicates whether the object represents a user a PC or a device.

Say for example that you decide to restrict the maximum number of PC node objects that can be attached to any one user at a particular time to four 4 . You decide there is no need to restrict the number of devices attached to the user as long as you provide restriction on the number of PCs. Based on this a control program can be set up to allow access if a relationship can be established between the user node and the node that requests access. That node then could be either a PC or a device.

Since the content decryption key in this example is encrypted using a secret key associated with the user s node this secret key will need to be obtained in order to decrypt the content decryption key. If the optional key derivation techniques described elsewhere herein have been used the user node s key can be obtained simply by decrypting the key derivation information contained in link using one of device s secret keys. The decrypted key derivation information will contain the key needed to decrypt the content decryption key contained in license or information from which it can be derived or obtained .

Referring once again to assume user wishes to associate a new PC with his or her user node . Server verifies that the maximum number of PCs have not already been associated with user node and authorizes PC to be associated with user node . To perform the association however server needs to obtain personalization information from PC e.g. cryptographic keys a unique identifier etc. . If however the PC has not been previously personalized as might be the case if the user simply downloaded a copy of the PC software server will perform the personalization process e.g. by creating a PC node object using the bootstrap protocol described elsewhere herein or direct the user to a service provider who can perform the personalization process. Upon completion of the personalization process server can create a link from PC to user node and send the link to the PC which could continue to use it as long as it remained valid.

The user could request to add additional PCs later and the server would enforce the policy that limits the number of PC node objects per user to 4 typically it would also provide the ability for users to remove PCs from its active list as needed .

As yet another example assume now that the service provider has decided that users should be able to play any content that they own on any device that they own. The service provider might also wish to allow the user s PC software to create links to each of his or her devices rather than requiring the user to contact server . In such an embodiment when the user wished to play content on a new device the user s PC software would access the new device s confidential personalization information and use it to create a new link for that device e.g. a link from the new device to the user s node . If the device was not personalized then the PC software might access a remote service or direct the device to access the remote service to perform the personalization process. The PC software would then send the link to the new device at which point the new device would be able to play the content as long as it remained valid since in one embodiment once a link object exists there is no need to create another one unless the link object expires or is otherwise invalidated.

In the examples shown above content is targeted to the user. To do this a packager application chooses a new ID for the content or uses an existing one creates an encryption key and associated ContentKey object as well as a protector object to bind the content object and the ContentKey object. The packager then creates a control object with a control program e.g. compiled in byte code executable by the DRM engine s virtual machine that allows the play action to take place if and only if the user node is reachable from the PC or device node that is requesting the action. Typically the control controller protector and ContentKey objects are embedded in the packaged content if appropriate so that the PCs and devices do not have to obtain them separately.

In one embodiment when a device or a PC wants to play content it follows a process such as that previously described in connection with . That is the DRM engine finds the protector object for the content ID of the content then the ContentKey object referenced by that protector then the controller object that references that ContentKey object and finally the control object referenced by that controller. The DRM engine executes the control program of the control object which checks whether or not the user node is reachable. If the device or PC node has the necessary link objects to verify that there exists a path between its node and the user node then the condition is met and the control program allows the use of the key represented in the ContentKey object. The media rendering engine of the device or PC can then decrypt and play the content.

To accomplish this a link object would be created with a limited validity period. In one embodiment this could be done as follows 

For ease of explanation assume that the DRM enabled consuming software required to play the DRM protected content is already present on the friend s PC . The file containing the content and license is transferred to the friend s PC . When the user tries to play the content the software recognizes that there is no valid link object linking the local PC node with the node of the user who owns the content. Software prompts the user for his credentials this could be provided via a username password a mobile phone authentication protocol a smartcard or any authentication system allowed under the policy of the system and communicates with a backend system . The backend system checks the attributes of the user node object and PC node object for which the link is requested and checks that there is no active temporary login link object still valid. If those conditions are met the backend service creates a link object linking the friend s PC node object and user s node with a validity period limited to the requested login duration e.g. less than 12 hours to comply with the policy in this example . Having the link object now enables the friend s PC to play the user s content until the link expires.

In the illustration shown in the directory server may for example contain user profiles and group definitions. For example a group called Special Projects Team may be set up by a company s system administrator to identify the members of the company s Special Projects Team.

In one embodiment the directory server may comprise an Active Directory server running web services such as those described in the 551 application and implemented e.g. with standard IIS based technologies on the Windows platform that issue nodes links and licenses to the people in the Special Projects Team group based on content that is accessed. If membership changes in the group then new tokens may be issued. For revocation of rights the directory server can run a security metadata service based on technology such as that described in the 551 application occasionally referred to herein as NEMO technology . In some embodiments the client can be required to have an to date time value or notion of time based on whatever freshness value the company chooses to define e.g. 1 week 1 day 1 hour every 5 minutes etc. in order to use DRM licenses. For example a token that the security metadata service provides might include a trusted and authenticable time value. In some embodiments the client can identify user node IDs in security metadata service interactions. Security metadata can be evaluated directly in the context of license controls to determine if a user still has a given membership. Security metadata can also return agents that can determine if relationships such as being a member in the Special Projects Team are valid. Thus in some embodiments it is possible to leverage a company s existing authorization and authentication infrastructure e.g. the company s Active Directory server with just the addition of a few well defined web services.

John can access the document because his device has a link to John s User Node and it also has a link from John s User Node to the Special Projects Team Group Node. Likewise if he forwards this document to others they can only access it if they also can produce a valid chain of links to the Special Projects Team Group Node e.g. by requiring that the Special Projects Team Node be reachable by the device .

John might save the file already protected on his computer and later attach it to an email message action . For example he might open an old email to his boss George attach the file as he normally does and send the message. As shown in George also has the DRM plugin installed on his computer . When he logged in to his computer the plugin opportunistically checked all of the groups that he has been added to action and downloaded new refreshed links for any that had expired action . If he had been added to Special Projects Team since his last login his plugin would download a Link Object that links his User Node to the Special Projects Team Group Node. This Link signifies that User Node George is a member of the Group Node Special Projects Team . In this example assume Link Object has an expiration date after which it will no longer be valid e.g. 3 days .

As shown in when George tries to open the document actions the DRM plugin checks the embedded or attached license and learns that the Special Projects Team node must be reachable. His plugin constructs and validates a chain of links from his computer s Device Node to the User Node George and from User Node George to Group Node Special Projects Team action . Since the device has a valid chain of Links his plugin permits access to the file.

As described elsewhere herein in some embodiments links can also carry a secure chain of keys. Thus in some embodiments by producing a chain of Links to the Special Projects Team Node the plugin can not only prove that it is permitted to access the content but also that it is capable of decrypting a chain of keys that enable it to decrypt the content.

If for example another employee Carol receives John s email accidentally and attempts to open the document her DRM plugin will retrieve the license bundled with the file and evaluate the terms of the license. Her PC has a link to her User Node Carol but since she is not a member of the team there is no Link from Carol to the Special Projects Team Group Node. Since Special Projects Team is not reachable she is not permitted to access the file.

If Carol is eventually added to the group Special Projects Team . The next time her DRM plugin refreshes her memberships it will detect this new group and download a Link Object that links her User Node to the Special Projects Team Node. Her plugin now has all of the links it needs to construct a chain from her Device Node to her User Node to the Special Projects Team Node. The Special Projects Team node now is reachable and she can open any documents or emails that are targeted to the Special Projects Team even those that were created before she joined the team.

Assume that a month later George moves on to a new role and is removed from the Special Projects Team Group in the Active Directory. The next time George logs in his plugin does not receive a new refreshed Link Object associating his User Node George to the Special Projects Team . When weeks later he tries to open John s file his plugin attempts to construct a chain of links to the Special Projects Team. His PC still has a link to the User Node George George s PC still belongs to him but the Link from George to the Special Projects Team has expired. Since Special Projects Team is not reachable he is not permitted to access the file.

Assume that the company has a policy that requires access to all confidential information to be logged. In one such an embodiment the policy for the Special Projects Team dictates that all licenses that are created for this group also need to require collection and reporting of usage information to e.g. a central repository. Thus in this example when evaluating e.g. executing the control program in the license the plugin executes the requirement to log the access and does so. For example activity of consequences can be logged in a local protected state database such as that described herein and when network connectivity is re established the relevant content can be reported via services previously described.

Assume that John is an attorney and wishes to send an email with an attachment to other members of the Special Projects Team. When John installs the DRM plug in for his applications it also installs items to his email toolbar. At some point during his composition of the email message John accesses Set Permissions from a pull down menu that was added to his toolbar. The DRM plug in contacts a Policy Service and displays a list of corporate messaging policies from which to choose. John selects Special Project DRM Template and the DRM plug in uses the NEMO protocol to request and ensure the authenticity integrity and confidentiality of policy object that it receives. The policy describes how the licenses that use this template should be created including how they should be targeted and bound.

When John hits Send the DRM plugin encrypts the message and attachment and generates the associated license s . The license requires that in order to access the email or the attachment either the Special Projects Team Group Node or the Attorneys Group Node must be reachable.

The license s are bundled with the encrypted message payload and encrypted attachment. The message is subsequently sent to a list of recipients using standard email functionality. Since the license rules and encryption are not dependent on the addressing of the email the fact that an incorrect email recipient might be erroneously included does not put the contents of the email or attachment at risk.

Since such an unintended recipient will not have a valid Link Object linking his User Node to the Special Projects Team he is not permitted to access the content if and when he attempts to do so. Furthermore since his device does not have the necessary chain of Links and the keys they contain his device does not even have the capability to decrypt the content.

However if the unintended recipient in turn forwards the same unmodified email using standard email functionality to a member of the Special Projects Team. That member will have a Link Object that Links his User Node to the Special Projects Team Group Node and will be able to access the email s contents.

Assume that another attorney Bill at the company has also received a Link Object that associates him with the Special Projects Team Group Node. Bill can also view the file. If he forwards the message to a paralegal Trent who is neither an attorney nor associated with the Special Projects Team Trent will not have a Link Object that connects him with the Special Projects Team Group Node and he will not be able to access the document.

If Trent is subsequently added to the Special Projects Team group in the LDAP directory he will be given the necessary Link Object s and will be able to access the previously forwarded email.

If as previously discussed the company has a policy indicating that a reporting requirement be included in all licenses then in one embodiment whenever a control program within one of these licenses is executed e.g. when someone attempts to access the file a reporting event can be triggered. The reporting step can additionally include an indicator as to whether or not access was granted or denied this is a matter of implementation choice. If such an indicator is used a log can be maintained of the number of attempts to access a particular document and status or other information on each e.g. success failure etc. .

As yet another example assume that one of the members Stephen of the Special Projects Team travels to another company to perform work on the special project. Before leaving for the other company Stephen s email client downloads a local copy of all the email in is Inbox. The protected report attached to one of these emails also includes an embedded or attached license. This license object includes both the rules for accessing the content as well as an encrypted content key. The only missing link required to access the content is the necessary link objects to reach the Special Projects Team Group Node.

Since in this example the company s policy is to allow Link Objects to remain valid for 3 days the Link Object that links Stephen s User Node to the Special Projects Team Node will remain valid while he is traveling and disconnected. If he attempts to access the file while offline the Special Projects Team Group Node will still be reachable and he will be permitted to access the file.

If however Stephen stays offline for more than three days the Link Object linking him to the Special Projects Team will expire. The Special Projects Team Group Node will then no longer he reachable and he will not be permitted to access the file.

If Stephen eventually travels to a location where he can connect to the company s system e.g. via VPN his DRM plug in will request refreshed copies of Link Objects for each of the groups to which he belongs. Since he is still part of the Special Projects Team group he will receive a new link object from his User Node to the Special Projects Team Group Node. This link replaces the old link which has expired and is no longer valid.

Since the Special Projects Team Node is now reachable using this new refreshed Link he is once again able to access the protected report. The new link object will be valid for a period of 3 days after which it will also expire.

As yet another example assume that a member Sally of the Special Projects Team wishes to communicate with another team member via an instant messenger save a copy of the communication and give it to another member of the team e.g. via an email attachment a diskette a dongle or the like . In this example the instant messenger client and potentially any other messaging or communication products which the company offers its employees is linked to a DRM plugin which as in the previous examples accesses the Policy Special Project DRM Template that dictates how licenses are to be targeted and bound. When Sally attempts to save her instant messaging conversation e.g. by selecting Save As the plug in chooses an encryption key e.g. randomly and packages encrypts the text of the conversation. Per company policy the DRM plugin then generates a license object that is targeted and bound to the Special Projects Team Group Node.

The file containing the protected IM transcript is bundled with the license to access the transcript contents. As in the previous examples the License contains both the rules that govern access to the content as well as an encrypted copy of the content key. Sally can transfer this bundled file to an email USB dongle diskette etc. using standard drag and drop procedures and send it to someone else. Provided that the recipient s device can produce valid links to the Special Project Group Node access to the content is permitted and possible.

Assume that Sally gives the file to John who is also a member of the Special Projects Team. If John has a recently refreshed Link Object that identifies him as a member of the Special Projects Team he will be able to access the file. Per the company s policy this Link Object contains an expiration date that will cause it to expire in three days. Therefore even if John remains disconnected he will still have access as long as that link remains valid.

If at some later time John leaves the Special Projects Team for another job assignment and finds the USB dongle from Sally in his bag and attempts to open the file using his desktop computer the Link Object associating his User Node to the Special Projects Team will have expired. Since he is no longer part of the team the DRM plugin on his device no longer can acquire new refreshed links. Since the Special Projects Team Group Node is no longer reachable by his device access is not permitted.

Figuring that his laptop has not been connected to the network since he changed jobs he also tries to open the file with that device. Since the maximum allotted time has passed that Link is also no longer valid. In some embodiments each time he attempts to access the file a report can be generated and queued to be sent to a central repository.

The central repository receives multiple reports of unsuccessful attempts to access the file and flags a manager via email. The manager reminds John that he is no longer permitted to access the confidential material and asks for all files to be destroyed even though the system indicates that access has not been granted .

As yet another example assume that a governmental agency or outside auditor wishes to investigate or audit the Special Projects Team s handling of confidential information. To support the investigation the company wishes to demonstrate audit records for access to sensitive information related to the Special Project.

To this end the company first scans all cleartext message archives for any messages related to the Special Project. To their relief they discover that in adherence to company policy no employees sent messages discussing the Special Project without appropriate DRM protection e.g. outside of the system .

The company then uses the DRM access records to produce an audit trail detailing who was given access to protected information and when.

Per company procedure when the Special Projects Team Group was established it also included the Chief Compliance Officer CCO by default. A Link Object for Chief Compliance Officer was created and saved to the archive server which allows him or her to review the contents of all messages if needed in the future.

In this example the policy defined for the Special Projects Team indicated that all Licenses generated by the team must include the requirement to report any attempted access to the file including the date and time UserNode and whether or not access was granted. These reports were saved in an access log on a central repository.

The CCO checks the access logs for all accesses associated with the Special Projects Team prior to the date when any leak or other irregularity was suspected to have occurred. The CCO also searches the email IM and network backup archives for all message traffic and system files on or before that date. Since each file has an attached license with content key and the CCO has the necessary Link Objects to satisfy the requirements of the License he or she is permitted to access the contents of each and every message that was accessed prior to the time in question.

The access logs and unencrypted message contents are made fully available to the agency auditor as part of the investigation.

In some embodiments the policy for the Special Projects Team could also have included the requirement to set an expiration date for the all licenses related to the Special Project. For example if the company were only statutorily required to keep records of this nature for a period of 1 year they could indicate in the policy that Licenses expire one year following date of issue. In that case the company might only keep records as long as legally required to do so. Even the CCO would not have access after that time.

In the foregoing discussion reference has occasionally been made to targeting and binding . In preferred embodiments targeting and binding represent two different yet closely related processes. In preferred embodiments binding is primarily a cryptographic process concerned with protecting the key that was used to encrypt the content. When a License is bound to a Node for example the Special Projects Team Node it can mean e.g. that the content key is encrypted with the public key associated with that Node. Thus only devices that have access to the private key of the Node will have the necessary key to decrypt the content and in preferred embodiments the only way to get access to the private key of a Node is to decrypt a chain of Links to that Node however simply having the correct private key only indicates that the device has the capability to decrypt the content if it is also permitted to do so.

In preferred embodiments whether or not a device is permitted to access the content is determined by a Control Program within the License and specifically how it is targeted . Targeting refers to adding a requirement in the Control Program to specify that a particular node or nodes are reachable to perform a use of the content. In the examples shown above the Control Program typically specifies that a particular Node Special Projects Team is reachable by the consuming device.

In some instances it may be desirable to have licenses targeted to more than one Node such as a new product development team at a company Company that is working with multiple suppliers to bid on components for a new top secret product. Assume that during the early stages of the project Supplier A and Supplier B competitors both have links to SecretProjectX . Supplier A wants its ideas to be shared with all members of SecretProjectX but does not want them to inadvertently leak to Supplier B. Supplier A can target these licenses such that SecretProjectX is reachable AND Supplier A is reachable or Company is reachable . If Company inadvertently shares this information to everyone in Secret Project X including Supplier B those at supplier B will not be permitted to look at it limiting any non disclosure risk to Company and eliminating the prospect of Supplier A losing its trade secrets.

As shown in this healthcare ecosystem can be modeled using DRM objects like nodes and links such as those describe elsewhere herein. For example nodes could be assigned to the patient the patient s doctors the patient s insurance company the patient s devices a specific one of patient s doctors the doctor s computing devices the group of all doctors the group of doctors of a certain specialty a medical institution an insurance company the computing devices used by the insurance company the group of all insurance companies and the like.

Assume that the patient s doctor uses his or her PC to create a medical record regarding the patient. For example the medical record may comprise a document template with a number of fields for his or her notes diagnoses prescription instructions instructions for the patient and or the like. The template may also allow the doctor to select the security policies for governing the document and or the individual field thereof. For example the doctor s application may present a set of standard security policy choices and upon obtaining the doctor s selection may automatically generate a license based on those choices and associate with the protected e.g. encrypted content of the medical record.

For purposes of this example assume the license grants viewing access to the patient to all healthcare providers who treat the patient and to all insurance companies that provide coverage for the patient. Further assume for the sake of illustration that the license grants editing rights only to cardiologists at medical institution x.

The packaging application accepts the doctor s policy specification input which may simply comprise a mouse click on a standard template and generates a license that includes a control program such as that shown below 

The medical record and its associated license might then be stored in a central database of medical records a database operated by the particular medical foundation and or the like. If patient Y subsequently visits another healthcare provider and authorizes that healthcare provider as one of his approved healthcare providers e.g. by signing an authorization form that healthcare provider will obtain a link to the patient y approved healthcare providers node which the healthcare provider would store on his computer system. If that healthcare provider were to then obtain the medical record created by doctor x he would be able to gain viewing access to that medical record since patient y s approved healthcare provider node would be reachable from the new healthcare provider s computer system. If on the other hand an unapproved healthcare provider were to obtain a copy of the encrypted medical record he would be unable to access it since none of the required nodes i.e. patient y s node the node for all of patient y s approved healthcare providers and the node for all of patient y s approved insurance companies would be reachable from his computing system.

Note however that the example control program shown above includes an override feature that can be invoked e.g. in emergencies if for example a healthcare provider needs to access the protected medical record but is unable to satisfy the conditions of the control program e.g. because the healthcare provider attempting to make emergency access to the medical record has not previously been registered as a healthcare provider of patient Y . Note also however that invocation of the emergency access exception will cause information to be automatically recorded regarding the invocation and or other circumstances and in this example will also cause a notification to be sent e.g. to the patient s preferred healthcare provider i.e. an entity explicitly authorized by the patient and or the patient himself . The association of such obligations with the emergency exception may discourage abuse of the exception since a record of the abuse would exist.

It will be appreciated that this example program has been provided to facilitate explanation of certain embodiments of the systems and methods described herein. For example whether a system includes support for emergency exceptions will typically depend on the requirements and desires of the system architect. Thus for example some embodiments may not support emergency exceptions others may support emergency exceptions but limit the class of entities who can invoke such exceptions to the class of all doctors e.g. by requiring that the EmergencyException flag be set to true AND the All Doctors node be reachable and others still may support emergency exceptions but not associate mandatory obligations therewith since inability to comply with the obligation would in a preferred embodiment render the content inaccessible relying instead on non technical legal or institutional means for enforcement e.g. by trusting healthcare providers not to abuse the ability to invoke the exception and or relying on industry certification and the legal system to prevent abuse .

Yet another variation that could be made to the examples provided above might be to require stronger proof that a doctor or a specifically named doctor was actually the one accessing a medical record as opposed to someone else sitting at the computer that the doctor uses to access records and thus a computer potentially containing the links necessary to satisfy a reachability analysis . Such a stronger form of authentication could be enforced in any suitable manner. For example it could be wholly or partially enforced at the application or system level by protecting the doctor s computer and or the software used to access medical records using passwords dongles biometric identification mechanisms and or the like. Alternatively or in addition the control programs associated with certain medical records could themselves include an obligation or condition require such stronger identification such as checking for the presence of a dongle requiring the host to obtain a password and or the like.

When Alice downloads a piece of content to her PC and attempts to play it the DRM engine on her PC evaluates the license associated with the content which indicates that subscription node must be reachable in order to play the content. Alice had previously registered her PC with her ISP at which time she received a link from her PC node to her account node . The DRM engine thus possess link objects connecting PC node to subscription node however before granting Alice s request to play the content the DRM engine first determines whether the links are valid by executing any control programs that the links contain. When the control program in link is executed the DRM engine checks the state database entry to determine if 5 plays have already been made and if they have not grants her request to play the content but also issues an obligation to the host application. The obligation requires the host to degrade the content before rendering. The host application determines that it is able to fulfill this obligation and proceeds to render the content. In order to enable Alice to preview content before counting that content against her five free trial offer plays the control program might also include a callback that checks e.g. 20 seconds after a request to play a piece of content has been granted to see if the content is still being played. If the content is still being played the play count is decremented otherwise it is not. Thus Alice can select from any of the content items offered by the subscription service and play any five of them before her trial subscription expires.

Once Alice s trial subscription expires Alice decides to purchase a full monthly subscription which enables her to play as many content items as she wishes for a monthly fee. Alice use s her PC to sign up for the subscription and receives a link from her account node to the subscription node . The link includes a control program indicating that the link is only valid for one month e.g. the control program checks an entry in the state database to see if one month has elapsed since the link was issued . This link is sent to Alice s PC along with an agent program that is operable to initialize an appropriate entry in the state database of the PC s DRM engine indicating the date on which the link was issued. When Alice downloads a piece of content from the subscription service and attempts to play it her PC s DRM engine determines that a path to the subscription node exists comprised of links . The DRM engine executes any control programs contained in links to determine if the links are valid. If less than a month has elapsed since link was issued the control program in link will return a result indicating that link is still valid and Alice s request to play the piece of content. If Alice attempts to play a piece of content she previously obtained during her free trial period the DRM engine on her PC will perform the same analysis and grant her request. Since the license associated with the piece of content obtained during the trial period indicates that if the TrialState variable in the secure database is not set the only condition is that the subscription node must be reachable Alice can now access that content once again since the subscription node is once again reachable from Alice s PC this time via link not link which is no longer valid. Thus Alice does not need to obtain a second copy of the content item to replace the copy she obtained during the free trial offer. Similarly if Alice obtains a piece of subscription content from her friend Bob who is also a subscriber to the same service Alice will in this example be able to play that content too since the content s license simply requires that the subscription node be reachable not that it be reachable via Bob s PC or account.

It will be appreciated that the above examples are simply intended to illustrate some of the functionality that can be enabled by the systems and methods described herein and is not intended to suggest that subscriptions must be implemented in precisely the manner described above. For example in other embodiments the license associated with a piece of subscription content might be bound to a user s node rather than the subscription node thus preventing two subscribers from sharing content like Bob and Alice were able to do in the example described above. It will be appreciated that many other variations to the above examples could be made.

The table below provides some illustrative pseudo code for the agent link and license control programs in the example described above 

Referring once again to Alice also has an account with her mobile service provider which remains valid as long as she remains connected to the network. Alice is not required to make a special payment for the subscription in exchange for which she gets sent a link instead renewal links are sent to her phone automatically when she connects to the network. These links enable her to access any of the content items or services offered by the mobile service provider which have licenses that require only that the subscription node be reachable. If Alice changes mobile service providers she will unable to access previously acquired content once her links expire.

As the preceding examples illustrate embodiments of the systems and methods presented herein enable electronic content to be shared in natural ways. For example the systems and methods described herein can be used to enable consumers to share entertainment content with their friends and family members and or enjoy it on all of their family s devices while simultaneously protecting against wider unauthorized distribution. For example automated peer to peer discovery and notification services can be used such that when one device obtains content or associated rights other devices can automatically become aware of that content thereby providing a virtual distributed library that can be automatically updated. For example in one embodiment if one user obtains content or rights on a portable device at one location then comes home the user s family s devices can automatically discover and make use of those rights. Conversely if a user obtains rights on a device on his or her home network his or her portable devices can discover and carry away that content for use elsewhere. Preferred embodiments of the systems and methods described herein can be used to create services and rights objects that allow the above described scenarios to be completely automated using for example the service discovery and inspection techniques described in the 551 application. For example the devices registered to a particular domain may provide services to each other e.g. sharing of rights and content and or remote services can be invoked to facilitate local sharing of content. The systems and methods described enable the creation of DRM frameworks that are not focused on preventing the creation of copies per se but rather are designed to work harmoniously with network technology to allow content to be shared while protecting against consumers becoming illicit distributors of the content.

Preferred embodiments of the DRM systems and methods described herein also enable the determination of rights without the verbose types of rights expressions characteristic of some other DRM systems. Instead preferred embodiments use a set of crafted rights objects that can interact contextually. These objects describe relationships and controls among entities such as users devices content and groups thereof. For example such contextual interactions might allow a device to determine that a given piece of content can be played because a the content was obtained from a legitimate content service that the user currently subscribes to b the user is part of a specific family group and c the device is associated with this specific family group. There are numerous types of relationships such as those described in this example which users understand intuitively and preferred embodiments of the systems and methods described herein enable the creation of systems that naturally understand these kinds of relationships. The relationships among entities can be created destroyed and changed over time and preferred embodiments provide a natural way of determining rights in a dynamic networked environment an environment that consumers can naturally understand. Nevertheless if a content deployer wants to use a more traditional rights expression approach preferred embodiments can accommodate that as well. For example tools can be used to translate traditional rights expressions into sets of objects such as those described above and or a DRM engine can be implemented that operates directly on such rights expressions. Alternatively in some embodiments devices do not need to understand such traditional rights expressions and are not constrained by their limitations.

Preferred embodiments of the systems and methods described herein also have a very general notion of a media service. A broadcast service and an Internet download or subscription service are examples of media services. Restrictions associated with these services can make content difficult to share. With preferred embodiments of the systems and methods described herein content can be obtained on broadcast broadband and mobile services and shared on a group of networked devices in the home including portable devices. Alternatively or in addition services can be offered by individual devices in a peer to peer fashion via wireless connectivity. For example the new generation of WiFi enabled cellphones can provide content catalog services to other devices. Such a service allows other devices to see what content is available to be shared from the device. The service provides information that can be used to determine the rights so that any limitations can be accepted or easily eliminated.

Preferred embodiments of the systems and methods described herein are not confined to one service or to one platform. As explained above preferred embodiments are capable of working with numerous services including personal services. This is becoming more and more important as home and personal networks become more ubiquitous. For example digital cameras are now available with WiFi connectivity making it very convenient to share photos over networks. It is nice to be able to automate the sharing of photographs but the camera will encounter many different networks as it is carried about. Automated sharing is convenient but personal photos are of course personal. Embodiments of the systems and methods described herein make it easy to share photos within a family on the family s devices but not with arbitrary devices that happen to encounter the camera on a network. In general as more devices become networked it is going to be increasingly important to manage the rights of all content on those devices. Although the purpose of networking is to allow information on the networked devices to be shared networks will overlap and merge into one another. Networks enable content to be shared easily but it should not be shared arbitrarily. Thus it is desirable to have a DRM system that is network aware and that can use the context provided by the content the user the network and characteristics of devices to determine if and how content should be shared. Preferred embodiments of systems and methods described herein enable such an approach.

The following is a description of a reference architecture for a consuming application e.g. a media player that consumes DRM protected content and a packaging application e.g. an application residing on a server that packages content targeted to consuming applications.

The following provides an example of functions that an illustrative embodiment of a DRM engine might perform for a host application that consumes content.

Although in a preferred embodiment there is no required API for DRM engines the following are high level descriptions of the type of interface provided by an illustrative DRM engine referred to as the Octopus DRM engine to a host application in one illustrative embodiment 

Creates a session given a Host Application Context. The context object is used by the Octopus DRM engine to make callbacks into the application.

This function should be called by the host application when it encounters certain types of objects in the media files that can be identified as belonging to the DRM subsystem. Such objects include content control programs membership tokens etc. The syntax and semantics of those objects is opaque to the host application.

The host application calls this function when it needs to interact with a multimedia content file. The DRM engine returns a Content object that can be used subsequently for retrieving DRM information about the content and interacting with it.

Returns DRM metadata about the content that is otherwise not available in the regular metadata for the file.

The host application calls this function when it wants to interact with a Content object. The actionlnfo parameter specifies what type of action the application needs to perform e.g. Play as well as any associated parameters if necessary. The function returns an Action object that can then be used to perform the action and retrieve the content key.

Checks whether the DRM subsystem will authorize the performance of this action i.e whether Action Perform would succeed .

Performs the action and carries out any consequences with their side effects as specified by the rule that governs this action.

The following is an example of the type of Host Services interface needed by an illustrative embodiment of a DRM engine from an illustrative embodiment of a host application.

Returns a virtual FileSystem object that the DRM subsystem has exclusive access to. This virtual FileSystem will be used to store DRM state information. The data within this FileSystem should only be readable and writeable by the DRM subsystem.

Gives back to the host services a data object that may have been embedded inside a DRM object but that the DRM subsystem has identified as being managed by the host e.g. certificates .

Checks the validity of a digital signature over a data object. In one embodiment the signatureInfo object contains information equivalent to the information found in an XMLSig element. The Host Services are responsible for managing the keys and key certificates necessary to validate the signature.

Creates a Cipher object that the DRM subsystem can use to encrypt and decrypt data. A minimal set of cipher types will be defined and for each a format for describing the key info required by the cipher implementation.

Creates a Digester object that the DRM subsystem can use to compute a secure hash over some data. In one embodiment a minimal set of digest types can be defined.

The following provides an example of the functions that a packaging engine might perform for a host application that packages content. In practice a packaging application may focus on packaging specifically or could be part of a general purpose application operating at a user system that also accesses protected content either packaged locally or elsewhere in a network .

This section provides a high level description of an illustrative API between a host application and a packaging engine used in connection with a reference DRM engine referred to as Octopus .

Creates a session given a host application context. The context object that is returned by this function is used by the packaging engine to make callbacks into the application.

The host application calls this function in order to create a content object that will be associated with license objects in subsequent steps. Having more than one content reference in the contentReferences array implies that these are bound together in a bundle e.g. one audio and one video track and that the license issued should be targeted to these as one indivisible group.

The drmInfo parameter specifies the metadata of the license that will be issued. The drmInfo will act as a guideline to translate the license into bytecode for the virtual machine.

This function is called when the host application is ready to get the drmObjects that the packager engine created. The format parameter will indicate the format expected for these objects e.g. XML or binary atoms .

This function is called by the host packaging application when it needs keys in order to encrypt content. In one embodiment there is one key per content reference.

The following is an example of the type of interface that an illustrative packaging engine needs the host application to provide in one embodiment.

Returns a virtual FileSystem object that the DRM subsystem has exclusive access to. This virtual FileSystem can be used to store DRM state information. The data within this FileSystem should only be readable and writeable by the DRM subsystem.

Some DRM objects created by the packaging engine will have to be trusted. This service provided by the host will be used to sign a specified object.

Creates a cipher object an object that is able to encrypt and decrypt data that the packaging engine can use to encrypt and decrypt data. In one embodiment the cipher object is used to encrypt the content key data in the ContentKey object.

This section provides more information regarding the DRM objects that serve as the building blocks of an illustrative implementation of a DRM engine. First a relatively high level overview is given of the types of objects the DRM engine uses for content protection and governance. Next a more detailed description of these objects and the information they convey is provided along with some example data structures used in one illustrative embodiment.

As previously described in connection with content governance objects sometimes referred to collectively with node and link objects as DRM objects are used to associate usage rules and conditions with protected content. Together these objects form a license.

As shown in the data represented by content object is encrypted using a key. That key needed to decrypt the content is represented by ContentKey object and the binding between the content and the key used to encrypt it is represented by protector object . The rules that govern the use of the decryption key are represented by control object and the binding between the ContentKey and the control object is represented by controller object . In one embodiment trusted systems will only make use of the content decryption key under governance of the rules expressed by the byte code in control object . is a more detailed illustration of a license such as that shown in and illustrates a signature scheme that is used in one embodiment.

In one embodiment objects share common basic traits they can each have an ID a list of attributes and a list of extensions.

Objects that are referenced by other objects have a unique ID. In one embodiment IDs are simply URIs and the convention is that those URIs are URNs

Attributes are typed values. Attributes can be named or unnamed. The name of a named attribute is a simple string or URI. The value of an attribute is of a simple type string integer or byte array or a compound type list and array . Attributes of type list contain an unordered list of named attributes. Attributes of type array contain an ordered array of unnamed attributes.

Extensions are elements that can be added to objects to carry optional or mandatory extra data. Extensions are typed and have unique IDs as well. Extensions can be internal or external.

Internal extensions are contained in the object they extend. They have a critical flag that indicates whether the specific extension data type for the extension is required to be known to the implementation that uses the object. In one embodiment if an implementation encounters an object with a critical extension with a data type that it does not understand it must reject the entire object.

In one embodiment the ID of an internal extension needs to be locally unique an object cannot contain two extensions with the same ID but it is possible that two different objects each contain an extension with the same ID as that of an extension of the other object.

External extensions are not contained in the object they extend. They appear independently of the object and have a subject field that contains the ID of the object they extend. In one embodiment the ID of an external extension needs to be globally unique.

In one embodiment the content object is an external object. Its format and storage are not under the control of the DRM engine but under the content management subsystem of the host application for instance the content could be an MP4 movie file an MP3 music track etc. . In one embodiment the format for the content needs to provide support for associating an ID with the content payload data. The content payload is encrypted in a format dependent manner typically with a symmetric cipher such as AES .

The ContentKey object represents a unique encryption key and associates an ID with it. The purpose of the ID is to enable Protector objects and Controller objects to make references to ContentKey objects. The actual key data encapsulated in the ContentKey object is itself encrypted so that it can only be read by the recipients that are authorized to decrypt the content. The ContentKey object specifies which cryptosystem was used to encrypt the key data. The cryptosystem used to protect the content key data is called the Key Distribution System. Different Key Distribution Systems can be used. An example of a Key Distribution System is the Scuba Key Distribution System described above.

The Protector object contains the information that makes it possible to find out which key was used to encrypt the data of Content objects. It also contains information about which encryption algorithm was used to encrypt that data. In one embodiment the Protector object contains one or more IDs that are references to Content objects and exactly one ID that is a reference to the ContentKey object that represents the key that was used to encrypt the data. If the Protector points to more than one Content object all those Content objects represent data that has been encrypted using the same encryption algorithm and the same key. In one embodiment unless the cryptosystem used allows a safe way of using the same key for different data items it is not recommended that a Protector object point to more than one Content object.

The control object contains the information that allows the DRM engine to make decisions regarding whether certain actions on the content should be permitted when requested by the host application. In one embodiment the rules that govern the use of content keys are encoded in the control object as byte code for execution by the virtual machine. The control object also has a unique ID so that it can be referenced by a controller object. In one embodiment control objects are signed so that the DRM engine can verify that the control byte code is valid and trusted before it is used to make decisions. The validity of the control object can also optionally be derived through the verification of a secure hash contained in a controller object.

The controller object contains the information that allows the DRM engine to find out which control governs the use of one or more keys represented by ContentKey objects. The controller object contains information that binds it to the ContentKey objects and the control object that it references. In one embodiment controller objects are signed e.g. by a packager application that has a certificate allowing it to sign controller objects so that the validity of the binding between the ContentKey and the control object that governs it as well as the validity of the binding between the ContentKey ID and the actual key data can be established. The signature of the controller object can be a public key signature or a symmetric key signature or a combination of both. Also when the digest of the control object referenced by the controller object is included in the controller object the validity of the control object can he derived without having to separately verify the signature of the control object.

In one embodiment this is the preferred type of signature for controller objects and is implemented by computing a Message Authentication Code MAC of the controller object keyed with the same key as the key represented by the corresponding ContentKey object. In one embodiment the canonical method for this MAC is to use HMAC with the same hashing algorithm as the one chosen for the PKI signature algorithm used in the same deployment.

This type of signature is used when the identity of the signer of the controller object needs to be known. This type of signature is implemented with a public key signature algorithm signing with the private key of the principal who is asserting the validity of this object. In one embodiment when using this type of signature a symmetric key signature will also be present and sign both the controller object as well as the public key signature so that is can be guaranteed that the principal who signed with its private key also had knowledge of the actual value of the content key carried in the ContentKey object.

As previously described node objects represent entities in a DRM profile and no implicit or explicit semantics are used to define what the node objects represent. A given deployment DRM profile of a system will define what types of principals exist and what roles and identities different node objects represent. That semantic information is typically expressed using attributes of the node object.

Link objects represent relationships between nodes. Link objects can also optionally contain some cryptographic data that allows the link to be used for content key derivation. Just as for nodes in one embodiment no implicit or explicit semantics are used to define what a link relationship means. Depending on what the from and to nodes of the link represent in a given DRM Profile the meaning of the link relationship can express membership ownership association and or many other types of relationships. In a typical DRM profile some node objects could represent users other nodes could represent devices and other nodes could represent user groups or authorized domains ADs . In such a context links between devices and users might represent an ownership relationship and links between users and user groups or authorization domains might represent membership relationships. illustrates the structure and interrelationship between nodes and links in one example embodiment.

The node object represents an entity in the system. The node object s attributes define certain aspects of what the node object represents such as the role or identity represented by the node object in the context of a DRM profile. The node object may also have a confidentiality asymmetric key pair that is used for targeting confidential information to the subsystems that have access to the confidential parts of the node object typically the entity represented by the node or some entity that is responsible for managing that node . Confidential information targeted at a node can be encrypted with that node s confidentiality public key. The node object may also have a sharing asymmetric key pair and a sharing symmetric key can be used in conjunction with link objects when the system uses a ContentKey derivation system for ContentKey distribution such as that described elsewhere herein. In a preferred embodiment only entities that need to be referenced by link or control objects or to receive cryptographically targeted information need to have corresponding node objects.

The link object is a signed assertion that there exists a directed edge in the graph whose vertices are the node objects. For a given set of nodes and links we say that there is a path between a node X and a node Y if there exists a directed path between the node X vertex and the node Y vertex in the graph. When there is a path between node X and node Y we say that node Y is reachable from node X. The assertions represented by link objects are used to express which nodes are reachable from other nodes. The controls that govern content objects can check before they allow an action to be performed that certain nodes are reachable from the node associated with the entity performing the action. For example if node D represents a device that wants to perform the play action on a content object a control that governs the content object can test if a certain node U representing a certain user is reachable from node D. To determine if node U is reachable the DRM engine can check whether there is a set of link objects that can establish a path between node D and node U.

In one embodiment the DRM engine verifies link objects before it uses them to decide the existence of paths in the node graph. Depending on the specific features of the certificate system e.g. x509v3 used to sign link objects link objects can be given limited lifetimes be revoked etc. In one embodiment the policies that govern which keys can sign link objects which link objects can be created and the lifetime of link objects are not directly handled by the DRM engine. Instead those policies leverage the node s attribute information. To facilitate the task of enforcing certain policies in one embodiment a way to extend standard certificate formats with additional constraint checking is provided. These extensions make it possible to express validity constraints on certificates for keys that sign links such that constraints such as what type of nodes the link is connecting as well as other attributes can be checked before a link is considered valid.

In one embodiment a link object can contain a control object that will be used to constrain the validity of the link. In addition in one embodiment a link object may contain cryptographic key derivation data that provides the user with sharing keys for key distribution. That cryptographic data will contain in addition to metadata the private and or symmetric sharing keys of the from node encrypted with the sharing public key and or the sharing symmetric key of the to node.

The following paragraphs describe in more detail an illustrative object model for the objects discussed above defining the fields that each type of object has in one illustrative embodiment. Data structures are described using a relatively simple object description syntax. Each object type is defined by a class that can extend a parent class this is an is a relationship . The class descriptions are in terms of the simple abstract types string character strings int integer value byte 8 bit value and boolean true or false but do not define any specific encoding for those data types or for compound structures containing those types. The way objects are encoded or represented can vary depending on the implementation of the engine. In practice a given profile of use of the DRM engine can specify how the fields are represented e.g. using an XML schema .

In one embodiment there are four kinds of attributes IntegerAttribute StringAttribute ByteArrayAttribute and ListAttribute each having a name and a type.

In the illustrative embodiment under discussion there are two types of extensions internal extensions which are carried inside the Octobject and external extensions which are carried outside the Octobject.

In some embodiments it will be important to be able to verify the signature of an object even if a particular type of ExtensionData is not understood by a given implementation. Thus in one embodiment a level of indirection with the dataDigest field is added. If the specification of the ExtensionData mandates that the data is part of the signature within the context of a particular object then the dataDigest field will be present. An implementation that understands this ExtensionData and is therefore capable of computing its canonical representation can then verify the digest. If in such an embodiment the specification of this ExtensionData mandates that the data is not part of the signature then the dataDigest field will not be present.

In one embodiment each key has a unique id a format a usage that can be null and data. The usage field if it is not empty specifies the purpose for which the key can be used. For normal content keys this field is empty. In embodiments in which a key distribution scheme such as that described above is used this field may specify if this is a sharing key or a confidentiality key. The format field specifies the format of the data field such as for example RAW for symmetric keys or PKCS 8 for RSA private keys etc. . The data field contains the actual key data formatted according to the format field.

For keys that are part of a key pair such as RSA keys the extra field pairId gives a unique identifier for the pair so that the pair can be referenced from other data structures.

In one embodiment the data field in the key object is the plaintext value of the actual key i.e. it is the plaintext value of the key that will be hashed even though the object s actual representation contains an encrypted copy of the key.

Preferred embodiments of the DRM engine described herein use a virtual machine sometimes referred to herein as the control virtual machine the control VM or simply the VM to execute control programs that govern access to content. Illustrative embodiments of such a virtual machine are described below as are various modifications and design considerations that could e made to this illustrative embodiment. The integration of an illustrative embodiment of the virtual machine referred to as the Plankton virtual machine with an illustrative embodiment of the DRM engine referred to as Octopus is also described. It should be appreciated however that embodiments of the digital rights management engine architecture and other systems and methods described herein can be used with any suitable virtual machine or in some embodiments without a virtual machine at all and thus it will be appreciated that the details provided below regarding example embodiments of a virtual machine are for purposes of illustration and not limitation.

In a preferred embodiment the control VM is a traditional virtual machine designed to be easy to implement using various programming languages with a very small code footprint. It is based on a simple stack oriented instruction set that is designed to be minimalist without undue concern for execution speed or code density. In situations where compact code is required data compression techniques can be used to compress the virtual machine s byte code.

In preferred embodiments the control virtual machine is designed to be suitable as a target for low or high level programming languages and supports assembler C and FORTH. In addition it will be appreciated that compilers for other languages such as Java or custom languages can be created in a relatively straightforward fashion to compile code into the format e.g. byte code used by the virtual machine. In one embodiment the control virtual machine is designed to be hosted within a host environment not run directly on a processor or in silicon. In preferred embodiments the natural host environment for the virtual machine is the DRM engine although it will be appreciated that the virtual machine architecture described herein could alternatively or in addition be used in other contexts.

In preferred embodiments the VM runs programs by executing instructions stored in byte code in code modules. Some of these instructions can call functions implemented outside of the program itself by making system calls. System calls can be implemented by the VM itself or delegated to the host environment.

In one embodiment the VM executes instructions stored in code modules as a stream of byte codes loaded into memory. The VM maintains a virtual register called the Program Counter PC which is incremented as instructions are executed. The VM executes each instruction in sequence until an OP STOP instruction is encountered an OP RET instruction is encountered with an empty call stack or a runtime exception occurs. Jumps are specified either as a relative jump specified as a byte offset from the current value of PC or as an absolute address.

In one embodiment the VM uses a relatively simple memory model in which memory is separated into data memory and code memory. For example data memory can be implemented as a single flat contiguous memory space starting at address 0 and can be implemented as an array of bytes allocated within the heap memory of the host application or host environment. In one embodiment attempts to access memory outside of the allocated space will cause a runtime exception which will cause program execution to terminate.

Data memory is potentially shared between several code modules concurrently loaded by the virtual machine. The data in the data memory can be accessed by memory access instructions which in one embodiment can be either 32 bit or 8 bit accesses. 32 bit memory accesses are performed using big endian byte order. In a preferred embodiment no assumptions are made with regards to alignment between the virtual machine visible memory and the host managed memory i.e. the host CPU virtual or physical memory .

In one embodiment code memory is a flat contiguous memory space starting at address 0 and can be implemented as an array of bytes allocated within the heap memory of the host application or host environment.

The VM may support loading more than one code module. If the VM loads several code modules in one embodiment all the code modules share the same data memory although each module s data is preferably loaded at a different address but each has its own code memory thus preventing a jump instruction in one code module to cause a jump to code in another code module.

In one embodiment the VM has the notion of a data stack which represents 32 bit data cells stored in the data memory. The VM maintains a virtual register called the Stack Pointer SP . After reset the SP points to the end of the data memory and the stack grows downward when data is pushed on the data stack the SP register is decremented . The 32 bit data cells on the stack are interpreted either as 32 bit addresses or 32 bit integers depending on the instruction referencing the stack data. Addresses are unsigned integers. In one embodiment all other 32 bit integer values on the data stack are interpreted as signed integers unless otherwise specified.

In one embodiment the VM manages a call stack used for making subroutine calls. In one embodiment the values pushed on this stack cannot be read or written directly by the memory access instructions. This stack is used internally by the VM when executing OP JSR OP JSRR and OP RET instructions. For a given VM implementation the size of this return address stack can be fixed to a maximum which will allow only a certain number of nested calls.

In one embodiment the VM reserves a small address space at the beginning of data memory to map pseudo registers. In one embodiment the addresses of these pseudo registers are fixed. For example the following registers could be defined 

Before executing a code routine in one embodiment the virtual machine implementation resets the data stack pointer to point to the top of the initialized data stack. The initialized data stack contains the routine s input data and extends to the end of the data memory. The initialized data stack may be used as a way to pass input arguments to a routine. When there is no initialized data stack the data stack pointer points to the end of the data memory. In one embodiment the initial call stack is either empty or contains a single terminal return address pointing to an OP STOP instruction which will force execution of the routine to end on an OP STOP instruction in case the routine finished with an OP RET instruction.

When execution stops either because a final OP RET instruction with an empty call stack has been executed or a final OP STOP instruction has been executed any data left on the data stack is considered to be the output of the routine.

In one embodiment any of the following conditions is considered to be a runtime exception which causes execution to stop immediately 

In one embodiment the control VM uses a relatively simple instruction set. Though limited the number of instructions is sufficient to express programs of arbitrary complexity. Instructions and their operands are represented by a stream of byte codes. In one embodiment the instruction set is stack based and except for the OP PUSH instruction none of the instructions have direct operands. Operands are read from the data stack and results pushed on the data stack. In one embodiment the VM is a 32 bit VM all the instructions operate on 32 bit stack operands representing either memory addresses or signed integers. Signed integers are represented with 2s complement binary encoding. An illustrative embodiment of an instruction set for use with the control VM is shown in the following table. In the table the stack operands for instructions with two operands are listed as A B where the operand on the top of the stack is listed last i.e. B . Unless otherwise specified the term push as used in the following description of one illustrative embodiment refers to pushing a 32 bit value onto the top of the data stack.

In a preferred embodiment code modules are stored in an atom based format similar or identical to that used for the MPEG 4 file format in which atoms contain a 32 bit size e.g. represented by 4 bytes in big endian byte order followed by a 4 byte type e.g. bytes that correspond to ASCII values of letters of the alphabet followed by a payload e.g. 8 bytes .

As shown in pkDS atom contains a memory image of a data segment that can be loaded into data memory. As shown in in one embodiment memory image is represented by a sequence of bytes consisting of one header byte followed by zero or more data bytes . Header byte encodes a version number that identifies the format of the bytes that follow .

In one embodiment only one version number is defined i.e. DataSegmentFormatVersion 0 and in this format the data bytes of the memory image represent a raw image to be loaded into memory. The virtual machine loader only loads the data bytes of the memory image not including the header byte . In one embodiment the virtual machine loader is operable to refuse to load an image in any other format.

As shown in pkCS atom contains a memory image of a code segment that can be loaded into code memory. As shown in in one embodiment memory image is represented by a sequence of bytes consisting of one header byte followed by zero or more data bytes . Header byte encodes a version number that identifies the format of the bytes that follow .

In one embodiment only one version number is defined i.e. CodeSegmentFormatVersion 0 and as shown in in this version the byte following header byte contains another header byte containing a version number that identifies the byte code encoding of the following bytes . In the example shown in header byte identifies ByteCodeVersion 0 which specifies that data bytes contain a raw byte sequence with byte code values such as those defined in the example instruction set that is set forth above. In a preferred embodiment the virtual machine loader only loads the byte code portion of the data bytes not the two header bytes .

Referring once again to the pkEX atom contains a list of export entries. In the example shown in the first four bytes of pkEX atom encode a 32 bit unsigned integer in big endian byte order equal to the number of entries that follow. As shown in each following export entry consists of a name encoded as one byte containing the name size S followed by S bytes containing the ASCII characters of the name including a terminating zero followed by a 32 bit unsigned integer in big endian byte order representing the byte offset of the named entry point measured from the start of the byte code data stored in the 31CS atom. shows an example of an export table entry for the entry point MAIN at offset in which the first byte indicates that the size of the name i.e. MAIN plus the terminating zero is five bytes and in which the last four bytes indicate that the byte offset is 64.

As shown in pkRQ atom contains requirements that need to be met by the virtual machine implementation in order to execute the code in the code module. In one embodiment this atom is optional and if it is not present the virtual machine uses default implementation settings such as may be defined by an implementation profile.

In one embodiment the pkRQ atom consists of an array of 32 bit unsigned integer values one for each field 

The virtual machine is responsible for loading code modules. When a code module is loaded the Data Segment memory image encoded in the pkDS atom is loaded at a memory address in the Data Memory. That address is chosen by the VM loader and is stored in the DS pseudo register when the code executes.

The Code Segment memory image encoded in the pkCS atom is loaded at a memory address in the Code Memory. That address is chosen by the VM loader and is stored in the CS pseudo register when the code executes.

When a code module is loaded the special routine named Global.OnLoad is executed if this routine is found in the entries of the Export table. This routine takes no argument on the stack and returns an integer status upon return 0 signifying success and a negative error code signifying an error condition.

When a code module is unloaded or when the virtual machine that has loaded the module is disposed of the special routine named Global.OnUnload is executed if it is found in the Export table. This routine takes no argument on the stack and returns an integer status upon return 0 signifying success and a negative error code signifying an error condition.

The virtual machine s programs can call functions implemented outside of their code module s Code Segment. This is done through the use of the OP CALL instruction which takes an integer stack operand specifying the System Call Number to call. Depending on the System Call the implementation can be a byte code routine in a different code module for instance a library of utility functions executed directly by the VM in the VM s native implementation format or delegated to an external software module such as the VM s host environment.

In one embodiment if an OP CALL instruction is executed with an operand that contains a number that does not correspond to any System Call the VM behaves as if the SYS NOP system call was called.

In the illustrative embodiment under discussion System Call Numbers 0 to 1023 are reserved for fixed System Calls these System Calls will have the same number on all VM implementations . System Call Numbers 1024 to 16383 are available for the VM to assign dynamically for example the System Call Numbers returned by System.FindSystemCallByName can be allocated dynamically by the VM and do not have to be the same numbers on all VM implementations .

In one embodiment a few standard system calls are supported that are useful for writing control programs. These calls include the fixed number system calls listed in the table above as well as system calls that have dynamically determined numbers i.e. their system call number is retrieved by calling the System.FindSystemCallByName system call with their name passed as the argument .

In one embodiment the system calls specified in this section that can return a negative error code may return error codes with any negative value. Section 8.4.4 defines specific illustrative values. In one embodiment if negative error code values are returned that are not predefined they are interpreted as if they were the generic error code value FAILURE.

This call takes no inputs and returns no outputs and simply returns without doing anything. It is used primarily for testing the VM.

This call takes as its input from the top of the stack the address of a memory location containing a null terminated string and returns no output. A call to this function causes the string of text to be printed to a debug output which can be useful in debugging. If the VM implementation does not include a facility to output debug text such as might be the case in a non development environment the VM may ignore the call and treat it as if System.NoOperation had been called.

This call finds the number of a system call given its name. The call takes as its input from the top of the stack the address of a null terminated ASCII string containing the name of the system call for which to look and returns to the top of the stack the system call number if a system call with the specified name is implemented an ERROR NO SUCH ITEM if the system call is not implemented and a negative error code if an error occurs.

This call takes no inputs and returns to the top of the stack the current value of the local time of the host which in one embodiment is expressed as a 32 bit signed integer equal to the number of minutes elapsed since Jan. 1 1970 00 00 00 or a negative error code.

This call takes no inputs and returns to the top of the stack the current time offset from UTC time of the host which in one embodiment is expressed as a 32 bit signed integer number equal to the number of minutes difference between local time and UTC time i.e. LocalTime UTC .

This call takes no inputs and returns to the top of the stack the trusted time and the value of one or more flags. In one embodiment the trusted time is the current value of the trusted time clock if the system includes such a trusted clock or a negative error code if the trusted time is not available. In one embodiment the value of trusted time is expressed as a 32 bit signed integer equal to the number of minutes elapsed since Jan. 1 1970 00 00 00 UTC or a negative error code. In one embodiment the flags are the bit set of flags that further define the current state of the trusted clock. In one embodiment if an error has occurred e.g. the value of TrustedTime is a negative error code the value returned for the flags is 0.

This system call is relevant on systems that implement a trusted clock that can be synchronized with a trusted time source and maintain a monotonic time counter. The value of the trusted time is not guaranteed to always be accurate but in one embodiment the following properties are required to be true 

Therefore in this example embodiment the value of TrustedTime is between the value of the last synchronized time synchronized with a trusted time source and the current real time. If the system is able to determine that its trusted clock has been operating and updating continuously and normally without interruption since the last synchronization with a trusted time source it can determine that the value of TrustedTime is not an estimate but an accurate value and set the TIME IS ESTIMATE flag to 0.

In one embodiment if the trusted clock detects that a hardware or software failure condition has occurred and it is unable to return even an estimate of the trusted time an error code is returned and the value of the returned flags is set to 0.

This system call is a generic interface that allows a program to access objects provided by the virtual machine s host. The System.Host.GetObject call takes the following inputs listed from the top of the stack downwards Parent Name ReturnBuffer and ReturnBuffer Size. Where Parent is the 32 bit handle of the parent container Name is the address of a null terminated string containing the path to the requested object relative to the parent container ReturnBuffer is the address of a memory buffer where the value of the object is to be stored and ReturnBufferSize is a 32 bit integer indicating the size in bytes of the memory buffer in which the value of the object is to be stored.

The System.Host.GetObject call produces the following outputs listed from the top of the stack downwards TypeID Size. Where TypeId is the object type id or a negative error code if the call failed. If the requested object does not exist the error returned is ERROR NO SUCH ITEM. If the buffer supplied for the return value is too small the error returned is ERROR INSUFFICIENT SPACE. If the part of the object tree that is being accessed is access controlled and the calling program does not have the permission to access the object ERROR PERMISSION DENIED is returned. Other error codes may be returned. Size is a 32 bit integer indicating the size in bytes of the data returned in the buffer supplied by the caller or the size required if the caller provided a buffer that was too small.

In one embodiment the value of a byte array object is an array of 8 bit bytes the value of a string object is a null terminated character string incoded in UTF 8 and the value of an integer object is a 32 bit signed integer value. Containers are generic containers that contain a sequence of any number of objects of any combination of types. Objects contained in a container are called the children of that container. The value of a container is a 32 bit container handle that is unique within a given VM instance. In one embodiment the root container has the fixed handle value 0.

In one embodiment the namespace for host objects is hierarchical where the name of a container s child object is constructed by appending the name of the child to the name of the parent container separated by a character. String and integer objects do not have children. For example if a container is named Node Attributes and has a string child named Type then Node Attributes Type refers to the child string.

The root of the namespace is T. All absolute names start with a I . Names that do not start with a are relative names. Relative names are relative to a parent container. For example the name Attributes Type relative to parent Node is the object with the absolute name Node Attributes Type .

In one embodiment container objects can also have real and virtual child objects that be accessed by using virtual names. Virtual names are names that are not attached to host objects but a convention to identify either unnamed child objects child objects with a different name or virtual child objects child objects that are not real children of the container but created dynamically when requested .

For containers the following virtual names are defined as virtual child object names in one embodiment 

In this example calling System.Host.GetObject parent 0 name Node returns a type ID of 0 i.e. container and causes the handle value of 1 to be written in the buffer supplied by the caller. The size of the value is 4 bytes.

Calling System. Host. GetObject parent 0 name Node Attributes Domain returns a type ID of 2 i.e. string and causes the string TopLevel to be written in the buffer supplied by the caller. The size of the value is 9 bytes.

Calling System.Host.GetObject parent 1 name Attributes 1 returns a type ID of 1 i.e. integer and causes the integer to be written in the buffer supplied by the called. The size of the value is 4 bytes.

This system call is a generic interface that allows a program to create write and destroy objects provided by the virtual machine s host. The description of the object names and types is the same as for the System.Host.GetObject call described above. Not all host objects support being written to or destroyed and not all containers support having child objects created. When a SetObject call is made for an object that does not support the operation ERROR PERMISSION DENIED is returned.

The System.Host.SetObject system call takes as input the following parameters listed from the top of the stack downwards 

Name address of a null terminated string containing the path to the object relative to the parent container.

ObjectAddress address of a memory buffer where the value of the object is stored. If the address is 0 the call is interpreted as a request to destroy the object. The data at the address depends on the type of the object.

ObjectSize 32 bit integer indicating size in bytes of the memory buffer where the value of the object is stored. In the illustrative embodiment under discussion the size is set to 4 for integer objects and to the size of the memory buffer including the null terminator for string objects. For byte array objects the size is the number of bytes in the array.

The System.Host.SetObject system call returns a ResultCode to the top of the stack as an output. The ResultCode is 0 if the call succeeded and a negative error code if the call failed. If the call is a request to destroy an object and the requested object does not exist or the call is a request to create or write an object and the object s parent does not exist the error code returned is ERROR NO SUCH ITEM. If the part of the object tree that is being accessed is access controlled and the calling program does not have the permission to access the object ERROR PERMISSION DENIED is returned. Other error codes may also be returned.

There is a special case when the object refers to a container and the ObjectAddress is not 0. In this case the ObjectSize parameter is set to 0 and the value of ObjectAddress is ignored. If the container already exists nothing is done and a SUCCESS ResultCode is returned. If the container does not exist and the parent of the container is writeable an empty container is created.

This system call is used by control programs to check whether a given node is reachable from the node associated with the entity hosting this instance of the virtual machine. The call takes as its input a NodeId from the top of the stack where the NodeId is a null terminated string containing the ID of the target node to be tested for reachability. As output the call returns a ResultCode and a StatusBlockPointer to the top of the stack. The ResultCode is an integer value that is 0 if the node is reachable or a negative error code if it is not. The StatusBlockPointer is the address of a standard ExtendedStatusBlock or 0 if no status block is returned.

This system call is used by control programs to request that a new instance of a virtual machine be created and a new code module loaded. In one embodiment the host of the newly created virtual machine exposes the same host objects as the ones exposed to the caller except the host object Octopus Runtime Parent Id is set to the identity of the caller. In one embodiment this host object is a container. The children of this container are objects of type string each with a value representing a name. In one embodiment the semantics and specific details of those names are specified by the specification of the virtual machine s host.

In one embodiment when the virtual machine that is running the code for the caller terminates any spawned virtual machine that has not been explicitly released by calling System.Host.ReleaseVm is automatically released by the system as if System.Host.ReleaseVm had been called.

The System.Host.SpawnVm call takes as its input a ModuleId from the top of the stack. The ModuleId identifies the code module to be loaded into the new virtual machine instance. In one embodiment the specification of the virtual machine s host describes the mechanism by which the actual code module corresponding to this module ID is to be located.

The System.Host.SpawnVm call returns a ResultCode and a VmHandle to the top of the stack. The ResultCode is an integer value that is 0 if the call was successful and a negative error code if it failed. The VmHandle is an integer value identifying the instance of the virtual machine that has been created. If the call fails this handle is set to 0. In one embodiment this handle is only guaranteed to be unique within the virtual machine in which this call is made.

This system call is used by control programs to call routines that are implemented in code modules loaded in virtual machine instances created using the System.Host.SpawnVm system call. This system call takes the following input from the top of the stack 

VmHandle an integer value representing the handle of a virtual machine that was created by calling System.Host.SpawnVm.

EntryPoint the address of a null terminated string that specifies the name of the entry point to call. This name needs to match one of the entry points in the Export Table of the code module that was loaded into the virtual machine instance that corresponds to the VmHandle parameter.

ParameterBlockAddress the address of a memory block that contains data to be passed to the callee. If no parameters are passed to the callee this address is set to 0.

ParameterBlockSize the size in bytes of the memory block at address ParameterBlockAddress or 0 if ParameterBlockAddress is 0.

ReturnBufferAddress the address of a memory buffer where the caller can receive data from the callee. If the caller does not expect any data back from the callee this address is set to 0.

ReturnBufferSize the size in bytes of the memory buffer at address ReturnBufferAddress or 0 if ReturnBufferAddress is 0.

SystemResultCode an integer value that is 0 if the call was successful or a negative error code if it failed. This value is determined by the system not by the callee. Success only indicates that the system was able to successfully find the routine to call execute the routine and get the return value from the routine. The return value from the routine itself is returned in the CalleeResultCode value.

ReturnBlockSize the size in bytes of the data returned in the buffer supplied by the caller or the size required if the caller provided a buffer that was too small. If no data was returned by the callee the value is 0.

In the illustrative embodiment under discussion the called routine complies with the following interface conventions When the routine is called the top of the stack contains the value ParameterBlockSize supplied by the caller indicating the size of the parameter block followed by ParameterBlockSize bytes of data. If the size is not a multiple of 4 the data on the stack will be padded with zeros to ensure that the stack pointer remains a multiple of 4. Upon return the called routine provides the following return values on the stack 

ReturnBlockAddress the address of a memory block that contains data to be returned to the caller. If no data is returned this address is set to 0.

ReturnBlockSize size in bytes of the memory block at address ReturnBlockAddress or 0 if ReturnBlockAddress is 0.

This system call is used by control programs to release a virtual machine that was spawned by a previous call to System.Host.SpawnVm. Any virtual machines spawned by the released virtual machine are released and so on recursively. The System.Host.ReleaseVm call takes as its input a VmHandle from the top of the stack the VmHandle representing the handle of a virtual machine that was created by calling System.Host.SpawnVm. The System.Host.ReleaseVm call returns a ResultCode to the top of the stack as an output. The ResultCode is an integer value that is 0 if the call was successful or a negative error code if it failed.

Size 32 bit unsigned integer equal to the size in bytes of the characters field that follows. If this value is 0 the characters field is left empty i.e. nothing follows .

Size 32 bit unsigned integer equal to the size in bytes of the data field that follows. If this value is 0 the data field is left empty i.e. nothing follows the size field in the ValueBlock .

Data array of 8 bit bytes representing a value. The actual bytes depend on the data encoding specified by the type field.

ValueCount 32 bit unsigned integer equal to the number of ValueBlock structures that follow. If this value is 0 no ValueBlocks follow.

The standard ExtendedStatusBlock is a data structure typically used to convey extended information as a return status from a call to a routine or a system call. It is a generic data structure that can be used in a variety of contexts with a range of different possible values for its fields. In one embodiment an ExtendedStatusBlock is defined as follows 

GlobalFlags boolean flags whose semantics are the same regardless of the category field. The position and meaning of the flags are defined by profiles that use standard ExtendedStatusBlock data structures.

Category Unique integer identifier of a category to which this status belongs. The category identifier values are defined by profiles that use standard ExtendedStatusBlock data structures.

SubCategory Integer identifier unique within the category of a sub category that further classifies the type of status described by this block.

LocalFlags Boolean flags whose semantics are local to the category and subcategory of this status block. The position and meaning of the flags are defined by profiles that define and use the semantics of the category.

CacheDuration Indicates the duration for which this status can be cached i.e remains valid . See the definition of the CacheDurationBlock type below for how the actual value of the duration is defined.

Parameters List of zero or more ValueBlocks. Each ValueBlock contains a parameter encoded as a value of type Parameter or ExtendedParameter. Each parameter binds a name to a typed value and is used to encode flexible variable data that describes the status block in more detail than just the category sub category cache duration and flags.

Type Integer identifier for the type of the value. In one embodiment the following types are defined 

Standard result codes are used in various APIs. Other result codes may be defined for use in more specific APIs.

This section describes an example syntax for use in compiling programs into the bytecode format described elsewhere herein. It should be appreciated that this is just one example of one possible syntax and that any suitable syntax could be used. As previously indicated it should also be understood that the bytecode format presented herein is also just an example and the systems and methods described herein could be used with any other suitable byte code format or other code format.

An assembler reads source files containing code data and processing instructions and produces binary code modules that can be loaded by a control virtual machine. In one illustrative embodiment the assembler processes a source file sequentially line by line. Lines can be zero or more characters followed by a newline. Each line can be one of an empty line whitespace only a segment directive a data directive an assembler directive a code instruction a label or an export directive. In addition each line can end with a comment which starts with a character and continues until the end of the line.

Data and instructions read from the source files have an implicit destination segment i.e. where they end up when loaded by the VM . At any point during the parsing process the assembler will have a current segment which is the implicit destination segment for data and instructions. The current segment can be changed using segment directives.

Segment directives change the current segment of the parser. In one embodiment the supported segment directives are .code and .data. The .code segment holds the byte code instructions and the .data segment holds global variables.

Data directives specify data e.g. integers and strings that will be loaded in the virtual machine s data segment. In one embodiment the supported data directives are 

In one embodiment the supported assembler directives are .equ which sets the symbol to be equal to the value . Symbols are typically used as operands or code instructions.

Labels are symbols that point to locations within segments. Labels pointing to instructions in the code segment are typically used for jump branch instructions. Labels pointing to data in the data segment are typically used to refer to variables. In one embodiment the syntax for a label is 

Note that there is nothing after the except an optional comment. A label points to the location of the next data or instruction. In one embodiment it is ok to have more than one label pointing to the same address.

Export directives are used to create entries in the export section of the code module produced by the assembler. Each entry in the export section is a name address pair. In the illustrative embodiment under discussion only addresses within the code segment can be specified in the export section.

The syntax of the export directive is .export which will export the address pointed to by with the name .

When compiling data destined for the code segment the assembler reads instructions that map directly or indirectly into byte codes. In the example instruction set shown above most virtual machine byte codes have no direct operands and appear with a simple mnemonic on a single line. To make the assembler syntax more readable some instructions accept pseudo operands which look as if they were byte code operands but are not really in this case the assembler generates one or more byte code instructions to produce the same effect as if the instruction did have a direct operand. For example the branch instructions use pseudo operands.

Branch instructions can be specified verbatim without any operand or with an optional operand that will be converted by the assembler into a corresponding byte code sequence. The optional operand is an integer constant or a symbol. When the operand is a symbol the assembler computes the correct integer relative offset so that the branch ends up at the address corresponding to the symbol.

In one embodiment the PUSH instruction always takes one operand. The operand can be one of an integer constant a symbol or the prefix directly followed by a label name. When the operand is a symbol the value that is pushed is the direct value of that symbol whether the symbol is a label or an .equ symbol the value is not incremented by a segment offset . When the operand is a label name prefixed with the value pushed depends on what the label points to. The value pushed on the stack is the absolute address represented by the label i.e. the local label value added to the segment offset .

In one embodiment the assembler is a command line tool that can be invoked with the following syntax PktAssembler options where the options can be cs int ds int xml id or h where cs int is a Code Segment Address Value default 8 ds int is a Data Segment Address Value default 4 xml id is used to output a control object as an XML file with the specified ID and h is used to display help information.

This section describes illustrative embodiments of control objects. Control objects can be used to represent rules that govern access to content by granting or denying the use of the ContentKey objects they control. They can also be used to represent constraints on the validity of a link object in which they are embedded. They can also be used as standalone program containers that are run on behalf of another entity such as in agents or delegates. In one embodiment controls contain metadata and byte code programs which implement a specific interaction protocol. The purpose of a Control Protocol is to specify the interaction between the DRM engine and a control program or between a host application and a control program through the DRM engine. This section also describes illustrative actions the application can perform on the content which action parameters should be supplied to the control program and how the control program encodes the return status indicating that the requested action can or cannot be performed as well as parameters that can further describe the return status.

In one embodiment a control object contains a control program. The control program includes a code module containing byte code that is executable by a virtual machine and a list of named routines e.g. entries in the export table .

In one embodiment the set of routines that represent the rules that govern the performance of a certain operation such as play on a content item is called an action control . The set of routines that represent validity constraints on a link object is called a link constraint . The set of routines that are intended to be executed on behalf of a remote entity such as during a protocol session with a DRM engine running on a different host is called an agent . The set of routines that are intended to be executed on behalf of another control such as when a control program uses the System.Host.CallVm system call is called a delegate .

In one embodiment control programs are executed by a virtual machine running in a host environment. The host environment can be implemented in any suitable manner however for ease of explanation and for purposes of illustration it will be assumed in the following discussion that the implementation of the virtual machine s host environment can be logically separated into two parts a host application and a DRM engine. It will be appreciated however that other embodiments may have a different logical separation of functions which may be equivalent to the logical structure described above.

As was shown in in preferred embodiments the DRM engine is the logical interface between the host application and control programs . The host application makes logical requests to the engine such as requesting access to a content key for a certain purpose e.g. to play or render a content stream . In one embodiment the engine ensures that the interaction protocol described below is implemented correctly such as by ensuring that any guarantees regarding a control program s initialization call sequence and other interaction details are met.

When the host application requests the use of content keys for a set of content IDs the DRM engine determines which Control object to use. The Protector objects allow the engine to resolve which ContentKey objects need to be accessed for the requested content IDs. The engine then finds the Controller object that references those ContentKey objects. In one embodiment a Controller object can reference more than one ContentKey object. This allows multiple ContentKey objects to be governed by the same Control object. When the host application requests access to a content key by invoking an action it can request content IDs as a group to the extent that the ContentKey objects that correspond to them are referenced by the same Controller object. In one embodiment a request to access a group of content keys referenced by more than one controller object is not allowed.

In one embodiment the DRM engine follows a convention for mapping actions to routine names. For example in one embodiment for each of the routines described below the name that appears in the Export Table entry in the code module is the respective string shown below in Sections 9.1.4 9.1.7.

In one embodiment before the engine can make calls to control routines it needs to load the control s code module into the virtual machine. In one embodiment only one code module per VM is loaded.

In one embodiment the engine ensures that calls to routines within control programs are atomic with respect to the resources it makes available to the routine such as the object or state database. Thus in such an embodiment the engine needs to ensure that those resources remain unmodified during the execution of any of the routines it calls. This may be done by effectively locking those resources during a routine call or by preventing multiple VMs to run concurrently. However the engine need not guarantee that those resources are unmodified across successive routine invocations.

In one embodiment the routine naming the input output interface and the data structures for each routine in a code module together constitute a Control Protocol. The protocol implemented by a code module is signaled in the Control object s protocol field. The illustrative Control Protocol described below will be called the Standard Control Protocol and its identifier the value of the protocol field is http www.octopus drm.com specs scp 1 0 .

In one embodiment before the DRM engine loads a code module and calls routines in the control program it needs to guarantee that the interaction with the control program will be consistent with the specification for the specific protocol id signaled in the protocol field. That includes any guarantee about the features of the virtual machine that need to be implemented guarantees about the size of the address space available to the control program and the like.

It is possible for control protocols such as the Standard Control Protocol to evolve over time without having to create a new protocol specification. As long as the changes made to the protocol are consistent with previous revisions of the specification and as long as existing implementations of the DRM engine as well as existing control programs that comply with that protocol continue to perform according to the specification then the changes are deemed compatible. Such changes may include for instance new action types.

In the illustrative embodiment described above involving the Standard Control Protocol the type of the byte code module is Plankton byte code module version 1.0 . In this example embodiment the value for the type field of the Control object is http www.octopus drm.com specs pkcm 1 0 .

General routines are routines that are applicable to the control as a whole and are not specific to a given action or link constraint. The following general control routines are used in one illustrative embodiment 

This routine is optional i.e. it is not required in all controls . If this routine is used the engine calls it once before any other control routine is called. The routine has no inputs and returns a ResultCode to the top of the stack as an output. The ResultCode is 0 on success or a negative error code on failure. In one embodiment if the ResultCode is not 0 the engine aborts the current control operation and does not make any further calls to routines for this control.

This routine is optional. The routine is called when the application requests a description of the meaning of the rules represented by the control program in general i.e. not for a specific action . The routine has no inputs and returns a ResultCode and a StatusBlockPointer to the top of the stack as outputs where the ResultCode is an integer value 0 if the routine completed successfully or a negative error code otherwise and where the StatusBlockPointer is the address of a standard ExtendedStatusBlock. The ExtendedStatusBlock contains information that an application can interpret and use to provide information to the user regarding the meaning of the rules represented by the control program.

This routine is optional. If this routine exists the DRM engine calls it once after it no longer needs to call any other routine for the control. No other routine will be called for the control unless a new use of the control is initiated in which case the Control.Init routine will be called again . The routine has no inputs and returns a ResultCode to the top of the stack as an output. The ResultCode is 0 on success or a negative error code on failure.

Each possible action has a name e.g. play transfer export etc. . In one illustrative embodiment for a given action the following routine names are defined where denotes the actual name of the action e.g. play transfer export etc. 

This routine is optional. If it exists the engine calls it once before any other routine is called for this action. The routine has no inputs and returns a ResultCode to the top of the stack as an output. The ResultCode is 0 on success or a negative error code on failure. In one embodiment if ResultCode is not 0 the engine aborts the current action and does not make any further calls to routines for this action in this control.

In the illustrate embodiment being discussed this routine is required and is called to check without actually performing a given action what the return status would be if the Perform routine were to be called for that action. It is important for this routine not to have any side effects. Note that if the Perform routine also has no side effects the Check and Perform entries in the control s Entries Table can point to the same routine. This routine has the same inputs and outputs as the Perform routine described below.

In one embodiment this routine is required and is called when the application is about to perform the action. The routine has no inputs and returns a ResultCode and a StatusBlockPointer to the top of the stack as outputs where the ResultCode is an integer value 0 if the routine completed successfully or a negative error code otherwise and where the StatusBlockPointer is the address of a standard ExtendedStatusBlock. Note that in one embodiment a success ResultCode i.e. 0 does not mean that the request was granted. It only means that the routine was able to run without error. It is the ExtendedStatusBlock that indicates whether the request was granted or denied. However if the ResultCode indicates a failure the host application proceeds as if the request was denied. For example in one embodiment the StatusBlock s category should be ACTION DENIED or the returned ExtendedStatusBlock is rejected and the host application aborts the action.

When an action is performed only the Perform routine needs to be called. The engine does not need to call the Check routine beforehand. An implementation of the Perform routine can call the Check routine internally if it chooses to do so but should not assume that the system will have called the Check routine beforehand.

This routine is optional and is called when an application requests a description of the meaning of the rules and conditions represented by the control program for the given action. The routine has no inputs and returns a ResultCode and a StatusBlockPointer to the top of the stack as outputs where the ResultCode is an integer value 0 if the routine completed successfully or a negative error code otherwise and where the StatusBlockPointer is the address of a standard ExtendedStatusBlock.

This routine is optional. If it exists it is called once after the DRM engine no longer needs to call any other routines for the given action. No other routine are called for the given action unless a new use of the action is initiated in which case the Init routine will be called again . The routine has no inputs and returns a ResultCode to the top of the stack as an output. The ResultCode is 0 on success and a negative error code on failure. If the ResultCode is not 0 the engine does not make any further calls to routines for the given action

In one embodiment when a link object has an embedded control the DRM engine calls the link constraint routines in that control to verify the validity of the link object. The following link constraint routines are used in one illustrative embodiment 

This routine is optional and if it exists is called exactly once before any other routine is called for the given link constraint. The routine has no inputs and returns a ResultCode to the top of the stack as an output. The ResultCode is 0 on success and a negative error code on failure. If the ResultCode is not 0 the engine deems the validity constraint for the link object to be unsatisfied and avoids making further calls to routines for the link control.

In the illustrative embodiment being discussed this routine is required and is called to check if the validity constraint for a given link is satisfied. The routine has no inputs and returns a ResultCode and a StatusBlockPointer to the top of the stack as outputs where the ResultCode is an integer value 0 if the routine completed successfully or a negative error code otherwise and where the StatusBlockPointer is the address of a standard ExtendedStatusBlock. If the ResultCode is not 0 the engine deems the validity constraint for the link object to be unsatisfied and avoids making further calls to routines for the link control. Even if the ResultCode is 0 success this does not mean that the constraint has been satisfied it only means that the routine was able to run without error. It is the StatusBlock that indicates whether the constraint is satisfied or not.

This routine is optional and is called when the application requests a description of the meaning of the constraint represented by the control program for a given link. The routine has no inputs and returns a ResultCode and a StatusBlockPointer to the top of the stack as outputs where the ResultCode is an integer value 0 if the routine completed successfully or a negative error code otherwise and where the StatusBlockPointer is the address of a standard ExtendedStatusBlock.

This routine is optional and if it exists is called by the engine once after the engine no longer needs to call any other routine for the given constraint. The routine has no inputs and returns a ResultCode to the top of the stack as an output. The ResultCode is 0 on success and a negative error code on failure. In the embodiment being discussed after calling this routine no other routine can be called for the given constraint unless a new cycle is initiated in which case the Init routine is called again . Similarly if the ResultCode is not 0 the engine does not make further calls to routines for the given link constraint.

In one embodiment an agent is a control object that is designed to run on behalf of an entity. Agents are typically used in the context of a service interaction between two endpoints where one endpoint needs to execute some virtual machine code within the context of the second endpoint and possibly obtain the result of that execution. In one embodiment a control can contain multiple agents and each agent can contain any number of routines that can be executed however in practice agents typically have a single routine.

In one illustrative embodiment the following entry points are defined for agents where is a name string that refers to the actual name of an agent.

This routine is optional and if it exists the engine calls it once before any other routine is called for the given agent. The routine has no inputs and returns a ResultCode to the top of the stack as an output. The ResultCode is 0 on success and a negative error code on failure.

In the illustrative embodiment under discussion this routine is required and is the main routine of the agent. The routine has no inputs and returns a ResultCode a ReturnBlockAddress and a ReturnBlockSize to the top of the stack as outputs. The ResultCode is an integer value 0 if the routine completed successfully or a negative error code otherwise the ReturnBlockAddress is the address of a block of memory that contains data that the agent code is expected to return to the caller if the routine does not need to return anything the address is 0 and the ReturnBlockSize is the size in bytes of the block of memory at the ReturnBlockAddress. In one embodiment if ReturnBlockAddress is 0 the value of ReturnBlockSize is also 0.

This routine is optional and is called when an application request a description of a given agent. The routine has no inputs and returns a ResultCode and a StatusBlockPointer to the top of the stack as outputs where the ResultCode is an integer value 0 if the routine completed successfully or a negative error code otherwise and where the StatusBlockPointer is the address of a standard ExtendedStatusBlock.

This routine is optional and if it exists the engine calls it once after the engine no longer needs to call any other routines for this agent. No other routine will be called for this agent unless a new cycle is initiated in which case the Init routine will be called again . The routine has no inputs and returns a ResultCode to the top of the stack as an output. The ResultCode is 0 on success and a negative error code on failure.

The following example definitions are applicable to the ExtendedStatusBlock data structures returned by illustrative embodiments of several of the routines described above. Examples of ExtendedStatusBlock data structures are described in connection with the description of the virtual machine.

In one embodiment there are no global ExtendedStatusBlock flags. In this embodiment control programs set the GlobalFlag field of the ExtendedStatuBlock to 0.

The following paragraphs define values for the Category field of ExtendedStatusBlocks in accordance with one embodiment. In one embodiment none of these categories have sub categories and thus the value of the SubCategory field of the ExtendedStatusBlocks is set to 0.

In one embodiment in the context of ExtendedStatusBlock parameters returned by action routines a constraint means a condition that is required to be true or a criterion that is required to be met in order for the result of the routine to return an ExtendedStatusBlock with the category ACTION GRANTED.

In the table shown above the parameter list that is referred to is the Parameters field of the ExtendedStatusBlock data structure.

In one embodiment no category codes are defined for Describe routines. In one embodiment the same local flags as the ones defined for Action routines apply to Describe routines and Describe routines should include in their retuned ExtendedStatusBlock a parameter named Description as specified below. In one embodiment Describe routines do not contain in their retuned ExtendedStatusBlock any obligation or callback parameters however Describe routines should include in their returned ExtendedStatusBlock parameters that describe some or all of the constraints that are applicable for the corresponding action or link constraint.

In one embodiment the same local flags as the ones defined for Action routines apply for each of these categories.

In one embodiment in the context of ExtendedStatusBlock parameters returned by link constraint routines a constraint means a condition that is required to be true or a criterion that is required to be met in order for the result of the routine to return an ExtendedStatusBlock with the category LINK VALID.

The CacheDuration field of an ExtendedStatusBlock is an indication of the validity period of the information encoded in the ExtendedStatusBlock. When an ExtendedStatusBlock has a non zero validity period it means that the ExtendedStatusBlock can be stored in a cache and that during that period of time a call to the exact same routine call with the same parameters would return the same ExtendedStatusBlock so the cached value may be returned to the host application instead of calling the routine.

Some parameters are used to convey detailed information about the return status as well as variable bindings for template processing see Section 9.4 .

In one embodiment except for obligations and callbacks all the constraints described here are strictly for the purpose of helping the host application classify and display not for enforcement of the usage rules. The enforcement of the rules is the responsibility of the control program.

In one embodiment the parameters defined in the following section are encoded either as a ParameterBlock if no parameter flags are applicable or as an ExtendedParameterBlock of one or more flags are applicable. Representative flags are described below 

Description List of description parameters. Each value in the list is of type Parameter or Extended Parameter. In one embodiment the following parameters are defined Default Short and Long. Each of them if present has for a value the ID of one of the control s resources. That resource should contain a textual payload or a template payload. If the resource is a template it is processed to obtain a textual description of the result either a description of the entire control program or of a specific action . The template is processed using as variable bindings the other parameters of the list in which the Description parameter appears.

In one embodiment the Short and Long descriptions can only be included if a Default description is also included.

In one embodiment constraint parameters are grouped in lists that contain constraints of similar types. In one embodiment standard constraints are defined for some of the types. In one embodiment controls may return constraint parameters that are not included in the set of standard constraints provided that the name of the constraint parameters be a URN in a namespace that guarantees the uniqueness of that name. This may include vendor specific constraints or constraints defined in other specifications.

Description List of generic constraints that may be applicable. Each value in the list is of type Parameter or ExtendedParameter.

In one embodiment generic constraints are constraints that do not belong to any of the other constraint types defined in this section. In one embodiment no generic constraint parameters are defined.

Description List of temporal constraints that may be applicable. Each value in the list is of type Parameter or Extended Parameter. Temporal constraints are constraints that are related to time date duration and or the like. In one embodiment the following temporal constraint parameters are defined 

Description List of spatial constraints that may be applicable. In one embodiment each value in the list is of type Parameter or ExtendedParameter. Spatial constraints are constraints that are related to physical locations. In one embodiment no standard spatial constraints are defined.

Description List of group constraints that may be applicable. Each value in the list is of type Parameter or Extended Parameter. Group constraints are constraints that are related to groups group membership identity groups and or the like. In one embodiment the following parameters are defined 

Description List of device constraints that may be applicable. Each value in the list is of type Parameter or Extended Parameter. Device constraints are constraints that are related to characteristics of a device such as features attributes names identifiers and or the like. In one embodiment the following parameters are defined 

Description List of counter constraints that may be applicable. Each value in the list is of type Parameter or ExtendedParameter. Counter constraints are constraints that are related to counted values such as play counts accumulated counts and or the like. In one embodiment no standard counter constraints are defined.

In one embodiment the following flags may be used for all the parameters described in Section 9.2.3 when they are encoded as an ExtendedStatusBlock 

In one embodiment certain actions when granted require further participation from the host application. Obligations represent operations that need to be performed by the host application upon or after the use of the content key it is requesting. Callbacks represent calls to one or more of the control program routines that need to be performed by the host application upon or after the use of the content key they are requesting.

In one embodiment if an application encounters any critical obligation or callback that it does not support or does not understand for example because the obligation type may have been defined after the application was implemented it must refuse to continue the action for which this obligation or callback parameter was returned. In one embodiment a critical obligation or callback is indicated by setting the CRITICAL parameter flag for the parameter that describes it.

If a control has side effects such as decrementing a play count for example it should use the OnAccept callback to require the host application to call a certain routine if it is able to understand and comply with all critical obligations and callbacks. The side effect should happen in the callback routine. In one example embodiment implementations are required to understand and implement the OnAccept callback since it can be useful in preventing side effects e.g. updates to the state database from occurring prematurely e.g. before the host application determines that it is unable to comply with a given critical obligation or callback and needs to terminate performance of an action thus providing a measure of transactional atomicity.

The following parameters define several types of obligations and callbacks that can be returned in ExtendedStatusBlock data structures.

Description List of obligation parameters. Each value in the list is of type Parameter or Extended Parameter. In one embodiment the following obligation parameters are defined 

Description List of callback parameters. Each value in the list is of type Parameter or Extended Parameter. In one embodiment the following callbacks parameters are defined 

In one embodiment the Callback type mentioned in the table above is a ValueListBlock with three ValueBlock elements 

In one embodiment the same parameter flags as defined in the previous section are used. In one embodiment callbacks and obligations that a caller is required to implement are marked as CRITICAL so as to avoid giving a host application the choice to ignore these parameters.

In one embodiment events are specified by name. Depending on the type of event there may be a set of flags defined that further specify the event. In one embodiment if no flags are defined for a specific event the value of the flag field is set to 0. Also some events may specify that some information be supplied to the callback routine when the event occurs. In one embodiment if no special information is required from the host application the host application must call with an empty ArgumentsBlock see the description of the callback routine interface in section 3.3 below .

In one embodiment if the name of an event in a callback parameter marked CRITICAL is not understood or not supported by the host application the host application must consider this parameter as a not understood CRITICAL parameter and the action for which permission was requested must not be performed .

ArgumentsBlockSize number of bytes of data passed on the stack below this parameter. When the routine is called the stack contains the value ArgumentsBlockSize supplied by the caller indicating the size of the arguments block at the top followed by ArgumentsBlockSize bytes of data. In one embodiment if the size is not a multiple of 4 the data on the stack will be padded with 0 value bytes to ensure that the stack pointer remains a multiple of 4.

ResultCode an integer value. The result value is 0 if the routine was able to execute or a negative error code if an error occurred.

Description if the ResultCode indicates that the callback routine was able to run i.e. the value is 0 the host application can continue the current operation. If the ResultCode indicates that an error occurred the host application aborts the current operation and cancels all pending callbacks and obligations.

When a control routine has specified one or more callbacks of type RESET in the ESB returned from a routine the host application will call any specified callback routine when the condition for that callback is met. In one embodiment as soon as the conditions of any of the callbacks are met the host application needs to 

The return status from the routine indicates to the host application if it can continue performing the current operation. In one embodiment if the permission is denied or the routine fails to execute successfully the host application must abort the performance of the current operation. Similarly if the permission is granted the host application must comply with any obligation or callback that may be returned in an ESB just as if it had called the original Control.Actions..Perform routine. Previous obligations or callback specifications are no longer valid.

In one embodiment all routines specified as callback entry points for this type of callback have the following output 

ResultCode an integer value. The result value is 0 if the routine was able to execute or a negative error code if an error occurred.

Description the return semantics of this routine are equivalent to what is described for the Control.Actions..Perform routine.

In one embodiment control objects can contain metadata resources which can be referenced from the parameters returned in ExtendedStatusBlock data structures. Resources can be simple text text templates or other data types. Each resource is identified by a resource ID and can contain one or more text strings or encoded data one for each version in a different language. It is not required that resources be provided for all languages. It is up to the host application to choose which language version is most appropriate for its needs.

Resources accompany control programs by being included as Extensions in a Control object. The resource Id maps to the Id of an internal extension of the Control object that contains the code module with the routine that is currently running.

For the purpose of computing the canonical byte sequence for Resource objects in one embodiment the data structure description is the following 

In addition to the standard text resources in one embodiment a text template type is defined. The MIME type for this is text vnd.intertrust.octopus text template .

In one embodiment a text template contains text characters encoded in UTF 8 as well as named placeholders that are to be replaced by text values obtained from parameters returned in the parameters list such as that of an ExtendedStatusBlock. The syntax for a placeholder is PLACEHOLDER where PLACEHOLDER specifies the name of a Parameter Block and an optional formatting hint. In one embodiment the template processor must replace the entire token PLACEHOLDER with the formatted representation of the Value field of that Parameter Block and the formatting of the Value data is specified below in Section 4.2.1.

In one embodiment if the character appears in the text outside of a placeholder it must be encoded as and all occurrences of in the text will be reverted to by the template processor.

The syntax for the placeholder is FORMATINAME where NAME is the name of a Parameter Block and FORMAT is the formatting hint to convert the parameter s data into text. If the default formatting rules for the parameter value s data type are sufficient then the formatting hint can be omitted and the placeholder is simply NAME.

Explicit format names can be used as the FORMAT part of a placeholder tag. If an unknown FORMAT name is encountered the template processing engine will use the default formatting rules.

In one embodiment when a control routine is executing it has access to a number of context objects through the use of the System.Host.GetObject system call.

In one embodiment the following context is present for all controls that are running in a VM that has been created using the System.Host.SpawnVm system call. In one embodiment this context must be non existent or an empty container for controls that are running in a VM that was not created using System.Host.SpawnVm.

In one embodiment the following context is present whenever a routine of a control is running and the control was pointed to by a controller object e.g. when accessing a ContentKey object in order to consume protected content .

In embodiments where a host application is allowed to only group content keys that are controlled by a single controller object for a given action there will be only one applicable controller object.

In one embodiment the following context is present whenever a control is called for the purpose of controlling an Action.

In one embodiment the following context is present whenever a control is called for the purpose of limiting the validity of a link object e.g. a control object embedded in a link object 

The Parameter and Session containers are normally used to allow the protocols that require one entity to send and run an agent on another entity to specify which input parameters to pass to the agent and which session context objects the host needs to set under certain conditions. The presence or absence of certain session context objects may allow the agent code to decide whether it is running as part of the protocol it was designed to support or if it is running out of context in which case it may refuse to run. For example an agent whose purpose is to create a state object on the host on which it runs may refuse to run unless it is being executed during a specific protocol interaction.

In one embodiment each action has a name and a list of parameters. In one embodiment some parameters are required the application must provide them when performing this action and some are optional the application may provide them or may omit them.

Transferring to a compatible target system is used when the content has to be made available to a system with the same DRM technology such that the target system can use the same license as the one that contains this control but state information may need to be changed on the source the sink or both. The system from which the transfer is being done is called the source. The target system to which the transfer is being done is called the sink.

This action is intended to be used in conjunction with a service protocol that allows an Agent to be transferred from the source to the sink in order to do the necessary updates in the source s and sink s persistent states e.g. objects in the state database described herein . In one embodiment a control uses the RunAgentOnPeer obligation for that purpose. Additional information about illustrative embodiments of this service protocol are provided below in connection with the discussion of the state database.

Exporting to a foreign target system is an action that is used when the content has to be exported to a system where the original content license cannot be used. This could be a system with a different DRM technology a system with no DRM technology or a system with the same technology but under a situation that requires a license different from the original license. The system from which the transfer is being done is called the source. The target system to which the transfer is being done is called the sink.

In one embodiment in the Extended Status result for the Describe Check and Perform methods of this action the following parameter shall be set 

In one embodiment the standard TargetSystem ID CleartextPcmAudio is used when the target system is an unencrypted medium onto which uncompressed PCM audio is written such as a writeable audio CD or DVD. For this target system the ExportInfo parameter is a single Integer parameter representing a copyright flag. This flag is indicated in the least significant bit of the integer value.

A secure object store that can be used by preferred embodiments of a DRM engine to provide a secure state storage mechanism is described below. Such a facility is useful to enable control programs to be able to read and write in a protected state database that is persistent from invocation to invocation. Such a state database can be used to store state objects such as play counts date of first use accumulated rendering times and or the like. In a preferred embodiment the secure database is implemented in non volatile memory such as flash memory on a portable device or an encrypted area of the hard disk drive on a PC. It will be appreciated however that the secure database could implemented on any suitable medium.

The term object as used in this section generally refers to the data objects contained within the secure object store and not to the objects e.g. controls controllers links etc. discussed elsewhere herein if necessary to distinguish between these two categories of objects the term DRM object will be used to refer to the objects described elsewhere herein i.e. controls controllers protectors ContentKeys links nodes and the like while the term state object will be used to refer to the objects stored within the state database. In the following discussion reference will occasionally be made to an illustrative implementation of the state database called Seashell which is used in connection with the Octopus DRM engine embodiment described elsewhere herein. It will be appreciated however that embodiments of the systems and methods described herein can be practiced without some or all of the features of this illustrative implementation.

The object store e.g. a database contains data objects. In one embodiment objects are arranged in a logical hierarchy where container objects are parents of their contained children objects. In one embodiment there are four types of objects string integer byte array and container. Each object has associated metadata and a type. Depending on its type an object can also have a value.

In one embodiment state objects can be accessed from virtual machine programs using the System.Host.GetObject and System.Host.SetObject system calls and as described in more detail below object metadata can be accessed using virtual names. In one embodiment some of the metadata fields can be changed by clients of the database i.e. they are read write RW accessible while other metadata fields are read only RO .

As previously indicated in one embodiment there are four types of state objects strings integers byte arrays and container. In this embodiment the value of a string object is a UTF 8 encoded character string the value an integer object is a 32 bit integer value and the value of a byte array object is an array of bytes. In this embodiment a container object contains zero or more objects. A container object is referred to as the parent of the objects it contains. The contained objects are referred to as the children of the container. All the container objects that make up the chain of an object s parent the parent s parent and so on are called the object s ancestors. If an object has another object as it ancestor that object is called a descendant of the ancestor object.

In one embodiment the lifetime of objects in the state database follows a number of rules. Objects can be explicitly destroyed or implicitly destroyed. Objects can also be destroyed as the result of a database garbage collection. Regardless of how an object is destroyed in one embodiment the following rules apply 

Explicit object destruction happens when a client of the database requests that an object be removed see Object Access for more details on how this can be done using the Host.SetObject system call .

Implicit object destruction happens when an object is being destroyed as the result of one of the objects in its ancestry being destroyed.

In one embodiment the state database destroys any object that has expired. An object is considered to have expired when the local time on the system that implements the database is later than the ExpirationDate field of the object s metadata. An implementation may periodically scan the database for expired objects and destroy them or it may wait until an object is accessed to check its expiration date. In one embodiment an implementation must not return to a client an expired object. In one embodiment when a container object is destroyed e.g. because it has expired its children objects are also destroyed and all their descendants recursively even if they have not expired yet.

In one embodiment the objects in the state database can be accessed from virtual machine programs through a pair of system calls System.Host.GetObject to read the value of an object and System.Host.SetObject to create destroy or set the value of an object.

In one embodiment to be visible as a tree of host objects the state database is mounted under a certain name in the host object tree. This way the database is visible as a sub tree in the more general tree of host objects. To achieve this in one embodiment the state database contains a top level built in root container object that always exists. This root container is essentially the name of the database. All other objects in the database are descendants of the root container. Multiple state databases can be mounted at different places in the host object tree for two databases to be mounted under the same host container they need to have different names for their root container . For example if a state database whose root container is named Database1 contains a single integer child object named Child1 the database could be mounted under the host object container SeaShell in which case the Child1 object would be visible as SeaShell Database1 Child1 . In one embodiment accesses to objects in the state database are governed by an access policy.

The value of an object can be read by using the system call System.Host.GetObject. In one embodiment of the state database the four object types integer string byte array and container that can exist in the database map directly onto their counterparts in the virtual machine. The object values can be accessed in the normal way and the standard virtual names can be implemented.

Objects can be created calling System.Host.SetObject for an object name that does not already exist. The object creation is done according to the system call specification. In one embodiment when an object is created the state database does the following 

When creating an object under a path deeper than the existing container hierarchy in one embodiment the state database implicitly creates the container objects that need to exist to create a path to the object being created. In one embodiment implicit container object creation follows the same rules as an explicit creation. For example if there is a container A with no children a request to set A B C SomeObject will implicitly create containers A B and AB C before creating A B C SomeObject .

The value of objects can be changed by calling System.Host.SetObject for an object that already exists. If the specified ObjectType does not match the type ID of the existing object ERROR INVALID PARAMETER is returned. In one embodiment if the type ID is OBJECT TYPE CONTAINER no value needs to be specified the ObjectAddress must be non zero but its value will be ignored . When an existing object is set the state database sets the ModificationDate of object to the current local time.

Objects can be explicitly destroyed by calling System.Host.SetObject for an object that already exists with an ObjectAddress value of 0. When an object is destroyed the state database preferably 

In one embodiment the metadata for state database objects is accessed by using the System.Host.GetObject and System.Host.SetObject system calls with virtual names. The following table lists the standard and extended virtual names that are available for objects in one embodiment of the state database and how they map to the metadata fields.

In one embodiment an implementation must refuse a request to set the Flags metadata field if one or more undefined flags are set to 1. In this case the return value for the System.Host.SetObject is ERROR INVALID PARAMETER. In one embodiment when reading the Flags metadata field a client must ignore any flag that is not predefined and when setting the Flags field of an object a client must first read its existing value and preserve the value of any flag that is not predefined e.g. in a system specification .

In one embodiment whenever a request is made to read write create or destroy an object the state database implementation first checks whether the caller has the permission to perform the request. The policy that governs access to objects is based on the concepts of principal identities and delegation. In order for the policy to be implemented the trust model under which the implementation operates needs to support the notion of authenticated control programs. This is typically done by having the virtual machine code module that contains the program be digitally signed directly or indirectly through a secure reference with the private key of a PKI key pair and having a name certificate that associates a principal name with the signing key however it will be appreciated that different ways of determining control program identities are possible any suitable one of which could be used.

In one embodiment the access policy for the objects in the state database is comprised of a few simple rules 

In one embodiment when the access policy denies a client s request the return value of the system call for the request is ERROR PERMISSION DENIED.

The root container of the state database is preferably fixed when the database is created. When an object is created the value of its Owner metadata field is set to the same value as that of its parent container Owner metadata field. Ownership of an object can change. To change the ownership of an object the value of the Owner metadata field can be set by calling the Sytem.Host.SetObject system call for the Owner virtual name of that object provided that it is permitted under the access control rules.

In embodiments where it is not possible for a control program to access objects that are not owned by the same principal as the one whose identity it is running under a control program needs to delegate access to foreign objects to programs loaded from code modules that have the ability to run under the identity of the owner of the foreign object. To do this a control program may use the System.Host.SpawnVm System.Host.CallVm and System.Host.ReleaseVm system calls in the control virtual machine.

The storage of state information in a database such as that described above enables rights to be moved between devices or exported from a domain e.g. by transferring the state information to another device . The following section describes embodiments of protocols by which the state of a database can be transferred from a source to a sink. Note that although this process will be referred to as a license transfer protocol it is the state of the state database that is being transferred as opposed to merely an actual license e.g. a control object etc. . The protocol is referred to as a license transfer protocol because in one embodiment the transfer is initiated by execution of a transfer action in a control program and because transfer of the state information enables the sink to successfully execute the relevant license for a piece of content.

In one embodiment the protocol shown in supports two modes where this is a problem i render no stop render and ii checkout no check in . Because of this problem control issuers may be led to issue timeouts on the states that are transferred. However this can result in a bad consumer experience when for example a user wants to render content on one device but decides that she actually wants to render this content on another one with the current design it is likely that she will have to wait for the entire piece of content to he rendered on the first device before she is able to render it on the other device. This might be undesirable if the content is relatively long e.g. a movie .

In one embodiment the request contains only the Content IDs and the source retrieves the license associated with the Content IDs from its license database. However this process can be prone to error since the licenses may be stored on a removable media and at the time of engagement of the protocol a particular license may not be available if the media has been removed. Moreover even if the licenses are available it can be cumbersome to perform a lookup for the licenses in the license store. Also because there can be multiple licenses associated with a set of Content IDs it may be difficult to determine if the resolved license is the same as the one that was intended in the request.

In one embodiment the set of system calls callbacks obligations does not support a way for a Control to ask for proximity checking of a peer. Instead a control can only read a value of a host object Octopus Action Parameters Sink Proximity LastProbe that is populated by the application during a transfer with a value it got from a previous execution of a proximity checking protocol. This can be a problem in the case where it may be desirable to avoid a proximity check if such a proximity check is not needed e.g. if the sink is known to be within a certain domain .

In the embodiment shown in the protocol is limited to three rounds. This can be a serious limitation since the the protocol will be unable to handle the case where the OnAgentCompletion callback returns an extended status block with another RunAgentOnPeer obligation. Moreover after the protocol is finished the sink will not really know if the protocol has succeeded or not. In addition the proximity check will need to occur before the response is sent see previous problem but this is not needed in the case where the source and the sink are in the same domain. In addition in the protocol shown in the source gives the content key to the sink without knowing if this content key will ever be used.

In the embodiment shown in when a DRM Client evaluates a license e.g. Control.Actions.Play.Check there is no easy way for the control writer to hint that a license transfer is needed in order to get the state that will enable a successful evaluation of the control.

In the protocol shown in the license transfer is initiated by the sink. It would be desirable for the source to be able to initiate the transfer as well.

In one embodiment a new release operation is introduced. When this operation is specified in the request the Transfer Mode ID is set to Release. In order for the client to do the correlation between a render checkout and a release operation an optional element SessionId is added to the request see section below . In one embodiment when this element is present it is reflected in the host object tree of the Transfer Action context under SessionId.

The sink knows that it has to send this SessionId in the release request if the Extended Status Block it will get in the Teardown message see below contains a parameter 

In one embodiment the solution consists of having the sink device put the license bundle s in the request so that there is essentially a guarantee that the sink and the source will execute the same license. In the embodiment shown in the XML schema for the request is the following 

Where the ContentIdList contains the list of Content IDs one per track stream identifying the content the Operation contains the type of license transfer operation and the Bundle contains the Personality node of the requestor and the associated signature.

To avoid the license resolution problem described above the license bundle s can be included in the request e.g. by amending the schema as follows 

In this schema the ContentIdList element is replaced by a License element. This element carries a set of LicensePart elements. A LicensePart element carries an oct Bundle element containing license objects as well as an optional ContentId attribute indicating that the license objects are applied to this particular ContentId. A LicensePart element with no ContentId attribute means that the objects contained in the underlying bundle are applied to all Content IDs generally the controller and the control objects .

In one embodiment the SessionId optional element cannot be present except if the operation is urn marlin core 1 2 service license transfer release in which case it may be present if a SessionId parameter was received in the Extended Status Block of the corresponding render or checkout action see above .

In one embodiment the NeedsContentKeys optional element should be present with a value of false if the sink knows that it is already capable of decrypting the content keys. The absence of this element means that the source has to re encrypt the Content Keys of the sink in case of success of the protocol.

In order to allow Control programs to do this a new pair of Obligations Callbacks can be defined. Specifically the control can put a ProximityCheckSink obligation in its extended status block. This indicates to the application that proximity with the sink has to be checked. When the proximity check is done the application will call back the control using the OnSinkProximityChecked callback.

In one embodiment a ProximityCheck obligation is defined that is only applicable in the context of a License Transfer. In this embodiment there needs to be zero or one such obligation per extended status block and if present an OnSinkProximityChecked callback needs to be present as well.

As shown in after the Setup the application will run the Control as explained above and will get an Extended Status Block ESB . This ESB may contain a RunAgentOnPeer obligation OnAgentCompletion callback. In one embodiment the RunAgentOnPeer obligation will contain all the parameters that the Source application needs to build the RunAgent message . Note that in one embodiment the RunAgent message will also be sent if the application encounters another RunAgentOnPeer OnAgentCompletion callback obligation pair in the Extended Status Block of the OnAgentCompletion callback after one or more RunAgent AgentResult message exchanges .

In one embodiment if the ESB does not contain a RunAgentOnPeer obligation OnAgentCompletion callback it means that the Teardown message see below needs to be sent. Note that this ESB may contain a ProximityCheck obligation OnSinkProximityChecked callback in which case the proximity check protocol will be performed and the result will be read from the ESB of the OnSinkProximity checked callback before sending the Teardown message.

In one embodiment the payload of the RunAgent message is identical to the Response message of the previous design except that it does not carry a ContentKeyList.

As shown in after the sink has run the agent sent by the source in the RunAgent message the sink sends an AgentResult message to the source . In one embodiment the message payload is the same as the Confirmation message described in connection with .

As shown in the Teardown message is sent by the Source application when the extended status block of the OnAgentCompletion does not carry any RunAgentOnPeer OnAgentCompletion callback obligation pair which means that the protocol is over. In one embodiment the Teardown message carries two pieces of information i a description of the protocol result so that the sink knows if the protocol has succeeded or not and if not an indication of why it failed see below for more details and ii in case of success of the protocol the updated ContentKey objects the ContentKeyList of the Response in the previous message if the NeedsContentKey element of the setup message is set to true or not present.

In one embodiment the description of the protocol result is actually the Extended Status Block ESB of the last invocation of the control carrying no agent related obligation callback pair.

In case of failure the parameters of the ESB may point to resources. In one embodiment these resources are located in the ResourceList extension of the Control that was sent in the Setup message.

In case of success in one embodiment the cache duration will indicate for how much time the Content Keys may be used without asking the control again.

An example of such an ESB XML representation is shown below and can be added to the virtual machine schema 

The following is an example of a rendering use case in accordance with an embodiment of the improved license transfer mechanisms described above. In this example a broadcast import function imports a piece of content with the following license 

Assume a Core DRMClient1 requests permission to render the content stream. A Setup Request is sent from the sink Core DRMClient1 to the Source BC Import function containing the following parameters 

Upon receiving the request the source application populates the relevant host objects and invokes the Control.Actions.Transfer.Perform method. Illustrative pseudo code for the method governing rendering transfer is shown below 

Assuming that the rendering is not locked the RunAgentOnPeer obligation is executed. A RunAgent message is sent with the Control containing the CheckDomainAgent Method. Upon receiving this message the sink will populate the relevant host objects and invoke the CheckDomainAgent method. Illustrative pseudo code for the CheckDomainAgent is shown below 

Assume for purposes of this illustration that the sink is indeed in the domain. The sink will then send an AgentResult message containing this agent result. Upon receiving the AgentResult the Source will invoke the callback method. Illustrative pseudo code for RenderAgentCompleted is shown below 

We had assumed that the agent successfully checked the domain membership on the sink. A Teardown message is sent with i the re encrypted content keys for the sink using the keys provided with the sink node in the Setup request and ii the ESB carrying the cache duration specified above 0 in this case meaning that the sink has to re ask next time it wants to access the content . When the sink receives this message it knows it is allowed to render the content and has the needed content keys.

Now assume that the user wants to render the content on his other device DRMClient2. The problem is that the content is locked for 180 minutes on the source. Fortunately when the user presses STOP on DRMClient1 DRMClient1 will initiate a new license transfer protocol with the operation Release. Upon receiving the request the source application will populate the relevant host objects and invoke the Control.Actions.Transfer.Perform method. Illustrative pseudo code for the method governing transfer release is shown below 

Since no obligation callback is found in the ESB this means that a Teardown message will be sent back with this ESB.

This rendering use case thus illustrates that in certain embodiments there is no need for the requesting DRMClient of a render operation to re evaluate the control locally state does not have to be transferred from the source to the sink the control can proactively ask for a proximity check and the content can be released when the renderer is done with it.

In one embodiment certificates are used to check the credentials associated with cryptographic keys before making decisions based on the digital signature created with those keys.

In some embodiments the DRM engine is designed to be compatible with standard certificate technologies and can leverage information found in the elements of such certificates such as validity periods names and the like. In addition to those basic constraints in some embodiments additional constraints can be defined about what a certified key can and cannot be used for. This can accomplished by for example using key usage extensions available as part of the standard encoding of the certificates. The information encoded in such extensions allows the DRM engine to check if the key that has signed a specific object was authorized to be used for that purpose. For example a certain key may have a certificate that allows it to sign link objects only if the link is from a node with a specific attribute to a node with another specific attribute and no other link. Since the semantics of the generic technology used to express the certificate will generally not be capable of expressing such a constraint as it will have no way of expressing conditions that relate to DRM engine specific elements such as links and nodes in one embodiment such DRM engine specific constraints are conveyed as a key usage extension of the basic certificate that will be processed by applications that have been configured to use the DRM engine.

In one embodiment the constraints in the key usage extension are expressed by a usage category and a VM constraint program. The usage category specifies what type of objects a key is authorized to sign. The constraint program can express dynamic conditions based on context. In one embodiment any verifier that is being asked to verify the validity of such a certificate is required to understand the DRM engine semantics and delegates the evaluation of the key usage extension expression to a DRM engine which uses an instance of the virtual machine to execute the program. The certificate is considered valid if the result of the execution of that program is successful.

In one embodiment the role of a constraint program is to return a boolean value. True means that the constraint conditions are met and false means that they are not met. In one embodiment the control program will have access to some context information that can be used to reach a decision such as information available to the program through the virtual machine s Host Object interface. The information available as context depends on what type of decision the DRM engine is trying to make when it requests the verification of the certificate. For example before using the information in a link object in one embodiment a DRM engine will need to verify that the certificate of the key that signed the object allows that key to be used for that purpose. When executing the constraint program the virtual machine s environment will be populated with information regarding the link s attributes as well as the attributes of the nodes referenced by the link.

In one embodiment the constraint program embedded in the key usage extension is encoded as a virtual machine code module that exports at least one entry point named Octopus.Certificate..Check where Category a name indicating which category of certificates needs to be checked. Parameters to the verification program will be pushed on the stack before calling the entry point. The number and types of parameters passed on the stack will generally depend on the category of certificate extension being evaluated.

In preferred embodiments some or all of the objects used by the DRM engine are signed. The following is a description of how objects are digitally signed in one embodiment using the XML digital signature specification http www.w3.org TR xmldsig core XMLDSig . In addition a canonicalization method of XML compatible with the XML exclusive canonicalization http www.w3.org TR xml exc c14n c14n ex is also described the output of which can be processed by a non XML namespace aware parser. Appendix D provides more information on an exemplary object serialization including an illustrative way to compute a canonical byte sequence for objects in an encoding independent manner.

As shown in in preferred embodiments certain elements in a DRM license are signed. Techniques such as those shown in are useful in prevent or impeding tampering with or replacement of the license components. As shown in in a preferred embodiment controller object includes cryptographic digests or hashes or other suitable bindings of contentkey object and control object respectively. Controller is itself signed with a MAC or preferably an HMAC that makes use of the content key and a public key signature typically of the content or license provider . In a preferred embodiment the public key signature of the controller is itself signed with an HMAC using the content key. It will be appreciated that in other embodiments other signature schemes could be used depending on the desired level of security and or other system requirements. For example different signature schemes could be used for the signature of the controller and or control such as PKI standard MACs and or the like. As another example a separate MAC signature could be computed for both the control and the controller rather than including a digest of the control in the controller and computing a single MAC signature of the controller. In yet another example the controller could be signed with both a MAC and a public key signature. Alternatively or in addition different keys than those described above could be used to generate the various signatures. Thus while illustrate several advantageous signature techniques in accordance with some embodiments it will be appreciated that these techniques are illustrative and non limiting. illustrates an embodiment in which a controller references multiple content keys. As shown in in one embodiment each of the content keys is used to generate an HMAC of the controller and the PKI signature.

In one embodiment the data mode processing input parameters and output data for XML canonicalization are the same as for Exclusive Canonical XML c14n ex except that namespace prefixes are removed namespaces are indicated using the default namespace mechanism and external entities are not supported only character entities are. The first limitation implies that an attribute and its element need to be in the same namespace.

A simple example of the simplified signature scheme is provided below In a preferred embodiment however the standard XML canonicalization is used.

The signature elements discussed in this section belong to the XMLDSig namespace xmlns http www.w3.org 2000 09 xmldsig and are defined in the XML schema defined in the XMLDSig specification. In one embodiment the container element of the XML representation of DRM objects is the element.

In one embodiment the signatures need to be detached and the element needs to be present in the object that contains the XML representation of the objects that need to be signed.

In one embodiment the element is empty and its Algorithm attribute has the following value http www.w3.org 2001 10 xml exc c14n 

In one embodiment there can be one or more Reference elements inside the block if more than one objects need to be signed by the same key e.g. this would be the case for the Control and the Controller object .

In one embodiment when signing an object the value of the URI attribute of the Reference element is the ID of the referenced object. When signing a local XML element for example in the multiple signature case of the public signature method for Controller objects the value of the URI is the value of the Id attribute of the referenced element.

In one embodiment when a reference points to an object what is digested in the reference is not the XML representation of the object but its canonical byte sequence. This transform of the object is indicated in XMLDSig by the means of the block. Therefore in one embodiment the Reference element will embed this block 

Appendix D provides additional information. In one embodiment no other is allowed for object references.

In one embodiment the element is empty and its Algorithm attribute has the following value http www.w3.org 2000 09 xmldsig sha1

In one embodiment the signature value is the base64 encoded value of the signature of the canonicalized ex c14n element with the key described in the element.

In one embodiment in this case the will only have one child that will indicate the ID of the key that has been used for the HMAC signature.

In one embodiment in this case the public key used to verify the signature will be carried in an X.509 v3 certificate and may be accompanied by other certificates that may be necessary to complete the certificate path to a CA root.

These certificates are carried encoded in base64 in elements. These elements are embedded in an element child of the element and appear in sequential order starting from the signing key s certificate. The certificate of the root is usually omitted.

Example for the sake of brevity the entire values of the example certificates have not been reproduced the material that has been deleted is indicated by ellipses 

In one embodiment controller objects need to have at least one HMAC signature for each ContentKey referenced in their list of controlled targets. The key used for each of those signatures is the value of the content key contained in the ContentKey object referenced.

Controllers may also have an RSA signature. In one embodiment if such a signature is present this signature also appears as a Reference in each of the HMAC signatures for the object. To achieve this in one embodiment the element for the RSA signature must have an Id attribute unique within the enclosing XML document which is used as the URI attribute in one of the Reference elements of each of the HMAC signatures. In one embodiment the verifier must reject RSA signatures that are not corroborated by the HMAC signature.

In some embodiments it may be desirable to restrict access to content services and or other system resources based on the physical proximity of the requesting entity e.g. to help enforce rules indicating that a protected piece of content cannot be copied outside a user s home network office complex and or the like . Embodiments of a proximity check protocol are described below that provide security without unduly impeding the performance of the proximity check itself. The proximity check protocol lends itself to application in a wide variety of contexts one of which is as indicated above in the context of digital rights management controls however it will be appreciated that the proximity checking systems and methods described below are not limited in application to the digital rights management context. For example without limitation the proximity checking techniques presented herein can also be used in the context of a network service orchestration system such as that described in the 551 application and or any other suitable context.

In one embodiment a proximity check is performed by measuring the amount of time it takes a first computing node to receive a response from a second computing node to the first computing node s request. If the amount of time is less than a predefined threshold generally indicating that the second computing node is within a certain physical distance of the first computing node then the proximity check is deemed a success.

It will be appreciated that due to the wide variety of different network connections over which the request and or the response might be sent a given amount of time may correspond to range of possible distances. In some embodiments this variation is simply ignored and the proximity check is deemed a success if the round trip time of the request response exchange is less than the predefined threshold e.g. 8 milliseconds or any other suitable amount of time regardless of whether e.g. a fast network connection is being used that could mean that the requesting and responding nodes are actually relatively distant from each other. In other embodiments a determination could be made as to the type of network connection being used and different round trip time requirements could be applied to each different network connection.

In a preferred embodiment the proximity check allows an anchor e.g. a client to check the proximity of a target e.g. a service . In one embodiment the protocol is asymmetric in that the anchor generates the secret seed that is used and is the only one that makes use of a secure timer. Moreover the target does not need to trust the anchor. Preferred embodiments of the proximity check are also cryptographically efficient in one embodiment making use of only two public key operations.

In one embodiment a set R is obtained from a seed S according to the following formula R HS . Where H M is the digest value of the hash function H over the message M and H M H H M for n 1 and H M M. It will be appreciated that this is simply one illustrative technique for generating a shared secret and that in other embodiments other techniques could be used without departing from the principles hereof.

In one embodiment the algorithm used for the hash function H is SHA1 see e.g. FIPS PUB 180 1. Secure Hash Standard. U.S. Department of Commerce National Institute of Standards and Technology although it will be appreciated that in other embodiments other hash message digest or functions could be used.

In one embodiment a proximity check is performed as follows where A is the anchor e.g. client and B is the target e.g. service 

 b A sends to B E PubB Q S where E Y X denotes the encryption of X with the key Y and PubB denotes B s public key in a public private key pair.

 j If B responded to A with the correct value for R and D is less than a predefined threshold then the proximity check is deemed a success.

As shown in once A and B complete any initial set up steps e.g. steps a through e above A and B engage in a secure timed challenge response exchange e.g. steps f through i above that enables A to determine whether B is within an acceptable proximity.

As shown in in one embodiment A sends B a Setup Request comprising E PubB Q S i.e. the number of pairs Q as well as the secret pairs seed S encrypted with B s public encryption key e.g. a key used by B in the context of service orchestration . In one embodiment Q S is the byte stream concatenation of Q 1 byte and S 16 bytes in network byte order. In one embodiment the encryption is performed using RSA public key encryption e.g. as described in B. Kaliski J. Staddon PKCS 1 RSA Cryptography Specifications Version 2.0. IETF RFC2437. October 1998 . In a preferred embodiment PubB will have been previously accessed by A through inspection and its certificate will have been verified. Although a Setup Response from B to A is shown in in other embodiments a Setup Response is not used. As previously indicated after receiving the Setup Request B preferably precomputes the set R so as to facilitate rapid response to subsequent challenges from A .

As shown in A sends B a Challenge Request consisting of k R i.e. the index k and the corresponding secret computed from the seed. In one embodiment k R is the byte stream concatenation of k 1 byte and R 20 bytes in network byte order encoded in base64 for transport. As shown in in one embodiment B is operable to send a Challenge Response to A the Challenge Response consisting of R i.e. the corresponding secret from the Challenge Request . In one embodiment Ris the byte stream of R 20 bytes in network byte order encoded in base64 for transport.

The protocol can alternatively or in addition be aborted if A receives an incorrect value of Rin step h . In other embodiments a certain number of incorrect responses from B may be tolerated.

It will be appreciated that optimal values for Q and the predefined time threshold will typically depend on the unique circumstances of the application at hand e.g. the speed of the network the importance of ensuring a relatively tight proximity etc. . Therefore implementations should preferably provide for flexibility in configuring these values. In one embodiment it is assumed that implementations will support a minimum value of 64 for Q and a value of 8 ms for the threshold where at some of today s network speeds 8 ms may correspond to a proximity of a few miles .

In a preferred embodiment no additional security is needed for the exchange of the request and the response. Because of the size of the messages being exchanged e.g. 20 bytes and their effective randomness through use of the SHA1 hashing algorithm or other method it will be cryptographically infeasible for an attacker to determine the correct response even if the attacker manages to intercept the request.

It should be appreciated that the above described embodiments are illustrative and that numerous modifications could be made without departing from the inventive principles presented herein. For example while a recursively hashed secret seed is described above any suitable shared secret could be used for the challenge response. In one embodiment the shared secret might simply comprise an encrypted number message sent from A to B and the challenge response could simply comprise A and B exchanging portions of the number message e.g. A sends B the first character of the message and B sends A the second character of the message and so forth . Although such a technique may lack the security of the embodiment described in connection with since a character in a message would be much easier to guess than a 20 byte hash in some embodiments such a level of security may be adequate especially where for example the variability of network delays makes the proximity checking mechanism a fairly coarse control of actual proximity anyway and in other embodiments security could be enhanced by performing the proximity check multiple times where although any particular digit or bit may be relatively easy to guess the likelihood that an attacker would be able to correctly guess a given sequence of digits or bits will rapidly decrease with the length of the sequence. In such an embodiment the proximity check could be deemed a success only if B is able to provide more than a predefined number of consecutive correct responses or a predefined percentage of correct responses .

For purposes of illustration and explanation an additional illustrative example of a proximity check protocol is provided below. In this example a first device SRC communicates with a second device SNK over a communication channel e.g. a computer network . We want to be able to securely determine if SRC and SNK are within proximity of each other as measured by the time it takes for SNK to respond to a communication request from SRC. A challenge or probe message is sent from SRC to SNK and SNK replies with a response message. The period of time between the emission of the challenge and the reception of the response will be called the round trip time or RTT. To avoid introducing unnecessary overhead in the time it takes SNK to compute and send back a response to the challenge it will generally be desirable to make the challenge response communication as lightweight as practical. In particular it will typically be desirable to avoid requiring cryptographic operations by SRC or SNK between the emission of the challenge and the reception of the response.

Also to ensure that only SNK is able to produce a valid response to the challenge from SRC e.g. to avoid a man in the middle attack where a third party could intercept the challenge from SRC and send a response back as if SNK had responded the protocol could proceed as follows 

 1 SRC creates a secret. This secret is composed of one or more pairs of random or pseudo random numbers.

 2 SRC sends to SNK the secret. This part of the protocol is not time sensitive. The secret is kept confidential by SRC and SNK. The secret is also sent in a way that ensures that only SNK knows it. This typically involves sending the secret over a secure authenticated channel between SRC and SNK for example SRC can encrypt the secret data with a public key for which it knows that only SNK has the corresponding private key . The secret data does not have to be the pair s of random or pseudo random numbers described above. Even in embodiments where such pairs are used the secret data transmitted in this step only needs to be enough information to allow SNK to compute or deduct the values of the pair s of numbers. For example the secret data could be a random seed number from which one or more pair s of pseudo random numbers can be generated using a seeded pseudo random number generator.

 3 Once SRC knows that SNK is ready to receive a challenge for example SNK may send a READY message after receiving and processing the secret data SRC creates a challenge message. To create the challenge message. For example in a preferred embodiment SRC selects one of the random number pairs. If more than one pair is used the challenge message data contains the information to indicate which pair was chosen as well as one of the two numbers in that pair.

 4 SRC measures the value of the current time T. Immediately after SRC sends the challenge message no need for encryption or digital signature to SNK and waits for the response. Alternatively SRC could measure the current time T immediately before sending the challenge message although preferably after any concomitant cryptographic operations e.g. encryption signing and or the like had been performed.

 5 SNK receives the challenge from which it can identify one of the pairs it has received previously. SNK checks that the random number in the challenge is part of the pair and constructs a response message that contains the value of the other random number of that pair.

 7 SRC receives the response message and measures the value of the current time T. The round trip time RTT is equal to T T.

 8 SRC verifies that the number received in the response is equal to the other value in the pair that was chosen for the challenge. If the numbers match the challenge response is successful and SRC can be assured that SNK was within the proximity indicated by the roundtrip time. If the numbers do not match SRC can abort the protocol or if more than one pair was shared and there is at least one pair that has not been used go back to step 3 and use a different pair.

It will be appreciated that a number of variations could be made to the illustrative proximity checking protocols described above without departing from the principles thereof. For example without limitation different cryptographic algorithms could be used different shared secrets could be used and or the like.

In practical applications of the systems and methods described herein security can be provided at a variety of different levels and using a variety of different techniques. The discussion herein has focused primarily on the design and operation of a DRM engine and related host application for use in efficiently regulating potentially complex business relationships. When the DRM engine and host application operate as intended content is protected from unauthorized access or other use by the enforcement of the license terms associated therewith.

Protection of the DRM engine and or the environment in which the DRM engine runs e.g. the applications and hardware with which it interacts from malicious tampering or modification can be done using any suitable combination of security techniques. For example cryptographic mechanisms such as encryption digital signatures digital certificates message authentication codes and the like can be employed e.g. as described elsewhere herein to protect the DRM engine host application and or other system software or hardware from tampering and or other attack as could structural and or tactical security measures such as software obfuscation self checking customization watermarking anti debugging and or other mechanisms. Representative examples of such techniques can be found for example in U.S. Pat. No. 6 668 325 B1 Obfuscation Techniques for Enhancing Software Security and in commonly assigned U.S. patent application Ser. No. 11 102 306 published as US 2005 0183072 A1 U.S. patent application Ser. No. 09 629 807 U.S. patent application Ser. No. 10 172 682 published as US 2003 0023856 A1 U.S. patent application Ser. No. 11 338 187 published as US 2006 0123249 A1 and U.S. Pat. No. 7 124 170 B1 Secure Processing Unit Systems and Methods each of which is hereby incorporated by reference herein in its entirety. Alternatively or in addition physical security techniques e.g. the use of relatively inaccessible memory secure processors secure memory management units hardware protected operating system modes and or the like can be used to further enhance security. Such security techniques will be well known to one of ordinary skill in the art and it will be appreciated that any suitable combination of some none or all of these techniques could be used depending on desired level of protection and or the details of the particular application at hand. Thus it will be appreciated that while certain security mechanisms e.g. key derivation techniques digital signature techniques encryption techniques and the like are described herein in connection with certain embodiments use of these techniques is not required in all embodiments.

Yet another form of security can be provided by the institutional design and operation of the system and by the legal and social regulation of the participants therein. For example in order to obtain a personality node keying material protected content and or the like a device or entity may be required to contractually agree to adhere to system specifications and requirements may need to submit to a certification process during which the entity s compliance with system requirements could be verified and or the like. For example a device or application may be required to implement the DRM engine in a way that is compatible with other implementations in the environment and or be required to provide a certain type or level of tamper resistance or other security. Digital certificates could be issued that attested to a device s or other entity s compliance with such requirements and these certificates could be verified before allowing the device or entity to participate in the system or as a condition of allowing continuing access.

Additional non limiting information on security techniques that can be used in connection with the inventive body of work is provided below.

In some embodiments a system designer may choose to use a combination of renewability refusal and or remediation techniques to manage risks and mitigate threats that may arise from attacks on and compromise of devices applications and services. Examples of various technical mechanisms that can be used to mitigate threats are presented below.

First they can be used to convey up to date information to trusted system entities that allow them to refuse access or service to untrusted system entities. Second renewal mechanisms enable an untrusted entity to regain trusted status by updating any compromised component s . Refusal countermeasures can be further characterized as exhibiting one or more of the following behaviors 

For example refusal mechanisms can be used to counter threats such as device cloning impersonation attack protocol failures policy enforcement failures application security failures and stale or suspicious information.

The following table provides examples of potential threats some of the risks they pose and mechanisms to remedy the threat and renew system security.

Revocation can be viewed as a remediation mechanism that relies on blacklisting an entity. Typically what is revoked is a credential such as a public key certificate. Upon revoking the credential the blacklist will need to be updated and a renewal mechanism used to convey the update so that a relying party may benefit therefrom.

Thus for example devices users and or other entities can be required to present identity certificates other credentials and a variety of security data before they are given the information necessary to consume content or a service. Similarly in order for a client to trust a service the service may need to provide its credentials to the client.

Examples of ways that an entity can effectively invalidate information necessary for accessing a service include 

Revocation lists can be used by different entities to revoke identity certificates licenses links and other security assertions. This mechanism is most effective to remedy the situation which results from a service being compromised. A number of techniques can be used for distributing CRLs. For example some systems may employ an indirect CRL so that there is a single CRL governing the entire ecosystem. In addition entities can advertise or publish the CRL s in their possession and or subscribe to an update service. CRL s can be distributed peer to peer in a viral fashion and or portable devices can receive published CRL s when tethered. The service orchestration techniques described in the 551 application can also be used for this purpose.

Validity services can be used to provide up to date information on the status of credentials and other security related data. Validity services can perform either active validation operations on behalf of a relying party or they can be used to manage security information on behalf of relying parties. An example of an active validity service is one that can check the validity of a credential or attribute. Examples of validity services that manage security information are those which disseminate CRL or security policy updates or provide a secure time service. The use of validity services can help ensure that relying parties have current data to inform governance decisions.

Typically not all system entities will need up to the minute information on the validity of credentials and security data. For example not all consumer devices will use an Online Certificate Status Protocol OCSP service to validate a license server s certificate chain each time a license is used or a new license is obtained. However a license server may use an OCSP service with some frequency to check the validity of subscriber credentials. Policy which can be easily updated can determine when and what services must be used. By providing an opportunity to dynamically update policy license servers can adapt to operational changes. Thus security policy can evolve based on experience technological progress and market factors.

Self destruction of credentials and data by an entity is appropriate when the integrity of the entity s security processing is not suspect. When this option is available it is often the most straightforward expeditious and efficient method of revocation. It can be particularly useful when there is little or no suspicion of breach of integrity and bi directional communication supports a protocol allowing specific directions for destruction along with verification that destruction has been completed.

There are a number of security objects that will often be useful to have destroyed or disabled. For example when a device leaves a domain or a content license times out it will he useful for the associated objects that contain keys and can be used to access content to be destroyed. The agent control programs desdcribed in more detail elsewhere herein are well suited to the implementation of self destruction mechanisms. Agents can be crafted to destroy state in secure storage e.g. the state database to affect changes in domain membership or to remove keys that are no longer usable e.g. due to changes in membership or policy .

Exclusion is a remediation mechanism which bars a bad actor or group of bad actors from participating in future consumption of goods and services. Due to the severe consequences exclusion imposes it is typically only used as a last resort when circumstances warrant. Exclusion relies on a mechanism that effectively blacklists the bad actors thereby prohibiting them from consuming media and media related services. Dissemination of the blacklist relies upon a renewal mechanism to enable this remediation. However exclusion does not necessarily provide a renewal mechanism to restore a bad actor to a trusted status.

Key exclusion is a key management mechanism that is used to broadcast key information to a set of receivers in such a way that at any given time a decision can be made to logically exclude some subset of receivers from the ability to decrypt future content. This is activated by using efficient techniques to construct a Broadcast Key Block BKB that includes information necessary for each member of a large group of receivers to decrypt content. The BKB is structured in such a way that it can be easily updated excluding one or more members of the group from the ability to decrypt the content. In other words the design of the BKB allows for an authority to update the system with a new BKB so that a content provider can specifically exclude a target set of devices from making use of the BKB even though s he may have access to it.

This mechanism is particularly effective against a cloning attack where a pirate reverse engineers a legitimate device extracts its keys and then deploys copies of those keys to clone devices. The clones externally act like the original except that these clones will not necessarily adhere to the governance model. Once the compromise is discovered an updated BKB can be deployed that excludes the compromised device and all of its clones. However key exclusion incurs some storage transport and computation overhead that in some situations make it less efficient than other methods. This is especially true when the content is not broadcast or when there is a back channel.

Shunning is a remediation mechanism very similar in behavior to exclusion but with less severe repercussions. Essentially it is a means for refusing service because of a runtime policy decision. Instead of more heavy handed approaches to disable a device s capability through directed self destruction or access denial via key exclusion shunning offers a simple approach to disabling a device by having service providers refuse to supply it with services. With the current trend towards extending the value of devices by using externally provided services shunning becomes a more effective security mechanism.

Device shunning is driven by policy and can be used to discriminate against entities e.g. clients servers and specific role players that do not produce all of the appropriate credentials that policy requires. Policy could for example require that an entity demonstrate it has administered the latest security update. Therefore shunning can be either a consequence of revocation or the failure to take some specific action. Shunning can be facilitated in a peer to peer fashion using the inspection services and services such as those describe in the 551 application. Also a data certification service e.g. an instance of a validity service can perform shunning at policy enforcement time. After a system entity has been shunned it can be informed of the specific credential or object that is failing to comply with the policy of the service. This can trigger the shunned entity to renew the object through an appropriate service interface.

Expiration is a remediation mechanism that relies upon some temporal event to invalidate a credential or object. Expiration is effective in enabling temporary access to media or media services once these have expired the governance model ensures that access is no longer permitted. Effective use of expiration may require renewal mechanisms whereby the credential or object can be refreshed to enable continued access to media or media services.

Certified keys can have various expiry attributes assigned to protect relying parties. Expiration of credentials can be used to ensure that entities whose certificates have expired are refused service and used in conjunction with key rollover and key renewal procedures. When entities are expected to be frequently connected to a wide area network best practice dictates renewing credentials and other security data regularly. Another best practice is to keep the validity period of these objects as short as reasonable. Various techniques such as overlapping validity periods and grace periods in validity checking policies can be used to ensure smooth operation during transitions. Short validity periods also help to reduce the size of CRLs.

As previously described link objects may be assigned validity periods. Upon expiration a link is deemed invalid and a DRM engine will not consider it in the construction of its graph. This mechanism can be used to enable temporary access to goods and services. Links can be renewed so that continued access to media may be granted as long as it is permitted by policy. Because in one embodiment links are relatively lightweight self protected objects they can be easily distributed over peer to peer protocols.

Efficient renewability will typically entail the rapid deployment of remedies to protocol failures which are often the dominant security problems seen in security applications including in DRM systems . Software updates can then be used to update the business logic and security protocols. When applications are designed to separate security policy and trust policy from application logic a separate mechanism can be used to update policy this is a less risky approach. In fact peer to peer publishing mechanisms can be used to rapidly update policy. Otherwise the application deployer s software update methods can be used to update security and trust policy.

It will generally be desirable to use relatively lightweight tools when possible. Using credentials with limited validity periods and policies that check validity dates can help keep the overall population of entities to a manageable size and eliminate the need for growing CRLs too rapidly. Shunning an entity rather than excluding it from access to keys can extend the lifetime of BKBs moreover it has the advantage of enabling fine grained policies that can be temporary and change with circumstances. Different CRLs that track specific types of credentials of interest to different role players can be used instead of BKBs which can be deployed where they are most effective such as dealing with cloned receivers . Policies can direct the use of online validity services when those services can be expected to provide a reasonable return on investment of time and effort where fresh credentials are very important and where slower revocation mechanisms are inadequate. When a node is likely to have integrity and can be expected to do the right thing and when a license or security object such as a link for a subscription or a domain link needs to be revoked then a reasonable approach will typically be to tell the node to destroy the object. In such a situation there is no need to tell the world that the license is invalid and there is no need to deploy a BKB or re key a domain. Self destruction driven by local policy or by an authoritative command is one of the more efficient methods for revocation.

It will be appreciated that while a variety of revocation renewal remediation and other technologies and practices have been described it will be appreciated that different situations call for different tools and that preferred embodiments of the systems and methods described herein can be practiced using any suitable combination of some or none of these techniques.

The following discussion illustrates some of the security considerations and techniques that can be relevant to embodiments in which the DRM engine and applications described above are used in connection with networked service orchestration systems and methods such as those described in the 551 application.

Practical implementations of DRM systems employing a DRM engine and architecture such as those disclosed herein will often perform networked transactions for accessing content and DRM objects. In such a context the systems and methods described in the 551 application can be used to inter alia standardize message layer security including entity authentication and formats for authorization attributes roles .

For the sake of discussion the transactions that occur in a DRM system can be separated into at least two general categories based on the type of information being accessed acquired or manipulated 

Content Access Transactions involve direct access to or manipulation of media or enterprise content or other sensitive information protected by the DRM system. Examples of content access transactions include rendering a protected video clip burning a copy of a protected audio track to a compact disc moving a protected file to a portable device emailing a confidential document and the like. Content access transactions typically involve direct access to a content protection key and are performed at the point of consumption under the direction of a user.

Object Transactions are transactions in which a user or system acquires or interacts with objects defined by the DRM system that in some way govern access to protected content. Such objects include DRM licenses membership tokens revocation lists and so forth. One or more object transactions are usually required before all of the collateral necessary to perform a content access transaction is available. Object transactions are typically characterized by the use of some type of communications network to assemble DRM objects at the point of consumption.

These two types of transactions define two points of governance that are generally relevant to most DRM systems. shows a typical pair of interactions in which a DRM enabled client requests a DRM license from an appropriate DRM license service . In the example shown in the DRM license is sent from the DRM license service to the client where it is evaluated in order to provide access to content .

DRM systems typically require that both content access and object transactions be performed in a manner that prevents unauthorized access to content and creation of objects that protect the content. However the security concerns for the two types of transactions are naturally different. For example 

Content Access Transactions may require authenticating a human principal checking a secure render count evaluating a DRM license to derive a content protection key etc. A major threat against legitimate execution of a content access transaction is breach of the tamper resistant boundary that protects the objects and the data inside.

Object Transactions usually involve a communications channel between the entity that requires the DRM object and the entity that can provide it. As such object transactions face communications based threats such as man in the middle attacks replay attacks denial of service attacks and attacks in which unauthorized entities acquire DRM objects that they should not legitimately possess.

In general object transactions involve authentication of two interacting entities the protection of the messages passed between them and authorization of the transaction. The primary purpose of such transactions is to gather integrity protected DRM objects from legitimate sources so that content access transactions can be performed. From the perspective of a content access transaction the mechanisms by which legitimate DRM objects are obtained and the collateral information used in obtaining them are essentially irrelevant these mechanisms can and preferably should be invisible to the content access itself. This natural separation of concerns leads in a preferred embodiment to a layered communications model that distinguishes the trusted communications framework from applications that are built on top of it.

The simplified license acquisition and consumption example shown in obscures some details that will generally be important in practical applications. For example it does not show how the DRM license service verifies that the entity requesting a DRM license is in fact a legitimate DRM client and not a malicious entity attempting to obtain an unauthorized license or to deny service to legitimate clients by consuming network bandwidth and processing power. Nor does it show how sensitive information is protected for confidentiality and integrity as it moves through the communications channels connecting the client and service.

A more detailed view of this example transaction is shown in . Referring to the dotted line represents the logical transaction from the point of view of the application layer content rendering client and DRM license server . The stack below represents the layers of processing used to ensure trusted and protected delivery between the two endpoints.

In a rendering client requests a license from a DRM license server . The dotted line in the diagram indicates that the original source and ultimate consumer of the information are the content rendering client and the DRM license server . However in practice the message payload may actually be handled by several layers of processing interposed between the application layer logic and the unsecured communications channel connecting the two endpoints.

The processing layers that separate the application layer components from the unsecured communications channel will be referred to collectively as the security stack. The security stack can be thought of as a secure messaging framework that ensures integrity protected confidential delivery of messages between trusted endpoints. The layered stack model offers advantages such as 

 1 Designers of the application layer logic do not need to expend effort developing the underlying secure communications mechanisms that connect endpoints. The trusted messaging infrastructure is a common design pattern that once designed can be deployed in many different situations regardless of the application layer logic that they are supporting.

 2 The messaging framework itself can remain agnostic to the precise semantics of the messages it is conveying and focus its efforts on preventing communications related attacks and attacks on the authenticity of the messaging endpoints.

In one embodiment the security stack consists of several distinct layers of processing as described below. In one embodiment the service orchestration systems and methods described in the 551 application can be used to provide some or all of the operations of the security stack.

In one embodiment messaging endpoints may be authenticated. Authentication is a process by which a given endpoint demonstrates to another that it has been given a valid name by an authority trusted for this purpose. The naming authority should be trusted by the relying endpoint in a transaction establishing such an authority is typically undertaken by the organizations deploying the trusted technology.

A common mechanism for demonstrating possession of a valid name uses public key cryptography and digital signatures. Using this approach an entity is provided with three pieces of information 

 3 A digitally signed certificate that asserts that the holder of the private key has the given distinguished name.

The certificate binds the distinguished name and the private key. An entity that uses the private key to sign a piece of information is trusted to have the given distinguished name. The signature can be verified using only the public key. For example authentication can be based on the X.509v3 standard.

Since in one embodiment an entity that can demonstrate possession of a certified private key is trusted to have the distinguished name indicated in the certificate protecting the private key used to sign information becomes an important consideration. In effect the ability to use the private signing key defines the boundaries of the entity identified by the distinguished name. At the application layer senders and recipients need to know that messages originate from trusted counterparts. As such in one embodiment it is important that the application layer logic itself be part of the authenticated entity. For this reason in one embodiment the security stack and the application layers that rely upon it are preferably enclosed in a trust boundary such that a subsystem contained within the trust boundary is assumed to share access to the entity s private message signing key.

The authentication mechanism described above proves to distributed messaging endpoints that their correspondent s identity is trustworthy. In many applications this information is too coarse more detailed information about the capabilities and properties of the endpoints may be needed to make policy decisions about certain transactions. For example in the context of the content rendering client may need to know not only that it is communicating with an authenticated endpoint but also whether it is communicating with a service that has been deemed competent to provide valid DRM license objects.

Embodiments of the security stack provide a mechanism for asserting conveying and applying policy that is based on more fine grained attributes about authenticated entities via an authorization mechanism. Using this mechanism entities that already possess authentication credentials are assigned role assertions that associate a named set of capabilities with the distinguished name of the entity. For example role names can be defined for a DRM client and a DRM license server.

The named roles are intended to convey specific capabilities held by an entity. In practice roles can be attached to an entity by asserting an association between the entity s distinguished name and the role name. As with authentication certificates which associate keys with distinguished names in one embodiment role assertions used for authorization are signed by a trusted role authority that may be different from the name issuer. Inside an entity role assertions are verified along with the authentication credentials as a condition for granting access to a messaging endpoint s application layer.

An entity may hold as many role attributes as are required by the application being built. The example in shows an entity with multiple roles one role that indicates the ability to function as a DRM client and two service roles. For example one entity may be simultaneously a DRM client a DRM object provider and a security data provider. In one embodiment SAML 1.1 is used for assertions regarding entity attributes.

The bottom layer of the security stack is the message security layer which provides integrity confidentiality and freshness protection for messages and mitigates the risk of attacks on the communications channel such as replay attacks. In the message security layer 

In one illustrative embodiment support is provided for AES symmetric encryption RSA public key cryptography SHA 256 signature digests and mechanisms to signal other algorithms in messages.

In some embodiments a bootstrap protocol is used to deliver initial confidential configuration data to entities such as devices and software clients. For example when an entity wishes to join a larger network or system and communicate with other entities using cryptographic protocols it may need to be configured with personalized data including a set of keys shared secret and public . When it is not possible or practical for the entity to be pre configured with personalized data it will need to bootstrap itself using a cryptographic protocol.

The example protocol described below uses a shared secret as the basis for bootstrapping an entity with a set of keys and other configuration data. In the following sections the following notation will be used 

In one embodiment the client has the following set of bootstrap tokens preloaded at manufacturing time and or in firmware software 

The client may be configured with multiple BootRootCertificate certificates and BAK authentication keys in order to be able to participate in the Boot Protocol with different Boot Servers that may require different trust domains.

An illustrative embodiment of a bootstrap protocol is shown in and described below. A failure during the process for example when verifying a signature or a certificate chain will lead to an error and stop the protocol progression.

The client sends a request to the server indicating that it wants to initiate a bootstrap session and provides some initial parameters e.g. protocol version profile etc. as well as a session ID to prevent replay attacks and a list of Trust Domains in which it can participate. The following table shows an illustrative format for a BootStrapRequestMessage 

The Protocol and Version message attributes specify which protocol specification the client is using and the Profile field identifies a predefined set of cryptographic protocols and encoding formats used for exchanging messages and data.

The Client chooses a SessionId which should be unique to that client and not re used. For example a unique ID for the client and an incrementing counter value can be used as a way to generate a unique session ID.

In one embodiment the Client also sends a list of all the Trust Domains for which it has been configured.

In one embodiment after receiving the ChallengeRequestMessage the client performs the following steps 

In one embodiment each trust domain includes a Root Certificate Authority and a unique name for the domain. When a client sends a BootstrapRequest it identifies all the trust domains that it is willing to accept i.e. which certificates it will consider valid . The server selects a trust domain from the list sent by the client if it supports any.

In one embodiment whenever signatures are used in message payloads the signatures are computed over a canonical byte sequence for the data fields contained in the signed portion s of the message. The canonical byte sequence is computed from the field values not from the encoding of the field values. Each profile preferably defines the algorithm used to compute the canonical byte sequence of the fields for each message type.

A profile of the bootstrap protocol is a set of choices for the various cryptographic ciphers and serialization formats. Each profile preferably has a unique name and includes choice of 

This Appendix B presents the XML encoding of objects in one embodiment of a system using the example Octopus DRM engine described elsewhere herein. For a particular application an application specific XML schema can be created by importing the XML schema shown below the Octopus XML Schema and adding elements specific to the application e.g. extensions used for revocation . In one embodiment the encoding of objects in XML need to be able to be validated against the application specific XML schema. Additional possible constraints on these XML encodings can be found below.

In the example illustrated in this Appendix B the base XML Schema Type for all the DRM objects is OctopusObjectType. This means that all the objects support attributes and extensions. The type of each Octopus object element is derived from this base type. These types may aggregate other elements such as the SecretKey element for the ContentKeyType for instance.

In this example embodiment the Scuba key distribution system keys are described in terms of an extension the ScubaKeys element will then be a child of the extension element. The same applies for revocation keys with the Torpedo extension.

As described elsewhere herein there are different kinds of Octopus Objects e.g. ContentKey Protector Controller Control Node and Link . These objects can be bundled together along with extensions using the element. In one embodiment if objects or extensions are signed within the the will contain elements as described elsewhere herein.

In one embodiment nodes contain keys e.g. in Extensions such as ScubaKeys and it is necessary to be able to separate the public information of the node e.g. the id attributes and public keys and its private extensions that will e.g. carry the secret and private keys . Moreover there will be one signature per part the public and the private so that the public node with its signature can be exported as is as a parameter of the request to the license service for example .

In one embodiment the private extensions will be carried in an ExternalExtension and signed. The public node and its private extensions can be packaged in the same element or can arrive separately. An example of a signed Octopus Personality Node is given below in Annex A to Appendix B.

As shown in Annex A to this Appendix B in one embodiment Octopus personality nodes carry extensions for ScubaKeys both sharing and confidentiality keys and Torpedo broadcast secret key . Other types of nodes carry only Scuba sharing keys.

All the public keys are carried inside the element in an element in the . Other keys are carried in a separate element outside of the element.

In one embodiment the extensions are signed in the . In this embodiment the internal carrying inside the public keys will need to include a element as well as a element. The private keys carried in an external will need to be signed and this by signing the whole extension. Likewise the extension will be signed.

In one embodiment the and elements of the element contain only an element and no element. The element is optional. Annex C to this Appendix B contains an example of a signed link object.

In one embodiment links do not have mandatory attributes. This means that the is not required and will be ignored by a compliant implementation.

In the example embodiment shown in this Appendix B links have internal extensions carried inside the and thus the element is mandatory. In addition the extension in a link is not signed and thus no and element are carried inside the element. This extension contains an encrypted version of the private secret Scuba Sharing keys in a and a element of the To Node with the public or secret Scuba Sharing key of the From Node . This encryption is signaled using the XML encryption syntax. In the embodiment illustrated in this Appendix B the encoding attribute of the element child of the and elements is set to xmlenc . The child of this element will be an element. The name of the encryption key will be advertised in the element.

Annex C to this Appendix B provides an example of a signed license before the first revocation has occurred see the ContentKey section below .

In the example embodiment shown in this Appendix B the element and the elements e.g. inside the element contain only an element and no element. In this illustrative embodiment Protector objects contain no mandatory attributes or extensions the and elements are optional and will be ignored.

In the example embodiment shown in this Appendix B ContentKey objects contain no mandatory attributes or extensions. Therefore the and elements are optional and will be ignored.

In one embodiment elements contain a element which represent the actual key that will be used to decrypt the content. The associated with the is encrypted. In one embodiment it is mandatory that the encoding attribute of is set to xmlenc .

In one embodiment there are two distinct cases for ContentKey objects 1 Before the first revocation of a device or a PC application in this case the content key Kc represented by the element will be only encrypted by the Scuba key public or secret of the entity the content is bound to the user for example . 2 After the first revocation where the content key is encrypted according to the Mangrove broadcast encryption scheme. The resulting data is then encrypted with the Scuba key public or secret of the entity the content is bound to. In this case we have super encryption.

Illustrative methods for encrypting the element in case of super encryption are described elsewhere herein. The following explains how to apply this to case b.

In one embodiment the xmlenc syntax for the encryption of the content key Kc with the Mangrove Broadcast Encryption scheme is 

In one embodiment the byte sequence of the referred to above is encrypted with the scuba sharing key public or secret of the entity the license is bound to. If the public key is used then the same conventions apply as the one described in below e.g. see encrypting with a public key and an intermediary key is needed if the byte sequence of the is too big for a RSA public key. An example of the XML encoding of such a ContentKey object can be found in Annex D to this Appendix B.

In one embodiment controller objects contain no mandatory attributes or extensions. Therefore the and elements are optional and will be ignored by a compliant implementation.

In one embodiment the value of the Algorithm attribute of the elements is always http www.w3.org 2000 09 xmldsig sha1.

In one embodiment the must have a element. The element must contain the base64 encoding of the digest of the referenced control.

In one embodiment if the signature over the Controller is a PKI signature rsa sha1 the elements within the elements need to include a element and the element must contain the digest of the plain text content key embedded in the ContentKey object.

In one embodiment control objects contain no mandatory attributes or extensions. Therefore the and elements are optional and will be ignored by a compliant implementation.

In one embodiment the type attribute of the element is set to plankton and the byteCodeType attribute of the element is set to Plankton 1 0. 

This Appendix C shows an example of simple profile for use with the bootstrap protocol described above. Also provided are a simple canonical serialization an example XML marshalling and example WSDL for the Octopus Bootstrap SOAP Web Service.

In one embodiment the simple canonical byte sequence used in the simple profile described above consists of constructing sequences of bytes from the values of the fields of the objects in the messages. Each message and each object is made of one or more fields. Each field is either a simple field or a compound field.

Simple fields can be one of four types integer string byte sequence or arrays of fields. Compound fields consist of one or more sub fields each sub field being simple or compound.

In one embodiment the rules for constructing the canonical byte sequence for each field type are as follows 

The canonical byte sequence is the concatenation of the canonical byte sequences of each sub field optional fields are not skipped but serialized according to the rule for optional fields .

The field count encoded as a sequence of 4 bytes in big endian order followed by each field s canonical byte sequence. If the field count is 0 then nothing follows the 4 bytes field count in this case all 4 bytes have the value 0 .

The string is represented by a UTF 8 encoded sequence of 8 bit bytes. The byte count of the encoded byte sequence is encoded as a sequence of 4 bytes in big endian order. The byte count is followed by the sequence of bytes of the UTF 8 encoded string.

The byte count is encoded as a sequence of 4 bytes in big endian order if the byte sequence is empty or the corresponding field has been omitted the Byte Count is 0 and no byte value follows the 4 byte byte count . Each byte is encoded as is.

An encoding neutral way of computing a canonical byte sequence CBS for objects is presented below and used in preferred embodiments in the calculation of digests for use digitally signing objects. This byte sequence is independent of the way the objects are represented or transmitted thus enabling the same digest and signature values to be used throughout systems in which multiple encoding formats e.g. XML ANS1 programming languages or the like are used.

The canonical byte sequence algorithm consists of constructing sequences of bytes from value of fields. Each field has a value with a simple type or a compound type. Some fields can be specified to be optional the field may be present or omitted .

Compound types consist of one or more sub fields each sub field having a value with a simple or compound type. Compound types are either heterogeneous or homogenous meaning that there are one or more sub field values simple or compound of different types i.e. heterogeneous or that there are one or more sub field values simple or compound all of the same type homogeneous .

The canonical byte sequence of a field is obtained by applying the encoding rule to the field s value when the field is always present or the encoding rule for optional fields when the field is specified to be optional. In the following encoding rule descriptions the term byte means an 8 bit value octet 

If an optional field is present its value is serialized as the byte value 1 followed by the canonical byte sequence of the field value. If it is omitted its value is serialized as the byte value 0.

The canonical byte sequence is the concatenation of the canonical byte sequences of each sub field value optional fields are not skipped but serialized according to the rule for optional fields .

The canonical byte sequence is the sub field count encoded as a sequence of 4 bytes in big endian order followed by the concatenation of each sub field value s canonical byte sequence. If the sub field count is 0 then nothing follows the 4 bytes field count in this case all 4 bytes have the value 0 .

Strings are represented by a UTF 8 encoded byte sequence not null terminated . The canonical byte sequence for a string consists of 1 the byte count of the string encoded as a sequence of 4 bytes in big endian order followed by 2 the sequence of bytes of the string.

In one embodiment the canonical byte sequence for an Octopus object is the concatenation of the canonical byte sequences of each of its fields in the order they are defined in the object model.

For heterogeneous compound types the order of the fields is the one specified in the type definition. For homogeneous compound types the order of the elements is specified in the following paragraphs.

An object s attributes field is treated as an unnamed attribute of type list it is an unsorted container of named attributes . Named attributes contained in the value of attributes of type list are sorted lexicographically by their name field. Unnamed Attributes contained in the value attribute of type array are not sorted they are serialized in their array order .

An object s internal extensions are sorted lexicographically by their id field. In one embodiment for internal extensions the extensionData field is not used in the computation of the canonical byte sequence. For such extensions if they need to be included in the computation of a digest for the purpose of a signature they will contain a digest field that will represent the digest of the actual data carried in the extensionData . For each type of extension data a definition will be given that allows the computation of its canonical byte sequence.

The keys in the publicKeys privateKeys and secretKeys fields are sorted lexicographically by their id field.

The canonical byte sequence of an instance of class B where a 7 8 9 s Abc x 5 4 s2 and optional x is not present is serialized as 

An example of a control program is provided below. In this example the license indicates that the play action can be granted if the membership state provisioned during registration or the license state provisioned during a license transfer can be found in the state database referred to as the Seashell database in this example embodiment . The license also allows a peer to request a license transfer. This transfer will be granted if the two peers are in a given proximity. The license contains an agent that will set the license state on the peer.

In the code files that follow MovableDomainBoundLicense.asm is the main control LicenseUtils are helpers for the license GenericUtils are generic helpers that perform functions such as computing the length of a string comparing strings manipulating the stack and or the like and ExtendedStatusBlockParameters contains an XML description of an extended status block parameter and the corresponding representation as a series of bytes compiled from the XML.

Although the foregoing has been described in some detail for purposes of clarity it will be apparent that certain changes and modifications may be made within the scope of the appended claims. It should be noted that there are many alternative ways of implementing both the processes and apparatuses described herein. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the inventive body of work is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

