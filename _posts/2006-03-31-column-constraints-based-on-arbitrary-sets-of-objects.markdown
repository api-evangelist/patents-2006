---

title: Column constraints based on arbitrary sets of objects
abstract: Techniques for using arbitrary sets of objects to constrain objects in database systems. The constraint set of objects is associated with the constrained object in the database system and the database system will perform an operation which adds an object to the constrained object only if the object being added belongs to the constraint set. In a preferred embodiment, the techniques are employed to obtain constraint sets of terms from ontologies which are then used to constrain columns containing those terms. An implementation of the techniques makes a materialized view out of the objects in the constraint set and uses the materialized view to define a referential integrity constraint on the constrained column.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08214354&OS=08214354&RS=08214354
owner: Oracle International Corporation
number: 08214354
owner_city: Redwood Shores
owner_country: US
publication_date: 20060331
---
U.S. Ser. No. 10 916 547 System for ontology based semantic matching in a relational database system which has the same inventors and assignee as the present patent application and U.S. Ser. No. 11 108 204 Integrating RDF data into a relational database system which has the same inventors and assignee as the present patent application are hereby incorporated by reference into this patent application for all purposes.

The present invention relates generally to database management systems and more particularly to techniques for defining constraints on columns in database management systems.

Relational database systems have become increasingly robust with many features that insure the integrity of the data stored within the columns of tables of a database instance. The means of ensuring the integrity of data are a set of business rules defined by the application developer and are referred to as Integrity Constraints in the database system.

There are many types of integrity constraints the most relevant type for the present discussion is referential integrity constraints. A referential integrity constraint is a constraint which maintains consistency between coupled tables. A value from a key column in a first one of the coupled tables is used as a value in a non key column of a second one of the coupled tables. The value from the key column is termed the parent key the key value in the non key column of the other table is termed the foreign key. A referential integrity constraint requires that every foreign key value in the non key column of the second table have a value which is equal to the value of one of the keys in the key column. A consequence of the rule is that when keys are added to or deleted from the key column in the first table there may be effects on the foreign key values in the second table. The rules for dealing with these effects are 

Tables and are coupled by a referential constraint as shown by arrow . The primary key values in column DNAME are parent keys. The foreign keys which have the values of the parent keys are values in column DNAME . The referential integrity constraint guarantees that every value in the column already exists as a value in the column . Because of the constraint the relational database system handles inserts in a manner that ensures data integrity. Insert violates the referential integrity constraint in that the value MARKETING for the column DNAME cannot be found in the rows of column . The referential integrity constraint further enforces rules concerning what occurs in EMP table when a row containing a DNAME has the corresponding row deleted from DEPT table .

What a referential constraint does in general terms is constrain DNAME column such that all of the values in DNAME column must be selected from the set of values defined by the values of DNAME column . There are many contexts other than parent keys and foreign keys where it would be desirable to constrain a column such that the values in the column had to be selected from a dynamic set of values that is a set of values whose member values were not known until the time the constraint was enforced. In the following such constraints will be generically termed dynamic set constraints. At present the only dynamic set constraints which are supported in relational database systems are referential constraints. It is an object of the invention disclosed herein to provide a relational database system which supports other kinds of dynamic set constraints.

One kind of dynamic set constraint which is particularly useful is one in which the dynamic set is a set of terms that belong to a domain in an ontology. For purposes of the following discussion ontology and domain are defined as follows 

As will be explained in more detail below a set of departments defined in the ontology may be used as a constraint on column DNAME or on column DNAME . For example if EMP table were a table of engineering employees column DNAME could be constrained such that a row for an employee could be added to the table only if his or her department was Engineering Software or Hardware.

Within the RDBMS an ontology can be represented using Resource Description Framework RDF . RDF is a language that was originally developed for representing information metadata about resources in the World Wide Web. It may however be used for representing information about absolutely anything including ontologies. U.S. Ser. No. 11 108 204 Integrating RDF data into a relational database system discloses how this may be done.

U.S. Ser. No. 11 108 204 discloses the integration of RDF into SQL by means of a set of tables and user objects that represent RDF data sets and a table function RDF MATCH that takes a specification of an RDF data set and an RDF pattern as parameters and returns a set of result rows of triples from the RDF data set that match the RDF pattern. The solution of the RDF pattern may include inferencing based on RDFS and user defined rules.

It should be noted that the contents of the result rows returned by RDF MATCH will depend on the RDF pattern used in the query and the RDF data against which the query is run. For this reason the return type for RDF MATCH has been defined as AnyDataSet which is a collection of tuples of a generic type called AnyData. When an SQL query employs the RDF MATCH table function components of the query such as its SELECT WHERE ORDER BY etc. clauses can reference the variables present in the RDF pattern simply by the variable names.

An advantage of using the RDF MATCH table function in a SELECT statement to query RDF data is that any SQL construct that can be used with a SELECT statement can be used to further process the result rows returned by RDF MATCH. These constructs include iterating over the result rows aggregating values contained in the result rows constraining the result rows using WHERE clause predicates sorting the result rows using ORDER BY clauses and limiting the result rows by using the ROWNUM clause. Also the SQL set operations can be used to combine result sets of two or more invocations of RDF MATCH. In SELECT statement the WHERE clause limits the triples to those for students whose age is less than 25. The output of the SELECT statement is shown at .

An Ontology can be accessed using the new SQL operators disclosed in U.S. Ser. No. 10 916 547 System for ontology based semantic matching in a relational database system. The new operators are named ONT RELATED ONT EXPAND ONT DISTANCE and ONT PATH. These operators may be used directly in SQL statements and thus allow database users to combine these semantic matching operators with other conventional SQL operations such as joins to make use of the full expressive power of SQL while performing semantic based matching. Prior to executing a query containing the semantic matching operator the specified ontology is expressed in RDF and represented in the database system as described in U.S. Ser. No. 11 208 204. The operators explained using ontology of are the following 

The ONT RELATED operator performs ontology based semantic matching and is expressed within an SQL statement using an expression of the form ONT RELATED term1 reltype term2 ontology . When executed the ONT RELATED operator determines whether the two input terms term1 and term2 are related by the specified relationship type reltype by consulting the ontology. Thus ONT RELATED Software subDepartmentOf Management Department Ontology will return TRUE because the subDepartmentOf relationship modeled using subClassOf property is transitive and consequently if Software is a subdepartment of Engineering and Engineering is a subdepartment of Management then Software is a subdepartment of Management as well.

Two ancillary operators ONT PATH and ONT DISTANCE are employed to determine additional measures for pairs of terms belonging to the ontology namely the shortest path connecting two terms and the length of the shortest path respectively.

This operator returns rows representing a set of terms in the ontology. The terms to be returned are indicated by parameters that specify a first term a second term and a relationship between the first and second term. The specified relationship may be either a simple relationship or combination of them. The following is an example of the operator s declaration 

Typically non NULL values for RelType and Term2 are specified as input and then the operator computes all the appropriate tuples in the closure taking into account the characteristics transitivity and symmetry of the specified RelType. In addition it also computes the relationship measures in terms of distance TermDistance and path TermPath . For cases when a term is related to input term by multiple paths one row per path is returned. It is also possible that ONT EXPAND invocation may specify input values for any one or more of the three parameters or even none of the three parameters. In each of these cases the appropriate set of tuples is returned.

The term1 reltype and term2 can have either a specific input value or NULL value. The NULL means all possible values. For example ONT EXPAND NULL subDepartmentOf Engineering Department Ontology will generate all nodes that are related by the subDepartmentOf relationship to the node Engineering namely the nodes Software and Hardware.

Objects of the invention include providing techniques for defining column constraints in terms of arbitrary sets of values and providing techniques for dealing with the effects of changes in the set of values used to define the constraint on the values in the column subject to the constraint as well as providing techniques for defining column constraints in terms of sets of values obtained by queries on ontologies.

The objects of the invention are obtained by a technique that is used in the database system to associate a constrained object with an arbitrary constraint set of objects that are possible values of the constrained object. When an operation in the database system adds a value to the constrained object the operation is permitted only if the added value is a member of the constraint set. The constraint set may be specified by a query that is executed in the database system. The query may include a table function.

In one aspect the technique employs referential integrity constraint mechanisms provided by the database system. The constrained object is a column that is defined in the database system. The technique makes a materialized view with a column whose values are members of the constraint set and then uses the materialized view to define a referential integrity constraint for the constrained column.

In another aspect when an operation in the database system results in a new constraint set a variety of responses may be specified when the constraint set is associated with the constrained object. Operations that alter the constraint set may be barred or the database system may change values in the constrained object when the constraint set is altered. Changes may include setting a value which is in the constrained object but not in the new constraint set to NULL setting it to a default value and using a transform function to transform a value which is not in the new constraint set into a value which is in the new constraint set. The transform function may return a number of possibilities for transforming a value which is not in the new constraint set. In that case the techniques permit user selection of one of the possibilities.

The constraint set may be derived from any source of objects however in one species of the invention the constraint set is a set of terms from an ontology. The query that is used to obtain the constraint set from the ontology returns terms that stand in a defined relationship to each other in the ontology and the constraint set is used to limit terms in a keyword column to terms that belong to the part of the ontology that was returned by the query.

Other objects and advantages will be apparent to those skilled in the arts to which the invention pertains upon perusal of the following Detailed Description and drawing wherein 

Reference numbers in the drawing have three or more digits the two right hand digits are reference numbers in the drawing indicated by the remaining digits. Thus an item with the reference number first appears as item in .

The following Detailed description will first present an overview of a species of the invention in which the set of objects that is used to constrain the column is obtained from an ontology and will then present details of a preferred embodiment of the species. In the following the species will be termed an ontology based referential constraint .

Traditional referential integrity constraints are specified by SQL syntax of the form REFERENCES where is a foreign key and contains parent keys in . The database system ensures that the only contains values that are also present in .

While ONT EXPAND provides a useful functionality its parameters are limited to expressing an RDF pattern that contains a single triple. The RDF MATCH table function can be used for RDF patterns containing more than one triple. For example assume that a user of a database system wants to create a journal article table for journal articles concerning macromolecules. The table will have a row for each journal article. The table s columns will include a column whose values are keywords for the classes of chemical compounds that the articles are written about such as Proteins and Polypeptides . The values contained in the column chemical compounds are to be taken from terms which are subclasses of the class Macromolecules in the Pathway Genome ontology BioCyc see www.biopax.org.

SQL statement creates an ontology based referential constraint which limits the terms used in the column chemical compound to terms which are in fact subclasses of the class Macromolecules in the ontology. The referential constraint s SELECT clause uses the RDF MATCH table function with an RDF pattern consisting of a single triple that returns all terms that are subclasses of Macromolecules.

If the user wants to further restrict the column to compounds that are subclasses of both the class Proteins and the class Complexes the user may issue a query like query . There the RDF pattern used in RDF MATCH at contains two triples. The terms that satisfy the pattern are terms that are subclasses of both Proteins and Complexes . In the following a column which is subject to dynamic set constraint such as an ontology based referential constraint will be termed a constrained column and the set of objects which constrains the values in the constrained column will be termed the constraint set. Though the constraint set may come from any source it is typically the result of a query.

A na ve implementation of an ontology based referential constraint is inefficient in that each insert or update of a value in a column that is subject to the ontology based referential constraint requires the execution of a query on the ontology to produce a constraint set from which the database system may determine whether the inserted or updated value violates the constraint. To allow for more efficient processing of inserts and updates subject to ontology based referential constraints a materialized view is used to store the constraint set in persistent storage.

In a relational database system the execution of a SELECT statement returns a table containing the results of the query defined by the SELECT statement. The table returned by the query is termed a view. Ordinarily a view is stored in non persistent storage. A materialized view is a view whose data is stored in persistent storage. Because the materialized view is stored in persistent storage the materialized view has an entry in the database system s data dictionary and the values in a column of the materialized view may serve as parent keys for a standard referential constraint.

Constraint enforcement diagram shows how a materialized view and a standard referential constraint may be used to implement an ontology based referential constraint. Keyword column is constrained by an ontology based referential constraint . Ontology based referential constraint executes a query against ontology . The result set returned by the query is the ontology based referential constraint s constraint set. The constraint set is made into a materialized view . The materialized view is a table with a single column that contains the values of the constraint set. A conventional referential constraint is then defined for keyword column in which the terms in the single column of the materialized view are the parent keys for the terms in keyword column . Conventional referential constraint is then enforced on keyword column in the usual fashion Whenever a new value appears in keyword column conventional referential constraint is enforced based on the contents of materialized view . As will be explained in more detail later Journal Table records changes to materialized view . It is used when ontology is modified.

It should be pointed out here that the technique of is general and can be used to implement any kind of dynamic set constraint. All that is required is a mechanism for making the values of the dynamic set constraint s constraint set into an RDBMS view. Once that has been done the view can be materialized and the dynamic set constraint can be implemented using the conventional referential constraint.

When an ontology that provides constraint sets is modified the constraint sets may get modified as a result and then to maintain the referential integrity constraints changes may need to be made to the columns that are constrained by the constraint sets. The present invention provides techniques for handing any such changes that may become necessary due to modifications to constraint sets caused by modifications of ontology data. The techniques are supported by extensions to the SQL statements that define ontology based referential constraints which permit the user to define actions to be performed on values in the constrained column when modification of the ontology results in constraint set modification. These extensions have the form 

Ontology based referential constraint definition is referential constraint definition with the addition of the ON DELETE clause . Clause specifies that on deletion of an element from the constraint set caused by modification to Department Ontology a value in the column DNAME in the user table EMP which is the same as the value that is being deleted from the constraint set will be replaced with a NULL value. EMP table contains a number of records where the DNAME column contains the value Manufacturing belonging to the constraint set. A delete from ontology of the MANUFACTURING department will result in deletion of the MANUFACTURING department from the constraint set and this will cause the clause to be executed. The execution will search for the value MANUFACTURING in the column DNAME of user table EMP and set them to NULL as shown at in updated EMP table .

Referential constraint definition is a version of referential constraint definition wherein ON DELETE TRANSFORM clause is being used to specify that a function find broader term be executed on a deletion from the constraint set caused by a modification of Department Ontology . Function find broader term finds a term which is still in the ontology and which is broader than the deleted term. The function is defined at line and receives as input arguments O R and dterm. Ois the ontology prior to modification. Ris the constraint set after modification of the ontology and dterm is the value of the deleted value. Function find broader term starts at line by applying the deleted term to the constraint set O starting from the position of the deleted term in Oand moving up Ountil it finds a broader term that is in R. The function returns a result set of the nearest ancestors in Rof the value deleted from the ontology . The returned result set could be NULL indicating no replacements could be found or a possibly singleton subset of R. If a single replacement value is returned by the function then the actual replacement can take place automatically updating table . Otherwise the set of replacement values may be stored in recommendation table .

Using ontology as an example deleting the Quality Assurance department from the ontology leads to deletion of that term from the constraint set and that results in a search for broader terms. The search would return the next broader term which is MANUFACTURING to replace Quality Assurance in updated EMP table . If more than one possible term were returned by the function for example if Quality Assurance reported to more than one department perhaps MANUFACTURING then the two possible changes would be inserted into recommendation table .

Changes to the ontology may cause insertion of terms into the constraint set and this may also cause a search for recommendations to replace current data. For example if two new departments are added to Department Ontology under Hardware that results in addition of those two departments into the constraint set then a recommendation based on results returned by find refined term of referential constraint definition is executed. The addition of the two new departments causes recommendation table to have the two departments Board Design and Chip Design added as possible new values of the DNAME column in the row for employee who was previously listed as belonging to Hardware.

Modifications of ontologies and the resulting modifications to the values in the constrained column can be done either in batch or incrementally. Batch modification of the values of the constrained column in response to a modification of the ontology is termed in the following batch enforcement of the constraint. In batch enforcement the ontology based referential constraint is disabled during batch enforcement and reenabled thereafter. With incremental enforcement of the constraint enforcement remains enabled but is deferred until changes to the ontology are committed.

For batch enforcement additional processing is needed for both DISABLE and ENABLE constraint operations. The details are described below.

DISABLE constraint When the ontology based constraint is disabled a copy of current materialized view is created. The copy is subsequently used to identify changes in the constraint set resulting from the modification of the ontology. Also saved is current version information for the ontology.

ENABLE constraint Let R be the copy of materialized view made when the constraint was last disabled and R be the current constraint set. We determine the set of deleted terms using the following query 

If the constraint has a transformation function associated with it the transformation function is invoked for the deleted terms and the ontology version that existed when the constraint was disabled. If the transformation function yields a single result T for a deleted term T then update all instances of Tin the constrained column to T. If the transformation function yields either no terms or multiple terms then the ROWIDs of all rows in the table with the constrained column in which the value in the constrained column is equal to Tare recorded in the recommendations table along with the transformation function results before all instances of Tin the keyword column are updated to NULL. If the constraint does not have a transformation function then all instances of Tin the keyword column are updated to NULL.

R the copy of materialized view made prior to the modification of ontology is shown at . Then ontology is modified by removing the department Hardware is removed from ontology . The result of the query of modified ontology produces constraint set which is the constraint set represented by R. The difference of R and R is result set which contains the deleted term Hardware. If the transformation function find broader term is passed result set it produces a single new term namely Engineering . Table EMP s DNAME column is now constrained by result set R . Consequently in each row of table EMP which has the term Hardware in the column DNAME Hardware is replaced with Engineering .

Similarly to determine the effect of insertions into the ontology on the constraint set the following query is used.

If the constraint has a refinement function we invoke it for these terms. The refinement function s results are stored in the recommendations table.

Finally the underlying conventional referential constraint is enabled. If the underlying constraint had an EXCEPTIONS clause a clause which specifies a table into which constraint violations may be written the clause is appended to the end of the constraint creation and has syntax of 

This method can also be used as part of a protocol to enforce the constraint during incremental ontology modifications. In this case the constraint would be disabled before the modification is started and enabled after the modification is completed.

When the materialized view changes incrementally along with incremental changes in the ontology the conventional referential integrity constraint enforcement between the constrained table and the materialized view is altered to a deferred constraint i.e. a constraint that s enforced only at transaction commit time with ON DELETE SET NULL semantics. With a deferred constraint spurious constraint violations during transient states that may exist as the materialized view changes are avoided.

Row level triggers on the materialized view journal all changes in the constraint query result set to temporary journal table . A row level update trigger on the constrained column is used to write orphaned values and their row s rowid to the recommendation table when the ON DELETE SET NULL behavior specified in the constraint definition sets an orphaned value to NULL. If a keyword is updated to null by explicit Data Manipulation Language DML this trigger will log the keyword and its rowid to the recommendation table however since there is no ontology update in this case the update will not be further processed by the constraint s refinement or translation mechanisms .

After the ontology has been modified i.e. after changes to the underlying ontology tables have committed journal table is processed to remove idempotent operations e.g. a term may be deleted and reinserted during materialized view maintenance . Then the appropriate calls are made to the constraint s refinement and transformation functions based on the remaining operations and the results are propagated to the constrained column and the constraint s recommendation table.

To address these problems we propose introducing AFTER REFRESH and AFTER REFRESH ERROR triggers on materialized views. Such triggers would run as part of the transaction that refreshes the materialized view.

The techniques described above for modifying the ontology making a new materialized view from a query on the ontology and altering values in the constrained column as required by the new materialized view can be applied with regard to constraint sets that are obtained in any way. Appropriate mechanisms will be of course required to obtain the constraint sets. For example if the constraint set is obtained by a query executed in the database system the proper query must be provided. Different sources for constraint sets will also require different transformation functions or no transformation functions at all.

The foregoing Detailed Description has disclosed to those skilled in the relevant technologies how to employ arbitrary sets of objects as constraints in database systems and has further disclosed the best mode presently known to the inventors of making constraints that use arbitrary sets of objects. While the specific example set forth in the Detailed Description employs constraints based on ontologies the technique is very general and can be used with any set of objects that are accessible to a database system. To give an example of the generality of the techniques the set of objects could be obtained via a table function that received the objects from a user of the database system.

While the techniques are very general the preferred embodiment is implemented in an Oracle relational database management system and the character of many of the specific features of the preferred embodiment is determined in considerable part by the fact that they are implemented in a specific relational database system. Implementations of the techniques in other database systems including non relational database systems will necessarily be determined by the characteristics of the database systems in which they are implemented. An apparatus includes a processor and a storage device as a storage medium.

For all of the foregoing reasons the Detailed Description is to be regarded as being in all respects exemplary and not restrictive and the breadth of the invention disclosed here in is to be determined not from the Detailed Description but rather from the claims as interpreted with the full breadth permitted by the patent laws.

