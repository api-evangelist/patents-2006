---

title: Method and system for providing a common structure for trace data
abstract: A method for providing a common structure for trace data is disclosed. In one embodiment, the method includes generating non-compatible trace data at a first provider, converting the non-compatible trace data into a first compatible trace data, generating a second compatible trace data at a second provider, and storing the first compatible trace data and the second compatible trace data as common trace data at a database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08037458&OS=08037458&RS=08037458
owner: SAP AG
number: 08037458
owner_city: Walldorf
owner_country: DE
publication_date: 20060929
---
Embodiments of the invention generally relate to the field of tracing. More particularly the embodiments of the invention relate to providing a common structure for trace data.

As application development projects are growing larger tracing is becoming increasingly important. Tracing can be a very useful tool used primarily by software developers to isolate problems for example by tracking execution of program code. For example when developing an application developers trace the execution of methods or functions within certain modules to identify problems and or to determine if the program code may be improved. If a particular method takes an inordinate amount of time to complete the developer may determine the reasons why and or change the program code to operate more efficiently.

Trace tools are proprietary application programs which use different techniques to trace the execution flows for an executing program. One technique referred to as event based profiling tracks particular sequences of instructions by recording application generated events as they occur. By way of example a trace tool may record each entry into and each exit from a module subroutine function method or system component within a trace file e.g. a time stamped entry may be recorded within the trace file for each such event . Trace events may also be sent to a console or other output destination.

Conventional trace tools however are limited with tracing data from various systems i.e. when dealing with tracing data of various structures. For example conventional trace tools do not provide for integration of various trace files of different structures relating to different corresponding systems. This often leads to at best delay in reading of errors as the data has to be manually read and at worst misreading of errors or even loss of trace data. Tracing is particularly cumbersome when a development project involves a great number of systems applications components modules developers and or multiple interfaces and services.

According to one embodiment a method for providing a common structure for trace data is disclosed. The method includes generating non compatible trace data at a first provider converting the non compatible trace data into a first compatible trace data generating a second compatible trace data at a second provider and storing the first compatible trace data and the second compatible trace data as common trace data at a database.

Other embodiments are also disclosed. Further the above attributes may be implemented using a computer program a system or an apparatus or any combination thereof. These and other details of one or more embodiments of the present invention are set forth in the accompanying drawings and in the description below.

As used herein references to one or more embodiments are understood as describing a particular feature structure or characteristic included in at least one implementation of the invention. Thus phrases such as in one embodiment or in an alternate embodiment appearing herein describe various embodiments and implementations of the invention and do not necessarily all refer to the same embodiment. However they are also not necessarily mutually exclusive. Descriptions of certain details and implementations follow including a description of the figures which may depict some or all of the embodiments described below as well as discussing other potential embodiments or implementations of the inventive concepts presented herein.

In one embodiment CPT architecture provides a mechanism for persisting and analyzing performance traces from various monitored systems . A performance trace refers to a special trace type that deals with performance issues of applications and program codes such as like call durations call stacks memory consumption amount of transferred data and the like. CPT architecture may consist of common data format trace data providers central analysis services generic reports and the like. CPT architecture further provides a library that provides one or more APIs e.g. CPT API to give access to CPT files and database . A CPT API refers to an interface that allows for generation and persistence of performance trace data which complies with the CPT format that is provided via CAS and stored at CPT database and manages various CPT processes as discussed elsewhere in this document. In one embodiment a trace correlator is employed at CAS . A trace correlaor includes an object that is used to analyze trace records which are obtained from different software components physical locations e.g. hosts and at different times. A trace correlator helps define a semantic group which is useful to understand how various traces belong together. Also distributed statistics may be used that refer to a minimum performance trace which continuously runs with a running system such as monitored systems . It may be aggregated offline to statistical aggregates and analyzed with respect to performance accounting hardware sizing system usage profiles and the like.

CAS is in communication with client . CAS includes Mbean server that is registered with CAS . Further display application or user interface UI e.g. WebDynPro Runtime is employed. In one embodiment a program code is instrumented that creates trace data supplier to write performance trace data via CPT API to database . Trace model that is in communication with Mbean server and database allows accessing of trace data at database via UI by providing a merged trace data received from multiple monitored systems via corresponding trace data importers located at central data provisioning . Trace model also provides for filtering and aggregation of trace data. To allow for proper access and analysis of trace data originating from multiple sources the trace data is converted into a common format or structure e.g. CPT format CPT structure etc. and provided to the user via client further via UI .

Various modules and components are employed at monitored systems to facilitate tracing and for collection processing and exporting of trace data. For example J2EE monitored system includes trace file storage and server node which includes trace data supplier model provider writer API and Mbean server . In one embodiment model provider is implemented as MBean registered to the local system MBean server and allows the accessing of trace data from CAS . Trace file storage is referred to as a CPT file that serves as a temporary storage for trace data at monitored system . Trace data supplier is a source of trace data while write API provides a CPT API for trace data writing and serves as a CPT tracer.

ABAP monitored system include a Computer Center Management System CCMS agent that allows CCMS to access trace data for the local ABAP system . The trace data is provided to CCMS agent via trace file provider and stored at trace file storage and received using work process . The trace data is retrieved from ABAP monitored system and exported to CAS by performing RFC calls to CCMS via CCMS agent . The trace data is imported at CAS via ABAP CCMS importer and then stored at database . In one embodiment a number of systems can be monitored and trace data from such systems may be provided to CAS so that it can then be converted into and provided as a common CPT structure trace data for access and analysis by client . For example a third party monitored system is illustrated that includes various third party compatible functional modules and components to collect trace data and provide it to CAS . Such modules may include a third party trace data writer a third party agent and a third party trace storage to perform their respective functions as with modules and components at other monitored systems . Further a third party importer at CAS is employed to import trace data from the third party monitored system .

In one embodiment CPT architecture provides a CPT format and correlation. The CPT format may be common interface model CIM compliant and provides a common format to perform traces to 1 define the type of data that is needed to analyze performance and or functional problems 2 allow for common central storage of trace data at database which provides a common mechanism for persistence management and analysis and 3 provide for correlation. Correlation allows for grouping e.g. correlating of trace records that belong to a single logical transaction by introducing a correlation which is an abstract object. CPT architecture further provides for selective and centralized switch of tracing data for involved components and traces types and structures. In one embodiment the CPT reports of trace data may be implemented using UI application framework such as the WebDynpro framework. The trace data is stored at database using trace model implemented as Mbean and registered with Mbean server of CAS . Trace model provides trace data both as race trace records and aggregated data.

In one embodiment a user activity triggers requests that are processed by various components at monitored systems and CAS . For example a web request from client is sent to a J2EE application server associated with J2EE monitored system . Similarly a request may be sent to other system such as ABAP system and any other third party system . Components at various systems produce different traces appropriate for analyzing several functional and performance problems. Abstract correlator objects are introduced to allow end to end analysis of applications and user activities that are processed by components running at various systems . Such correlator objects provide for combining performance and trace data from different origins such as different system 2 serializing the trace data over a network and transferring the trace data to CAS via the metadata of various communication protocols and 3 providing the trace data via a common structure to provide performance activities of applications program codes and user activities that are being monitored and analyzed.

CPT API enables the currently existing functionalities in tracing e.g. SQLTrace . Such functionalities include 1 reading trace data in an appropriate format for the corresponding application e.g. OpenSQLMonitors application 2 writing a trace record together with metrics is an atomic operation 3 allowing the writing of trace data to a non database storage and allowing the writing of trace data at server startup. Objects associated with CPT API that are used for direct instrumentation of a trace data provider include 1 a factory object e.g. CPTFactory that is responsible for generating CPT provider objects via configuration 2 a provider object e.g. CPTProvider which is used by the instrumented code to provide a lookup action and metric definition objects that are defined in the configuration thus identifying a single trace data provider 3 a record object e.g. CPTRecord that is used as a main entity to be persisted via CPT API . Record objects contain performance information for measured action.

Each trace record that is received from various providers e.g. monitored systems is then configured to a common structure e.g. CPT structure and is stored at database . A CPT trace record may contain any number of metrics. Such metrics are valued from the instrumented code at data providers e.g. monitored systems and are assigned to the CPT trace record by calling a particular API method such as an API addMetric method. If necessary a CPT trace record may be extended. CPT configuration may be separated in two parts static configuration and dynamic online configuration. The two configurations may be regarded as two different use cases. A static configuration file may be part of CPT API and used for such initialization of CPT API so it can be directly used by the data providers by having the static configuration contain default CPT writer settings. Static configuration is also used to predefine certain objects such as application layers system layers and database layers etc. Also the static configuration defines certain general metric definitions such as elapsed time central processing unit CPU time and memory allocation that are relevant for various types of performance traces. A dynamic configuration file is part of the component that provides performance trace data. The dynamic configuration file may contain provider specific configurations like actions and metric definitions.

In one embodiment CPT API is initialized by a J2EE engine service where the currently existing performance trace service is to be extended with various functionalities. The performance trace service provides various correlators such as a measurement correlator that is regarded as the main correlator and is used to group up trace records belonging to a certain measurement or trace. The measurement correlator is referred to as the parent correlator to other correlators that are additionally provided. Another correlator includes a J2EE Engine runtime info correlator that contains information about the corresponding J2EE Engine user session application. The origin of CPT trace records is at a monitored system such as at a node of a J2EE server associated with a J2EE system. To achieve a writing performance trace at server startup a default correlator is employed for each virtual machine VM . Default correlators may not contain any data relating to the monitored system. Further for each trace data provider or monitored system a default layer may be defined. The default layer is then automatically assigned to CPT trace records belonging to the corresponding trace data provider.

In one embodiment trace data from J2EE and ABAP systems is imported at CAS via various module and components such as a CPT API and importers e.g. CPT importer import module etc. . CPT importer is used to import data from J2EE monitored system and place it at database . The files having the trace data are first saved at file system before being imported into database . Import module may be used to import trace data from ABAP monitored system and from any other system such as the third party monitored system of and place it at database . For each ABAP trace a reader class may be generated to be used to form an importer API of the CPT library. ABAP system is in communication with trace manager via RFC connecter API . RFC connecter API serves as a proxy of RFC function modules and creates a general framework for connection to ABAP system . In addition to having and communicating with an ABAP system a CCMS system may also be added to CAS .

CAS further includes configuration module that contains methods for starting and stopping various trace activities and for keeping general information e.g. name start data end data filters etc. about such activities. Configuration module is in communication with configuration storage where configuration data is stored. When a HyerText Transfer Protocol HTTP proxy is used on the client side several XML files are generated as a result of that. These files are then uploaded to CAS and with the help of a file e.g. responses.trc file that is generated by an HTTP service. Such HTTP analysis are generated and imported to CAS via HTTP analysis module . Once trace activities are stopped and trace data form such activities are collected from monitored systems and imported into database the trace data may then be kept at analysis storage and analyzed by analysis module .

At decision block a determination is made as to whether the trace activity is to be deleted. If for any reason e.g. incorrect application being traced tracing data is correct etc. the trace activity at any given system is to be deleted at processing block it is deleted and the process ends at termination block . This is can be accomplished by the user via the UI. In case of multiple trace activities it is contemplated that one or more trace activities may be deleted while still performing one or more other trace activities. If the trace activity is not to be deleted the processing continues with collecting of trace data at the monitored system at processing block . When multiple trace activities are performed at multiple monitored systems the trace data collected from each of those monitored systems may be of format and structure. For example J2EE traces may be different in structure from ABAP traces. At processing block the trace data is imported to a central database that provides a common structure of all trace data. The trace data having different structures is imported and converted into a common structure for the user to access and analyze at the central CPT database. This import may be performed via a number of CPT APIs importers import modules temporary storages and other modules and components. The process ends at processing block .

In the illustrated embodiment the database storage of trace data is shown as having various modules records etc. For example a CPT compatible trace data format or structure contains a stream of six files such as 1 file origins 2 file metrics 3 file correlators 4 file metadata 5 file record correlator and 6 file records as further illustrated in . Each of the elements illustrated here are contained in one or more such streams of files. For example CPT metric definition which contains unique identification may be contained in file metrics but repeated in file origins. CPT origin includes a node from where a record e.g. CPT record originates. CPT origin is found in file metadata and when combined with the unique identification from CPT metric definition provides a global identification for the record . CPT module provides the name of the logical unit e.g. class name corresponding to the record originated. CPT module is contained in file metadata. CPT action which is in communication with CPT module provides the name e.g. method name of a module subsection which measures execution time.

CPT thread provides a unique identification of the thread executing the module. CPT thread is located in file metadata. CPT provider is a provider of the record and is contained in file metadata. Examples of trace data handled by a CPT provider include SATrace SQLTrace APPTrace etc. Based on the provider name the visualizer can use plug ins for additional processing. CPT record includes the record that is originated provided and used and is associated with other elements . CPT record resides in file records. CPT record may also include a parent identification which may be used when there is a nesting of trace records and may contain the identification of the parent record.

CPT metric is located at file metrics. CPT metric represents metrics having a set of name value pairs giving additional information about a call. For example CPT metric can describe a method call parameters or in case of a database call some database related values may be provided. These properties can be parsed by the visualizer to a provider specific plug in or merely can be used as a more detailed description of the record . Trace data structure further includes correlators such as CPT record correlator that resides at file record correlator CPT correlator that resides at file origins and CPT correlator definition that resides at file metadata. These correlators provide a value that defines and provides to which measurement or trace the record belongs. For each measurement a separate correlator may be defined.

Any CPT compatible data is first imported into file system which serves as a temporary storage for compatible data . This CPT compatible data is then imported from file system to database directly via CPT API . CPT API may include a generic CPT import module to deliver the compatible data from file system to database . However the non compatible data may not be directly imported into database as it may not be understood or recognize due to its non compatibility with the CPT based system and other CPT based data at database .

In one embodiment import module may be employed to understand the non compatible data and then import it from various systems to CPT API to further into database . In one embodiment trace data conversion module conversion module for data conversion is employed as part of import module and or provided as an additional functionality or module of CPT API . Conversion module is provided to perform conversion of non compatible data into data that is compatible with CPT and can be stored at CPT database . For example conversion module in converting the non compatible trace data provides to the non compatible trace data the missing functionalities components and modules e.g. file streams of compatible trace data . It is contemplated that import module may also be provided as part of CPT API along with CPT import module . Furthermore in one embodiment import module and or CPT API contains additional functionalities and modules such as an identification module to identify the non compatible trace data so that it is handled accordingly. Once the non compatible data is made compatible it is then imported into and stored at database along with other compatible data such as compatible data where it is provided in a single compatible CPT format and structure and is accessed and analyzed by users via clients and UIs.

Referring back to decision block in one embodiment if the data is not CPT compatible e.g. J2EE DSR ABAP SR from R3 systems XML files generated from other trace modules and systems it is imported via an import module to be converted into CPT compatible data and placed at the database at processing block . The non compatible trace data is made compatible at processing block . The conversion is performed using a trace data conversion module that is either part of the import module or is simply provided as an additional functionality of the CPT API. In either case the newly converted trace data that is now CPT compatible and is imported into the CPT database via the CPT API at processing block . At processing block access to trace data is provided.

In one embodiment to perform various embodiments of the present invention a server or node e.g. J2EE server is employed which supports Enterprise Java Bean EJB components and EJB containers at the business layer and Servlets and Java Server Pages JSP at the presentation layer . A virtual machine VM including a Java virtual machine JVM may be employed to host the server or server node. It is understood that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments Java based environments such as a J2EE environment or environments defined by other releases of the Java standard other environments e.g. a NET environment a Windows NT environment each provided by Microsoft Corporation and the like.

Processes taught by the discussion above may be performed with program code such as machine executable instructions which can cause a machine such as a virtual machine a general purpose processor disposed on a semiconductor chip a special purpose processor disposed on a semiconductor chip etc. to perform certain functions. Alternatively these functions may be performed by specific hardware components that contain hardwired logic for performing the functions or by any combination of programmed computer components and custom hardware components.

One or more modules within or associated with an enhanced configuration architecture such as common performance trace architecture of and its sub architectures and systems e.g. central administration system APIs e.g. CPT API and its modules models components and other elements may include hardware software and a combination thereof. In a case where a module includes software the software data instructions and or configuration may be provided via an article of manufacture by a machine electronic device hardware. An article of manufacture may include a machine accessible readable medium having content to provide instructions data etc. The content may result in an electronic device for example a filer a disk or a disk controller as described herein performing various operations or executions described. A machine accessible medium includes any mechanism that provides i.e. stores and or transmits information content in a form accessible by a machine e.g. computing device electronic device electronic system subsystem etc. . For example a machine accessible medium includes recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. as well as electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc. The machine accessible medium may further include an electronic device having code loaded on a storage that may be executed when the electronic device is in operation. Thus delivering an electronic device with such code may be understood as providing the article of manufacture with such content described above. Furthermore storing code on a database or other memory location and offering the code for download over a communication medium via a propagated signal may be understood as providing the article of manufacture with such content described above. The code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

Client systems may execute multiple application or application interfaces. Each instance or application or application interface may constitute a user session. Each user session may generate one or more requests to be processed by server . The requests may include instructions or code to be executed on a runtime system such as VM on server and its components and modules as described throughout this document.

In addition to what is described herein various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

