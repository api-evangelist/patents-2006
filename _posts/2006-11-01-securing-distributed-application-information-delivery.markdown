---

title: Securing distributed application information delivery
abstract: In an example implementation, a data structure comports with a secure application instruction protocol. The data structure includes a first application-level request and a second application-level request. The first application-level request has application-specific instructions from a requestor and a requestor signature over the application-specific instructions from the requestor. The second application-level request has application-specific instructions from an intermediary and an intermediary signature over at least the application-specific instructions from the intermediary.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08555335&OS=08555335&RS=08555335
owner: Microsoft Corporation
number: 08555335
owner_city: Redmond
owner_country: US
publication_date: 20061101
---
In modern distributed computing systems it is becoming increasingly important to optimize the use of one or more shared computational resources by a group of users. An example of this phenomenon is grid computing systems. Within a typical grid computing environment access to a number of computational devices is controlled by a set of job management systems. Job management systems determine the allocation of computational resources to submitted jobs determine the scheduling of those jobs and may sometimes determine aspects of the execution context of the jobs such as billing accounts security credentials the location of job activities executing in parallel and so forth. The purpose of the job management system s is to accept job requests from the grid environment s users and to optimize overall use of the computational resources. The computer resources may include supercomputers computing clusters application servers desktop workstations and so forth.

Distributed computing systems of which grid systems are an example may involve a hierarchy of application and resource management systems that support a large number of users and computers. For example a user may ask a centralized job manager to run an application. The central manager may in turn ask a subsidiary job manager that is responsible for a collection of compute clusters to run the application. The subsidiary manager determines the specific computing resource that is most appropriate for the application and then requests that the compute cluster s job manager run the user s application.

In such a hierarchically managed distributed system the sequence of job managers that are responsible for the user s application and the assigned compute cluster including any subsidiary managers may be dynamically determined based on the overall state of the distributed environment. Because the user may not know the details of where its application will ultimately execute at the time the job request is submitted it is likely that some information required at application execution time must be supplied by or can better be supplied by one or more of the job managers processing the job request. Existing systems fail to provide efficient and sufficient protections for the security of such information.

In an example implementation a data structure comports with a secure application instruction protocol. The data structure includes a first application level request and a second application level request. The first application level request has application specific instructions from a requestor and a requester signature over the application specific instructions from the requester. The second application level request has application specific instructions from an intermediary and an intermediary signature over at least the application specific instructions from the intermediary.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure API arrangement etc. implementations are described herein.

As described herein above some distributed computing systems involve a hierarchy of application and resource management systems that can support a large number of users and computing devices. By way of example only a user may ask a centralized manager to run an application. The central manager may in turn ask a subsidiary manager that is responsible for a collection of computing resource clusters to run the application. The subsidiary manager determines the specific computing resource that is most appropriate for the application and then requests that particular computing resource s manager to run the application.

In such systems there are typically multiple manager type intermediaries between the user who needs to run an application and the computing resource that is to actually run the application. Job managers as discussed above are one type of manager that are present in such environments. Other types of processing managers that may be present and may assist in processing the user s job request include but are not limited to message routing managers auditing managers and so forth. These managers can be generically referred to as request processing intermediaries. Request processing intermediaries cannot generally be determined a priori because they depend on other applications that are in the process of being scheduled or executed. These other applications are usually unknown to any single requesting user.

With existing approaches it is difficult to authenticate and or ensure the integrity of application information e.g. application specific instructions which may have been provided by multiple entities at the application execution site. The security of such application information can be critically important because the use of improper instructions can result in incorrect billing data security breaches incorrect computation denial of service and so forth.

Existing approaches generally assume that the entity making a request can ensure the request integrity and perform authentication by sending a secured message to the entity that will ultimately handle the request. These existing approaches do not fully address the issues present in the above described distributed computing environment because the original requestor and each intermediary processor may not know who will ultimately handle the request. Consequently they can not properly form a secured message to the entity that will ultimately handle the request using conventional approaches. Instead the request is processed and communicated using a set of independent messages with message security only protecting the contents on a point to point basis.

More specifically distributed computing environment includes user user user . . . user with u being some positive integer. It also includes processing manager processing manager processing manager processing manager . . . processing manager with p being some positive integer. Additionally distributed computing environment includes computing resource computing resource computing resource . . . computing resource with c being some positive integer.

In a described implementation each user may transmit a task request that asks that some task be performed on data . Although only one data element is shown each user may be associated with its own respective data with shared data with multiple units of data and so forth. For a hierarchy of processing managers request is forwarded from one processing manager to another processing manager until one can directly ask a computing resource to perform the requested task. Each computing resource may be a single computing device a cluster of computing devices part of a cluster of computing devices and so forth.

An example task request is illustrated as part of distributed compute environment . For this example task request user has an application that needs to be run or executed on data . User formulates a request that is realized as a message that is communicated from one participating entity to the next. Request is transmitted from user to processing manager . Processing manager forwards request to processing manager . Processing manager forwards request to processing manager . Processing manager ultimately forwards request to computing resource which actually performs the requested task. Request may be amended by each processing manager prior to forwarding it.

From a conventional perspective the type of computer system environment illustrated in creates two potential security problems. First each intermediate manager e.g. processing manager and final compute device s e.g. computing resources likely have access control policies that specify the particular users e.g. users and intermediary managers on behalf of whom they will do work. This is particularly true if the user managers and compute devices are in separate administrative domains with limited cross domain trust relationships which is typical in existing large scale computing Grids and collaborative business systems involving multiple companies. Consequently each request e.g. request to an intermediary or ultimate compute device should be able to provide authentication information for the instructions provided by the requesting user and each prior intermediary who processed the application request.

Second the compute device s that run the application typically require access to data resources e.g. data that are specified by the user. The repository holding this data likely has an access control policy limiting who can operate on the data. Hence the user and or processing intermediaries need some mechanism to provide the executing application e.g. at a computing resource with security credentials that the data repository accepts as valid for granting access to the data.

Existing approaches to these problems are inadequate as they fail to address how a set of application instructions that are incrementally generated by a series of dynamically determined intermediate processors can be communicated such that the integrity of each set of application instructions can be verified and an authentication of each intermediate processor can be performed. Consequently the overall security of such computing systems is often reduced which can also negatively impact usability.

With respect to the first security problem existing protocols are not designed to deal with this type of multi stage processing with incremental discovery of the participating entities. Many protocols are designed for point to point use e.g. IPsec SSL DCE RPC etc. . These point to point protocols allow one to send secured messages between two known end points i.e. the destination end point must be known prior to the message being sent but any intermediaries between the two end points see only opaque binary data. One can use such point to point protocols to secure the message flows between the communications participants described above but there is unfortunately no defined relationship between the security on an incoming request at a first participant and the outgoing request for the next participant.

Some other protocols e.g. SOAP Message Security are designed to deal with message security to a known end point while separately addressing security for intermediate processors. However these protocols still assume that the end point is known a priori and that it is only the intermediaries that may be discovered dynamically due to routing behaviors. The result is that existing systems tend to employ point to point message security in which message authentication and integrity protection are intended for use at the known end points.

Reliance on secure messages using existing protocols can perform adequately for the described distributed computing environment when all of the processing intermediaries and compute devices are in the same administrative domain or otherwise fully trust each other. In such cases the fact that such protocols assume the existence of a transitive trust model i.e. they assume the existence of a trust model in which a recipient of a request trusts the sender and by implication whoever sent the request to the sender is acceptable. However when full trust is not justifiable this assumption can permit a hostile intermediary to launch successful indirect attacks impacting the application to be executed. Additionally full trust scenarios allow for only coarse grained access control based on the request sender s identity and the information the request sender encodes in the request. That is any access control is ultimately based solely on the trust in the entity that sent the secured request message.

With respect to the second security problem existing approaches allowing the delegation of rights have similar limitations. For example some Grid job management systems such as Condor operate in a matchmaking mode. The Condor manager s locate resource s to run an application reserve those resources and then inform the request originator what resources it may use. This reservation approach is acceptable from a delegation perspective because the requester need only pass the data delegation security credentials to the actual compute device that is to run the request originator s application.

However this reservation approach has several negative aspects First the request originator must remain available because it does not know how long it will take the processing managers to find a suitable compute device. Presumably the compute device will cancel a resource reservation if the actual application and its associated instructions and delegation credentials are not provided in a reasonable amount of time. Second the requestor originator requires direct access to the compute device and this may not be practical or even possible in some complex systems due to network topology firewalls and so forth. Third the managers are probably unaware of what delegations are required hence they can not use delegation information to select an appropriate compute device.

In some other implementations name password credentials are used to grant access to security credentials that can be used to proxy the request originator e.g. via a MyProxy server . These name password credentials are typically passed as data to intermediate managers and eventually to a compute device. While they may be carried in an encrypted message they are revealed as clear text data at each intermediate manager and at each compute device. There is no protocol support that allows tracking of the full set of intermediate managers that had access to the credentials and then passed them along. Such tracking information can be important for example in auditing who potentially had access to the security credential or other information and in performing a forensic investigation if some unexpected access occurs. In short with existing approaches it is difficult to provide an adequate mechanism for securing application specific information between a request originator and the ultimate computing resource that is to actually run an application.

In contrast with certain implementations as described herein a transmission path along communication entity participants and or of may be secured and or rendered traceable using a secure application instruction protocol. For example each processing manager may elect to augment request by adding application specific instructions prior to forwarding it. In some distributed computing networks the addition of these augmentative instructions may be required by a computing resource for all job activities it is willing to execute. Each processing manager may digitally sign request prior to forwarding it to another processing manager . The request augmentation is performed at an application level. The digital signature is applied to the application specific information. Hence application level communication participants and or may authenticate the entity providing specific application instructions and validate the integrity of this application information. Moreover the identities of participating entities may be tracked.

More specifically for a described implementation a sender of a set of application specific instructions is allowed to include encrypted security credential information in a form in which a next processing intermediary may decrypt. This processing intermediary may then i re encrypt the credentials in a form another processing intermediary may decrypt and ii include this re encrypted credential in the set of intermediary supplied application specific instructions that it creates. This process continues on a point to point basis until a final request handler such as a computing resource is reached. The credential is used at the request handler. If each set of application specific instructions is digitally signed as is described in the preceding paragraph then a verifiable record of each entity who had access to the clear text credential is provided.

More specifically four processing intermediaries and are shown. Three request handlers and are shown. Four versions of an application level request are shown application level request A A application level request B B application level request C C and application level request D D . Although a specific number of each illustrated type of application level communication participant is illustrated in computing environment any number of each of requestors intermediaries and or request handlers may be involved in a given application level request communication.

In a described implementation generally a requester originates and initiates an application level request that is associated with data . Application level request is transmitted between and among one or more processing intermediaries . Each processing intermediary determines where application level request is to be forwarded next. As described further herein below each intermediary may also augment application level request by adding application specific instructions thereto. Eventually an intermediary forwards an application level request to at least one request handler . Each request handler is capable of executing an application in accordance with application level instructions received as part of an application level request and in accordance with its associated data .

With regard to a more specific distributed computing environment is illustrated. In the context of general computing environment of a requester may be realized as a user a processing intermediary may be realized as a processing manager and a request handler may be realized as a computing resource . Also application level request may be realized as request and data may be realized as data .

In a described implementation for computing environment requester intermediaries and request handler are interconnected by one or more networks which are not explicitly illustrated in . Using communication links of such network s application level request is forwarded between and among intermediaries until it is provided to at least one request handler that can perform the requested task.

As illustrated in and by way of example only an application level request A A is generated by requestor . Requestor transmits application level request A A to intermediary . Application level requests may be transmitted as part of a message being communicated in accordance with some transport protocol. The utilized transport protocol may differ between the application level communication participants and .

After some manipulation of the incoming request A intermediary transmits application level request B B to intermediary . After some manipulation of the incoming request B intermediary transmits application level request C C to intermediary . Additionally after some possibly different manipulation of the incoming request B intermediary also transmits application level request D D to intermediary .

Intermediary separates the requested task of application level request C C into two parts. It forwards a first part to a first request handler and a second part to a second request handler . Intermediary forwards the requested task of application level request D D to a third request handler . Request handlers and each therefore perform a part of the original requested task of application level request A A .

In a described implementation for application level request A A includes application specific instructions from requestor and a requester signature . Application specific instructions from requestor is information that specifies a requested task to be performed. For example it may specify an application that is to be executed and data on which the application is to execute as well as any required security credentials. More specifically application specific instructions from requester may include by way of example but not limitation execution requirements initialization parameters required data sources security context information and so forth. Requestor ascertains the information for application specific instructions from requester and formulates application level request A A .

Requestor signature is a digital signature that is applied to application specific instructions from requestor by requester . In other words a digital signature procedure is applied to application level information. Consequently entities that subsequently receive and process application level request A A such as an entity corresponding to intermediary may perform an authentication check and an integrity validation on application specific instructions from requester . The authentication check determines which requester generated the application specific instructions . The integrity validation validates that the information of application specific instructions from requestor has not been modified since it was originated and signed by requestor .

In a described implementation for application level request B B includes application specific instructions from intermediary intermediary signature and application level request A A . Intermediary accepts incoming application level request A A from requester and determines that it should be forwarded after some manipulation to intermediary . Intermediary effectively encapsulates application level request A A in application level request B B .

Intermediary augments application level request by adding supplemental application specific instructions to it. These supplemental instructions are illustrated as application specific instructions from intermediary . They are intended for processing by a least one subsequent recipient which may include intermediary in the example of . Intermediary also digitally signs application level request with an intermediary digital signature . This digital signature is illustrated as intermediary signature . Intermediary signature is a signature on the application specific information of application level request B B . This may include for example application specific instructions from intermediary and or application level request A A . Intermediary may also digitally sign application level request A A if for example there are reasons intermediary is to ensure its application specific instructions and those provided by requestor are not be modified independently.

In a described implementation for application level request C C includes application specific instructions from intermediary intermediary signature and application level request B B . Intermediary accepts incoming application level request B B from intermediary and determines that it should be forwarded at least in part and after some manipulation to intermediary . Intermediary effectively encapsulates application level request B B in application level request C C .

Intermediary augments application level request by adding supplemental application specific instructions to it. These supplemental instructions are illustrated as application specific instructions from intermediary . Intermediary also digitally signs application level request with an intermediary digital signature . This digital signature is illustrated as intermediary signature . Intermediary signature is a signature on the application specific information of application level request C C . This may include for example application specific instructions from intermediary and or application level request B B . Although not separately illustrated application level request D D may be formulated analogously to application level request C C .

Thus as illustrated in FIGS. and A C a described implementation of an application level instruction protocol effectively encapsulates an incoming application level request and produces an outgoing application level request . The outgoing application level request includes a digital signature over at least part of the application specific information. It may also include supplemental application specific instructions . As an application level request propagates through participating application level communication nodes or entities a nested set of application level requests is created as illustrated in particular by .

This nesting of application level requests coupled with digital signatures and over each nested request can enable participants to perform authentications and integrity validations of application specific information throughout a chain of request transmissions. However at least the eventual request handler of may need to access data to perform a requested task in accordance with application level request . In some implementations accessing data may require being granted a right to access data . Hence in such implementations the performance of a requested task by a request handler may entail first granting the implementer a right to access data . In a described implementation this access right to data may be granted via a delegation access control mechanism.

As illustrated application level request B B includes delegation of rights from intermediary and effectively also includes delegation of rights from requestor which is part of application level request A A by virtue of the request nesting. In a described implementation when requestor formulates application level request A A it includes delegation of rights from requestor . Requestor has access rights to its data . Because requestor may not know which request handler s will ultimately need the right to access data requestor may not be able to directly grant access rights to data . Consequently requestor grants a right to delegate access rights to data to subsequent application level communication participants e.g. processing intermediaries .

Data delegation information e.g. of delegation of rights from requestor of delegation of rights from an intermediary etc. is a granting of a delegation right to a first participant that may be transferred or extended to a second participant. In other words with application level request A A of application level request B B requestor delegates to intermediary a right to further grant access rights to data to a downstream communication participant. Intermediary utilizes this delegation right by adding delegation of rights from intermediary . In other words with application level request B B intermediary delegates to intermediary a right to further grant access rights to data to another downstream communication participant. This delegation chain can be extended until the selected request handler is granted access rights to data e.g. by intermediary and or intermediary . If this delegation information and or contains secrets e.g. passwords cryptographic keys etc. that should not be disclosed to unauthorized participants such information may be encrypted such that the next processing entity may decrypt it. This processing entity may then re encrypt the secret information for the next processing entity and include it with data delegation information that the request is to be augmented with.

Thus certain described implementations provide a general application level security protocol for interactions between a requestor that originates a request a handler of the request and one or more intermediaries who process and forward the request between the requestor and the request handler. Described implementations of the application level security protocol can be used in situations in which these entities are known prior to the request being issued. Moreover certain described implementations are capable of dealing with the more complex case in which these entities are not known a priori but they are instead established incrementally as the request propagates between the requestor and the ultimate request handler.

The flow of request in illustrates an example of a general message flow pattern that can be handled by an application level security protocol as described herein. As depicted the request flow from requestor to request handlers forms a directed graph. At any intermediary request may potentially be forwarded to multiple entities e.g. one or more other intermediaries and or request handlers . Each flow from a requestor to a request handler may be treated as being logically separate. Computing environment as illustrated in can therefore be considered to have three logically separate flows. Although implementation efficiency can be improved from the potential re use of the request processing for one flow in another flow such re use need not impact the application level security protocol. Consequently the description herein below addresses only a single request flow for the sake of clarity.

As described above a nesting process for application level requests in conjunction with digital signatures and provides a mechanism for authenticating requestor and any previous intermediaries that have processed a given request message. Furthermore the nesting and digital signatures provide mechanisms for independently validating the integrity of the application level information in the original request and any additional application level processing instructions added by the intermediaries.

In a described implementation message composition is accomplished using the nesting process and this nesting process is coupled with digital signature technology. The digital signatures may be based for example on public key cryptography. In the following text and example message request formats a requestor is termed requester R intermediaries n . . . n are termed intermediaries M Mn and a request handler is termed a request handler RH. Using this combined approach of nesting with digital signatures the requestor R with key K sends to a first intermediary M a message containing 

Intermediary M can check the signature to authenticate that the request comes from requester R and validate that it has not been modified in transit. If intermediary M who has key K decides to forward the request to a second intermediary M with key K intermediary M sends a message containing 

Intermediary M can now use the two signatures and to determine 1 that the M instructions for M originated from intermediary M 2 that intermediary M had the original request 3 that the original request came from requestor R and 4 that nothing has been modified since the signatures were applied. Intermediary M can then use this information to determine if it is willing to process such a request on behalf of both intermediary M and requestor R.

This approach is continued through n intermediaries M until the actual request handler is ultimately reached with n being some integer. This actual request handler receives a message containing 

The cryptographic digital signatures Kand K. . . Kare enacted over the data understood at the application layer by the intermediaries and the request handler. This is distinct from network security protocol digital signatures which are widely used to secure communications to authenticate and integrity protect the transmitted message. These widely used message digital signatures typically cover both the message content and the message headers as encoded for the specific lower layer security protocol being used. Consequently such message digital signatures can not be used for these applications because the headers are not generally meaningful across the intermediaries and because the messaging protocols used may not be identical between all entities participating in the request flow.

As described above with reference to the delegation of rights to data access can also facilitate using an application level security protocol in the context of dynamically discovered message flow participants. Certain described implementations thus provide a mechanism for passing delegation information between the various participating entities. This passing of data delegation information addresses the fact that the entities in the flow may be discovered dynamically. In other words the passing of data delegation information accommodates the fact that there may be no way for the requester to directly indicate which request handler is to be delegated data access rights when the requestor originally formulates the request.

Security credential information such as delegation of rights from requestor and or delegation of rights from intermediaries may be encrypted. Each processing intermediary may decrypt them perform any relevant analysis possibly modify them and then re encrypt them before forwarding request . Encryption may be applied using any commonly used ciphers e.g. http www.w3.org 2001 04 xmlenc aes128 cbc or a specially adapted cipher. Associated decryption keys may be communicated using commonly available techniques e.g. RSA key transport as described at http www.w3.org 2001 04 xrnlenc rsa oaep mgflp or a specially designed technique. Associated decryption keys may also be communicated using an AES key wrap e.g. http www.w3.org 2001 04 xmlenc kw aes128 . Other encryption decryption and key transport approaches may alternatively be employed.

Certain described implementations of securing distributed application information delivery that entail delegation of rights are agnostic as to what mechanism is used to delegate the data access rights of the requestor to the request handler. Example delegation mechanisms include by way of example but not limitation i a name password pair that is used to unlock a delegation credential such as is used with the MyProxy service ii a series of explicit delegation policies credentials generated at each processing intermediary using a policy language such as the ISO Rights Expression Language REL iii the Security Policy Assertion Language SecPAL language from Microsoft iv some combination thereof and so forth. An example implementation may use an XML encoding that is employed in conjunction with one or more SOAP based web service protocols that are being developed for Grid computing distributed job management.

An example described approach is to have the requestor and each processing intermediary encode the desired delegation to the next entity that is participating in the message communication flow. If the mechanism involves name password credentials and a MyProxy service it takes the form of the name password encrypted and sent to the next entity in the flow plus a reference to the MyProxy service to use. If the mechanism involves one of the policy language approaches it entails creating a credential indicating that the next entity participating in the flow has rights to access the required data and or delegate those rights to others.

Regardless such data delegation credentials are issued or digitally signed by the requestor or current processing intermediary. The delegation of rights information may then be combined with the authentication information described above as illustrated in combination in to form another described implementation of the application level security protocol. By way of example only a described implementation of the application level security protocol with a delegation of rights component may be generally formatted as follows with data access rights being represented by DAR 

Although ten modules are illustrated for application and described below an application that is functioning as a participating entity in an application level security protocol for application instructions may include any number of modules. The description below is primarily directed to an application that is functioning as an intermediary . Nevertheless the functioning of an application may be analogous for other entities such as a requester a request handler and so forth. However there may be some differences. For example a request handler may not need a message augmenter or a message signer . A requestor originates a request so it may not need an application specific information extractor or an application specific information analyzer . On the other hand including both in an application of a requestor enables the requestor itself to perform some request tracking forensic analysis of a transmission path of a request .

In a described implementation receiver accepts incoming requests from a layer of a computer s communication stack that is lower than the application layer. Similarly transmitter sends outgoing requests from an application layer to a lower layer of the communication stack for forwarding to another intermediary or a request handler using a lower layer communication transport protocol.

In a described implementation application specific information extractor extracts application specific information from incoming requests . Examples of application specific information include but are not limited to application specific instructions from requestor application specific instructions from an intermediary delegation of rights from requestor delegation of rights from intermediaries and so forth. Application specific information analyzer analyzes the extracted application specific information to determine where the request should be forwarded next. The next participating node may be for example another intermediary or a request handler. Application specific information analyzer also analyzes the extracted application specific information to determine what additional application specific instructions for this next node if any should be added to the incoming request for the outgoing request .

Message participant authenticator uses digital signatures to authenticate the origin of a request and or augmentative application specific information. Hence message participant authenticator may use requestor signature to authenticate that the original request A with application specific instructions from requestor was initiated by requester . It may also use intermediary signature to authenticate that the encapsulating request B with application specific instructions was forwarded from intermediary .

Message information integrity validator uses respective nested digital signatures and to validate the integrity of respective nested application specific information. More specifically message information integrity validator uses requester signature to validate the integrity of application specific instructions from requestor and or delegation of rights from requestor . Message information integrity validator may also use intermediary signature to validate the integrity of application specific instructions from intermediary and or delegation of rights from intermediary .

Message augmenter adds any additional desired processing instructions. For example message augmenter may add new application specific instructions for the next entity recipient e.g. an intermediary or a request handler and or data delegation rights including data access rights for the next entity recipient. Message signer digitally signs the application level information to produce intermediary signature . The digital signature procedure may be applied over the augmentative information such as application specific instructions from an intermediary that are for the next entity recipient. Alternatively the digital signature procedure may also be enacted over the nested application level requests so as to provide for verification of the order in which the requests are being created and the instructions are being added.

Encryption and decryption are handled by information encryptor and information decryptor respectively. Information can be decrypted by information decryptor . Information can be encrypted and or re encrypted by information encryptor . The information may be for example security credential information. More generally the information may be any given data including but not limited to application specific instructions and or delegation of rights and or and so forth.

At block an incoming message having a request that is digitally signed by a requestor at an application level is received. For example intermediary may receive a message having an application level request B B that is at least partially signed by requestor . Application level request B B encapsulates application level request A A which includes a requestor signature .

At block it is determined if the received request has any application specific instructions from a previous intermediary. For example it may be determined if application level request B B includes any application specific instructions from a previous intermediary . As illustrated in application level request B B does include application specific instructions from intermediary .

If the received message does have application specific instructions from a previous intermediary then at block the application specific intermediary instructions are extracted from the request. For example application specific instructions from intermediary may be extracted.

After block or after a No decision at block application specific requestor instructions are extracted from the request at block . For example application specific instructions from requester may be extracted. Thus after blocks and any application specific instructions whether they originate from the requestor or a previous intermediary have been extracted. Other application specific information such as digital signatures and or delegation of rights may also be extracted.

At block the extracted application specific information is analyzed. For example application specific requestor instructions and or application specific intermediary instructions may be analyzed to determine if the request is to be forwarded to another intermediary or to a request handler or to one or more of both. In other words the analysis can determine the identity of at least one entity that is to be a subsequent recipient of the request. The analysis can also determine what application specific instructions should be added to the request by the current intermediary.

When digital signature protections are being utilized requester signature and or intermediary signature s may be extracted and used to authenticate and or analyze the integrity of the application level requests . When data delegation information is included in the application level requests delegation of rights from the requestor and or delegation of rights from intermediaries may be extracted and used in the analysis especially to further delegate data access rights to downstream participants.

At block the request is augmented by adding application level instructions for a subsequent entity. For example responsive to the analysis of block intermediary may add application specific instructions for a subsequent intermediary such as application specific instructions from intermediary . If delegation rights are being forwarded intermediary may further augment the request by adding delegation of rights from intermediary to continue a data access rights transitive delegation chain.

At block the augmented request having the added instructions at the application level is digitally signed to create an outgoing message. For example intermediary may digitally sign the added application specific instructions and or the nested application level requests A and B to create intermediary signature .

At block the digitally signed outgoing message is transmitted towards a subsequent entity. For example intermediary may transmit application level request C C towards intermediary . Intermediary may also apply aspects of the described application level security protocol for subsequent communications to request handlers and depending on the logical and trust relationships between them.

As illustrated two devices and are capable of engaging in message communication transmissions such as the forwarding of application level requests via network . Although two devices are specifically shown one or more than two devices may be employed depending on implementation. Requestors intermediaries request handlers etc. may be realized as devices .

Generally a device may represent any computer or processing capable device such as a server device a workstation or other general computer device a data storage repository apparatus a personal digital assistant PDA a mobile phone a gaming platform an entertainment device a router computing node some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media include processor executable instructions .

In a described implementation of device I O interfaces may include i a network interface for communicating across network ii a display device interface for displaying information on a display screen iii one or more man machine interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports a network communications stack and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Examples of iii man machine interfaces include those that communicate by wire or wirelessly to man machine interface devices e.g. a keyboard a remote a mouse or other graphical pointing device etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device .

Thus realizations for the securing of distributed application information delivery may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects components metadata and definitions thereof data structures application programming interfaces APIs etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media and or executed by different processors.

Processor s may be implemented using any applicable processing capable technology. Media may be any available media that is included as part of and or accessible by device . It includes volatile and non volatile media removable and non removable media and storage. For example media may include an array of disks for longer term mass storage of processor executable instructions random access memory RAM for shorter term storing of instructions that are currently being executed and or otherwise processed and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein. Such functions include but are not limited to i realizing the application level communication participants that are illustrated in ii performing those actions that are illustrated in flow diagram of iii implementing those data structure s that are illustrated in B C and iv realizing the application that is illustrated in and so forth. By way of example only processor executable instructions may include one or more application level requests an application some combination thereof and so forth.

The devices actions aspects features functions procedures modules data structures protocols computing systems components etc. of are illustrated in diagrams that are divided into multiple blocks. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses APIs arrangements etc. for the securing of distributed application information delivery.

Although systems media devices methods procedures apparatuses mechanisms schemes approaches processes arrangements and other implementations have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

