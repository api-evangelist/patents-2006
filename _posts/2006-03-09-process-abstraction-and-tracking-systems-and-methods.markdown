---

title: Process abstraction and tracking, systems and methods
abstract: The present invention is an abstraction layer that “hides” the complexity of underlying workflow engine and provides a unified application programming interface (API) to access underlying workflow functions. The abstraction layer of the present invention serves as a gateway between application flow logic and one or more workflow engines and allows an application to build flow implementation logic once and then be able to run on various workflow engines without significant code changes. The present invention also enables different workflow engines to run concurrently to support one application and without the need for applications to migrate or consolidate to one workflow engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08752030&OS=08752030&RS=08752030
owner: Verizon Services Corp.
number: 08752030
owner_city: Ashburn
owner_country: US
publication_date: 20060309
---
Embodiments of the present invention generally relate to work flow management a k a business process management BPM products and particularly relate to an abstraction layer that allows one or more BPM s to interface with one or more applications with the addition of abstraction layer features.

There are many workflow BPM Business Process Management products available including those that are commercially available and those developed in house. Many of these products are developed using different workflow engines as a component of the BPM. The big challenge is that different application implementation is required for different workflow engine products. Those product implementations cannot co exist in a homogeneous deployment environment easily and therefore produce problems in system integration product upgrade and migration. There are some open standards in workflow area however those standards only address the definition part of the flow process. Existing workflow standards do not have a unified interface to define all workflow functionalities. Moreover there are many areas that standards leave to vendor implementation purposely such as work assignment and dispatch administrative flow management runtime flow status display etc.

Organizations make use of many workflow products in various systems and application products may have their own workflow providers and need to integrate external ones as well. On user interface side an application desirably exposes the client to a consistent look and feel for business process management functionalities. On the flow implementation side an application tries to avoid workflow vendor specific implementation to promote code reuse and flexibility. On the development and testing side an application wants to have a set of tools to help and automate daily implementation debugging and testing.

The preferred embodiments implemented according to the present invention now will be described more fully with reference to the accompanying drawings in which some but not all embodiments of the invention are shown. Indeed this invention may be embodied in many different forms and should not be construed as limited to the embodiments set forth herein. Rather these embodiments are provided so that this disclosure will satisfy applicable legal requirements. Like numbers refer to like elements throughout.

As will be appreciated by one skilled in the art the preferred embodiments may be embodied as a method a data processing system or a computer program product. Accordingly the preferred embodiments may take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment combining software and hardware aspects. Furthermore the preferred embodiments may take the form of a computer program product on a computer readable storage medium having computer readable program instructions e.g. computer software embodied in the storage medium. More particularly the preferred embodiments may take the form of web implemented computer software. Any suitable computer readable storage medium may be utilized including hard disks CD ROMs optical storage devices or magnetic storage devices.

The preferred embodiments are described below with reference to block diagrams and flowchart illustrations of methods apparatuses i.e. systems and computer program products. It will be understood that each block of the block diagrams and flowchart illustrations and combinations of blocks in the block diagrams and flowchart illustrations respectively can be implemented by computer program instructions. These computer program instructions may be loaded onto a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute on the computer or other programmable data processing apparatus create a means for implementing the functions specified in the flowchart block or blocks.

These computer program instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable memory produce an article of manufacture including computer readable instructions for implementing the function specified in the flowchart block or blocks. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions that execute on the computer or other programmable apparatus provide steps for implementing the functions specified in the flowchart block or blocks.

Accordingly blocks of the block diagrams and flowchart illustrations support combinations of means for performing the specified functions combinations of steps for performing the specified functions and program instruction means for performing the specified functions. It will also be understood that each block of the block diagrams and flowchart illustrations and combinations of blocks in the block diagrams and flowchart illustrations can be implemented by special purpose hardware based computer systems that perform the specified functions or steps or combinations of special purpose hardware and computer instructions.

In the preferred embodiments of the invention referenced herein a computer or computing device may be referenced. The computer may be for example a mainframe desktop notebook or laptop a hand held device such as a data acquisition and storage device or it may be a processing device embodied within another apparatus such as for example a set top box for a television system. In some instances the computer may be a dumb terminal used to access data or processors over a network. Turning to one embodiment of a computer is illustrated that can be used to practice aspects of the preferred embodiments. In a processor such as a microprocessor is used to execute software instructions for carrying out the defined steps. The processor receives power from a power supply that also provides power to the other components as necessary. The processor communicates using a data bus that is typically 16 or 32 bits wide e.g. in parallel . The data bus is used to convey data and program instructions typically between the processor and memory. In the present embodiment memory can be considered primary memory that is RAM or other forms which retain the contents only during operation or it may be non volatile such as ROM EPROM EEPROM FLASH or other types of memory that retain the memory contents at all times. The memory could also be secondary memory such as disk storage that stores large amount of data. In some embodiments the disk storage may communicate with the processor using an I O bus instead or a dedicated bus not shown . The secondary memory may be a floppy disk hard disk compact disk DVD or any other type of mass storage type known to those skilled in the computer arts.

The processor also communicates with various peripherals or external devices using an I O bus . In the present embodiment a peripheral I O controller is used to provide standard interfaces such as RS 232 RS422 DIN USB or other interfaces as appropriate to interface various input output devices. Typical input output devices include local printers a monitor a keyboard and a mouse or other typical pointing devices e.g. rollerball trackpad joystick etc. .

The processor typically also communicates using a communications I O controller with external communication networks and may use a variety of interfaces such as data communication oriented protocols such as X.25 ISDN DSL cable modems etc. The communications controller may also incorporate a modem not shown for interfacing and communicating with a standard telephone line . Finally the communications I O controller may incorporate an Ethernet interface for communicating over a LAN. Any of these interfaces may be used to access the Internet intranets LANs or other data communication facilities.

Finally the processor may communicate with a wireless interface that is operatively connected to an antenna for communicating wirelessly with another device using for example one of the IEEE 802.11 protocols 802.15.4 protocol or a standard 3G wireless telecommunications protocols such as CDMA2000 1 EV DO GPRS W CDMA or other protocol.

An alternative embodiment of a processing system that may be used is shown in . In this embodiment a distributed communication and processing architecture is shown involving a server communicating with either a local client computer or a remote client computer . The server typically comprises a processor that communicates with a database which can be viewed as a form of secondary memory as well as primary memory . The processor also communicates with external devices using an I O controller that typically interfaces with a LAN . The LAN may provide local connectivity to a networked printer and the local client computer . These may be located in the same facility as the server though not necessarily in the same room. Communication with remote devices typically is accomplished by routing data from the LAN over a communications facility to the Internet . A remote client computer may execute a web browser so that the remote client may interact with the server as required by transmitted data through the Internet over the LAN and to the server .

Those skilled in the art of data networking will realize that many other alternatives and architectures are possible such as for example the set top boxes contemplated herein can be used in implementing the preferred embodiments described herein. The embodiments illustrated in and can be modified in different ways and be within the scope of the present invention as claimed.

Generally workflow engines interact with one or more business applications to route work to designated parties or to perform certain steps as part of a flow. The use of workflow engines helps provide standardization efficiency and tracking to a business s processes. In many instances and as shown in the interaction between an application and a workflow engine is accomplished through a customized programming interface . The use of such customized interfaces creates additional expenses and decreases the flexibility and responsiveness of the business s workflow management system.

Exemplary applications include an integrated online ordering system for a wireless telecommunications provider. The application in this example takes order information from a web browser and pushes it back to backend legacy systems for processing. In the exemplary application the PATS layer creates a workflow instance in which it automatically interacts with a circuit tracking system order provisioning system and a billing system. In this instance a circuit tracking system is used by a telecommunications provider to store and track information about the provider s various circuits. The circuit tracking system in this example tracks the running status of each of the provider s circuits. When an order is taken the service normally requires the creation of a new circuit or changes to an existing circuit. Therefore the ordering system interacts with the circuit tracking system to maintain the status of the provider s circuits. In this instance the flow includes interactive tasks for contract review circuit testing and billing verification.

The PATS layer is also comprised PATS engine that is used to carry out the functions of the PATS layer . The PATS engine is responsible for executing application code maintaining the PATS layer s internal state information and providing coordination between various PATS layer modules such as for example the process logger a flow state manager and a flow simulator .

The PATS layer is an abstraction layer that hides the complexity of underlying workflow engines each of which are comprised of computer implemented instructions and are stored in memory in a manner that is accessible to and executable by the processor as described in and . The PATS layer provides a unified application programming interface API to access underlying workflow functions. It serves as a gateway between application flow logic and one or more workflow engines . The PATS layer allows an application to build flow implementation logic once and then be able to run on various workflow engines without significant code changes. The PATS layer also enables different workflow engines to run concurrently to support one application without the need to migrate or consolidate to one workflow engine thereby facilitating load balancing and increasing the efficiency with which the workflow engines can respond to the applications.

The preferred embodiments of the present invention use a service provider architecture design that allows easy plug ins for different workflow engines . For each workflow engine a service provider is implemented to plug the workflow engine into the PATS layer . Plug ins are known in the art and generally are self contained software components that modify adds or changes functions in a particular software system. When a user adds a plug in to a software system the foundation of the original software system remains intact. The development of plug ins requires well defined application programming interfaces APIs . The plug in performs a translation function so that the generic language of the applications can communicate with the more specific language of a workflow engine . The plug in is designed to communicate with both underlying workflow engines and the generic PATS layer . Generally different workflow engines behave differently therefore the plug in bridges the difference between the workflow engine and the PATS layer . Therefore when one or more applications interact with the PATS layer they are presented with one unified interface thus enabling workflow engine transparency to the one or more applications.

Unlike other service provider architecture designs that require adapters developed for both the client and server in an exemplary embodiment according to the present invention a generic implementation on the application side of the workflow engine called a flow task dispatcher is utilized. The flow task dispatcher is generally installed in an application program and facilitates communication between workflow engines and applications compare to plug ins that generally run inside a workflow engine . Plug ins and flow task dispatchers use one or more standard protocols defined by the PATS layer to exchange information which is transparent to the applications as there are not different flow task dispatchers for different workflow engines. The flow task dispatcher has a well defined interface and is not vendor specific. The flow task dispatcher communicates with workflow engine plug ins via for example pre defined Enterprise JavaBeans EJB and Java Messaging Services JMS interfaces as are known in the art. Therefore only the configuration of an application s flow needs to change by routing the flow to and from a different workflow engine. With one common flow task dispatcher an application has the benefit of switching to different workflow engines without code change or redeployment. Therefore there is no need to deploy a separate flow task dispatcher for each workflow engine though this is not precluded in the preferred embodiments. Thus applications are able to use all supported workflow engines .

Generally workflow engines are a component of commercial workflow management system WFMS products and are often referred to as BPM Business Process Management applications and may include extra services. In some instances however the workflow engines may be developed for specific entities or purposes or be a combination of commercial and in house developed products. Workflow engines provide for the automation of business processes workflows during which information and or tasks are passed along based on procedural or business rules. Business processes control which piece of work will be performed by whom and which resources are exploited for this work i.e. a business process describes how an enterprise will achieve its business goals. A WFMS may support both the modeling of business processes and their execution.

Generally a workflow engine recognizes the tasks of each business process in the workflow and determines whether the business process is ready to move to the next task. In some instances there may be many workflow engines as there may be a need for different implementations for different engines. Presently there is no easy way for different engines to co exist because of vendor specific requirements for each vendor s engine. In addition it is also difficult to migrate workflow processes when switching engines or vendors as flow implementations are tied to vendor implementations.

Although there are some workflow standards these standards try to define the core functions but leave add on features e.g. monitoring work assignment etc to vendor specific implementations. Existing workflow manager standards are more directed toward static flow process definitions but not toward systems or process of providing the appearance of a generic virtual workflow engine at run time. Many of the major industrial players have adapted different standards which makes it difficult for users to interface the workflow managers with applications.

The embodiments of the PATS layer provide a portal that has its own application user interface UI that exposes the user to one or more core workflow functions. This allows a consistent look and feel on the UI regardless of the workflow engine servicing an application and provides work list management based on a user s business processes. The UI enables flow status display for end to end visibility of business flows and provides flow diagnostics needed for debugging and testing. For example the UI may display an application workflow similar to the one shown in . In one embodiment the workflow tasks may be displayed in different colors to indicate the status of a working flow. In an exemplary implementation of a UI a user is able to view the overall status of a working flow where a different color box is used for each task. In this example a user may click on a task with a cursor associated with the UI to see more detailed information about the task such as for example starting time end time if done and pending reason if not done . Debugging may be performed based on task status. An exemplary color scheme for task boxes may be for example 

Green task is waiting for user input in order to continue. Normally user will use application UI to send input to workflow. When debugging a flow developer can bypass a customized application UI and interact with flow directly. After clicking on task user will get information about what the flow is expecting from the UI. The developer can then type in the response message and send input directly to the flow. After that the UI will refresh and retrieve new status for tasks.

Blue task is waiting for response from external system. Normally no user intervention is needed since the response should come from another system automatically. In a development environment however a developer can choose to post a response manually. This is helpful when an external system is not available for testing or it takes too long for the external system to respond. It provides an easy simulation environment for responses in different test cases.

Red task has encountered some critical error. User intervention is required to correct any errors. Similar to a green task a red task can be processed directly from the debugging UI.

Yellow task has encountered some non critical error. User intervention may be required to correct any errors. Similar to a green task and a red task a yellow task can be processed directly from the debugging UI.

A task could be in one of following colors and some debugging functions can be performed based on task status.

Similarly in one embodiment the UI of the PATS layer provides visibility through which a developer can view and edit flow states. An exemplary screen shot for UI visibility of the flow state management is shown in . Individual values for flow variables can be set or changed in this UI . Combined with the flow task execution manipulation as described above in regard to the flow status display for end to end visibility of business flows a developer can change workflow flow s running status to debug and test flow logic. The PATS layer UI may also be used in a production system to provide support and error recovery.

As indicated above the preferred embodiments of the present invention provide an abstract layer the PATS layer which helps to make transparent the complexity of workflow engines A unified API provides access to underlying workflow engines so that application flow implementations can be written once yet run on all supported engines . This helps to reduce vendor dependency to minimal levels. The service provider architecture allows easy plug in of different workflow engines . To include a new workflow engine new service providers are developed to implement a pre defined set of APIs. Workflow engines supported by the preferred embodiments include BEA WebLogic Process Integrator and in house developed workflow engines among others.

The preferred embodiments allow the development of unified extra services on top of underlying workflow engines . For example the PATS layer can provide unified flow state management unified work assignment API and user interface and unified task tracking and flow display diagrams among other extra services. The PATS layer makes these extra services non vendor specific and capable of migration integration on different workflow engines . The PATS layer provides a gateway to and from underlying workflow engines . It serves to forward an engine s invocation to application handlers send an application s response to the engine back to the engine and allows multiple workflow engines co exist and run smoothly together. This allows an application to make use of any underlying engine by configuration not by code implementation. Application handlers are modules comprised of application code that is invoked from the PATS layer by the PATS engine for fulfilling workflow tasks. For example Provisioning Circuit may be a task in a workflow. The PATS engine will execute application code i.e. the application handler to implement steps to provision a circuit through a backend system. For instance the application handler may make a call to legacy system.

Each workflow process can have its own states used for communicating information between tasks inside a workflow manager comprised of a workflow engine. Most workflow management systems WFMS keep process model information and the state information for the process instances together with detailed status information on the execution status of the process by the WFMS in some sort of a database system as are known in the art. Thus the WFMS maintains state information of the WFMS itself and of the process model instance currently executed by the WFMS. The WFMS control functions such as navigating through a process graph performing staff resolution invoking applications etc. access the WFMS state information make the appropriate computations and store new state information.

Because state management implementations vary from workflow engine to workflow engine the PATS layer implements its own state management outside of the underlying workflow engines which facilitates accessing and performing data reporting and also serves to alleviate vendor dependency. The flow state manager of the PATS layer wraps states defined by the one or more workflow engines and exposes them to the one or more applications via a non vendor specific API . If an application has persistent state information the PATS layer has in one embodiment external storage and an API for handling them. The PATS layer handles this type of state management outside of the underlying workflow engines because state management implementations vary from workflow engine to workflow engine. The PATS flow state manager maintains a superset of underlying workflow engine variables. When defining a flow variable an application designates whether the variable will be used in a workflow engine or not. The PATS layer manages all such designated flow variables which includes some variables that are not known to underlying workflow engines . This extra feature is provided to overcome some engine s limitations such as variable type. Therefore PATS state flow manager unifies state management for all workflow engines and in addition provides extra features not supported by all workflow engines .

In one embodiment the PATS layer includes scripting support where workflow can be implemented using scripting languages such as JavaScript and BeanShell. This provides the capability to change flow implementation logic in real time without going through a build or redeployment process. Furthermore it allows one unified way to communicate with all workflow engines . Scripting support enables the quick adoption of dynamic business requirements. Although the scripts are invoked by the workflow engines the engines have no knowledge of the scripts and therefore the engines are not required to have built in script support. While flow task handlers are generally implemented by the use of code such as Java code such handlers may also be implemented in script. The PATS layer stores the script code in text format in a database. When one or more workflow engines execute a task the PATS engine will compile and execute the script on the fly. Therefore in this instance the script is nothing more than a replacement for compiled code. Scripts provide runtime flexibility for changing implementations as it allows task logic to be modified by changing script code in the database.

Scripting is provided through the PATS engine and script content is provided by flow to instruct the PATS engine of tasks that should occur in order to complete a task. For example a task to perform data validation may be comprised of checking data for errors before passing a request to backend provisioning system. An exemplary JavaScript script excerpt for performing this task is the following 

The exemplary script above implements a rule that there are only limited bandwidth offers no bandwidth should be larger than 1024 KB due to network limitation available in the state of Massachusetts MA . Because business rule like this can change rapidly it is not desirable to implement such logic in compiled code like Java. Scripting enables quick changes and provides flexibility for underlying workflow to be more dynamic and flexible. If some day the network is upgraded and higher bandwidth products are offered in Massachusetts only the script is required to be changed and a code drop or new system release is not necessary.

When executing a script the PATS engine generally performs the following operations the script content is retrieved from a database a flow context object is set so that the script can access flow information such as the flow state manager a script runner is created based on language type the script runner is invoked to execute the script and the returns from executing the script are obtained and used to drive the flow process accordingly.

In one embodiment the PATS layer provides a process logger that is configured to monitor and log utilities that are not provided by the one or more workflow engines e.g. the extra services not provided by PATS layer . For instance the PATS layer systematically logs each task and event start time end time runtime message etc that happened inside a flow and build visual tool for monitoring and reporting. One embodiment of a process logger is used to display detailed process history which is organized in a tree table data structure and presentation as shown in . is an exemplary history of an order. Workflow instances are shown in the first column of and may include for example events such as Order Preprocessing Order Provisioning etc. The second column of is a start time of the workflow instances . A history or status field is shown as the third column in the exemplary history logger of . A complete time for completed workflow instances is shown in the fourth column of .

Another tool is to show the running status of all tasks inside a flow in a graph such as that shown in . is an exemplary embodiment of a workflow process for online ordering repair and billing for a telecommunications provider where an ordering application interacts with the PATS layer and underlying workflow engines. The process starts at Step . Step Order Preprocessing is where an ordering flow is started after taking some user input about detailed order information. This task is to create the order in a database and perform some data validation. Step Document Compliance Group DCG Approval is review by a legal group with responsibility of reviewing telecommunication orders to ensure their compliance to all laws imposed by government. In this instance this is manual step and a DCG member assigned to review the order can either reject or accept this order from user interface. Step is Data Gathering where based on user input the telecommunications provider s systems may need extra information about the order. This step is to fill in those data if necessary. Step is Master Circuit ID Processing. This step is for updating notifying the telecommunication provider s inventory system for tracking all of its circuits about orders involving new circuits. Step Billing Account and Subscription Management is a step for creating corresponding billing account generated from the order. Step Order Provisioning is where one or more backend systems are invoked to provision the order. Step Verification of Circuit Activation is a step involving the performance of circuit testing and activation. Step Billing Verification involves a review of the billing record for the user. At Step a billing application is authorized to start the billing process for the order. Step is Order Completion where there is a clean up temporary data and finish final book keeping for the order. The workflow process ends at Step .

The flow diagram of can be displayed inside a browser without heavy installation of Java packaging and is similar to a workflow engine s normal monitoring. This enables users to be able to access and display their flow process from anywhere Internet access is available.

The flow simulator that is included in one embodiment of the PATS layer assists in application flow development and automation of flow testing. In regular flow development if flow pauses for some reason manual work needed error condition occurred or waiting for external system to respond etc the developer needs to manually perform tasks from the user interface or must wait for the backend system to return which is time consuming un reliable and un predictable. The flow simulator is a set of tools provided in the PATS layer to allow flow to be driven automatically programmatically even in case of external system dependencies and human interaction. The flow simulator can simulate user input from the UI and finish a task automatically without going through a normal task assignment user interface. The flow simulator can also simulate a backend system s asynchronous response to let flow continue with a predictable data set. This is helpful for unit tests in development where backend systems may not be accessible. It can also be used in flow recovery in production environment. In one embodiment an XML file is used to capture the data needed for the simulator sample data provided below which assists in configuring and documenting desired flow behavior. Flow can be started and driven to the end with or without human or system interaction thus providing a testing framework for workflow development. To use a flow simulator a workflow is started with an instance of simulator. If a simulator is registered with the flow then the PATS engine forwards all user input or requests to backend systems to the simulator instead of the normal channels thus the simulator intercepts flow execution. Generally a simulator is developed by programming code to conform to a standard API to accept all inputs. In one embodiment the PATS layer provides a default implementation of a simulator which takes an XML about how simulator should respond to various inputs see example below .

It is to be appreciated that the above data simulates user input as well as backend system responses. For example when a manual task with a name such as Please choose bandwidth is generated the flow simulator will automatically respond with an answer such as 128M just like a customer would have from the user interface. Also when calling a backend system with function id the simulator responds with an error that has code . This technique is helpful since an error condition of normal is difficult to get from a real system.

The backend system defines a set of error conditions and sends different error code message back to a workflow for proper handling. While some errors are somewhat routine others happen only in unique situations and aren t easily reproduced in a testing environment. For example the backend system might have an error for hard disk failure which rarely happens in reality. With the PATS flow simulator error scenarios and test flow error handling logic can be easily created instead of waiting for such unusual errors to happen in a real environment. So a simulator can send back a hard disk failure error to a flow whenever the test needs it. Similarly cases can be created for various user inputs without time consuming operations from the user interface. Using this approach workflow test cases can run in a controlled environment and provide comprehensive coverage of different error and or normal scenarios. Not only does this make debugging easier it also provides opportunities to automate system integration tests at the workflow level.

The preferred embodiments of the system described above may be used to provide a user with an interface layer between one or more applications and one or more workflow engines. In order to limit the need for tailored programming between each engine and each workflow manager the embodiments of the present invention provide an API for the applications and a plug in for the workflow engine both of which are not vendor specific so that an application must merely change the configuration without need for deployment of a module.

An embodiment of a system is used in a process for online ordering repair and billing for a telecommunications provider where an ordering application interacts with the PATS layer and underlying workflow engine. The process is described in the flowchart illustrated in . The process starts at Step . At Step a user inputs order information through an online ordering application. For instance an exemplary order could be an order for Internet Protocol Virtual Private Network IPVPN or Frame Relay products that could potentially span multiple regions and systems. At Step the ordering application after receiving the order information will invoke an API to the PATS layer to start a workflow. This invocation is done through a synchronous API call or an asynchronous message. At Step and once the PATS layer gets the instruction to start a workflow it formats the data according to the protocol of underlying workflow engine and sends a request to start a flow there. At Step it is determined if the workflow initiation is successful or not. The workflow engine returns a success or failure message based on workflow starting status. The message is returned to the PATS layer not the application and the PATS layer receives the result and formats it to a unified status message and return the message back to the ordering application. At Step if the workflow initiation is unsuccessful the failure message is returned to the PATS layer from the workflow engine and the process ends at Step . At Step if the workflow initiation is successful the success message is returned to the PATS layer from the workflow engine. The process then continues to Step where the workflow engine will start to drive the flow. Based on a workflow template definition the workflow engine invokes one or more application specific modules. This is done through the PATS layer as well. The workflow engine sends task information to the workflow engine s PATS layer plug in. The PATS plug in will then forward the request and invoke an ordering application to fulfill the work. Since a plug in is normally deployed inside the workflow engine plug in invocation by a workflow engine is normally a direct API call. The PATS layer invokes an application via a PATS specification either EJB or Message interface . At Step it is determined whether the application successfully finishes the task or not. If the application does successfully finish the task then at Step the PATS layer will notify the workflow engine and let it continue. If the application fails to finish the task then at Step the PATS layer sends error information to the workflow engine and the engine waits for an exception clearance. At Step the workflow engine receives an exception clearance. Once an exception is cleared at Step the application notifies the PATS layer and the PATS layer tells the workflow engine to resume its task execution at Step . At Step it is determined whether the flow is complete or a stop condition reached. If not then the process returns to Step where the workflow engine will repeat Step through until all tasks in flow are finished or whatever stop condition reached normally a STOP task node . The process then ends at Step .

Many modifications to the preferred embodiments described herein and other embodiments of the invention will come to mind to one skilled in the art to which this invention pertains having the benefit of the teachings presented in the foregoing descriptions. For instance the trusted sources and their recommendations may be provided audibly rather than visually. Accordingly it should be understood that the invention is not to be limited to the specific embodiments disclosed and that modifications and other embodiments are intended to be included within the scope of the appended exemplary inventive concepts. Although specific terms are employed herein they are used in a generic and descriptive sense only and not for purposes of limitation.

