---

title: Policy based message aggregation framework
abstract: Messages generated by an originating application are aggregated into batches based on a configuration policy. The configuration policy contains business logic used to aggregate messages into a batch. Once a batch is complete, it is formatted into a single stream output and sent to a destination application designed to receive the messages. Messages may also be aggregated into batches that are controlled by the originating application. The messages include an indicator set by the originating application to signal when a batch is complete. Once the batch is complete, it is formatted into a single stream output and sent to a destination application designed to receive the messages.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07890955&OS=07890955&RS=07890955
owner: Microsoft Corporation
number: 07890955
owner_city: Redmond
owner_country: US
publication_date: 20060403
---
In today s global economy companies often need to integrate applications systems and technologies from a variety of sources. Typically these companies create systems for the computer to computer exchange of structured information by agreed upon message standards from one computer application to another by electronic means and with a minimum of human intervention. Examples of message standards include Health Level Seven HL7 for health care related clinical and administrative data GS 1 System for identification and communication of information regarding products assets services and locations SWIFT for financial data and EDI for the exchange of structured information by agreed message standards for the transfer of a variety of business transaction data.

As shown in a business enterprise may communicate with a variety of partners in a variety of message formats. For example the business may communicate with a customer in XML format the business may communicate with a supplier application in EDI or Flat File message format the business may communicate with a financial application in SWIFT message format and the business may communicate with a logistics application in some other industry standard message format.

Unfortunately the variety and number of messages complicates communication and creates inefficiencies in the typical business enterprise. Although solutions for aggregating messages may be written in custom software code such solutions increase complexity and cost in an enterprise and are only suitable for particular circumstances.

Aspects of the invention overcome one or more deficiencies in known computer to computer exchange of structured messages. An extensible policy based message aggregation framework aggregates messages into batches which permits multiple messages to be transmitted as a single output stream to a destination application.

In one aspect the invention involves policy based message aggregation in which aggregation is based on a policy that contains business logic used to aggregate messages into a batch. In another aspect the invention involves application based message aggregation in which the source application sets indicators in the messages that identify the messages to be batched and signal when the batch is complete.

Because the typical business enterprise generates many messages relating to critical business communications message aggregation systems embodying aspects of the invention are reliable and extensible. Also message aggregation may be implemented to decrease costs by accumulating messages and sending the messages when cost for the communication medium used to transmit the messages is lowest and increase performance by lowering the overhead involved with sending single messages by transmitting a bundle of messages at one time.

Computer readable media having computer executable instructions for message aggregation embody further aspects of the invention. Alternatively embodiments of the invention may comprise various other methods and apparatuses.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Referring further to the drawings illustrates one embodiment of a computing system environment for message aggregation. Message aggregation may be implemented to satisfy a number of business needs. For example a business enterprise communicates with a variety of partners in a variety of message formats. Message aggregation allows increased performance at decreased costs while accommodating communication at specified times. In this example the business enterprise may have a policy of ordering supplies from a supplier on a weekly basis. An application may allow the enterprise to order supplies throughout the week by generating messages addressed to a supplier. Embodiments of the invention permit aggregating these messages into a batch at the business enterprise for transmitting weekly to the supplier s application for fulfillment processing.

As another example imagine that a business is receiving a large number of purchase orders from customers. To fulfill each customer purchase order the business orders items from a partner company and the business communicates orders to the partner using EDI. But the connection to the partner company is only available at a certain time of the day. Therefore the business needs to accumulate all the orders for the partner and send them during the appropriate time of day. Additionally businesses often have to pay for connection time to the partner. In this case it is advantageous to bundle up all messages and open the connection once every couple of hours or so and transmit the single bundle of messages at one time. Moreover aspects of the invention permit aggregation of messages in a variety of message formats such as XML EDI Flat File SWIFT or some other industry standard message format.

As shown in a source application generates and sends messages. Those skilled in the art are familiar with sending messages addressed to a send port. A messaging engine receives each message and one or more batchers associated with the send port in the message address receive and aggregate the messages according to aspects of the invention. In one embodiment the source application and a destination application communicate with the messaging engine via endpoints. An endpoint is the logical representation of a location e.g. expressed in URL form providing a physical address for data received or sent. Endpoints in this embodiment are bi directional and are used to pump messages into the messaging engine as well as to get messages out of the messaging engine .

In another embodiment the messaging engine also writes the messages to a data store . If the messages in the batch are independent of one another aspects of the invention may assemble the messages based on selected parameters defined by a business configuration policy. For example the batch configuration policy contains business logic used to determine the number of messages in the batch the cumulative number of bytes in the batch the type of messages in the batch and or the time period for accumulating messages.

In one embodiment batcher is configured on the send port e.g. BatcherType BatcherLocation . For example an adapter framework code base may be leveraged for this and implements an interface for storing the configuration and other send port configuration information. APPENDIX A illustrates an exemplary implementation of a messaging framework for outbound batching embodying aspects of the invention including a batcher interface.

In another embodiment the messaging engine maintains an instance state see for one or more the batchers . The instance state includes a send port associated with the batcher and a list of messages that have been addressed to the send port. The instance states may be stored in the data store . The instance states are used to retrieve messages corresponding to each batcher instance in the event of system failure.

If the batcher associated with a particular send port does not exist the messaging engine will create it. By creating each batcher dynamically batchers are created as needed which promotes the extensibility of the message aggregation system. Additionally dynamic creation of batchers aides system performance by eliminating the overhead of idle batchers and permitting messaging engine to manage an instance state only for active batchers .

By storing the instance state and the messages in data store the batch may be recovered in case of system failure. In one embodiment after restarting messaging engine can access the instance states of the batches that were in progress at the time of failure. For each instance state messaging engine creates an instance of batcher . For each message in the message list of the instance state messaging engine resends the messages to batcher . Once the messages in the list have been resent to batcher the batch will be in the same state as it was at the time of failure.

For example the instance state is a place to store the state of the application instance in this case Assembler Batcher Instance . Although the messages corresponding to the application instance are stored in the data store there is also a need to store information regarding the state of the application instance so that the application can retrieve the instance information to continue processing after a failure. Subscriptions are independent of instance state. The subscription table defines a list of services identified by a Service ID that receive messages satisfying a particular condition. When the message is published to the message box e.g. data store the message box evaluates the condition and identifies which service will receive that message. The message box then creates a logical instance of that service in an Instances table and dispatches the message to the messaging engine after stamping the InstanceID on the message.

In another embodiment the message includes a batcher identifier associated with the batcher . In this embodiment a message box maintains a subscription table defines the list of services identified by a Service ID that receive messages satisfying a particular condition. The message box receives messages from the source application . When the message is published to the message box the message box evaluates the condition and determines which service will receive the message. The message box then creates the instance of the batcher for the service if it does not exist. The message box then sends the message to the messaging engine . The messaging engine hashes the batch identifier to determine the correct instance of the batcher . The messaging engine then sends the message to determined batcher .

Once batcher receives a message it determines if a batch of messages is complete. In one embodiment batcher determines if the batch is complete as a function of a batch configuration policy. The batch configuration policy contains the business logic used to determine when the batch is complete. The business logic may include one or more of the following a number of messages in the batch a cumulative number of bytes in the batch the type of messages in the batch and a time period to accumulate messages. In another embodiment the business logic may include a desired sort order for the messages in the batch which allows batcher to sort the messages within the batch.

The batcher associated with the send port in the message address receives and aggregates the messages according to aspects of the invention. As described above the messages in the batch may be independent of one another. In another embodiment the messages in the batch are dependent on each other and the code that is producing the messages has knowledge of when a new batch is to be started and when that batch should be completed. In this embodiment the message includes a batch end indicator. The batcher will complete the batch if the batch end indicator signals that the batch is complete.

After the batcher has determined that the batch is complete it returns the batch to messaging engine . The messaging engine sends the batch to an assembler . In turn the assembler serializes all the messages in the batch into a single output stream. In an alternative embodiment the batcher itself serializes all the batched messages into a single output stream. The assembler sends the message stream to an destination application associated with an application that is designed to receive the messages.

In another embodiment the message includes a batcher identifier associated with the particular batcher . In this embodiment aspects of the invention perform a check to verify that an instance of the batcher associated with the batch identifier exists. If the batcher associated with batch identifier does not exist an instance of the batcher is created at .

Referring further to messaging engine sends the message to the batcher associated with the send port in the message address at . At the batcher determines if the batch of messages is complete. In one embodiment the batcher determines if the batch is complete as a function of a batch configuration policy which contains the business logic used to make this determination. As described above the business logic may include one or more of the following number of messages in the batch cumulative number of bytes in the batch the type of messages in the batch and a time period to accumulate messages. Advantageously a customer can set its own criteria for batching messages by way of the batch configuration policy. Moreover batcher may sort the messages within the batch according to a desired sort order defined by the batch configuration policy.

If at the batcher determines that the batch is not complete the instance state of the batch will be updated at . The instance state includes a send port associated with the batcher and a list of messages that have been addressed to the send port. The instance states may be stored in data store . On the other hand if the batcher determines at that the batch is complete a message set is created from the batch at . At the batcher sends the message set to the assembler where messages are sent in a single output stream to a destination application . The destination application may be for example a customer application a supplier application or a financial application. The output stream may be in EDI format SWIFT format GS1 System HL7 or some other industry standard format as designated by the destination application . After the output stream has been sent at the instance state of the batcher is updated.

In one embodiment if new message for the batcher is received at while the messaging engine is either creating a message set for the batcher at or sending the message set to the assembler at the messaging engine will create a new instance of the batcher at . The process will continue on at for the new instance of the batcher . This allows the messaging engine to handle concurrent batches where one batch is in the process of being sent to the assembler while a new batch is begun on a new instance of the batcher .

For example when the batcher determines that a batch is complete the messaging engine takes note of it and passes the single output stream to the assembler . However if in the mean time the messaging engine receives a new message for that same send port the messaging engine will realize that the previous batch is complete and create a new batcher and hence a new batch. The multiple inflight batchers are identified by a batcherID .

The server typically has at least some form of computer readable media. Computer readable media which include both volatile and nonvolatile media removable and non removable media may be any available medium that may be accessed by server . By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. For example computer storage media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage such as the data store or other magnetic storage devices or any other medium that may be used to store the desired information and that may be accessed by server . Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. Those skilled in the art are familiar with the modulated data signal which has one or more of its characteristics set or changed in such a manner as to encode information in the signal. Wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media are examples of communication media. Combinations of any of the above are also included within the scope of computer readable media.

The server may also include other removable non removable volatile nonvolatile computer storage media. Other removable non removable volatile nonvolatile computer storage media that may be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like.

The drives or other mass storage devices and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the server .

The server may operate in a networked environment using logical connections to one or more remote servers such as remote servers A B C. The remote server may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to server . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. LAN and or WAN may be a wired network a wireless network a combination thereof and so on. Such networking environments are commonplace in offices enterprise wide computer networks intranets and global computer networks e.g. the Internet .

When used in a local area networking environment server is connected to the LAN through a network interface or adapter. When used in a wide area networking environment server typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external is connected to system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to computer or portions thereof may be stored in a remote memory storage device not shown . The network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Generally the data processors of server are programmed by means of instructions stored at different times in the various computer readable storage media of the computer. Programs and operating systems are typically distributed for example on floppy disks or CD ROMs. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory. Aspects of the invention described herein includes these and other various types of computer readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. Further aspects of the invention include the computer itself when programmed according to the methods and techniques described herein.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks. It is recognized however that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

Although described in connection with an exemplary computing system environment including server embodiments of the invention are operational with numerous other general purpose or special purpose computing system environments or configurations. The computing system environment is not intended to suggest any limitation as to the scope of use or functionality of any aspect of the invention. Moreover the computing system environment should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment. Examples of well known computing systems environments and or configurations that may be suitable for use with aspects of the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Embodiments of the invention may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. Aspects of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

An interface in the context of a software architecture includes a software module component code portion or other sequence of computer executable instructions. The interface includes for example a first module accessing a second module to perform computing tasks on behalf of the first module. The first and second modules include in one example application programming interfaces APIs such as provided by operating systems component object model COM interfaces e.g. for peer to peer application communication and extensible markup language metadata interchange format XMI interfaces e.g. for communication between web services .

The interface may be a tightly coupled synchronous implementation such as in Java 2 Platform Enterprise Edition J2EE COM or distributed COM DCOM examples. Alternatively or in addition the interface may be a loosely coupled asynchronous implementation such as in a web service e.g. using the simple object access protocol . In general the interface includes any combination of the following characteristics tightly coupled loosely coupled synchronous and asynchronous. Further the interface may conform to a standard protocol a proprietary protocol or any combination of standard and proprietary protocols.

The interfaces described herein may all be part of a single interface or may be implemented as separate interfaces or any combination therein. The interfaces may execute locally or remotely to provide functionality. Further the interfaces may include additional or less functionality than illustrated or described herein.

In operation server executes computer executable instructions such as those illustrated in the figures to implement aspects of the invention.

The order of execution or performance of the operations in embodiments of the invention illustrated and described herein is not essential unless otherwise specified. That is the operations may be performed in any order unless otherwise specified and embodiments of the invention may include additional or fewer operations than those disclosed herein. For example it is contemplated that executing or performing a particular operation before contemporaneously with or after another operation is within the scope of aspects of the invention.

Embodiments of the invention may be implemented with computer executable instructions. The computer executable instructions may be organized into one or more computer executable components or modules. Aspects of the invention may be implemented with any number and organization of such components or modules. For example aspects of the invention are not limited to the specific computer executable instructions or the specific components or modules illustrated in the figures and described herein. Other embodiments of the invention may include different computer executable instructions or components having more or less functionality than illustrated and described herein.

When introducing elements of aspects of the invention or the embodiments thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

As various changes could be made in the above constructions products and methods without departing from the scope of aspects of the invention it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

Outbound batching A batcher component includes the logic that is used to cut the batch i.e. decide when the batch is done. Also the batcher component encapsulates any other logic that is used to decide the order of messages in the batch etc. A messaging engine component includes the code that is responsible for interacting with the batcher component the pipeline and the database.

Standard batchers allow the messaging engine to handle all message persistence without the batcher s interaction. The type of the batcher is returned back to the messaging engine in a propertyBag in the call to Initialize . For standard batchers the messaging engine will automatically persist the message to instance state after every call to AddMessage till the batch is full.

High performance batchers are capable of pure in memory batching and tell the messaging engine when to persist messages. For these batchers the messaging engine will not persist the message to instance state after every call to AddMessage . Instead the batcher is able to accumulate messages in memory. In this manner when the batch is full the batcher can call BatchComplete on the messaging engine and give the IBaseMessageSet. The messaging engine is then able to directly execute the pipeline without having to read message from the instance state. These batchers may also have a configured threshold of holding messages in memory. Whenever the batcher would like to flush persist the messages to disk it can call PersistMessages API to do the same. If the batcher has called PersistMessages once then it ensures that it persists all in memory messages before it calls BatchComplete with the MessageIDs.

When the messaging engine gets a message going to a batched send port it checks to see if a batcher component has already been created for this sendport by looking at an internal hash table. If there is no batcher component already created it creates a new one and call Initialize on the batcher component.

The engine then calls AddMessage on the batcher component for that message. The batcher component looks at the message and decides if the batch is full. If the batch is full then it calls back the engine ICallback indicating a success batch status. If the batch is not full then the batcher component returns back from AddMessage after updating its internal state.

For standard batchers when AddMessage returns and the batch is not full the engine writes the message to the instance state. On the other hand when the batch is complete the batcher returns an IMessageSet back to messaging engine. The engine attempts to access the MessageIDList which has the message IDs of the messages in the right order any kind of sorting is done by the batcher on this list . Given the MessageIDList The engine may start pulling messages out of the instance state in the right order. The engine creates a message set out of these documents and then gives this message set to the pipeline manager to execute the pipeline.

High performance batchers in contrast to standard batchers periodically call PersistMessages on the ICallback to flush messages to instance state. If more messages arrive for this batch the engine calls AddMessage on the batcher component that was created earlier. The callback ICallback may be called synchronously from AddMessage or may be called asynchronously by the batcher component. If the batch has to be cut based on time then the batcher component waits for a windows timer for the batch i.e. if the time out occurs then it calls back the engine and tells it that the batch is complete. When the batch is complete the batcher returns an IMessageset back to the engine. The engine first attempts to access the MessageIDList same as for standard batchers . If the MessageIDList is empty the engine attempts to read the MessageList. This has a valid value if the batcher is doing in memory batching. If the MessageList is present the engine will create an IBaseMessaegSet and will execute the pipeline.

Pipeline Execution An interface in the pipeline manager permits the engine to give a message set to the pipeline for execution. The pipeline manager then calls AddDocument on the assembler for all the messages in the message set and then assembles the messages.

The messaging engine creates a dummy Instance when the 1 st message for a send port configured for independent batching is received from agent. The engine maintains a hash table that maps SendPortID to batcher pipeline pointer. At any point of time there is one active batcher component in which any new messages going to the send port will be fed to only the active batcher component. Other batcher components may be inactive in for example a failover scenario.

For dependent message batching the following are configured on a send port. Send port has the option whereby users can select the property that will be used for forming dependent batches. For example if the selected message context property is BTS.BatchID then a convoy subscription is created for the send port. Each message has at least two special message context properties a Property used for the convoy BTS.BatchID b BTS.BatchEnd true false used by the batcher c BTS.BatchStart true false also used by batcher. Properties b and c are configured in the Batcher property pages and do not appear in the send port properties.

The producer of the messages A workflow schedule or a pipeline service promotes BTS.BatchID for every message that it is publishing for this send port. Messages having the same BTS.BatchID are sent to the same instance of the send port for batching. The producer of the messages knows when the batch is complete and will be writing the BTS.BatchEnd.

To start a new batch the publisher of the messages promotes BTS.BatchID which is unique and publishes the message. A new instance is created by the message box after checking the convoy table.

Subsequent messages having the same BTS.BatchID are delivered on the same instance by the msgbox. When these messages are delivered to the messaging engine it already knows that they are dependent message batches sendport configuration . The engine hashes BTS.BatchID to the correct batcher pointer.

The batcher may perform the following for dependent batches a Batcher looks at the BTS.BatchEnd property and determines when to cut the batch b Batcher handles failure cases e.g. if the user wants to have a time out c Batcher sorts messages.

The engine may write messages to the instance state of the current instance depending on if it is standard batcher or a high performance batcher as described above.

If the batch is complete the engine executes the assembler and sends the message out. When the assembled message is successfully sent out deleteMessage the framework instanceCompletes the instance that was created due to the convoy. All the other issues retries movetonextTransport catastrophic failure etc. are similar to independent message batching.

When a message is written to the instance state the framework first writes the messageID to the instance stream. Then it calls agent API AddMessageObject .

Also when writing a message to the instance state the framework receivecomplete the original message in the same transaction to delete the original message from the ApplicationQ.

To read messages out of the instance state the framework uses the messageIDs. In other words the framework reads the instance stream first to get the messageIDs and then uses them to get the messages. Pulling messages out by message ID maintains order as well.

If the process dies due to some catastrophic failure then the message box creates a dummy message the next time around when the process comes back up. The messaging engine receives this dummy message and can identify that this message corresponds to the sendport that is being batched. That is before writing to the instance state for the first message for the instance the messaging engine writes the destination SendPortID and other relevant information to the instance state stream.

If the send port is configured for an independent message batch then when an instance fails over it may be given back to a messaging engine instance that already has an active batcher in use. Hence when the keep alive dummy message is received by the messaging engine the messaging engine drains the whole batch stored in the instance state in the same thread. The messaging engine creates a new batcher object and initializes it. The property bag passed by the messaging engine to the batcher indicates that this is a failed over instance. Also if possible the messaging engine also provides the number of messages in the batch. The messaging engine then reads all the messages out of the instance state and calls AddMessage on the batcher. When the batcher receives the last message it calls BatchComplete on the messaging engine.

Depending on how the batcher is configured it can either pass or fail the batch. If the batch is failed then the messaging engine suspends all the messages in the batch.

Successful transmission The adapter calls DeleteMessage on the message that came out of the pipeline. The messages from the Q have already been received completed so messages in the InstanceState are deleted. To delete a message from an instance state the framework calls agent API ReleaseMessage .

Resubmits The messages from the Q have already been received completed so the framework retries the messages that are in the InstanceState. A timer message that comes back after the retry interval is posted. When the messaging engine sees the timer message reading messages out of the instance state restarts and processing resumes. Again the messageIDs are read from the instance stream in order and then the messages are pulled from the instance state.

MoveToNextTransport The messaging engine posts a message to the instance. When this message comes back up the messaging engine knows that the message is getting moved to the backup transport and it attempts to drain the messages from the instance state and process the batch.

SuspendMessage The messages inside the InstanceState pulled out of the instance state and suspended using the SuspendMessages Messageld API which moves these message from the instance state to the suspendQ. Alternatively a message may be posted to the dummy instance and the dummy instance suspended. When the message is resumed the instance state is drained.

The batched send port is also marked for ordered delivery When this happens the messaging engine does not create a dummy instance for the send port even for the case of independent batches. The messaging engine automatically uses the instance state corresponding to the default instance for the ordered send port. The behavior may marginally change in the fact that before giving up the agent delivery thread the messaging engine blocks for the adapter to acknowledge that the message was sent or failed the callbacks on the batch .

Tracking A link may be maintained between the input messages to the send pipeline and the output message. When a message is moved from the applicationQ to the instance state calling ReceiveComplete on the message deletes the message from the applicationQ. The status in HAT when this happens is distinguishable from the status shown when the message is fully processed i.e. DeleteMessage translates to ReceiveComplete .

