---

title: Estimating sample-domain distortion in the transform domain with rounding compensation
abstract: Techniques and tools are described for compensating for rounding when estimating sample-domain distortion in the transform domain. For example, a video encoder estimates pixel-domain distortion in the transform domain for a block of transform coefficients after compensating for rounding in the DC coefficient of the block. In this way, the video encoder improves the accuracy of pixel-domain distortion estimation but retains the computational advantages of performing the estimation in the transform domain. Rounding compensation includes, for example, looking up an index (from a de-quantized transform coefficient) in a rounding offset table to determine a rounding offset, then adjusting the coefficient by the offset. Other techniques and tools described herein are directed to creating rounding offset tables and encoders that make encoding decisions after considering rounding effects that occur after an inverse frequency transform on de-quantized transform coefficient values.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08059721&OS=08059721&RS=08059721
owner: Microsoft Corporation
number: 08059721
owner_city: Redmond
owner_country: US
publication_date: 20060407
---
Digital video consumes large amounts of storage and transmission capacity. A typical raw digital video sequence includes 15 or 30 frames per second. Each frame can include tens or hundreds of thousands of pixels also called pels where each pixel represents a tiny element of the picture. In raw form a computer commonly represents a pixel as a set of three samples totaling 24 bits. Thus the number of bits per second or bit rate of a typical raw digital video sequence may be 5 million bits per second or more.

Many computers and computer networks lack the resources to process raw digital video. For this reason engineers use compression also called coding or encoding to reduce the bit rate of digital video. Compression decreases the cost of storing and transmitting video by converting the video into a lower bit rate form. Decompression also called decoding reconstructs a version of the original video from the compressed form. A codec is an encoder decoder system. Compression can be lossless in which the quality of the video does not suffer but decreases in bit rate are limited by the inherent amount of variability sometimes called entropy of the video data. Or compression can be lossy in which the quality of the video suffers but achievable decreases in bit rate are more dramatic. Lossy compression is often used in conjunction with lossless compression the lossy compression establishes an approximation of information and the lossless compression is applied to represent the approximation.

A basic goal of lossy compression is to provide good rate distortion performance. So for a particular bit rate an encoder attempts to provide the highest quality of video. Or for a particular level of quality fidelity to the original video an encoder attempts to provide the lowest bit rate encoded video. In practice considerations such as encoding time encoding complexity encoding resources decoding time decoding complexity decoding resources overall delay and or smoothness in quality bit rate changes also affect decisions made in codec design as well as decisions made during actual encoding.

In general video compression techniques include intra picture compression and inter picture compression. Intra picture compression techniques compress individual pictures and inter picture compression techniques compress pictures with reference to a preceding and or following picture often called a reference or anchor picture or pictures.

With quantization the encoder essentially trades off quality and bit rate. More specifically quantization can affect the fidelity with which the transform coefficients are encoded which in turn can affect bit rate. Coarser quantization tends to decrease fidelity to the original transform coefficients as the coefficients are more coarsely approximated. Bit rate also decreases however when decreased complexity can be exploited with lossless compression. Conversely finer quantization tends to preserve fidelity and quality but result in higher bit rates.

Different encoders use different parameters for quantization. In most encoders a level or step size of quantization is set for a block picture or other unit of video. In some encoders the encoder can also adjust the dead zone which is the range of values around zero that are approximated as zero. Some encoders quantize coefficients differently within a given block so as to apply relatively coarser quantization to perceptually less important coefficients and a quantization matrix can be used to indicate the relative weights. Or apart from the rules used to reconstruct quantized values some encoders vary the thresholds according to which values are quantized so as to quantize certain values more aggressively than others.

Returning to further encoding varies depending on whether a coefficient is a DC coefficient the lowest frequency coefficient shown as the top left coefficient in the block an AC coefficient in the top row or left column in the block or another AC coefficient. The encoder typically encodes the DC coefficient as a differential from the reconstructed DC coefficient of a neighboring 8 8 block. The encoder entropy encodes the differential. The entropy encoder can encode the left column or top row of AC coefficients as differentials from AC coefficients a corresponding left column or top row of a neighboring 8 8 block. The encoder scans the 8 8 block of predicted quantized AC coefficients into a one dimensional array . The encoder then entropy encodes the scanned coefficients using a variation of run level coding .

In corresponding decoding a decoder produces a reconstructed version of the original 8 8 block. The decoder entropy decodes the quantized transform coefficients scanning the quantized coefficients into a two dimensional block and performing AC prediction and or DC prediction as needed. The decoder inverse quantizes the quantized transform coefficients of the block and applies an inverse frequency transform such as an inverse DCT IDCT to the de quantized transform coefficients producing the reconstructed version of the original 8 8 block. When a picture is used as a reference picture in subsequent motion compensation see below an encoder also reconstructs the picture.

Inter picture compression techniques often use motion estimation and motion compensation to reduce bit rate by exploiting temporal redundancy in a video sequence. Motion estimation is a process for estimating motion between pictures. In one common technique an encoder using motion estimation attempts to match a block of samples in a current picture with a block of samples in a search area in another picture called the reference picture. When the encoder finds an exact or close enough match in the search area in the reference picture the encoder parameterizes the change in position of the blocks as motion data such as a motion vector . In general motion compensation is a process of reconstructing pictures from reference picture s using motion data.

The encoder computes the sample by sample difference between the current unit and the predictor to determine a residual also called error signal . The residual is frequency transformed quantized and entropy encoded. The overall bit rate of a predicted picture depends in large part on the bit rate of residuals. The bit rate of residuals is low if the residuals are simple i.e. due to motion estimation that finds exact or good matches or lossy compression drastically reduces the complexity of the residuals. Bits saved with successful motion estimation can be used to improve quality elsewhere or reduce overall bit rate. On the other hand the bit rate of complex residuals can be higher depending on the degree of lossy compression applied to reduce the complexity of the residuals.

Encoders typically spend a large proportion of encoding time performing motion estimation attempting to find good matches and thereby improve rate distortion performance. In most scenarios however an encoder lacks the time or resources to check every possible motion vector for every block or macroblock to be encoded. The encoder therefore uses motion vector search patterns and matching heuristics deemed likely to find a good match in an acceptable amount of time.

The number of motion vectors used to represent a picture can also affect rate distortion performance. Using four motion vectors for four different 8 8 blocks of a 16 16 macroblock instead of one motion vector for the macroblock allows an encoder to capture different motion for the different blocks potentially resulting in better matches. On the other hand motion vector information for four motion vectors instead of one is signaled increasing bit rate of motion data.

The encoder applies a frequency transform to the residual producing a block of transform coefficients . Some encoders switch between different sizes of transforms e.g. an 8 8 transform two 4 8 transforms two 8 4 transforms or four 4 4 transforms for an 8 8 prediction residual block. Smaller transform sizes allow for greater isolation of transform coefficients having non zero values but generally require more signaling overhead. shows the encoder using one 8 8 transform.

The encoder quantizes the transform coefficients and scans the quantized coefficients into a one dimensional array such that coefficients are generally ordered from lowest frequency to highest frequency. The encoder entropy codes the data in the array .

If a predicted picture is used as a reference picture for subsequent motion compensation the encoder reconstructs the predicted picture. When reconstructing residuals the encoder reconstructs transform coefficients that were quantized and performs an inverse frequency transform. The encoder performs motion compensation to compute the motion compensated predictors and combines the predictors with the residuals. During decoding a decoder typically entropy decodes information and performs analogous operations to reconstruct residuals perform motion compensation and combine the predictors with the reconstructed residuals.

The previous two sections mention some of the decisions that an encoder can make during encoding. When encoding a block of a predicted picture an encoder can evaluate and set a number of coding parameters including 1 whether the block should be encoded as an intra or inter 2 the number of motion vectors 3 the value s of motion vector s 4 the type of frequency transform 5 the size of frequency transform e.g. 8 8 4 8 8 4 or 4 4 6 the quantization step size 7 the quantization thresholds to apply 8 the dead zone size and 9 the quantization matrix. Or for a block of an intra coded picture the encoder can evaluate and set various quantization related parameters. Depending on implementation an encoder may finalize certain parameter decisions before starting to evaluate other parameters. Or the encoder may jointly explore different combinations of coding parameters which makes the decision making process even more complex given the number of permutations to evaluate.

In making encoding decisions an encoder often evaluates the distortion and rate associated with the different choices. In particular for a block to be encoded pixel domain distortion of the block encoded according to different coding choices is an important criterion in encoder mode decisions. There are several approaches to determining pixel domain distortion.

In one approach an encoder performs inverse quantization to reconstruct transform coefficients for a block and performs an inverse frequency transform on the de quantized transform coefficients. The encoder directly measures pixel domain distortion by comparing the reconstructed pixel domain values for the block to the original pixel domain values for the block. While this approach yields accurate pixel domain distortion measurements it is expensive in terms of encoding time and resources. Performing an inverse frequency transform for every evaluated coding choice greatly increases the computational complexity of the encoding task. As a result encoding time increases or more encoding resources are required. Or to handle practical time or resource constraints an encoder evaluates fewer coding options which can result in the encoder missing efficient options.

In another approach an encoder performs inverse quantization to reconstruct transform coefficients for a block but measures distortion in the transform domain. The encoder measures transform domain distortion by comparing the de quantized transform coefficients for the block to the original transform coefficients for the block. To estimate pixel domain distortion for the block the encoder can multiply the transform domain distortion by a scale factor that depends on the frequency transform used. If the transform is orthogonal the encoder multiplies the transform domain distortion by a non zero scale factor so that the energy in the transform domain is roughly equivalent to the energy in the pixel domain. In this approach the encoder does not perform an inverse frequency transform for every evaluated coding choice so computational complexity is lowered. The pixel domain distortion estimated by this approach is often inaccurate however particularly when only the DC coefficient of a block has a significant value. This inaccuracy in pixel domain distortion estimation can lead to inefficient choices of coding parameters and poor rate distortion performance.

Given the critical importance of video compression to digital video it is not surprising that video compression is a richly developed field. Whatever the benefits of previous video compression techniques however they do not have the advantages of the following techniques and tools.

The present application is directed to techniques and tools for compensating for rounding when estimating sample domain distortion in the transform domain. For example a video encoder estimates pixel domain distortion in the transform domain for a block of transform coefficients after compensating for rounding effects in the DC coefficient of the block. In this way the video encoder improves the accuracy of the pixel domain distortion estimation but retains the computational advantages of performing the estimation in the transform domain.

According to a first aspect of the described techniques and tools a tool such as a video encoder compensates for rounding in a coefficient of a set of transform coefficients. The tool estimates sample domain distortion using the rounding compensated coefficient and other transform coefficients of the set. The tool then makes a decision based on the estimated distortion and outputs results.

For example a video encoder compensates for rounding by looking up a table index determined from a DC coefficient of a block of de quantized transform coefficients in a rounding offset table to determine a rounding offset then adjusting the DC coefficient by the rounding offset. When estimating distortion the encoder computes the difference between the original DC coefficient and the rounding compensated DC coefficient. The encoder eventually selects between intra and inter encoding for the block based upon distortion estimates.

According to a second aspect of the described techniques and tools an encoder includes a frequency transformer a quantizer an entropy encoder an inverse quantizer and a controller. The controller makes encoding decisions after considering post inverse frequency transform rounding effects on de quantized transform coefficient values.

According to a third aspect of the described techniques and tools a range of values for a de quantized transform coefficient is identified. A rounding offset is computed for each of multiple values in the range. A periodic pattern in the offsets is identified and representative values are mapped to corresponding rounding offsets in an offset table. The corresponding rounding offsets show at least one period of the pattern without the table including all values in the range. In this way table size is reduced. The table is stored in computer storage or elsewhere. For example the offset table is created off line and distributed with a video encoder for use during video encoding.

This summary introduces a selection of concepts in a simplified form. The concepts are further described below in the detailed description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The foregoing and other objects features and advantages will become more apparent from the following detailed description which proceeds with reference to the accompanying figures.

The present application relates to techniques and tools for estimating sample domain distortion in the transform domain with rounding compensation. In various described embodiments a video encoder incorporates techniques for estimating pixel domain distortion in the transform domain with rounding compensation.

Various alternatives to the implementations described herein are possible. For example certain techniques described with reference to flowchart diagrams can be altered by changing the ordering of stages shown in the flowcharts by repeating or omitting certain stages etc. The various techniques and tools described herein can be used in combination or independently. Different embodiments implement one or more of the described techniques and tools. Aside from uses in video encoding sample domain distortion estimation in the transform domain with rounding compensation can be used in image encoding video transcoding image classification or other areas.

Some of the techniques and tools described herein address one or more of the problems noted in the Background. Typically a given technique tool does not solve all such problems. Rather in view of constraints and tradeoffs in encoding time resources and or quality the given technique tool improves encoding performance for a particular implementation or scenario.

With reference to the computing environment includes at least one processing unit and memory . In this most basic configuration is included within a dashed line. The processing unit executes computer executable instructions and may be a real or a virtual processor. In a multi processing system multiple processing units execute computer executable instructions to increase processing power. The memory may be volatile memory e.g. registers cache RAM non volatile memory e.g. ROM EEPROM flash memory etc. or some combination of the two. The memory stores software implementing an encoder with one or more of the described techniques and tools for sample domain distortion estimation in the transform domain with rounding compensation.

A computing environment may have additional features. For example the computing environment includes storage one or more input devices one or more output devices and one or more communication connections . An interconnection mechanism not shown such as a bus controller or network interconnects the components of the computing environment . Typically operating system software not shown provides an operating environment for other software executing in the computing environment and coordinates activities of the components of the computing environment .

The storage may be removable or non removable and includes magnetic disks magnetic tapes or cassettes CD ROMs DVDs or any other medium which can be used to store information and which can be accessed within the computing environment . The storage stores instructions for the software implementing the video encoder.

The input device s may be a touch input device such as a keyboard mouse pen or trackball a voice input device a scanning device or another device that provides input to the computing environment . For audio or video encoding the input device s may be a sound card video card TV tuner card or similar device that accepts audio or video input in analog or digital form or a CD ROM or CD RW that reads audio or video samples into the computing environment . The output device s may be a display printer speaker CD writer or another device that provides output from the computing environment .

The communication connection s enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer executable instructions audio or video input or output or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired or wireless techniques implemented with an electrical optical RF infrared acoustic or other carrier.

The techniques and tools can be described in the general context of computer readable media. Computer readable media are any available media that can be accessed within a computing environment. By way of example and not limitation with the computing environment computer readable media include memory storage communication media and combinations of any of the above.

The techniques and tools can be described in the general context of computer executable instructions such as those included in program modules being executed in a computing environment on a target real or virtual processor. Generally program modules include routines programs libraries objects classes components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer executable instructions for program modules may be executed within a local or distributed computing environment.

For the sake of presentation the detailed description uses terms like decide and analyze to describe computer operations in a computing environment. These terms are high level abstractions for operations performed by a computer and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.

The encoder processes video pictures. The term picture generally refers to source coded or reconstructed image data. For progressive video a picture is a progressive video frame. For interlaced video a picture may refer to an interlaced video frame the top field of the frame or the bottom field of the frame depending on the context. The encoder is block based and use a 4 2 0 macroblock format for frames with each macroblock including four 8 8 luminance blocks at times treated as one 16 16 macroblock and two 8 8 chrominance blocks. For fields the same or a different macroblock organization and format may be used. The 8 8 blocks may be further sub divided at different stages e.g. at the frequency transform and entropy encoding stages. The encoder can perform operations on sets of samples of different size or configuration than 8 8 blocks and 16 16 macroblocks. Alternatively the encoder is object based or uses a different macroblock or block format.

Returning to the encoder system compresses predicted pictures and intra coded key pictures. For the sake of presentation shows a path for key pictures through the encoder system and a path for predicted pictures. Many of the components of the encoder system are used for compressing both key pictures and predicted pictures. The exact operations performed by those components can vary depending on the type of information being compressed.

A predicted picture e.g. progressive P frame or B frame interlaced P field or B field or interlaced P frame or B frame is represented in terms of prediction from one or more other pictures which are typically referred to as reference pictures or anchors . A prediction residual is the difference between predicted information and corresponding original information. In contrast a key picture e.g. progressive I frame interlaced I field or interlaced I frame is compressed without reference to other pictures.

If the current picture is a predicted picture a motion estimator estimates motion of macroblocks or other sets of samples of the current picture with respect to one or more reference pictures. The picture store buffers a reconstructed previous picture for use as a reference picture. When multiple reference pictures are used the multiple reference pictures can be from different temporal directions or the same temporal direction. The encoder system can use the separate stores and for multiple reference pictures.

The motion estimator can estimate motion by full sample sample sample or other increments and can switch the precision of the motion estimation on a picture by picture basis or other basis. The motion estimator and compensator also can switch between types of reference picture sample interpolation e.g. between bicubic and bilinear on a per picture or other basis. The precision of the motion estimation can be the same or different horizontally and vertically. The motion estimator outputs as side information motion information such as differential motion vector information. The encoder encodes the motion information by for example computing one or more motion vector predictors for motion vectors computing differentials between the motion vectors and motion vector predictors and entropy coding the differentials. To reconstruct a motion vector a motion compensator combines a motion vector predictor with differential motion vector information.

The motion compensator applies the reconstructed motion vectors to the reconstructed reference picture s when forming a motion compensated current picture . The difference if any between a block of the motion compensated current picture and corresponding block of the original current picture is the prediction residual for the block. During later reconstruction of the current picture reconstructed prediction residuals are added to the motion compensated current picture to obtain a reconstructed picture that is closer to the original current picture . In lossy compression however some information is still lost from the original current picture . Alternatively a motion estimator and motion compensator apply another type of motion estimation compensation.

A frequency transformer converts spatial domain video information into frequency domain i.e. spectral transform data. For block based video pictures the frequency transformer applies a DCT variant of DCT or other forward block transform to blocks of the samples or prediction residual data producing blocks of frequency transform coefficients. Alternatively the frequency transformer applies another conventional frequency transform such as a Fourier transform or uses wavelet or sub band analysis. The frequency transformer may apply an 8 8 8 4 4 8 4 4 or other size frequency transform.

A quantizer then quantizes the blocks of transform coefficients. The quantizer applies uniform scalar quantization to the spectral data with a step size that varies on a picture by picture basis or other basis. The quantizer can also apply another type of quantization to the spectral data coefficients for example a non uniform vector or non adaptive quantization. In addition to adaptive quantization the encoder can use frame dropping adaptive filtering or other techniques for rate control.

When a reconstructed current picture is needed for subsequent motion estimation compensation an inverse quantizer performs inverse quantization on the quantized spectral data coefficients. An inverse frequency transformer performs an inverse frequency transform producing blocks of reconstructed prediction residuals for a predicted picture or samples for a key picture . If the current picture was a key picture the reconstructed key picture is taken as the reconstructed current picture not shown . If the current picture was a predicted picture the reconstructed prediction residuals are added to the motion compensated predictors to form the reconstructed current picture. One or both of the picture stores buffers the reconstructed current picture for use in subsequent motion compensated prediction. In some embodiments the encoder applies a de blocking filter to the reconstructed frame to adaptively smooth discontinuities and other artifacts in the picture.

The entropy coder compresses the output of the quantizer as well as certain side information e.g. motion information quantization step size . Typical entropy coding techniques include arithmetic coding differential coding Huffman coding run length coding LZ coding dictionary coding and combinations of the above. The entropy coder typically uses different coding techniques for different kinds of information and can choose from among multiple code tables within a particular coding technique.

The entropy coder provides compressed video information to the multiplexer MUX . The MUX may include a buffer and a buffer level indicator may be fed back to a controller. Before or after the MUX the compressed video information can be channel coded for transmission over the network. The channel coding can apply error detection and correction data to the compressed video information .

A controller not shown receives inputs from various modules such as the motion estimator frequency transformer quantizer inverse quantizer entropy coder and buffer . The controller evaluates intermediate results during encoding for example estimating distortion and performing other rate distortion analysis. The controller works with modules such as the motion estimator frequency transformer quantizer and entropy coder to set and change coding parameters during encoding. When an encoder evaluates different coding parameter choices during encoding the encoder may iteratively perform certain stages e.g. quantization and inverse quantization to evaluate different parameter settings. The encoder may set parameters at one stage before proceeding to the next stage. Or the encoder may jointly evaluate different coding parameters for example jointly making an intra inter block decision and selecting motion vector values if any for a block. The tree of coding parameter decisions to be evaluated and the timing of corresponding encoding depends on implementation.

The relationships shown between modules within the encoder indicate general flows of information in the encoder other relationships are not shown for the sake of simplicity. In particular usually does not show side information indicating the encoder settings modes tables etc. used for a video sequence picture macroblock block etc. Such side information once finalized is sent in the output bitstream typically after entropy encoding of the side information.

Particular embodiments of video encoders typically use a variation or supplemented version of the generalized encoder . Depending on implementation and the type of compression desired modules of the encoder can be added omitted split into multiple modules combined with other modules and or replaced with like modules. For example the controller can be split into multiple controller modules associated with different modules of the encoder. In alternative embodiments encoders with different modules and or other configurations of modules perform one or more of the described techniques.

Techniques and tools described herein provide ways to estimate sample domain distortion accurately in the transform domain. In particular an encoder or other tool estimates sample domain distortion using transform coefficients after compensating for at least some of the rounding that would occur following an inverse frequency transform.

When selecting certain coding parameters an encoder evaluates the distortion and or rate associated with different coding parameter choices in order to improve rate distortion performance. In particular pixel domain distortion is an important factor in encoding decisions in many systems. The pixel domain distortion for a block is based on differences between original sample values for the block and reconstructed sample values for the block. As such the pixel domain distortion reflects fidelity changes from throughout encoding e.g. from quantization and reconstruction e.g. from rounding after an inverse frequency transform .

One problem with computing distortion in the sample domain is that fully reconstructing sample values requires an inverse frequency transform. This adds a small computational cost every time a coding parameter or combination is evaluated with pixel domain distortion measurement. Even if the cost of performing a single inverse frequency transform is small in the aggregate the computational cost becomes significant.

One way to avoid the cost of performing an inverse frequency transform per distortion measurement is to estimate pixel domain distortion in the transform domain with reference to transform coefficients. By speeding up estimation a particular set of coding parameters can be evaluated more quickly or more coding parameters can be evaluated within a particular duration of time. Such transform domain estimations are inaccurate in many cases however in that they do not correlate well with corresponding pixel domain distortion measurements even when scaling factors compensate for differences in pixel domain energy and transform domain energy.

For example suppose an encoder frequency transforms an 8 8 block of uniform sample values all 1 into the following 8 8 block of transform coefficients.

Following quantization and inverse quantization suppose the 8 8 block of transform coefficients has the following de quantized values.

If the encoder estimates pixel domain distortion using the transform coefficients of blocks a and b the difference in DC coefficient values indicates distortion has been introduced. This might not correlate with pixel domain distortion however. Suppose that when the encoder applies an inverse frequency transform to block b due to rounding effects after the inverse frequency transform an 8 8 block of uniform sample values all 1 is reconstructed. In that case effectively no pixel domain distortion has been introduced contrary to the estimate of pixel domain distortion made using only the transform coefficients.

Depending on the distortion metric used block b might be even considered less favorable than another block such as 

If the encoder applies an inverse frequency transform to block c however the 8 8 block may have non uniform sample values due to the effect of the non zero AC coefficient. This shows another mismatch between estimated and actual pixel domain distortion values.

In many implementations after an encoder performs an integer forward frequency transform the results of the transform are not normalized completely. In other words the intermediate representation of information has a higher resolution than the original representation. This allows the encoder to retain precision in intermediate results. Although rounding may occur in the intermediate results after the forward integer transform the rounding often is insignificant in absolute terms and relative to subsequent quantization. After the encoder or a decoder performs the integer inverse frequency transform however rounding effects are typically much more significant. After the inverse transform results are returned to the resolution of the original representation which can include normalization to account for retained precision expansion from the forward transform as well as expansion from the inverse transform.

More formally suppose circumflex over X represents de quantized transform coefficients for a block and circumflex over x represents the inverse frequency transformed de quantized transform coefficients T circumflex over X . The de quantized transform coefficients are not necessarily the same as the transform of circumflex over x . For example circumflex over X does not equal T T circumflex over X . Due to rounding effects distortion calculated in the transform domain using de quantized transform coefficient values circumflex over X and original transform coefficient values X is biased and may lead the encoder to make a wrong decision.

For many inverse transforms the DC coefficient has consistent and pronounced rounding effects. In contrast rounding effects due to AC coefficients are less predictable and less pronounced. A typical frequency transform matrix has a top row of matrix coefficients with all positive values. Subsequent rows have positive and negative values. For many patterns of information positive and negative effects cancel each other out for an AC coefficient but the positive values of the top row consistently affect rounding due the DC coefficient. In addition the DC coefficient affects all samples in a block in the same way whereas an AC coefficient affects different samples differently. AC coefficients also tend to have smaller magnitudes than DC coefficients. Finally to the extent AC coefficients do have rounding effects the rounding effects for different AC coefficients often cancel each other out.

Therefore in some embodiments one or more rounding offsets parameterize the difference s between T circumflex over x and circumflex over X thereby accounting for rounding effects that follow an inverse frequency transform. In some implementations rounding compensation accounts for rounding effects from DC coefficients but not AC coefficients. For a block of de quantized transform coefficients circumflex over X an encoder compensates for rounding effects in the DC coefficient circumflex over X 0 0 of the block before estimating sample domain distortion in the transform domain. The encoder does not adjust the de quantized AC coefficients of the block as the overall effect of AC rounding on distortion calculation is typically negligible. Alternatively rounding compensation accounts for rounding effects in at least some AC coefficients. For example rounding compensation accounts for rounding effects for the top row or left column of AC coefficients for a block of transform coefficients.

The encoder determines a rounding offset for a particular DC coefficient circumflex over X 0 0 by looking up an index for the DC coefficient in a table that maps indices to rounding offsets. The table is implemented as an array or other data structure. In a simple case the index is the DC coefficient itself and the table includes a rounding offset for each possible de quantized DC coefficient value. The rounding offset is then added to the DC coefficient to produce a rounding compensated DC coefficient. 0 0 0 0 OFFSET 0 0 where circumflex over X 0 0 is the rounding compensated DC coefficient and DCOFFSET is an table mapping indices to corresponding rounding offsets. Or the DC coefficient is first mapped to an integer ranging from 0 to N 1 which is used as an index to a table that maps indices to rounding offsets. 0 0 0 0 OFFSET 0 0 where is an index mapping function that maps a de quantized DC coefficient to an index in the range 0 N 1 and DCOFFSET has length N.

In the sample domain distortion is computed using original sample values and reconstructed sample values. Suppose x denotes a block of sample values and circumflex over x denotes a block of reconstructed sample values obtained through inverse transform of circumflex over X circumflex over x T circumflex over X . Distortion measured in the sample domain is based on x and circumflex over x . The distortion metric D can be defined in different ways. For example D can be a sum of squared differences or errors SSE 

The cost of performing an inverse transform T on a large number of possible coding parameters or permutations for each block can be very expensive in the aggregate. Given the rounding compensated de quantized coefficient matrix circumflex over X and original transform coefficients X however sample domain distortion can be estimated without performing the inverse transform T . Adapting the SSE metric one rounding compensated sample domain distortion metric is 

In some implementations the distortion metric is scaled by a transform specific scaling factor for example as follows 

The scaling factor accounts for differences between pixel domain energy and transform domain energy when the applied transform is non unitary. When an encoder applies a frequency transform the transform matrix values may cause a difference in energy in the transform domain and pixel domain. This is particularly true for integer transforms that are not completely normalized. In general the scaling factor for a transform depends on the norms of the transform. For example consider the following transforms 

A VC 1 encoder can perform forward 4 4 4 8 8 4 and 8 8 transforms on a residual data block D having i rows and j columns as follows for a 4 4 transform for a 8 4 transform for a 4 8 transform and for a 8 8 transform where indicates a matrix multiplication Nindicates a component wise multiplication by a normalization factor T indicates the inverse of the matrix T and circumflex over D represents the transform coefficient block. The values of the normalization matrix Nare given by 

The forward transform causes an average expansion of a little more than 34in the transform coefficients and the inverse transform causes an average expansion of a little more than 34in the other direction. Collectively the inverse transform includes right shifts by 10 for simple normalization which corresponds to division by 1024 with truncation. So the normalization in the inverse transform is essentially by 1 32 . The forward transform includes normalization by an average of roughly 1 36 . The average normalization in the forward transform roughly 1 36 more than compensates for the average expansion roughly 34 so as to simplify normalization in the inverse transform for decoder implementations. As a result considering expansion and normalization of the forward transform the average effect is 34 36 0.9. As such an example scaling factor between sample domain distortion and transform domain distortion for an adapted SSE metric is 0.9 0.8

The scaling factor for a different transform is similarly determined considering expansion and normalization in the forward transform.

An encoder such as the encoder of incorporates the tool in a controller or other module. Alternatively another type of encoder or system incorporates the distortion estimation tool .

In x denotes a block or other set of sample values in a sample domain. For example the sample values are intensity values in the pixel domain for an image or video picture. For a video picture the sample values of an intra coded block are original intensity values and the sample values of an inter coded block are intensity values for a prediction residual. In encoders that use spatial prediction of sample values for intra coded blocks the intensity values of the block x can be for a prediction residual following spatial prediction. In some implementations the intensity values are for the Y channel i.e. luminance . In other implementations the intensity values are for the U and V channels i.e. chrominance or for Y U and V channels at different times.

The frequency transform module transforms the sample values into a block or other set of transform coefficients . The transform module applies a DCT DCT like transform or other block based transform. The size of the transform is 8 8 8 4 4 8 4 4 or some other size.

The quantization module quantizes the transform coefficients . Any of various types of quantization are applied. For example the quantization module applies uniform or non uniform quantization scalar or vector quantization and or adaptive or non adaptive quantization. The quantization module produces a block or other set of quantized coefficients.

The inverse quantization module performs inverse quantization on the quantized transform coefficients. The inverse quantization module produces a block or other set of de quantized transform coefficients .

The rounding compensation module adjusts one or more of the de quantized transform coefficients . For example the rounding compensation module adds a rounding offset to the DC coefficient of the de quantized transform coefficients . Alternatively the rounding compensation module adjusts one or more of the de quantized transform coefficients using some other mechanism. The rounding compensation module produces the de quantized transform coefficients denoted with circumflex over X in which include the rounding compensated coefficient s .

The distortion estimation module computes a distortion estimate using the original transform coefficients and the de quantized transform coefficients that include the rounding compensated coefficient s . The distortion metric is SSE SAD MSE or some other metric and can be scaled or unscaled.

Particular embodiments of encoders or other tools typically use a variation or supplemented version of the generalized tool . Depending on implementation modules of the tool can be added omitted split into multiple modules combined with other modules and or replaced with like modules. In alternative embodiments tools with different modules and or other configurations of modules perform one or more of the described techniques.

With reference to a tool such as a video encoder video transcoder image encoder or image classification tool gets a block or other set of transform coefficients to evaluate. For example the tool gets de quantized transform coefficients following partial decompression of the transform coefficients. Alternatively the tool gets the transform coefficients in some other way.

The tool then performs rounding compensation on one or more of the transform coefficients. For example the tool adjusts the DC coefficient by a rounding offset associated with the value of the DC coefficient. In some implementations the tool uses a rounding offset table that maps DC coefficients or indices derived from DC coefficients to rounding offsets. Alternatively the tool performs rounding compensation for other and or additional transform coefficients or uses another mechanism for determining rounding offsets.

The tool estimates sample domain distortion using the rounding compensated transform coefficients. For example the distortion metric is scaled or unscaled SAD MSE or SSE. The tool determines whether there are any other sets of transform coefficients to be evaluated before making a decision based upon the results of the distortion estimate s . If so the tool continues with the next transform coefficients to evaluate. Otherwise the tool makes a decision based upon the results of the previous distortion estimate s .

With reference to a video encoder uses distortion estimation with rounding compensation in making encoding decisions. The encoder uses this low complexity approach to computing pixel domain distortion accurately to improve the choice of coding parameters at the encoder without significantly increasing encoder complexity.

The video encoder sets one or more coding parameters for a block to be encoded. Depending on implementation at different times the coding parameters can include 1 whether the block should be encoded as intra or inter 2 a number of motion vectors 3 value s of motion vector s 4 a type of a frequency transform 5 a size of a frequency transform e.g. 8 8 4 8 8 4 or 4 4 6 a quantization step size 7 quantization thresholds 8 a dead zone size and or 9 perceptual quantization factors. The technique can be applied to set parameters for an intra block or macroblock inter block or macroblock or other unit of video. Alternatively the coding parameters relate to other and or additional coding options.

The encoder encodes the block according to the set coding parameter s performing a frequency transform and quantization and gets the transform coefficients to be analyzed. The encoder inverse quantizes the transform coefficients producing de quantized transform coefficients. The encoder then performs rounding compensation on one or more of the de quantized transform coefficients for example adjusting the DC coefficient by a rounding offset associated with the value of the DC coefficient.

The encoder estimates pixel domain distortion using the rounding compensated transform coefficient s . For example the encoder computes a scaled SSE or other distortion metric that compares original transform coefficients with the rounding compensated de quantized transform coefficient s from and other de quantized transform coefficients the encoder got.

The encoder determines whether there are any other sets of transform coefficients to be evaluated before making an encoding decision based upon the distortion estimate s . The encoder stops the evaluation process if constrained by time or resource requirements if the encoder has evaluated a complete range of options if the previous transform coefficients provide acceptable results or according to some other criteria.

If the encoder continues evaluation the encoder changes one or more of the coding parameter s and encodes the block according to the current coding parameter s . In changing the coding parameter s the encoder can consider the results of previous distortion estimates so as to more accurately identify coding parameters likely to provide good rate distortion performance.

Otherwise the encoder makes an encoding decision based upon the previous distortion estimate s . For example the encoder reviews one or more of the previous distortion estimate s determines the lowest distortion estimate and adopts coding parameter s used to produce the transform coefficients with the lowest distortion estimate.

Instead of evaluating distortion estimates for different coding parameters on a block by block basis alternatively an encoder can evaluate distortion estimates for different coding parameters on some other basis.

As another example a video transcoder estimates sample domain distortion from transform coefficients with rounding compensation in transcoding operations. A video transcoder converts encoded video in one format and bit rate to encoded video in another format and or bit rate. In homogeneous transcoding a transcoder converts encoded video from a bit stream of a particular format at a first bit rate to a bit stream of the same format at a lower bit rate. In heterogeneous transcoding a transcoder converts encoded video to a different format.

In one example of homogeneous transcoding a transcoder uses distortion estimation with rounding compensation when selecting a quantization step size for a block in transcoded video. The transcoder applies different quantization step sizes and estimates pixel domain distortion relative to the transform coefficients of the block of the original encoded video. For a given quantization step size after inverse quantization the transcoder gets a block of de quantized transform coefficients and performs rounding compensation on one or more of them. The transcoder computes a distortion metric that compares transform coefficients from the first encoded video with the rounding compensated transform coefficient s and other de quantized transform coefficients the transcoder got for the evaluated quantization step size. The transcoder reviews the distortion estimates and stops the evaluation process if it finds a quantization step size for the block that gives good rate distortion performance for encoding at the lower bit rate. If the tool continues the tool gets a block of transform coefficients for different quantization step size.

For heterogeneous transcoding a transcoder can use rounding compensation as in the homogeneous transcoding case also using a scaling factor to account for energy differences between transform coefficients in the first format and transform coefficients in the second format.

As another example an image classification tool estimates sample domain distortion from transform coefficients with rounding compensation in analysis and classification operations. For example the tool determines how closely a first compressed image matches a second compressed image. To do this without fully decompressing each image the tool compares transform coefficients from the first image to corresponding transform coefficients from the second image. By using rounding compensation the tool accounts for rounding that would occur in an inverse frequency transform thereby more accurately estimating pixel domain distortion here differences between the two images . After comparing transform coefficients for blocks or other sections of the images the image classification tool reviews distortion estimate s and makes a classification decision on how closely two images match. The image classification tool then outputs the classification decision to a file or screen.

Or the image classification tool determines how closely an image matches an image signature or image pattern comparing rounding compensated transform coefficients of the image to the image signature or image pattern.

To start a range of de quantized transform coefficient values is identified . In an example implementation the range of samples is 0 . . . 255 and following an 8 8 forward frequency transform quantization and inverse quantization the range of de quantized DC coefficients is 1816 . . . 1816 . More specifically circumflex over X 0 0 can take the value of any even integer in the range of 1816 . . . 1816 odd integers are not possible due to the rules applied in inverse quantization. In different implementations the range of values for de quantized transform coefficients is different or the transform size is different. Different ranges of input sample values typically result in different ranges of de quantized transform coefficient values. Depending on size e.g. 4 4 4 4 or 8 4 or type different transforms often have different scaling factors which also results in different ranges of de quantized transform coefficient values. Finally different quantization and inverse quantization rules affect which de quantized transform coefficient values are possible within a range. Although only even values are possible in the immediately preceding example implementation the approach can be applied to non integer quantization parameters QPs in which QPs can have step increments. In this case reconstructed DC coefficients can have odd values.

Next rounding offsets for the de quantized transform coefficient values in the range are computed . In the example implementation the rounding offsets for DC coefficient values are computed and stored in a table labeled DCOFFSET . For each de quantized coefficient value k in the identified range here even numbers in the range of 1816 . . . 1816 an inverse frequency transform is performed on a block having that value as its DC coefficient and zeros for all AC coefficients. A forward frequency transform is performed on the result. The difference is then computed between the DC coefficient of the forward transform results and the initial de quantized coefficient value k. To compensate for scaling in the transforms in some implementations k is multiplied by a scaling factor. The following equation yields rounding offset values for quantized coefficient values from 1816 to 1816 which can be stored in an array DCOFFSET.

In other implementations the scaling factor of 16 is not needed since normalization is completed in the inverse and forward transforms. The scaling factor of 16 is not incorporated in the computation of rounding offsets and the following equation yields rounding offset values for quantized coefficient values from 1816 to 1816 which can be stored in an array DCOFFSET.

Alternatively another mechanism is used to compute rounding offsets for the de quantized transform coefficient values in the identified range.

Different ranges and transforms inverse transforms result in different rounding offsets. For example if odd values of reconstructed DC coefficients are possible due to non integer QPs or otherwise the offsets of the DCOFFSET table include offsets for odd DC values.

Table 2 shows example values of k and corresponding rounding offsets for a generalized and idealized example in which the range of de quantized transform coefficient values is any integer and the scaling factor for the transform inverse transform is 1.

A rounding offset table is then created . For example the rounding offset table is an array that maps de quantized transform coefficient values to corresponding rounding offset values. A tool looks up a rounding offset by direct indexing with the value of a de quantized transform coefficient. Alternatively the rounding offset table is represented with a different data structure.

Optionally a periodic pattern in the rounding offset values is identified before the rounding offset table is created. For example a person performing the technique identifies a periodic pattern visually by plotting rounding offsets versus de quantized transform coefficient values or using analytical software. In general periodicity in the DC rounding offsets allows for reduction in table size. In the generalized idealized example of Table 3 the DC rounding offset is periodic with a period of 5. In the example implementation of Table 1 or Table 2 the DC rounding offset is periodic with a period of 32. The array DCOFFSET stores the first 32 rounding offset values and the length Nis 32. Specifically the values in the DC rounding offset table are DCOFFSET 32 42 10 22 54 28 4 36 46 14 18 50 32 0 32 49 17 15 47 35 3 29 53 21 11 43 39 7 25 56 24 8 40. To look up the correct DC rounding offset for a de quantized DC coefficient the de quantized DC coefficient value is converted to a table index by an index mapping function as follows i i 1816 1 31.

If the scaling factor of 16 is not incorporated in the computation of rounding offsets see Table 2 the values in the table are DCOFFSET 32 3 1 1 3 2 0 2 3 1 1 3 2 0 2 3 1 1 3 2 0 2 3 1 1 3 2 0 2 4 2 0 2.

The index mapping function is different for different ranges of de quantized transform coefficient values and different periodic patterns. The index mapping function can use different operations for example computing coefficient value MOD period. Different ranges of de quantized transform coefficient values and different forward inverse transforms result in different periodic patterns.

Although the techniques and tools described herein are in places presented in the context of video encoding sample domain distortion estimation from transform coefficients with rounding compensation may be applied to other data compression schemes in which an integer based transform especially a DCT like transform is used. For example the techniques and tools may be applied when encoding images with an integer based DCT like transform. In addition as noted above the techniques and tools may be applied in transcoding applications and image classification and analysis applications.

Finally an encoder can use results of rounding compensation in operations other than distortion estimation. For example an encoder groups quantized DC coefficient values using rounding offset information. The quantized DC coefficient values within a group have rounding offsets that make the values within the group equivalent for purposes of estimating distortion. In terms of the example of Table 1 the values 1816 1814 1812 and 1810 are grouped since T T of each of these values results in the same value 29014 . The values 1808 1806 and 1804 are in a second group and so on. The encoder can perform the grouping off line. During entropy coding if a first DC coefficient value in a group can be represented with fewer bits than a second DC coefficient value in the same group the encoder uses the first DC coefficient value instead of the second DC coefficient value in the encoded data.

Having described and illustrated the principles of our invention with reference to various embodiments it will be recognized that the various embodiments can be modified in arrangement and detail without departing from such principles. It should be understood that the programs processes or methods described herein are not related or limited to any particular type of computing environment unless indicated otherwise. Various types of general purpose or specialized computing environments may be used with or perform operations in accordance with the teachings described herein. Elements of embodiments shown in software may be implemented in hardware and vice versa.

In view of the many possible embodiments to which the principles of our invention may be applied we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto.

