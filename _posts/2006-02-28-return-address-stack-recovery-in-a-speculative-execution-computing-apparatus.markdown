---

title: Return address stack recovery in a speculative execution computing apparatus
abstract: A technique recovers return address stack (RAS) content and restores alignment of a RAS top-of-stack (TOS) pointer for occurrences of mispredictions due to speculative operation, out-of-order instruction processing, and exception handling. In at least one embodiment of the invention, an apparatus includes a speculative execution processor pipeline, a first structure for maintaining return addresses relative to instruction flow at a first stage of the pipeline, at least a second structure for maintaining return addresses relative to instruction flow at a second stage of the pipeline. The second stage of the pipeline is deeper in the pipeline than the first stage. The apparatus includes circuitry operable to reproduce at least return addresses from the second structure to the first structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07836290&OS=07836290&RS=07836290
owner: Oracle America, Inc.
number: 07836290
owner_city: Redwood City
owner_country: US
publication_date: 20060228
---
This application claims benefit under 35 U.S.C. 119 of provisional application No. 60 735 338 filed Nov. 9 2005 naming Shailender Chaudhry Quinn A. Jacobson Paul Caprioli and Marc Tremblay as inventors which application is incorporated by reference herein. This application also claims benefit under 35 U.S.C. 119 of provisional application No. 60 741 210 filed Dec. 1 2005 naming Paul Caprioli Sherman H. Yip and Shailender Chaudhry as inventors which application is incorporated by reference herein.

This application is a continuation of commonly assigned U.S. patent application Ser. No. 11 352 147 entitled Mechanism for Hardware Tracking of Return Address after Tail Call Elimination of Return Type Instruction filed on Feb. 10 2006 naming Paul Caprioli Sherman H. Yip and Shailender Chaudhry as inventors.

The present invention relates to the field of computers. More specifically the present invention relates to computer architecture.

A pipelined superscalar processor may fetch and execute instructions speculatively until an actual target address for change of control instructions i.e. those instructions that modify the program counter from a predetermined increment can be determined. For example speculative execution of instructions occurs while waiting for a branch target address to be resolved. The actual target of the branch may not be determined until many instruction cycles after making the branch prediction and speculative fetch of instructions. Meanwhile speculatively fetched and or executed instructions and or TRAP instructions may include changes in program flow.

A pipelined superscalar processor may include a return address stack RAS i.e. a stack of return addresses of function calls. The RAS is accessed using a stack pointer containing the address of the top of the stack. Call instructions push addresses onto the RAS and the RAS pointer is updated accordingly. Return instructions pop addresses from the top of the RAS and the RAS pointer is updated accordingly. A balanced sequence of pushes and pops will ensure correct return addresses. Updates to the RAS pointer and or the RAS inconsistent with actual program execution may result in misalignment of the RAS pointer to the RAS i.e. the RAS pointer incorrectly points to a particular entry of the RAS and or corruption of RAS content. Such corruption of the RAS content and or the RAS pointer may occur as a result of mispredicted speculative operations. In addition to mispredicted speculative operations the RAS pointer and or RAS content may be corrupted by changes in program flow resulting from program exception handling. Such corruption to the RAS pointer or RAS content can impact performance significantly.

A technique recovers return address stack RAS content and restores alignment of a RAS top of stack TOS pointer for occurrences of mispredictions due to speculative operation out of order instruction processing and exception handling. In at least one embodiment of the invention an apparatus includes a speculative execution processor pipeline a first structure for maintaining return addresses relative to instruction flow at a first stage of the pipeline at least a second structure for maintaining return addresses relative to instruction flow at a second stage of the pipeline. The second stage of the pipeline is deeper in the pipeline than the first stage. The apparatus includes circuitry operable to reproduce at least return addresses from the second structure to the first structure.

In at least one embodiment of the invention an apparatus includes a speculative execution processor pipeline and a first structure for maintaining return addresses associated with instructions at a first stage of the pipeline. The first structure includes a first pointer for referencing return addresses in the first structure consistent with instructions at the first stage of the pipeline. The apparatus includes at least a second pointer for referencing return addresses consistent with instructions at a second stage of the pipeline and at least a third pointer for referencing return addresses consistent with instructions at a third stage of the pipeline. The apparatus includes circuitry operable to reproduce at least contents of at least one of the second and third pointers to the first pointer upon occurrence of at least a first event having a particular type.

In at least one embodiment of the invention a method of operating a processor includes maintaining a respective return address structure corresponding to respective instruction flow at each of at least two stages within an instruction pipeline of the processor. The method includes restoring return address information from one return address structure to another return address structure upon the occurrence of an event having a particular type.

Referring to an exemplary high performance microprocessor architecture e.g. processor includes multiple pipelines e.g. the pipelines including shared logic and respective ones of pipeline portions to obtain high instruction throughput for high performance operation. Resources may be dedicated to a particular pipeline e.g. resources included in pipeline portion or shared by multiple pipelines e.g. resources included in shared logic . Shared logic may include instruction fetch unit which fetches instructions from an instruction store e.g. instruction cache and receives a group of instructions. For example fetch unit requests a line from the instruction cache and receives a group of instructions that is stored at the requested line. Tasks performed by exemplary fetch unit may be performed by logic distributed across multiple pipeline portions and or may be performed by logic in shared logic or combinations thereof. For each received instruction group fetch unit accesses branch prediction unit .

Branch prediction unit may implement a static semi static or dynamic branch prediction strategy. Branch prediction unit provides information for multiple instructions concurrently e.g. at approximately the same time such as within the same cycle half cycle etc. to the fetch unit. An exemplary branch prediction unit is described in U.S. patent application Ser. No. 11 068 626 entitled Multiple Branch Predictions filed Feb. 28 2005 naming Shailender Chaudhry and Paul Caprioli as inventors which application is incorporated herein by reference. Although fetch unit fetches instructions for multiple pipelines fetch unit fetches instructions for one instruction strand at a time and updates one set of fetch buffers e.g. fetch buffers and a return address stack e.g. return address stack F RAS in the pipeline e.g. the pipeline including pipeline portion corresponding to the particular instruction strand.

In a particular pipeline of the exemplary microprocessor the fetched instructions are decoded by decode unit s and queued in instruction queue . The decoded instructions are then issued to execution unit s by issue unit s . Branch prediction information may be supplied to one or more of the fetch unit decode unit s issue unit s and the execution unit s . Pipeline portion includes trap handler which processes exception events. Exceptions and exception events as used herein refer to internal interrupts e.g. trap exceptions external interrupts software interrupts or other non branch events that may change the normal flow of instruction execution. Results of instruction execution are committed e.g. by storing appropriate entries of working register file in architected register file by commit unit .

Exemplary processor may execute instructions speculatively i.e. operations execute as soon as their operands are available also known as conditional processing. For example processor may execute instructions speculatively by executing instructions during a delay introduced by a prior instruction e.g. instructions subsequent to a branch instruction fetch from memory or other action that may introduce delay slots in a pipelined processor are executed during the delay introduced by such instruction . If results of the instructions that were speculatively executed turn out to be unneeded the results are discarded. Upon completion of the delay introduced by the delay event execution is no longer speculative and non speculative execution resumes.

Instructions for execution may be chosen by dynamic branch prediction of branch prediction unit . Such speculation allows the execution of instructions before control dependencies are resolved with the ability to undo the effects of an incorrectly speculated sequence . Instructions execute and pass results to other instructions without allowing the instruction to perform any updates that cannot be undone until the instruction is no longer speculative. When processor determines that a speculatively executed instruction is no longer speculative the register file or memory is updated by commit unit . Instructions may execute out of order but are committed in order. Typically irrevocable actions e.g. updating a state of pipeline portion or handling certain exceptions are prevented until a commit stage of the pipeline.

Exemplary pipeline portion updates a return address stack e.g. F RAS upon fetching an appropriate instruction and also maintains at least a time delayed version of the return address stack pointer which is updated during an execution stage. Upon detection of a misprediction in the speculative execution at the execution units pipeline portion clears the pipeline and undoes any effects of instructions fetched following the mispredicted instruction. Pipeline portion updates the stack pointer associated with F RAS e.g. by copying the time delayed stack pointer to the pointer associated with F RAS . Assuming that instructions speculatively fetched after the mispredicted instruction were not destructive to the F RAS content F RAS will be returned to a state prior to execution of the mispredicted instruction and program flow will be resumed.

However in some situations thousands of instructions may be fetched prior to resolving e.g. a branch target address. Instructions fetched subsequent to the branch instruction may include instruction sequences that are destructive to the content of F RAS e.g. an instruction that invokes a POP operation on the F RAS followed by an instruction invoking a PUSH operation on the F RAS . In such cases maintaining a copy of the stack pointer associated with F RAS is insufficient to maintain the integrity. Processor may include another return address stack e.g. E RAS and an associated stack pointer to maintain a time delayed version of the return address stack that is updated at the execute stage of the pipeline. Upon detection of a misprediction in the speculative execution at the execution units processor clears the pipeline and undoes effects of instructions fetched following the mispredicted instruction. Processor may update the stack pointer associated with F RAS by copying the stack pointer associated with E RAS to the pointer associated with F RAS . In addition processor updates F RAS with the contents of E RAS e.g. by flash copying the contents of E RAS to F RAS .

Flash copying is a technique that includes moving substantial amounts of data at substantially the same time. For example substantially all of the RAS entries may be copied from E RAS to F RAS during the same clock cycle. Although F RAS and E RAS are architecturally associated with different stages of the pipeline e.g. the fetch stage and the execute stage respectively F RAS and E RAS may be located in physical proximity e.g. side by side to facilitate transfer of substantially all of the return addresses stored in E RAS to F RAS within one clock cycle. In at least one embodiment of the invention the entries of E RAS are copied to F RAS over multiple clock cycles. Since F RAS is a stack and is accessed from the top of the stack i.e. it is accessed by the pointer associated with F RAS copying begins with the location indicated by the pointer. By continuing the copying by proceeding from the location indicated by the pointer through the remaining entries of the stack the entire RAS may be copied in a sufficiently timely manner over multiple clock cycles.

In general an exception event invokes an unexpected function subroutine or procedure call. Trap handler may cause pipeline to save certain processor state information e.g. program counter s condition code register s return address stack pointer and other state information in a memory e.g. a hardware register stack and cause the pipeline s to execute the unexpected function subroutine or procedure. For example processor may implement vectored trap handling. Upon an exception event the trap handler will initiate execution of trap handling code associated with a particular trap vector. Exception handling may be precise allowing return to the interrupted program i.e. 1 all instructions preceding the instruction indicated by the saved program counter have been executed and have modified the processor state correctly 2 all instructions following the instruction indicated by the saved program counter are unexecuted and have not modified the processor state and 3 if the interrupt is caused by an exception condition raised by a program instruction the saved program counter points to the interrupted instruction. In exemplary processor the saved program counter corresponds to the instruction in commit unit an instruction that was to be committed had the exception not occurred. However processor may implement other known interrupt handling strategies e.g. the saved program counter may correspond to an instruction in issue unit s prior to the execution units .

As pipeline depths increase the number of in flight instructions increases and conventional techniques for handling exceptions may no longer be effective. For example in a typical processor upon returning to the normal program execution following an exception event the RAS pointer is restored from memory. However some sequences of instructions may destructively update the contents of the RAS. For example since F RAS is updated during the fetch stage if an instruction fetched into fetch buffers performs a POP operation e.g. a RETURN instruction and a subsequently fetched instruction fetched prior to an exception event and fetched into the fetch buffers performs a PUSH operation e.g. a jump to subroutine instruction and an instruction concurrently in the execution units triggers a trap event upon returning from the exception event the contents of F RAS are corrupted with respect to the POP function which is restarted upon return from an exception handling routine. Accordingly saving only the state of the RAS pointer is insufficient to effectuate a complete restoration of the correct RAS state. Similarly typical interrupt handling of the RAS i.e. saving the entire RAS in a hardware stack upon an exception event is insufficient to effectuate a complete restoration of the correct RAS state. Accordingly T RAS of processor may include a time delayed RAS in addition to a time delayed RAS stack pointer.

In at least one embodiment of the invention T RAS includes a delayed version of the stack pointer associated with F RAS . T RAS is updated at the trap stage of pipeline portion for any return address stack affecting instruction that completes execution and is committed without the occurrence of an exception event. Upon detection of an exception event pipeline portion clears the pipeline and undoes effects of instructions fetched following an event causing the exception and effects of other instructions that have not yet been committed prior to the exception event. Upon restoring the state of pipeline portion following the completion of the exception handling pipeline portion updates the stack pointer associated with at least F RAS by copying the time delayed stack pointer from T RAS to the pointers associated with F RAS and E RAS .

As the number of speculative instructions executed by processor increases and exceeds the depth of the pipeline maintaining F RAS E RAS and T RAS may not be enough to maintain the integrity of the return address stack. Checkpointing is a technique for supporting speculative execution by which processor saves the state of a pipeline at a particular point in the corresponding thread i.e. a separate process with its own instructions data and state information or program. A flash copy operation may instantly copy all of the state information to corresponding checkpoint registers or memory locations e.g. C RAS and an associated pointer . The checkpointing technique saves enough state information for the processor to be able to restart the corresponding thread at the checkpoint in the event of a misprediction. Upon such a misprediction the checkpointed information is restored to associated state elements and the thread restarts execution from the checkpoint. Multiple checkpoints may be taken to reduce the number of instructions reexecuted upon a branch misprediction. For example if multiple instructions in a portion of code are speculatively executed a checkpoint may be associated with each of those instructions. If one of those instructions is mispredicted the machine may return to the checkpoint associated with the mispredicted instruction instead of a checkpoint associated with another instruction.

In at least one embodiment of the invention E RAS and T RAS are differential versions of F RAS i.e. these time delayed versions of F RAS contain only a number of entries corresponding to the distance in pipeline depth between the F RAS and respective ones of E RAS and T RAS . Such a design choice trades off integrated circuit area with the amount of control logic. A full RAS implementation for E RAS and T RAS is larger than differential versions however additional control logic is included for restoring the F RAS from such differential versions.

Referring to particular stages of a simplified version of a pipeline consistent with at least one embodiment of the invention are associated with corresponding return address stack structures which are controlled by RAS control . In at least one embodiment of the invention RAS control is implemented with control circuitry that is distributed across multiple pipeline stages e.g. circuitry included in fetch unit execution units trap handler or other pipeline stages. RAS control updates RAS pointer upon detection of RAS affecting instructions during the fetch stage of pipeline . RAS pointer is updated during the execute stage and contains a time delayed version of RAS pointer . RAS control restores the contents of RAS pointer with the contents of RAS pointer in the event that instructions fetched after a speculative instruction is resolved are being cleared from pipeline . RAS pointer is updated during the trap stage for RAS affecting instructions that have executed without an exception event. RAS control restores the contents of RAS pointer and RAS pointer with the contents of RAS pointer in the event of exception handling. RAS pointer is a checkpointed version of RAS pointer . RAS control restores the contents of RAS pointers and with the contents of RAS pointer in the event that the program is restored to a checkpoint.

Referring to in at least one embodiment of the present invention stages of pipeline are associated with corresponding return address stack pointers and return address stacks that are used to restore contents of both F RAS and F RAS pointer . Return address stacks and may be the same size as F RAS or may be smaller in size e.g. differential RAS structures . F RAS and F RAS pointer are updated by RAS affecting instructions during the fetch stage of pipeline . E RAS and E RAS pointer are updated during the execute stage and contain a time delayed version of F RAS and F RAS pointer . RAS control restores the contents of F RAS and F RAS pointer with the contents of E RAS and E RAS pointer in the event that instructions fetched after a speculative instruction is resolved are being cleared from pipeline . T RAS and T RAS pointer are updated during the trap stage for RAS affecting instructions that have executed without an exception event. RAS control restores the contents of F RAS and F RAS pointer and E RAS and E RAS pointer with the contents of T RAS and T RAS pointer in the event of exception handling. C RAS and C RAS pointer are checkpointed versions of T RAS and T RAS pointer . RAS control restores the contents of F RAS E RAS and T RAS and associated pointers pointers and with the contents of C RAS and C RAS pointer respectively in the event that the program is restored to a checkpoint.

Other pipeline stages may have time delayed versions or other versions of the RAS pointer and or the RAS associated with them. In addition any or all of the RAS s associated with individual pipeline stages may be differential with respect to a RAS that is restored upon particular events. Other types of events may trigger restoration of the RAS pointer and or RAS.

Referring to A and B a technique for recovering a return address stack upon a branch misprediction or detection of other operation that requires clearing the pipeline and returning the state of the pipeline to a previous state maintains at least one additional RAS and or one additional RAS pointer for restoring a working RAS and or RAS pointer. In at least one embodiment of the invention predecode unit decodes an instruction which is stored in instruction store e.g. an instruction cache . Fetch unit fetches an instruction from instruction store based on prediction information when applicable supplied by branch prediction unit and writes the instruction in fetch buffers . If the instruction is a RAS modifying instruction e.g. an instruction that performs a jump and link a return or other RAS modifying instruction then fetch unit performs a PUSH function or a POP function on F RAS and an associated F RAS pointer is updated accordingly .

The instruction then proceeds through stages of pipeline e.g. through decode unit instruction queue and issue unit s or other combinations of pipeline stages to a stage in which an instruction is issued to execution units . After entering the execution stage execution unit determines whether the instruction is a RAS modifying instruction . If the instruction is a RAS modifying instruction the execution unit updates E RAS and or an E RAS pointer accordingly . The instruction then proceeds through any additional pipeline stages to a trap handling stage .

Exemplary trap handler determines whether the instruction is a RAS modifying instruction and whether the instruction has reached this stage in the pipeline without the occurrence of an exception event and updates T RAS and or an associated T RAS pointer . In addition if trap handler determines that instruction currently being handled coincides with a checkpoint event trap handler copies T RAS and or an associated T RAS pointer to C RAS and or an associated C RAS pointer . Next if the instruction is a non speculative instruction then the instruction is committed by commit unit .

An exemplary technique for restoring F RAS and or an associated F RAS pointer in response to actually executing an instruction that was previously fetched speculatively is illustrated in . The speculatively fetched instruction enters execution units for actual execution . During this stage RAS control receives an indication of whether the instruction was correctly speculated . If the speculation was correct F RAS and or the associated F RAS pointer contain correct information and are not updated. However if the instruction was incorrectly speculated RAS control initiates restoration of F RAS and or the associated F RAS pointer according to the contents of E RAS and or the associated E RAS pointer and operations are resumed .

An exemplary technique for restoring E RAS and or an associated pointer and or F RAS and or an associated F RAS pointer in response to exception processing is illustrated in . When an exception event is detected by RAS control prior to resuming normal operations RAS control initiates restoration of E RAS and or an associated pointer and or F RAS and or an associated F RAS pointer according to the contents of T RAS and or the associated T RAS pointer . Then non exception operations are resumed .

Referring to an exemplary technique restores E RAS and or an associated pointer and or F RAS and or an associated F RAS pointer and or T RAS and or an associated T RAS pointer in response to program control reverting to a program checkpoint. RAS control detects program control reversion to a predetermined checkpoint . Prior to resuming the program from a checkpointed instruction RAS control initiates restoration of E RAS and or an associated E RAS pointer and or F RAS and or an associated F RAS pointer and or T RAS and or an associated T RAS pointer according to the contents of C RAS and or the associated C RAS pointer and operations are resumed from the checkpoint .

Referring back to control transfer instructions CTIs implemented by exemplary processor include e.g. any combination of conditional program counter PC relative branches and calls unconditional PC relative branches and calls conditional register indirect jumps unconditional register indirect jumps conditional traps and unconditional traps. An exemplary instruction set includes the following types of CTIs a conditional branch instruction type an unconditional branch instruction type a call and link CALL instruction type a jump and link JPML instruction type a return from trap DONE RETRY instruction type and a trap instruction type. In at least one embodiment of the invention instructions accessed by processor may be executed annulled or trapped. In general in the absence of exception conditions a particular instruction is executed unless a previous instruction annuls the instruction e.g. the previous instruction is an annulling CTI or other annulling instruction and the PC is updated accordingly. For example if no exception event occurs the PC receives a predetermined value e.g. a value contained in a next PC nPC register which may be the value of the PC increased by four or other suitable increment. However if the instruction is a CTI the predetermined value may be a target address for the CTI which may be determined by other techniques.

In at least one embodiment of the invention at least one CTI is a delayed control transfer instruction DCTI i.e. when only the value of the nPC is changed by the instruction the effect of the transfer of control is delayed by one instruction. The instruction at a next sequential PC location following the DCTI is located in the delay slot of the DCTI. The instruction in the delay slot may be fetched prior to execution of the DCTI. A conditional or unconditional CTI may be a DCTI. The delay instruction may be fetched and or executed or may be fetched and or annulled according to a value of an annul field of the DCTI instruction. An annulled instruction has no effect on the program visible state of processor and cannot cause a trap.

In at least one embodiment of the invention a DCTI causes the processor to change control to an instruction at a target address after a one instruction delay. A non delayed CTI transfers control to the instruction at the target address immediately after the CTI is executed. Conditional delayed CTIs cause either a delayed or a non delayed control transfer depending upon the value of an annul bit of the instruction in the delay slot and whether a condition is met. The instruction pointed to by the nPC when a DCTI is encountered is the delay instruction and in general is the next sequential instruction in the instruction space i.e. PC 4 . However if the instruction that immediately precedes a DCTI is itself a DCTI the address of the delay instruction is actually the target of the preceding DCTI. In general pipeline front end complexity increases for the hardware to ensure proper instruction execution when a DCTI is positioned as a last instruction of a cache line and to ensure proper instruction execution of consecutive DCTIs.

Exemplary processor is responsive to a call type instruction e.g. CALL that causes an unconditional delayed PC relative control transfer to a program address e.g. address PC 4 sign ext disp30 where disp30 is a 30 bit displacement field. However the destination program address may be computed by other suitable techniques. In at least one embodiment of the invention processor is responsive to other call type instructions included in the instruction set e.g. a register indirect call type instruction. For example processor performs a register indirect call in response to a JMPL instruction that uses a link register as the destination register e.g. rd 15 . Other instruction set designs may implement call type instructions using other techniques. In addition rather than a dedicated CALL type instruction processor may respond to branch type and or jump type instructions using pc relative register indirect register direct absolute or other suitable addressing techniques for computing a target program address.

In response to an exemplary call type instruction processor writes the value of the PC which contains the address of the call type instruction into a link register e.g. r 15 which is a particular out register of a register window associated with architected register file and working register file . In addition processor pushes the value of the PC onto the RAS e.g. F RAS for use in prediction of a return address from a subroutine invoked by the call type instruction.

An exemplary return type instruction is a CTI that causes a transfer of control to a target program address typically to an instruction sequence that transferred control to an instruction sequence including the return type instruction. In at least one embodiment of the invention a return type instruction e.g. RETURN also restores the register window prior to a last instruction e.g. the register window prior to a SAVE instruction that provided a new register window to the instruction sequence. The target address of a return type instruction may be an immediate address a register indirect address a PC relative address or an address computed by other suitable techniques. Exemplary processor computes a target address of a RETURN instruction based on the contents of two registers or on the contents of one register and an immediate value. In at least one embodiment of the invention processor is responsive to other return type instructions included in the instruction set e.g. a register indirect return type instruction. For example processor performs a register indirect return in response to a JMPL instruction that uses a link register as the destination register e.g. rd 0 . Other instruction set designs may implement return type instructions using other techniques. For example rather than a dedicated RETURN type instruction branch type and or jump type instructions using pc relative register indirect register direct absolute or other suitable addressing techniques for computing a target program address may be used.

Referring to exemplary instruction sequence is a main program subroutine function or other sequence of instructions that calls a first subroutine e.g. SUB. The CALL SUB instruction of instruction sequence is a DCTI instruction. Exemplary instruction sequence does not include a tail call sequence of instructions indicative of an associated elimination of a return type instruction hereinafter a tail call elimination instruction sequence or tail call elimination sequence . The delay slot following CALL SUB of instruction sequence includes any suitable instruction accordingly.

When processor executes CALL SUB of instruction sequence processor stores the current PC in a particular register e.g. o7 of a register window associated with architected register file and working register file . In addition the instruction in the delay slot is fetched and executed the current PC or other return address information is pushed onto the RAS e.g. F RAS is updated from RAS state to RAS state the PC is updated to receive the value of the location corresponding to SUB and program control is transferred to subroutine . Subroutine includes an instruction sequence that calls a second subroutine e.g. by CALL SUB as a last instruction of the subroutine prior to a return type instruction e.g. RETURN which returns program control from subroutine to instruction sequence . When processor executes CALL SUB of subroutine processor stores the current PC in the particular register e.g. o7 . In addition the instruction in the delay slot is executed the current PC is pushed onto the RAS e.g. F RAS is updated from RAS state to RAS state the PC is updated to the value of the location corresponding to the CALL SUB instruction and program control is transferred to subroutine .

Referring to when subroutine completes and a return type instruction is executed e.g. RETURN program control is transferred back to subroutine . The PC may be speculatively updated to receive a predicted return address value that is an incremented version of an address stored on the RAS and pops the RAS. For example the PC may receive an incremented version of the address of the CALL SUB instruction the PC is updated to point to RETURN the next instruction to be executed in subroutine and processor pops the RAS e.g. F RAS is returned from RAS state to RAS state . Upon receiving program control subroutine executes the last instruction in the subroutine e.g. RETURN. Program control is then transferred back to instruction sequence . For example the PC is speculatively updated to receive an address that is the address of the CALL SUB instruction incremented by eight e.g. the PC is updated to point to INSTRUCTION the next instruction to be executed in instruction sequence and processor pops the RAS e.g. updating F RAS from RAS state to RAS state . Note that the control sequence illustrated in executes two consecutive DCTI instructions e.g. RETURN immediately followed by RETURN . Such a sequence may introduce substantial processing penalties due to program control transfers e.g. penalties associated with loading target instructions into instruction store and penalties due to mispredicted target addresses .

One technique for reducing penalties introduced by transfers in program control eliminates execution of one of the two return type instructions. With such a technique one return type instruction would effectively return program control for two return type instructions e.g. eliminates the execution RETURN of subroutine . The technique may eliminate a return type instruction that may otherwise immediately follow the call type CTI at the tail of an instruction sequence hereinafter a tail call . In at least one embodiment of the invention a compiler suitable for converting high level code e.g. code written in C or other high level language into machine code consistent with processor performs the technique eliminating the return type instruction associated with a tail call instruction. However such return type instruction may be included but is not executed because a return address of a subroutine called by the tail call returns the program to an instruction sequence that calls the subroutine including the tail call instruction.

An exemplary tail call elimination technique reduces a number of machine code instructions included in the compiled code which for some instruction sequences reduces the number of instructions executed and improves performance of the processor for such operating sequences. The exemplary compiler implementing a tail call elimination technique detects subprograms e.g. subroutines procedures functions or other sequences of code that include return type CTIs to exit such sequences of instructions and return to a sequence of instructions that called the subroutine procedure functions or other sequences of instructions . The exemplary compiler detects a first subprogram including a last instruction i.e. a last instruction before a return type CTI that is a call to a second subprogram. Rather than including two return type CTIs as last instructions in corresponding ones of the two subprograms the compiler eliminates the return type CTI as the last instruction of the first subprogram and includes only one return type CTI for the two subprograms. In at least one embodiment of the invention the one return type CTI is the last instruction of the second subprogram and returns from the second subprogram to the program that called the first subprogram. This technique allows a first function whose last instruction is a second function call to eliminate the overhead of two return transfers of program control. The compiler includes a single return type instruction having the return address that would be used by the first subprogram in the return from the second subprogram. However this optimization technique results in an instruction flow that includes two call type instructions but only one return type instruction. Such an instruction flow corrupts the RAS which may result in return address mispredictions and substantial performance degradation.

For example during execution processor fetches and executes two subprogram call type instructions but fetches and executes only one return type instruction. In general processor is an architecture that pushes the PC associated with the instruction performing the subprogram call onto the RAS for use in predicting the return address of called subprogram. Although a PC associated with a call type instruction is pushed onto the RAS for each of the two subprogram calls in situations where the compiler eliminates a return type instruction associated with a tail call of a subroutine the RAS is popped only once and the RAS content and or alignment is corrupted which may result in return address mispredictions.

In at least one embodiment of the invention to reduce return address mispredictions processor e.g. RAS control of or RAS control of pushes the RAS upon executing call type instructions unless processor detects a tail call elimination instruction sequence. Exemplary instruction sequences indicative of a tail call elimination i.e. a tail call elimination sequence of one or more instructions include a call type DCTI and a particular instruction in the delay slot of the DCTI. The particular instruction may be any suitable instruction that indicates a tail call elimination.

In at least one embodiment of the invention the particular instruction detected may be one of a plurality of instructions that effectively restore a saved version of the PC to a version prior to the call type DCTI. An exemplary tail call elimination sequence of instructions includes a CALL instruction with a MOV x o7 in the delay slot of the CALL. The MOV x o7 overwrites a version of the PC that was saved in register o7 of processor by the CALL instruction and replaces that version with a version of the PC saved temporarily to a register e.g. the x register by a MOV o7 x instruction prior to the DCTI. Although the MOV o7 x instruction may be located immediately prior to the call type instruction it is not necessarily so located and may be located in any position prior to the DCTI that maintains the integrity of the contents of the x register until the delay slot of the tail call type instruction.

Another exemplary tail call elimination sequence of instructions includes a tail CALL instruction with a RESTORE instruction in the delay slot of the CALL instruction. The RESTORE instruction restores contents of a register that stores a version of the PC used as a return address of a call and which were saved by a SAVE instruction to a temporary location prior to the CALL instruction. The RESTORE instruction restores to the register that stores the return address for a RETURN instruction the previously saved version of the PC used as the return address.

Referring to B A and B exemplary instruction sequences and associated RAS states are illustrated for exemplary instruction sequences including tail call elimination of return type instructions. Instruction sequence is a main program subroutine function or other sequence of instructions that calls a first subroutine e.g. SUB. A CALL SUB instruction of instruction sequence is a DCTI instruction having a delay slot. Exemplary instruction sequence does not include a tail call elimination sequence of instructions and the delay slot following CALL SUB of instruction sequence includes any suitable instruction accordingly. However instruction sequence may include a tail call elimination instruction sequence and the instruction sequences and corresponding RAS states of may be adapted accordingly.

When processor executes CALL SUB of instruction sequence processor stores the current PC in a particular register e.g. o7 . In addition the instruction in the delay slot is executed the current PC or other return address information is pushed onto the RAS e.g. F RAS is updated from RAS state to RAS state the PC is updated to receive the destination address of the CALL SUB instruction and program control is transferred to subroutine . Subroutine includes a tail call elimination sequence of instructions and does not include a return type instruction although such an instruction may be included but not executed in some embodiments of the invention. Processor detects a call type DCTI and a particular instruction in the delay slot of the DCTI e.g. processor detects CALL SUB and with MOV x o7 in the delay slot of CALL SUB .

Since processor detects the tail call elimination instruction sequence of subroutine processor does not push the RAS upon execution of the CALL SUB instruction of subroutine . Accordingly the state of the RAS e.g. RAS state does not change as a result of executing CALL SUB although program control changes from subroutine to subroutine . Referring to subroutine completes with a return type instruction e.g. RETURN . Program control does not return to subroutine the subroutine that called subroutine in response to the RETURN instruction. Rather processor transfers program control back to instruction sequence e.g. to INSTRUCTION and processor e.g. in response to the RETURN instruction pops the RAS returning F RAS to RAS state from RAS state . The call type instructions executed by instruction sequence and subroutine generate only one push of the RAS and one corresponding pop of the RAS. Thus processor maintains RAS alignment and content while improving cycle time of some instruction sequences associated with tail call elimination of return type instructions.

In at least one embodiment of the invention the particular instruction detected in the delay slot of a call type DCTI is a restore type instruction e.g. RESTORE instruction of subroutine of that effectively restores a saved version of the PC to a version prior to the call type DCTI e.g. saved by the SAVE instruction in subroutine . Since processor detects the tail call elimination instruction sequence of subroutine processor does not push the RAS upon execution of the CALL SUB instruction of subroutine . Accordingly the state of the RAS e.g. RAS state does not change as a result of executing CALL SUB although program control changes from subroutine to subroutine . The SAVE instruction of subroutine saves a version of register o7 to a temporary location thus saving the return address of subroutine e.g. saving the address of the CALL SUB instruction of instruction sequence .

The CALL SUB instruction of subroutine saves a copy of the PC to register o7 e.g. saves the address of CALL SUB to register o7 and updates the PC to change program control to subroutine e.g. PC is loaded with the address of SUB . The restore type instruction in the delay slot of the CALL SUB instruction copies the value in the temporary register back into register o7. Upon returning from subroutine an indicator of the actual return address is located in register o7. The indicator is incremented and loaded into the PC and control transfers from subroutine to instruction sequence . Processor pops the RAS and the state of the RAS changes from RAS state to RAS state . Thus processor maintains RAS alignment and content while improving cycle time of some instruction sequences associated with tail call elimination of return type instructions.

Referring back to the last instruction in instruction store may be a call type DCTI. In at least one embodiment of the invention shared logic may include control logic to stall issue and or execution of the call type DCTI until the instruction in the delay slot is loaded into instruction store to allow proper decode of the tail call elimination sequence and eliminate a push of the RAS associated with the call type DCTI. However shared logic may issue and or execute the call type DCTI without issuing and or executing the instruction in the associated delay slot. Such an implementation may push the RAS twice but pop the RAS once for a tail call instruction sequence. Misalignment of the RAS may result in return address mispredictions and associated degradation in performance. The approach taken by shared logic in such a situation includes a design tradeoff between circuit complexity and decreased performance due to return address mispredictions. However a call type instruction positioned as the last instruction in instruction store may be sufficiently infrequent that a resulting misalignment of the RAS has an insubstantial impact on performance. In addition software designers and compilers may prepare code for processor with the knowledge that positioning a call type instruction as the last instruction in instruction store is undesirable and may align instructions to reduce or eliminate such occurrences.

In at least one embodiment of the invention processor includes a predecode unit e.g. predecode unit that detects tail call elimination instruction sequences when a cache line is installed in instruction store . An individual instruction is augmented by the predecode unit to include at least one predecode bit corresponding to information on whether to push or pop the RAS. Accordingly processor may push or pop a RAS according to the predecode bit s without substantially impacting cycle time of fetch unit .

Referring to an exemplary computer system e.g. computer system includes a processor unit possibly including multiple processors a single threaded processor a multi threaded processor a multi core processor etc. . The computer system also includes a system memory A F e.g. one or more of cache SRAM DRAM RDRAM EDO RAM DDR RAM EEPROM or other suitable memory a system bus e.g. LDT PCI ISA or other suitable interface a network interface e.g. an ATM interface an Ethernet interface a Frame Relay interface or other suitable interface and a storage device s A D e.g. optical storage magnetic storage or other suitable storage device . At least one embodiment of the invention includes fewer or additional components not illustrated in e.g. video cards audio cards additional network interfaces peripheral devices or other components . Processor unit storage device s A D network interface and system memory A F are coupled to system bus . Processor unit includes a return address stack and return address stack recovery system consistent with the present invention.

While circuits and physical structures are generally presumed it is well recognized that in modern semiconductor design and fabrication physical structures and circuits may be embodied in computer readable descriptive form suitable for use in subsequent design test or fabrication stages. Structures and functionality presented as discrete components in the exemplary configurations may be implemented as a combined structure or component. The invention is contemplated to include circuits systems of circuits related methods and computer readable medium encodings of such circuits systems and methods all as described herein and as defined in the appended claims. As used herein a computer readable medium includes at least disk tape or other magnetic optical semiconductor e.g. flash memory cards ROM or electronic medium and a network wireline wireless or other communications medium.

The description of the invention set forth herein is illustrative and is not intended to limit the scope of the invention as set forth in the following claims. For example while the invention has been described in an embodiment in which a particular pipeline architecture is described one of skill in the art will appreciate that the teachings herein can be utilized with other pipeline architectures. Variations and modifications of the embodiments disclosed herein may be made based on the description set forth herein without departing from the scope and spirit of the invention as set forth in the following claims.

