---

title: Method and apparatus for accelerating generic inter-ORB protocol for a CORBA ORB
abstract: An HDL description of a communications protocol machine for transforming object communications into low-level octet sequences for physical transport is synthesized onto a programmable logic device such as an FPGA. This communications protocol machine replaces traditional software-based inter-ORB protocol engines in distributed computing environments, including embedded environments, to provide reduced latency. The communications protocol machine is described with two distinct elements: a protocol messaging machine and an encoder/decoder. The protocol messaging machine converts an object communication into a low-level octet sequence comprising one or more inter-ORB protocol messages and converts a low-level octet sequence comprising an inter-ORB protocol message into an object communication. The encoder/decoder encodes each data type associated with the object communication into a low-level octet sequence according to a set of rules, such as CDR, and decodes a low-level octet sequence into data types associated with the object communication according to the same rules.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07954108&OS=07954108&RS=07954108
owner: PrismTech Corporation
number: 07954108
owner_city: Woburn
owner_country: US
publication_date: 20061121
---
This application claims priority to U.S. Provisional Application No. 60 738 862 filed Nov. 21 2005 and entitled Method and Apparatus for Accelerating Generic Inter ORB Protocol for a CORBA ORB which is hereby incorporated by reference in its entirety.

The present disclosure generally relates to communications between object request brokers ORBs in distributed and embedded environments and specifically relates to methods for reducing communications overhead by accelerating inter ORB protocol messaging.

In distributed computing an object request broker ORB is middleware used to abstract the communications between software object implementations. When a client sends a request to a server object implementation the ORB is responsible for locating the server object implementation for preparing the server object implementation to receive the request and for transforming the request into a format suitable for transport to the server object implementation. An ORB on the server side is responsible for reconstituting the request for dispatch to the server object implementation. In distributed computing systems utilizing ORBs the client need only be aware of those aspects of the server object implementation that are reflected in the server object implementation s interface.

Using an ORB a client can transparently invoke a method on a server object implementation whether that server object implementation is located on the same machine as the client or is located across a network. The ORB intercepts the communication locates the server object implementation transforms the outgoing communication into a format suitable for transport and reconstitutes any incoming communication from the server object implementation into a format suitable for dispatch back to the client. Thus ORBs provide interoperability between applications on different machines in heterogeneous distributed environments and seamlessly interconnect multiple object systems.

In order to achieve such interoperability ORBs must communicate using a standardized communications protocol known as an inter ORB protocol. The ORB on the server side must speak the same language as the ORB on the client side to ensure proper message interpretation. One such inter ORB protocol is the General Inter ORB Protocol GIOP as specified by the Object Management Group OMG in version 3.0 of its Common Object Request Broker Architecture CORBA specification hereby incorporated by reference in its entirety into the specification of this patent application. The GIOP is designed such that it can be mapped onto any physical transport protocol that meets a minimal set of assumptions. Included in this minimal set of assumptions is that the transport must be connection oriented the transport must be reliable and the transport must be viewable as a low level octet stream. A low level octet stream is an uninterpreted sequence of 8 bit octets and is also referred to as a byte stream. Examples of connection oriented transport protocols include Transmission Control Protocol TCP and Reliable User Datagram Protocol RUDP . Examples of physical layer transport protocols include Ethernet and RapidIO.

Ethernet based TCP s latency in highly embedded environments has been cause for concern especially where the system has a high degree of sensitivity to loss of determinism in request and response latency. As recently as five years ago examination of the percentage of time spent in the transport stack compared to time spent in the ORB indicated that anywhere from 70 85 of the time was spent in transport compared to only 12 15 spent in the ORB. So ORB overhead was relatively low. More recently however the introduction of faster shared memory based fabric transports and newer fabric standard implementations such as those of RapidIO has caused a reversal in the latency picture. Using such transports we see 80 90 of total call time now appearing to be in the ORB and far less time now in the transports. Although these faster more predictable and deterministic transports have become available the ORBs have stayed somewhat static in their designs.

Examination of the time spent in an ORB has typically shown that the most CPU intensive and greatest contributor to latency is the ORB s marshalling engine. The marshalling engine is an inter ORB protocol engine that translates wire traffic from the transport into ORB communications and vice versa. Because it is desirable to lower call latency as much as possible and because traditional techniques have focused purely on software based mechanisms and on performing intelligent operations in search of faster leaner and more effective GIOP implementations over various transports a novel approach is desired to accelerate the inter ORB protocol engine and thus reduce latency.

In computing environments comprising distributed software objects running on processors and hardware objects residing in silicon custom proxies known as hardware abstraction layers HALs have been developed to establish communications between the processors and the hardware objects. These custom proxies are meant to increase portability and re use but in practice they tend to increase latency reduce throughput and lower re use. Another communication solution has been to embed general purpose processing cores into hardware platforms alongside the hardware objects in order to offer software based ORB capability. This approach tends to require significant gate count and memory utilization and generally these processing cores cannot be clocked fast enough to deal with ever increasing performance requirements. A novel approach is needed to facilitate communications between software objects running on processors and hardware objects residing in silicon.

One aspect of the disclosed invention is to provide a method to accelerate the inter ORB protocol by providing a hardware description language HDL description of a communications protocol machine. In an exemplary embodiment the communications protocol machine transforms object communications into low level octet sequences for transport and restores low level octet sequences into object communications for dispatch to object implementations. In some embodiments the communications protocol machine further asserts handshaking signals effectuating dispatch of the object communications to object implementations. In preferred embodiments the HDL description of the communications protocol machine is then synthesized onto a hardware platform such as a field programmable gate array FPGA and implemented as an inter ORB protocol engine. In an exemplary embodiment a communications protocol machine is described that transforms object communications into low level octet sequences comprising General Inter ORB Protocol GIOP messages and encodes data types associated with the object communications using Common Data Representation CDR .

Various aspects of a method and apparatus for accelerating GIOP protocol according to the present disclosure are described. It is to be understood however that the following explanation is merely exemplary in describing aspects of the present disclosure. Accordingly several modifications changes and substitutions are contemplated.

As shown in ORB comprises ORB core and inter ORB protocol engine . Inter ORB protocol engine assembles inter ORB protocol messages and encodes information to be shared between clients and servers. Inter ORB protocol engine also known as a CODEC engine or a marshalling engine transforms object communications from application software into low level octet sequences suitable for transport over physical transport and also transforms low level octet sequences received over physical transport into object communications for dispatch to application software . Embodiments of the disclosed invention specify methods for hardware accelerating inter ORB protocol engine .

In the preferred embodiment represented in communications protocol machine is synthesized onto a programmable logic device specifically a field programmable gate array FPGA . Other embodiments of the disclosed invention contemplate the use of other programmable logic devices for the hardware platform. Still other embodiments contemplate the use of an application specific integrated circuit ASIC for the hardware platform.

For communications outbound from application software object communications protocol machine waits for an indication from ORB core that the object communication is available in memory buffer . Upon receiving such an indication communications protocol machine retrieves the object communication from memory buffer transforms the object communication into a low level octet sequence and stores the low level octet sequence into memory buffer . Although represents memory buffer and memory buffer as distinct entities these buffers may actually reside in the same physical memory location.

After transforming the object communication into a low level octet sequence communications protocol machine sends an indication that the low level octet sequence is available for physical transport . In the embodiment of control is not returned to program space after communications protocol machine transforms the object communication into a low level octet sequence. Rather device driver passes the low level octet sequence directly to transport . Consequently the ORB developer and the transport developer are dependent on one other.

For communications inbound to application software object communications protocol machine waits for an indication that a low level octet sequence is available in memory buffer . Upon receiving such an indication communications protocol machine retrieves the low level octet sequence from memory buffer transforms the low level octet sequence into an object communication and stores the object communication into memory buffer . Communications protocol machine then sends an indication that the object communication is available for dispatch to application software object . In some embodiments communications protocol machine further asserts handshaking signals effectuating dispatch of the object communication to application software object .

For communications outbound from application software object communications protocol machine waits for an indication from ORB core that the object communication is available in memory buffer . Upon receiving such an indication communications protocol machine retrieves the object communication from memory buffer transforms the object communication into a low level octet sequence and stores the low level octet sequence into memory buffer . Although represents memory buffer and memory buffer as distinct entities these buffers may actually reside in the same physical memory location.

After transforming the object communication into a low level octet sequence communications protocol machine then sends an indication that the low level octet sequence is available for physical transport . In the embodiment of control is returned to program space after communications protocol machine transforms the object communication into a low level octet sequence. Program space then passes the low level octet sequence to the transport . Consequently the ORB developer and the transport developer remain independent from one another.

For communications inbound to application software object communications protocol machine waits for an indication that a low level octet sequence is available in memory buffer . Upon receiving such an indication communications protocol machine retrieves the low level octet sequence from memory buffer transforms the low level octet sequence into an object communication and stores the object communication into memory buffer . Communications protocol machine then sends an indication that the object communication is available for dispatch to application software object . In some embodiments communications protocol machine further asserts handshaking signals effectuating dispatch of the object communication to application software object .

In an exemplary embodiment the ORBs associated with the communications protocol machine support a subset of the Common Object Request Broker Architecture CORBA as specified by the Object Management Group OMG in version 3.0 of its Common Object Request Broker Architecture CORBA specification hereby incorporated by reference in its entirety into the specification of this patent application. In this embodiment protocol messaging machine generates a sequence of octets comprising a General Inter ORB Protocol GIOP message header that identifies the appropriate GIOP message type. Protocol messaging machine then generates a sequence of octets comprising a secondary message header. The structure of this secondary message header is dependent upon the GIOP message type identified in the primary header. GIOP message types GIOP message structure GIOP message header structure and GIOP message type header structures are all described in version 3.0 of OMG s CORBA specification.

After generating the one or more inter ORB message headers encoder decoder generates a message body by encoding each data type associated with the object communication according to a set of encoding decoding rules. Where there are no data types associated with the object communication no encoding is required. In that case the low level octet sequence for transport will contain header information only and no message body. An example of an object communication with no associated data types is a void function call that passes no parameters for example void f .

In an exemplary embodiment the set of encoding decoding rules applied by encoder decoder is Common Data Representation CDR . CDR is a transfer syntax for mapping data types into a low level octet sequence for on the wire transfer between ORBs. CDR is described fully in version 3.0 of OMG s CORBA specification and requires that machines with a common byte order may exchange messages without byte swapping. When communicating machines have a different byte order the message originator determines the message byte order and the receiver is responsible for swapping bytes to match its native ordering. A flag in the message header indicates the appropriate byte order. Byte order is also referred to as endian ness. CDR also requires that data types be aligned on their natural boundaries within the message body. Other embodiments of the disclosed invention contemplate the use of other sets of encoding decoding rules such as XDR and CCDR for example.

When an inbound communication from an object implementation not shown is received from transport communications protocol machine transforms the low level octet sequence into an object communication for dispatch to application software . Protocol messaging machine receives the low level octet sequence comprising one or more inter ORB message headers and evaluates the message headers. In an exemplary embodiment the ORBs associated with the communications protocol machine support a subset of the Common Object Request Broker Architecture CORBA as specified by the Object Management Group OMG in version 3.0 of its Common Object Request Broker Architecture CORBA specification. In this embodiment protocol messaging machine evaluates the sequence of octets comprising a General Inter ORB Protocol GIOP message header and identifies the appropriate GIOP message type. Protocol messaging machine then evaluates the secondary message header unique to the GIOP message type. GIOP message types GIOP message structure GIOP message header structure and GIOP message type header structures are all described in version 3.0 of OMG s CORBA specification.

In some embodiments of the disclosed invention protocol messaging machine demultiplexes the destination information contained in the secondary message header specifically the object key and the operation name. Communications protocol machine uses lookup tables implemented in memory to determine the destination of the incoming GIOP message.

After evaluating the one or more inter ORB message headers encoder decoder decodes the message body if present into the data types associated with the object communication according to a set of encoding decoding rules. Where there are no data types associated with the object communication no message body exists and therefore no decoding is required. In an exemplary embodiment the set of encoding decoding rules applied by encoder decoder is Common Data Representation CDR . In other embodiments XDR CCDR or some other set of encoding decoding rules are used.

In typical existing designs local processor communicates with hardware object inside the FPGA via the processor bus or some other local transport such as Ethernet. Each accessible register and memory within the FPGA is assigned a location in the processor s address map. Data bound for the FPGA is partitioned into packets with the address of the destination and may be further encapsulated in the format of the local transport. Logic on the receive side strips away the transport encapsulation and passes the data packets to the local address decode logic. The address is decoded and the data is sent to its location via a data bus along with the required read or write strobe.

In the case of the embodiment of the disclosed invention illustrated by each function performed by the hardware object is given an operation name and its properties are described in Interface Description Language IDL a canonical language for describing interfaces used to exchange messages in a distributed environment. IDL is described in version 3.0 of OMG s CORBA specification. The operation may include several accessible memory elements such as registers FIFOs RAM etc. Memory elements can be accessed alone or in groups depending on how they are described in IDL. If it is desired to write a register and read it back at a different time the register would require two operation names one for write and one for read. If it is desirable to write a register and read the results immediately it could be described as a single operation with an inout parameter.

Once the object s operation interfaces are described in terms of IDL an IDL to HDL compiler parses the IDL and generates HDL skeletons to forward GIOP requests and send back GIOP replies from HDL based implementations housed in the hardware platform. The IDL compiler creates three HDL source files and a text file for each IDL file. The HDL files contain the IDL derived information needed when synthesizing the hardware ORB. The text file is an information file to aid developers and it shows how the hardware ORB maps IDL operations and parameters to data ports. The text file lists each parameter and return type of each operation in the interface and shows the IDL type the direction the data width in bytes and the read or write port used for each parameter. After the compiler has parameterized communications protocol machine software ORB can access the object functionality via CORBA GIOP messages. ORB encapsulates the data in a GIOP message and passes this to the local transport.

Communications protocol machine is a hardware implementation of a CORBA ORB. It supports a general subset of CORBA functions and a preferred embodiment is described in portable HDL such as VHDL that can be synthesized onto any FPGA or ASIC platform. Communications protocol machine is responsible for implementing the transfer syntax used in CORBA messages. The core unmarshalls the incoming GIOP octet stream and extracts header and data fields while discarding padding. Endian conversion is performed on all incoming data based on information in the GIOP message header. In the incoming direction communications protocol machine performs operation name demultiplexing to determine which object the data in the GIOP message is being transferred to. Message data is then extracted for transfer to the appropriate logic.

If a message indicates that response is expected communications protocol machine generates a reply message and will perform a read operation to an object if necessary to obtain data for the reply. It then populates the header field and aligns the data. When a reply message has been built communication protocol machine transfers the data to the local transport via a FIFO like interface.

Preferred embodiments of communications protocol machine can also be configured to support FPGA hardware objects that act as clients. When the embedded object makes a function call request communications protocol machine will gather the data from the object and then marshall a GIOP request message and send it to the desired client via the local transport. Any returning reply messages will be processed and the data passed back to the client.

While various embodiments of a method and apparatus for accelerating GIOP protocol have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of the invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents. Moreover the above advantages and features are provided in described embodiments but shall not limit the application of the claims to processes and structures accomplishing any or all of the above advantages.

Additionally the section headings herein are provided for consistency with the suggestions under 37 CFR 1.77 or otherwise to provide organizational cues. These headings shall not limit or characterize the invention s set out in any claims that may issue from this disclosure. Specifically and by way of example although the headings refer to a Technical Field the claims should not be limited by the language chosen under this heading to describe the so called technical field. Further a description of a technology in the Background is not to be construed as an admission that technology is prior art to any invention s in this disclosure. Neither is the Brief Summary to be considered as a characterization of the invention s set forth in the claims found herein. Furthermore any reference in this disclosure to invention in the singular should not be used to argue that there is only a single point of novelty claimed in this disclosure. Multiple inventions may be set forth according to the limitations of the multiple claims associated with this disclosure and the claims accordingly define the invention s and their equivalents that are protected thereby. In all instances the scope of the claims shall be considered on their own merits in light of the specification but should not be constrained by the headings set forth herein.

