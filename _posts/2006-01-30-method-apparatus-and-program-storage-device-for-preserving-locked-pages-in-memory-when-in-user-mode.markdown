---

title: Method, apparatus and program storage device for preserving locked pages in memory when in user mode
abstract: A method, apparatus and program storage device for preserving locked pages in memory when in user mode. A user command daemon is provided for executing a command string received from a user application. A socket interface is disposed between the user command daemon and the application for routing signals between the user application and the user command daemon. The user command daemon provides a returned value to application for loading into memory without causing latencies to the running of the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07661115&OS=07661115&RS=07661115
owner: International Business Machines Corporation
number: 07661115
owner_city: Armonk
owner_country: US
publication_date: 20060130
---
This invention relates in general to a computer operating systems and more particularly to a method apparatus and program storage device for preserving locked pages in memory when in user mode.

A thread is a sequence of instructions. Multiple threads can be executed in parallel on many computer systems. Multithreading generally occurs by time slicing where a single processor switches between different threads or by multiprocessing where threads are executed on separate processors. Threads are similar to processes but differ in the way that they share resources. Many modern operating systems directly support both time sliced and multiprocessor threading with a process scheduler. The operating system kernel allows programmers to manipulate threads via the system call interface.

Operating systems generally implement threads in one of two ways preemptive multithreading or cooperative multithreading. Preemptive multithreading allows the operating system to determine when a context switch should occur. The term context simply refers to all the information that completely describes the process s current state of execution e.g. the contents of the CPU registers the program counter the flags etc. The process of saving the currently executing process s context flushing the CPU and loading the next process s context is called a context switch. A context switch for a full fledged multithreaded process will obviously take a lot longer than a context switch for an individual thread within a process. So depending on the amount of hardware support for context switching and the type of context switch a context switch can take a decent amount of time thereby costing a number of CPU cycles. Cutting back on context switches improves execution efficiency and reduces delays as does the extensive use of multithreading since thread switches are usually faster than full sized process switches.

Cooperative multithreading on the other hand relies on the threads themselves to relinquish control once they are at a stopping point. This can create problems if a thread is waiting for a resource to become available. The disadvantage to preemptive multithreading is that the system may make a context switch at an inappropriate time causing priority inversion or other bad effects if there are real time requirements at the application level which may be avoided by cooperative multithreading.

In multithreaded operating systems all threads in a task share the same address space and are usually sharing large amounts of data. Context switching between two threads in the same task may take much less time than context switching between two threads in different tasks. After a context switch in a multithreaded system a new thread will be running and perhaps a new task.

The kernel mode is a privileged mode in which only the kernel runs and which provides access to all memory locations and all other system resources. Context switches can occur only in kernel mode. Other programs including applications initially operate in user mode but they can run portions of the kernel code via system calls. A system call is a request by an active process for a service performed by the kernel such as input output I O or process creation.

To implement a real time application in user mode it is highly desirable to have the text and data required by the application always reside in the memory. For a typical user mode application text and data are paged in as and when needed. Memory is divided into a number of fixed size or variable sized partitions or regions that are allocated to running processes. The variable size partition scheme may result in a situation where available memory is not contiguous but fragmented into many scattered blocks. To solve this problem the memory may be compacted thereby making large free memory blocks or a paging scheme may be used which allows a program s memory to be noncontiguous thereby permitting a program to be allocated physical memory wherever it is available.

However paging schemes influence process scheduling. When a process is to be executed the scheduler checks its size expressed in pages. Available memory is examined for that process. If the process requires N pages there must be N frames available in memory that must be allocated to this process before the process can be executed. Thus when the code is running there will be cases where the underlying operating system has to stop executing the process code and wait for the text or data to be paged into the main memory. This is done in a transparent method that a user application is not aware that it is waiting on a page. However it does cause unexpected delays and context switching which are very expensive in a tightly time bound process.

This issue is circumvented by loading and locking in the memory all the code and data that a real time application is going to require during the initial bring up of the process. However if at any point of time the process gets context switched out after the initial bring up process problems may occur in the system due to the delays in context switching and the unexpected changes of timing among interacting processes inside the real time application with stringent timing requirements.

There is also a potential problem when a process is running in user mode. If at any point of time the process calls system cmd to run command cmd that translates to forking a process and making the process do the work related to cmd . Each process has process context which is everything that is unique about the state of the program you are currently running. A fork in a multithreading environment means that a thread of execution is duplicated. When a new process is forked it shares relatively little data with the parent process that created it when a new thread is created it shares much more information such as all the global variables and static local variables the open files and the process ID . Specifically in an operating system like Linux whenever a process does a fork it changes the property of all the memory pages used by the process to copy on write . This unlocks the memory pages previously locked by the process and can cause the operating system to page out or drop these unlocked memory pages when the system comes under memory stress. As a result a real time application will go through the undesired re loading of the memory pages later during its execution even when it has attempted to lock the memory pages in the first place during the initialization. A temporary suspension of program execution due to the delays when a required memory page is being brought in can introduce problems to a real time application.

It can be seen then that there is a need for a method apparatus and program storage device for preserving locked pages in memory when in user mode.

To overcome the limitations in the prior art described above and to overcome other limitations that will become apparent upon reading and understanding the present specification the present invention discloses a method apparatus and program storage device for preserving locked pages in memory when in user mode.

The present invention solves the above described problems by executing the system cmd while maintaining memory pages in a locked state while the command is processed by a user command daemon.

An apparatus in accordance with an embodiment of the present invention preserves locked pages in memory when in user mode. The apparatus includes a user command daemon for executing a command string received from a user application and a socket interface disposed between the user command daemon and the application for routing signals between the user application and the user command daemon. The user command daemon provides a returned value to the socket interface in response to execution of the command string and the socket interface provides the returned value to the application for loading into memory without causing latencies to the running of the application.

In another embodiment of the present invention a method for preserving locked pages in memory when in user mode is provided. In another embodiment of the present invention a program storage device that includes program instructions executable by a processing device to perform operations for preserving locked pages in memory when in user mode is provided. The method and program storage device provide for running an application with all required memory pages locked in main memory sending a command string from the application to a user command daemon executing the command string by the user command daemon to produce a returned value and returning the returned value to the application for loading into memory without causing latencies to the running of the application.

These and various other advantages and features of novelty which characterize the invention are pointed out with particularity in the claims annexed hereto and form a part hereof. However for a better understanding of the invention its advantages and the objects obtained by its use reference should be made to the drawings which form a further part hereof and to accompanying descriptive matter in which there are illustrated and described specific examples of an apparatus in accordance with the invention.

In the following description of the embodiments reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration the specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized because structural changes may be made without departing from the scope of the present invention.

The present invention provides a method apparatus and program storage device for preserving locked pages in memory when in user mode. A system cmd is executed in a different process context in which case the memory pages locked by a real time application remain intact and the returned value provided in response to the executed command is provided to the memory with causing any latencies.

The computer system and the allocation of system resources to the computer system are controlled by operating system . For the purpose of the present discussion it is assumed that operating system is resident within primary memory although those skilled in the art will appreciate that certain infrequently utilized segments of operating system may be swapped out to secondary memory by memory manager . Operating system includes kernel which comprises the lowest layer of operating system that interacts most directly with the computer system . Kernel dispatches kernel threads to processors for execution provides services to device drivers interfacing with hardware within computer system and implements system services memory management network access and the file system utilized by computer system . In addition to kernel primary memory also stores frequently utilized segments of application software . As is well known to those skilled in the art application software communicates with operating system through an Application Programming Interface API .

Computer system also includes bus interface through which multiple nodes can interface to system resources available within computer system . As will be appreciated by those skilled in the art computer system may also include additional hardware coupled to system bus that is not necessary for an understanding of the present invention and is accordingly omitted for simplicity.

Processes that run in kernel mode can directly access system data and hardware and are not restricted like processes running in user mode . Performance sensitive drivers and services run in kernel mode to interact with hardware more efficiently. All components for processes running in kernel mode are fully protected from applications running in user mode . Processes that run in user mode are effectively isolated from processes running in kernel mode and other processes running in user mode .

In a thread for a process running in user mode is characterized as having its own context including registers and memory stack . A user stack is a data structure that includes a series of memory locations and a pointer to the initial location. All processors provide instructions for placing and retrieving values to and from the stack . The user memory is a block of memory that is dedicated to the use of a current process running in user mode . A complete user state of a thread is maintained in user registers .

The kernel operates in its own protected address space and includes its own registers and kernel stack . The kernel maintains the integrity of its own data structures and that of other processes. The kernel stack includes information used by the kernel. Kernel memory is generally shared by all processes but is only accessible in kernel mode . Context changes from one task to another happen on the kernel stack of the current process.

When a system call is issued a sequence of instructions is typically run to save the current context of the processor. This method by which the operating system makes one CPU suspend the execution of on process and continue or begin executing a second process is referred to as a context switch. During a context switch the CPU switches to using the full context of the second process i.e. its execution stack its memory area the values the registers contained when last executing this process. A context switch is invoked when the current process is preempted by a system call. However as mentioned above if at any point of time a user process calls system cmd to run command cmd that translates to forking a process and making the process do the work related to cmd . This unlocks the memory pages previously locked by the process and can cause the operating system to page out or drop these unlocked memory pages when the system comes under memory stress. As a result a real time application will go through the undesired re loading of the memory pages later during its execution even when it has attempted to lock the memory pages in the first place during the initialization. A temporary suspension of program execution due to the delays when a required memory page is being brought in can introduce problems to a real time application.

The main real time user application runs with all the memory pages it requires locked in main memory . The user command daemon waits to receive a command from the main user application . Whenever the main user application needs to run a system cmd the user application sends the command string across to the daemon through the socket interface . The socket interface supports communication between the user application and the daemon . When the daemon receives the string command from the main user application the daemon executes the command by calling the system cmd . The command execution block executes the command and returns code in response to the executed command. The returned value is returned to the socket interface which is waiting for the returned value . The socket interface provides the returned code to the user application .

Accordingly the system cmd call may be run while simultaneously retaining all the process memory in the locked state so there will be no latencies caused because of page faults within the main real time user application . As the process is being forked on the daemon side the memory locked by the real time application remains intact and unnecessary task suspensions are avoided when the pager actually brings the code into the memory . This increases the performance and avoids other race conditions.

For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The medium may be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly to the system or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the system to become coupled to other data processing systems remote printers or storage devices through intervening private or public networks . Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

Accordingly the computer program comprise instructions which when read and executed by the system of causes the system to perform the steps necessary to execute the steps or elements of the present invention

The foregoing description of the embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not with this detailed description but rather by the claims appended hereto.

