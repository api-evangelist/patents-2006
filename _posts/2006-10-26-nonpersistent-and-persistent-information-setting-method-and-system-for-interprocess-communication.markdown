---

title: Non-persistent and persistent information setting method and system for inter-process communication
abstract: System, method, architecture, network device, and computer programs and computer program products for inter-process communications. Message structure, procedure for generating the message structure, applications of the message structure and messaging method for obtaining status, statistics, and other information and for performing an information or parameter set operation across one or more process boundaries, and to other device and system architectures and methods for utilizing the messages and messaging methodology.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08250587&OS=08250587&RS=08250587
owner: Trapeze Networks, Inc.
number: 08250587
owner_city: Pleasanton
owner_country: US
publication_date: 20061026
---
This patent application claims the benefit of priority under 35 USC 119 to U.S. Provisional Application Ser. No. 60 732 038 filed Oct. 27 2005 and entitled MOBILITY SYSTEM which application is hereby incorporated by reference in its entirety.

This application is also related to U.S. Utility patent application Ser. No. 11 588 849 filed 26Oct. 2006 and entitled Mobility System and Method for Messaging and Inter Process Communication and U.S. Utility patent application Ser. No. 11 588 878 filed 26 Oct. 2006 and entitled Information and Status and Statistics Messaging Method and System for Inter Process Communication each of which applications are hereby incorporated by reference.

This invention relates generally to systems methods architectures and computer programs and computer program products for interprocess communications and more particularly to a message structure a procedure for generating the message structure applications of the message structure and messaging method for obtaining status statistics and other information and for performing an information or parameter set operation across one or more process boundaries and to other device and system architectures and methods for utilizing the messages and messaging methodology.

Conventionally authoring a single or small set of executable software or other program code for what may be considered as bundling of multiple functions or operations into the single process code has had the advantage that communication between the multiple functions or operations is simplified. Communications between any two functions within the single executable program code has also been relatively simple in that communications between any two or more of the multiple functions may readily be achieved by passing or sharing memory contents or ranges within the single executable software or other program code.

Unfortunately executing the single or small set of executable software or program code has had the disadvantage that it may contribute to instability because of functions that may sometimes tend to interfere with each other in unexpected ways during their execution in the real world as well as possible susceptibility to security flaws memory overflow and other problems. It may also complicate the task for developers to work together without having detailed knowledge of other developers efforts.

Therefore it has been recognized that in at least some instances there are advantages to separating different functions or operations even when related or when requiring coordination between the related functions to separate the functions into different processes that have defined process boundaries and are executed independently and advantageously substantially autonomously from one another. Typically however since the processes are at least somewhat related or interdependent some degree of communication between the different processes usually referred to as Inter Process Communications or IPC is required to facilitate operation of the system as a whole.

Software and system designers have utilized various interprocess communications architectures and methods in the past to permit communications between different processes within in a system. Unfortunately these architectures methods procedures and interprocess communications techniques have had limitations so that they have not necessarily been universally applicable to the diverse range of system architectures device characteristics or functional and operational needs. They may also have had complicated interfaces that required relatively high levels of programming skills that added to the cost and time involved in implementing them and were more difficult to test and debug.

For example some conventional interprocess communication or messaging techniques are protocol or transport layer dependent or are client server relationship specific in some way or are merely remote program calls or other situation where there is again an asymmetry dependency special treatment or characteristic or bias toward one of the message sender or receiver. Furthermore these conventional interprocess communication techniques architectures and methods may not usually be able to efficiently and reliably provide the type of interprocess communication that are required for particular situations or applications.

One of conventional communication that may be thought of as a pseudo interprocess communication technique was the Sun Microsystems remote program call RPC technique. Another was the Open Network Computing ONC remote program call technique. Each of these techniques involved specifying one or more interfaces to a library so that there was a client on one side of a network and a server on the other side of the network and to the client it would essentially appear that the client was making a direct functional call to a library on the server even though was or might be a network between the client and the server based library. These RPC models may be considered to be asymmetric and very much client server models which means at the very least that each side has either a special server characteristic a special client characteristic or some other side specific characteristic. These side specific characteristics are frequently undesirable in many applications.

Many of these conventional interprocess communication or pseudo interprocess communication models methods and techniques were also synchronous in that there was a need for the sender process to receive a response back from the intended recipient or receiver process before the sender process could continue. Since the response in many networking situations could take at least large fractions of a second such synchronous operational requirements led to inefficiencies unnecessary overhead and reduced performance.

Conventional interprocess communication schemes and techniques and even the messages themselves were also frequently difficult to implement and typically required highly skilled computer programmers with an ability to program code in relatively low level and non intuitive languages such as the C C and similar programming languages.

Conventional processes also frequently fell primarily or even exclusively into one of two models a thread execution based model or a finite state machine based execution model.

Therefore there remains a need for an interprocess communication method model and architecture in which the interprocess messaging is more symmetric and peer to peer or message producer consumer like in approach without a bias as to which process device or system is the producer and which process device or system is the consumer of any particular messaging event. Even where there may actually be a server and a client such labels from the standpoint of the messaging event are or should be relatively unimportant.

There also remains a need for a message structure that provides the desired message information and content and that is compatible with the messaging model and method.

There further remains a need for a message that is relatively easy to specify and that may advantageously be written in a relatively high level language such as for example in the XML language or other higher level language.

There also remains a need for a interprocess message communication methodology and message structure that permits the sharing of information across process boundaries whether the process boundaries exist between processes in a single hardware device or between separate hardware devices that are either collocated in a facility that may use one particular message transport layer or coupled or connected over a communications link between geographically remote hardware devices or systems possibly using a different transport layer but the same message structure.

There also remains a need for an interprocess communication scheme and message structure that permits authoring and generating messages and communicating messages between different processes that is simple and efficient.

There also remains a need for an interprocess communication scheme and message structure that is suitable for wired wireless and hybrid wired and wireless network communication infrastructures including infrastructures involving one or more of network servers routers switches access points and clients.

There also remains a need for an interprocess communication scheme and message structure that permits efficient operation with low overhead in both thread based execution schemes and finite state machine based execution schemes particularly as they may apply to different devices and systems in a network infrastructure and network packet processing environment.

There also remains a need for an interprocess communication scheme and message structure that permits the acquisition by one process of the status and statistical information known within or available from another process.

There also remains a need for an interprocess communication scheme and message structure that permits persistent and or non persistent setting of information or data using a message sent from a first process and received by a different process.

This invention provides systems methods architectures and computer programs and computer program products for inter process communications and more particularly to a message structure a procedure for generating the message structure applications of the message structure and messaging method for obtaining status statistics and other information and for performing an information or parameter set operation across one or more process boundaries and to other device and system architectures and methods for utilizing the messages and messaging methodology.

In one aspect the invention provides a method for setting an information across an interprocess boundary from a from an information producer process to an information consumer process using an information setting message where the producer and consumer processes are separated by at least one process boundary the method comprising generating an information set request in the producer process communicating a message including the information set request from the producer process to the consumer process receiving the information request by the consumer process and processing the request and setting the information in the consumer process.

In another aspect the invention provides a computer readable medium encoded with a computer program for directing a computer to set an information in an information consumer process where the consumer process is separated by at least one process boundary from an information producer process the computer program including a module that includes executable instructions for generating an information set request in the producer process communicating a message including the information set request from the producer process to the consumer process receiving the information request by the consumer process and processing the request and setting the information in the consumer process.

In another aspect the invention provides a system for setting an information from an information producer process to an information consumer process where the producer and consumer processes are separated by at least one process boundary the computer system comprising means for generating an information set request in the producer process means for communicating a message including the information set request from the producer process to the consumer process means for receiving the information request by the consumer process and means for processing the request and setting the information in the consumer process.

In another aspect the invention provides a method for defining information to be set in an external process in a computing machine or device the method comprising defining a message using a high level language automatically generating a plurality of application programming interfaces APIs including implementation code and any interfaces using the APIs to transfer information data or state from one process to another process across a process boundary.

In another aspect the invention provides a method for designing an information setting message comprising 1 defining an information setting NPS message in a high level descriptive language 2 running the high level descriptive language through an NPS message transformation or modification tool adapted to the high level descriptive language to generate per NPS message Application Program Interfaces APIs and 3 using these APIs to set the NPS information from one process to another process.

In yet another aspect the invention provides for implementation of at least some of the various methods to be implemented as computer programs where the computer programs may include a computer readable medium encoded with a computer program for directing a computer or a processor or other logic circuit or logic means to act in a particular manner.

A communication and messaging system method computer program and computer program product are described for communicating or messaging between two or more processes. This inter process communication or messaging scheme may be applied between any two processes whether within a single physical device between processes executing in different devices in peer to peer situations or in client server or server client situations and in any other situation where there is a need or desirability to communicate message send instructions make requests pass parameters get status or other information set parameters data or other information or in any other way perform one way two way or multi way information exchanges between computer programs or processes.

Aspects of the invention provide for sending general messages between processes that may or may not result in an optional response from the receiving process. Other aspects of the invention provide for sending a message from a first process to a second process that will result in the return or retrieval of an information item or data from the second process whether that returned information item or items be status from the second process statistical information that the second process has access to or any other information. In another aspect the invention provides for sending a message from a first process for non persistently setting or persistently setting with an additional store or save operations some information item data status flag condition or any other parameter value or state in a second process. The non persistently set information item can then be made persistent by having the second process persistently store keep save utilize or by any other means retain the information sent from the first process to the second process.

In general terms elements of the general messaging system and method are also used for the system and method for returning or receiving information from a second process and elements of both of these systems and methods are used for setting information in a second process by the first process. Extensions and enhancements are added at each level to achieve the desired operation. The generalized interprocess messaging the interprocess information retrieval and the interprocess information setting are described below.

Techniques described herein enable developers to create interprocess communication messages without having to implement marshalling and unmarshalling functions or worry about many other aspects of interprocess communications and to provide an intuitive means of specifying and using those messages. An example of a system developed according to this technique provides automated Inter Process Communication IPC such as for example various processes in a LAN to allow developers to work only on an XML layer this allows messages to be specified using only XML. The messages may be organized into catalogs of specific functions. Advantageously a developer can register a function against a message so that a single dispatch can be called to handle both. This is particularly valuable in a system that includes multiple processes with the need to communicate with each other. In a non limiting embodiment marshaled messages are hardware architecture agnostic and message transport is independent of the messages.

In one non limiting embodiment an exemplary system configuration with which the inventive messaging architecture method procedures and computer program and computer program product may be utilized may include a network device such as for example a network switch is coupled for communication with a network management system. In one embodiment the network management system may include the Ringmaster server management software manufactured by Trapeze Incorporated of Pleasanton Calif. . The network management system may further include mobility systems software. Though not required for practicing the invention a network management system such as the Ringmaster server network management system provides a client server application that enables organizations to perform pre and post deployment planning configuration and monitoring and management of the a network infrastructure. The two or more processes which may for example take place between two processes executing in a device such as for example in a network wireless switch or other device or system. For example if the device is a switch then a first process that is involved with a web http process may need to talk to a second process involved with device configuration so that the process involved with the device configuration can enable or disable the http process for communication or to get status statistics or other information or even to set some parameter or condition. These are merely non limiting examples of interprocess communications that may benefit from the inventive features.

Aspects and features of this invention have been described in co pending U.S. Provisional Patent Application No. 60 732 038 filed 27 Oct. 2005 entitled MOBILITY SYSTEM including in the specification drawings and computer program code and pseudo code that is included in one or more of the appendices of that application and which application is hereby incorporated by reference in its entirety.

In a non limiting implementation rather than developing a new language to obtain desired functionality XML was used to facilitate use of the system without extensive retraining of developers in the new language. Underlying processes may advantageously be handled automatically for developers who only needed to work in an XML or other higher language layer. Interfaces are advantageously generated using XML or other higher language or more intuitive code or other declaratory computer programming language as well. In this particular embodiment communication between processes is accomplished by passing messages through UNIX domain sockets. However the communication could be by any other practical means such as over Internet sockets. Of course the communication could be by less practical means as well such as facsimile. Other implementations using for example other languages are anticipated and should be apparent to those of skill in the art upon a careful reading of this specification.

Various methods procedures and techniques are described in terms of two or a plurality of processes. It will be appreciated that the invention and its various embodiments include the method steps that occur between and among the different processes as well as the steps that take place in each of the processes separately as the process interacts with another process. Therefore in the embodiments described herein although the method technique computer program code or the like may be described in terms of two processes the invention will be understood to include the steps taking place in each process separately and vice versa.

In one non limiting aspect the inventive message structure and messaging method provides an automated interprocess communication IPC that permits various processes to communicate with each other while the developers of the system and device architecture and computer program code do not have to work or program at any other layer than an XML or other declaratory computer programming language program language layer. The developers define messages using a message structure and the inventive structure method and programming technique handles everything else automatically to generate the information files and executable program code to implement the desired interprocess communication or messaging.

In one non limiting embodiment the invention provides one or more message definition files and each of these message definition files may where each message catalog may include zero to many messages typically one or more messages be referred to as a message catalog. In one embodiment there is one message catalog in one file but the message catalogs need not be files and a file is merely one non limiting physical manifestation of how a message catalog may be defined or implemented. Advantageously the message definition files provide a description of the message elements are written or defined in terms of the XML programming language or other declaratory computer programming language . Table I below provides an example of a message catalog that may include one or more messages.

The inventive structure and method differ from conventional structures and methods in at least the following ways. First in at least one non limiting embodiment it has its own message definition language and language structure from other known IPC and remote program call RPC interprocess communication structures and methods. Second in at least one non limiting embodiment the invention utilizes XML to generate the interprocess communication interfaces. Other languages may be utilized for this generation. Third in at least one non limiting embodiment marshalling code is automatically generated in a C language file. The marshalling code puts or encodes the desired message from the easier to program and more intuitive higher level XML language into a defined message structure and since it put into a well defined message structure by the marshalling code the same message when received by an intended recipient may readily be decoded and put into a known defined structure by unmarshalling code at the recipient or receiving end. Each C file for other implementation file advantageously includes one or a number of computer programs. These computer programs may be considered to be functions procedures or routines for each message and used to implement or communicate for each message.

Exemplary embodiments provide a C file or other implementation file that provides message marshalling a kind of well defined structured creation of a message. Message marshalling and message unmarshalling are described herein elsewhere.

Registration routines for each message are created by the message translation tool such as by a message compiler. A message may be created and a function is registered that is linked with or associated with that message. Advantageously the inventive message structure and messaging method are automated as much as possible with the goal that not only are the structures created but it is also desirable to provide the automation so that the developer can take a function and register the function against the message so that the developer may then when a message is received call a single message dispatch function with the message.

In a non limiting embodiment the structure of the messages is advantageously well defined. Having a message that is well defined assists in the message automation and the marshalling and unmarshalling of the message. Table 1 depicts an exemplary structure of the message catalog using the XML language and using a Document Type Definition DTD or dtd structural definition of a document using XML. Table 2 illustrates an instance of a catalog defined using DTD. Other message definition forms may be used so that the invention is not limited to DTD defined messages or to the XML language.

In one non limiting embodiment of the invention messages are defined using a simple XML document type definition dtd as indicated in the XML language which is further described relative to Table I below.

The exemplary message definition in Table 1 provides a document type definition dtd for a message catalog. It may be noted that the lower case abbreviation dtd and the upper case abbreviation DTD for Document Type Definition are equivalent and used interchangeably in this document though the lower case dtd is more typically used in the exemplary code and pseudo code. The DTD defines the proper or legal building blocks of an XML document and defines the document structure with a list of legal elements. Here in Step ELEMENT CATALOG defines the element CATALOG as having zero or more elements called MESSAGE. It may be appreciated in light of the description provided here that a catalog may be considered at a high level to be like a document and just as a document may be comprised of a single file or data set or a plurality of files or data sets so too may a catalog be a single file or data set or a plurality of files or data sets.

The XML attribute list declaration ATTLIST is used to declare XML element attributes. The ATTLIST declaration defines the element which may in general have four parts the attribute the name of the attribute the type of the attribute and the default attribute value.

In step ATTLIST CATALOG catalog name NMTOKEN REQUIRED declares that the element CATALOG has an attribute name catalogname and that the attribute catalogname has an attribute type NMTOKEN meaning that the value must be a valid XML name and that the attribute value must be included in the element REQUIRED .

In step ELEMENT MESSAGE defines the element MESSAGE as having one element PARAMETER . In step ATTLIST MESSAGE callname ID REQUIRED declares that the element MESSAGE has an attribute name callname and that the attribute callname has an attribute type ID meaning that the value is an unique ID and that the attribute value must be included in the element REQUIRED .

In step ATTLIST PARAMETER id CDATA REQUIRED type INT STR INTARRAY STRARRAY OPAQUE SEQUENCE REQUIRED declares that the element PARAMETER has an attribute name where CDATA indicates that the value is character data INT STR INTARRAY STRARRAY OPAQUE SEQUENCE indicates enumerated values of INT STR INTARRAY STRARRAY OPAQUE SEQUENCE and that the value must be included in the element REQUIRED .

In step ELEMENT SUBPARAM EMPTY defines the element SUBPARAM as having no additional elements e.g. is empty .

In step ATTLIST SUBPARAM type INT STR OPAQUE REQUIRED declares that the element SUBPARM has an attribute type and no name or ID.

By way of summary this set of steps says that catalogs may include messages messages may include parameters and parameters may include sub parameters.

It will be appreciated that the marshalling procedure may advantageously utilize a well defined format that does not introduce ambiguity into the marshaled code structure so that unmarshalling or extraction of the message or message catalog content may be performed in an efficient and unambiguous manner. Advantageously the marshalling and unmarshalling are performed in a manner and according to rules that permit the marshaled and unmarshalled messages and or compiled and or decompiled versions thereof to be understood in a hardware operating system OS and or applications program interface or computing or processing environment agnostic manner. In at least non limiting embodiments of the invention the particular message definition marshaled and or unmarshalled message format or formats is not important so long as there are understandable rules that are used to put the message information into the form marshal and then later extract it unmarshal . In one non limiting embodiment a marshaled message may be unmarshalled in different formats for different processes if desired or required. There is no one standard that needs to be implemented whatever standard or implementation adopted just needs to be repeatable. The particular embodiment of the format and rules described herein do provide some particular advantages to the particular network environment inter process communications.

It will be appreciated in light of the description provided herein that embodiments of the invention provide a way of describing a message as consisting of a number of parameters wherein each parameter may be described as to the data or information it represents. The inventive message structure and messaging method are able to collect one or a plurality of messages into a catalog of messages message catalog .

An exemplary process for marshalling information generally and for marshalling a message in particular is now described.

Marshalling information or data refers generally to a procedure for collecting constructing organizing formatting or otherwise bringing together information or data in any form and putting it into a well defined standard form or organization. Data or information may include but is not limited to numbers symbols characters code messages or message components statistics status indicators binary or ASCII representations or any other data or information without limitation. A particular marshalling procedure that is applied to a non limiting embodiment of the invention that optionally but advantageously uses a network operating system NOS context to generate the messaging code and provide the message generation transmission and message receipt infrastructure. This messaging methodology may be applied to messaging amongst and between a plurality of processes in a network environment that need to or are advantaged by communication with each other either directly or indirectly.

The structures of the messages are advantageously defined or well defined and based on rules or policies that provide not only for the construction or marshalling of the message or messages but also provide for the unmarshalling or extraction of the message content or information in a different receiving process that is advantageously but optionally any one or a combination of operating system agnostic or independent or does not care hardware software language environment and or in other ways agnostic or independent so that the structures of the messages and the marshalling and unmarshalling will work properly and predictably in any environment and in particular will work where the sending computing or messaging environment is different from the receiving computing or messaging environment.

In one non limiting embodiment the interprocess communication in the form of messaging uses UNIX domain sockets to pass messages. In another non limiting embodiment the interprocess communication messaging uses Internet sockets to pass messages. In yet another non limiting embodiment the interprocess communication messaging uses a shared memory a file or files or any other means to pass messages.

In one embodiment of the invention a simple and relatively high level programming language such as XML is used to define messages and message catalogs and a message converter tool optionally including a message marshalling tool is then used to convert the messages and message catalogs into marshaled computer code. Advantageously the converted or marshaled computer code may be in a derivative or different computer language such as in a language that is more closely adapted to the computing or information processing environment that will execute or otherwise use the marshaled computer code. In one non limiting embodiment the different or derivative language may be the C C or other language without limitation. For example though having some possible disadvantages even programming languages such as Fortran Cobol Pascal new languages yet to be developed as well as enhancements and extensions to known languages may be used.

Because the rules and structure of the converted or marshaled message computer code are well defined a different or complementary second conversion or unmarshalling tool may advantageously be used to unmarshall the message or perform a second conversion so that the receiver of the message may readily understand and or extract the content of the received message even though the receiver process may exist in a different hardware operating system application program or other environment.

In the exemplary embodiments described herein the marshalling and subsequent unmarshalling of messages and or message catalogs generate one or more message catalogs based on specifications or definitions in the XML language such as XML version 1.0 however the invention is not limited to any particular XML or other language version. In particular it will be appreciated that later versions of XML may be utilized in conjunction with the invention as well as later languages that may be used in the computer and programming arts particularly as they apply to network devices and systems. In other non limiting embodiments of the invention the marshalling and subsequent unmarshalling of messages and or message catalogs generate message catalogs based on specifications or definitions in some other language which other language is advantageously higher level and therefore a simpler easier to program and or more intuitive language . The marshalling language and unmarshalling language may the same or may be different languages. The unmarshalling may result in the initial message form or may result in a different message form or structure so that the marshalling and unmarshalling need not be symmetrical.

A message transformation tool such as a message compiler automatically creates the marshalling and unmarshalling tools so that a computer code or program developer may work in the relatively high level or more intuitive programming language such as XML and does not need to know how to explicitly and in detail create either the marshaled code or unmarshalled code or the converted or compiled version of the marshaled or unmarshalled code such as for example the header file and the C file code described herein elsewhere .

In one non limiting embodiment a first file referred to as an interface or header file describes the contents of a second file such as the C file and the second or implementation file such as the C file implements the marshalling of the message and the transport of the message to the other process. However it will be appreciated that the invention itself is transport independent and that any transport process or mechanism may be used.

In at least one non limiting embodiment of the invention multiple or a plurality of message catalogs may be related. By way of example but not limitation a first process Process A may support message catalogs 1 2 and 3 and a second process e.g. Process B may support message catalogs 1 5 and 6. Each message catalog may therefore support either non overlapping e.g. disjoint processes partially overlapping or common processes or completely overlapping processes without limitation. These are some examples of relationships between message catalogs.

A message catalog is defined by a message catalog definition. In one non limiting embodiment the message catalog definition has a form exemplified by the XML message catalog definition shown in Table 2.

In this exemplary message catalog definition Step identifies the XML version as being version 1.0 . This statement the XML declaration should always be included as the first line in the document and defines the XML version of the document. In this case the document conforms to the 1.0 specification of XML.

In Step a document type declaration DOCTYPE is used to wrap the included DTD in the XML source file and says the only valid document type here is a CATALOG and having a catalog name. For purposes of this example the catalog name is testcatalog but it can be any name. Here the root element CATALOG PUBLIC is the TRPZ DTD Messages definition 1.0 EN messaged document type definition messages.dtd See also Table 1 

Next Step the refers back to the description in Table 1 Steps and for the catalog with catalog name testcatalog.

Then Step specifies three parameters for the message testone a first parameter having id 1 and type integer a second parameter having id 2 and having type string and a third parameter having id 3 and a type integer and ends with .

This message catalog is then processed through the message transformation tool or message converter such as for example through a message compiler to generate an implementation file or data structure such as for example a C language file or data structure and an interface file or data structure such as for example a C language header file . Typically the language of the implementation file and of the interface file will be the same but they need not be and in some embodiments there will only be an implementation file without an interface or header file. In these situations the interface information may usually be provided within the implementation file itself or by other means. It will be appreciated in light of the description provided herein that the inventive system and method may be implemented in a variety of languages and even for example when the implementation file is a C language file the invention includes all of the versions variation enhancements and extensions to the C language such as for example but without limitation to the C C Java Fortran Pascal Cobol and any other language.

It will be noted that the term file may refer to a file or any other data structure whether in the form of a traditional file or other data structure. In one non limiting embodiment the message and message catalog are written or defined in the XML language and the compiler is an XML compiler that generates a compiled output into the target output program language such as the C language.

In the example of the message transformation tool or message converter such as for example a message compiler transforms or converts each message into an interface file where required and an implementation file . In a non limiting embodiment the message converter may be a message compiler that compiles or transforms the code into the two files. By way of example but not limitation the interface file may be a C language header file and the implementation file may be a C program language file. In an alternative embodiment the message converter may be an interpreter and by way of example but not limitation the resulting code could be included in a single e.g. Java file rather than in both an interface file and an implementation file .

Table 3 and Table 4 depict examples of a header file a type of interface descriptor file and a C language executable file a kind of message implementation file respectively that might be generated according to one alternative embodiment.

An exemplary compiler output of the C language implementation file and the C language language header file are illustrated in Table 5 and Table 6. also illustrates relationships between the interface file the implementation file and other elements of the system.

With reference to Table 3 in one non limiting embodiment the catalog interface procedure comprises the steps of creating a function to handle each response Step registering the function in the message catalog Step calling or otherwise utilizing the marshal code to create a message Step sending the encoded message to a message recipient such as to a server or to a different recipient directly or indirectly through a server Step receiving and reading a response from the recipient or server either directly or as an intermediary from a different ultimate recipient and responder Step and calling the generic or overall unmarshalling routine e.g. unmarshall testcatalog to process the incoming message Step . The unmarshalling call may optionally include an argument such as a last argument in an argument list to be passed to the function defined in step and may be used to maintain state. In the exemplary code in Table 3 the last argument NULL is used for this state maintaining purpose.

In the step of sending the encoded message Step above the transport layer used is not important it can be a file or any other transport mechanism or layer.

Although XML program language is preferred and described herein it may be appreciated that other programming languages may be used instead or in combination. For example the invention may be implemented using any formal computer program language that allows one to define a structure usually any declarative language.

In one embodiment two files are utilized. Advantageously one file provides a header or interface description for the second file and the second file provides the implementation details. The header file is referred to as an interface file because it describes the interface s that is or are available for passing messages.

The header or interface file is provided to other programs to use and identifies what is in the second implementation or C file. The term C file is used because in one preferred embodiment the implementation file is a C language program code file. The implementation or C file may be a single file or may be separated into a plurality of files. For example though no particular advantage may be provided the second or C file may be cut or separated into a plurality of files such as for example into as many separate files as there are C functions. Since the file is automatically generated it does not matter how large the implementation or C file is. In the context of embodiments of the invention there is no need or particular advantage to separate the contents of the implementation or C file. Furthermore though not required anyone process or device using one component of the implementation or C file probably wants to or readily may use all or selected ones of the components of the single implementation or C file so that there is probably no advantage to using more than a single header file.

For ease of description it will be understood that the use of the term C file implies any implementation file having the properties described herein and not merely to a C language program file. In similar manner reference to a header or h file refers to any interface file having the properties described herein.

In one non limiting embodiment one implementation or C file and one interface or header file are provide per message catalog. This may typically be true when each message catalog includes a single message. That is compilation of each XML file ultimately generates one C file and one header file. Alternatively one may put more than one XML file into a catalog so that the multiple XML containing catalog may be compiled into a one C file and one header file. The use of multiple files may typically be advantageous when the catalog is particularly large however in prototype implementations no practical limits for single file implementations have been identified.

In general a catalog can have an unlimited number of messages and therefore an unlimited number of XML message descriptions. However as one of the objects of the present invention is to provide an easier code development procedure where a code developer need only concern her self him self with the single coding or programming task at hand it is advantageous to have each XML file compile into one C file and one corresponding h or header file.

The invention is not however limited to implementation languages that require or are compatible with header files. For example some languages such as PERL may be used for the implementation file and yet do not require or even benefit from a header file. It is a dynamic or interpretive language and does not need a header file. Even for a C language or any other language implementation the invention may be implemented without an interface or header file so long as one specifies the appropriate rules and policies for interpretation of the implementation file. Alternatively or in addition the information that would have been placed in the header or interface file may be included in the implementation file itself so that when that implementation file is accessed or opened the information will be available to interpret and use the implementation file. In one non limiting embodiment that utilizes XML program language for the operations for a client program use of the message catalog and interface the code or pseudo code shown in Table 3 serves as an example.

Function prototypes are advantageous when trying to compile or code against. Table 4 sets forth exemplary rules or policies for creating function prototypes. The prototypes are included in the header files.

The following rules in Table 4 may be used in one embodiment to create function prototypes. An exemplary sample header file such as may be generated by compiling the message catalog illustrated in Table 5 and an exemplary implementation file here an implementation file in the C language illustrated in Table 6.

The rules set forth a procedure or logic within the message transformation tool or message compiler for generating information for the interface or header file or other data structure. These rules are described by way of an exemplary transformation between definitions in Table 2 as inputs and resulting code in Table 5. Two of the rules in Table 4 apply to messages Rule 1 and Rule 2 and two of the rules apply to catalogs Rule 3 and Rule 4 one each for marshalling and unmarshalling. In the case of marshalling the message catalog the result is called register message function e.g. register mfunc testcatalog rather than marshall testcatalog.

Rule 1 applies to marshalling and specifies that the message should be marshaled or constructed using the message name. Step of Table 5 is an example of the result of applying Rule 1 from Table 4 to generate the particular message component testone of the header file. Table 4 is inside of the message compiler logic inside of the message compiler and for every message inside the message catalog these rules get applied and that application yields or generates the output in the interface or header file of Table 5.

Applying the first two rules to message named testone results in marshall message testone see step in Table 5 and unmarshall message testone see step in Table 5 and applying the second two rules to the catalog named testcatalog which results in register mfunc testcatalog see step in Table 5 and unmarshall testcatalog see step in Table 5 . More particularly Step of Table 5 e.g. marshall message testone is the result of applying Rule 1 to Step of Table 2 e.g. Step of Table 5 is the result of applying Rule 2 of Table 4 to Step of Table 2 Step of Table 5 is the result of applying Rule 3 of Table 4 to Step of Table 2 and Step of Table 5 is the result of applying Rule 4 of Table 4 to Step of Table 2. It may be appreciated that other or alternative rules or transformation tool or compiler logic may be used to implement the desired message transformation conversion or compilation and that the rule execution embodied in the examples are for purposes of illustration and not a limitation of the invention.

It will be apparent by comparing the content of the XML based message definition file in Table 2 and the automatically created interface file e.g. h file or header file and implementation e.g. content file or C file that there are related or associated entries in each file. Advantageously a developer creates a message catalog and then includes the header file and this becomes part of the library. The developer generates the definition and understands the rules which are very clear as to how the function prototypes are structured and generated a developer may then generate code and the code may use or reference the function prototypes and need not know or care at all about how the messaging happens.

Recall that the program code developer merely needs to define the message testone as belonging to the message catalog testcatalog and having parameters 1 2 and 3 with parameter types integer INT string STR and integer INT respectively See Table 2 . The inventive structure and method then automatically and without programmer intervention through the compiler or other message transformation tool generates the interface e.g. the h or header file and the implementation e.g. C file . Exemplary interface file and implementation files are illustrated in Table 5 and Table 6 respectively.

It will be apparent from the description provide herein that the program developers task is vastly simplified by being able to define the message in an XML file or other high level definition format and have the inventive method generate the interface and implementation files. Once these interface and implementation files have been generated a program such as a client program may utilize the catalog interface to send a message and receive and handle a response.

Returning now to the mobility system example of it will be apparent that the interface file and the implementation file are stored in the library . After storage the library includes message specific routines. The routines may include by way of example but not limitation message marshalling message unmarshalling and registration routines for each message. In a non limiting embodiment these routines are not shared among messages. However in alternative embodiments some of the functions or routines could be shared. For example the routines could include a dispatch routine that is shared among more than one message.

In the example of the interface file is included either directly or indirectly in the operational systems code . Operational systems code may for example be a computer program in one of the processes making use of the library. The compiled interface file and implementation files are included in the MSS along with the operational systems code . The MSS may be based upon by way of example but not limitation Trapeze Networks Mobility Switch Software .

Attention is now directed to a description of an embodiment of a method for utilizing a mobility system relative to the flowchart diagram of depicts a flowchart of an exemplary embodiment of a method for utilizing a system having interprocess communications such as mobility system. In the example of the flowchart starts at module where a function to handle a response is created.

By way of example but not limitation the function to handle a response could be similar to the sample function depicted in Table 7. This exemplary function to handle a response performs a minimal function handling task.

In the example of the flowchart continues at module where the function is registered in a catalog. By way of example but not limitation the function may be registered with a call to registration code register mfunc testcatalog testone testonefunc . See e.g. the code register mfunc testcatalog char name intfunc func in Table 4 where in this example char name is testone and intfunc func is testonefunc . The registration code may include registering a callback function.

In the example of the flowchart continues at module where a message is generated or created. By way of example but not limitation the message may be generated or created with a call to marshalling code to create the message marshall message testone buffer 2048 55 test 28 . See for example the C code for marshall message testone char buffer int bufsize int parameter1 char parameter2 int parameter3 in Table 4. Where the function may be registered at a first location or process such as a first process e.g. Process A the message may be created at a second location or process such as a at a second process e.g. Process B . The marshalling code may include creating a message encoding the message deleting the message and returning a result. Advantageously the marshalling code does not require symmetry between the one process and another process.

When these inter process communication or interaction aspects of the invention are applied in a network environment where there may be one of more servers or clients these different processes may apply to server server communications client server communications and or to client client communications. It will also be appreciated that since the inventive system method and techniques do not really have a client server server client client client or server server specificity that the label of client and server are somewhat misapplied. However it may be appreciated that the invention may be applied to clients server and to interactions between clients and servers. The term producer and consumer may be more appropriate and it will be appreciated that a process may at the same time be both a producer for one interaction or communication and a consumer for a different interaction or communication.

In the example of the flowchart continues at module where the encoded message is sent. In one non limiting embodiment the encoded message is sent from the first process to a second process and then a response from the second process is received and read by the first process. When making an analogy to threads sending the message may be considered part of the same thread as the marshalling step . In either case in a non limiting embodiment the thread does not continue waiting for a reply from a server. Rather the message is sent and the thread ends. In a non limiting embodiment the message is received at for example the server where the message was registered step or module . The server may execute a dispatch routine possibly including marshalling a response and send the response back to the client.

In the example of the flowchart continues at module where a response is received. In a non limiting embodiment the response is received at the first process. The first process may start a new thread. illustrates one example of the processes and threads as described in the example of .

In the example of the flowchart ends at module where the incoming message sent by the one process and received by the other process is processed by for example a dispatch function. By way of example but not limitation the message may be processed with a call to an unmarshalling routine such as by a call to unmarshalling code unmarshall testcatalog buffer 2048 NULL . See for example the exemplary C language code for unmarshall testcatalog char buf int size void arg in Table 4. Processing the received response is performed in order to perform useful work with the message such as to perform the instruction or satisfy a request made in the message. The last argument or information of the unmarshalling code i.e. NULL is in the exemplary implementation an optional state argument or information that may be passed to the function defined in Table 5 and can be used to maintain state in one of the processes or to obtain or exchange state or status information between processes.

The method of the flowchart and other methods are depicted as serially arranged modules. However modules of the methods may be reordered or arranged for parallel execution as appropriate.

In light of the description provided herein it will be apparent that the invention provides a generalized inter process message structure messaging method and procedure and substantially automated method for generating messages from high level languages that unburden developers.

Having described various embodiments of the inventive system method device and computer program for generalized messaging attention is now directed to a highlighting of several non limiting embodiments of the invention having particular combinations of features. Some of these features may then be extended to provide information gathering capabilities and information setting capabilities across process boundaries as are described elsewhere herein.

In one 1 embodiment the invention provides a method for automatically generating an implementation data structure for an inter process message to achieve a communication between a first process and a second process the method comprising adopting a message input specification for specifying a message input language and a message input format adopting at least one rule for converting any input message complying with the message input specification into at least one executable message structure in a message implementation language different from the message input language receiving a particular input message complying with the message input specification and automatically generating a particular executable message implementation data structure corresponding to the particular input message from the particular input specification.

In another embodiment 2 the method of 1 provides that the automatically generating includes processing the received input message through a message converter to generate the executable message implementation data structure.

In another embodiment 3 the method of 1 provides that the message converter comprises a message compiler and the executable message implementation data structure comprises a executable implementation file and an interface file.

In another embodiment 4 the method of 1 provides that the input message includes XML language elements the message compiler comprises an XML language to C language compiler and the executable implementation language file comprises a C language file.

In another embodiment 5 the method of 1 provides that the message input language comprises a high level programming language file and the implementation data structure includes a low level executable program code file and the low level executable program code file is generated from the high level programming language specification of the message without programmer coding.

In another embodiment 6 the method of 1 provides that the message input language comprises an XML programming language and the input message is defined in a document type definition file.

In another embodiment 7 the method of 1 provides that the implementation data structure comprises at least one executable program code file.

In another embodiment 8 the method of 1 provides that the executable program code comprises executable program code in a C programming language.

In another embodiment 9 the method of 1 provides that the executable program code comprises executable program code in a C programming language and includes a plurality of C language program components selected from the set of program components consisting of functions routines subroutines procedures libraries and combinations thereof.

In another embodiment 10 the method of 1 provides that n the implementation data structure further comprises an interface data structure.

In another embodiment 11 the method of 1 provides that the interface data structure comprises a header file.

In another embodiment 12 the method of 1 provides that the adopting a message input specification for specifying a message input language and a message input format further comprises defining the message input specification for specifying a message input language and a message input format.

In another embodiment 13 the method of 1 provides that the adopting at least one rule for converting any input message complying with the message input specification into at least one executable message structure in a message implementation language different from the message input language further comprises defining the at least one rule for converting any input message complying with the message input specification into at least one executable message structure in a message implementation language different from the message input language.

In another embodiment 14 the method of 1 provides that the method further comprising preparing the particular input message complying with the message input specification and the automatically generating a particular executable message implementation data structure is performed without human intervention.

In another embodiment 15 the method of 1 provides that the high level message specification and rules completely enable automated generation of an executable message and any interface that may be required.

In another embodiment 16 the method of 1 provides that at least one rule for converting any input message includes at least one rule for marshalling message elements into a complete message.

In another embodiment 18 the method of 1 provides that at least one rule for converting any input message includes at least one rule for generating a message catalog.

In another embodiment 19 the method of 18 provides that a message catalog contains messages messages contain parameters parameters may optionally include sub parameters parameters have a parameter identifier ID and each parameter has a parameter type selected from among a set of defined parameter types.

In another embodiment 20 the method of 1 provides that the message input specification for specifying a message input language and a message input format comprises a formal specification that defines how to specify the message in terms of a high level XML language so that executable code to implement the specified message may automatically be generated without human coding or intervention.

In another embodiment 22 the invention provides a computer readable medium encoded with a computer program for directing a computer to generate a particular executable message implementation data structure corresponding to the particular input message from a particular input message the computer program including a module that includes executable instructions for accessing at least one rule for converting an input message complying with a known message input specification into at least one executable message structure in a message implementation language different from the message input language receiving a particular input message complying with the message input specification and automatically generating a particular executable message implementation data structure corresponding to the particular input message from the particular input specification.

In another embodiment 23 the invention provides an inter process message definition structure comprising a formal message input specification wherein an interprocess message is defined in terms of a document type definition DTD file at least one message catalog element including a catalog name at least one parameter for at least one message catalog element and an optional sub parameter for at least one parameter.

In another embodiment 24 the invention provides an inter process message catalog data structure comprising an XML version element a message catalog name element a message catalog call name element and at least one message parameter identifier element and at least one message parameter type element.

In another embodiment 25 the invention provides a method for communicating a message between a first process and a second process the method comprising generating marshalling an encoded inter process message data set the inter process message data set including an encoded message interface file and an encoded message implementation file sending the encoded message from the sending first process to the destination second process the sending first process not being required to wait for a response from the destination second process receiving a response from the destination processing the received response and optionally extracting a state information.

In another embodiment 26 the method of 25 provides that the generation of the message includes marshalling of message elements into a message to be sent.

In another embodiment 27 the method of 25 provides that the processing of the received response includes unmarshalling the received response.

In another embodiment 28 the method of 25 provides that there is no client server dependency relationship between the first process and the second process or between the second process and the first process.

In another embodiment 29 the method of 25 provides that the messaging between the first process and the second process is a peer to peer symmetric messaging.

In another embodiment 30 the method of 25 provides that the message may be sent from the first process to the second process and or from the second process to the first process and is not a remote procedure call.

In another embodiment 31 the method of 25 provides that there is no dependency on the processing behavior or timing on either the sending first process side or the receiving destination second process side.

In another embodiment 32 the method of 25 provides that the message does not have a dependency on a processing behavior on either the sending first process side or on the destination receiving second process side.

In another embodiment 33 the method of 1 provides that for each message sent by a sender process a response back to the sender process from the destination receiving process is optional and non receipt of a response does not degrade operation in the first sending process.

In another embodiment 34 the method of 1 provides that in messaging a message is sent a acknowledgement of delivery may be returned and a response may or may not be returned.

In another embodiment 35 the invention provides a method for sending an interprocess communication from a sending process to an external second process the method comprising generating an encoded inter process message data set the inter process message data set including an encoded message interface file and an encoded message implementation file the generation of the message includes marshalling of message elements into a message to be sent and sending the encoded message from the sending first process to the destination second process the sending first process not being required to wait for a response from the destination second process.

In another embodiment 36 the invention provides a network device adapted for coupling to a network including a plurality of other network devices by a communications link the network device comprising a processor and random access memory coupled to the processor the processor for executing computer program code instructions a persistent non volatile memory for storing configuration information and the computer program code instructions a communications port for sending and receiving messages with other ones of the other network devices and means for sending and receiving messages.

Exemplary System for Messaging Gathering Status and Statistics and or Non Persistent or Persistent Setting of Information Across Process Boundaries

The above described message structure and messaging method and procedures may be used as an underlying layer to message between processes generally this messaging may optionally but advantageously also be utilized to communicate send and or receive status statistics and other information or data between processes as well as to set or reset status data information conditions or memory in at least a non persistent fashion.

Although the methods and procedures described herein are not limited to any particular system or hardware configuration optionally but advantageously the mobility system See for example may be used to retrieve statistics status and or other information across process boundaries by for example using an automated object definition scheme as described above. This scheme may advantageously be XML based or non XML based. This allows statistical STATistical status STATus and or other information generally referred to herein as STAT to be specified in terms of objects using XML or other object oriented or definitional languages. Application Program Interfaces APIs and implementation files may be generated in by way of example but not by way of limitation the C programming language. In a non limiting embodiment the system is independent of hardware operating system and interprocess transport layer or scheme.

It is desirable to simplify STAT or per STAT information massaging or acquisition program code as much as possible from the developer hiding or at least relieving the developer from any need to understand the complexity in any STAT infrastructure. This simplification or higher level abstraction may generally result in faster and less expensive code development and more robust code.

It may be appreciated that many multitasking systems do not have a systematic way in which to obtain send retrieve or otherwise exchange or transfer statistical status or other information or data between processes. This being the case each software or code developer tends to define his her own way in which to retrieve and or send this information. It is desirable to provide a scheme in which to not only define this information in a generic way but also to automatically generate interfaces such as for example Application Programming Interfaces APIs and implementation code and any ancillary interface information which developers can use to easily obtain send transfer and or retrieve such information or data. Among its advantages such an approach saves development time and increases code and process stability.

This approach also advantageously allows statistical and status information to be specified in terms of objects using a higher level and more intuitive language such as the exemplary XML language. APIs may for example be generated in the C programming language or other implementation languages. Furthermore the approach is advantageously independent of hardware operating system and interprocess transport schemes.

An embodiment of the overall design of the architecture structure method and procedure for collecting or retrieving statistics and status STAT and other information in a multi process environment is now described. In particular the invention provides a means and mechanism for STAT information to be passed across process boundaries. This description includes a high level description of the transport mechanism used to transfer STAT information between processes as well as detailed descriptions of software Application Program Interfaces APIs that may be used by developers.

The invention provides a mechanism for communicating the STAT information across process boundaries so that the STAT information that may be resident in the first process may be obtained and utilized in the second process or vice versa.

It will be appreciated in light of the description provided herein that the APIs are provided by way of example and not by way of limitations and that different and other APIs may be developed and used in accordance with the invention. The description includes the software architecture and the APIs provided to or for applications. The applications may for example include but are not limited to applications on network switches operating under a network based system.

With reference to a high level view of the information retrieval or STAT model may include two components an information producer such as a status or statistical STAT information producer and an information consumer such as a status or statistical STAT information consumer . The STAT consumer would typically reside inside the a first process e.g. Process A such as for example in a device configuration CFG process while the producer may typically reside in a second process e.g. Process B which may for example be in one non limiting embodiment a network process that is somehow associated with the exemplary device process. In one non limiting embodiment of the invention wherein the two processes are processes within a network switch the configuration process is the process responsible for configuring settings or parameter of the switch and the network process is responsible for providing one or more parameters or status information items.

It may be appreciated however that the producer and consumer could simultaneously exist or reside in other places as well for example the first process could be a STAT consumer and another external process could be a producer of STAT information . Furthermore the invention is not limited to any particular environment such as a network environment or to any particular process or processes within a particular network device such as a network switch device.

In the exemplary embodiment of the information consumer in a first process is a STAT consumer in an exemplary configuration process generates a status or statistical information e.g. STAT request and sends the request to a second process which in this example is a network process wherein it may be received by the STAT producer optionally via a dispatcher. The second or STAT producer process then takes up the request and generates a response that it sends back to the first STAT consumer in the first or configuration process optionally via a dispatcher. In one embodiment a STAT dispatcher receives a STAT message decodes the message based on the received message type and then provides and optionally executes the appropriate callback function.

In one non limiting embodiment the design process involves three basic steps 1 Define STAT messages in a high level descriptive or programming language such as in the XML language 2 Run the high level descriptive language through an appropriate compiler such as XML language through an XML compiler to generate per STAT message Application Program Interfaces APIs and 3 Use these APIs to fetch or otherwise obtain the STAT information needed by one process from another process.

Exemplary STAT Message formats are now described. In one non limiting embodiment the STAT messages may be considered as a special class of the generic network type inter process messages as described herein before. In one embodiment STAT messages may contain a STAT header keys and one or more records however some of these may be absent or null. In embodiments that utilize an implementation or header file the header or implementation may be required in the request and in the response to that request but the other elements are optional including for example the keys which may be absent or null. shows an exemplary structure of a STAT request and shows an exemplary structure of a STAT response.

An exemplary embodiment of a STAT header or interface description for the STAT request e.g. STAT REQUEST and STAT response e.g. STAT RESPONSE are illustrated in . It may include a plurality of fields or appropriate size such as six 4 byte fields in one none limiting embodiment. The length field indicates the total size or number of elements e.g. number of octets in the message not including the STAT header. The sequence number seqnum field indicates an ever increasing message sequence number. Other or different numbering schemes may alternatively be used. The number of records num rec field indicates the total number of records included in the message but does not include keys. The flags field uses a zero bit bit to indicate exact or next bit exact next where if bit 0 then a Get Exact operation is indicated and if bit 1 a Get Next operation is indicated and a one bit bit to indicate first or not first bit first where if bit 1 a first operation is indicated and if bit 0 a not first operation is indicated. The result field indicates a returned result from operation and is typically only used in response message. The last record lastrec field indicates an Offset to the last record in the message and is counted as the number of bytes from the start of the message body where in at least one non limiting embodiment the message body starts immediately after the message header.

The record and keys use the generic inventive message format described relative to the general messaging described herein before relative to marshalling and shown in . The structure in also shows the format of a general message type even when that general message is not requesting or communicating status or statistics. Some fields such as for example the key field may be null field however for a generalized message. The STAT type messages may generally provide and utilize the key element as set forth in the DTD for the STAT message type in Table 9. The key element includes reference information on the process on the other side for the STAT message to return and the returned response stat message includes a similar key or reference information for use by the receiver of the response. When a general message does not need to reference or have information returned the key is not needed. The record and key may include a variable length message type e.g. msg type field that indicates a len string defining the type of generic message a four byte number of parameters num par field identifying the number of parameters in the record key and a parameters param field that indicates the parameters encoded with parameter identifier ID parameter type parameter length len and parameter value. A return status code is or may optionally but advantageously be sent in the STAT response message as part of a STAT operation.

In one non limiting embodiment messages are advantageously defined in XML however other languages may be used to define or specify messages. A message incorporating a new STAT element is defined as follows in Table 9 showing an exemplary DTD for a STAT message. The STAT message element provides an extension over and above the general message type described herein before in that for at least on non limiting embodiment the STAT message element comprises a feature that provides a capability for returning an information item such as for example some value statistical information or plurality of information items or some status or set of status or a combination of these from another process so that the statistical status or other information may be requested from across a process boundary without many of the negative impacts that may be incurred using conventional inter process messaging or information gathering techniques. As described above the message structure and format includes a key element that permits reference from the STAT message sender requesting the information and another key that is included with the message back from the other responding process so that the process receiving the response has a reference to match it back with either the requested information or with the requesting process. Comparison between the general MESSAGE and the STAT MESSAGE are apparent from a comparison of the exemplary DTD descriptions in Table 1 and Table 9.

The STAT type message is a more complex and complicated message type than the generalized message at least in part because of the need have information returned from the destination process back to the originally requesting origination process. Some of these additional application program interfaces APIs and code are described in greater detail herein below. One of the optional features that may advantageously be included with the STAT type message is an indicator parameter flag field pointer or the like having at least two possible states that indicates whether the message should be executed as a synchronous communication or message or as an asynchronous communication or message.

Several parameter types are identified and these parameter types will be understood to be exemplary and non limiting as workers in the art will appreciate in light of the description provided herein that other and different types of parameters may be added.

STAT MESSAGE generates the interfaces for statistics which automatically create both the request and the response prototypes and provides either one of the synchronous and asynchronous prototypes. Later in this description and in the related applications is described a NPS MESSAGE type will be described which generates the interfaces for persistent or non persistent set of information or state type operations and which automatically creates both request and response prototypes with no user data returned in the response. The set operation is non persistent in the target process and may be made persistent in the target process by directing the receiving process to save or store the state that is communicated by the NPS message.

Parameter type SEQUENCE is a special and optional parameter type that is used to define a list of elements within a message. These list elements may also or alternatively be defined to be messages. This allows embedding one or more levels of messages within a message. This functionality may generally be useful for more complex data structures where one or more levels of lists or other data structures are attached to a main structure. General STAT APIs used to support sequences are described herein elsewhere.

A sample STAT catalog and message would look something like the example in Table 10. The name identifies the attribute via a user defined string. The type identifies the type of the attribute integer string etc . The key indicates whether the attribute is to be sent in the request message. Typically the parameters which uniquely identify the record define the key. However it is also possible to add other parameters to the key which may be used as filters in the request.

It may be appreciated that a message catalog my include general messages information passing status and or statistics STAT type messages as well as persistent or non persistent set NPS messages in the same catalog. Alternatively different catalogs may be used for different message types.

Computer program software code for the implantation and interface files where required is generated after the STAT messages have been fully defined in the defining language such as in the XML language by running through a compiler for example through an XML compiler when the defining language is XML which produces an output code in the target output language such as C code. An interface file such as the header or h file may also be generated as for the general message file described herein before above. It will be apparent to those workers in the art in light of the description provided herein that although aspects of the invention are described relative to XML as the high level defining language and to a C language file as the compiler output language the invention is not limited to these particular exemplary languages. By way of example and as described relative to general messages but not limitation the defining language may be XML or any other language and the compiled output language may be C C or any other language and that the defining language may generally be used with an appropriate compiler to generate any of the possible output codes.

While it will be appreciated that any languages may be used the inventive system method technique and computer programs and computer program product for general messages information or STAT messages and for interprocess persistent or non persistent set messages advantages do arise from using XML as a high level intuitive language and outputting to C C or one of the related languages which are commonly used for contemporary programming features. This choice of languages may therefore also be considered a novel and non obvious aspect of at least some embodiments of the invention.

There are several functions that may advantageously be automatically generated for each STAT message defined. These functions comprise the Application program Interface API which developers may then use when implementing STAT gathering or retrieval. shows by way of example some of the functions that are automatically generated by the compiler and what the STAT message transformation or conversion tool in some embodiments the STAT message compiler . Some functions are internal functions such as marshall message unmarshall message unmarshall register marshall function and dispatcher functions for example in some exemplary embodiments these functions may include marshall message  unmarshall message  unmarshall  register mfunc  and dispatcher  that may be used by the message producer and consumer and the rest of the functions are used by the STAT message consumer for example stat get  stat nextrec  and stat nextkey  and the STAT message producer e.g. stat register  stat alloc  stat dealloc  and stat insert  .

As illustrated in some of the auto generated APIs are per message APIs and some are per catalog auto generated APIs identified in the Internal functions block by the per message indicator suffix and the per catalog indicatior suffix respectively. A set of APIs internal consumer and producer are automatically generated for each message and for each catalog. The different classes of APIs and members of the classes are described in greater detail below.

In terms of transport mechanism STAT information will be requested by a STAT consumer and returned by a STAT producer. The STAT consumer sends a STAT request message and the STAT Producer returns a STAT response message. These messages will be organized or marshaled using the marshalling scheme described herein before. The invention is transport mechanism independent and any know or to be developed transport mechanism may be utilized.

In at least one non limiting embodiment of the invention the STAT model includes application program interfaces. General APIs are used by all STAT provider and STAT consumer callback functions and may be common across all message types. They are not typically generated on a per message or per catalog basis as are the per message and per catalog message specific APIs described below.

Several auto generated APIs for the STAT messaging are now described. Autogenerated APIs are typically generated on a per STAT MESSAGE basis. For example there is an entire set or plurality of APIs generated that are specific to the given STAT MESSAGE. This differs from the generalized APIs which are global and shared across all message types. For each of the below described Autogenerated APIs the message is the message name defined in the XML message definitions. A stat  structure is generated for the returned records in the format in Table 20. This stat  structure is provided for the application programmer to conveniently fill in message parameters in the STAT callback function.

Table 21 through Table 28 provide exemplary descriptions of several autogenerated STAT APIs as well as an exemplary Handler.

The autogenerated API stat nextrec  in Table 21 is used by the STAT Consumer to retrieve the next record in a STAT response. The stat handle keeps track of the next record in the response message.

The autogenerated API stat next key stat nextkey  in Table 22 is used by the STAT consumer to retrieve the key to be used for the next get request.

The autogenerated API stat get  in Table 23 is used to send a STAT request message from STAT Consumer to STAT Producer. In the synchronous case this function blocks and waits for a STAT response message from the STAT Producer.

The autogenerated API stat register  in Table 24 is used by the STAT Producer to register a Producer Handler function for a given message. Whenever a STAT request is received for this message type this handler is called.

The autogenerated API stat alloc  in Table 25 allocates memory for the record of the given message type.

The autogenerated API stat dealloc  in Table 26 frees memory for the record of the given message type.

The autogenerated API stat insert  in Table 27 is used by the STAT Producer to insert a record into a STAT Response message.

An exemplary Producer Handler in Table 28 is not an autogenerated API but the registered callback function that is used to process a given type of STAT message.

Appendix A sets forth some examples associated with statistics status and other information STAT messaging. The first example is of the STAT Get Exact operation in which at most one record is retrieved from the STAT Producer. The second example shows a STAT Get Next operation in which zero or more records are retrieved.

Exemplary Embodiment of System and Method for Persistent and Non Persistent Setting of Information Across Process Boundaries

Limitations of conventional message structures and messaging schemes have already been described relative to interprocess messaging and messaging that retrieves status statistics and other information across process boundaries.

In analogous manner many conventional multi process multitasking systems do not have a systematic way in which to define and set information including persistently or non persistently set information between processes. As such each developer conventionally tends to define his her own way in which to set this information across and between processes. It is therefore desirable to provide a scheme in which to not only define this information in a more general or generic way but also to automatically generate Application Programming Interfaces APIs including implementation code and any interfaces which developers can use to easily transfer and set information or data between and across process boundaries. As with other of the embodiments of the invention these features save development time and increases code stability.

Therefore advantageously a system or device such as but not limited to the mobility system See may also be used to set information across process boundaries using an automated object definition scheme. One non limiting embodiment of this scheme may be XML based. This allows persistent or non persistent information to be specified in terms of objects using XML. APIs may be generated in by way of example but not by way of limitation the C programming language. In a non limiting embodiment the system is independent of hardware operating system and interprocess transport schemes. The use of XML allows information to be persistently or non persistent stored or used to be specified in terms of objects using XML and APIs are generated in the C language or other lower level programming language. These exemplary implementations are independent of hardware operating system and interprocess transport schemes.

An embodiment of the overall design of the architecture structure method and procedure for a new scheme to perform a Non Persistent Set NPS of information in a multi process environment is now described. This scheme may also be used to persistently set information across process boundaries by adding an additional store or save in the target process so that he non persistently set information becomes persistently set. In particular the invention provides a means and mechanism for the setting persistently or non persistently of information across process boundaries. This description includes an exemplary high level description of the transport mechanism used to transfer NPS information between processes as well as detailed software APIs to be used by developers.

In one embodiment much of the computer program code involved in setting NPS information will reside in an external process. The invention provides a mechanism for passing or communicating the information or state to be set across process boundaries so that the information or state to be set resident in one first process may be obtained and utilized in another second process external to the first process.

It will be appreciated in light of the description provided herein that the APIs are provided by way of example and not by way of limitations and that different and other APIs may be developed and used in accordance with the invention. The description includes the software architecture and the APIs provided to or for applications. The applications may for example include but are not limited to applications on the MX series of network switches operating under a network based system. Systems and switches such as these are made by Trapeze Networks of Pleasanton Calif.

With reference to a high level view of a messaging model applied to the Non Persistent Set operation may include two components a NPS producer and a NPS consumer. An additional save or storage of the information at the NPS consumer may persistently save the non persistently set information at the information consumer making that consumer a persistently set PS consumer.

The NPS message producer would typically reside inside one process for example in a network device configuration first process while the NPS message consumer may reside in a different second process such as for example in a second device or network process. Note that the consumer and producer processes may be viewed as being swapped or exchanged for the NPS model as compared to the STAT model processes. In the STAT model a first process is requesting information from a second process and in the NPS model a first process is sending an information or command or a set of information or command s to another process. Stated differently relative to our earlier example in at least one embodiment of the STAT model the STAT information consumer is in the configuration process and the STAT information producer is in the network process while in the NPS model the NPS consumer is in the network process and the NPS producer is in the configuration process. These configuration and network processes are merely convenient examples as it will be understood that the two different processes for which the inter process messaging is occurring can be any processes.

It may be noted however that the producer and consumer could simultaneously exist or reside in other places as well for example the network process could be a NPS producer and another external process could be a consumer of NPS information . Furthermore the invention is not limited to any particular environment such as a network environment or to any particular process or processes within a particular network device such as a network switch device.

In the exemplary embodiment of the NPS producer in the configuration CFG process generates a NPS request and sends the request to the network process and may be received by the NPS consumer via an optional dispatcher . The NPS consumer then takes up the request and generates a response that it sends back to the NPS producer in the configuration process optionally via a dispatcher.

In one non limiting embodiment the NPS design process involves three basic steps 1 define NPS messages in a high level descriptive or programming language such as in the XML language 2 run the high level descriptive language through an appropriate message transformation or modification tool such as an NPS message compiler such as XML language high level descriptive language through an XML compiler to generate per NPS message Application Program Interfaces APIs and 3 use these APIs to set the NPS information in one process from another process.

The Non Persistent Set NPS messages are a special class of the generic inventive message described above and use substantially the same message format as the STAT information messages described herein elsewhere with reference to and and are not repeated here. These NPS message formats are shown in and . In fact in at least one embodiment the NPS message format is the same as the STAT message format. Although the NPS message format may be the same as the STAT format the information contained in the message may differ.

One difference in the NPS implementation as compared to the STAT implementation is that all NPS message parameters NPS PARAMETERs may inherently be defined as key parameters and are therefore sent as keys in the NPS request message. Furthermore there are no or at least need not be any records returned in the NPS response as compared to the STAT response message only an optionally but advantageously returned status code. The status code may for example merely provide an indication that the message was received or completed successfully or some other indication of success or failure or error. There can be zero one or a plurality of NPS parameters NPS PARAMETERs . As with the STAT message a return status code is or may optionally but advantageously be sent in an NPS response message as part of a NPS operation.

A exemplary new NPS message element is defined as in Table 29 showing an exemplary DTD for an NPS message. The NPS message element differs from a STAT message in that different APIs are generated and the results are different. Some of these differences are apparent from the different DTD description of an NPS Message while other differences will be apparent from the different APIs and code generated when processed through the NPS message transformation or conversion tool such as for example an NPS message compiler.

An NPS message NPS MESSAGE generates the interfaces for persistent or non persistent set operations and automatically creates both request and response prototypes with no user data returned in the response.

A non limiting embodiment of an exemplary sample catalog and message may have the form illustrated in Table 30. The name identifies the attribute via a user defined string. The type identifies the type of the attribute integer string etc . Several parameter types are identified and these types will be understood to be exemplary and non limiting as workers in the art will appreciate in light of the description provided herein that other and different types of parameters may be added.

Code for execution is generated after the NPS message has been fully defined in the defining language such as in a DTD file using the XML language by running through a transformation tool or converter such as a compiler for example through an XML compiler when the defining language is XML which produces an output code in the target output language such as C language code. It will be apparent to those workers in the art in light of the description provided herein that although aspects of the invention are described relative to XML as the high level defining language and to C as the compiler output language the invention is not limited to these particular languages. As for the general message or information message any programming language may be used and the transformed or compiled output interface and implementations files may be used though definition in the XML language and implementation in the C language may be preferred.

There are several functions that may automatically generated for each NPS message defined. These functions comprise the Application program Interface API which developers may then use when implementing NPS setting. shows by way of example some of the functions that may automatically be generated by the compiler. Some functions are internal functions e.g. a marshal message marshall message  function an unmarshall message unmarshall message  function an unmarshall unmarshall  function a register catalog register mfunc  function and optional dispatcher dispatcher  function which are typically only used by the NPS engine and the rest of the functions are used by the NPS message consumer e.g. NPS register nps register  and the NPS message producer e.g. nps set  .

In terms of transport mechanism NPS information will be requested by a NPS producer process and returned by a NPS consumer process. The NPS producer sends a request message and the NPS consumer optionally returns a response message. These messages will be marshaled using the marshalling scheme described herein before. The invention is transport mechanism independent.

In at least one non limiting embodiment of the invention the NPS messaging model includes application program interfaces. General APIs are used by all NPS producer and NPS consumer callback functions when present and are common across all message types. They are not typically generated on a per message or per catalog basis as are the per message and per catalog message specific APIs described below.

The NPS general API NPS set nps set  in Table 34 is used to send an NPS request message from NPS Producer to NPS Consumer.

The NPS general API NPS register nps register  in Table 35 is used by the NPS Consumer to register a Consumer Handler function for a given message.

The NPS general API NPS delete error string nps delete errstr in Table 33 is used by the NPS Consumer to delete an error string that was returned from NPS set nps set  .

Several Autogenerated APIs for the NPS messaging are now described. For each of the below described Autogenerated APIs is the message name defined in the XML message definitions. A nps  structure is generated for the returned records in the format in Table 34. This nps  structure is provided for the application programmer to conveniently acquire message parameters in the NPS callback function.

The NPS general API nps set  in Table 34 is used to send an NPS request message from NPS Producer to NPS Consumer.

The NPS general API nps register  in Table 35 is used by the NPS Consumer to register a Consumer Handler function for a given message.

The NPS Consumer Handler and not an API in Table 36 is the registered callback function that is used to process a given type of NPS message.

Appendix B sets forth some examples associated with information setting messages such as persistent or non persistent setting NPS messaging. The example is of the NPS Set Memory Leak example operation.

As used herein the term embodiment means an embodiment that serves to illustrate by way of example but not limitation.

It will be appreciated to those skilled in the art that the preceding examples and preferred embodiments are exemplary and not limiting to the scope of the present invention. It is intended that all permutations enhancements equivalents and improvements thereto that are apparent to those skilled in the art upon a reading of the specification and a study of the drawings are included within the true spirit and scope of the present invention.

