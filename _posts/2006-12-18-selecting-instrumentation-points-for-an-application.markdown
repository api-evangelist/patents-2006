---

title: Selecting instrumentation points for an application
abstract: Instrumentation points are selected for an application by running the application with comprehensive instrumentation of its components in a development mode. The application can be run by a human operator and/or load simulator which provides requests to the application. The instrumented components are monitored as the application runs. A subset of the components is selected based on criteria such as an order in which the instrumented components are invoked, whether resource utilization, such as consumption of processor cycles, exceeds a threshold, or a frequency with which components are called or call other components, and only that subset is instrumented in a production mode of the application. In one approach, the subset includes components which are invoked when traffic to/from the application matches a pattern provided by an interaction model. As a result, relevant instrumentation points can be identified.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009680&OS=09009680&RS=09009680
owner: CA, Inc.
number: 09009680
owner_city: New York
owner_country: US
publication_date: 20061218
---
This application is related to commonly assigned U.S. patent application Ser. No. 11 565 490 filed Nov. 30 2006 issued as U.S. Pat. No. 7 805 510 on Sep. 28 2010 titled Hierarchy For Characterizing Interactions With An Application commonly assigned U.S. patent application Ser. No. 11 566 454 filed Dec. 4 2006 and published as US 2007 0266149 on Nov. 15 2007 titled Integrating Traffic Monitoring Data And Application Runtime Data and commonly assigned U.S. patent application Ser. No. 11 612 063 filed Dec. 18 2006 and published as US 2008 0148242 on Jun. 19 2008 titled Optimizing An Interaction Model For An Application each of which is incorporated herein by reference.

The growing presence of the Internet as well as other computer networks such as intranets and extranets has brought many new applications in e commerce education and other areas. Organizations increasingly rely on such applications to carry out their business or other objectives and devote considerable resources to ensuring that the applications perform as expected. To this end various application management techniques have been developed.

One approach involves monitoring an application by instrumenting individual software components in the application and collecting data regarding the instrumented components that are invoked when the application runs. Instrumentation can involve using agents that essentially live in the system being monitored. For example instrumentation allows an execution flow e.g. thread or process to be traced to identify each component that is invoked as well as obtain runtime data such as the execution time of each component. However determining which components to instrument can be problematic due to the difficulty in selecting components which can provide relevant data and the need to avoid excessive instrumentation overhead costs.

A method and system are provided for selecting instrumentation points and optimizing an interaction model which characterizes interactions with an application.

In one embodiment a method for selecting instrumentation points for an application includes running an application having a first set of instrumented components monitoring the instrumented components during the running and based on the monitoring selecting a subset of components of the first set of instrumented components for which active instrumentation is to be maintained. That is a filtering process can be performed to reduce the number of components which are instrumented by monitoring the behavior of the components when the application runs. The application can run in a development mode where the overhead caused by instrumenting a large set of components is not problematic. Once a number of relevant components are identified the application can be run in a production mode gathering data from only the relevant components. The filtering process can occur in successive iterations as well and can be based on static analysis in addition to dynamic analysis performed during the running of the application.

The application can be run by a human operator and or load simulator interacting with the application. In one approach the human operator and or load simulator provide requests to the application which are associated with an interaction model e.g. a model or template which characterizes interactions with the application. Such a model can be useful in understanding the way a client interacts with the application. Various criteria can be used for selecting instrumented components which are relevant to the interaction model. For example the instrumented components can be selected by evaluating components which are invoked by requests which correspond to at least one pattern associated with an interaction model or other interactions which are part of an interaction model. The selection can be made based on an order in which the instrumented components are invoked so that for example a first invoked or last invoked component is selected. The selection can also be made based on whether resource utilization such as consumption of processor cycles exceeds a threshold. Various other factors including a combination of factors can be used as well.

In another embodiment a method for selecting instrumentation points for an application includes running an application in a development mode providing a report indicating components of the application which were invoked during the running and processing the report for selecting one or more of the components to be instrumented in a production mode.

A method and system are provided for optimizing the selection of instrumentation points and optimizing an interaction model for an application.

One or more human operators and or load generators can interact with the application via the client such as by submitting requests to the application. For example the human operator can be a trained operator who provides specific requests to the application to exercise the application in a test or development mode that is by entering various commands which are likely to be entered by other users when the application is placed in a production mode. Further the commands can be chosen to be significant from the perspective of an interaction model which involves the application. For instance for an application involving a business which includes an e commerce web site the operator may enter commands to login to the web site shop add to cart checkout track orders contact customer service and so forth. An interaction model can assist in understanding the demands which are made of an application so that computing and network resources can be efficiently deployed. Further an interaction model can assist in trouble shooting problems with an application and in measuring application performance.

Alternatively or additionally a load generator may be programmed to interact with the application via the client such as by entering commands which are significant from the perspective of an interaction model. The load generator and client can be combined on one computing device or maintained separately for instance. Further a number of different operators and or load generators may be used to interact with the application. In practice a number of other network components which are not shown may be used including routers gateways load balancing servers and the like.

The application includes software components which are invoked when various execution paths are invoked in response to receipt of the requests. In particular the application may respond to a request by accessing information locally and or remotely as necessary. For example the application may access a database to obtain information for responding to a request. Once a response is prepared it is communicated to the client via the network . Further instrumentation is provided for various components of the application such as servlets Java Server Pages JSPs Enterprise Java Beans EJBs Java Database Connectivity JDBC components and .NET components. Behavior of the application can be monitored by instrumenting bytecode or intermediate language IL code of the application by plugging into an exit built into the application or a network server or by any other monitoring technique. In one possible approach the application is instrumented by adding probes to the application code. The probes may measure specific pieces of information regarding the application without changing the application s business logic. A probe may be thought of as a turnstile that is tripped when a component is invoked in an execution path. As the application runs the probes send data to the agent . The agent collects the data and sends it the application monitoring system e.g. in a component data log.

More information about instrumenting bytecode can be found in U.S. Pat. No. 6 260 187 System For Modifying Object Oriented Code by Lewis K. Cirne and U.S. patent application Ser. No. 09 795 901 Adding Functionality To Existing Code At Exits filed on Feb. 28 2001 issued as U.S. Pat. No. 7 512 935 on Mar. 31 2009 each of which is incorporated herein by reference in its entirety. More information regarding monitoring an application using probes can be found in U.S. Patent App. Pub. No. 2004 0075690 published Apr. 22 2004 titled User Interface For Viewing Performance Information About Transactions by Lewis K. Cirne issued as U.S. Pat. No. 7 310 777 on Dec. 18 2007 and incorporated herein by reference.

The instrumentation allows data to be gathered when the components are invoked during execution of the application. For example the component data can include information such as average response time errors per interval and invocations per interval. Further the component data can indicate a utilization of resources by the components e.g. CPU cycles execution time variance in execution times component size how frequently a component is called by other components how frequently a component calls other components how many different components call a given component whether a component is a frontier component which can include components that are invoked first or last in servicing a request or which call an application programming interface API how many instances of a component exist simultaneously and whether a component has a high complexity a component has high complexity e.g. when it is an entry point into another component it makes other method calls so it doesn t just do all the work by itself and or it is above a certain length threshold .

The component data can be obtained for a single request and or aggregated over many requests. Data from the instrumented components in the form of an application component data log is provided to the application monitoring system . Additionally a request log may be used to maintain a record of the requests which are received by the application. The requests can be indexed to the component data in the log.

The application monitoring system includes a number of facilities which can be used to process the information received from the agent . For example a dynamic analysis module analyzes the component data which is generated dynamically e.g. when the application runs. The dynamic analysis module can interact with a component selection criteria module and a request pattern matching module . The component selection criteria module can use a number of criteria which are applied to the component data. These criteria can include e.g. one or more threshold values relating to utilization of resources by the components execution time variance in execution times component size how frequently a component is called by other components how frequently a component calls other components how many different components call a given component whether a component is a frontier component how many instances of a component exist simultaneously and whether a component has a high complexity.

The request pattern matching module operates on the request log to determine whether the requests correspond to at least one pattern of an interaction model for the application. For example an interaction model for an application of an e commerce web site can include the steps of login to web site shop add to cart checkout track orders contact customer service and so forth. Further a URL or URL component may be associated with each step. Thus in one possible embodiment a request includes a a request for a component of a web page b a request for a web page or c a request for a set of web pages. The request can be parsed from the request log to obtain components of the request. The components in turn are analyzed and compared to the interaction model patterns. The analysis can be done in real time when a request is received by the application or at later time based on a log of requests for instance. If there is a correspondence it is concluded that the client is invoking one or more steps of the interaction model which are defined by the patterns.

A static analysis module analyzes components without running the application to identify components which are known a priori to be of interest. For example a component may be analyzed statically based on its type as well as based on a name of a class or method function with which the component is associated a direct and or indirect super class or a directly and or indirectly implemented interface. This is particularly true for applications that are developed using a set of best practices such as those provided by J2EE or .NET. Regarding component type servlets Java Server Pages JSPs Enterprise Java Beans EJBs Java Database Connectivity components and Microsoft .NET components are often frontier components and therefore worthy of instrumenting. JSPs provide a way to do scripting at the front end of a web server while EJBs are business processing components that often do interesting work. The static analysis module operates on the static application code and does not require access to the component data log. The static analysis can be achieved e.g. using appropriate software which parses and analyzes application code to detect specific component types classes and or methods.

An output device interface which can include an on screen interface for example can be used to provide reports and other information to an operator based on an output from the application monitoring system as well to receive commands from the operator such as for configuring the facilities of the application monitoring system .

Portable storage can operate with a portable non volatile storage medium to input and output data and code to and from the computer system. In one embodiment the system software for implementing the present invention is stored on such a portable medium and is input to the computer system via the portable storage . Peripheral device s may include any type of computer support device such as an input output interface to add functionality to the computer system. For example peripheral device s may include a network interface for connecting the computer system to a network a modem a router etc.

User input device s provides a portion of a user interface and may include e.g. a pointing device such as a mouse a trackball stylus or cursor direction keys. In order to display textual and graphical information the computer system includes graphics subsystem and an output display such as a cathode ray tube CRT display liquid crystal display LCD or other suitable display device. Graphics subsystem receives textual and graphical information and processes the information for output to output display . Additionally the computer system includes output devices such as speakers printers network interfaces monitors etc.

The components contained in the computer system are those typically found in computer systems suitable for use with the present invention and are intended to represent a broad category of such computer components that are well known in the art. Thus the computer system can be a personal computer hand held computing device telephone mobile computing device workstation server minicomputer mainframe computer or any other computing device. The computer system can also include different bus configurations networked platforms multi processor platforms etc. Various operating systems can be used as well including Unix Linux Windows Macintosh OS Palm OS and other suitable operating systems.

In particular as mentioned the criterion can include e.g. one or more threshold values relating to utilization of resources by the components execution time variance in execution times component size how frequently a component is called by other components how frequently a component calls other components how many different components call a given component whether a component is a frontier component how many instances of a component exist simultaneously and whether a component has a high complexity. The component data in the log can be processed based on these criteria. Moreover one criterion or a combination of separate criteria can be applied. For example the component log may indicate that component A has an execution time of T. A criterion may indicate that a component carries relevant information if its execution time is above a threshold TH. Thus step can include determining whether T exceeds TH. If it does component A is included in the subset as a selected component. An appropriate data structure can be used to identify components which are included in the subset. Similarly if T does not exceed TH component A can be identified as not being included in the subset or similarly as being included in a group of non selected components.

Once the subset of components is selected instrumentation is not needed for the other non selected components which are not in the subset. In one approach the instrumentation can be deactivated or removed for the non selected components step . In one embodiment instrumentation is deactivated by turning off the probes for the non selected components. In this case the probes remain in the application but are not active and do not send data to the agent. In another approach the instrumentation e.g. probes for the non selected components is removed. For instance classes which include non selected components can be re written without the instrumentation for the non selected components and re loaded. In some cases this can be done on the fly as an application is running depending on the capabilities of the virtual machine on which the application runs. In other cases the application is temporarily taken offline to modify the instrumentation.

At step the application with active instrumentation provided for only the subset of components is run e.g. in a production mode thereby allowing relevant information to be gathered while avoiding excessive instrumentation overhead.

At decision block a determination is made as to whether another iteration is desired. For instance if the process involves cycling through a different selection criterion in each iteration another iteration will be performed if there are any criterion which have not yet been applied. In another approach the decision can involve assessing the components that have already been selected. For example if the number of selected components is below a threshold or an amount of instrumentation overhead is less than a threshold an additional iteration may be performed to select additional components. If no additional iteration is desired the instrumentation for the non selected components is deactivated or removed at step and at step the application can be run with active instrumentation for all subsets of selected components. If an additional iteration is desired at decision block the application is run again at step and additional component data is gathered.

In one option the process can iteratively refine a single subset of selected components. In this case step can be performed prior to decision block so that the non selected components are deactivated or removed before each new iteration. For example a more exclusive criterion can be applied in each successive iteration. To illustrate a criterion regarding a first execution time T can be applied in one iteration while a criterion regarding a more exclusive second execution time T can be applied in a next successive iteration. Components in the subset which do not meet the more exclusive criterion can be removed in each iteration so that only the components which meet the most exclusive criterion remain in the subset after the last iteration.

The process of can be modified to provide an iterative process for selecting components of an application to be instrumented. In one possible approach step is modified to select a new set of components based on one or more criterion. For example after the first set of components is instrumented the new set of components can be a second set which can include one or more new components which are not in the first set and or one or more components which are in the first set. Further the second set can include all new components none of which is in the first set. Step is modified to refer to running the application with active instrumentation for the current set of components. This approach can provide a drill down capability in which the initial set of instrumented components can be expanded. Also a capability can be provided for adding instrumentation back to some components for which the instrumentation was previously deactivated.

In particular at step a first set of components to be instrumented is identified based on static analysis. At step a second set of components to instrument is identified based on dynamic analysis. These steps can be performed independently as mentioned. At step the first and second sets of components are instrumented in the application and at step the application is run. Note that there may be some overlap in the first and second sets as the same components identified by static analysis may also be identified by dynamic analysis.

Regarding low instrumentation overhead block this can refer in one approach to a ratio of CPU cycles consumed by instrumentation of a component to CPU cycles consumed when the instrumented component is invoked e.g. by a method call.

In one approach scores can be assigned to the components for each selection criteria and a total score indicates whether a component is selected at decision block . The different scores for the different selection criteria can have different weights as well so that relatively more important criteria are weighted more heavily. Any type of scoring scheme can be used.

Additionally components identified by static analysis block such as by component type block associated class method block associated direct or indirect super class block and or an associated directly or indirectly implemented interface block can be flagged for instrumentation step .

At step components in an application are instrumented. This can include essentially all of the components or some group of components which may provide relevant data. At step the application is run. At step requests received by the application are monitored and at decision block a determination is made as to whether the requests correspond to one or more patterns of an interaction model. In one approach the determination can be based on comparing one or more URLs in one or more requests to one or more URLs in a pattern. For example each request may be parsed to determine query cookie post URL and session type name value pairs. A typical HTTP post request which can be parsed is shown below.

An example of an HTTP parameter list derived from parsing the above request is shown below. Each parameter includes a type and name value pair.

The parameter list data can be retrieved from the request listed above. In particular the parameter list query data can be retrieved from the request line of the request the cookie data can be retrieved from the request headers the post data can be retrieved from the request body and the URL data can be retrieved from the request header and request line. A request can be processed by comparing parameters in the request to parameters in different interaction model patterns to locate a corresponding pattern. If there is no match the request is considered to be a non matching request.

If there is a correspondence between the request and an interaction model pattern at decision block the requests are not reported at step in one approach. This approach can be taken when there is a focus on identifying non matching requests. If there is no correspondence between the request and an interaction model pattern at decision block a log is provided with data from the monitored components which are invoked by the non matching requests step . In another approach the log also includes data from components which are invoked by matching requests. A separate log can be provided for data from the components which are invoked by the matching requests as well. At step the components are analyzed using one or more criterion see to determine whether significant activity is invoked in the application by the request. If the components meet the criterion at decision block the non matching requests are reported at step . One or more new patterns of an interaction model can be developed based on the reported requests at step . For example non matching requests that generate significant activity such as resource utilization in the application can be used as new patterns so that the interaction model is more closely aligned with the application activity. The process can therefore reveal significant interactions with an application which may have previously been overlooked.

If the components do not meet the criterion at decision block it is concluded that the non matching requests do not generate significant activity in the application and monitoring continues at step without reporting the non matching requests.

It is also possible to rank the matching requests based on metrics derived from components which they invoke. The matching requests can be ranked separately from or together with the non matching requests.

The determination at block can be based on one or more metrics and or criterion applied to the invoked application components. These metrics and or criterion can include those mentioned previously such as high resource utilization block high execution time block whether a component has high complexity block whether a component is frequently called by other components block whether a component makes frequent calls to other components block whether a component is frequently called by many other different components block high variance in execution time block whether a component is a frontier component such as a first invoked or last invoked component or a component which calls an API block and whether multiple instances or generally a given number of instances of a component exist simultaneously block . The metrics and or criterion can also include component type block associated class method block associated direct and or indirect super class block and associated directly and or indirectly implemented interface block . Also the determination at block can include metrics or criterion derived from the requests themselves such as the frequency with which a request is made. For instance the significance score of a request can be increased when the request is frequently made.

In one approach scores are assigned for each selection criteria and a total score indicates whether a request is selected at decision block . The different scores for the different selection criteria can have different weights as well so that relatively more important criteria are weighted more heavily. Any type of scoring scheme can be used.

The example hierarchy includes five levels although one or more levels can be used. A top level of the hierarchy is a domain level named Customer Experience. 

A next level of the hierarchy is a business process level . An example of a business process is buying a book from a web site for instance. Other example business processes for a book selling web site can include Search Books Contact Customer Service and Track Order. Another example of a business process involves employees enrolling in a benefits program in which case the business process can be named e.g. Enroll in benefits .

A next level of the hierarchy is a business transaction level . A business process can be made up of a number of business transactions. For example for the business process of buying a book from a web site the business transactions can include business transactions of logging in to the web site such as by entering a user id and password shopping on the web site such as by viewing different items for sale adding a selected item to a shopping cart and completing a checkout process such as by entering payment and shipping information.

A next level of the hierarchy is a transaction level . A business transaction can be made up of a number of individual transactions. For example the class of business transactions named Add To Cart may include classes of transactions named confirm selection and display items in cart. In one approach each transaction is associated with a web page. For example a first web page may ask the user to confirm a selection and a second web page may display the items in the cart. In another example a checkout business transaction may include transactions for confirming a purchase entering payment information and entering shipping information.

A bottom level of the hierarchy is a transaction component level . A transaction can be made up of one or more transaction components such as components of a web page. These components can include e.g. images e.g. .gif files cascading style sheets e.g. .css files JavaScript code components e.g. .js files and so forth.

The interaction model hierarchy can be expressed in terms of a rules engine which includes patterns. The rules engine can be used by the application monitoring system for instance for comparing the patterns to requests which are received by the application to determine whether they are matching or non matching requests. It is also possible for another entity such as a traffic monitoring system which monitors traffic between the application and a client to implement the rules engine and to provide matching non matching status information to the application monitoring system.

Further related information regarding a hierarchy can be found in U.S. patent application publication no. 2003 0191989 to P. O Sullivan published Oct. 9 2003 titled Methods systems and computer program products for triggered data collection and correlation of status and or state in distributed data processing systems and incorporated herein by reference.

The rules engine can define how to identify a transaction component based on the characteristics of a request response pair. In one approach the request can be analyzed by the rules engine to determine whether the request corresponds to a level of the hierarchy. For example some levels of the hierarchy can be associated with a sequence of multiple requests e.g. the domain level business process levels business transaction level and the transaction level while other levels can be associated with a single request e.g. the transaction component level . The analysis can be done in real time when a request is received by the application or at later time based on a log of requests for instance.

In one approach the application monitoring system implements the rules engine in the request pattern matching module . The application monitoring system obtains a request and uses the set of rules patterns defined in the rules engine to determine whether the request corresponds to one or more transaction components transactions business transactions business process and or domains. In particular an in memory rule engine can operate as follows 

1. For every component invocation obtain characteristics of the associated request such as a URL host name and port b URL parameters c HTTP post parameters d cookie parameters e session manager parameters and others.

2. Given these request characteristics determine the business transaction and business process to which the request belongs.

3. Identify the transaction components using a sorted set of regular expressions one regular expression for each possible transaction component. For each request start matching the request against this set of regular expressions one by one. The first match identifies the transaction component to which the request corresponds.

4. Identify the transaction business transaction business process and domain using an in memory tree. Create a tree of the hierarchy including the transaction component level the transaction level the business transaction level the business process level and the domain level. Once the transaction component is known for a request the tree can be traversed to determine the other levels of the hierarchy to which the request corresponds.

The functionality described herein may be implemented using one or more processor readable storage devices having processor readable code embodied thereon for programming one or more processors. The processor readable storage devices can include computer readable media such as volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer. Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

The foregoing detailed description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto.

