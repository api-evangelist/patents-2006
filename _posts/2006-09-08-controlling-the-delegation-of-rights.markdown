---

title: Controlling the delegation of rights
abstract: The delegation of rights may be controlled in a number of manners. In an example implementation, a delegation authority assertion is formulated with a delegator principle, a delegatee principal, a verb phrase, a resource, and a delagation-directive verb. In another example implementation, a delegation mechanism involving an assertor, a first principal, and a second principal enables a delegation to be specifically controlled. In yet another example implementation, a chained delegation mechanism enables explicit control of a permitted transitive chaining depth.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08201215&OS=08201215&RS=08201215
owner: Microsoft Corporation
number: 08201215
owner_city: Redmond
owner_country: US
publication_date: 20060908
---
Computers and other electronic devices are pervasive in the professional and personal lives of people. In professional settings people exchange and share confidential information during project collaborations. In personal settings people engage in electronic commerce and the transmission of private information. In these and many other instances electronic security is deemed to be important.

Electronic security paradigms can keep professional information confidential and personal information private. Electronic security paradigms may involve some level of encryption and or protection against malware such as viruses worms and spyware. Both encryption of information and protection from malware have historically received significant attention especially in the last few years.

However controlling access to information is an equally important aspect of securing the safety of electronic information. This is particularly true for scenarios in which benefits are derived from the sharing and or transferring of electronic information. In such scenarios certain people are to be granted access while others are to be excluded.

Access control has been a common feature of shared computers and application servers since the early time shared systems. There are a number of different approaches that have been used to control access to information. They share a common foundation in combining authentication of the entity requesting access to some resource with a mechanism of authorizing the allowed access. Authentication mechanisms include passwords Kerberos and x.509 certificates. Their purpose is to allow a resource controlling entity to positively identify the requesting entity or information about the entity that it requires.

Authorization examples include access control lists ACLs and policy based mechanisms such as the eXtensible Access Control Markup Language XACML or the PrivilEge and Role Management Infrastructure PERMIS . These mechanisms define what entities may access a given resource such as files in a file system hardware devices database information and so forth. They perform this authorization by providing a mapping between authenticated information about a requestor and the allowed access to a resource.

As computer systems have become more universally connected over large networks such as the Internet these mechanisms have proven to be somewhat limited and inflexible in dealing with evolving access control requirements. Systems of geographically dispersed users and computer resources including those that span multiple administrative domains in particular present a number of challenges that are poorly addressed by currently deployed technology.

The delegation of rights may be controlled in a number of manners. In an example implementation a delegation authority assertion is formulated with a delegator principal a delegatee principal a verb phrase a resource and a delegation directive verb. In another example implementation a delegation mechanism involving an assertor a first principal and a second principal enables a delegation to be specifically controlled. In yet another example implementation a chained delegation mechanism enables explicit control of a permitted transitive chaining depth.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure API arrangement protocol etc. implementations are described herein.

In a described implementation security scheme can be overlaid and or integrated with one or more devices which can be comprised of hardware software firmware some combination thereof and so forth. As illustrated d devices with d being some integer are interconnected over one or more networks . More specifically device device device . . . device are capable of communicating over network .

Each device may be any device that is capable of implementing at least a part of security scheme . Examples of such devices include but are not limited to computers e.g. a client computer a server computer a personal computer a workstation a desktop a laptop a palm top etc. game machines e.g. a console a portable game device etc. set top boxes televisions consumer electronics e.g. DVD player recorders camcorders digital video recorders DVRs etc. personal digital assistants PDAs mobile phones portable media players some combination thereof and so forth. An example electronic device is described herein below with particular reference to .

Network may be formed from any one or more networks that are linked together and or overlaid on top of each other. Examples of networks include but are not limited to an internet a telephone network an Ethernet a local area network LAN a wide area network WAN a cable network a fibre network a digital subscriber line DSL network a cellular network a Wi Fi network a WiMAX network a virtual private network VPN some combination thereof and so forth. Network may include multiple domains one or more grid networks and so forth. Each of these networks or combination of networks may be operating in accordance with any networking standard.

As illustrated device corresponds to a user that is interacting with it. Device corresponds to a service that is executing on it. Device is associated with a resource . Resource may be part of device or separate from device .

User service and a machine such as any given device form a non exhaustive list of example entities. Entities from time to time may wish to access resource . Security scheme ensures that entities that are properly authenticated and authorized are permitted to access resource while other entities are prevented from accessing resource .

As illustrated device A includes two security related components a security token and an application . Security token includes one or more assertions . Device B includes five security related components an authorization context a resource guard an audit log an authorization engine and a security policy . Security policy includes a trust and authorization policy an authorization query table and an audit policy .

Each device may be configured differently and still be capable of implementing all or a part of security scheme . For example device A may have multiple security tokens and or applications . As another example device B may not include an audit log or an audit policy . Other configurations are also possible.

In a described implementation authority issues security token having assertions to entity . Assertions are described herein below including in the section entitled Security Policy Assertion Language Example Characteristics . Entity is therefore associated with security token . In operation entity wishes to use application to access resource by virtue of security token .

Resource guard receives requests to access resource and effectively manages the authentication and authorization process with the other security related components of device B . Trust and authorization policy as its name implies includes policies directed to trusting entities and authorizing actions within security environment . Trust and authorization policy may include for example security policy assertions not explicitly shown in . Authorization query table maps requested actions such as access requests to an appropriate authorization query. Audit policy delineates audit responsibilities and audit tasks related to implementing security scheme in security environment .

Authorization context collects assertions from security token which is are used to authenticate the requesting entity and security policy assertions from trust and authorization policy . These collected assertions in authorization context form an assertion context. Hence authorization context may include other information in addition to the various assertions.

The assertion context from authorization context and an authorization query from authorization query table are provided to authorization engine . Using the assertion context and the authorization query authorization engine makes an authorization decision. Resource guard responds to the access request based on the authorization decision. Audit log contains audit information such as for example identification of the requested resource and or the algorithmic evaluation logic performed by authorization engine .

In a described implementation entity authenticates itself to resource guard with a token security token . Resource guard forwards the token assertions to authorization context . These token assertions are assertions of of security token . Security policy provides the authorization query table to resource guard . The authorization query table derives from authorization query table module . The authorization query table sent to resource guard may be confined to the portion or portions directly related to the current access request.

Policy assertions are extracted from trust and authorization policy by security policy . The policy assertions may include both trust related assertions and authorization related assertions. Security policy forwards the policy assertions to authorization context . Authorization context combines the token assertions and the policy assertions into an assertion context. The assertion context is provided from authorization context to authorization engine as indicated by the encircled A .

An authorization query is ascertained from the authorization query table. Resource guard provides the authorization query auth. query to authorization engine . Authorization engine uses the authorization query and the assertion context in an evaluation algorithm to produce an authorization decision. The authorization decision auth. dcn. is returned to resource guard . Whether entity is granted access to resource by resource guard is dependent on the authorization decision. If the authorization decision is affirmative then access is granted. If on the other hand the authorization decision issued by authorization engine is negative then resource guard does not grant entity access to resource .

The authorization process can also be audited using semantics that are complementary to the authorization process. The auditing may entail monitoring of the authorization process and or the storage of any intermediate and or final products of e.g. the evaluation algorithm logically performed by authorization engine . To that end security policy provides to authorization engine an audit policy from audit policy . At least when auditing is requested an audit record having audit information may be forwarded from authorization engine to audit log . Alternatively audit information may be routed to audit log via resource guard for example as part of the authorization decision or separately.

Generally a device may represent any computer or processing capable device such as a client or server device a workstation or other general computer device a PDA a mobile phone a gaming platform an entertainment device one of the devices listed above with reference to some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media include processor executable instructions .

In a described implementation of device I O interfaces may include i a network interface for communicating across network ii a display device interface for displaying information on a display screen iii one or more man machine interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Printing device interfaces may similarly be included as part of I O interfaces . Examples of iii man machine interfaces include those that communicate by wire or wirelessly to man machine interface devices e.g. a keyboard a remote a mouse or other graphical pointing device etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device .

Thus realizations for security related implementations may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects components metadata and definitions thereof data structures application programming interfaces APIs schema etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

Processor s may be implemented using any applicable processing capable technology. Media may be any available media that is included as part of and or accessible by device . It includes volatile and non volatile media removable and non removable media and storage and transmission media e.g. wireless or wired communication channels . For example media may include an array of disks flash memory optical media for longer term mass storage of processor executable instructions random access memory RAM for shorter term storing of instructions that are currently being executed link s on network for transmitting communications e.g. security related data and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein including those actions that are illustrated in the various flow diagrams. By way of example only processor executable instructions may include a security token at least one of its assertions an authorization context module a resource guard an audit log an authorization engine a security policy e.g. a trust and authorization policy an authorization query table and or an audit policy etc. some combination thereof and so forth. Although not explicitly shown in processor executable instructions may also include an application and or a resource .

This section describes example characteristics of an implementation of a security policy assertion language SecPAL . The SecPAL implementation of this section is described in a relatively informal manner and by way of example only. It has an ability to address a wide spectrum of security policy and security token obligations involved in creating an end to end solution. These security policy and security token obligations include by way of example but not limitation describing explicit trust relationships expressing security token issuance policies providing security tokens containing identities attributes capabilities and or delegation policies expressing resource authorization and delegation policies and so forth.

In a described implementation SecPAL is a declarative logic based language for expressing security in a flexible and tractable manner. It can be comprehensive and it can provide a uniform mechanism for expressing trust relationships authorization policies delegation policies identity and attribute assertions capability assertions revocations audit requirements and so forth. This uniformity provides tangible benefits in terms of making the security scheme understandable and analyzable. The uniform mechanism also improves security assurance by allowing one to avoid or at least significantly curtail the need for semantic translation and reconciliation between disparate security technologies.

A SecPAL implementation may include any of the following example features 1 SecPAL can be relatively easy to understand. It may use a definitional syntax that allows its assertions to be read as English language sentences. Also its grammar may be restrictive such that it requires users to understand only a few subject verb object e.g. subject verb phrase constructs with cleanly defined semantics. Finally the algorithm for evaluating the deducible facts based on a collection of assertions may rely on a small number of relatively simple rules.

 2 SecPAL can leverage industry standard infrastructure in its implementation to ease its adoption and integration into existing systems. For example an extensible markup language XML syntax may be used that is a straightforward mapping from the formal model. This enables use of standard parsers and syntactic correctness validation tools. It also allows use of the W3C XML Digital Signature and Encryption standards for integrity proof of origin and confidentiality.

 3 SecPAL may enable distributed policy management by supporting distributed policy authoring and composition. This allows flexible adaptation to different operational models governing where policies or portions of policies are authored based on assigned administrative duties. Use of standard approaches to digitally signing and encrypting policy objects allow for their secure distribution. 4 SecPAL enables an efficient and safe evaluation. Simple syntactic checks on the inputs are sufficient to ensure evaluations will terminate and produce correct answers.

 5 SecPAL can provide a complete solution for access control requirements supporting required policies authorization decisions auditing and a public key infrastructure PKI for identity management. In contrast most other approaches only manage to focus on and address one subset of the spectrum of security issues. 6 SecPAL may be sufficiently expressive for a number of purposes including but not limited to handling the security issues for Grid environments and other types of distributed systems. Extensibility is enabled in ways that maintain the language semantics and evaluation properties while allowing adaptation to the needs of specific systems.

As illustrated at the top row of assertion format an example assertion at a broad level includes a principal portion a says portion and a claim portion . Textually the broad level of assertion format may be represented by principal says claim.

At the next row of assertion format claim portion is separated into example constituent parts. Hence an example claim portion includes a fact portion an if portion n conditional factportions . . . and a c portion . The subscript n represents some integer value. As indicated by legend c portion represents a constraint portion. Although only a single constraint is illustrated c portion may actually represent multiple constraints e.g. c . . . c . The set of conditional fact portions . . . and constraints . . . on the right hand side of if portion may be termed the antecedent.

Textually claim portion may be represented by fact if fact . . . fact c. Hence the overall assertion format may be represented textually as follows principal says fact if fact . . . fact c. However an assertion may be as simple as principal says fact. In this abbreviated three part version of an assertion the conditional portion that starts with if portion and extends to c portion is omitted.

Each fact portion may also be further subdivided into its constituent parts. Example constituent parts are an e portion and a verb phrase portion . As indicated by legend e portion represents an expression portion. Textually a fact portion may be represented by e verbphrase.

Each e or expression portion may take on one of two example options. These two example expression options are a constant and a variable . Principals may fall under constants and or variables .

Each verb phrase portion may also take on one of three example options. These three example verb phrase options are a predicate portion followed by one or more eportions . . . a can assert portion followed by a fact portion and an alias portion followed by an expression portion . Textually these three verb phrase options may be represented by predicate e. . . e can assert fact and alias e respectively. The integer n may take different values for facts . . . and expressions . . . .

Generally SecPAL statements are in the form of assertions made by a security principal. Security principals are typically identified by cryptographic keys so that they can be authenticated across system boundaries. In their simplest form an assertion states that the principal believes a fact is valid e.g. as represented by a claim that includes a fact portion . They may also state a fact is valid if one or more other facts are valid and some set of conditions are satisfied e.g. as represented by a claim that extends from a fact portion to an if portion to conditional fact portions . . . to a c portion . There may also be conditional facts . . . without any constraints and or constraints without any conditional facts . . . .

In a described implementation facts are statements about a principal. Four example types of fact statements are described here in this section. First a fact can state that a principal has the right to exercise an action s on a resource with an action verb . Example action verbs include but are not limited to call send read list execute write modify append delete install own and so fort. Resources may be identified by universal resource indicators URIs or any other approach.

Second a fact can express the binding between a principal identifier and one or more attribute s using the possess verb. Example attributes include but are not limited to email name common name group name role title account name domain name server service DNS name internet protocol IP address device name application name organization name service name account identification identifier ID and so forth. An example third type of fact is that two principal identifiers can be defined to represent the same principal using the alias verb.

 Qualifiers or fact qualifiers may be included as part of any of the above three fact types. Qualifiers enable an assertor to indicate environmental parameters e.g. time principal location etc. that it believes should hold if the fact is to be considered valid. Such statements may be cleanly separated between the assertor and a relying party s validity checks based on these qualifier values.

An example fourth type of fact is defined by the can assert verb. This can assert verb provides a flexible and powerful mechanism for expressing trust relationships and delegations. For example it allows one principal A to state its willingness to believe certain types of facts asserted by a second principal B . For instance given the assertions A says B can assert fact and B says fact it can be concluded that A believes fact to be valid and therefore it can be deduced that A says fact .

Such trust and delegation assertions may be i unbounded and transitive to permit downstream delegation or ii bounded to preclude downstream delegation. Although qualifiers can be applied to can assert type facts omitting support for qualifiers to these can assert type facts can significantly simplify the semantics and evaluation safety properties of a given security scheme.

In a described implementation concrete facts can be stated or policy expressions may be written using variables. The variables are typed and may either be unrestricted e.g. allowed to match any concrete value of the correct type or restricted e.g. required to match a subset of concrete values based on a specified pattern .

Security authorization decisions are based on an evaluation algorithm e.g. that may be conducted at authorization engine of an authorization query against a collection of assertions e.g. an assertion context from applicable security policies e.g. a security policy and security tokens e.g. one or more security tokens . Authorization queries are logical expressions which may become quite complex that combine facts and or conditions. These logical expressions may include for example AND OR and or NOT logical operations on facts either with or without attendant conditions and or constraints.

This approach to authorization queries provides a flexible mechanism for defining what must be known and valid before a given action is authorized. Query templates e.g. from authorization query table form a part of the overall security scheme and allow the appropriate authorization query to be declaratively stated for different types of access requests and other operations actions.

Modern systems especially distributed systems often function more effectively when rights may be delegated between entities. This is manifested in a wide variety of functional situations. Example situations include but are not limited to 

These types of delegations should typically be controlled in one or more of many various ways. For example they may be allowed for only restricted periods of time and they may need to be limited to the particular resources a delegatee needs to perform the intended function. Effective control over the ability to allow downstream delegation of rights can also be beneficial. In other words it may be beneficial for a delegatee to further delegate downstream some or all of the access rights it has been granted.

Existing systems provide a limited ability to support controlled delegation. In most systems it is limited to allowing a running program to impersonate a user. Impersonation represents the ability for the delegatee to exercise the full access rights of the delegator. At most there is some time restriction on this impersonation but it is typically a default system value which is measured in hours and can not be controlled on a per interaction basis. The Microsoft Windows Kerberos implementation further supports the ability for a service to have delegation rights when processing requests on behalf of a user. This allows a service to pass along the right to impersonate the user to another service but it provides no effective controls for constraining use of this capability. As a result users of these existing systems must fully trust the delegatee to not abuse its impersonation rights.

The Grid community has developed a delegation approach based on X.509 proxy certificates. These also provide a very limited ability to control a delegation. Although they do allow the setting of a time limit on a particular delegation they also still allow the delegatee to use the identity and attributes of the delegator when making access requests. The developers of the standard that defines proxy certificates did recognize a need for controlled delegation and they provided a placeholder where a controlled delegation policy could be inserted into a certificate. However they did not define any mechanism to express or enforce such controls.

In a described implementation for the example delegation scenario of assertor corresponds to an authority principal corresponds to a delegator and principal corresponds to a delegatee. Assertor has a right granting ability . Via transfer of delegation authority assertion right granting ability is delegated from assertor to principal .

Hence principal gains right granting ability as a result of delegation authority assertion . Principal has a right . Because of delegation authority assertion principal may grant right to one or more other principals such as principal . The delegatee principal s the nature of the granted right and or how the granted right may be exercised is controllable by delegation authority assertion . Via transfer of delegation granting assertion right is granted from principal to principal . It should be understood that transfer may be implicit and that delegation authority assertion may be made known via a security policy to resource guard of . It is resource guard that enforces resource access based on right and delegation granting assertion .

Thus delegation mechanism includes at least delegation authority assertion and may include delegation granting assertion to complete a full delegation process. Example implementations of delegation authority assertion and delegation granting assertion are described further herein below.

Delegation mechanism is capable of implementing a number of different types of delegation control. As illustrated these example delegation control types include but are not limited to attributed based delegation constrained delegation depth bound delegation and width bound delegation . These four specific example types of controlled delegation are described below in greater detail after additional description of general controlled delegation concepts and implementations. As representing by other delegation types T delegation mechanism may be capable of implementing many other types of controlled delegation.

In a described implementation each of blocks logically represents a capability of delegation mechanism to control delegation with respect to the indicated factor. Accordingly delegation mechanism may control a delegation by way of an identified principal or principals a certain verb phrase a particular resource one or more indicated fact qualifiers at least one given attribute and or a permitted transitive chaining depth . By way of example only delegation mechanism may be realized as an application programming interface API that can be used to control delegations using at least the factors of .

As described herein above fact qualifiers include environmental restrictions such as time periods time spans location network connectivity mechanism revocation check frequency and so forth. Attributes refer to attribute name attribute value pairs in which a principal may possess one or more or attributes.

Any of these factors may be related to principal and or principal . In other words and by way of example only delegation mechanism may control what accesses e.g. by way of verb phrases on which resources may be delegated by principal to principal . Delegation mechanism may control which principals qualify as a principal . Furthermore delegation mechanism may require that a would be principal possess a given attribute . Additionally restrictive environmental controls on delegation may be enforced through fact qualifiers e.g. in conjunction with conditional constraints . These and other possibilities are further illuminated by the description herein below.

Delegation mechanism may also control whether transitive chaining delegation is enabled and if so to what degree or depth transitive chaining delegation is permitted by transitive chaining factor . Transitive chaining refers to whether principal is permitted to her transfer or delegate right granting ability to principal . If this is permitted then principal is enabled to issue a delegation authority assertion to principal . Principal in turn is then enabled to issue a delegation granting assertion to some third principal. This transitive chaining delegation is described further herein below with particular reference to .

A portion of the example assertion format of is reproduced in . However principal portion is replaced by an assertor portion and the capacity for multiple or m constraints is explicitly shown. It should be noted that the nomenclature assertor principal and principal is utilized herein to facilitate differentiation of respective parties in a delegation scenario. However each party may be considered to be essentially and effectively a principal in the overall scheme of a described security language.

Thus in a described implementation example assertion format includes an assertor portion a says portion a fact portion an if portion n conditional fact portions . . . and m constraintportions . . . . Fact is realized as a delegation fact by including a delegation directive verb . Examples included by way of example but not limitation can assert can say can profess may contend and so forth. Some delegation related assertion examples set forth herein below use the specific example of can assert without loss of generality.

Delegation fact includes a principal portion delegation directive verb and a delegated fact portion D . Delegated fact D includes a principal portion a verb phrase portion a resource portion and a fact qualifierportion . . . . Hence an example assertion format may comport with a form of 

Thus in a described implementation a program may include an application programming interface API for a delegation mechanism. The delegation mechanism is initiated by an assertor and enables a first principal to delegate a right to a second principal for the second principal to make at least one assertion. The delegation mechanism enables the delegation to be specifically controlled. For example the delegation mechanism may enable a delegation to be controlled using any of factors .

For example delegation mechanism may enable an assertor to specify at least one attribute that a first principal is to possess for the first principal to be capable of delegating a right to make an assertion and or to specify at least one attribute that a second principal is to possess for the second principal to be permitted to make an assertion. For instance delegation authority assertion may include a conditional fact such as principal possesses attribute name attribute value or principal possesses attribute name attribute value .

As another example delegation mechanism may enable an assertor to specify that a first principal can only delegate a right to make an assertion if the first principal has a certain capability with respect to a particular resource and or that a second principal is only permitted to make an assertion if the second principal has a certain capability with respect to a particular resource. For instance delegation authority assertion may include a conditional fact such as principal read resource a or principal verb Foo.

As yet another example delegation mechanism may enable an assertor to specify at least one fact qualifier that restricts a manner in which the delegation or the right may be exercised. For instance delegation authority assertion may include a delegated fact D such as principal write resource b connectivity mechanism with a constraint such as connectivity mechanism LAN.

Thus in a described implementation a general mechanism enables fine grained controls to be expressed on delegated access rights. By way of example but not limitation fine grained control over delegated access rights can be expressed with respect to the following 

A delegation mechanism as described herein is capable of expressing these delegation control factors using a uniform declarative representation that allows specification of both delegation policy and delegate rights. As illustrated in and as described above the general form of security assertions is leveraged to create an example form for delegation authority assertions that enables the expression of controlled delegation policies. The example format is repeated here for convenient reference 

 1 The right for B to delegate read access to the file Foo for 8 hours to any principal may be expressed as 

By controlling the values that the variable x may bind to the set of principals who may be delegatees may be restricted. For example equality and inequality constraints may be applied to the variable x .

 2 The right for a principal p to delegate rights it holds to a resource Foo to other principals may be expressed as 

If B read write Foo is true then the above delegation policy implies A says B can assert x read write Foo .

Delegation policies such as the examples above are combined with asserted capabilities to create a full delegation. In the example scenario of delegation granting assertion is an asserted capability. Given the policy 1 above if B also asserts B says C read Foo 0800 1200 then A would believe that C is allowed to read Foo during the indicated time span. Similarly given policy 2 above and the two assertions A says B read Foo and B says C read Foo A would believe that C is allowed to read Foo.

With regard to the transitive chaining of delegation rights a mechanism is also described for controlling the ability for a delegatee to further delegate the access rights it has been granted. The following example set of assertions is presented to expand upon this concept 

The question is whether or not A believes that D is authorized to read Foo based on assertion 3 which only states that B has the right to delegate read access to Foo. But in this example B has in turn asserted 4 that C has the right to delegate read access to Foo.

If one allows uncontrolled chaining then thru logical deductions based on these statements the answer to the question is yes. This affirmative answer is because one can conclude B says D read Foo is valid by deduction using assertions 4 and 5 . Based on that deduction and assertion 3 one can conclude that A say D read Foo is valid. If on the other hand one disallows logical chaining thru deduced facts then the answer to the question is no. When chaining is not allowed one could only reach conclusions thru direct combination of assertion 3 with either assertion 4 or assertion 5 but not thru both 4 and 5 .

In a described implementation an example chaining delegation mechanism enables precise control over this type of logical chaining by introducing a depth indicator or parameter that modifies the delegation directive verb e.g. can assert . If one wishes to disallow logical chaining then the depth indicator has a value of zero and assertion 3 is rewritten as 

Alternatively if one wanted to explicitly allow B to pass along the delegation to exactly one more principal then assertions 3 4 and 5 are rewritten with the depth indicator having a value of one as 

The depth indicator is set to a value of zero in assertion 4.2 to enforce that C is not allowed to pass along the access rights it has been delegated. If it were permitted to do so the chain of logical deductions needed to establish an assertion that is valid with respect to assertion 3.2 would exceed the indicated allowed depth of 1. With this approach to enable an unbounded ability to pass along delegated access rights to other principals a depth indicator value of infinity may be used.

Thus in an example implementation the depth indicator may be set to zero infinity or any positive integer. An example corresponding syntax is respectively can assert can assert and can assert. This enables unbounded delegation e.g. with the infinity or bounded delegation with a precise setting to any desired transitive chaining depth e.g. 0 1 2 . . . .

However in another example implementation the depth indicator may only be set to zero or infinity. This enables i the prevention of any delegation chaining e.g. with the zero value or ii unbounded delegation. In this alternative example implementation bounded but non zero chaining may be enabled with nested delegation directive verbs which is described in the following paragraph.

More specifically using a can assert implementation chained delegation may be implemented with nesting using an assertion comporting with a form of A says B can assertx can asserty can assertz possesses group name g. The preceding example is an explicit 3 level delegation. The number of delegation directed verbs or level of nesting establishes the chaining depth. To reduce the use of depth indicators either no chaining or unbounded chaining may be considered the default transitive chaining rule when there is not explicit indication. Nesting may also be used with depth indicators of positive integer values. Other combinations or derivations may be implemented.

In a described implementation assertor delegates right granting ability to principal . Principal delegates right granting ability to principal . Principal delegates right granting ability to principal d perhaps through other intermediate principals as indicated by the ellipses. Principal d then grants right to principal . Example general approaches to a security language implementation that enables chained delegation mechanism C are described herein above e.g. the transitive chaining descriptions and examples above as well as the general delegation authority assertion format . Example format approaches that are specific to a chained delegation mechanism are described below with reference to .

More specifically format includes a principal portion a can assert portion and a delegated fact portion D . Format also includes a chaining depth indicator . Chaining depth indicator is associated with can assert portion . Chaining depth indicator may take on any value to establish the allowed transitive chaining depth. Examples from above include zero infinity and positive integers.

Format includes a principal portion a can assert portion a principal portion a can assert portion a principal portion a can assert portion and a delegated fact portion D . Although not shown each can assert portion of format may also be associated with a chaining depth indicator . For example such a chaining depth indicator may be set to zero to indicate that each individual can assert portion of format does not allow transitive chaining e.g. beyond that permitted by the nesting .

In a described implementation at block a delegator principal and a delegatee principal are specified. For example a principal and a principal may be identified with a principal factor of a delegation mechanism .

At block a verb phrase is specified. For example a certain verb phrase may be specified with a verb phrase factor . At block a resource is specified. For example a particular resource may be specified with resource factor . The verb phrase and resource may be combined to represent a right that may be granted from principal to principal .

At block a chaining depth is specified. For example in accordance with transitive chaining factor a chaining depth may be specified by way of a chaining depth indicator to comport with assertion format approach and or a nested expression of multiple delegation directive verbs to comport with assertion format approach .

At block a fact qualifier is specified. For example at least one environmental restriction or other fact qualifier factor may be indicated to be applied to any right with regard to the resource. Although not shown in a given attribute with respect to one or both principals may also be specified and incorporated into the delegation authority assertion of block . For example it may be specified that principal and or principal must possess a given attribute for a delegation to be permitted with attributes factor .

At block a delegation authority assertion with the specified factors is formulated with a delegation directive verb. For example a delegation authority assertion comporting with assertion format and including a delegation directive verb portion may be formulated using any of the specified factors . For instance a principal portion a principal portion a verb phrase portion a resource portion and fact qualifierportion s . . . may each be included as part of delegation authority assertion . Given attributes may be specified as needing to be possessed by an identified principal using one or more conditional facts . . . .

At block the delegation authority assertion is added to a trust and authorization policy. For example delegation authority assertion may be added to a trust and authorization policy . Thereafter a delegation granting assertion and or any other relevant assertions may be combined into an assertion context within authorization context .

In a described implementation delegation granting assertion for the delegation to be properly effected also includes at least the particular resource the certain verb phrase and the delegatee principal specified in the corresponding delegated fact D of in delegation granting assertion . An authorization query from authorization query table is then evaluated in conjunction with the assertion context in authorization engine to determine an authorization decision with respect to the particular resource .

Four example delegation related policy idioms are presented below. Each corresponds to an example delegation type of . Specifically attribute based delegation constrained delegation depth bound delegation and width bound delegation examples are presented.

Attribute Based Delegation Type Attribute based as opposed to identity based authorization enables collaboration between parties whose identities are initially unknown to each other. The authority to assert that a subject holds an attribute such as being a student may then be delegated to other parties who in turn may be characterized by attributes rather than identity.

In the example below students are entitled to a discount. The expiration date of the student attribute can be checked with a constraint. The authority over the student attribute is delegated to holders of the university attribute and authority over the university attribute is delegated to a known principal the Board of Education.

Constrained Delegation Type Delegators may wish to restrict the parameters of the delegated fact. This can be done with constraints. In the example below an STS is given the right to issue tickets for accessing some resource for a specified validity period of no longer than eight hours.

The delegation depth specified in the assertion above is unlimited so STS can in turn delegate the same right to some STS. With STS s assertion below Admin accepts tickets issued by STS with a validity period of at most eight hours where the start date is not before Jan. 1 2007.

Depth Bounded Delegation Type In a described implementation the delegation depth subscript of the can assert keyword can only be 0 no re delegation or unlimited re delegation . Nevertheless such an example security language can express any fixed integer delegation depth by nesting can assert. In the following example Alice delegates the authority over is a friend facts to Bob and allows Bob to re delegate one level further.

Suppose Bob re delegates to Charlie with the assertion Bob says Charlie can assert x is a friend . Now Alice says Eve is a friend follows from Charlie says Eve is a friend . Since Alice does not accept any longer delegation chains Alice in contrast to Bob does not allow Charlie to re delegate with

Furthermore Charlie cannot circumvent the delegation depth restriction with the following trick either because the restriction also applies to conditional facts.

Accordingly if it is assumed that the only assertions by Alice and Bob that mention the verbphrase x is a friend are those listed above it can be shown that the result of the query Alice says x is a friend depends only of Charlie s assertions not those of Doris for instance.

Width Bounded Delegation Type Suppose Alice wants to delegate authority over is a friend facts to Bob. She does not care about the length of the delegation chain but she requires every delegator in the chain to satisfy some property e.g. to possess an email address from fabrikam.com. The following assertions implement this policy by encoding controlled transitive delegation using the can assert keyword with a 0 subscript. Principals with the is a delegator attribute are authorized by Alice to assert is a friend facts and to transitively re delegate this attribute but only amongst principals with a matching email address.

The devices actions aspects features functions procedures modules data structures protocols components etc. of are illustrated in diagrams that are divided into multiple blocks. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses APIs protocols arrangements etc. for controlling the delegation of rights.

Although systems media devices methods procedures apparatuses mechanisms schemes approaches processes arrangements and other implementations have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

