---

title: Widget searching utilizing task framework
abstract: A task framework and a semantic reasoning engine are combined to provide a scalable mechanism for dealing with extremely large numbers of widgets, allowing users to both find a widget and automatically fill-in whatever functionality is available on the widget. Calling applications are employed to obtain task information from each widget. The calling application also receives user queries that can be resolved by a widget. A task reasoning process based on an adaptive semantic reasoning engine utilizes the task information to select a widget best suited to respond to a user's query. The task reasoning process can also be employed to determine “best-guess” slot filling of the selected widget. The calling application can then invoke the selected widget and, if available, fill appropriate slots with information to facilitate user interaction with the selected widget. Instances can be client- and/or server-side based.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07996783&OS=07996783&RS=07996783
owner: Microsoft Corporation
number: 07996783
owner_city: Redmond
owner_country: US
publication_date: 20060302
---
This application is related to co pending U.S. patent application Ser. No. 11 270 393 filed Nov. 9 2005 and entitled ADAPTIVE TASK FRAMEWORK co pending U.S. patent application Ser. No. 11 270 407 filed Nov. 9 2005 and entitled ADAPTIVE TASK FRAMEWORK co pending U.S. patent application Ser. No. 11 290 076 filed Nov. 30 2005 and entitled ADAPTIVE SEMANTIC REASONING ENGINE and co pending U.S. patent application Ser. No. 11 294 265 filed Dec. 5 2005 and entitled EMPLOYMENT OF TASK FRAMEWORK FOR ADVERTISING . These applications are incorporated herein by reference.

Computers have become an integral part of modern society. They can be found in almost all businesses and homes today helping to reduce the burdens of repetitive tasks allowing more time for other more productive activities. Typically a program or application is created in software that runs on a computer to accomplish the task that was once required to be performed by humans. Thus applications can be utilized in place of manual labor often yielding superior results in a much shorter amount of time. The size of these applications have grown exponentially over time and some are quite complex. In order to support more powerful applications additional computer resources are required such as computational resources and memory. The increases in application sizes and resource utilization have also yielded increased startup times and processing times.

For example a user may desire to write a quick note to send out to a friend. The user could use a word processing application to accomplish this. However modern word processing applications are often packed with additional features that allow them to be utilized in many different tasks. They may have spreadsheet interaction capabilities drawing package attributes database management tools format conversion capabilities advanced math symbology multiple font selections advanced text formatting tools page formatting options printing preview tools etc. All of these capabilities might be unnecessary to send a quick note to a friend. The user most likely would prefer launching a small application typing the short note and sending it to their friend. If the user has to wait for the entire word processor application to load into the computer they may decide that it takes too long and not write the note.

As a way to speed up applications significantly smaller sized applications called widgets were created that allowed a user to accomplish tasks in a much shorter time. These widgets are small purpose built applications that typically accomplish singular tasks. In general a widget does not require the same level of system resources to run as a full application does and can be started quickly. Widgets have become very popular even too popular. Today there appears to be a widget for every task imaginable. Users typically download these widgets to their desktops so that they can quickly find and start them. The store on the desktop schema works well when a user has only a few widgets. However as users download more and more widgets this schema often causes widgets to overrun a user s desktop. So eventually users have to organize their widgets in some form of hierarchy such as in folders and databases. And although they may be stored in an orderly fashion it is now more difficult to quickly find and start an appropriate widget when a task becomes desirable. This difficulty will continually increase as the number of widgets increases. Since widgets are becoming more popular each day more and more users will become frustrated with trying to locate and employ their favorite widgets.

The following presents a simplified summary of the subject matter in order to provide a basic understanding of some aspects of subject matter embodiments. This summary is not an extensive overview of the subject matter. It is not intended to identify key critical elements of the embodiments or to delineate the scope of the subject matter. Its sole purpose is to present some concepts of the subject matter in a simplified form as a prelude to the more detailed description that is presented later.

The subject matter relates generally to search engines and more particularly to systems and methods for enhancing searching and or slot filling of widgets. A task framework and an adaptive semantic reasoning engine are combined to provide a scalable mechanism for dealing with extremely large numbers of widgets allowing users to both find a widget and automatically fill in whatever functionality is available on the widget. Calling applications are employed to obtain task information from each widget. The calling application also receives user queries that can be resolved by a widget. A task reasoning process based on an adaptive semantic reasoning engine utilizes the task information to select a widget best suited to respond to a user s query. The task reasoning process can also be employed to determine best guess slot filling of the selected widget. The calling application can then invoke the selected widget and if available fill appropriate slots with information to facilitate user interaction with the selected widget.

Instances can be client side and or server side based. This allows for example Web browser based widget searching of widgets on a remote server and the like. Other instances incorporate user feedback with regard to the appropriateness of the selected widget and or the slot filling. The user feedback can then be utilized by the task reasoning process to improve subsequent widget selections for that user. Thus substantial improvements in quickly locating appropriate widgets and filling in information automatically allows users to effortlessly employ widgets to find related information foregoing the previous inherent difficulties of searching through large numbers of widgets.

To the accomplishment of the foregoing and related ends certain illustrative aspects of embodiments are described herein in connection with the following description and the annexed drawings. These aspects are indicative however of but a few of the various ways in which the principles of the subject matter may be employed and the subject matter is intended to include all such aspects and their equivalents. Other advantages and novel features of the subject matter may become apparent from the following detailed description when considered in conjunction with the drawings.

The subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the subject matter. It may be evident however that subject matter embodiments may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the embodiments.

As used in this application the term component is intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a computer component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

 Widgets are small programs that perform very specific functions and can reside on a client and or a server. They can be used for example to show the time find the cheapest gas near a particular zip code show the weather forecast near a city find flights from a particular airline show sports scores or compare prices on a particular product or service and the like. The number of applications of widgets is virtually unlimited both on the client and the server. Thus with the proliferation of widgets a larger problem is manifested finding a particular widget when the user wants it and allowing a user to execute pieces of functionality from the widget directly using natural language queries as an input mechanism. Thus having an efficient mechanism for searching for widgets is critical. Additionally there currently is no way to generically pass parameter information to a widget that allows it to be driven externally to allow a user to request for example weather in Seattle. 

ADAPTIVE TASK FRAMEWORK mechanisms U.S. patent application Ser. Nos. 11 270 393 and 11 270 407 and ADAPTIVE SEMANTIC REASONING ENGINE mechanisms U.S. patent application Ser. No. 11 290 076 provide approaches that facilitate modeling advanced semantic constructs such as tasks whereby a task is something that users want to do and may or may not take parameters as input. These framework mechanisms allow a system to respond to users behavior and improve the ranking and slot filling models thus enhancing the user experience over time. Instances of the systems and methods herein provide mechanisms that reason over widgets and perform searching by utilizing the infrastructure provided by the ADAPTIVE TASK FRAMEWORK and ADAPTIVE SEMANTIC REASONING ENGINE mechanisms. This combination of approaches provides leveraging of the work done for semantic processing with a new paradigm of widgets that for example allows a user to enter a query such as weather in Seattle find the appropriate widget e.g. the weather widget pass information to the widget e.g. City Seattle and then show the widget with Seattle s forecast already loaded.

In a block diagram of a widget search system in accordance with an aspect of an embodiment is shown. The widget search system is comprised of a widget search component that receives an input and provides an output . The input can include but is not limited to a query that can be responded to via a widget and or parametric task data from various widgets to facilitate widget selection. The widget search component employs widget parametric task data in its task models to facilitate in selecting appropriate widgets for a given user query. The task data can include but is not limited to general task capabilities types of acceptable inputs i.e. slots and or information that can facilitate the widget search component to properly select the widget and or fill slots when appropriate. The query can be received by the widget search component directly from a user and or via an intermediate means such as for example a Web browser. This flexibility allows the widget search system to reside client side and or server side to support searching of widgets located at the client and or at the server. The query itself can be but is not required to be a natural language query and the like. This allows a simplistic user interface for accepting query inputs. The input is modality independent and can include but is not limited to audible inputs keyboard inputs and or mouse inputs and the like. One skilled in the art can appreciate that as technology develops additional input techniques will also be created and are within the scope of the systems and methods herein.

The widget search component employs widget parametric task data to select an appropriate widget based on a given query. The query itself can contain slot data that the widget search component processes to determine a best guess slot match for the data. This enables the widget search component to provide information that can be utilized to pre fill slots for a selected widget reducing the amount of data required to be entered by a user for the selected widget. If a user desires to know how many Yen are in a 100 dollars the widget search component can select a currency converter widget and send slot data matched to a dollar slot for the widget. The output can then include but is not limited to widget selections widget slot data and or widget invoking calling commands and the like. Thus the output can be utilized to identify an appropriate widget based on a given query and or to facilitate in invoking the appropriate widget with or without slots being filled and the like.

The widget search component employs the Task Framework and adaptive semantic reasoning engine to facilitate mapping of queries to an appropriate task. The Task Framework provides a schema for having a widget specify what information can be utilized to find it and what parameter values it can accept. The appropriate task can then be matched to a widget given the widget s task data by an adaptive semantic reasoning engine. The combination of these two mechanisms allows the widget search system to substantially outperform existing widget search functions both in scalability and accuracy. It also allows a user to not only search for a specific widget but also to merely ask questions and have the appropriate widget automatically provided to them. For example a user can ask where is the cheapest local gas and the widget search system can provide a gas price widget with the user s area code pre filled so that the gas price widget displays local gas prices when it is automatically invoked.

Turning to another block diagram of a widget search system in accordance with an aspect of an embodiment is illustrated. The widget search system is comprised of a widget search component that receives a user query and provides a selected widget call . The widget search component is comprised of a calling application and an adaptive task reasoning component . The adaptive task reasoning component can also be referred to as a semantic reasoning component that employs aspects from ADAPTIVE SEMANTIC REASONING ENGINE see U.S. patent application Ser. No. 11 290 076 . The calling application interfaces with widgets . The calling application typically interfaces with widgets to initially obtain widget task data that the calling application then passes to the adaptive task reasoning component to facilitate in widget selection. When a user query is received the calling application passes the user query to the adaptive task reasoning component . The calling application can include but is not limited to applications such as search engines and or toolbars and the like. The adaptive task reasoning component selects an appropriate widget to respond to the user query . The adaptive task reasoning component employs the widget task data to facilitate selection of the widget and or to determine slot filling for the widget. The selected widget information and or slot fill information is then passed to the calling application . In this instance the calling application provides a selected widget call which can include slot fill information when applicable. Although the selected widget call is illustrated apart from the widgets for clarification the selected widget call is sent to the appropriate widget which can be one of the widgets .

Referring to a block diagram of a browser based widget search system in accordance with an aspect of an embodiment is depicted. The widget search system is comprised of a widget search component that receives a user query via a Web browser and provides a selected widget call . The widget search component is comprised of a calling application and an adaptive task reasoning component . The adaptive task reasoning component can also be referred to as an adaptive semantic reasoning component that employs aspects from ADAPTIVE SEMANTIC REASONING ENGINE see U.S. patent application Ser. No. 11 290 076 . The calling application interfaces with widgets . The calling application can include but is not limited to applications such as search engines and or toolbars and the like. In this instance the Web browser resides on the client side and is utilized to interface with a user to accept the user query . This provides a user interface on the client side while the widgets reside on the server side. One skilled in the art can appreciate that the widgets can also reside solely on the client side or even on both the client side and server side and thus these embodiments are also within the scope of the systems and methods herein. Likewise the widget search component can reside on the client side while the widgets reside on the client side and or the server side. The Web browser can be utilized to accept the user query and or display a selected widget to the user. The Web browser passes the user query to the calling application . In other instances a Web browser i.e. intermediate application is not necessary and the user query can pass directly to the calling application .

The calling application typically interfaces with widgets to initially obtain widget task data that the calling application then passes to the adaptive task reasoning component to facilitate in widget selection. When a user query is received from the Web browser the calling application passes the user query to the adaptive task reasoning component . The adaptive task reasoning component selects an appropriate widget to respond to the user query . The adaptive task reasoning component employs the widget task data to facilitate selection of the widget and or to determine slot filling for the widget. The selected widget information and or slot fill information is then passed to the calling application . In this instance the calling application provides a selected widget call which can include slot fill information when applicable. Although the selected widget call is illustrated apart from the widgets for clarification the selected widget call is sent to the appropriate widget which can be one of the widgets .

Looking at a block diagram of a widget search system with user feedback in accordance with an aspect of an embodiment is shown. The widget search system is comprised of a widget search component . The widget search component receives a user query from a user and provides a call selected widget to widgets . A selected widget is then launched and displayed to the user . The user then interfaces with the selected widget . The selected widget can then relay various aspects of the interaction with the user to the widget search component as user feedback relating to the widget selection process. The widget search component can utilize aspects of an ADAPTIVE SEMANTIC REASONING ENGINE see U.S. patent application Ser. No. 11 294 265 to facilitate performance improvements on the widget selection process and or the widget slot matching filling process. The adaptive reasoning engine can employ statistical learning models e.g. Hidden Markov Models HMM for semantic slot filling Na ve Bayesian models for Information Retrieval IR Max Entropy Minimum Divergence MEMD for ranking and or query and context to asset mapping .

Thus with the proliferation of widgets i.e. small often singular purposed applications on both server and client sides finding and executing widget functionality becomes substantially more problematic without utilization of the above systems. For users running tens or hundreds of client side widgets managing the widgets becomes increasingly more difficult. Similarly in server side widget scenarios the number of widgets is potentially huge making it more difficult for users to find the appropriate widget and perform a task. The Task Framework adaptive semantic reason engine based systems and methods provide scalable mechanisms for dealing with extremely large numbers of widgets allowing users to both find a widget and execute whatever functionality is available on the widget. For example if a user enters a request for find flights from Boston to Seattle the Task Framework adaptive semantic reason engine based systems and methods can first find the appropriate widgets e.g. a flight finding or vacation booking widgets and can also allow any parametric or slot information to be filled. This ability increases the value of widget searching systems that employ the systems and methods herein and would yield a competitive advantage over other searching engines.

Users can download widgets easily from Internet Web sites to perform many different functions. In an illustration of examples of widgets in accordance with an aspect of an embodiment is shown. The illustration shows a few examples of widgets that are freely available to do things like compare current exchange rates using the Currency Comparer find chords using the Chord Finder or just check the news from a particular source using the CNN Widget . Typically after downloading the widgets the widgets exist like any other application and can be shown on the desktop much in the way a regular sized application is shown. Of course if the user has tens or hundreds of widgets running the desktop will quickly become cluttered and unmanageable. Thus users attempt to file the widgets in some logical manner. However this only slightly decreases the time it takes a user to hunt down an appropriate widget when they need it to perform a task.

These types of widgets contain functionality that is executed on a server without requiring that a user download any client side application code. For example a search engine may wish to provide a flight finding widget to facilitate finding cheap airfare where the functionality for finding flights resides on the server and the client is only used to display the results via standard HTML hypertext markup language conventions. depicts an illustration of such an example of a browser based widget . Having a broad range of server side widgets allows users to have access to functionality they may only use once or twice with a minimum of effort. Of course the problem remains that as the number of server side widgets increases finding the appropriate widget s at the appropriate time becomes more and more of a challenge.

The Task Framework is described in depth in ADAPTIVE TASK FRAMEWORK U.S. patent application Ser. Nos. 11 270 393 and 11 270 407 and is briefly described here. The central construct is the notion of a Task where a task provides various metadata and slot information to describe an action. The FlightFinder task below illustrates some of the elements that might be seen in a task 

Additionally the Task Framework and adaptive semantic reasoning engine provide mechanisms to learn from user behavior such that if users start entering queries such as departing Boston for Seattle to mean Departure City Boston and Arrival City Seattle the system automatically learns the pattern departing for without needing to explicitly add new Pre or Post indicators to the Task definition. A system implementing the Task Framework adaptive semantic reasoning engine is responsible for taking an input query finding a set of likely Tasks given the input query filling out slot values given a Task and the input query retrieving the most likely Tasks with the most likely slot values and or optionally receiving feedback data to learn from the user feedback.

Widgets are incredibly useful at encapsulating a piece of functionality within a pseudo application. However the number of potential widgets is incredibly large. Thus finding an appropriate widget at an appropriate time becomes a substantial problem with existing solutions. However the Task Framework provides an approach for modeling widgets as tasks that facilitate both retrieval of the widget e.g. finding the appropriate widget given a query such as what is the exchange rate of USD to GBP and slot filling e.g. Currency1 USD and Currency2 GBP . Moreover instances of the systems and methods herein have the added benefit of scaling to large numbers of tasks easily.

Each widget is responsible for exposing metadata and methods used by the Task Framework. For example the FlightFinder widget would expose the data shown for the Task FlightFinder shown above. This allows the retrieval engine to retrieve the proper widget if any of the words in the tag e.g. cheap tickets flights flight vacations occur. It allows the widget to be called with any of the slot parameters e.g. Arrival City . . . Adults . . . Children specified as well. Thus when the widget is created the task metadata must be created with it through a well defined task API. By adhering to a strict task API a widget is capable of being found and having its slots filled using a centralized Task Reasoning entity i.e. adaptive semantic reasoning engine . This ensures consistency of the ranking algorithms and the ability to find the best task at the appropriate time. Optionally the widget can pass user feedback to the system to improve both the retrieval and slot filling models e.g. a user who enters the query I want 2 tickets departing Boston for Seattle would end up setting Adults 2 Departure City Boston and Arrival City Seattle and that feedback can be used to map tickets FlightFinder and departure Departure City and the like.

In cases where additional information is required or confirmation is needed the widget is responsible for that process.

In view of the exemplary systems shown and described above methodologies that may be implemented in accordance with the embodiments will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the embodiments are not limited by the order of the blocks as some blocks may in accordance with an embodiment occur in different orders and or concurrently with other blocks from that shown and described herein. Moreover not all illustrated blocks may be required to implement the methodologies in accordance with the embodiments.

The embodiments may be described in the general context of computer executable instructions such as program modules executed by one or more components. Generally program modules include routines programs objects data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various instances of the embodiments.

In a flow diagram of a method of facilitating widget searching in accordance with an aspect of an embodiment is shown. The method starts by obtaining task associated data from at least one widget . The task associated data can include but is not limited to widget task capabilities and or widget slot information for performing a task and the like and is based upon aspects of ADAPTIVE TASK FRAMEWORK mechanisms U.S. patent application Ser. Nos. 11 270 393 and 11 270 407 . The task associated data is employed to facilitate in selecting an appropriate widget for a given user widget associated query . Semantic reasoning aspects from ADAPTIVE SEMANTIC REASONING ENGINE see U.S. patent application Ser. No. 11 290 076 are typically utilized to facilitate this process. The query is processed to determine an appropriate task and or slot information that can be utilized to pre fill widget slots. The task associated data is then utilized to determine best guess slot filling for the selected widget . The selected widget with appropriate slots filled is then called ending the flow .

Looking at another flow diagram of a method of facilitating widget searching in accordance with an aspect of an embodiment is depicted. The method starts by utilizing a calling application to obtain task associated data from at least one widget . A calling application can include but is not limited to applications such as search engines and or toolbars and the like. The task associated data can include but is not limited to widget task capabilities and or widget slot information for performing a task and the like and is based upon aspects of ADAPTIVE TASK FRAMEWORK mechanisms U.S. patent application Ser. Nos. 11 270 393 and 11 270 407 . The task associated data is then passed from the calling application to an adaptive task reasoning entity . The adaptive task reasoning entity utilizes at least in part semantic reasoning aspects from ADAPTIVE SEMANTIC REASONING ENGINE see U.S. patent application Ser. No. 11 290 076 . The adaptive task reasoning entity can be but is not limited to a component and or a system that performs task reasoning. The adaptive task reasoning entity is then employed to facilitate in selecting an appropriate widget for a given user widget associated query and to determine best guess slot filling for the selected widget . The selected widget and best guess slot filling from the adaptive task reasoning entity is then passed to the calling application . The selected widget with filled slots is then invoked via the calling application ending the flow .

Turning to a flow diagram of a method of facilitating widget searching utilizing user feedback in accordance with an aspect of an embodiment is illustrated. The method starts by obtaining a widget associated query from a user . The query can be obtained directly and or indirectly e.g. via a Web browser etc. from the user. Adaptive task reasoning is then employed to facilitate in determining an appropriate widget selection for the query and widget best guess slot filling . The adaptive task reasoning is based on at least in part semantic reasoning aspects from ADAPTIVE SEMANTIC REASONING ENGINE see U.S. patent application Ser. No. 11 290 076 . The selected widget with filled slots is then invoked for utilization by the user . User feedback regarding the selected widget and or the slot filling is then obtained to improve adaptive task reasoning widget selection and or slot filling ending the flow . An adaptive semantic reasoning engine can be utilized to facilitate performance improvements on the widget selection process and or the widget slot matching filling process. The adaptive reasoning engine can employ statistical learning models e.g. Hidden Markov Models HMM for semantic slot filling Na ve Bayesian models for Information Retrieval IR Max Entropy Minimum Divergence MEMD for ranking and or query and context to asset mapping .

In order to provide additional context for implementing various aspects of the embodiments and the following discussion is intended to provide a brief general description of a suitable computing environment in which the various aspects of the embodiments can be performed. While the embodiments have been described above in the general context of computer executable instructions of a computer program that runs on a local computer and or remote computer those skilled in the art will recognize that the embodiments can also be performed in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations including single processor or multi processor computer systems minicomputers mainframe computers as well as personal computers hand held computing devices microprocessor based and or programmable consumer electronics and the like each of which can operatively communicate with one or more associated devices. The illustrated aspects of the embodiments can also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the embodiments can be practiced on stand alone computers. In a distributed computing environment program modules can be located in local and or remote memory storage devices.

With reference to an exemplary system environment for performing the various aspects of the embodiments include a conventional computer including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The processing unit can be any commercially available or proprietary processor. In addition the processing unit can be implemented as multi processor formed of more than one processor such as can be connected in parallel.

The system bus can be any of several types of bus structure including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of conventional bus architectures such as PCI VESA Microchannel ISA and EISA to name a few. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer such as during start up is stored in ROM .

The computer also can include for example a hard disk drive a magnetic disk drive e.g. to read from or write to a removable disk and an optical disk drive e.g. for reading from or writing to a CD ROM disk or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of data data structures computer executable instructions etc. for the computer . Although the description of computer readable media above refers to a hard disk a removable magnetic disk and a CD it should be appreciated by those skilled in the art that other types of media which are readable by a computer such as magnetic cassettes flash memory digital video disks Bernoulli cartridges and the like can also be used in the exemplary operating environment and further that any such media can contain computer executable instructions for performing the methods of the embodiments.

A number of program modules can be stored in the drives and RAM including an operating system one or more application programs other program modules and program data . The operating system can be any suitable operating system or combination of operating systems. By way of example the application programs and program modules can include a widget searching scheme in accordance with an aspect of an embodiment.

A user can enter commands and information into the computer through one or more user input devices such as a keyboard and a pointing device e.g. a mouse . Other input devices not shown can include a microphone a joystick a game pad a satellite dish a wireless remote a scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but can be connected by other interfaces such as a parallel port a game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor the computer can include other peripheral output devices not shown such as speakers printers etc.

It is to be appreciated that the computer can operate in a networked environment using logical connections to one or more remote computers . The remote computer can be a workstation a server computer a router a peer device or other common network node and typically includes many or all of the elements described relative to the computer although for purposes of brevity only a memory storage device is illustrated in . The logical connections depicted in can include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment for example the computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem e.g. telephone DSL cable etc. or is connected to a communications server on the LAN or has other means for establishing communications over the WAN such as the Internet. The modem which can be internal or external relative to the computer is connected to the system bus via the serial port interface . In a networked environment program modules including application programs and or program data can be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means e.g. wired or wireless of establishing a communications link between the computers and can be used when carrying out an aspect of an embodiment.

In accordance with the practices of persons skilled in the art of computer programming the embodiments have been described with reference to acts and symbolic representations of operations that are performed by a computer such as the computer or remote computer unless otherwise indicated. Such acts and operations are sometimes referred to as being computer executed. It will be appreciated that the acts and symbolically represented operations include the manipulation by the processing unit of electrical signals representing data bits which causes a resulting transformation or reduction of the electrical signal representation and the maintenance of data bits at memory locations in the memory system including the system memory hard drive floppy disks CD ROM and remote memory to thereby reconfigure or otherwise alter the computer system s operation as well as other processing of signals. The memory locations where such data bits are maintained are physical locations that have particular electrical magnetic or optical properties corresponding to the data bits.

It is to be appreciated that the systems and or methods of the embodiments can be utilized in widget search facilitating computer components and non computer related components alike. Further those skilled in the art will recognize that the systems and or methods of the embodiments are employable in a vast array of electronic related technologies including but not limited to computers servers and or handheld electronic devices and the like.

What has been described above includes examples of the embodiments. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the embodiments but one of ordinary skill in the art may recognize that many further combinations and permutations of the embodiments are possible. Accordingly the subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

