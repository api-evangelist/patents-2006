---

title: Java application framework for use in a content delivery network (CDN)
abstract: An application deployment model for enterprise applications to enable applications to be deployed to and executed from a globally distributed computing platform, such as an Internet content delivery network (CDN). According to the invention, application developers separate their Web application into two layers: a highly distributed edge layer and a centralized origin layer. In a representative embodiment, the edge layer supports a servlet container that executes a Web tier, typically the presentation layer of a given Java-based application. Where necessary, the edge layer communicates with code running on an origin server to respond to a given request. In an alternative embodiment, the edge layer supports a more fully-provisioned application server that executes both Web tier (e.g., presentation) and Enterprise tier application (e.g., business logic) components. In either case, the inventive framework enables one or more different applications to be deployed to and executed from the edge server on behalf of one or more respective entities.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08392912&OS=08392912&RS=08392912
owner: Akamai Technologies, Inc.
number: 08392912
owner_city: Cambridge
owner_country: US
publication_date: 20061023
---
This application is a division of Ser. No. 10 340 206 filed Jan. 10 2003 now U.S. Pat. No. 7 127 713 which application was based on and claimed priority to Ser. No. 60 347 481 filed Jan. 11 2002.

The present invention relates generally to an application deployment model for use in a content delivery network.

Enterprises can expand their business increase efficiency and enable new revenue streams by extending their business applications over the Internet to customers partners and suppliers. One way to enable enterprises to shift the operational burden of running a reliable and secure Web presence is to outsource that presence in whole or in part to a service provider such as a content delivery network CDN . A content delivery network is a collection of content servers and associated control mechanisms that offload work from Web site origin servers by delivering content e.g. Web objects streaming media HTML and executable code on their behalf to end users. Typically the content servers are located at the edge of the Internet. A well managed CDN achieves this goal by serving some or all of the contents of a site s Web pages thereby reducing the customer s infrastructure costs while enhancing an end user s browsing experience from the site. In operation the CDN uses a request routing mechanism to locate a CDN edge server electronically close to the client to serve a request directed to the CDN. Sites that use a CDN benefit from the scalability superior performance and availability of the CDN service provider s outsourced infrastructure.

Many enterprises such as those that outsource their content delivery requirements also implement their business services as multi tier n tier applications. In a representative n tiered application Web based technologies are used as an outer a first or presentation tier to interface users to the application and one or more other tiers comprise middleware that provides the core business logic and or that integrates the application with existing enterprise information systems. The Java 2 Platform Enterprise Edition J2EE is a technology and an associated component based model that reduces the cost and complexity of developing such multi tier enterprise services. The J2EE runtime environment defines several types of application components that can be used to build services. These include a Web tier components e.g. servlets JSP pages Java beans filters and web event listeners which are components that typically execute in a web server and respond to HTTP requests from web clients and b Enterprise tier components e.g. session beans entity beans and message driven beans which may be developed as Enterprise JavaBeans EJB that include the business logic and that execute in a managed environment to support transactions. Runtime support for J2EE application components are provided by so called containers with a Web container supporting the Web tier components and an Enterprise container supporting the Enterprise tier components. Containers execute the application components and provide utility services. J2EE compliant servers provide deployment management and execution support for conforming application components.

It would be desirable to be able to provide a framework by which such server side Java applications as well as other Web services could be deployed in a distributed computing environment such as a content delivery network to enable application processing on the edge of the Internet.

It is an object of the present invention to provide an application deployment model for enterprise applications to enable such applications to be deployed to and executed from a globally distributed computing platform such as an Internet content delivery network CDN .

It is a more specific object of the invention to provide a framework by which Java based applications and Web services are deployed onto a distributed computing platform so that enterprises can take advantage of a multi tier distributed application model.

Another object of the present invention is to provide a deployment model for a content delivery network that enables support for a Java based Web container or Enterprise container or both so that applications or application components can be executed on the edge of the Internet.

A more general object of this invention is to provide a content delivery network with the ability to execute application code on an edge server. Using the present invention content is created on the edge of the network by running application code.

A specific object of the invention is to provide an edge application deployment model that supports execution of Web tier components e.g. Java server pages JSP servlets and Java beans on the edge of the Internet close to end users thus avoiding network latency and the need for costly infrastructure over provisioning while improving the performance and reliability of mission critical enterprise applications.

In a preferred embodiment the present invention is a CDN Java application framework offering comprising Java enabled edge servers. This framework takes advantages and leverages the mapping load balancing and management systems that are similar to the ones used with known CDN offerings. In a first aspect the present invention enables the offloading and execution of the presentation or Web tier of n tier Internet applications. JSP Servlets Java beans and custom tags which are executed within an application server s servlet container are executed at the edge of the Internet close to the end user. In an alternate embodiment in addition to the Web tier at least some or all of the Enterprise tier of the application is also deployed to and executed on a given edge server. The Enterprise tier typically comprises middleware such as entity beans session beans and message driven beans that implement the application s business logic and that provide local or remote database support.

According to another aspect of the present invention developers preferably separate their Web application into two layers a highly distributed edge layer and a centralized origin layer. In a representative embodiment the edge layer supports a Web container so that the following technologies are supported Java server pages JSPs servlets Java beans Java helper classes and tag libraries. Preferably communications between the edge and the origin use conventional communication protocols such as RMI and SOAP. Any protocol that can be tunneled over HTTP such as JDBC can also be supported.

Preferably an application is run on the edge server in its own application server instance in its own Java virtual machine JVM . In a preferred embodiment a content delivery network service provider operates a CDN with at least one edge server that includes multiple application server JVM instances with each instance associated with a given CDN customer. Resource utilization by the multiple application server instances are monitored and application server processes that over utilize given resources e.g. memory CPU disk and network I O are terminated. In addition to resource management preferably security restrictions are imposed on applications running in each application server JVM process. This is sometimes referred to as sandboxing. These restrictions include for example file system read write restrictions limitations on socket opening and usage restrictions on thread starting stopping and modification as well as code restrictions that prevent applications from reading certain application server classes. Preferably a given application cannot run or load code belonging to other applications it cannot load data belonging to another application it cannot read or write arbitrary files on the file system and it cannot make native kernel calls or load libraries that make native calls.

By providing Web containers at the edge the present invention provides the ability to off load up to the entire Web tier of n tier Internet applications. Web components executed within the application server s servlet container can be executed at the edge of the Internet close to the end user.

In an illustrative operation an end user makes a request that is directed to a CDN edge server. If the request calls for Java processing and is the first request for the particular application the application is retrieved from the origin unpacked and loaded into the application server. If the application component e.g. a Web application archive or WAR file is already cached on the edge server the appropriate servlet or JSP page is used to generate the response. As needed the edge server contacts the origin site with those portions of the application that need to run on the origin e.g. access to a central data resource or other non edgeable servlet. The parts of the page that can best be served from the edge are processed at the edge while those parts that need to be processed at the origin are processed at the origin and the results are served back to the end user from the edge server.

Application components are delivered to the edge servers on an as needed basis. In an alternate embodiment it is desirable to pre deploy an application or an application component based on some prediction of expected future need for that application or component or for purposes of fault tolerance. Thus a given application or component thereof may be delivered to a particular edge server and initialized and started irrespective of whether an end user request has been received at the server.

The foregoing has outlined some of the more pertinent features of the present invention. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed invention in a different manner or by modifying the invention as will be described.

The present invention is a Java application framework that leverages Internet CDN architecture and functionality such as generally described below. Familarity with Java programming conventions and the J2EE architecture are presumed. Additional information about J2EE is available in the publication titled 2 1.3 July 2001 which is available from Sun Microsystems.

By way of background it is known in the prior art to deliver digital content e.g. HTTP content streaming media and applications using an Internet content delivery network CDN . A CDN is a network of geographically distributed content delivery nodes that are arranged for efficient delivery of content on behalf of third party content providers. Typically a CDN is implemented as a combination of a content delivery infrastructure a request routing mechanism and a distribution infrastructure. The content delivery infrastructure usually comprises a set of surrogate origin servers that are located at strategic locations e.g. Internet network access points Internet Points of Presence and the like for delivering content to requesting end users. The request routing mechanism allocates servers in the content delivery infrastructure to requesting clients in a way that for web content delivery minimizes a given client s response time and for streaming media delivery provides for the highest quality. The distribution infrastructure consists of on demand or push based mechanisms that move content from the origin server to the surrogates. An effective CDN serves frequently accessed content from a surrogate that is optimal for a given requesting client. In a typical CDN a single service provider operates the request routers the surrogates and the content distributors. In addition that service provider establishes business relationships with content publishers and acts on behalf of their origin server sites to provide a distributed delivery system.

As seen in an Internet content delivery infrastructure usually comprises a set of surrogate origin servers that are located at strategic locations e.g. Internet network access points and the like for delivering copies of content to requesting end users . A surrogate origin server is defined for example in IETF Internet Draft titled Requirements for Surrogates in the HTTP dated Aug. 9 2000 which is incorporated herein by reference. The request routing mechanism allocates servers in the content delivery infrastructure to requesting clients. The distribution infrastructure consists of on demand or push based mechanisms that move content from the origin server to the surrogates. A CDN service provider CDNSP may organize sets of surrogate origin servers as a group or so called region. In this type of arrangement a CDN region typically comprises a set of one or more content servers that share a common back end network e.g. a LAN and that are located at or near an Internet access point. Thus for example a typical CDN region may be co located within an Internet Service Provider ISP Point of Presence PoP . A representative CDN content server is a Pentium based caching appliance running an operating system e.g. Linux Windows NT Windows 2000 and having suitable RAM and disk storage for CDN applications and content delivery network content e.g. HTTP content streaming media and applications . Such content servers are sometimes referred to as edge servers as they are located at or near the so called outer reach or edge of the Internet. The CDN typically also includes network agents that monitor the network as well as the server loads. These network agents are typically co located at third party data centers or other locations. Mapmaker software receives data generated from the network agents and periodically creates maps that dynamically associate IP addresses e.g. the IP addresses of client side local name servers with the CDN regions.

Content may be identified for delivery from the CDN using a content migrator or rewrite tool operated for example at a participating content provider server. Tool rewrites embedded object URLs to point to the CDNSP domain. A request for such content is resolved through a CDNSP managed DNS to identify a best region and then to identify an edge server within the region that is not overloaded and that is likely to host the requested content. Instead of using content provider side migration e.g. using the tool a participating content provider may simply direct the CDNSP to serve an entire domain or subdomain by a DNS directive e.g. a CNAME . In either case the CDNSP may provide object specific metadata to the CDN content servers to determine how the CDN content servers will handle a request for an object being served by the CDN. Metadata as used herein refers to a set of control options and parameters for the object e.g. coherence information origin server identity information load balancing information customer code other control codes etc. and such information may be provided to the CDN content servers via a configuration file in HTTP headers or in other ways. The Uniform Resource Locator URL of an object that is served from the CDN in this manner does not need to be modified by the content provider. When a request for the object is made for example by having an end user navigate to a site and select the URL a customer s DNS system directs the name query for whatever domain is in the URL to the CDNSP DNS request routing mechanism. Once an edge server is identified the browser passes the object request to the server which applies the metadata supplied from a configuration file or HTTP response headers to determine how the object will be handled.

As also seen in the CDNSP may operate a metadata transmission system comprising a set of one or more servers to enable metadata to be provided to the CDNSP content servers. The system may comprise at least one control server and one or more staging servers each of which is typically an HTTP server e.g. Apache . Metadata is provided to the control server by the CDNSP or the content provider e.g. using a secure extranet application and periodically delivered to the staging servers . The staging servers deliver the metadata to the CDN content servers as necessary.

The present invention is a CDN Java application framework offering comprising Java enabled edge servers. A given edge server the machine such as illustrated above in is assumed to include application server code. As is well known an application server is a software platform sometimes called middleware on which applications can be deployed. It provides useful utility services and functions to applications. There are currently several major types of application servers Java based J2EE and Microsoft .NET. Java of course is a programming language and a platform and the programming language is object oriented and platform independent. Applications written in Java are translated into Java byte code which code is then run on intepreted by a Java Virtual Machine JVM . In a preferred embodiment of the invention given edge servers in the CDN are provisioned with a Java application server and additional code to enable Java applications or application components to be executed from the edge of the Internet. The framework can take advantage of and leverage the mapping load balancing and management systems used with known CDN offerings such as the CDN illustrated in which is merely representative . In a first embodiment the application server is a servlet container e.g. Apache Tomcat in which case the present invention enables the offloading and execution of the Web tier of n tier Java based applications. JSP servlets Java beans and custom tags which are executed within an application server s servlet container are executed at the edge of the Internet close to the end user. The Web tier is typically the front end of a J2EE server. In an alternate embodiment in addition to the Web tier at least some or all of the Enterprise tier of the application is also deployed to and executed on a given edge server. The Enterprise or business tier typically hosts application specific business logic and provides system level services such as transaction management concurrency control and security.

The present invention advantageously enables a J2EE compliant application to run in an edge origin server environment. In particular the inventive framework preferably leverages a distributed computing platform by distributing the application across the origin and the CDN. As noted above typically the application contains servlets JSPs filters tag libraries and Java beans helper classes in a Web tier and enterprise beans in an enterprise tier. Separation of the Web tier from the Enterprise tier with execution of the Web tier e.g. in a Web container on the edge servers and the Enterprise tier e.g. in an Enterprise container on the origin site is illustrated in . In this embodiment the edge enabled version of the application typically comprises two cooperating applications an edge side application and an origin side application. Components of the Web tier may be packaged as a Web Archive WAR and components of the Enterprise tier may be packaged as an Enterprise Archive EAR . As described above the creation of these two applications typically requires decisions based on knowledge of the application namely decisions about which processes should run on the origin and which at the edge.

The inventive framework is not limited to running the Enterprise tier in an Enterprise container on the origin however. As illustrated in the Enterprise tier may also be distributed out to the edge servers and executed with the Web tier in an application server . In this embodiment the Enterprise tier for illustrative purposes only comprises one or more Enterprise JavaBeans EJB elements as session beans entity beans and message driven beans . To support the Enterprise tier session beans preferably are persisted into globally coherent state. Entity beans can be used to replicate at the edge server read only databases and to provide transparent tunneling e.g. using JDBC over SOAP to an enterprise database.

In a representative embodiment an application server is IBM WebSphere 5.0 application server WAS . IBM WebSphere uses JVM Java Virtual Machine 1.3.1 available from IBM. In in contrast the Web tier is executed in a Web container . In this example the Web tier comprises such elements as JSP pages servlets and JavaBeans . A representative Web container is provided by Apache Tomcat servlet container which uses the JVM in JDK 1.3.104 available from Sun Microsystems. Of course these components are merely exemplary and are not meant to be limiting. Preferably a Web or Enterprise container runs in multiple instances on CDN edge servers preferably under application isolation as will be described.

In particular preferably each application is run in an isolated environment via a sandboxing mechanism implemented e.g. in the JVM. Generally sandboxing is accomplished by monitoring the resource e.g. CPU memory disk network I O utilization of each application server process. If an application server process over utilizes resources it is terminated and a new application server is started. If an application server induces multiple restarts dues to excessive resource utilization it is blocked from causing another restart. Preferably a separate application server process is used for each CDN customer as this prevents one customer s application from stealing resources from another customer s application. It also isolates application server restarts. In addition each application server process preferably is run within its own sandboxed directory outside of which it cannot read or write files. This prevents one customer s application from interfering with another customer s application or one customer s application accessing another customer s data. Additional details regarding resource management and sandboxing are set forth below.

The following are some additional guidelines for edge enabling an application for the framework in an embodiment in which just the Web tier is located on the edge. In this embodiment enterprise beans run at the origin and calls to the enterprise beans including use of home or remote interfaces preferably do not exist in edge located filters servlets helper classes or beans. Preferably direct calls to origin based system resources such as a database do not exist in edge located servlets helpers or beans. In such case however database connectivity is provided preferably using a Type 3 JDBC driver. Also any filters servlets or JSPs that require servlet context preferably do not access the ServletContext of a different web application. In this embodiment Web applications can use ServletContext attributes to store state. For security reasons certain web components may need to run at the origin. The web application preferably adheres to the distributable conventions described in Servlet Specification 2.3 including marking the web application as distributable in its deployment descriptor. Web components in an execution sequence followed in response to a request preferably run entirely at the origin or entirely at the edge in response to this request. A web application edge component that uses request dispatching include forward preferably can only dispatch to another edge web application component the same is true for an origin component. However the source or target dispatched edge component is free to contact the origin to send data retrieve data or the like.

An execution sequence normally consists of filters servlets and JSPs that are involved in response to a request but preferably it does not include external resources that are used via connections to the origin such as HttpURLConnection . Preferably the same request and response argument are shared by the filters that are executed and by servlets and JSPs that include or forward to each other to form the execution sequence. The definition is dynamic because a servlet could be included in edge side and origin side execution sequences without contradiction.

With knowledge of the legal execution requests in the application and the set of requests that cause these execution sequences to be followed a developer can edge enable the application. In one embodiment this process involves identifying components as origin only edge only or both. Origin only components can run on the origin preferably unchanged. Edge only components run only at the edge. The both designation applies to a servlet that could be on an execution path to an origin only servlet and also on an execution path in which all servlets are edgeable. In this case the servlet needs to be installed at the origin as well as the edge. The both category might also apply to a servlet serving a comparable function at the edge and at the origin. Some components may best be split into edge and origin components.

To construct the request sets and corresponding execution sequences the deployment descriptor web.xml can be used to obtain servlet mapping values and URL patterns corresponding to them. For those components that should be split into edge and origin components it is desirable to create an edge side component of the same type and one or more origin side servlets. This can be done by factoring out the origin side functionality to create the edge side component and using servlet facades for the origin side system calls. Components needed both at the edge and at the origin are marked both and the remaining components are marked edge.

An edge dispatcher is then constructed. An edge dispatcher is a single entry point into the web component at the edge. This dispatcher servlet examines an input request and decides to proxy it to the origin or to forward it to a servlet JSP on the edge. If the pre edge enabled web component i.e. without the dispatcher already has a single entry point then the dispatcher functionality can be built into this entry point itself. To construct this component consider each request set and its corresponding execution sequence. If the execution sequence includes a component marked origin only then the corresponding request set must be proxied to the origin and the filters at the edge must be configured to ignore these requests . Otherwise the request can be satisfied at the edge and the edge dispatcher forwards it to the first edge side servlet or JSP in the execution sequence.

In addition to edge enable the application some deployment information in the web.xml deployment descriptor must be altered in particular the servlet mapping and filter mapping values to make sure that all requests are routed through the edge dispatcher. Also filters preferably are not applied twice e.g. first at the edge and then at the origin on requests that are proxied to the origin. Alternatively one could set up edge filters and origin filters. The webapp must adhere to the distributable conventions described in Servlet Specification 2.3 including the fact that it must also be marked as distributable in its deployment descriptor. The deployment information in the deployment descriptor is altered particularly the servlet mapping and filter mapping values to make sure that all requests that routed through the edge dispatcher and that filters are appropriately applied.

Typically the edge dispatcher receives the request and determines its handling. As illustrated in which is merely exemplary the request may be processed entirely at the edge by the edge components . Alternatively the dispatcher may serve as a proxy and send the request to the origin which might in turn call origin processes such as enterprise beans which return the response to the proxy which in turn responds to the client. In a split scenario the dispatcher sends the request to the edge side component . The edge component communicates with the origin side split component which in turn may call origin processes such as the beans . The response return via the edge side component .

In the above approach a servlet JSP on the edge the proxy marshals arguments and sends them to a servlet at the origin the broker which parses the arguments and performs the requisite method invocation. Then the broker marshals the return value and sends it back to the proxy. The broker exports origin side functionality to the edge and serves as a facade for this functionality. In particular any communication between an edge servlet JSP and an enterprise bean is preferably via a servlet facade at the origin. An alternative to the design is to have a single origin side servlet that mediates between the edge and all serlet facades at the origin. This provides a single entry point for edge origin requests. An origin dispatcher could itself provide all the functionality of all servlet facades that would otherwise exist at the origin.

The following describes modifications to a Java application server specifically its servlet container component to integrate into the inventive framework. This application server is executed on an edge server which as noted above is a machine running commodity hardware and an operating system. As illustrated in a preferred architecture is implemented via out of process architecture and comprises an edge server process and multiple Java application server processes . An edge node in the content delivery network preferably has a single edge server application that can spawn multiple child processes each containing an application server instance as was illustrated in . Each child process preferably is configured for a Java Edge Services API JESAPI which according to the invention is an integration framework for a Java application server. Generally JESAPI interfaces the edge server manager process to the application server instances to facilitate various administration functions namely the starting stopping and reloading of WAR and EAR files the monitoring of the health of the various application server instances the monitoring of resource usage by the application server instances and the collecting of data from the instances to facilitate reporting and billing for use of the platform. As illustrated in an HTTP HTTPS request first connects to the edge server process . The edge server process preferably maps the request to a context path that is preferably specified in a metadata configuration from the customer configuration data. The edge server process then fetches and unpacks an associated web application archive WAR on a file system and installs the archive. Finally the edge server process modifies the request to be handled by an application server instance and proxies it using sockets. Additionally the edge server process preferably employs bi directional communication with each JESAPI application server child instance transmitting such information as control data and resource usage.

The application wrapper acts as the bootstrap logic for the application server process . The wrapper is customized to the application server type and acts as glue code connecting all the various components of the process. The wrapper component provides a JESAPI implementation singleton specific for the application server type which may vary. In particular the wrapper initializes JESAPI performs any necessary runtime configuration of the application server process starts the server and notifies JESAPI when the server is ready to process requests. Because it is the entry point for the application the wrapper must initialize JESAPI and the application server with the data supplied to it by the edge server process element in in the form of arguments Java system properties and the like . The data includes for example an application server instance id used by JESAPI and the socket port the servlet container must be on for HTTP connections. The application wrapper preferably configures the edge server to only accept HTTP socket connections. In an illustrative embodiment the application server process must accept connections bound for the local loopback host and on the port specified by the edge server process. Additionally the application wrapper provides and registers any handlers with the application server necessary for integration such as protocol handling and logging. Preferably the application wrapper receives each application server log event server and per webapp and routes it to JESAPI. The log handling API provided by the application server preferably invokes the handler in the same thread that issued the log message and this thread forwards the message to JESAPI. Because application server log messages are redirected to JESAPI via the application wrapper log handlers file logging can be disabled in the application server. Other standard data streams from the application server likewise are redirected to JESAPI via the application wrapper.

Preferably and as described below the application server process uses J2EE security policies to restrict the functionality of web applications as well as server code itself. Preferably the server code is locked down as much as possible to avoid security loopholes. Also the JESAPI implementation singleton and any classes that are part of the application wrapper preferably have the same protection as server classes. In addition preferably there are appropriate security restrictions imposed on the entire process including server and web application logic .

Aside from the features offered by the standard J2EE security permissions additional restrictions should be imposed for the applications sometimes referred to as webapps . Preferably web applications are prevented from creating or modifying threads and thread groups. If a web application runs in a non system thread the application server process provides a way to address security permissions. A web application also should be allowed to perform JNDI and file read only operations recursively from its base path the unpacked WAR file directory root . Preferably the application server dynamically creates security permissions for the web application at runtime.

Because web applications from different customers preferably can run on the same server the servlet container preferably is configurable to allow disallow a web application in one context to access the ServletContext instance of a different context when servlets attempt to call ServletContext.getContext depending on the configuration for the web application null may be returned. Preferably this operation is specified per web application at install time. As an added level of security an external shared object preferably traps system calls made in the application server process and performs access control checks as will be described below.

Prior to forwarding any HTTP requests for a particular web application in the application server the edge server process element in is responsible if necessary for unpacking the associated WAR to a base directory on the file system and installing the web application components in the application server. The edge server process notifies the application server process to install and invalidate a web application using JESAPI supplying the web application configuration at runtime. The edge server process is also responsible for managing which contexts are installed in each application server instance. When the edge server process requests the application server to install a web application the edge server process sends a control request to JESAPI supplying the web application s context path its base directory path and a flag that determines if the web application will be able to access other servlet contexts e.g. using ServletContext.getContext . The JESAPI implementation singleton then processes this request e.g. by invoking the application server s dynamic web application installation mechanism. After the web application gets installed the edge server process sends requests for it to the application server. When the edge server process is ready to invalidate a particular web application it stops sending requests to that web application instance and sends a web application uninstallation control request to JESAPI identifying the web application with its context path.

To support web application revisions by hot swapping the edge server process preferably generates an artificial context path used for web application installation invalidation and regular requests in the application server. The context path preferably consists of the context id a hash of various values that identify the web application instance including the host name original context path WAR contents and revision number. In a preferred publishing model applications are downloaded and unpacked to the application server as has been described. If a new application version e.g. Version 1.1 is published while an old application version e.g. Version 1.0 is active the new application version is placed in the same process as the original version and new requests are directed into the new application version. When the old application version drains of requests that application version is terminated and appropriate clean up effected. Preferably both versions of the same customer application run in the same process although this is not a requirement. This hot swapping technique is illustrated in .

With explicit web application installation the edge server process thus sends a web application install command to JESAPI and waits for a successful response before forwarding any HTTP requests associated with the web application to the application server. If an explicit install request occurs because the edge server process encounters a request for a not yet installed web application there is added latency for processing that initial request because of the explicit install roundtrip. As an alternative an implicit web application install may be performed to minimize the delay incurred by the first request for a web application that is not yet installed. Instead the edge server process forwards the request to pre installed JESAPI webapp at JESAPI startup in the application server that will both install the specified web application and have that web application process the original request. This is achieved in a single pass between the edge server process and the application server process. To accomplish this the edge server procsess modifies the original HTTP request to provide the added data to the JESAPI web application so it can install the application and then have it process the request.

A preferred request processing operation is illustrated in . Preferably JESAPI requires the application server to assign a distinct thread to process each request. The same thread preferably makes all JESAPI calls for processing that request. After the edge server process receives a request and takes care of installing the associated the webapp as necessary in the application server but before forwarding it to the installed webapp context the edge server process modifies the HTTP request to correctly get processed by the application server and a JESAPI Servlet Filter. Specifically the edge server process alters the request s URI to contain the artificial context path so the application server can correctly map the request to the previously installed unique context instance . The edge server process also inserts various JESAPI internal headers that provide the JESAPI Servlet Filter with more data about how to handle the request.

In particular resources consumed by each child application server process are monitored preferably by shared object components that are loaded by each application server process at startup. These include a Java Edge Services API JESAPI shared object and an intercept shared object . The JESAPI shared object implements specific JESAPI Java native calls and it is responsible for communicating across the shared memory segment with the Java manager subsystem . The intercept shared object preferably loads various intercept system calls such as open close gethostbyname and the like. By intercepting system calls the manager subsystem can prevent access to some calls or make intermediate calculations or accrue statistics or the like before making the real system call that the application server intended to make. The Intercept shared object reports any resource utilization to the JESAPI shared object which then reports it across the shared memory segment to the Java manager subsystem.

The following resources may be monitored for each application server process memory the memory used by the JVM s internal Java heap i.e. the heap in which it does memory management for Java objects allocated by the application server and the webapps that run in the application server CPU the CPU time consumed for each request while it was active inside the application server disk the disk operations that the application server performs including disk operations done as a result of a client request the JESAPI shared object may also check whether a disk read was from disk or from buffer cache so that flits can be properly attributed to the request and network the number of sockets that are opened by each application server process to fetch include URLs. The Java manager subsystem performs resource management e.g. through a set of policies based on resource utilization. Thus for example the Java manager will kill a child application server process for over utilization of the following resources in the following ways memory if the application server s Java heap uses more memory than a configurable amount set in customer metadata it will be killed runaway requests a runaway request is a request that has been processing for an unreasonible amount of time a configurable number and if an application server generates a certain configurable number of runaways it will be killed open sockets if an application server reaches a configurable limit of open sockets for which it has never called close it will be killed or the like. This rate limiting of resources ensures that no application server instance can become an exclusive user of the server s resources.

In addition to the above described resource management the Java Security Manager framework facilitates sandboxing by imposition of security restrictions to web applications running in each application server process. Preferably this is achieved through a combination of a security policy file and a Java Security Manager implementation. The following restrictions preferably are placed on Java web applications in this manner file system customer web applications cannot read or write to the file system although they can read files from within their own WAR file such as static html socket customer web applications cannot open Java sockets threads customer web applications are not allowed to start stop modify Java threads and code customer web applications are prevented from reading JESAPI or application server classes. In the case of sockets preferably a customer webapp can fetch include files through the

HttpURLConnection Java class that is intercepted by JESAPI code and that forces the include to go only through the edge server manager process and monitors the number of open connections . In addition preferably the framework allows customers to open raw Java sockets. This is because the previously mentioned intercept shared object will intercept all of the socket API calls and monitor the number of connections made by the application server process. The intercept object will then connect to the edge server manager process using the HTTP CONNECT method and the edge server manager process will then open a socket to the desired host.

The resource management sandboxing and security features described above are merely exemplary. Other techniques may be used for example resource management by user ID. In such case after each application server process is launched a setuid is performed setting the process to a unique user ID. Once set to this unique UID other operating system kernel features for resource management can be used. These include total thread limit file sytem quotas socket filters and the like. In addition this approach enables use of other system calls e.g. chroot to limit the application server process to a subset of the filesystem outside of which it will not be able to read or write.

One or ordinary skill in the art will appreciate that the JESAPI interface can be designed such as described above to support application servers unchanged. Alternatively a given application server vendor may modify given application server functionality as appropriate to enable the application server to run on the CDN server provider s edge server platform in which case certain changes to the servlet container may be necessary for it to be run on the edge server. Thus for example where possible a new subclass of an existing servlet container component should be created as needed and then modified to interface to the edge server manager. In either case preferably the edge server manager interfaces client requests to and from the edge server itself.

Some additional aspects of the edge enabled application framework are now described below and several examples are also provided.

When an edge server receives a request from a client preferably it first matches the request with an appropriate customer configuration file. The configuration file may be delivered to the edge servers via any convenient mechanism such as a CDN metadata transmission system as illustrated in . Of course any convenient technique for providing the customer configuration data to the edge servers can be used. If the customer configuration associates Java processing with the request the Java processor is engaged as has been described.

As noted above if the WAR file is already in the edge server the Java processor uses the applicable servlet or JSP page for Web tier processing to generate a response for incoming requests. A standard deployment descriptor preferably is used to properly map the requests to a servlet. If the Java application is not currently on the edge server it is retrieved from the origin site or from some other source. Because the retrieval process may cause a significant latency the application may be retrieved asynchronously while the initial request is tunneled to the origin server simultaneously. The output of the processed request is returned to the user. The executed servlet preferably remains in memory ready for the next user.

Servlets preferably are managed to make sure no process consumes an undue amount of resources. Proper resource monitoring and load balancing assures that no application affects another one running at the same time. The Java application may make requests for content through the network. The requests preferably are made through HTTP and HTTPS protocols. Remote Invocation of other Java resources is also preferably done through HTTP.

The origin server may remain an integral part to the edge application especially when just the Web tier is deployed on the edge network. In addition because some servlets rely on access to centralized resources not all requests can be processed by the edge server. In such case the origin site is responsible for fulfilling the non edgeable requests as well as answering any remote calls that might be made by the edge deployed application.

The following are the typical responsibilites of the origin site in such circumstances respond to RMI requests from the edge tier respond to HTTP requests from static and dynamic content set Host Response Headers HRH for controlling edge server behavior as necessary serve WAR files when requested by the edge servers and respond to JDBC requests from the edge tier.

The communication between the servlet on the edge server and the origin site preferably occurs through HTTP or HTTPS protocols as follows Remote Method Invocation RMI communication is tunneled through HTTP SOAP messages are exchanged over HTTP or HTTPS JDBC is tunneled over HTTP HTTPS responses to relational database queries are encoded in XML allowing the edge server to cache the results re use them with the future requests and minimizing the inter tier latency Servlet control methods e.g. RequestDispatcher.include and RequestDispatcher.forward are preferably supported regardless of whether the communication is edge to origin or origin to edge communication and custom communication solutions are supported provided messages are transported over HTTP or HTTPS. is illustrative of these techniques.

To ensure that the application is scalable and benefits from being on the edge the amount of bytes sent and the number of calls between edge and origin should be minimized. This can be accomplished for example through caching of the data on the edge and through the use of a data access facade instead of making multiple calls to a database in which case an edgeable servlet is used to call a non edgeable servlet to make the database calls on its behalf .

J2EE applications are encouraged to be modular and have a specific structure. The framework obtains the benefits of this decoupled and structured nature of many J2EE applications. The following is a brief summary of different approaches that application architects can use to take advantage of the framework.

A servlet may be deemed edgeable if the request contains all the information necessary for the creation of the correct response.

A servlet that utilizes content targeting information a user s country state city bandwidth or the like can also be delivered completely from the edge. An application programming interface API may be provided for accessing content targeting information which an application can use to customize the response. The servlet may use the API to get information about the end user.

The framework allows applications to easily cache and access data as XML. XML is a convenient platform agnostic way of generating storing and accessing the data. Many databases provide a straightforward way of producing XML from stored records. Caching XML content on the edge reduces the latency associated with retrieving data. Edge servers preferably contain JAXP and XML Query classes which enable simple parsing and manipulation of the cached XML files. Also applications can use XSLT processing in the Web applications to transform and present XML data that is retreived from the origin or a cache.

Web Services architecture defines how applications can access data and logic from other applications using standard XML and Internet protocols. Web services provide a simple mechanism that an edge server uses to communicate. Edge servers preferably include the necessary Java classes that enable SOAP communication with the services running on the origin or at third party sites.

JDBC calls preferably are tunneled to the origin. To minimize inter tier latency and reap the benefits of caching the response to JDBC calls can be cached and shared between different requests.

RMI can be used for object to object communication between the edge server and the origin. Edgeable applications can call object methods located remotely as if the object were local. Method invocations are preferably cached.

The following common patterns may be used when architecting and developing J2EE applications that run on a distributed Java platform. While many different design patterns are possible this description is intended to highlight some of the more common patterns their benefits and the situations when they are most applicable.

The information contained in the request such as HTTP header Cookie Referer etc Query String or HTTP POST body form field data uploaded data etc is sufficient for the edge application to produce a response.

In this example the edgeable servlet uses local class libraries to process the request and serve the response. The servlet may use relevant methods to verify the accuracy of the submitted data before providing the next form screen.

By testing for the presence of the relevant headers the servlet may respond with an appropriate version of HTML.

Response is determined by the content targeting information such as end user s locality or connectivity.

An application programming interface API may be provided for accessing content targeting information which an application can use to customize the response. The servlet will use the API to get information about the end user.

HTTP responses such as XML data tunneled JDBC responses as well as SOAP responses preferably are cached merely by the act of making a request through the edge server. Caching of HTTP responses is particularly useful when the same resource is being used multiple times by one or more servlets. An API allows for the application to make sure that the content freshness is maintained.

User preferences can be retrieved from the origin by making a request to a servlet that retrieves the properties from the database. This file could be a hash XML or the like. Subsequent requests for the same URL are served from the cache.

Alternatively the edgeable application may use an HTTP SOAP RPC calls to maintain the customer s state with the origin. Origin can provide all of the methods that act on the shopping cart as a web service. The SOAP RPC calls will change the state of the shopping cart when necessary however most of the time the shopping cart will only be read and not modified. All subsequent calls with the same version number would return a cached shopping cart.

Because the response has been cached a subsequent request to the URL with the same cart id will result in an identical response. If a user makes a transaction that changes the contents of the shopping cart the cart version number is incremented. After the version is modified future requests will result in a call to the origin. Current cart version number can be stored in a cookie or some other user specific properties object.

Often an application needs access to large amounts of data. XML is a convenient platform agnostic way of generating storing and accessing the data. Many databases provide a straightforward way of producing XML from the stored records. Caching XML content on the edge would reduce the latency associated with retrieving data.

A most simple scenario would be to simply make an HTTP request for the necessary data passing the query parameters if necessary . Preferably the process of requesting the data is enough to cache it. To control freshness of the object HTTP Headers on the server or the TTL parameter in the request can be used to specify how long data can be cached. Alternatively a data version number can be used to force a cache miss when the servlet thinks data may have changed. To access the data XML parsers can be used. Alternatively an XML Query implementation can be used to retrieve only the relevant records from the cached XML. When the content provider deems it necessary the cached catalog can be invalidated. The invalidation can occur programmatically e.g. by connecting to a managed SOAP invalidation service.

Different approaches exist for managing JDBC queries from the edge. One pattern works by caching common SQL query results. Another pattern caches a large data set but allows the application to read only the relevant data. The use of these patterns reduces the load on the database and minimizes the latency caused by inter tier communication.

The service provider preferably also provides a JDBC driver implementation which allows an edge server to communicate with the origin and place queries as if the database was running locally. Preferably this implementation also caches the results of the queries. Content freshness is maintained by setting an appropriate freshness mechanism on the served results specifying a time to live TTL upon calling of the content or using a versioning scheme. The JDBC driver preferably makes a SOAP call that allows for the edge server to cache and reuse the response.

One technique is to use a ResultsSetsObject to minimize the need for JDBC calls. This approach creates a single large object with the contents of the database. This is done with an expectation that another request will use results from this expanded set. If another servlet makes the same requests the same object will be returned. Results set caching classes can be used to traverses and access the retrieved data.

Leveraging the services provided by third parties is a useful way of leveraging competencies of others while minimizing the complexity of the application.

In cases where application uses multiple cacheable items that need to be in a consistent state with respect to each other instead of synchronizing each item with the origin a single object can act as a coherence mechanism that holds the versions IDs for the content.

A Coherence object having given properties is defined. This small object could be either tunneled to the origin or cached for a relatively short period of time and then consulted before the content is used. Consequently data could be cached for a long time yet the content provider still retains control over content freshness.

RMI can be used for object to object communication between the edge server and the origin. Edgeable applications can call object methods located remotely as if the object were local. This allows the application to leverage the unique capabilities of the origin and the edge as appropriate.

This approach is optimal when the object being used is closely tied to the origin and would not benefit from caching. If the object itself can be cached and only some methods require use of the origin consider using the Optimized RMI mechanism described next.

A web site providing driving directions requires the use of the origin to calculate the precise path however the edgeable servlet would prefer to manipulate a local object so that code would not have to be extensively modified.

Standard RMI invocation is used. Once an object is instantiated it works seamlessly as if it is running locally. This method can potentially increase the inter tier traffic causing severe performance degradations. In this example a CDN service provider specific JNDI client is used if the CDN does not run the JNDI service alternatively a request to a servlet on the origin could be made which would then result in the passing back of an RMI stub representing the instantiated object.

One drawback of using RMI objects is that any data access or method call requires communication with the origin. This pattern allows for those methods that can be invoked locally to be invoked in such manner.

This pattern applies to situations where the methods of the object that are used frequently do not actually require to be executed on the origin.

An edgeable object is created by sub classing the class of the remote object. The methods that need to be executed on the origin are overridden to use the RMI representation of the remote object. After the remote method is executed the edge object s state is synchronized with the origin. When local methods are executed they work directly with the local representation of the object. For example read only methods such as getter would not cause inter tier traffic.

This scenario demonstrates that those methods that required remote processing were performed by the origin on an identical object through RMI. Methods that can be executed locally are executed on the cached representation of the object.

The present invention delivers the ability to run Java based web applications at the edges of the Internet near the end user providing several benefits. The web application will be served by as many servers as necessary to maximize the performance. New servers are allocated automatically based on increased traffic without capital expenditure by an enterprise. Offloading applications from the origin to a distributed network can eliminate single points of failure. In addition monitoring of edge servers built in redundancies and the ability to map users instantly to the optimal servers allows the CDN service provider to bypass network congestions and overcome hardware failures. Offloading application processing from a single origin to to numerous servers at the edge can result in significant performance gains. By mapping each user to an optimal or preferred server the CDN service provider avoids Internet bottlenecks and can dramatically reduce latency. The ability to allocate servers on demand means applications will never lack processing power or bandwidth. By reducing the number of application servers needed to run at the origin site the CDN service provider reduces complexity associated with hardware and software maintenance and management.

There is no limitation as to the particular type of application component that may be implemented and deployed as an edge enabled CDN application. In addition to the examples set forth above representative applications include without limitation product configurators dealer locators contest engines content transcoders content generators search aggregators financial calculators registration engines and a myriad of others.

One of ordinary skill will recognize that many variants are within the scope of the present invention. Thus for example a particular edge server may execute a first type of application server instance e.g. Tomcat servlet container as well as a second different type of application server instance e.g. IBM WebSphere Application Server . As already described multiple instances of a particular application server will typically be used on a given edge server to facilitate use of that server by multiple service provider customers. Of course other Web containers besides Apache Tomcat can be used to implement the Web tier and other Enterprise containers besides IBM WebSphere Application Server can be used to implement the Enterprise container. There is no requirement that a particular application have components that execute on both the edge and the origin indeed a given application may execute in a standalone manner completely as an edge enabled application. There also is no requirement that the application components be packaged as WAR or EAR files as any convenient mechanism may be used to deploy the application components to the edge. There is no requirement that application components be loaded only in response to client requests at a particular edge server. Indeed in many cases it will be desirable to pre deploy an application or an application component based on some prediction of expected future need for that application or component or for purposes of fault tolerance. Thus a given application or component thereof may be delivered to a particular edge server and initialized and started irrespective of whether an end user request has been received at the server. Also there is no requirement that application components be fully or partially J2EE compliant or even that the subject matter be implemented entirely in Java. Indeed the present invention is also extensible beyond Java and J2EE. In particular the inventive concepts may be practiced in any platform independent application server programming environment e.g. Microsoft .NET Mod Perl executing in Apache Zope or the like capable of being deployed in a distributed computing environment such as a content delivery network.

The CDN service provider may provide the ability to test and debug the application within an enterprise firewall. A test server may be a CDN edge server simulator that can be used during application development and testing to validate the execution of the application on the platform s runtime environment.

To deploy a prepared edgeable application the content provider preferably publishes the application e.g. using FTP to a CDN staging network. The staging network preferably is a set of staging servers which may be the CDN edge servers or some other set. This creates a staging environment in which the application can be tested by the enterprise s quality assurance personnel. When tests prove satisfactory the application is made live preferably through a secure web interface. illustrates this process which takes advantage of a service provider portal. Customers also may upload deploy and provision applications programmatically. Deployment to the edge preferably occurs automatically. Edge enabled applications or their components may also be deployed from a CDN content storage network or some other third party server. As already noted application components also may be pre fetched to a particular edge server or server region to reduce start up latency. In a general case however an edge application component has not been pre deployed and an end user has been mapped to a particular edge server. If the end user request then matches the configuration parameters created during the setup phase the edge server to which the end user has been mapped will attempt to load the associated Java application. If the Java application is not in cache it is retrieved from the staging network or the content storage network or some other server. Preferably the application continues to reside within the servlet container for the next request. Unused applications preferably are removed from the Web container but may still be stored in cache. Preferably if an application has been invalidated or if the application has not been accessed for an extended period of time it is removed from the disk cache. To protect the Web application from unauthorized access preferably only the edge servers are allowed to retrieve the application from the staging network or the other content storage network.

