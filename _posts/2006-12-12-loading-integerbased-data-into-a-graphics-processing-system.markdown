---

title: Loading integer-based data into a graphics processing system
abstract: One embodiment of the present invention sets forth a technique for improving the flexibility and programmability of a graphics pipeline by enabling full access to integer texture maps within a graphics processing unit (GPU). A new mechanism for loading and unloading integer texture images is disclosed that enables the shader units within the GPU to have full access to integer values stored within an integer image buffer in a GPU local memory. New integer formats are added to the graphics API that indicate that data should be loaded and processed without the prior art conversion to a floating-point representation, thereby enabling the use of these new integer data types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07986325&OS=07986325&RS=07986325
owner: NVIDIA Corporation
number: 07986325
owner_city: Santa Clara
owner_country: US
publication_date: 20061212
---
Embodiments of the present invention generally relate to graphics programming and more specifically to loading integer based data into a graphics processing system.

Over the past decade the cost of adding on chip logic to processors has substantially decreased. Consequently certain types of processors such as advanced graphics processing units GPUs now include functionality not previously available in earlier GPU designs. For example newly introduced GPUs are now able to perform full integer processing operations whereas such operations could not be effectively performed on the GPU. One benefit of this new capability is that more efficient graphics processing may now be performed on the GPU thereby increasing overall performance in the graphics pipeline.

To fully realize additional processing capabilities of advanced GPUs as much GPU functionality as possible needs to be exposed to graphics application developers. Among other things doing so enables graphics application developers to tailor their shader programs to optimize the way GPUs process graphics scenes and images. Exposing new full integer GPU processing capabilities to graphics application developers requires that the application programming interface API be configured with new calls and libraries that make new features and functionalities directly accessible by developers.

GPU APIs typically expose an interface to graphics application developers that enables an application executing on the host CPU to load image data in the form of one or more texture maps into GPU local memory for greater access and processing efficiency by the GPU. Texture map data is commonly represented as one or more intensity values per texture element called a texel. For example a texel may include a single intensity value per texel. Alternately a texel may include four values corresponding to red green and blue intensity and opacity. Each value within a texel is commonly represented using either a floating point value such as a standard 32 bit floating point number or a fixed point normalized value. For example an 8 bit normalized value includes 256 codes ranging from 0x00 to 0xFF where 0x00 corresponds to a floating point value of 0.0 and 0xFF corresponds to a floating point value of 1.0. The incremental codes between 0x00 and 0xFF correspond to 254 increasing floating point values between zero and one.

In prior art GPUs the data stored in a texture map is used for a very limited scope of computation typically performed by fixed function shaders that are limited to using floating point math. Thus data retrieved from a texture map by a shader is first converted to a floating point representation before being presented to the shader. Data written to the texture map by the shader is presumed to originate as floating point data from the shader and may be converted from the presumed floating point format to a specific storage format such as normalized 8 bit values before being stored. With the introduction of GPUs that able to perform full integer processing the prior art data path connecting a shader unit to the GPU local memory becomes an impediment to enabling the use of integer data within a texture map. By always casting texture data to a floating point or normalized representation in this way the GPU s ability to perform more general computation using data stored in a texture map is highly constrained.

As the foregoing illustrates what is needed in the art is a mechanism to extend the use of integer data types within texture maps.

One embodiment of the invention sets forth a method for loading texture data produced by an application program into a local memory of a graphics processing unit. The method includes the steps of determining that the texture data is integer texture image data where the integer texture image data has a defined packing organization and is comprised of pixels having values expressed in a first integer format unpacking the texture data into an array of pixels populating any unpopulated pixel data fields and storing the texture data within the local memory.

One advantage of the disclosed method it provides new mechanisms for loading and unloading integer texture images into the local memory of a graphics processing unit. These mechanisms enable the different shader units within the graphics processing unit as well as the application program to have full access to the integer data included in the integer texture images.

As described herein the term texture image broadly refers to texture data that is organized as an array of pixels or texels. A texture image may reside in memory that is typically not accessible for texture mapping using texture mapping techniques. Pixels is usually used when discussing texture image data that is a source image or other data transmitted from an application program or when the texture image data is stored a frame buffer memory local to a graphics processing unit and texels is usually used when discussing texture image data that is stored in a texture memory local to the graphics processing unit. The words pixel and texel may be used interchangeably throughout the present application depending on context and neither word is intended to limit the scope of the present invention. Texture image data may include conventional image data such as color components or may include other types of data also suitable for use as a texture map e.g. light intensity height fields displacement data and the like. Each pixel or texel making up the texture data may include one or more components. An integer texture image is texture image data where each component of the pixels or texels has a signed or unsigned integer value. A prior art texture map or non integer texture map is texture image data where each component of the pixels or texels has a non integer representation such as a floating point type or normalized integer type. Importantly when an integer texture image stored in either the texture memory or frame buffer memory is accessed by either the application program or if possible by a programmable or fixed function processing engine within the graphics processing unit signed or unsigned integer values are returned to the application program or processing engine.

The system memory includes an application program and integer texture image data that represents one or more integer texture images an API and a GPU driver . The system memory may also include texture map data representing one or more texture maps. The application program generates calls to the API in order to produce a desired set of results typically in the form of a sequence of graphics images. The application program also transmits integer texture image data and texture map data to the API for processing within the GPU driver . The GPU driver includes a texture loader and a texture unloader . The texture loader coordinates the transmission of integer texture image data and texture map data to the GPU which then stores this data in the GPU local memory . As described below the texture loader also performs any processing and formatting of the integer texture image data and the texture map data according to the specific requirements of the GPU . The texture unloader retrieves data from the GPU local memory on behalf of the application program . The texture unloader performs any processing and formatting of the integer texture image data and the texture map data according to the specific request requirements of the application program .

The GPU includes a vertex shader a geometry shader a fragment shader a scan out unit and a memory interface . As is well known the vertex shader receives a sequence of one or more sets of vertex attributes where each set of vertex attributes is typically associated with a geometric primitive. The vertex shader processes the vertex attributes so that linear interpolation may be performed on the processed vertex data by subsequent processing stages. The vertex shader may also store and retrieve data within the GPU local memory . The vertex shader may operate according to a set of fixed functions or operate according to a set of programming instructions as determined by the specific class of GPU design. The geometry shader receives sets of processed vertices from the vertex shader . The geometry shader performs per primitive operations on vertices grouped into primitives such as triangles lines strips and points generated by the vertex shader . The geometry shader may operate according to a set of fixed functions or operate according to a set of programming instructions as determined by the specific class of GPU design. The fragment shader processes fragment data which may include raster position depth or interpolated vertex attributes such as texture coordinates color opacity and other relevant per pixel data to produce final pixel values. The fragment shader may operate according to a set of fixed functions or operate according to a set of programming instructions as determined by the specific class of GPU design.

The memory interface stores and retrieves data within the GPU local memory in response to requests from on chip clients such as the vertex shader the geometry shader the fragment shader and the scan out unit . The memory interface arbitrates for competing requests for bandwidth performs address remapping for greater efficiency in the use of the available bandwidth re formats data according to the type of buffer being accessed and implements the bus interface protocol used by the GPU local memory . The scan out unit retrieves data from the GPU local memory for visible display on the display . The scan out unit typically operates under a set of real time requirements set by the display such as horizontal and vertical refresh rates. The scan out unit should in some operating modes be permitted to complete a vertical refresh of an image prior to any modification of the image source buffer to avoid visual tearing of the image being displayed.

The GPU local memory includes at least one integer texture image and a frame buffer . The GPU local memory may also include one or more texture maps . The integer texture image may be generated by copying data from the integer texture image data within system memory . Alternately the integer texture image may be generated procedurally by one of the shader units within the GPU such as the fragment shader . The texture map is typically copied from texture map data within system memory . Alternately the texture map may be generated procedurally by one of the shader units within the GPU . The texture map and integer texture image store data elements typically organized in one dimensional two dimensional or three dimensional structures. Data stored within the texture map and integer texture image is typically accessed with the assistance of application specific hardware that provides for a dimensional access view of the data. For example a two dimensional surface may be addressed with the assistance of a hardware unit that transposes a horizontal and vertical surface location into a physical memory address that corresponds to the location. The frame buffer includes at least one two dimensional surface that is used to drive the display . The frame buffer may include more than one two dimensional surfaces so that the GPU can render to one two dimensional surface while a second two dimensional surface is used to drive the display .

Again as described herein the integer texture image comprises an array of texels stored as signed or unsigned integer values and the texture map comprises an array of texels having a non integer representation or a normalized integer representation that is converted to floating point when accessed. If stored in the frame buffer the integer texture image and the texture map are stored as an array of pixels.

The display is an output device capable of emitting a visual image corresponding to an input data signal. For example the display may be built using a cathode ray tube CRT monitor a liquid crystal display or any other suitable display system. The input data signal to the display is typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .

In one embodiment the first texture load pipeline within the texture load path proceeds according to the prior art pipeline described in detail in the OpenGL 2.0 specification. This texture load pipeline includes an unpack data engine a convert data to red green blue alpha RGBA floating point unit a pixel transfer engine a clamp unit and a pack data engine . The unpack data engine is configured using OpenGL functions to unpack a source image such as texture data and to produce an array of pixels where each pixel has a specified dimension that includes allocated space for RGBA values. As described in detail in the Open GL 2.0 specification the pixels within a source image are a sequence of signed or unsigned bytes GL data types byte and ubyte signed or unsigned short integers GL data types short and ushort signed or unsigned integers int or uint or floating point values float . These data values are grouped into sets of one two three or four values per pixel depending on the format of the source image. Fixed point normalized data are then converted from the unpacked source image format to a standard floating point format in the convert RGBA to floating point unit using Equation 1 set forth below. The variable f represents the converted floating point value. The variable c represents the integer value of the bit field within the source image containing the data value being converted. N is the number of bits in the bit field. 2 1 Equation 1 

In the event that the source image format is not a complete RGBA format the convert RGBA to floating point unit fills out the unpopulated data fields of the converted pixels with values from one or more data fields of the source pixels. For example if the source image format includes only luminance then the convert RGBA to floating point unit copies the source luminance value to each of the RGBA values in the destination pixel. The pixel transfer engine is configured using OpenGL functions to perform scale bias convolution and color conversion operations on the converted floating point data. The pixel transfer engine transmits data to the clamp unit which optionally clamps the data values generated by the pixel transfer engine to the inclusive range of 0.0 to 1.0 . The data generated by the clamp unit is then processed by the pack data engine for efficient storage and access within the texture map . The first texture load pipeline thus processes the texture data which may include a significant number of different source formats into a consistent floating point format for efficient storage in the texture map .

The second texture load pipeline within the texture load path processes data according to a newly introduced pipeline architecture whereby the texture data generally proceeds from the application program to GPU local memory without modification of the byte values of the texels within the texture data . A set of new data formats are added to the API that enable the application to indicate which of the two texture load pipelines should be used to load a given set of texture data into GPU local memory . TABLE 1 lists these new data formats.

The unpack from memory engine reverses any packing remapping or formatting performed by the pack data engine of and presents the pixel transfer engine with floating point values from the texture data . The pixel transfer engine is configured using OpenGL functions to perform scale bias convolution and color conversion operations on the floating point data. The pixel transfer engine transmits data to the convert RGB to L unit which in turn restructures the floating point RGB data if necessary in accordance with the format of texture map data . The restructured data is transmitted to the clamp unit which optionally clamps the output values to a specified range. For example a floating point number maybe clamped to the range of 0.0 1.0 . The pack data engine then stores the clamped pixel data using the pixel packing organization specified for the texture map data . The pack data engine performs any remaining conversions to a specific format for storage as requested by the application program . The OpenGL 2.0 specification defines the different packing organizations that may be implemented by the pack data engine .

The second texture unload pipeline within the texture load path processes data according to a newly introduced pipeline architecture whereby the texture data generally proceeds from the GPU local memory to the application program without modification of the byte values of the texels within the texture data . More specifically GPU driver processes texture data through this second pipeline when GPU driver determines in step that the texture data is in one of the integer formats listed in TABLE 1. The second pipeline includes an unpack from memory engine a format conversion unit a convert RGBA to L unit and a pack data engine .

The unpack from memory engine reverses any remapping packing or formatting performed by the pack data engine of and presents the format conversion unit with integer values from the texture data . The integers values are passed to the format conversion unit which may resize the integer values according to the format of the integer texture image data . For example a signed 16 bit integer within the texture data may be sign extended to conform to a signed 32 bit format within the integer texture image data . The convert RGB to L unit performs any organizational modifications to the data received from the format conversion unit necessary to conform to the format of the integer texture image data . The pack data engine then clamps the pixel data to a range that is representable within the integer texture image data and stores the pixel data using the packing organization in the integer texture image data . Again the pack data engine uses the OpenGL 2.0 specification for packing formats which are organized according to elements per pixel and bytes per element.

In addition even though describes unloading texture data stored in either texture map or integer texture image within GPU local memory using the load path of in alternative embodiments un load path of may be used to unload texture data stored in frame buffer within GPU local memory using the load path described below in .

In one embodiment the first texture load pipeline within the frame buffer load path proceeds according to the prior art pipeline described in detail in the OpenGL 2.0 specification. This texture load pipeline includes an unpack data engine a convert data to floating point unit a convert to RGBA unit a pixel transfer engine a clamp unit and the fragment shader . The unpack data engine is configured using OpenGL functions to unpack a source image such as texture data and to produce an array of pixels where each pixel has a specified dimension that includes allocated space for RGBA values. As described in detail in the Open GL 2.0 specification the pixels within a source image are a sequence of signed or unsigned bytes. These data values are grouped into sets of one two three or four values per pixel depending on the format of the source image. Fixed point normalized data are then converted from the unpacked source image format to a standard floating point format in the convert data to floating point unit using Equation 1 set forth previously herein.

In the event that the source image format is not a complete RGBA format the convert to RGBA unit fills out the unpopulated data fields of the converted pixels with a combination of predefined constant values and values from one or more data fields of the source pixels. For example in the LUMINANCE and LUMINANCE ALPHA formats the red green and blue components are filled with the luminance values. Any remaining unpopulated fields are filled with predefined default values. The pixel transfer engine is configured using OpenGL functions to perform scale bias convolution and color conversion operations on the converted floating point data. The pixel transfer engine transmits data to the clamp unit which clamps the data values generated by the pixel transfer engine to the inclusive range of 0.0 to 1.0 . The data generated by the clamp unit is then used to generate fragments that are processed by the fragment shader which provides access to the frame buffer within GPU local memory . The DrawPixels OpenGL API command may be used to engage the fragment shader to provide the write path to the frame buffer . The first texture load pipeline thus processes the texture data which may include a significant number of different source formats into a consistent floating point or normalized integer format for storage in the frame buffer . When the frame buffer is configured to store a normalized integer format the outputs of the fragment shader are converted to a fixed point value for storage

The second texture load pipeline within the frame buffer load path processes data according to a newly introduced pipeline architecture whereby the texture data generally proceeds from the application program to the frame buffer within GPU local memory without modification of the byte values of the texels within the texture data . Again Table 1 sets forth a set of new data formats that are added to the API that enable the application to indicate which of the two texture load pipelines should be used to load a given set of texture data into the frame buffer within GPU local memory .

More specifically in step if GPU driver determines that texture data is in one of the formats listed in TABLE 1 then GPU driver processes texture data through the second texture load pipeline which includes an unpack data engine a convert to RGBA unit a format conversion unit and to pack data unit . The unpack data engine operates on the data formats specified in TABLE 1 producing an array of pixels similar to the array produced by the unpack data engine . In the event that the source image format is not a complete RGBA format the convert to RGBA unit fills out the unpopulated data fields according to well known prior art techniques. In one embodiment the pixel values may be expressed as signed or unsigned integer values that are 8 16 or 32 bits in length. The format conversion unit converts between integer formats should the need arise but otherwise passes data through unmodified. For example a source image using signed 8 bit values should undergo sign extension if the frame buffer format is a signed 32 bit format. The data generated by the format conversion unit are then processed by the fragment shader which provides access to the frame buffer within GPU local memory . The DrawPixels OpenGL API command may be used to engage the fragment shader to provide the write path to the frame buffer . In such a scenario the fragment shader should be compiled to expect the input colors associated with input fragments to be integer values.

In sum three types of texture access mechanisms are added to a computing device that incorporates a GPU co processor capable of full integer math operations. The first mechanism provides full integer texture loading and un loading between the system memory and the GPU local memory. This process is invoked by a graphics application using new integer data types added to the API. The second mechanism enables GPU shader units to access integer texture image data directly and without compulsory casting operations being performed on the data. The third mechanism enables the GPU to render texture data directly into the frame buffer via the fragment shader.

In one embodiment of the invention a computer readable medium includes instructions that when executed by a processor cause the processor to load texture data produced by an application program into a local memory of a graphics processing unit by performing the steps of determining that the texture data is integer texture image data wherein the integer texture image data has a defined packing organization and is comprised of pixels having values expressed in a first integer format unpacking the texture data into an array of pixels populating any unpopulated pixel data fields and storing the texture data within the local memory.

While the forgoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

