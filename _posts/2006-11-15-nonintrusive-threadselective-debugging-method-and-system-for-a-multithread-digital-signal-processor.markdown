---

title: Non-intrusive, thread-selective, debugging method and system for a multi-thread digital signal processor
abstract: A method and system provide processing instructions in a multi-threaded process including the use of breakpoint instructions for generating debugging event(s). A debugging event is generated in response to the execution of breakpoint instructions and executes debugging instructions in response to the debugging event. The debugging instructions debug processing instructions in the multi-threaded processor by transitioning at least one or more threads into a debugging mode. A debugging return is generated for reporting the executing debugging instructions in the subset of the threads of the multi-threaded processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08370806&OS=08370806&RS=08370806
owner: QUALCOMM Incorporated
number: 08370806
owner_city: San Diego
owner_country: US
publication_date: 20061115
---
This application is related to the following U.S. patent application Ser. No. 11 560 323 now U.S. Pat. No. 7 657 791 filed Nov. 15 2006 and entitled METHOD AND SYSTEM FOR A DIGITAL SIGNAL PROCESSOR DEBUGGING DURING POWER TRANSITIONS U.S. patent application Ser. No. 11 560 332 filed Nov. 15 2006 and entitled METHOD AND SYSTEM FOR TRUSTED UNTRUSTED DIGITAL SIGNAL PROCESSOR DEBUGGING OPERATIONS U.S. patent application Ser. No. 11 560 339 filed Nov. 15 2006 and entitled EMBEDDED TRACE MACROCELL FOR ENHANCED DIGITAL SIGNAL PROCESSOR DEBUGGING OPERATIONS and U.S. patent application Ser. No. 11 560 344 filed Nov. 15 2006 and entitled METHOD AND SYSTEM FOR INSTRUCTION STUFFING OPERATIONS DURING NON INTRUSIVE DIGITAL SIGNAL PROCESSOR DEBUGGING.

The disclosed subject matter relates to data communications. More particularly this disclosure relates to a novel and improved non intrusive thread selective debugging method and system for a multi threaded digital signal processor.

Increasingly telecommunications and other types of electronic equipment and supporting video complex audio videoconferencing and other rich software applications involve signal processing. Signal processing requires fast mathematical calculations and data generation in complex but repetitive algorithms. Many applications require computations in real time i.e. the signal is a continuous function of time which must be sampled and converted to digital signals for numerical processing. The processor must execute algorithms performing discrete computations on the samples as they arrive. The architecture of a digital signal processor DSP is optimized to handle such algorithms. The characteristics of a good signal processing engine include fast flexible arithmetic computation units unconstrained data flow to and from the computation units extended precision and dynamic range in the computation units dual address generators efficient program sequencing and ease of programming.

One promising application of DSP technology includes communications systems such as a code division multiple access CDMA system that supports voice and data communication between users over a satellite or terrestrial link. The use of CDMA techniques in a multiple access communication system is disclosed in U.S. Pat. No. 4 901 307 entitled SPREAD SPECTRUM MULTIPLE ACCESS COMMUNICATION SYSTEM USING SATELLITE OR TERRESTRIAL REPEATERS and U.S. Pat. No. 5 103 459 entitled SYSTEM AND METHOD FOR GENERATING WAVEFORMS IN A CDMA CELLULAR TELEHANDSET SYSTEM both assigned to the assignee of the claimed subject matter.

A CDMA system is typically designed to conform to one or more standards. One such first generation standard is the TIA EIA IS 95 Terminal Base Station Compatibility Standard for Dual Mode Wideband Spread Spectrum Cellular System hereinafter referred to as the IS 95 standard. The IS 95 CDMA systems are able to transmit voice data and packet data. A newer generation standard that may more efficiently transmit packet data is offered by a consortium named the 3 Generation Partnership Project 3GPP and embodied in a set of documents including Document Nos. 3G TS 25.211 3G TS 25.212 3G TS 25.213 and 3G TS 25.214 which are readily available to the public. The 3GPP standard is hereinafter referred to as the W CDMA Standard.

Complex DSP operational software employing the W DCMA Standard for example requires robust development tools. Such development tools may include those for code generation integration testing debugging and evaluating application performance. In developing and operating software or complex DSP applications such as advanced telecommunications applications there is the need for sophisticated yet non intrusive debugging software. That is debugging software applications must be not only sufficiently robust to monitor test and support the correction of software defects and operational problems but also they may operate so as not to interfere with the core processor software during debugging operations. Otherwise any problems in the core processing software may not be detected or detected properly during the use of such debugging software.

For example cycle accurate profiling and non intrusive debugging features are critical for optimizing and debugging real time video software. Also development boards need support for moving large quantities of test data into and out of the processor to enable extensive real time testing. These and other situations require non intrusive core processor software debugging. So in a multi threaded digital signal processor there is the need to debug multi threaded operating software in a way that is non intrusive. Moreover in an environment were there is real time operating software any change in the software that an intrusive debugging program may cause may unequivocally change what occurs in the processor much to the detriment of both determining software operational problems as well as any necessary debugging operations.

From the above it becomes clear that there is the need for DSP debugging processes that may operate interactively and yet non intrusively to the real time behavior of the multi threaded digital signal processor.

In a multi threaded DSP interactions between one or more threads may also cause core processor malfunctions. This may be true although individual threads may operate individually as programmed and desired. Also different combinations of operating threads may cause still different types of programming problems for which debugging software analysis is beneficial.

Furthermore in a multi threaded DSP there may be many points i.e. breakpoints at which debugging operations are desired. Such breakpoints may arise due to hardware conditions software conditions external conditions and other conditions affecting the core processor applications. A flexible type of multi threaded DSP debugging software application would preferably accommodate a wide variety of conditions that call for core processor application debugging. In fact flexibility may mandate that the debugging software vary even dynamically according to those conditions that call into operation the debugging software.

With these considerations in mind it is clear that a need exists for a multi threaded DSP debugging process that supports debugging individual threads.

A need also exists for multi threaded DSP debugging processes that permit thread selective debugging operations of one two or more threads according to needs of the core processing applications.

A need yet exists for a method and system that permits a multi threaded DSP to engage a debugging process with a wide variety of conditions affecting DSP operation including for example hardware conditions software conditions external conditions and other conditions for which debugging breakpoints may be established.

Techniques for providing non intrusive thread selective debugging method and system for a multi threaded digital signal processor are disclosed which techniques improve both the operation of a digital signal processor and the efficient use of digital signal processor instructions for increasingly powerful software applications including applications operating in personal computers personal digital assistants wireless handsets and similar electronic devices as well as increasing the associated digital processor speed and service quality.

According to one aspect of the disclosed subject matter there is provided a method and system non intrusive debugging of a multi threaded digital signal processor. The method and system allow storing debugging instructions in a first set of registers and storing processing instructions in a second set of registers. The second set of registers is distinct from the first set of registers. The method and system further execute processing instructions in a multi threaded process using at least one or more threads of the multi threaded digital signal processor. Subsets of the processing instructions are breakpoint instructions for generating at least one debugging event. The process generates at least one debugging event in response to the execution of at least one of the breakpoint instructions and executes debugging instructions in response to the debugging event the debugging instructions allow non intrusively debugging the executing of processing instruction in the multi threaded digital signal processor by transitioning at least one or more threads of the multi threaded digital signal processor into a debugging mode of operation. The disclosure generates a debugging return from the execution of the plurality of debugging instructions for reporting the executing debugging instructions in the subset of the threads of the multi threaded digital signal processor.

These and other advantages of the disclosed subject matter as well as additional novel features will be apparent from the description provided herein. The intent of this summary is not to be a comprehensive description of the claimed subject matter but rather to provide a short overview of some of the subject matter s functionality. Other systems methods features and advantages here provided will become apparent to one with skill in the art upon examination of the following FIGUREs and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the accompanying claims.

The disclosed subject matter for a non intrusive thread selective debugging method and system for a multi threaded digital signal processor has application for multi threaded processing of any type for which the benefits here presented may be advantageous. One such application appears in telecommunications and in particular in wireless handsets that employ one or more digital signal processing circuits. For explaining how such a wireless handset may be used provides a simplified block diagram of a communications system that may implement the presented embodiments of the disclosed interrupt processing method and system. At a transmitter unit data is sent typically in blocks from a data source to a transmit TX data processor that formats codes and processes the data to generate one or more analog signals. The analog signals are then provided to a transmitter TMTR that modulates filters amplifies and up converts the baseband signals to generate a modulated signal. The modulated signal is then transmitted via an antenna to one or more receiver units.

At a receiver unit the transmitted signal is received by an antenna and provided to a receiver RCVR . Within receiver the received signal is amplified filtered down converted demodulated and digitized to generate in phase I and Q samples. The samples are then decoded and processed by receive RX data processor to recover the transmitted data. The decoding and processing at receiver unit are performed in a manner complementary to the coding and processing performed at transmitter unit . The recovered data is then provided to a data sink .

The signal processing described above supports transmissions of voice video packet data messaging and other types of communication in one direction. A bi directional communications system supports two way data transmission. However the signal processing for the other direction is not shown in for simplicity. Communications system may be a code division multiple access CDMA system a time division multiple access TDMA communications system e.g. a GSM system a frequency division multiple access FDMA communications system or other multiple access communications system that supports voice and data communication between users over a terrestrial link. In a specific embodiment communications system is a CDMA system that conforms to the W CDMA Standard.

Output from execution data paths goes to register file write circuit also configured to accommodate individual threads T T for returning the results from the operations of DSP . Thus the data path from circuit and before to register file write circuit forms a processing pipeline . The present embodiment may employ a single processor with up to six threads T T. Processor pipeline has six stages matching the minimum number of processor cycles necessary to fetch a data item from circuit to registers and . DSP concurrently executes instructions of different threads T T within a processor pipeline . That is DSP provides six independent program counters an internal tagging mechanism to distinguish instructions of threads T T within processor pipeline and a mechanism that triggers a thread switch.

DSP therefore provides a general purpose digital signal processor designed for high performance and low power across a wide variety of signal image and video processing applications. provides a brief overview of the DSP architecture including some aspects of the associated instruction set architecture for one manifestation of the disclosed subject matter. Implementations of the DSP architecture support interleaved multithreading IMT . In this execution model the hardware supports concurrent execution of multiple hardware threads T T by interleaving instructions from different threads in the pipeline. This feature allows DSP to include an aggressive clock frequency while still maintaining high core and memory utilization. IMT provides high throughput without the need for expensive compensation mechanisms such as out of order execution extensive forwarding networks and so on. Moreover the DSP may include variations of IMT such as those variations and novel approaches disclosed in the commonly assigned U.S. Patent Applications by M. Ahmed et al and entitled Variable Interleaved Multithreaded Processor Method and System and Method and System for Variable Thread Allocation and Switching in a Multithreaded Processor. 

Sequencer provides hybrid two way superscalar instructions and four way VLIW instructions to S Pipe unit M Pipe unit LD Load Pipe and LD ST Store Pipe unit all of which communicate with general registers . AXI Bus also communicates via Bus I F with shared data cache LD ST instructions to threads T T. Optional L Cache TCM signals include LD ST instructions with shared data TCM which LD ST instructions further flow to threads General Registers . From AHB peripheral bus MSM specific controller communicates interrupts with T T including interrupt controller instructions debugging instructions and timing instructions. Global control registers communicates control register instructions with threads T T.

DSP therefore includes six virtual DSP cores each containing global control registers and private supervisor control registers . Global control registers are shared between all threads. Each thread shares a common data cache and a common instruction cache. Load store and fetch operations are serviced by a common bus interface. High performance AXI bus and a lower performance AHB bus are used to connect the data and instruction traffic to off core memory and peripherals. An integrated level two memory cache and or TCM input is optional. Peripheral access may be through memory mapped loads and stores. The physical address partition between AHB and AXI may be configured at the MSM level.

Clearly the presented architecture for DSP may evolve and change over time. For example the number of instruction caches that DSP may use could change from six to one or other numbers of caches. Superscalar dispatch L data at TCM and other architectural aspects may change. However the present subject matter may have continued relevance in a wide variety of configurations and for a large family of modifications of DSP .

ISDB through JTAG interface provides a hardware debugger for DSP . ISDB provides software debug features through JTAG interface by sharing system or supervisor only registers that are divided into supervisor control registers on a per thread basis and global control registers between all threads. The system control registers are used for per thread interrupt and exception control and per thread memory management activities. Global registers allow interacting with the ISDB for debugging operations.

ISDB enables software developers to debug their software while DSP operates. ISDB hardware in combination with a software debugger program operating in ISDB may be used to debug the DSP operating system software. ISDB supports debugging hardware threads individually. Users may suspend thread execution view and alter thread registers view and alter instruction and data memory single step threads stuff instructions to threads and resume thread execution. Trusted users have access to all of ISDB features while untrusted users have access to one or more of features.

ISDB may communicate with a debugger interface card to communicating with ISDB debugging software residing on a program counter all through JTAG interface . Host debugger software may interact with the ISDB by reading and writing ISDB control registers. Communication for example may be through a 40 bit packet which identifies the ISDB register to which read write is to occur as well as a 32 bit data payload. A packet format supporting this operation may be up to 64 control registers which may be 32 bits wide each.

ISDB includes a trusted register for controlling security during a debugging operation. If the ISDB trusted is set then all ISDB registers are visible to the debugger software and all ISDB commands are available for use. In the case that ISDB trusted is cleared then ISDB only permits a restricted set of operations.

Certain ISDB registers may be made visible to core software. These are accessible via SUPERVISOR mode control register transfer instructions. The core instructions include a breakpoint instruction. When ISDB trusted is set this instruction causes the executing thread to enter DEBUG mode . This transition shifts thread control to ISDB . In addition to the thread that executed a breakpoint other threads may optionally enter DEBUG mode according to ISDB programming. If ISDB is not trusted or not enabled this instruction is treated as a NOP. Preferably the breakpoint instruction is the only instruction in a packet.

Now referring to DSP supports processing modes that are both global to all threads and local to individual threads. Each DSP hardware thread individually supports two execution modes USER mode and SUPERVISOR mode and three non processing modes o WAIT mode OFF mode and DEBUG mode all as may appear in . The mode of a thread is independent of other threads for example one thread may be in WAIT mode while another is in USER mode and so on. The per thread mode state diagram of is supported by various instructions or events. These include Except or internal exception event an Int or external interrupt event an RTE or software return instruction from exception mode and SSR or update to SSR register instruction a Stop or software stop instruction that may be entered from any mode a Start or software start instruction that also may be entered from any mode a trap or software trap instruction a Wait or software wait instruction a Resume or software resume instruction a DE or debug event and a DR or debug instruction. While the functions in different implementations of the claimed subject matter may vary slightly from those here presented the meanings of Start Wait Resume DE and or DR may be given their broadest interpretations consistent with the scope of the claimed subject matter.

Registers are available in DSP in both USER mode and SUPERVISOR mode . The user mode registers are divided into a set of general registers and a set of control registers. General registers are used for all general purpose computation including address generation scalar and vector arithmetic. Control registers support special purpose functionality such as hardware loops predicates etc.

General purpose registers are 32 bits wide and may be accessed as single registers or as aligned pairs of two registers. The general register file provides all operands for instructions including addresses for load store data operands for numeric instructions and vector operands for vector instructions.

DSP registers and instructions support efficient use of a software stack which employs standard C language conventions. The stack grows from high addresses towards low addresses. A stack pointer register points to the last valid element at the top of stack. Push operations first decrement the stack pointer and then write the data to the stack while Pop operations read from the stack and then increment the stack pointer.

A procedure frame on the stack contains a return address for the function call and all local variables and data needed by the procedure. In addition a frame pointer is stored after the return address. This frame pointer contains the address of the previous procedure frame on the stack. Its purpose is to facilitate debug by allowing a debugger to examine the stack in memory and easily determine the call sequence function parameters etc.

DEBUG mode is a special state where the thread is waiting for commands from ISDB . Whenever an ISDB debug event occurs such as by the execution of a software breakpoint instruction a break command from ISDB or occurrence of a hardware breakpoint indicated threads may enter DEBUG mode . While in DEBUG mode the core is controlled by ISDB via commands from JTAG interface . When the ISDB releases the thread due to execution of a resume command the thread may resume operation according to their current mode settings. When a thread is in DEBUG mode it is controlled by ISDB and cannot be controlled by other threads. A Wait Resume Start or Stop instruction from a running thread targeting a thread in DEBUG mode may be ignored. Similarly a Non Maskable Interrupt NMI may be ignored by threads in DEBUG mode .

A HARDWARE RESET mode not shown and DEBUG mode are global to all threads. Whenever the hardware reset pin is asserted regardless of any thread s processing state DSP may enter HARDWARE RESET Mode. In RESET mode all registers are set to their reset values. No processing may occur until the hardware reset pin is de asserted. When the reset pin is asserted the processor may transition into reset mode and all registers may be reset to their reset values. After the reset pin is de asserted thread T may be given a soft reset interrupt. This may cause thread T to enter SUPERVISOR mode and begin executing at the reset vector location. All other threads may remain off. At this point the software is free to control mode transitions for each thread individually.

Each thread may have one transition bit in mode control register that controls the transition to and from OFF mode for that thread. Writing to the transition bit via the Stop instruction turns the associated thread OFF. Writing to the transition bit via the Start instruction turns the thread on and triggers a soft reset interrupt. Each thread may include one wait bit in mode control register for controlling transitions to and from WAIT mode . Writing to wait bit via the wait instruction may idle the associated thread while writing via the resume instruction may cause the thread to resume whatever it was doing before WAIT mode was set.

Through the use of breakpoints the six threads of DSP may individually enter and exit DEBUG mode . A breakpoint trigger may come from five sources which correspond to the five different types of breakpoints supported in ISDB . These include hardware breakpoints software breakpoints ETM breakpoints JTAG interface breakpoints and external breakpoint. Upon hitting a breakpoint a thread transitions from its current mode e.g. WAIT RUN to DEBUG mode . In DEBUG mode the thread waits for commands from ISDB . A thread in OFF mode is powered down and may not accept any commands from ISDB . The latency of entering DEBUG mode is implementation defined. For example an implementation may choose to complete a given operation for example finish an outstanding load request before entering DEBUG mode . In one embodiment a thread identifier register contains an 8 bit read write field and is used for holding a software thread identifier. This field is used by the hardware debugger to match breakpoints.

There are a number of different ways to enter the breakpoint process. For example there are two hardware breakpoints. In a register equals a predetermined value then when the program counter PC matches the predetermined value then the process goes into the DEBUG mode . In addition to PC there may other qualifiers such as thread IDs such as address translations physical address or virtual addresses . ASIDs are tags that are similar to processes IDs in a process or a particular thread in a multithreaded process. So physical address virtual address ASID PC or other qualifiers may be used to optionally obtain a fix of the location of the program in a space of process.

ISDB also defines two output interrupt pins. These signals go out of ISDB into the MSM and are strapped at the MSM level. The two signals are break event and JTAG interface command. At the break event command ISDB may be programmed to raise this interrupt whenever a breakpoint occurs on an indicated thread number. At the JTAG interface command JTAG interface sends a command to raise this interrupt.

A hardware breakpoint matches one or more of a threads program counter ASID Address Space Identifier and thread identifier registers against ISDB programmed values. When the match conditions are met the thread enters DEBUG mode . In addition to the thread that hit the breakpoint other threads may be configured to enter DEBUG mode as well. This may be achieved for example through breakpoint configuration register programming.

Hardware breakpoints may support various features including for example matching a 32 bit program counter value which may be physical or virtual matching a 6 bit ASID value match an 8 bit thread identifier value and or forcing other threads into DEBUG mode upon hitting a breakpoint. To set a hardware breakpoint the breakpoint program counter and breakpoint configuration registers may be set through JTAG interface and then through use of the breakpoint enabled and configured via ISDB configuration registers.

The disclosed subject matter also provides certain software breakpoints. For example the user level breakpoint instruction may be used to enter hardware DEBUG mode . When this instruction is executed the core examines a system configuration ISDB trusted bit. If the ISDB trusted bit is set then the thread may enter DEBUG mode . In the case that ISDB trusted is clear or ISDB is disabled execution of the breakpoint instruction may be treated as a NOP. There is no restriction on the program counter address of a breakpoint instruction. However breakpoint instructions cannot be packetized with other instructions.

The disclosed subject matter also provides for embedded trace macro or ETM breakpoints for initiating an ETM process which monitors the operation of the DSP core processor. ETM supports a wide variety of trigger conditions. As such linking hardware breakpoint to ETM breakpoint may occur when the breakpoint configuration is set for such a transition. Through the use of ETM embedded trace map ISDB provides the ability to use a section of processor hardware that is adjacent to the processor for the purpose of monitoring processor operations. In addition the disclosed subject matter provides the ability to link debugging operations on one or more threads to operations occurring on one or more other threads. For example if one hardware thread hits a breakpoint then the present disclosure permits starting or stopping processing in another thread. The present disclosure therefore provides for independently debugging any one thread or a set of threads as well as the ability to control how events occurring on one thread or one set of threads may affect operations on one thread or set of threads.

So the disclosed subject matter provides a path for moving into a DEBUG mode in the event of a breakpoint causing entry into the DEBUG mode . The disclosed subject matter controls which thread or sets of threads in the multi threaded digital signal processor go into the DEBUG mode . ETM breakpoint debugging performs operations such as performance profiling that may be used for processor debugging. That block may provide a breakpoint for entering the debugging process.

In this situation both a hardware breakpoint and a ETM breakpoint thread number MASK are enabled for the matching thread. In this instance DSP may switch to DEBUG mode only when the hardware breakpoint is triggered following the ETM breakpoint. Any hardware breakpoint triggers that occur before the ETM breakpoint occurs may be ignored. When breakpoint configuration is set to 0 or not set the hardware breakpoint and ETM breakpoint thread number MASK behave normally. That is when enabled the corresponding breakpoint trigger may cause the thread s to switch to DEBUG mode immediately.

The JTAG interface breakpoint is triggered on an ISDB break command so that threads indicated in the command mask may enter DEBUG mode . ISDB also supports multi core debug through external breakpoints. Such a breakpoint is triggered when a rising edge is detected on the external debug request signal. Upon this event all threads indicated in the external breakpoint thread number mask may enter DEBUG mode .

Another feature of the disclosed subject is termed instruction stuffing. Instruction stuffing occurs when the host debugging process seeks to inspect the state of the core. Thus when a breakpoint occurs the process seeks to examine the core to determine that operations are occurring at the core. The mechanism to do that is to send over a processor instruction for the purpose of executing the instruction on the thread that is entering the DEBUG mode of operation.

In the instruction stuffing operation the instruction may direct the processor to read all or a portion of all affected registers at the time of the DEBUG mode . In addition the DEBUG mode may direct the processor to load a predetermined set or type of instructions. In addition reading and writing the state essentially any instruction may be read or written to the core in this process. For example if it is desirable to run some algorithm or process on the processor core the disclosed subject matter now allows set of options. In the instruction stuffing process a branch to a location and the process may then release the code for operation. Such code could include for instance code for performing certain functions for a specified set of reasons. One such reason may be to process a complicated data structure. If the instruction is to read out all elements of a given data structure then the process could be to reconstruct the data structure. Such a process could be exceedingly difficult. With a set of instructions to read out the data structure the process could be to call the set of instructions to obtain the specific instructions then specific instruction could run to the desired element e.g. element . This would significantly simplify many types of data retrieval and similar operations.

Instruction stuffing is a method for ISDB to execute instructions on the core. Instructions are stuffed for various reasons including for reading and writing core registers and memory for debugger operations abstracted for the user and for user entered instructions. To stuff an instruction the user must first program the stuff instruction register with the 32 bit instruction to be executed. For instruction stuffing the ISDB command register may be written first by setting the command field to the stuff code and then setting the thread number field to the thread to receive the instruction. The selected thread may be in DEBUG mode before the instruction may be stuffed. If more than one bit in thread number is set or the selected thread is not in DEBUG mode the results are undefined. Then a phase involving setting the privilege level of the stuffed instructions either user or supervisor occurs.

After issuing the stuff command the instruction may be executed on the chosen thread with the chosen privilege level. During instruction stuffing the program counter does not advance. Stuffed instructions which use program counter branches or instructions that cause an exception may use the thread s current program counter value. In the case that a stuffed instruction causes an exception the ISDB status register may indicate that an exception occurred. The thread may remain in DEBUG mode . The thread s designed registers may reflect the exception state. Preferably the ISDB debugging software queries the ISDB status register after stuffing an instruction that could cause an exception to see if an exception occurred.

Once an exception has been recognized the process here disclosed includes a number of choices as to how to handle the situation. For example the debugger software could choose to program a software or hardware breakpoint at the exception return point and resume the thread in order to run the handler. Then the debugger may redirect a thread to an OS helper function. Stepping through the handler using single step and manually fix the problem e.g. reload the TLB may next occur. However the specific strategy may differ according to the OS and or software debugger implementation.

Registers cache and memory may be accessed by stuffing the appropriate instruction sequences. The sequence of steps for instructions may include reading writing registers and cache using the ISDB debugging algorithms. The debugger software may read write thread registers by stuffing the appropriate control register transfer instruction to move data between a core register and the ISDB mailbox. This instruction may be stuffed using supervisor privilege level to ensure no exception occurs.

The Resume command is used to transition threads from debug to the mode programmed in the core mode control register. There are two ways to resume either from a JTAG interface command or from an external signal. If resuming is from a JTAG interface command the threads indicated in the command mask that are in DEBUG mode terminate to the mode indicated in the mode control register. If resuming is from an external signal the threads indicated in the external resume thread number MASK that are in DEBUG mode transition to the modes indicated in the mode control register.

Executing an ISDB Reset command forces a hardware reset and causes the entire DSP all threads to reset. This may set all registers to initial values e.g. power off threads and send a reset interrupt to thread T. If it is desired to reset just certain threads this may be done with a procedure of first stuffing a Start instruction with appropriate mask settings. This may cause a reset interrupt to be pending to the indicated threads. Then the process involves executing an ISDB resume instruction on the desired threads.

Another type of breakpoint is the JTAG interface breakpoint wherein the host sends a command over to the processor and says break. There is essentially an external pin that goes in. In this embodiment ISDB control registers may be accessed by the debugger host software via JTAG interface . ISDB provides various control registers which may be used by the host system to configure ISDB to perform different debug tasks and communicate with the DSP core processor. For example an ISDB status register indicates the current status of ISDB . Bits of the ISDB status register indicate which threads are in WAIT vs. RUN mode and others indicate which threads are in OFF mode. They reflect the E bit field of the core mode control register. A thread that is OFF for example generally cannot be debugged. So if ISDB commands are sent to a thread that is off then the results are undefined. Other DEBUG mode status bits indicate which threads are in DEBUG mode . If these bits indicate a thread is in DEBUG mode then the WAIT RUN mode bit indicates the mode prior to entering DEBUG mode .

Still other bits may indicate the stuff command status i.e. whether the stuff instruction process has been successful or whether the stuff instruction caused an exception. An ISDB command status bit denotes whether the ISDB command was successful or failed. Another set of bits provide a global interrupt disable when any thread in DEBUG mode such that interrupts are disabled for threads in DEBUG mode enabled for other threads. Interrupts are disabled for all threads when any thread is in DEBUG mode .

Yet other bits may form a field that indicates which threads to resume upon external resume signal. Upon external resume signal for threads which have the mask bit set if that thread is in DEBUG mode then it may resume its previous mode otherwise there is no affect. Another field indicates which threads to break upon an external breakpoint request. Upon receiving in ISDB an external breakpoint signal for threads which have the mask bit set if that thread is in not in DEBUG mode then it may enter DEBUG mode otherwise there is no affect.

Also an ISDB configuration instruction may enable or disable various features of the ISDB . A global interrupt disable occurs when any thread in DEBUG mode thereby disabling interrupts for threads in DEBUG mode . Another field in the ISDB configuration register may indicate which threads to resume upon external resume signal. Upon external resume signal for threads which have the mask bit set if such thread is in DEBUG mode then the thread resumes its previous mode. Otherwise there is no effect.

Yet another field in the ISDB register may indicate which threads to break upon ISDB receiving an external breakpoint request. Upon receiving the external breakpoint signal for threads which have the mask bit set if the thread is not in DEBUG mode then it may enter DEBUG mode . Otherwise there is no effect.

A breakpoint information register indicates for the threads in DEBUG mode which trigger caused the breakpoint. This may be a 6 bit field indicating which additional threads to break upon a breakpoint instruction execution. The least significant bit may be for thread number the next bit for thread number and so on. Upon breakpoint instruction execution the thread that executed breakpoint may enter DEBUG mode . Additionally the threads which have a bit set in this mask may enter DEBUG mode .

There is an interrupt signal break event which goes from ISDB to the MSM. Whenever a thread number indicated in this mask goes into DEBUG mode the break event interrupt is raised. In one embodiment bit is for thread number bit for thread number etc. For threads in DEBUG mode these bits indicate what caused the transition to DEBUG mode . For threads not in DEBUG mode these bits are undefined. So bits indicate the presence of a hardware breakpoint a breakpoint instruction execution an ETM breakpoint a JTAG interface breakpoint an external breakpoint. Also other bits may indicate the breakpoint source. A breakpoint program counter includes registers that are identical to breakpoint program counters except that they control hardware breakpoints. Breakpoint configuration registers are used to compare against a thread s program counter register.

An ISDB command register may include a break command for indicating which threads may transition to DEBUG mode . For resume command for indicating which threads to resume. An ISTEP command indicates which threads to step in a step by step process. A stuff instruction command indicates which thread may receive the stuff instruction for performing instruction stuffing operations. Stuff instruction privileges allow some stuffed instructions to execute in USER mode while others may execute in SUPERVISOR mode.

On a break command DSP may transition all threads indicated in the thread number mask to DEBUG mode . The resume command causes the processor to transition all threads indicated in the thread number mask to RUN mode. A step command allows the digital signal processor to step all threads indicated in the thread number mask for one packet. If the indicated threads are not in DEBUG mode there is no effect.

A stuff command causes the digital signal processor to execute the 32 bit instruction contained in the stuff instruction register on the thread indicated in the thread number mask. Only one bit in the mask may be set. If the indicated thread is not in DEBUG mode the behavior is undefined. The reset command initiates a hardware reset to the DSP. Registers are set to their initial values threads through are turned off and thread T is given a reset interrupt. On the interrupt command the ISDB raises the JTAG interface command interrupt. This signal goes out of ISDB into MSM and is strapped at the MSM level. An ISDB enable register enables ISDB operation and also checks the status of the security ISDB enable bit and the ISDB clock.

Having addressed the various commands supporting the operation of ISDB an exemplary process of ISDB debugging operations may be further instructive. Accordingly shows an ISDB flow diagram for the various non invasive debugging algorithm aspects of the present disclosure. Although the ISDB process flow of may be performed using a variety of approaches the basic flow of the disclosed subject matter as presented achieves the desired non intrusive debugging operations. So referring to from JTAG interface at ISDB entry step process flow may begin.

From ISDB entry step non intrusive debugging process flow may proceed to ISDB enabled query which tests whether ISDB has been enabled for DSP operation. If so then process flow goes to hardware breakpoint query . Hardware breakpoint query tests whether a hardware breakpoint has been encountered. If not then process flow may continue to software breakpoint query . Otherwise process flow goes to debugging operations step at which debugging operations begin. Software breakpoint tests for the presence of a software breakpoint and directs the ISDB process to debugging operations step in the event that a software breakpoint is present. Otherwise process flow continues to ETM breakpoint query . ETM breakpoint tests for the presence of an ETM breakpoint and directs the ISDB process to debugging operations step in the event that an ETM breakpoint is present. Otherwise process flow continues to JTAG interface breakpoint query . JTAG interface breakpoint tests for the presence of a JTAG interface breakpoint and directs the ISDB process to debugging operations step in the event that a JTAB breakpoint is present. Otherwise process flow continues to external breakpoint query . External breakpoint tests for the presence of an external breakpoint and directs the ISDB process to debugging operations step in the event that an external breakpoint is present. Otherwise process flow returns to ISDB enabled query . This type of cycle may be repeated during the operation of DSP .

Once ISDB process flow goes to debugging operations step a wait for debug query tests whether WAIT mode is effective. If so then until the WAIT mode terminates debugging operations do not yet occur. If WAIT mode is not effective then process flow goes to ISTEP debugging query . ISTEP debugging query tests whether individual step debugging is effective for ISDB operations. If so then process flow goes to ISTEP debugging step to perform this type of debugging operation. If ISTEP debugging is not effective then process flow may go to stuff instruction query . Stuff instruction query tests whether instruction stuffing operations are effective for ISDB operations. If so then process flow may proceed to stuff instruction step representing the instruction stuffing operations here described. If instruction stuffing is not effective then process flow goes to query .

At query a test occurs of whether a core DSP reset instruction has been generated by debugging operations. If so process flow goes to JTAG interface for delivering the core DSP digital signal processor reset command. If no such reset command has been generated then process flow goes to interrupts exist query . Interrupts exist query tests whether an interrupt to the debugging operations exists. If so then ISDB operations are interrupted and process flow goes to JTAG interface for delivering to DSP the signal that debugging operations have been so interrupted. If no interrupt signal exists then process flow goes to resume normal thread query for testing whether normal thread operation are to begin and debugging operations are to cease. If so then process flow goes to JTAG interface DSP transitions the affected threads from the DEBUG mode of operation to the normal mode of operation. If debugging operations are to continue then process flow returns to debugging operations step .

Clearly operations of ISDB process flow may vary widely and yet be within the scope of the disclosed subject matter. Accordingly ISDB process flow of is provided for illustrative purposes as one possible embodiment of the present disclosure.

Another aspect of the disclosed subject matter includes debugging through a power collapse in DSP . The ISDB configuration registers are readable and writeable by both the debugger software via JTAG interface and by supervisor core software via CR transfer instructions . Kernel software may use this feature to save and restore the ISDB configuration over power collapse. Because there are multiple masters writing these shared registers it is important to only write them in a consistent and mutually exclusive fashion.

The policy is that while the core is in the process of powering down or powering up the JTAG interface is not allowed to read write these registers. Similarly when the JTAG interface is in the process of modifying these registers the core is not allowed to power down. This policy is enforced through a combination of hardware and software. A bit in system configuration an ISDB core ready register bit may be written only by core supervisor software. This bit is cleared on hardware reset of DSP . When the bit is clear all JTAG interface read and write packets may return an invalid status. Using this bit the core may indicate to the host software when it has completed the power up sequence and is ready to talk to the ISDB. This gives the core an opportunity to restore any saved ISDB configuration in warm boot power up restore sequences.

One example of debugging through power collapse may exist in a cell phone where there is the need to be power conscious. DSP may go off or idle while there is yet the need to perform debugging. The disclosed subject matter therefore provides the ability to set a breakpoint that may manifest itself only in the power collapse instance. This provides the ability to debug even when the core is not even operating or on. 

Debugging through power collapse in the disclosed embodiment includes setting a set of breakpoints for configurations associated with the DSP dropping power. Before the DSP drops power the DSP saves off the configurations in specific registers. These specific registers and configurations allow a suspend to RAM process. So when the DSP comes back up the configuration is in a position to perform the next debug operation.

The processing features and functions described herein for non intrusive thread selective debugging in a multi threaded digital signal digital signal processor may be implemented in various manners. For example not only may DSP perform the above described operations but also the present embodiments may be implemented in an application specific integrated circuit ASIC a microcontroller a digital signal processor or other electronic circuits designed to perform the functions described herein. Moreover the process and features here described may be stored in magnetic optical or other recording media for reading and execution by such various signal and instruction processing systems. The foregoing description of the preferred embodiments therefore is provided to enable any person skilled in the art to make or use the claimed subject matter. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments without the use of the innovative faculty. Thus the claimed subject matter is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

