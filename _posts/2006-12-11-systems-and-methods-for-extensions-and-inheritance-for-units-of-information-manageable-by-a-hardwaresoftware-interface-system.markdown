---

title: Systems and methods for extensions and inheritance for units of information manageable by a hardware/software interface system
abstract: By modeling real-world application objects with complex structures, behaviors, and operations described by a schema which is enforced by the hardware/software interface system, various embodiments of the present invention provide rich sub-typing functionality by extending Items (and Item types) using “Extensions” which provide additional data structures (Properties, Relationships, etc.) to already existing Items type structures. Extensions are strongly typed instances that cannot exist independently and must be attached to an Item or a Nested Element. Extensions are also intended to address “multi-typing” issues by enabling the overlap of type instances (e.g., a Document may be a “legal document” as well a “secure document”).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07917534&OS=07917534&RS=07917534
owner: Microsoft Corporation
number: 07917534
owner_city: Redmond
owner_country: US
publication_date: 20061211
---
This application is a division of U.S. patent application Ser. No. 10 693 574 filed on Oct. 24 2003 entitled SYSTEMS AND METHODS FOR EXTENSIONS AND INHERITANCE FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM which is a continuation in part of U.S. patent application Ser. No. 10 646 580 filed on Aug. 21 2003 entitled SYSTEMS AND METHODS FOR DATA MODELING IN AN ITEM BASED STORAGE PLATFORM the contents of which are herein incorporated by reference.

This application is related by subject matter to the inventions disclosed in the following commonly assigned applications the contents of which are hereby incorporated by reference into this present application in their entirety and partially summarized herein for convenience U.S. patent application Ser. No. 10 647 058 filed on Aug. 21 2003 entitled SYSTEMS AND METHODS FOR REPRESENTING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM BUT INDEPENDENT OF PHYSICAL REPRESENTATION U.S. patent application Ser. No. 10 646 941 filed on Aug. 21 2003 entitled SYSTEMS AND METHODS FOR SEPARATING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM FROM THEIR PHYSICAL ORGANIZATION U.S. patent application Ser. No. 10 646 940 filed on Aug. 21 2003 entitled SYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A BASE SCHEMA FOR ORGANIZING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM U.S. patent application Ser. No. 10 646 632 filed on Aug. 21 2003 entitled SYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A CORE SCHEMA FOR PROVIDING A TOP LEVEL STRUCTURE FOR ORGANIZING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM U.S. patent application Ser. No. 10 646 645 filed on Aug. 21 2003 entitled SYSTEMS AND METHOD FOR REPRESENTING RELATIONSHIPS BETWEEN UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM U.S. patent application Ser. No. 10 646 575 filed on Aug. 21 2003 entitled SYSTEMS AND METHODS FOR INTERFACING APPLICATION PROGRAMS WITH AN ITEM BASED STORAGE PLATFORM U.S. patent application Ser. No. 10 646 646 filed on Aug. 21 2003 entitled STORAGE PLATFORM FOR ORGANIZING SEARCHING AND SHARING DATA U.S. patent application Ser. No. 10 692 779 filed on Oct. 24 2003 entitled SYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A DIGITAL IMAGES SCHEMA FOR ORGANIZING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM U.S. patent application Ser. No. 10 692 515 filed on Oct. 24 2003 entitled SYSTEMS AND METHODS FOR PROVIDING SYNCHRONIZATION SERVICES FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM U.S. patent application Ser. No. 10 692 508 filed on Oct. 24 2003 entitled SYSTEMS AND METHODS FOR PROVIDING RELATIONAL AND HIERARCHICAL SYNCHRONIZATION SERVICES FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM U.S. patent application Ser. No. 10 693 362 filed on Oct. 24 2003 entitled SYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A SYNCHRONIZATION SCHEMAS FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM and U.S. patent application Ser. No. 11 636 871 filed on even date herewith entitled SYSTEMS AND METHODS FOR EXTENSIONS AND INHERITANCE FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE SOFTWARE INTERFACE SYSTEM .

The present invention relates generally to the field of information storage and retrieval and more particularly to an active storage platform for organizing searching and sharing different types of data in a computerized system. Various embodiments of the present invention are directed to the use of extension and inheritance methods utilized by a hardware software interface system to manage data.

Individual disk capacity has been growing at roughly seventy percent 70 per year over the last decade. Moore s law accurately predicted the tremendous gains in central processing unit CPU power that has occurred over the years. Wired and wireless technologies have provided tremendous connectivity and bandwidth. Presuming current trends continue within several years the average laptop computer will possess roughly one terabyte TB of storage and contain millions of files and 500 gigabyte GB drives will become commonplace.

Consumers use their computers primarily for communication and organizing personal information whether it is traditional personal information manager PIM style data or media such as digital music or photographs. The amount of digital content and the ability to store the raw bytes has increased tremendously however the methods available to consumers for organizing and unifying this data has not kept pace. Knowledge workers spend enormous amounts of time managing and sharing information and some studies estimate that knowledge workers spend 15 25 of their time on non productive information related activities. Other studies estimate that a typical knowledge worker spends about 2.5 hours per day searching for information.

Developers and information technology IT departments invest significant amounts of time and money in building their own data stores for common storage abstractions to represent such things as people places times and events. Not only does this result in duplicated work but it also creates islands of common data with no mechanisms for common searching or sharing of that data. Just consider how many address books can exist today on a computer running the Microsoft Windows operating system. Many applications such as e mail clients and personal finance programs keep individual address books and there is little sharing among applications of the address book data that each such program individually maintains. Consequently a finance program like Microsoft Money does not share addresses for payees with the addresses maintained in an email contact folder like the one in Microsoft Outlook . Indeed many users have multiple devices and logically should synchronize their personal data amongst themselves and across a wide variety of additional sources including cell phones to commercial services such as MSN and AOL nevertheless collaboration of shared documents is largely achieved by attaching documents to e mail messages that is manually and inefficiently.

One reason for this lack of collaboration is that traditional approaches to the organization of information in computer systems have centered on the use of file folder and directory based systems file systems to organize pluralities of files into directory hierarchies of folders based on an abstraction of the physical organization of the storage medium used to store the files. The Multics operating system developed during the 1960s can be credited with pioneering the use of the files folders and directories to manage storable units of data at the operating system level. Specifically Multics used symbolic addresses within a hierarchy of files thereby introducing the idea of a file path where physical addresses of the files were not transparent to the user applications and end users . This file system was entirely unconcerned with the file format of any individual file and the relationships amongst and between files was deemed irrelevant at the operating system level that is other than the location of the file within the hierarchy . Since the advent of Multics storable data has been organized into files folders and directories at the operating system level. These files generally include the file hierarchy itself the directory embodied in a special file maintained by the file system. This directory in turn maintains a list of entries corresponding to all of the other files in the directory and the nodal location of such files in the hierarchy herein referred to as the folders . Such has been the state of the art for approximately forty years.

However while providing a reasonable representation of information residing in the computer s physical storage system a file system is nevertheless an abstraction of that physical storage system and therefore utilization of the files requires a level of indirection interpretation between what the user manipulates units having context features and relationships to other units and what the operating system provides files folders and directories . Consequently users applications and or end users have no choice but to force units of information into a file system structure even when doing so is inefficient inconsistent or otherwise undesirable. Moreover existing file systems know little about the structure of data stored in individual files and because of this most of the information remains locked up in files that may only be accessed and comprehensible to the applications that wrote them. Consequently this lack of schematic description of information and mechanisms for managing information leads to the creation of silos of data with little data sharing among the individual silos. For example many personal computer PC users have more than five distinct stores that contain information about the people they interact with on some level for example Outlook Contacts online account addressees Windows Address Book Quicken Payees and instant messaging IM buddy lists because organizing files presents a significant challenge to these PC users. Because most existing file systems utilize a nested folder metaphor for organizing files and folders as the number of files increases the effort necessary to maintain an organization scheme that is flexible and efficient becomes quite daunting. In such situations it would be very useful to have multiple classifications of a single file however using hard or soft links in existing file systems is cumbersome and difficult to maintain.

Several unsuccessful attempts to address the shortcomings of file systems have been made in the past. Some of these previous attempts have involved the use of content addressable memory to provide a mechanism whereby data could be accessed by content rather than by physical address. However these efforts have proven unsuccessful because while content addressable memory has proven useful for small scale use by devices such as caches and memory management units large scale use for devices such as physical storage media has not yet been possible for a variety of reasons and thus such a solution simply does not exist. Other attempts using object oriented database OODB systems have been made but these attempts while featuring strong database characteristics and good non file representations were not effective in handling file representations and could not replicate the speed efficiency and simplicity of the file and folder based hierarchical structure at the hardware software interface system level. Other efforts such as those that attempted to use SmallTalk and other derivatives proved to be quite effective at handling file and non file representations but lacked database features necessary to efficiently organize and utilize the relationships that exist between the various data files and thus the overall efficiency of such systems was unacceptable. Yet other attempts to use BeOS and other such operating systems research proved to be inadequate at handling non file representations the same core shortcoming of traditional file systems despite being able to adequately represent files while providing some necessary database features.

Database technology is another area of the art in which similar challenges exits. For example while the relational database model has been a great commercial success in truth independent software vendors ISV generally exercise a small portion of the functionality available in relational database software products such as Microsoft SQL Server . Instead most of an application s interaction with such a product is in the form of simple gets and puts . While there are a number of readily apparent reasons for this such as being platform or database agnostic one key reason that often goes unnoticed is that the database does not necessarily provide the exact abstractions that a major business application vendor really needs. For example while the real world has the notion of items such as customers or orders along with an order s embedded line items as items in and of themselves relational databases only talk in terms of tables and rows. Consequently while the application may desire to have aspects of consistency locking security and or triggers at the item level to name a few generally databases provide these features only at the table row level. While this may work fine if each item gets mapped to a single row in some table in the database in the case of an order with multiple line items there may be reasons why an item actually gets mapped to multiple tables and when that is the case the simple relational database system does not quite provide the right abstractions. Consequently an application must build logic on top of the database to provide these basic abstractions. In other words the basic relational model does not provide a sufficient platform for storage of data on which higher level applications can easily be developed because the basic relational model requires a level of indirection between the application and the storage system where the semantic structure of the data might only be visible in the application in certain instances. While some database vendors are building higher level functionality into their products such as providing object relational capabilities new organizational models and the like none have yet to provide the kind of comprehensive solution needed where a truly comprehensive solution is one which provides both useful data model abstractions such as Items Extensions Relationships and so on for useful domain abstractions such as Persons Locations Events etc. .

In view of the foregoing deficiencies in existing data storage and database technologies there is a need for a new storage platform that provides an improved ability to organize search and share all types of data in a computer system a storage platform that extends and broadens the data platform beyond existing file systems and database systems and that is designed to be the store for all types of data. The present invention together with the related inventions incorporated by reference earlier herein satisfies this need. In particular the present invention provides methods of extension and inheritance for objects manipulated by a hardware software interface system.

The following summary provides an overview of various aspects of the invention described in the context of the related inventions incorporated by reference earlier herein the related inventions . This summary is not intended to provide an exhaustive description of all of the important aspects of the invention nor to define the scope of the invention. Rather this summary is intended to serve as an introduction to the detailed description and figures that follow.

The present invention as well as the related inventions are collectively directed to a storage platform for organizing searching and sharing data. The storage platform of the present invention extends and broadens the concept of data storage beyond existing file systems and database systems and is designed to be the store for all types of data including structured non structured or semi structured data.

The storage platform of the present invention comprises a data store implemented on a database engine. The database engine comprises a relational database engine with object relational extensions. The data store implements a data model that supports organization searching sharing synchronization and security of data. Specific types of data are described in schemas and the platform provides a mechanism to extend the set of schemas to define new types of data essentially subtypes of the basic types provides by the schemas . A synchronization capability facilitates the sharing of data among users or systems. File system like capabilities are provided that allow interoperability of the data store with existing file systems but without the limitation of such traditional file systems. A change tracking mechanism provides the ability track changes to the data store. The storage platform further comprises a set of application program interfaces that enable applications to access all of the foregoing capabilities of the storage platform and to access the data described in the schemas.

The data model implemented by the data store defines units of data storage in terms of items elements and relationships. An item is a unit of data storable in a data store and can comprise one or more elements and relationships. An element is an instance of a type comprising one or more fields also referred to herein as a property . A relationship is a link between two items. As used herein these and other specific terms may be capitalized in order to offset them from other terms used in close proximity however there is no intention whatsoever to distinguish between a capitalized term e.g. Item and the same term when not capitalized e.g. item and no such distinction should be presumed or implied. 

The computer system further comprises a plurality of Items where each Item constitutes a discrete storable unit of information that can be manipulated by a hardware software interface system a plurality of Item Folders that constitute an organizational structure for said Items and a hardware software interface system for manipulating a plurality of Items and wherein each Item belongs to at least one Item Folder and may belong to more than one Item Folder.

An Item or some of the Item s property values may be computed dynamically as opposed to being derived from a persistent store. In other words the hardware software interface system does not require that the Item be stored and certain operations are supported such as the ability to enumerate the current set of Items or the ability to retrieve an Item given its identifier which is more fully described in the sections that describe the application programming interface or API of the storage platform for example an Item might be the current location of a cell phone or the temperature reading on a temperature sensor. The hardware software interface system may manipulate a plurality of Items and may further comprise Items interconnected by a plurality of Relationships managed by the hardware software interface system.

A hardware software interface system for the computer system further comprises a core schema to define a set of core Items which said hardware software interface system understands and can directly process in a predetermined and predictable way. To manipulate a plurality of Items the computer system interconnects said Items with a plurality of Relationships and manages said Relationships at the hardware software interface system level.

The API of the storage platform provides data classes for each item item extension and relationship defined in the set of storage platform schemas. In addition the application programming interface provides a set of framework classes that define a common set of behaviors for the data classes and that together with the data classes provide the basic programming model for the storage platform API. The storage platform API provides a simplified query model that enables application programmers to form queries based on various properties of the items in the data store in a manner that insulates the application programmer from the details of the query language of the underlying database engine. The storage platform API also collects changes to an item made by an application program and then organizes them into the correct updates required by the database engine or any kind of storage engine on which the data store is implemented. This enables application programmers to make changes to an item in memory while leaving the complexity of data store updates to the API.

Through its common storage foundation and schematized data the storage platform of the present invention enables more efficient application development for consumers knowledge workers and enterprises. It offers a rich and extensible application programming interface that not only makes available the capabilities inherent in its data model but also embraces and extends existing file system and database access methods.

Within view of this overarching structure of interrelated inventions described in detail in Section II of the Detailed Description the present invention is specifically directed to the use of Extensions to extend functionality of Item and Property types as well as to the use of Inheritance to facilitate efficient searching and organization among related Items described in detail in Section III of the Detailed Description . Other features and advantages of the invention may become apparent from the following detailed description of the invention and accompanying drawings.

The subject matter of the present invention is described with specificity to meet statutory requirements. However the description itself is not intended to limit the scope of this patent. Rather the inventors have contemplated that the claimed subject matter might also be embodied in other ways to include different steps or combinations of steps similar to the ones described in this document in conjunction with other present or future technologies. Moreover although the term step may be used herein to connote different elements of methods employed the term should not be interpreted as implying any particular order among or between various steps herein disclosed unless and except when the order of individual steps is explicitly described.

Numerous embodiments of the present invention may execute on a computer. and the following discussion is intended to provide a brief general description of a suitable computing environment in which the invention may be implemented. Although not required various aspects of the invention may be described in the general context of computer executable instructions such as program modules being executed by a computer such as a client workstation or a server. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Moreover the invention may be practiced with other computer system configurations including hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

As shown in an exemplary general purpose computing system includes a conventional personal computer or the like including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the personal computer such as during start up is stored in ROM . The personal computer may further include a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment. Likewise the exemplary environment may also include many types of monitoring devices such as heat sensors and security or fire alarm systems and other sources of information.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the personal computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers. The exemplary system of also includes a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The personal computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the personal computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the personal computer typically includes a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

As illustrated in the block diagram of a computer system can be roughly divided into three component groups the hardware component the hardware software interface system component and the applications programs component also referred to as the user component or software component in certain contexts herein .

In various embodiments of a computer system and referring back to the hardware component may comprise the central processing unit CPU the memory both ROM and RAM the basic input output system BIOS and various input output I O devices such as a keyboard a mouse a monitor and or a printer not shown among other things. The hardware component comprises the basic physical infrastructure for the computer system .

The applications programs component comprises various software programs including but not limited to compilers database systems word processors business programs videogames and so forth. Application programs provide the means by which computer resources are utilized to solve problems provide solutions and process data for various users machines other computer systems and or end users .

The hardware software interface system component comprises and in some embodiments may solely consist of an operating system that itself comprises in most cases a shell and a kernel. An operating system OS is a special program that acts as an intermediary between application programs and computer hardware. The hardware software interface system component may also comprise a virtual machine manager VMM a Common Language Runtime CLR or its functional equivalent a Java Virtual Machine JVM or its functional equivalent or other such software components in the place of or in addition to the operating system in a computer system. The purpose of a hardware software interface system is to provide an environment in which a user can execute application programs. The goal of any hardware software interface system is to make the computer system convenient to use as well as utilize the computer hardware in an efficient manner.

The hardware software interface system is generally loaded into a computer system at startup and thereafter manages all of the application programs in the computer system. The application programs interact with the hardware software interface system by requesting services via an application program interface API . Some application programs enable end users to interact with the hardware software interface system via a user interface such as a command language or a graphical user interface GUI .

A hardware software interface system traditionally performs a variety of services for applications. In a multitasking hardware software interface system where multiple programs may be running at the same time the hardware software interface system determines which applications should run in what order and how much time should be allowed for each application before switching to another application for a turn. The hardware software interface system also manages the sharing of internal memory among multiple applications and handles input and output to and from attached hardware devices such as hard disks printers and dial up ports. The hardware software interface system also sends messages to each application and in certain case to the end user regarding the status of operations and any errors that may have occurred. The hardware software interface system can also offload the management of batch jobs e.g. printing so that the initiating application is freed from this work and can resume other processing and or operations. On computers that can provide parallel processing a hardware software interface system also manages dividing a program so that it runs on more than one processor at a time.

A hardware software interface system shell simply referred to herein as a shell is an interactive end user interface to a hardware software interface system. A shell may also be referred to as a command interpreter or in an operating system as an operating system shell . A shell is the outer layer of a hardware software interface system that is directly accessible by application programs and or end users. In contrast to a shell a kernel is a hardware software interface system s innermost layer that interacts directly with the hardware components.

While it is envisioned that numerous embodiments of the present invention are particularly well suited for computerized systems nothing in this document is intended to limit the invention to such embodiments. On the contrary as used herein the term computer system is intended to encompass any and all devices capable of storing and processing information and or capable of using the stored information to control the behavior or execution of the device itself regardless of whether such devices are electronic mechanical logical or virtual in nature.

In most computer systems today files are units of storable information that may include the hardware software interface system as well as application programs data sets and so forth. In all modern hardware software interface systems Windows Unix Linux Mac OS virtual machine systems and so forth files are the basic discrete storable and retrievable units of information e.g. data programs and so forth that can be manipulated by the hardware software interface system. Groups of files are generally organized in folders. In Microsoft Windows the Macintosh OS and other hardware software interface systems a folder is a collection of files that can be retrieved moved and otherwise manipulated as single units of information. These folders in turn are organized in a tree based hierarchical arrangement called a directory discussed in more detail herein below . In certain other hardware software interface systems such as DOS z OS and most Unix based operating systems the terms directory and or folder are interchangeable and early Apple computer systems e.g. the Apple IIe used the term catalog instead of directory however as used herein all of these terms are deemed to be synonymous and interchangeable and are intended to further include all other equivalent terms for and references to hierarchical information storage structures and their folder and file components.

Traditionally a directory a.k.a. a directory of folders is a tree based hierarchical structure wherein files are grouped into folders and folder in turn are arranged according to relative nodal locations that comprise the directory tree. For example as illustrated in a DOS based file system base folder or root directory may comprise a plurality of folders each of which may further comprise additional folders as subfolders of that particular folder and each of these may also comprise additional folders ad infinitum. Each of these folders may have one or more files although at the hardware software interface system level the individual files in a folder have nothing in common other than their location in the tree hierarchy. Not surprisingly this approach of organizing files into folder hierarchies indirectly reflects the physical organization of typical storage media used to store these files e.g. hard disks floppy disks CD ROMs etc. .

In addition to the foregoing each folder is a container for its subfolders and its files that is each folder owns its subfolders and files. For example when a folder is deleted by the hardware software interface system that folder s subfolders and files are also deleted which in the case of each subfolder further includes its own subfolders and files recursively . Likewise each file is generally owned by only one folder and although a file can be copied and the copy located in a different folder a copy of a file is itself a distinct and separate unit that has no direct connection to the original e.g. changes to the original file are not mirrored in the copy file at the hardware software interface system level . In this regard files and folders are therefore characteristically physical in nature because folders are the treated like physical containers and files are treated as discrete and separate physical elements inside these containers.

The present invention in combination with the related inventions incorporated by reference as discussed earlier herein is directed to a storage platform for organizing searching and sharing data. The storage platform of the present invention extends and broadens the data platform beyond the kinds of existing file systems and database systems discussed above and is designed to be the store for all types of data including a new form of data called Items.

Referring to a storage platform comprises a data store implemented on a database engine . In one embodiment the database engine comprises a relational database engine with object relational extensions. In one embodiment the relational database engine comprises the Microsoft SQL Server relational database engine. The data store implements a data model that supports the organization searching sharing synchronization and security of data. Specific types of data are described in schemas such as schemas and the storage platform provides tools for deploying those schemas as well as for extending those schemas as described more fully below.

A change tracking mechanism implemented within the data store provides the ability track changes to the data store. The data store also provides security capabilities and a promotion demotion capability both of which are discussed more fully below. The data store also provides a set of application programming interfaces to expose the capabilities of the data store to other storage platform components and application programs e.g. application programs and that utilize the storage platform. The storage platform of the present invention still further comprises an application programming interfaces API which enables application programs such as application programs and to access all of the foregoing capabilities of the storage platform and to access the data described in the schemas. The storage platform API may be used by application programs in combination with other APIs such as the OLE DB API and the Microsoft Windows Win32 API .

The storage platform of the present invention may provide a variety of services to application programs including a synchronization service that facilitates the sharing of data among users or systems. For example the synchronization service may enable interoperability with other data stores having the same format as data store as well as access to data stores having other formats. The storage platform also provides file system capabilities that allow interoperability of the data store with existing file systems such as the Windows NTFS files system . In at least some embodiments the storage platform may also provide application programs with additional capabilities for enabling data to be acted upon and for enabling interaction with other systems. These capabilities may be embodied in the form of additional services such as an Info Agent service and a notification service as well as in the form of other utilities .

In at least some embodiments the storage platform is embodied in or forms an integral part of the hardware software interface system of a computer system. For example and without limitation the storage platform of the present invention may be embodied in or form an integral part of an operating system a virtual machine manager VMM a Common Language Runtime CLR or its functional equivalent or a Java Virtual Machine JVM or its functional equivalent. Through its common storage foundation and schematized data the storage platform of the present invention enables more efficient application development for consumers knowledge workers and enterprises. It offers a rich and extensible programming surface area that not only makes available the capabilities inherent in its data model but also embraces and extends existing file system and database access methods.

In the following description and in various ones of the figures the storage platform of the present invention may be referred to as WinFS. However use of this name to refer to the storage platform is solely for convenience of description and is not intended to be limiting in any way.

The data store of the storage platform of the present invention implements a data model that supports the organization searching sharing synchronization and security of data that resides in the store. In the data model of the present invention an Item is the fundamental unit of storage information. The data model provides a mechanism for declaring Items and Item extensions and for establishing relationships between Items and for organizing Items in Item Folders and in Categories as described more fully below.

The data model relies on two primitive mechanisms Types and Relationships. Types are structures which provide a format which governs the form of an instance of the Type. The format is expressed as an ordered set of Properties. A Property is a name for a value or set of values of a given Type. For example a USPostalAddress type might have the properties Street City Zip State in which Street City and State are of type String and Zip is of Type Int32. Street may be multi valued i.e. a set of values allowing the address to have more than one value for the Street property. The system defines certain primitive types that can be used in the construction of other types these include String Binary Boolean Int16 Int32 Int64 Single Double Byte DateTime Decimal and GUID. The Properties of a Type may be defined using any of the primitive types or with some restrictions noted below any of the constructed types. For example a Location Type might be defined that had Properties Coordinate and Address where the Address Property is of Type USPostalAddress as described above. Properties may also be required or optional.

Relationships can be declared and represent a mapping between the sets of instances of two types. For example there may be a Relationship declared between the Person Type and the Location Type called LivesAt which defines which people live at which locations. The Relationship has a name two endpoints namely a source endpoint and a target endpoint. Relationships may also have an ordered set of properties. Both the Source and Target endpoints have a Name and a Type. For example the LivesAt Relationship has a Source called Occupant of Type Person and a Target called Dwelling of Type Location and in addition has properties StartDate and EndDate indicating the period of time for which the occupant lived at the dwelling. Note that a Person may live at multiple dwellings over time and a dwelling may have multiple occupants so the most likely place to put the StartDate and EndDate information is on the relationship itself.

Relationships define a mapping between instances that is constrained by the types given as the endpoint types. For example the LivesAt relationship cannot be a relationship in which an Automobile is the Occupant because an Automobile is not a Person.

The data model does allow the definition of a subtype supertype relationship between types. The subtype supertype relationship also known as the BaseType relationship is defined in such a way that if Type A is a BaseType for Type B it must be the case that every instance of B is also an instance of A. Another way of expressing this is that every instance that conforms to B must also conform to A. If for example A has a property Name of Type String while B has a property Age of Type Int16 it follows that any instance of B must have both a Name and an Age. The type hierarchy may be envisaged as an tree with a single supertype at the root. The branches from the root provide the first level subtypes the branches at this level provide the second level subtypes and so on to the leaf most subtypes which themselves do not have any subtypes. The tree is not constrained to be of a uniform depth but cannot contain any cycles. A given Type may have zero or many subtypes and zero or one super type. A given instance may conform to at most one type together with that type s super types. To put it another way for a given instance at any level in the tree the instance may conform to at most one subtype at that level. A type is said to be Abstract if instances of the type must also be an instance of a subtype of the type.

An Item is a unit of storable information that unlike a simple file is an object having a basic set of properties that are commonly supported across all objects exposed to an end user or application program by the storage platform. Items also have properties and relationships that are commonly supported across all Item types including features that allow new properties and relationships to be introduced as discussed below.

Items are the objects for common operations such as copy delete move open print backup restore replicate and so forth. Items are the units that can be stored and retrieved and all forms of storable information manipulated by the storage platform exist as Items properties of Items or Relationships between Items each of which is discussed in greater detail herein below.

Items are intended to represent real world and readily understandable units of data like Contacts People Services Locations Documents of all various sorts and so on. is a block diagram illustrating the structure of an Item. The unqualified name of the Item is Location . The qualified name of the Item is Core.Location which indicates that this Item structure is defined as a specific type of Item in the Core Schema. The Core Schema is discussed in more detail later herein. 

The Location Item has a plurality of properties including EAddresses MetropolitanRegion Neighborhood and PostalAddresses. The specific type of property for each is indicated immediately following the property name and is separated from the property name by a colon . To the right of the type name the number of values permitted for that property type is indicated between brackets wherein an asterisk to the right of the colon indicates an unspecified and or unlimited number many . A 1 to the right of the colon indicates that there can be at most one value. A zero 0 to the left of the colon indicates that the property is optional there may be no value at all . A 1 to the left of the colon indicates that there must be at least one value the property is required . Neighborhood and MetropolitanRegion are both of type nvarchar or equivalent which is a predefined data type or simple type and denoted herein by the lack of capitalization . EAddresses and PostalAddresses however are properties of defined types or complex types as denoted herein by capitalization of types EAddress and PostalAddress respectively. A complex type is type that is derived from one or more simple data types and or from other complex types. The complex types for the properties of an Item also constitute nested elements since the details of the complex type are nested into the immediate Item to define its properties and the information pertaining to these complex types is maintained with the Item that has these properties within the Item s boundary as discussed later herein . These concepts of typing are well known and readily appreciated by those of skill in the art.

Similar to but distinct from properties and their property types Items inherently represent their own Item Types that can also be the subject of subtyping. In other words the storage platform in several embodiments of the present invention allows an Item to be a subtype of another Item whereby the one Item inherits the properties of the other parent Item . Moreover for various embodiments of the present invention every Item is a subtype of the Item Item type which is the first and foundational Item type found in the Base Schema. The Base Schema will also be discussed in detail later herein. illustrates an Item the Location Item in this Instance as being a subtype of the Item Item type found in the Base Schema. In this drawing the arrow indicates that the Location Item like all other Items is a subtype of the Item Item type. The Item Item type as the foundational Item from which all other Items are derived has a number of important properties such as ItemId and various timestamps and thereby defines the standard properties of all Items in an operating system. In the present figure these properties of the Item Item type are inherited by Location and thereby become properties of Location.

Another way to represent the properties in the Location Item inherited from the Item Item type is to draw Location with the individual properties of each property type from the parent Item listed therein. is a block diagram illustrating the Location Item wherein its inherited types described in addition to its immediate properties. It should be noted and understood that this Item is the same Item illustrated in although in the present figure Location is illustrated with all of its properties both immediate shown in both this figure and FIG. A and inherited shown in this figure but not whereas in these properties are referenced by showing with an arrow that the Location Item is a subtype of the Item Item type .

Items are stand alone objects thus if you delete an Item all of the Items immediate and inherited properties are also deleted. Similarly when retrieving an Item what is received is the Item and all of its immediate and inherited properties including the information pertaining to its complex property types . Certain embodiments of the present invention may enable one to request a subset of properties when retrieving a specific Item however the default for many such embodiments is to provide the Item with all of its immediate and inherited properties when retrieved. Moreover the properties of Items can also be extended by adding new properties to the existing properties of that Item s type. These extensions are thereafter bona fide properties of the Item and subtypes of that Item type may automatically include the extension properties.

The boundary of the Item is represented by its properties including complex property types extensions and so forth . An Item s boundary also represents the limit of an operation performed on an Item such as copy delete move create and so on. For example in several embodiments of the present invention when an Item is copied everything within that Item s boundary is also copied. For each Item the boundary encompasses the following 

Items are uniquely identified within the global items space with an ItemID. The Base.Item type defines a field ItemID of type GUID that stores the identity for the Item. An Item must have exactly one identity in the data store .

An item reference is a data structure that contains information to locate and identify an Item. In the data model an abstract type is defined named ItemReference from which all item reference types derive. The ItemReference type defines a virtual method named Resolve. The Resolve method resolves the ItemReference and returns an Item. This method is overridden by the concrete subtypes of ItemReference which implement a function that retrieves an Item given a reference. The Resolve method is invoked as part of the storage platform API .

ItemIDReference is a subtype of ItemReference. It defines a Locator and an ItemID field. The Locator field names i.e. identifies an item domain. It is processed by a locator resolution method that can resolve the value of the Locator to an item domain. The ItemID field is of type ItemID

ItemPathReference is a specialization of ItemReference that defines a Locator and a Path field. The Locator field identifies an item domain. It is processed by a locator resolution method that can resolve the value of the Locator to an item domain. The Path field contains a relative path in the storage platform namespace rooted at the item domain provided by the Locator.

This type of reference cannot be used in a set operation. The reference must generally be resolved through a path resolution process. The Resolve method of the storage platform API provides this functionality.

The reference forms discussed above are represented through the reference type hierarchy illustrated in . Additional reference types that inherit from these types can be defined in the schemas. They can be used in a relationship declaration as type of the target field.

As discussed more fully below groups of Items can are organized into special Items called Item Folders which are not to be confused with file folders . Unlike in most file systems however an Item can belong to more than one Item Folder such that when an Item is accessed in one Item Folder and revised this revised Item can then be accessed directly from another Item folder. In essence although access to an Item may occur from different Item Folders what is actually being accessed is in fact the very same Item. However an Item Folder does not necessarily own all of its member Items or may simply co own Items in conjunction with other folders such that the deletion of an Item Folder does not necessarily result in the deletion of the Item. Nevertheless in several embodiments of the present invention an Item must belong to at least one Item Folder so that if the sole Item Folder for a particular Item is deleted then for some embodiments the Item is automatically deleted or in alternative embodiments the Item automatically becomes a member of a default Item Folder e.g. a Trash Can Item Folder conceptually similar to similarly named folders used in various file and folder based systems .

As also discussed more fully below Items may also belong to Categories based on common described characteristic such as a an Item Type or Types b a specific immediate or inherited property or properties or c a specific value or values corresponding to an Item property. For example a Item comprising specific properties for personal contact information might automatically belong to a Contact Category and any Item having contact information properties would likewise automatically belong to this Category. Likewise any Item having a location property with a value of New York City might automatically belong to a NewYorkCity Category.

Categories are conceptually different form Item Folders in that whereas Item Folders may comprise Items that are not interrelated i.e. without a common described characteristic each Item in a Category has a common type property or value a commonality that is described for that Category and it is this commonality that forms the basis for its relationship to and among the other Items in the Category. Moreover whereas an Item s membership in a particular Folder is not compulsory based on any particular aspect of that Item for certain embodiments all Items having a commonality categorically related to a Category might automatically become a member of the Category at the hardware software interface system level. Conceptually Categories can also be thought of as virtual Item Folders whose membership is based on the results of a specific query such as in the context of a database and Items that meet the conditions of this query defined by the commonalities of the Category would thus comprise the Category s membership.

In contrast to files folders and directories the Items Item Folders and Categories of the present invention are not characteristically physical in nature because they do not have conceptual equivalents of physical containers and therefore Items may exist in more than one such location. The ability for Items to exist in more than one Item Folder location as well as being organized into Categories provides an enhanced and enriched degree of data manipulation and storage structure capabilities at the hardware software interface level beyond that currently available in the art.

To provide a universal foundation for the creation and use of Items various embodiments of the storage platform of the present invention comprise a Base Schema that establishes a conceptual framework for creating and organizing Items and properties. The Base Schema defines certain special types of Items and properties and the features of these special foundational types from which subtypes can be further derived. The use of this Base Schema allows a programmer to conceptually distinguish Items and their respective types from properties and their respective types . Moreover the Base Schema sets forth the foundational set of properties that all Items may possess as all Items and their corresponding Item Types are derived from this foundational Item in the Base Schema and its corresponding Item Type .

As illustrated in and in regard to several embodiments of the present invention the Base Schema defines three top level types Item Extension and PropertyBase. As shown the Item type is defined by the properties of this foundational Item Item type. In contrast the top level property type PropertyBase has no predefined properties and is merely the anchor from which all other property types are derived and through which all derived property types are interrelated being commonly derived from the single property type . The Extension type properties define which Item the extension extends as well as identification to distinguish one extension from another as an Item may have multiple extensions.

ItemFolder is a subtype of the Item Item type that in addition to the properties inherited from Item features a Relationship for establishing links to its members if any whereas both IdentityKey and Property are subtypes of PropertyBase. CategoryRef in turn is a subtype of IdentityKey.

Various embodiments of the storage platform of the present invention further comprise a Core Schema that provides a conceptual framework for top level Items type structures. is a block diagram illustrating Items in the Core Schema and is a block diagram illustrating the property types in the Core Schema. The distinction made between files with different extensions .com .exe .bat .sys etc. and other such criteria in file and folder based systems is analogous to the function of the Core Schema. In the Item based hardware software interface system the Core Schema defines a set of core Item types that directly by Item type or indirectly by Item subtype characterize all Items into one or more Core Schema Item types which the Item based hardware software interface system understands and can directly process in a predetermined and predictable way. The predefined Item types reflect the most common Items in the Item based hardware software interface system and thus a level of efficiency is gained by the Item based hardware software interface system understanding these predefined Item types that comprise the Core Schema.

In certain embodiments the Core Schema is not extendable that is no additional Item types can be subtyped directly from the Item type in the Base Schema except for the specific predefined derived Item types that are part of the Core Schema. By preventing extensions to the Core Schema that is by preventing the addition of new Items to the Core Schema the storage platform mandates the use of the Core Schema Item types since every subsequent Item type is necessarily a subtype of a Core Schema Item type. This structure enables a reasonable degree of flexibility in defining additional Item types while also preserving the benefits of having a predefined set of core Item types.

For various embodiments of the present invention and in reference to the specific Item types supported by the Core Schema may include one or more of the following 

Likewise and in reference to the specific property types supported by the Core Schema may include one or more of the following 

Relationships are binary relationships where one Item is designated as source and the other Item as target. The source Item and the target Item are related by the relationship. The source Item generally controls the life time of the relationship. That is when the source Item is deleted the relationship between the Items is also deleted.

Relationships are classified into Containment and Reference relationships. The containment relationships control the life time of the target Items while the reference relationships do not provide any life time management semantics. illustrates the manner in which relationships are classified.

The Containment relationship types are further classified into Holding and Embedding relationships. When all holding relationships to an Item are removed the Item is deleted. A holding relationship controls the life time of the target through a reference counting mechanism. The embedding relationships enable modeling of compound Items and can be thought of as exclusive holding relationships. An Item can be a target of one or more holding relationships but an Item can be target of exactly one embedding relationship. An Item that is a target of an embedding relationship can not be a target of any other holding or embedding relationships.

Reference relationships do not control the lifetime of the target Item. They may be dangling the target Item may not exist. Reference relationships can be used to model references to Items anywhere in the global Item name space i.e. including remote data stores .

Fetching an Item does not automatically fetch its relationships. Applications must explicitly request the relationships of an Item. In addition modifying a relationship does not modify the source or the target Item similarly adding a relationship does not affect the source target Item.

The source Item is the owner of the relationship. While an Item designated as owner controls the life time of the relationship the relationship itself is separate from the Items it relates. The storage platform API provides mechanisms for exposing relationships associated with an Item.

This is an example of a Reference relationship. The relationship can not be created if the person Item that is referenced by the source reference does not exist. Also if the person Item is deleted the relationship instances between the person and organization are deleted. However if the Organization Item is deleted the relationship is not deleted and it is dangling.

Holding relationships are used to model reference count based life time management of the target Items.

An Item can be a source endpoint for zero or more relationships to Items. An Item that is not an embedded Item can be a target of in one or more holding relationships.

The target endpoint reference type must be ItemIDReference and it must reference an Item in the same store as the relationship instance.

Holding relationships enforce lifetime management of the target endpoint. The creation of a holding relationship instance and the Item that it is targeting is an atomic operation. Additional holding relationship instances can be created that are targeting the same Item. When the last holding relationship instance with a given Item as target endpoint is deleted the target Item is also deleted.

The types of the endpoint Items specified in the relationship declaration will generally be enforced when an instance of the relationship is created. The types of the endpoint Items can not be changed after the relationship is established.

Holding relationships play a key role in forming the Item namespace. They contain the Name property that defines the name of the target Item relative to the source Item. This relative name is unique for all the holding relationships sourced from a given Item. The ordered list of this relative names starting from the root Item to a given Item forms the full name to the Item.

The holding relationships form a directed acyclic graph DAG . When a holding relationship is created the system ensures that a cycle is not created thus ensuring that the Item namespace forms a DAG.

While the holding relationship controls the life time of the target Item it does not control the operational.consistency of the target endpoint Item. The target Item is operationally independent from the Item that owns it through a holding relationship. Copy Move Backup and other operations on an Item that is a source of a holding relationship do not affect the Item that is a target of the same relationship for example that is backing up a Folder Item does not automatically backup all the Items in the folder targets of the FolderMember relationship .

Embedding relationships model the concept of exclusive control of the lifetime of the target Item. They enable the concept of compound Items.

The creation of an embedding relationship instance and the Item that it is targeting is an atomic operation. An Item can be a source of zero or more embedding relationship. However an Item can be a target of one and only one embedding relationship. An Item that is a target of an embedding relationship can not be a target of a holding relationship.

The target endpoint reference type must be ItemIDReference and it must reference an Item in the same data store as the relationship instance.

The types of the endpoint Items specified in the relationship declaration will generally be enforced when an instance of the relationship is created. The types of the endpoint Items can not be changed after the relationship is established.

Embedding relationships control the operational consistency of the target endpoint. For example the operation of serializing of an Item may include serialization of all the embedding relationships that source from that Item as well as all of their targets copying an Item also copies all its embedded Items.

The reference relationship does not control life time of the Item it references. Even more the reference relationships do not guarantee the existence of the target nor do they guarantee the type of the target as specified in the relationship declaration. This means that the reference relationships can be dangling. Also the reference relationship can reference Items in other data stores. Reference relationships can be thought of as a concept similar to links in web pages.

Any reference type is allowed in the target endpoint. The Items that participate in a reference relationship can be of any Item type.

Reference relationships are used to model most non lifetime management relationships between Items. Since the existence of the target is not enforced the reference relationship is convenient to model loosely coupled relationships. The reference relationship can be used to target Items in other data stores including stores on other computers.

In at least one embodiment the storage platform of the present invention supports ordering of relationships. The ordering is achieved through a property named Order in the base relationship definition. There is no uniqueness constraint on the Order field. The order of the relationships with the same order property value is not guaranteed however it is guaranteed that they may be ordered after relationships with lower order value and before relationships with higher order field value.

Applications can get the relationships in the default order by ordering on the combination SourceItemID RelationshipID Order . All relationship instances sourced from a given Item are ordered as a single collection regardless of the type of the relationships in the collection. This however guarantees that all relationships of a given type e.g. FolderMembers are an ordered subset of the relationship collection for a given Item.

The data store API for manipulating relationships implement a set of operations that support ordering of relationships. The following terms are introduced to help explain the operations 

As previously mentioned every Item must be a member of an Item Folder. In terms of Relationships every Item must have a relationship with an Item Folder. In several embodiments of the present invention certain relationships are represented by Relationships existing between the Items.

As implemented for various embodiments of the present invention a Relationship provides a directed binary relationship that is extended by one Item the source to another Item the target . A Relationship is owned by the source Item the Item that extended it and thus the Relationship is removed if the source is removed e.g. the Relationship is deleted when the source Item is deleted . Moreover in certain instances a Relationship may share ownership of co own the target Item and such ownership might be reflected in the IsOwned property or its equivalent of the Relationship as shown in for the Relationship property type . In these embodiments creation of a new IsOwned Relationship automatically increments a reference count on the target Item and deletion of such a Relationship may decrement the reference count on the target Item. For these specific embodiments Items continue to exist if they have a reference count greater than zero and are automatically deleted if and when the count reaches zero. Again an Item Folder is an Item that has or is capable of having a set of Relationships to other Items these other Items comprising the membership of the Item Folder. Other actual implementations of Relationships are possible and anticipated by the present invention to achieve the functionality described herein.

Regardless of actual implementation a Relationship is a selectable connection from one object to another. The ability for an Item to belong to more than one Item Folder as well as to one or more Categories and whether these Items Folders and Categories are public or private is determined by the meanings given to the existence or lack thereof in an Item based structure. These logical Relationships are the meanings assigned to a set of Relationships regardless of physical implementation which are specifically employed to achieve the functionality described herein. Logical Relationships are established between the Item and its Item Folder s or Categories and vice versa because in essence Item Folders and Categories are each a special type of Item. Consequently Item Folders and Categories can be acted upon the same way as any other Item copied added to an email message embedded in a document and so and so forth without limitation and Item Folders and Categories can be serialized and de serialized imported and exported using the same mechanisms as for other Items. For example in XML all Items might have a serialization format and this format applies equally to Item Folders Categories and Items. 

The aforementioned Relationships which represent the relationship between an Item and it Item Folder s can logically extend from the Item to the Item Folder from the Item Folder to the Item or both. A Relationship that logically extends from an Item to an Item Folder denotes that the Item Folder is public to that Item and shares its membership information with that Item conversely the lack of a logical Relationship from an Item to an Item Folder denotes that the Item Folder is private to that Item and does not share its membership information with that Item. Similarly a Relationship that logically extends from an Item Folder to an Item denotes that the Item is public and sharable to that Item Folder whereas the lack of a logical Relationship from the Item Folder to the Item denotes that the Item is private and non sharable. Consequently when an Item Folder is exported to another system it is the public Items that are shared in the new context and when an Item searches its Items Folders for other sharable Items it is the public Item Folders that provide the Item with information regarding sharable Items that belong thereto.

As previously discussed the Items in an Item Folder do not need to share a commonality because Item Folders are not described. Categories on the other hand are described by a commonality that is common to all of its member Items. Consequently the membership of a Category is inherently limited to Items having the described commonality and in certain embodiments all Items meeting the description of a Category are automatically made members of the Category. Thus whereas Item Folders allow trivial type structures to be represented by their membership Categories allow membership based on the defined commonality.

Of course Category descriptions are logical in nature and therefore a Category may be described by any logical representation of types properties and or values. For example a logical representation for a Category may be its membership to comprise Items have one of two properties or both. If these described properties for the Category are A and B then the Categories membership may comprise Items having property A but not B Items having property B but not A and Items having both properties A and B. This logical representation of properties is described by the logical operator OR where the set of members described by the Category are Items having property A OR B. Similar logical operands including without limitation AND XOR and NOT alone or in combination can also be used describe a category as will be appreciated by those of skill in the art.

Despite the distinction between Item Folders not described and Categories described Categories Relationship to Items and Items Relationship to Categories essentially the same way as disclosed herein above for Item Folders and Items in many embodiments of the present invention.

Finally because Categories and Item Folders are themselves Items and Items may Relationship to each other Categories may Relationship to Item Folders and vice versa and Categories Item Folders and Items can Relationship to other Categories Item Folders and Item respectively in certain alternative embodiments. However in various embodiments Item Folder structures and or Category structures are prohibited at the hardware software interface system level from containing cycles. Where Item Folder and Category structures are akin to directed graphs the embodiments that prohibit cycles are akin to directed acyclic graphs DAGs which by mathematical definition in the art of graph theory are directed graphs wherein no path starts and ends at the same vertex.

The storage platform is intended to be provided with an initial set of schemas as described above. In addition however in at least some embodiments the storage platform allows customers including independent software vendor ISVs to create new schemas i.e. new Item and Nested Element types . This section addresses the mechanism for creating such schemas by extending the Item types and Nested Element types or simply Element types defined in the initial set of schemas .

Since an Item type or Nested Element type defined by the initial set of storage platform schemas may not exactly match an ISV application s need it is necessary to allow ISVs to customize the type. This is allowed with the notion of Extensions. Extensions are strongly typed instances but a they cannot exist independently and b they must be attached to an Item or Nested Element.

In addition to addressing the need for schema extensibility Extensions are also intended to address the multi typing issue. Since in some embodiments the storage platform may not support multiple inheritance or overlapping subtypes applications can use Extensions as a way to model overlapping type instances e.g. Document is a legal document as well a secure document .

To provide Item extensibility the data model further defines an abstract type named Base.Extension. This is a root type for the hierarchy of extension types. Applications can subtype Base.Extension to create specific extension types.

The ItemID field contains the ItemID of the item that the extension is associated with. An Item with this ItemID must exist. The extension can not be created if the item with the given ItemID does not exist. When the Item is deleted all the extensions with the same ItemID are deleted. The tuple ItemID ExtensionID uniquely identifies an extension instance.

There are no constraints on the types of extensions that can be associated with a given Item type. Any extension type is allowed to extend any item type. When multiple extension instances are attached to an item they are independent from each other in both structure and behavior.

The extension instances are stored and accessed separately from the item. All extension type instances are accessible from a global extension view. An efficient query can be composed that will return all the instances of a given type of extension regardless of what type of item they are associated with. The storage platform APIs provides a programming model that can store retrieve and modify extensions on items.

The extension types can be type sub typed using the storage platform single inheritance model. Deriving from an extension type creates a new extension type. The structure or the behavior of an extension cannot override or replace the structure or behaviors of the item type hierarchy. Similar to Item types Extension type instances can be directly accessed through the view associated with the extension type. The ItemID of the extension indicates which item they belong to and can be used to retrieve the corresponding Item object from the global Item view. The extensions are considered part of the item for the purposes of operational consistency. The Copy Move Backup Restore and other common operations that the storage platform defines may operate on the extensions as part of the item.

A CRM application developer would like to attach a CRM application extension to the contacts stored in the storage platform. The application developer would define a CRM extension that would contain the additional data structure that the application can manipulate.

An HR application developer may want to also attach additional data with the Contact. This data is independent from the CRM application data. Again the application developer can create an extension

CRMExtension and HRExtension are two independent extensions that can be attached to Contact items. They are created and accessed independently of each other.

In the above example the fields and methods of the CRMExtension type cannot override fields or methods of the Contact hierarchy. It should be noted that instances of the CRMExtension type can be attached to Item types other than Contact.

When the Contact item is retrieved its item extensions are not automatically retrieved. Given a Contact item its related item extensions can be accessed by querying the global extension view for extensions with the same ItemId.

All CRMExtension extensions in the system can be accessed through the CRMExtension type view regardless of which item they belong to. All item extension of an item share the same item id. In the above example the Contact item instance and the attached CRMExtension and HRExtension instances the same ItemID.

The following table summarizes the similarities and differences between Item Extension and NestedElement types 

Nested Element types are not extended with the same mechanism as the Item types. Extensions of nested elements are stored and accessed with the same mechanisms as fields of nested element types.

The NestedElement type inherits from this type. The NestedElement element type additionally defines a field that is a multi set of Elements.

As mentioned above the data store is implemented on a database engine. In the present embodiment the database engine comprises a relational database engine that implements the SQL query language such as the Microsoft SQL Server engine with object relational extensions. This section describes the mapping of the data model that the data store implements to the relational store and provides information on the logical API consumed by storage platform clients in accordance with the present embodiment. It is understood however that a different mapping may be employed when a different database engine is employed. Indeed in addition to implementing the storage platform conceptual data model on a relational database engine it can also be implemented on other types of databases e.g. object oriented and XML databases.

An object oriented OO database system provides persistence and transactions for programming language objects e.g. C Java . The storage platform notion of an item maps well to an Object in object oriented systems though embedded collections would have to be added to Objects. Other storage platform type concepts like inheritance and nested element types also map object oriented type systems. Object oriented systems typically already support object identity hence item identity can be mapped to object identity. The item behaviors operations map well to object methods. However object oriented systems typically lack organizational capabilities and are poor in searching. Also object oriented systems to do not provide support for unstructured and semi structured data. To support the complete storage platform data model described herein concepts like relationships folders and extensions would need to be added to the object data model. In addition mechanisms like promotions synchronization notifications and security would need to be implemented.

Similar to object oriented systems XML databases based on XSD XML Schema Definition support a single inheritance based type system. The item type system of the present invention could be mapped to the XSD type model. XSDs also do not provide support for behaviors. The XSDs for items would have to be augmented with item behaviors. XML databases deal with single XSD documents and lack organization and broad search capabilities. As with object oriented databases to support the data model described herein other concepts like relationships and folders would need to be incorporated into such XML databases also mechanisms like synchronization notifications and security would need to be implemented.

In regard to the following subsections a few illustrations are provided to facilitate the general information disclosed is a diagram illustrating a notification mechanism. is a diagram illustrating an example in which two transactions are both inserting a new record into the same B Tree. illustrates a data change detection process. illustrates an exemplary directory tree. shows an example in which an existing folder of a directory based file system is moved into the storage platform data store.

In the present embodiment the relational database engine which in one embodiment comprises the Microsoft SQL Server engine supports built in scalar types. Built in scalar types are native and simple . They are native in the sense that the user cannot define their own types and they are simple in that they cannot encapsulate a complex structure. User defined types hereinafter UDTs provide a mechanism for type extensibility above and beyond the native scalar type system by enabling users to extend the type system by defining complex structured types. Once defined by a user a UDT can be used anywhere in the type system that a built in scalar type might be used

In accordance with an aspect of the present invention the storage platform schemas are mapped to UDT classes in the database engine store. Data store Items are mapped to UDT classes deriving from the Base.Item type. Like Items Extensions are also mapped to UDT classes and make use of inheritance. The root Extension type is Base.Extension from which all Extension types are derived.

A UDT is a CLR class it has state i.e. data fields and behavior i.e. routines . UDTs are defined using any of the managed languages C VB.NET etc. UDT methods and operators can be invoked in T SQL against an instance of that type. A UDT can be the type of a column in a row the type of a parameter of a routine in T SQL or the type of a variable in T SQL

The mapping of storage platform schemas to UDT classes is fairly straightforward at a high level. Generally a storage platform Schema is mapped to a CLR namespace. A storage platform Type is mapped to a CLR class. The CLR class inheritance mirrors the storage platform Type inheritance and a storage platform Property is mapped to a CLR class property.

Given the desirability for Items to be globally searchable and the support in the relational database of the present embodiment for inheritance and type substitutability one possible implementation for Item storage in the database store would be to store all Items in a single table with a column of type Base.Item. Using type substitutability Items of all types could be stored and searches could be filtered by Item type and sub type using Yukon s is of Type operator.

However due to concerns about the overhead associated with such an approach in the present embodiment the Items are divided by top level type such that Items of each type family are stored in a separate table. Under this partitioning scheme a table is created for each Item type inheriting directly from Base.Item. Types inheriting below these are stored in the appropriate type family table using type substitutability as described above. Only the first level of inheritance from Base.Item is treated specially.

A shadow table is used to store copies of globally searchable properties for all Items. This table may be maintained by the Update method of the storage platform API through which all data changes are made. Unlike the type family tables this global Item table contains only the top level scalar properties of the Item not the full UDT Item object. The global Item table allows navigation to the Item object stored in a type family table by exposing an ItemID and a TypeID. The ItemID will generally uniquely identify the Item within the data store. The TypeID may be mapped using metadata which is not described here to a type name and the view containing the Item. Since finding an Item by its ItemID may be a common operation both in the context of the global Item table and otherwise a GetItem function is provided to retrieve an Item object given an Item s ItemID.

For convenient access and to hide implementation details to the extent possible all queries of Items might be against views built on the Item tables described above. Specifically views may be created for each Item type against the appropriate type family table. These type views may select all Items of the associated type including sub types. For convenience in addition to the UDT object the views may expose columns for all of the top level fields of that type including inherited fields.

Extensions are very similar to Items and have some of the same requirements. As another root type supporting inheritance Extensions are subject to many of the same considerations and trade offs in storage. Because of this a similar type family mapping is applied to Extensions rather than a single table approach. Of course in other embodiments a single table approach could be used. In the present embodiment an Extension is associated with exactly one Item by ItemID and contains an ExtensionID that is unique in the context of the Item. As with Items a function might be provided to retrieve an Extension given its identity which consists of an ItemID and ExtensionID pair. A View is created for each Extension type similar to the Item type views.

Nested Elements are types that can be embedded in Items Extensions Relationships or other Nested Elements to form deeply nested structures. Like Items and Extensions Nested Elements are implemented as UDT s but they are stored within an Items and Extensions. Therefore Nested Elements have no storage mapping beyond that of their Item and Extension containers. In other words there are no tables in the system which directly store instances of NestedElement types and there are no views dedicated specifically to Nested Elements.

Each entity in the data model i.e. each Item Extension and Relationship has a unique key value. An Item is uniquely identified by its ItemId. An Extension is uniquely identified by a composite key of ItemId ExtensionId . A Relationship is identified by a composite key ItemId RelationshipId . ItemId ExtensionId and RelationshipId are GUID values.

All objects created in the data store can be stored in a SQL schema name derived from the storage platform schema name. For example the storage platform Base schema often called Base may produce types in the System.Storage SQL schema such as System.Storage .Item . Generated names are prefixed by a qualifier to eliminate naming conflicts. Where appropriate an exclamation character is used as a separator for each logical part of the name. The table below outlines the naming convention used for objects in the data store. Each schema element Item Extension Relationship and View is listed along with the decorated naming convention used to access instances in the data store.

When mapping any object model into a store the possibility of naming collisions occur due to additional information stored along with an application object. In order to avoid naming collisions all non type specific columns columns which do not map directly to a named Property in a type declaration is be prefixed with an underscore   character. In the present embodiment underscore   characters are disallowed as the beginning character of any identifier property. Further in order to unify naming between CLR and the data store all properties of a storage platform types or schema element relationship etc. should have a capitalized first character.

Views are provided by the storage platform for searching stored content. A SQL view is provided for each Item and Extension type. Further views are provided to support Relationships and Views as defined by the Data Model . All SQL views and underlying tables in the storage platform are read only. Data may be stored or changed using the Update method of the storage platform API as described more fully below.

Each view explicitly defined in a storage platform schema defined by the schema designer and not automatically generated by the storage platform is accessible by the named SQL view . View . For example a view named BookSales in the schema AcmePublisher.Books would be accessible using the name AcmePublisher.Books . View BookSales . Since the output format of a view is custom on a per view basis defined by an arbitrary query provided by the party defining the view the columns are directly mapped based on the schema view definition.

All SQL search views in the storage platform data store use the following ordering convention for columns 

Members of each type family are searchable using a series of Item views with there being one view per Item type in the data store. is a diagram illustrating the concept of an Item search view.

Each Item search view contains a row for each instance of an Item of the specific type or its subtypes. For example the view for Document could return instances of Document LegalDocument and ReviewDocument. Given this example the Item views can be conceptualized as shown in .

Each instance of a storage platform data store defines a special Item view called the Master Item View. This view provides summary information on each Item in the data store. The view provides one column per Item type property a column which described the type of the Item and several columns which are used to provide change tracking and synchronization information. The master item view is identified in a data store using the name System.Storage . Master Item .

Each Item type also has a search view. While similar to the root Item view this view also provides access to the Item object via the  Item column. Each typed item search view is identified in a data store using the name schemaName . itemTypeName . For example AcmeCorp.Doc . OfficeDoc .

Each instance of a data store defines a special Extension view called the Master Extension View. This view provides summary information on each Extension in the data store. The view has a column per Extension property a column which describes the type of the Extension and several columns which are used to provide change tracking and synchronization information. The master extension view is identified in a data store using the name System.Storage . Master Extension .

Each Extension type also has a search view. While similar to the master extension view this view also provides access to the Item object via the  Extension column. Each typed extension search view is identified in a data store using the name schemaName . Extension extensionTypeName . For example AcmeCorp.Doc . Extension OfficeDocExt .

All nested elements are stored within Items Extensions or Relationships instances. As such they are accessed by querying the appropriate Item Extension or Relationship search view.

As discussed above Relationships form the fundamental unit of linking between Items in a storage platform data store.

Each data store provides a Master Relationship View. This view provides information on all relationship instances in the data store. The master relationship view is identified in a data store using the name System.Storage . Master Relationship .

Each declared Relationship also has a search view which returns all instances of the particular relationship. While similar to the master relationship view this view also provides named columns for each property of the relationship data. Each relationship instance search view is identified in a data store using the name schemaName . Relationship relationshipName . For example AcmeCorp.Doc . Relationship DocumentAuthor .

All views in the storage platform data store are read only. In order to create a new instance of a data model element item extension or relationship or to update an existing instance the ProcessOperation or ProcessUpdategram methods of the storage platform API must be used. The ProcessOperation method is a single stored procedure defined by the data store which consumes an operation that details an action to be performed. The ProcessUpdategram method is a stored procedure which takes an ordered set of operations known as an updategram which collectively detail a set of actions to be performed.

The operation format is extensible and provides various operations over the schema elements. Some common operations include 

Change tracking and tombstone services are provided by the data store as discussed more fully below. This section provides an outline of the change tracking information exposed in a data store.

Each search view provided by the data store contains columns used to provide change tracking information the columns are common across all Item Extension and Relationship views. Storage platform Schema Views defined explicitly by schema designers do not automatically provide change tracking information such information is provided indirectly through the search views on which the view itself is built.

For each element in the data store change tracking information is available from two places the master element view and the typed element view. For example change tracking information on the AcmeCorp.Document.Document Item type is available from the Master Item View System.Storage . Master Item and typed Item search view AcmeCorp.Document . Document .

Change tracking information in the master search views provides information on the creation and update versions of an element information on which sync partner created the element which sync partner last updated the element and the version numbers from each partner for creation and update. Partners in sync relationships described below are identified by partner key. A single UDT object named  ChangeTrackingInfo of type System.Storage.Store .ChangeTrackingInfo contains all this information. The type is defined in the System.Storage schema.  ChangeTrackingInfo is available in all global search views for Item Extension and Relationship. The type definition of ChangeTrackingInfo is 

In addition to providing the same information as the global search view each typed search view provides additional information recording the sync state of each element in the sync topology.

The data store provides tombstone information for Items Extensions and Relationships. The tombstone views provide information about both live and tombstoned entities items extensions and relationships in one place. The item and extension tombstone views do not provide access to the corresponding object while the relationship tombstone view provides access to the relationship object the relationship object is NULL in the case of a tombstoned relationship .

Extension tombstones are retrieved from the system using the view System.Storage . Tombstone Extension . Extension change tracking information is similar to that provided for Items with the addition of the ExtensionId property.

Relationship tombstones are retrieved from the system via the view System.Storage . Tombstone Relationship . Relationships tombstone information is similar to that provided for Extensions. However additional information is provided on the target ItemRef of the relationship instance. In addition the relationship object is also selected.

In order to prevent unbounded growth of tombstone information the data store provides a tombstone cleanup task. This task determines when tombstone information may be discarded. The task computes a bound on the local create update version and then truncates the tombstone information by discarding all earlier tombstone versions.

The Base mapping also provides a number of helper functions. These functions are supplied to aid common operations over the data model.

There are two types of metadata represented in the Store instance metadata the type of an Item etc and type metadata.

Instance metadata is used by an application to query for the type of an Item and finds the extensions associated with an Item. Given the ItemId for an Item an application can query the global item view to return the type of the Item and use this value to query the Meta.Type view to return information on the declared type of the Item. For example 

In general all securable objects arrange their access rights using the access mask format shown in the . In this format the low order 16 bits are for object specific access rights the next 7 bits are for standard access rights which apply to most types of objects and the 4 high order bits are used to specify generic access rights that each object type can map to a set of standard and object specific rights. The ACCESS SYSTEM SECURITY bit corresponds to the right to access the object s SACL.

In the access mask structure of item specific rights are placed in the Object Specific Rights section low order 16 bits . Because in the present embodiment the storage platform exposes two sets of APIs to administer security Win32 and the storage platform API the file system object specific rights must be considered in order to motivate the design of the storage platform object specific rights.

The security model for the storage platform of the present invention is fully described in the related applications incorporated by reference earlier herein. In this regard FIG. parts a b and c depicts a new identically protected security region being carved out of an existing security region in accordance with one embodiment of a security model.

According to another aspect of the present invention the storage platform provides a notifications capability that allows applications to track data changes. This feature is primarily intended for applications which maintain volatile state or execute business logic on data change events. Applications register for notifications on items item extensions and item relationships. Notifications are delivered asynchronously after data changes have been committed. Applications may filter notifications by item extension and relationship type as well as type of operation.

According to one embodiment the storage platform API provides two kinds of interfaces for notifications. First applications register for simple data change events triggered by changes to items item extensions and item relationships. Second applications create watcher objects to monitor sets of items item extensions and relationships between items. The state of a watcher object can be saved and re created after a system failure or after a system has gone off line for an extended period of time. A single notification may reflect multiple updates.

Additional details regarding this functionality can be found in the related applications incorporated by reference earlier herein.

According to another aspect of the present invention the storage platform provides a synchronization service that i allows multiple instances of the storage platform each with its own data store to synchronize parts of their content according to a flexible set of rules and ii provides an infrastructure for third parties to synchronize the data store of the storage platform of the present invention with other data sources that implement proprietary protocols.

Storage platform to storage platform synchronization occurs among a group of participating replicas. For example with reference to it may be desirable to provide synchronization between the data store of the storage platform with another remote data store under the control of another instance of the storage platform perhaps running on a different computer system. The total membership of this group is not necessarily known to any given replica at any given time.

Different replicas can make the changes independently i.e. concurrently . The process of synchronization is defined as making every replica aware of the changes made by other replicas. This synchronization capability is inherently multi master.

The primary application of the synchronization service of the storage platform of the present invention is to synchronize multiple instances of the storage platform each with its own data store . The synchronization service operates at the level of the storage platform schemas rather than the underlying tables of the database engine . Thus for example Scopes are used to define synchronization sets as discussed below.

The synchronization service operates on the principle of net changes . Rather than recording and sending individual operations such as with transactional replication the synchronization service sends the end result of those operations thus often consolidating the results of multiple operations into a single resulting change.

The synchronization service does not in general respect transaction boundaries. In other words if two changes are made to a storage platform data store in a single transaction there is no guarantee that these changes are applied at all other replicas atomically one may show up without the other. The exception to this principle is that if two changes are made to the same Item in the same transaction then these changes are guaranteed to be sent and applied to other replicas atomically. Thus Items are the consistency units of the synchronization service.

Any application can connect to the synchronization service and initiate a sync operation. Such an application provides all of the parameters needed to perform synchronization see sync profile below . Such applications are referred to herein as Sync Controlling Applications SCAs .

When synchronizing two storage platform instances sync is initiated on one side by an SCA. That SCA informs the local synchronization service to synchronize with the remote partner. On the other side the synchronization service is awoken by the messages sent by the synchronization service from the originating machine. It responds based on the persistent configuration information see mappings below present on the destination machine. The synchronization service can be run on schedule or in response to events. In these cases the synchronization service implementing the schedule becomes the SCA.

To enable synchronization two steps need to be taken. First the schema designer must annotate the storage platform schema with appropriate sync semantics designating Change Units as described below . Second synchronization must be properly configured on all of the machines having an instance of the storage platform that is to participate in the synchronization as described below .

A fundamental concept of the synchronization service is that of a Change Unit. A Change Unit is a smallest piece of schema that is individually tracked by the storage platform. For every Change Unit the synchronization service may be able to determine whether it changed or did not change since the last sync.

Designating Change Units in the schema serves several purposes. First it determines how chatty the synchronization service is on the wire. When a change is made inside a Change Unit the entire Change Unit is sent to the other replicas since the synchronization service does not know which part of the Change Unit was changed. Second it determines the granularity of conflict detection. When two concurrent changes these terms are defined in detail in subsequent sections are made to the same change unit the synchronization service raises a conflict on the other hand if concurrent changes are made to different change units then no conflict is raised and the changes are automatically merged. Third it strongly affects the amount of meta data kept by the system. Much of the synchronization service meta data is kept per Change Unit thus making Change Units smaller increases the overhead of sync.

Defining Change Units requires finding the right trade offs. For that reason the synchronization service allows schema designers to participate in the process.

In one embodiment the synchronization service does not support Change Units that are larger than an element. However it does support the ability for schema designers to specify smaller change units than an element namely grouping multiple attributes of an element into a separate Change Unit. In that embodiment this is accomplished using the following syntax 

A group of storage platform partners that wish to keep certain parts of their data in sync are referred to as a sync community. While the members of the community want to stay in sync they do not necessarily represent the data in exactly the same way in other words sync partners may transform the data they are synchronizing.

In a peer to peer scenario it is impractical for peers to maintain transformation mappings for all of their partners. Instead the synchronization service takes the approach of defining Community Folders . A community folder is an abstraction that represents a hypothetical shared folder that all community members are synchronizing with.

This notion is best illustrated by an example. If Joe wants to keep My Documents folders of his several computers in sync Joe defines a community folder called say JoesDocuments. Then on every computer Joe configures a mapping between the hypothetical JoesDocuments folder and the local My Documents folder. From this point on when Joe s computers synchronize with each other they talk in terms of documents in JoesDocuments rather than their local items. This way all Joe s computers understand each other without having to know who the others are the Community Folder becomes the lingua franca of the sync community.

Configuring the synchronization service consists of three steps 1 defining mappings between local folders and community folders 2 defining sync profiles that determine what gets synchronized e.g. whom to sync with and which subsets should be sent and which received and 3 defining the schedules on which different sync profiles should run or running them manually.

Community Folder mappings are stored as XML configuration files on individual machines. Each mapping has the following schema 

The presence of this element indicates that the sender of messages to this mapping must be impersonated and requests processed under his credentials.

A Sync Profile is a total set of parameters needed to kick off synchronization. It is supplied by an SCA to the Sync Runtime to initiate sync. Sync profiles for storage platform to storage platform synchronization contain the following information 

The synchronization service provides a runtime CLR class that allows simple building of Sync Profiles. Profiles can also be serialized to and from XML files for easy storage often alongside schedules . However there is no standard place in the storage platform where all the profiles are stored SCAs are welcome to construct a profile on the spot without ever persisting it. Note that there is no need to have a local mapping to initiate sync. All sync information can be specified in the profile. The mapping is however required in order to respond to sync requests initiated by the remote side.

In one embodiment the synchronization service does not provide its own scheduling infrastructure. Instead it relies on another component to peform this task the Windows Scheduler available with the Microsoft Windows operating system. The synchronization service includes a command line utility that acts as an SCA and triggers synchronization based on a sync profile saved in an XML file. This utility makes it very easy to configure the Windows Scheduler to run synchronization either on schedule or in response to events such as user logon or logoff.

Conflict handling in the synchronization service is divided into three stages 1 conflict detection which occurs at change application time this step determines if a change can be safely applied 2 automatic conflict resolution and logging during this step that takes place immediately after the conflict is detected automatic conflict resolvers are consulted to see if the conflict can be resolved if not the conflict can be optionally logged and 3 conflict inspection and resolution this step takes place if some conflicts have been logged and occurs outside of the context of the sync session at this time logged conflicts can be resolved and removed from the log.

In the present embodiment the synchronization service detects two types of conflicts knowledge based and constraint based.

A knowledge based conflict occurs when two replicas make independent changes to the same Change Unit. Two changes are called independent if they are made without knowledge of each other in other words the version of the first is not covered by the knowledge of the second and vice versa. The synchronization service automatically detects all such conflicts based on the replicas knowledge as described above.

It is sometimes helpful to think of conflicts as forks in the version history of a change unit. If no conflicts occur in the life of a change unit its version history is a simple chain each change occurring after the previous one. In the case of a knowledge based conflict two changes occur in parallel causing the chain to split and become a version tree.

There are cases where independent changes violate an integrity constraint when applied together. For instance two replicas creating a file with the same name in the same directory could cause such a conflict to occur.

A constraint based conflict involves two independent changes just like a knowledge based one but they do not affect the same change unit. Rather they affect different change units but with a constraint existing between them.

The synchronization service detects constraint violations at change application time and raises constraint based conflicts automatically. Resolving constraint based conflicts usually requires custom code that modifies the changes in such as way as to not violate the constraint The synchronization service does not provide a general purpose mechanism for doing so.

When a conflict is detected the synchronization service can take one of three actions selected by the sync initiator in the Sync Profile 1 reject the change returning it back to sender 2 log a conflict into a conflict log or 3 resolve the conflict automatically.

If the change is rejected the synchronization service acts as if the change did not arrive at the replica. A negative acknowledgement is sent back to the originator. This resolution policy is primarily useful on head less replicas such as file servers where logging conflicts is not feasible. Instead such replicas force the others to deal with the conflicts by rejecting them.

Sync initiators configure conflict resolution in their Sync Profiles. The synchronization service supports combining multiple conflict resolvers in a single profile in the following ways first by specifying a list of conflict resolvers to be tried one after another until one of them succeeds and second by associating conflict resolvers with conflict types e.g. directing update update knowledge based conflicts to one resolver but all the other conflicts to the log.

In addition ISVs can implement and install their own conflict resolvers. Custom conflict resolvers may accept configuration parameters such parameters must be specified by the SCA in the Conflict Resolution section of the Sync Profile.

When a conflict resolver handles a conflict it returns the list of operations that need to be performed in lieu of the conflicting change back to the runtime. The synchronization service then applies these operations having properly adjusted remote knowledge to include what the conflict handler has considered.

It is possible that another conflict is detected while applying the resolution. In such a case the new conflict must be resolved before the original processing resumes.

When thinking of conflicts as branches in the version history of an item conflict resolutions can be viewed as joins combining two branches to form a single point. Thus conflict resolutions turn version histories into DAGs.

A very particular kind of a conflict resolver is the Conflict Logger. The synchronization service logs conflicts as Items of type ConflictRecord. These records are related back to the items that are in conflict unless the items themselves have been deleted . Each conflict record contains the incoming change that caused the conflict the type of the conflict update update update delete delete update insert insert or constraint and the version of the incoming change and the knowledge of the replica sending it. Logged conflicts are available for inspection and resolution as described below.

The synchronization service provides an API for applications to examine the conflict log and to suggest resolutions of the conflicts in it. The API allows application to enumerate all conflicts or conflicts related to a given Item. It also allows such applications to resolve logged conflicts in one of three ways 1 remote wins accepting the logged change and overwriting the conflicting local change 2 local wins ignoring conflicting parts of the logged change and 3 suggest new change where the application proposes a merge that in its opinion resolves the conflict. Once conflicts are resolved by an application the synchronization service removes them from the log.

In complex synchronization scenarios the same conflict can be detected at multiple replicas. If this occurs several things can happen 1 the conflict can be resolved on one replica and the resolution be sent to the other 2 the conflict is resolved on both replicas automatically or 3 the conflict is resolved on both replicas manually through the conflict inspection API .

To ensure convergence the synchronization service forwards conflict resolutions to other replicas. When a change that resolves a conflict arrives at a replica the synchronization service automatically finds any conflict records in the log that are resolved by this update and eliminates them. In this sense a conflict resolution at one replica is binding on all the other replicas.

If different winners are chosen by different replicas for the same conflict the synchronization service applies the principle of binding conflict resolution and picks one of the two resolutions to win over the other automatically. The winner is picked in a deterministic fashion that is guaranteed to produce the same results at all times one embodiment uses replica ID lexicographic comparisons .

If different new changes are suggested by different replicas for the same conflict the synchronization service treats this new conflict as a special conflict and uses the Conflict Logger to prevent it from propagating to other replicas. Such situation commonly arises with manual conflict resolution.

According to another aspect of the storage platform of the present invention the storage platform provides an architecture for ISVs to implement Sync Adapters that allow the storage platform to synchronize to legacy systems such as Microsoft Exchange AD Hotmail etc. Sync Adapters benefit from the many Sync Service provided by the synchronization service as described below.

Despite the name Sync Adapters do not need to be implemented as plug ins into some storage platform architecture. If desired a sync adapter can simply be any application that utilizes the synchronization service runtime interfaces to obtain services such as change enumeration and application.

In order to make it simpler for others to configure and run synchronization to a given backend Sync Adapter writers are encouraged to expose the standard Sync Adapter interface which runs sync given the Sync Profile as described above. The profile provides configuration information to the adapter some of which adapters pass to the Sync Runtime to control runtime services e.g. the Folder to synchronize .

The synchronization service provides a number of sync services to adapter writers. For the rest of this section it is convenient to refer to the machine on which the storage platform is doing synchronization as the client and the non storage platform backend that the adapter is talking to as the server .

Based on the change tracking data maintained by the synchronization service Change Enumeration allows sync adapters to easily enumerate the changes that have occurred to a data store Folder since the last time synchronization with this partner was attempted.

Changes are enumerated based on the concept of an anchor an opaque structure that represents information about the last synchronization. The anchor takes the form of the storage platform Knowledge as described in the proceeding sections. Sync adapters utilizing change enumeration services fall into two broad categories those using stored anchors vs. those using supplied anchors .

The distinction is based on where the information about the last sync is stored on the client or on the server. It is often easier for adapters to store this information on the client the backend is often not capable of conveniently storing this information. On the other hand if multiple clients synchronize to the same backend storing this information on the client is inefficient and in some cases incorrect it makes one client unaware of the changes that the other client has already pushed up to the server. If an adapter wants to use a server stored anchor the adapter needs to supply it back to the storage platform at the time of change enumeration.

In order for the storage platform to maintain the anchor either for local or remote storage the storage platform needs to be made aware of the changes that were successfully applied at the server. These and only these changes can be included in the anchor. During change enumeration Sync Adapters use an Acknowledgement interface to report which changes were successfully applied. At the end of synchronization adapters using supplied anchors must read the new anchor which incorporates all of the successfully applied changes and send it to their backend.

Often Adapters need to store adapter specific data along with the items they insert into the storage platform data store. Common examples of such data are remote IDs and remote versions timestamps . The synchronization service provides a mechanism for storing this data and Change Enumeration provides a mechanism to receive this extra data along with the changes being returned. This eliminates the need for adapters to re query the database in most cases.

Change Application allows Sync Adapters to apply changes received from their backend to the local storage platform. Adapters are expected to transform the changes to the storage platform schema. illustrates the process by which storage platform API classes are generated from the storage platform Schema.

The primary function of change application is to automatically detect conflicts. As in the case of Storage Platform to Storage Platform sync a conflict is defined as two overlapping changes being made without knowledge of each other. When adapters use Change Application they must specify the anchor with respect to which conflict detection is performed. Change Application raises a conflict if an overlapping local change that is not covered by the adapter s knowledge is detected. Similar to Change Enumeration adapters may use either stored or supplied anchors. Change Application supports efficient storage of adapter specific meta data. Such data may be attached by the adapter to the changes being applied and might be stored by the synchronization service. The data might be returned on next change enumeration.

The Conflict Resolution mechanisms described above logging and automatic resolution options are available to sync adapters as well. Sync adapters may specify the policy for conflict resolution when applying changes. If specified conflicts may be passed on to the specified conflict handler and resolved if possible . Conflicts can also be logged. It is possible that the adapter may detect a conflict when attempting to apply a local change to the backend. In such a case the adapter may still pass the conflict on to the Sync Runtime to be resolved according to policy. In addition Sync Adapters may request that any conflicts detected by the synchronization service be sent back to them for processing. This is particularly convenient in the case where the backend is capable of storing or resolving conflicts.

While some adapters are simply applications utilizing runtime interfaces adapters are encouraged to implement the standard adapter interfaces. These interfaces allow Sync Controlling Applications to request that the adapter perform synchronization according to a given Sync Profile cancel on going synchronization and receive progress reporting percentage complete on an ongoing sync.

The synchronization service strives to introduce as little as possible into the security model implemented by the storage platform. Rather than defining new rights for synchronization existing rights are used. Specifically 

The synchronization service does not maintain secure authorship information. When a change is made at replica A by user U and forwarded to replica B the fact that the change was originally made at A or by U is lost. If B forwards this change to replica C this is done under B s authority not that of A. This leads to the following limitation if a replica is not trusted to make its own changes to an item it cannot forward changes made by others.

When the synchronization service is initiated it is done by a Sync Controlling Application. The synchronization service impersonates the identity of the SCA and performs all operations both locally and remotely under that identity. To illustrate observe that user U cannot cause the local synchronization service to retrieve changes from a remote storage platform for items that user U does not have read access.

Monitoring a distributed community of replicas is a complex problem. The synchronization service may use a sweep algorithm to collect and distribute information about the status of the replicas. The properties of the sweep algorithm ensure that information about all configured replicas is eventually collected and that failing non responsive replicas are detected.

This community wide monitoring information is made available at every replica. Monitoring tools can be run at an arbitrarily chosen replica to examine this monitoring information and make administrative decisions. Any configuration changes must be made directly at the affected replicas.

As mentioned above the storage platform of the present invention is in at least some embodiments intended to be embodied as an integral part of the hardware software interface system of a computer system. For example the storage platform of the present invention may be embodied as an integral part of an operating system such as the Microsoft Windows family of operating systems. In that capacity the storage platform API becomes a part of the operating system APIs through which application programs interact with the operating system. Thus the storage platform becomes the means through which application programs store information on the operating system and the Item based data model of the storage platform therefore replaces the traditional files system of such an operating system. For example as embodied in the Microsoft Windows family of operating systems the storage platform might replace the NTFS file system implemented in that operating system. Presently application programs access the services of the NTFS file system through the Win32 APIs exposed by the Windows family of operating systems.

Recognizing however that completely replacing the NTFS file system with the storage platform of the present invention would require recoding of existing Win32 based application programs and that such recoding may be undesirable it would be beneficial for the storage platform of the present invention to provide some interoperability with existing file systems such as NTFS. In one embodiment of the present invention therefore the storage platform enables application programs which rely on the Win32 programming model to access the contents of both the data store of the storage platform as well as the traditional NTFS file system. To this end the storage platform uses a naming convention that is a superset of the Win32 naming conventions to facilitate easy interoperability. Further the storage platform supports accessing files and directories stored in a storage platform volume through the Win32 API.

Additional details regarding this functionality can be found in the related applications incorporated by reference earlier herein.

The storage platform comprises an API that enables application programs to access the features and capabilities of the storage platform discussed above and to access items stored in the data store. This section describes one embodiment of a storage platform API of the storage platform of the present invention. Details regarding this functionality can be found in the related applications incorporated by reference earlier herein with some of this information summarized below for convenience.

Referring to a Containment Folder is an item which contains holding Relationships to other Items and is the equivalent of the common concept of a file system folder. Each Item is contained within at least one containment folder.

The hierarchy of classes resulting from a given schema directly reflects the hierarchy of types in that schema. As an example consider the Item types defined in the Contacts schema as shown in and .

In regard to APIs a programming interface or more simply interface may be viewed as any mechanism process protocol for enabling one or more segment s of code to communicate with or access the functionality provided by one or more other segment s of code. Alternatively a programming interface may be viewed as one or more mechanism s method s function call s module s object s etc. of a component of a system capable of communicative coupling to one or more mechanism s method s function call s module s etc. of other component s . The term segment of code in the preceding sentence is intended to include one or more instructions or lines of code and includes e.g. code modules objects subroutines functions and so on regardless of the terminology applied or whether the code segments are separately compiled or whether the code segments are provided as source intermediate or object code whether the code segments are utilized in a runtime system or process or whether they are located on the same or different machines or distributed across multiple machines or whether the functionality represented by the segments of code are implemented wholly in software wholly in hardware or a combination of hardware and software.

Notionally a programming interface may be viewed generically as shown in or . illustrates an interface Interface as a conduit through which first and second code segments communicate. illustrates an interface as comprising interface objects I and I which may or may not be part of the first and second code segments which enable first and second code segments of a system to communicate via medium M. In the view of one may consider interface objects I and I as separate interfaces of the same system and one may also consider that objects I and I plus medium M comprise the interface. Although show bi directional flow and interfaces on each side of the flow certain implementations may only have information flow in one direction or no information flow as described below or may only have an interface object on one side. By way of example and not limitation terms such as application programming interface API entry point method function subroutine remote procedure call and component object model COM interface are encompassed within the definition of programming interface.

Aspects of such a programming interface may include the method whereby the first code segment transmits information where information is used in its broadest sense and includes data commands requests etc. to the second code segment the method whereby the second code segment receives the information and the structure sequence syntax organization schema timing and content of the information. In this regard the underlying transport medium itself may be unimportant to the operation of the interface whether the medium be wired or wireless or a combination of both as long as the information is transported in the manner defined by the interface. In certain situations information may not be passed in one or both directions in the conventional sense as the information transfer may be either via another mechanism e.g. information placed in a buffer file etc. separate from information flow between the code segments or non existent as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation e.g. depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration and so this list should be considered illustrative and non limiting.

This notion of a programming interface is known to those skilled in the art and is clear from the foregoing detailed description of the invention. There are however other ways to implement a programming interface and unless expressly excluded these too are intended to be encompassed by the claims set forth at the end of this specification. Such other ways may appear to be more sophisticated or complex than the simplistic view of but they nonetheless perform a similar function to accomplish the same overall result. We will now briefly describe some illustrative alternative implementations of a programming interface.

Factoring A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown some interfaces can be described in terms of divisible sets of functionality. Thus the interface functionality of may be factored to achieve the same result just as one may mathematically provide 24 or 2 times 2 times 3 times 2. Accordingly as illustrated in the function provided by interface Interface may be subdivided to convert the communications of the interface into multiple interfaces InterfaceA Interface B Interface C etc. while achieving the same result. As illustrated in the function provided by interface I may be subdivided into multiple interfaces I I I etc. while achieving the same result. Similarly interface I of the second code segment which receives information from the first code segment may be factored into multiple interfaces I I I etc. When factoring the number of interfaces included with the 1st code segment need not match the number of interfaces included with the 2nd code segment. In either of the cases of the functional spirit of interfaces Interface and I remain the same as with respectively. The factoring of interfaces may also follow associative commutative and other mathematical properties such that the factoring may be difficult to recognize. For instance ordering of operations may be unimportant and consequently a function carried out by an interface may be carried out well in advance of reaching the interface by another piece of code or interface or performed by a separate component of the system. Moreover one of ordinary skill in the programming arts can appreciate that there are a variety of ways of making different function calls that achieve the same result.

Redefinition In some cases it may be possible to ignore add or redefine certain aspects e.g. parameters of a programming interface while still accomplishing the intended result. This is illustrated in . For example assume interface Interface of includes a function call Square input precision output a call that includes three parameters input precision and output and which is issued from the 1st Code Segment to the 2nd Code Segment. If the middle parameter precision is of no concern in a given scenario as shown in it could just as well be ignored or even replaced with a meaningless in this situation parameter. One may also add an additional parameter of no concern. In either event the functionality of square can be achieved so long as output is returned after input is squared by the second code segment. Precision may very well be a meaningful parameter to some downstream or other portion of the computing system however once it is recognized that precision is not necessary for the narrow purpose of calculating the square it may be replaced or ignored. For example instead of passing a valid precision value a meaningless value such as a birth date could be passed without adversely affecting the result. Similarly as shown in interface I is replaced by interface I redefined to ignore or add parameters to the interface. Interface I may similarly be redefined as interface I redefined to ignore unnecessary parameters or parameters that may be processed elsewhere. The point here is that in some cases a programming interface may include aspects such as parameters that are not needed for some purpose and so they may be ignored or redefined or processed elsewhere for other purposes.

Inline Coding It may also be feasible to merge some or all of the functionality of two separate code modules such that the interface between them changes form. For example the functionality of may be converted to the functionality of respectively. In the previous 1st and 2nd Code Segments of are merged into a module containing both of them. In this case the code segments may still be communicating with each other but the interface may be adapted to a form which is more suitable to the single module. Thus for example formal Call and Return statements may no longer be necessary but similar processing or response s pursuant to interface Interface may still be in effect. Similarly shown in part or all of interface I from may be written inline into interface I to form interface I . As illustrated interface I is divided into Iand I and interface portion Ihas been coded in line with interface I to form interface I . For a concrete example consider that the interface I from performs a function call square input output which is received by interface I which after processing the value passed with input to square it by the second code segment passes back the squared result with output. In such a case the processing performed by the second code segment squaring input can be performed by the first code segment without a call to the interface.

Divorce A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown in one or more piece s of middleware Divorce Interface s since they divorce functionality and or interface functions from the original interface are provided to convert the communications on the first interface Interface to conform them to a different interface in this case interfaces InterfaceA InterfaceB and InterfaceC. This might be done e.g. where there is an installed base of applications designed to communicate with say an operating system in accordance with an Interface protocol but then the operating system is changed to use a different interface in this case interfaces InterfaceA InterfaceB and InterfaceC. The point is that the original interface used by the 2nd Code Segment is changed such that it is no longer compatible with the interface used by the 1st Code Segment and so an intermediary is used to make the old and new interfaces compatible. Similarly as shown in a third code segment can be introduced with divorce interface DI to receive the communications from interface I and with divorce interface DI to transmit the interface functionality to for example interfaces Iand I redesigned to work with DI but to provide the same functional result. Similarly DI and DI may work together to translate the functionality of interfaces I and I of to a new operating system while providing the same or similar functional result.

Rewriting Yet another possible variant is to dynamically rewrite the code to replace the interface functionality with something else but which achieves the same overall result. For example there may be a system in which a code segment presented in an intermediate language e.g. Microsoft IL Java ByteCode etc. is provided to a Just in Time JIT compiler or interpreter in an execution environment such as that provided by the .Net framework the Java runtime environment or other similar runtime type environments . The JIT compiler may be written so as to dynamically convert the communications from the 1st Code Segment to the 2nd Code Segment i.e. to conform them to a different interface as may be required by the 2nd Code Segment either the original or a different 2nd Code Segment . This is depicted in . As can be seen in this approach is similar to the Divorce scenario described above. It might be done e.g. where an installed base of applications are designed to communicate with an operating system in accordance with an Interface protocol but then the operating system is changed to use a different interface. The JIT Compiler could be used to conform the communications on the fly from the installed base applications to the new interface of the operating system. As depicted in this approach of dynamically rewriting the interface s may be applied to dynamically factor or otherwise alter the interface s as well.

It should also be noted that the above described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways serially and or in parallel or with other intervening code. Thus the alternative embodiments presented above are not mutually exclusive and may be mixed matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in . It is also noted that as with most programming constructs there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein but nonetheless are represented by the spirit and scope of the invention i.e. it is noted that it is at least partly the functionality represented by and the advantageous results enabled by an interface that underlie the value of an interface.

A foundational concept of the present invention is the utilization of Items that to a certain extent model real world application objects with complex structures behaviors and operations described by a schema and enforced by the hardware software interface system. To provide rich sub typing functionality and in various embodiments of the present invention a hardware software interface system which for convenience we shall simply refer to as WinFS hereafter may provides a mechanism by which Items and Item types can be extended using Extensions. Extensions provide additional data structures Properties Relationships etc. to already existing Items type structures.

As previously discussed herein and particularly discussed in Sections II.E.6. a and II.F.3 while the storage platform is intended to be provided with an initial set of schemas in at least some embodiments the storage platform allows customers including independent software vendor ISVs to create new schemas i.e. new Item and Nested Element types . Since an Item type or Nested Element type defined by the initial set of storage platform schemas may not exactly match an ISV application s need it is necessary to allow ISVs to customize the type. This is allowed with the notion of Extensions. Extensions are strongly typed instances but a they cannot exist independently and b they must be attached to an Item or Nested Element. Also in addition to addressing the need for schema extensibility Extensions are also intended to address multi typing issues. Since in some embodiments the storage platform may not support multiple inheritance or overlapping subtypes applications can use Extensions as a way to model overlapping type instances e.g. a Document may be a legal document as well a secure document .

In various embodiments of the present invention the WinFS type system provides a mechanism for defining structures of data. The type system is used to represent data stored in WinFS. A WinFS type is declared in a WinFS schema. A WinFS schema defines a namespace which serves as a logical grouping for a set of types and other WinFS schema elements. WinFS Schemas may be declared using a WinFS Schema Definition Language SDL that might use an XML format. The following is an example of a possible schema declaration 

WinFS Schemas also serve as a unit for type versioning. WinFS defines several system schemas that bootstrap the system. These are the System.Storage schema namespace that contains the type declarations of the root types in the system and the System.Storage.WinFS schema namespace that declares all the primitive scalar types in the system.

The WinFS type system declares a set of simple scalar types. These types are used as the most primitive building block for all other types in the WinFS type system. These types are declared in the schema namespace System.Storage.WinFS. The following table defines the set of primitive types.

A WinFS enumeration is a scalar type that declares a set of named constants called a value list. An enumeration type can be used in any place where a scalar type can be used. Here is an example for an enumeration declaration 

A complex type is defined by a name and a set of properties. A Property is a member field of the type and is defined by a name and a type. The type of a Property can be either scalar including enumeration type or other complex type. A WinFS type that can be used as type of a Property is called a nested type. An instance of a nested type can only exist as a value of a Property of a complex WinFS type the instance is nested within an instance of a complex type. A nested type is declared using the NestedType schema element. Here are some examples of valid type declarations 

For properties of type String and Binary a Size attribute must be specified. This attribute specifies the maximum size of the values contained in the Property. A Property can optionally declare a nullability constraint using the Nullable attribute. A value false for this attribute indicates that the application must provide a value when creating an instance of the type. Another optional Property attribute is the Default attribute that specifies the default value for the Property. This value will be assigned to the Property at instance creation time if the application did not provide it.

The Addresses Property in the example above is of type MultiSet. A Property of type MultiSet is also referred to as a multi valued Property. In the example the MultiSet contains a set of instance of type Address. A MultiSet is similar to a collection. It can contain zero or more instances of a complex type. The type of the instance in the MultiSet must be a complex nested type. MultiSet type does not support instances of WinFS scalar types including enumeration types . A Property of type MultiSet can not be nullable and can not have a default value.

WinFS supports single inheritance of types. All types in WinFS must inherit from one and only on WinFS type. The inheriting type is referred to as the derived type and the type from which this type was derived is referred to as the base type. The base type in the BaseType attribute of the WinFS type declaration elements. Suppose that type A derives from base type B which in turn derives from type C. The type C is an ancestor type of the types A and B. The type A is a descendant type of the types B and C. A data instance stored in WinFS is always an instance of a single type. We can however treat that data instance as an instance of a set of types containing the type and all its ancestor types. For a data instance which is an instance of such a set of types we call the type which is not the ancestor of any other type in the set the most derived type. A singly typed data instance is an instance of exactly one most derived type. In general we will refer to the most derived type of a singly typed element as its type. The derived type inherits all the properties declared in its base type. The derived type can declare new properties but can not override the properties defined in the base type. A Property declared in the derived type must not use the same name as a Property of the base type.

The main advantage of inheritance in the data model comes from substitutability of inherited types. Consider the following example 

The same rule is extended to set properties. The Property OtherNames contains a set of elements. For each singly typed instance which is a member of that set the most derived type of that instance must have Name as one of its ancestors. So some of the instances in the set OtherNames may be instances of type Name while others maybe instances of type NameWithMiddleInitial.

Inheritance also enables convenient querying in that it is possible in the WinFS system to find all instances of a certain type. When looking for all instances of a type the query engine will also return all instances whose most derived types are descendents of this type. However these operations are only supported for Item Extension and Relationship types not Property types . For nested types a.k.a. Nested Elements Property or complex property types the operation is only supported for instances contained within a single multiset Property.

Unlike the other WinFS Type families nested types can be used as types of properties of complex WinFS types. Instances of a nested type can only be nested inside an instance of another complex type. However Instances of nested types cannot be queried globally that is applications cannot compose a simple query that returns all instances of a given nested type in the WinFS store.

A WinFS Item is an instance of a type whose ancestor is the type System.Storage.Item. This type is a complex type that is the root of the Item type family. System.Storage.Item declares a Property of name ItemId of type Guid. This is a special Property of an Item that serves as a primary key of the Item. The value of this Property is guaranteed to be unique for Items in a given WinFS store. This Property is non nullable and must be assigned by the application when creating an instance of an Item type. The ItemId Property is also immutable it can never change and must not be reused.

The query engine can return instances of a given Item type in a WinFS store. This query may returns all instances of the type and all its type descendent types. Later herein is described the central role that Items have in the WinFS system operational semantics.

Relationship types enable Relationships to exist between Items. WinFS Relationship types describe binary Relationships where one Item is designated as the source and the other Item is designated as the target. A Relationship is an instance of a type whose ancestor is the type System.Storage.Relationship. This type is a root of the Relationship type hierarchy. System.Storage.Relationship type declares the following properties 

The Relationship declares a source endpoint named Document of Item type Core.Document and a target endpoint of type Core.Contact . The Relationship also declares two additional properties. The Relationship instances are stored and accessed separately from the Item. All Relationship type instances are accessible from a global Extension view. A query can be composed that will return all the instances of a given type of Relationship.

Given an Item all the Relationships for which the Item is a source can be enumerated based on the SourceItemId Property of the Relationship. Similarly for a given Item all the Relationship in the same store for which the Item is a target can be enumerated using the TargetItemId Property of the Relationship.

Holding Relationships Holding Relationships are used to model reference count based life time management of the target Items. An Item can be a source endpoint for zero or more Relationships to Items. An Item that is not an embedded Item can be a target of one or more holding Relationships. The target Item must be in the same store as the Relationship instance.

Holding Relationships enforce lifetime management of the target endpoint. The creation of a holding Relationship instance and the Item that it is targeting is an atomic operation. Additional holding Relationship instances can be created that are targeting the same Item. When the last holding Relationship instance with a given Item as target endpoint is deleted the target Item is also be deleted.

The types of the endpoint Items specified in the Relationship declaration will be enforced when an instance of the Relationship is created. The types of the endpoint Items can not be changed after the Relationship is established.

Holding Relationships play a key role in forming the WinFS Item namespace. All holding Relationships participate in the namespace declaration. The Name Property in the Relationship declaration defines the name of the target Item relative to the source Item. This relative name is unique for all the holding Relationships sourced from a given Item and cannot be null. The ordered list of this relative names starting from the root Item to a given Item forms the full name to the Item.

The holding Relationships form a directed acyclic graph DAG . When a holding Relationship is created the system ensures that a cycle is not created and thus ensuring that the WinFS Item namespace forms a DAG. For more information of the WinFS namespace and Item paths refer to the WinFS Namespace specification.

Embedding Relationships Embedding Relationships are modeling the concept of exclusive control of the lifetime of the target Item. They enable the concept of compound Items. The creation of an embedding Relationship instance and the Item that it is targeting is an atomic operation. An Item can be a source of zero or more embedding Relationship. However an Item can be a target of a one and only one embedding Relationship. An Item that is a target of embedding Relationship can not be a target of a holding Relationship. The target Item must be in the same store as the Relationship instance.

The types of the endpoint Items specified in the Relationship declaration will be enforced when an instance of the Relationship is created. The types of the endpoint Items can not be changed after the Relationship is established. The embedding Relationships do not participate in the WinFS namespace. The value of the Name Property of an embedding Relationship must be null.

Reference Relationships Reference Relationships do not control life time of the Item it references. Reference Relationships do not guarantee the existence of the target nor do they guarantee the type of the target as specified in the Relationship declaration. This means that the reference Relationships can be dangling. Also the reference Relationship can reference Items in other WinFS stores.

In WInFS reference Relationships will be used to model most non lifetime management Relationships between Items. Since the existence of the target is not enforced the reference Relationship is convenient to model loosely coupled Relationships. The reference Relationship can be used to target Items in other WinFS stores including stores on other machines. The embedding Relationships do not participate in the WinFS namespace. The value of the Name Property of an embedding Relationship must be null.

A WinFS Extension is an instance of a type whose ancestor is the type System.Storage.Extension. This type is a complex type that is the root of the Extension type family.

There are no constraints on the types of Extensions that can be associated with a given Item type. Any Extension type is allowed to extend any Item type. When multiple instances of different Extension types are attached to an Item they are independent from each other in both structure and behavior. The Extension instances are stored and accessed separately from the Item. All Extension type instances are accessible from a global Extension view. A query can be composed that will return all the instances of a given type of Extension regardless of what type of Item they are associated with. The ItemId of the Extension indicates which Item they belong to and can be used to retrieve the corresponding Item object from the global Item view. Also given an Item all Extension instances associated with the Item can be enumerated using the ItemId Property of the Extension.

In several embodiments of the present invention a hardware software interface system utilizes Extensions and Inheritance in order to formalize relationships between various Items and thereby enhance the ability to query a plurality of Items.

However it is important to note that relationship inheritance is not automatic and does not occur in every context. For example attributes that describe when a type can be inherited i.e. inheritance controls are not themselves inheritable. Inheritance parameters are maintained and regulated by the hardware software interface system.

A partial solution to this problem illustrated in is to extend the properties of Contact to include the fields necessary for an application that requires such. In this case Contact is extended to include the Additional Fields required by APPX. However directly extending the fields of an Item such as Contact can only be done once and thus APPY cannot employ this method.

In one embodiment of the present invention a more comprehensive solution is to extend the Contact with an Extension that is distinct and separate from Contact itself as illustrated in . In this way APPX can extend Contact to include its APPX Additional Fields while APPY can also separately extend Contact to include its APPY Additional Fields. These Extensions are then themselves searchable and queryable and thus these Extensions enable a form of multi typing for the hardware software interface system.

As the foregoing illustrates the present invention is directed to a storage platform for organizing searching and sharing data. The storage platform of the present invention extends and broadens the concept of data storage beyond existing file systems and database systems and is designed to be the store for all types of data including structured non structured or semi structured data such as relational tabular data XML and a new form of data called Items. Through its common storage foundation and schematized data the storage platform of the present invention enables more efficient application development for consumers knowledge workers and enterprises. It offers a rich and extensible application programming interface that not only makes available the capabilities inherent in its data model but also embraces and extends existing file system and database access methods. It is understood that changes may be made to the embodiments described above without departing from the broad inventive concepts thereof. Accordingly the present invention is not limited to the particular embodiments disclosed but is intended to cover all modifications that are within the spirit and scope of the invention as defined by the appended claims.

As is apparent from the above all or portions of the various systems methods and aspects of the present invention may be embodied in the form of program code i.e. instructions . This program code may be stored on a computer readable medium such as a magnetic electrical or optical storage medium including without limitation a floppy diskette CD ROM CD RW DVD ROM DVD RAM magnetic tape flash memory hard disk drive or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer or server the machine becomes an apparatus for practicing the invention. The present invention may also be embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics over a network including the Internet or an intranet or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates analogously to specific logic circuits.

