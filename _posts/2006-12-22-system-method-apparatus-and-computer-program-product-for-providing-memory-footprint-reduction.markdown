---

title: System, method, apparatus and computer program product for providing memory footprint reduction
abstract: An apparatus for providing memory footprint reduction for classes of an application programming interface includes a comparing element and a set selection element. The comparing element may be configured to receive a reference class file and one or more modified class files for each of a plurality of classes and to compare a size of each of the one or more modified class files and the reference class file. The set selection element may be in communication with the comparing element. The set selection element may be configured to select one of the one or more modified class files or the reference class file based at least in part on the size of each of the one or more modified class files and the reference class file as a selected file for each corresponding one of the classes and to form a class set comprising the selected file for each corresponding one of the classes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09378002&OS=09378002&RS=09378002
owner: Core Wireless Licensing S.a.r.l.
number: 09378002
owner_city: Luxembourg
owner_country: LU
publication_date: 20061222
---
Embodiments of the present invention relate generally to resource management and more particularly relate to method apparatus and computer program product for providing memory footprint reduction for classes of an application programming interface or application code.

The modern communications era has brought about a tremendous expansion of wireline and wireless networks. Computer networks television networks and telephony networks are experiencing an unprecedented technological expansion fueled by consumer demand. Wireless and mobile networking technologies have addressed related consumer demands while providing more flexibility and immediacy of information transfer.

Current and future networking technologies continue to facilitate ease of information transfer and convenience to users. One area in which there is a demand to increase ease of information transfer and convenience to users relates to provision of various applications or software to users of electronic devices such as a mobile terminal. The applications or software may be executed from a local computer a network server or other network device or from the mobile terminal such as for example a mobile telephone a mobile television a mobile gaming system etc or even from a combination of the mobile terminal and the network device. In this regard various applications and software have been developed and continue to be developed in order to give the users robust capabilities to perform tasks communicate entertain themselves etc. in either fixed or mobile environments. However many electronic devices which have different operating systems may require different versions of a particular application to be developed in order to permit operation of the particular application at each different type of electronic device. If such different versions were developed to correspond to each different operating system the cost of developing software and applications would be increased.

Accordingly virtual machines VMs have been developed. A VM is a self contained operating environment that behaves as if it is a separate computer. The VM may itself be a piece of computer software that isolates the application being used by the user from the host computer or operating system. Typically the VM consists of the execution engine and implementations of the standardized APIs. For example Java applets run in a Java VM while having no access to the host operating system. Because versions of the VM are written for various computer platforms any application written for the VM can be operated on any of the platforms instead of having to produce separate versions of the application for each computer and operating system. One of the most popular languages based on a VM is Java. Java which is well known in the industry is extremely portable flexible and powerful with respect to allowing applications to for example access mobile phone features through well known standard APIs. Thus Java has been widely used by developers to develop portable applications that can be run on a wide variety of electronic devices or computers without modification.

Particularly in mobile environments where resources are scarce due to consumer demand to reduce the cost and size of mobile terminals it is important to conserve or reuse resources whenever possible. In this regard efforts have been exerted to try to conserve or reclaim resources of mobile terminals when the resources are no longer needed by a particular application. Memory is one such resource for which it may be desirable to reduce consumption. In this regard since more and more Java applications and application programming interfaces APIs are being supported by mobile terminals a memory footprint of Java class libraries has been increasing.

In an effort to reduce the memory footprint of a Java class library or application a technique known as romizing has been developed. During romizing Java class files are typically transformed to Java VM specific format during the build phase. Some optimizations may be applied to class files during romizing since certain dynamic features of Java language may not be required for the class library. Examples of such optimizations may include combining constant pools of all classes and replacing duplicate strings with references pointing to an original string. All class files may be combined into a single large image. As a result of romizing a size of the class library may be decreased and class loading performance of the Java VM may be improved.

However romizing only decreases the size of some parts of the class file which may include many separate parts that can be handled separately. For example Java bytecode which is an abstract or intermediate language is one part of a Java class file. is a graph illustrating an example of a static memory footprint of a typical class library in romized form. In this regard although Java bytecode may represent about 27 of the Java class library memory footprint Java bytecode size is not affected by romizing and is therefore not optimized in terms of size.

Given the above described problems it may be advantageous to provide an improved mechanism for providing memory footprint reduction for languages such as Java that are based on using bytecode and need to store or transfer bytecode. Both applications and class libraries implementing APIs include bytecode so both can benefit from improved memory footprint reduction mechanism.

A method apparatus and computer program product are therefore provided for providing memory footprint reduction for classes of an application programming interface or application code. As such for example a reduced amount of memory may be consumed for storage of Java classes. According to exemplary embodiments of the present invention bytecode optimizers and or compilers may be applied to each class file to produce a modified version of the class file. A size of the modified version may be compared to the reference class file and the smaller of the reference class file and the modified version may be selected for loading. In some cases there may be a plurality of modified versions from which to select. The above procedure may be performed for each class file and an optimized class set may be determined from among the selected class files for each class.

In another embodiment each reference class file may include profile data indicative of performance criticality of the associated reference class file. Accordingly optimization in terms of file size reduction may be performed in a discriminative manner based on whether a particular file is performance critical e.g. therefore favoring performance factors over file size reduction or whether the particular file is not performance critical e.g. therefore favoring file size reduction .

In one exemplary embodiment a method of providing memory footprint reduction is provided. The method includes receiving a reference class file and one or more modified class files for each of a plurality of classes selecting one of the one or more modified class files or the reference class file based at least in part on a size of each of the one or more modified class files and the reference class file as a selected file for each corresponding one of the classes and forming a class set comprising the selected file for each corresponding one of the classes.

In another exemplary embodiment a computer program product for providing memory footprint reduction is provided. The computer program product includes at least one computer readable storage medium having computer readable program code portions stored therein. The computer readable program code portions include first second and third executable portions. The first executable portion is for receiving a reference class file and one or more modified class files for each of a plurality of classes. The second executable portion is for selecting one of the one or more modified class files or the reference class file based at least in part on a size of each of the one or more modified class files and the reference class file as a selected file for each corresponding one of the classes. The third executable portion is for forming a class set comprising the selected file for each corresponding one of the classes.

In another exemplary embodiment an apparatus for providing memory footprint reduction is provided. The apparatus includes a comparing element and a set selection element. The comparing element may be configured to receive a reference class file and one or more modified class files for each of a plurality of classes and to compare a size of each of the one or more modified class files and the reference class file. The set selection element may be in communication with the comparing element. The set selection element may be configured to select one of the one or more modified class files or the reference class file based at least in part on the size of each of the one or more modified class files and the reference class file as a selected file for each corresponding one of the classes and to form a class set comprising the selected file for each corresponding one of the classes.

In another exemplary embodiment an apparatus for providing memory footprint reduction is provided. The apparatus includes means for receiving a reference class file and one or more modified class files for each of a plurality of classes means for selecting one of the one or more modified class files or the reference class file based at least in part on a size of each of the one or more modified class files and the reference class file as a selected file for each corresponding one of the classes and means for forming a class set comprising the selected file for each corresponding one of the classes.

In another exemplary embodiment a system for providing memory footprint reduction is provided. The system includes one or more class file output tools and a class selection element. Each of the class file output tools may be capable of generating a reference class file or corresponding one or more modified class files for each of a plurality of classes. The class selection element may be in communication with the one or more class file output tools. The class selection element may include a comparing element and a set selection element. The comparing element may be configured to receive the reference class file and the one or more modified class files corresponding to the reference class file for each of the classes. The comparing element may also be configured to compare a size of each of the one or more modified class files and the reference class file. The set selection element may be in communication with the comparing element. The set selection element may be configured to select one of the one or more modified class files or the reference class file based at least in part on the size of each of the one or more modified class files and the reference class file as a selected file for each corresponding one of the classes. The set selection element may also be configured to form a class set comprising the selected file for each corresponding one of the classes.

Embodiments of the invention may provide a system method apparatus and computer program product for employment during or prior to loading of a Java VM or other APIs. As a result for example mobile terminals and other electronic devices may benefit from an ability to utilize corresponding applications or APIs with a reduced memory footprint. Accordingly a robust capability for executing various applications associated with Java or other APIs may be provided while consuming relatively smaller amounts of memory resources.

Embodiments of the present invention will now be described more fully hereinafter with reference to the accompanying drawings in which some but not all embodiments of the invention are shown. Indeed the invention may be embodied in many different forms and should not be construed as limited to the embodiments set forth herein rather these embodiments are provided so that this disclosure will satisfy applicable legal requirements. Like reference numerals refer to like elements throughout.

The system and method of embodiments of the present invention will be primarily described below in conjunction with mobile communications applications. However it should be understood that the system and method of embodiments of the present invention can be utilized in conjunction with a variety of other applications both in the mobile communications industries and outside of the mobile communications industries.

The mobile terminal includes an antenna or multiple antennae in operable communication with a transmitter and a receiver . The mobile terminal further includes a controller or other processing element that provides signals to and receives signals from the transmitter and receiver respectively. The signals include signaling information in accordance with the air interface standard of the applicable cellular system and also user speech received data and or user generated data. In this regard the mobile terminal is capable of operating with one or more air interface standards communication protocols modulation types and access types. By way of illustration the mobile terminal is capable of operating in accordance with any of a number of first second third and or fourth generation communication protocols or the like. For example the mobile terminal may be capable of operating in accordance with second generation 2G wireless communication protocols IS 136 TDMA GSM and IS 95 CDMA or with third generation 3G wireless communication protocols such as UMTS CDMA2000 WCDMA and TD SCDMA with fourth generation 4G wireless communication protocols or the like.

It is understood that the controller includes circuitry desirable for implementing audio and logic functions of the mobile terminal . For example the controller may be comprised of a digital signal processor device a microprocessor device and various analog to digital converters digital to analog converters and other support circuits. Control and signal processing functions of the mobile terminal are allocated between these devices according to their respective capabilities. The controller thus may also include the functionality to convolutionally encode and interleave message and data prior to modulation and transmission. The controller can additionally include an internal voice coder and may include an internal data modem. Further the controller may include functionality to operate one or more software programs which may be stored in memory. For example the controller may be capable of operating a connectivity program such as a conventional Web browser. The connectivity program may then allow the mobile terminal to transmit and receive Web content such as location based content and or other web page content according to a Wireless Application Protocol WAP Hypertext Transfer Protocol HTTP and or the like for example.

The mobile terminal may also comprise a user interface including an output device such as a conventional earphone or speaker a microphone a display and a user input interface all of which are coupled to the controller . The user input interface which allows the mobile terminal to receive data may include any of a number of devices allowing the mobile terminal to receive data such as a keypad a touch display not shown or other input device. In embodiments including the keypad the keypad may include the conventional numeric 0 9 and related keys and other keys used for operating the mobile terminal . Alternatively the keypad may include a conventional QWERTY keypad arrangement. The keypad may also include various soft keys with associated functions. In addition or alternatively the mobile terminal may include an interface device such as a joystick or other user input interface. The mobile terminal further includes a battery such as a vibrating battery pack for powering various circuits that are required to operate the mobile terminal as well as optionally providing mechanical vibration as a detectable output.

The mobile terminal may further include a user identity module UIM . The UIM is typically a memory device having a processor built in. The UIM may include for example a subscriber identity module SIM a universal integrated circuit card UICC a universal subscriber identity module USIM a removable user identity module R UIM etc. The UIM typically stores information elements related to a mobile subscriber. In addition to the UIM the mobile terminal may be equipped with memory. For example the mobile terminal may include volatile memory such as volatile Random Access Memory RAM including a cache area for the temporary storage of data. The mobile terminal may also include other non volatile memory which can be embedded and or may be removable. The non volatile memory can additionally or alternatively comprise an EEPROM flash memory or the like such as that available from the SanDisk Corporation of Sunnyvale Calif. or Lexar Media Inc. of Fremont Calif. The memories can store any of a number of pieces of information and data used by the mobile terminal to implement the functions of the mobile terminal . For example the memories can include an identifier such as an international mobile equipment identification IMEI code capable of uniquely identifying the mobile terminal .

The MSC can be coupled to a data network such as a local area network LAN a metropolitan area network MAN and or a wide area network WAN . The MSC can be directly coupled to the data network. In one typical embodiment however the MSC is coupled to a gateway device GTW and the GTW is coupled to a WAN such as the Internet . In turn devices such as processing elements e.g. personal computers server computers or the like can be coupled to the mobile terminal via the Internet . For example as explained below the processing elements can include one or more processing elements associated with a computing system two shown in origin server one shown in or the like as described below.

The BS can also be coupled to a signaling GPRS General Packet Radio Service support node SGSN . As known to those skilled in the art the SGSN is typically capable of performing functions similar to the MSC for packet switched services. The SGSN like the MSC can be coupled to a data network such as the Internet . The SGSN can be directly coupled to the data network. In a more typical embodiment however the SGSN is coupled to a packet switched core network such as a GPRS core network . The packet switched core network is then coupled to another GTW such as a GTW GPRS support node GGSN and the GGSN is coupled to the Internet . In addition to the GGSN the packet switched core network can also be coupled to a GTW . Also the GGSN can be coupled to a messaging center. In this regard the GGSN and the SGSN like the MSC may be capable of controlling the forwarding of messages such as MMS messages. The GGSN and SGSN may also be capable of controlling the forwarding of messages for the mobile terminal to and from the messaging center.

In addition by coupling the SGSN to the GPRS core network and the GGSN devices such as a computing system and or origin server may be coupled to the mobile terminal via the Internet SGSN and GGSN . In this regard devices such as the computing system and or origin server may communicate with the mobile terminal across the SGSN GPRS core network and the GGSN . By directly or indirectly connecting mobile terminals and the other devices e.g. computing system origin server etc. to the Internet the mobile terminals may communicate with the other devices and with one another such as according to the Hypertext Transfer Protocol HTTP and or the like to thereby carry out various functions of the mobile terminals .

Although not every element of every possible mobile network is shown and described herein it should be appreciated that the mobile terminal may be coupled to one or more of any of a number of different networks through the BS . In this regard the network s may be capable of supporting communication in accordance with any one or more of a number of first generation 1G second generation 2G 2.5G third generation 3G 3.9G fourth generation 4G mobile communication protocols or the like. For example one or more of the network s can be capable of supporting communication in accordance with 2G wireless communication protocols IS 136 TDMA GSM and IS 95 CDMA . Also for example one or more of the network s can be capable of supporting communication in accordance with 2.5G wireless communication protocols GPRS Enhanced Data GSM Environment EDGE or the like. Further for example one or more of the network s can be capable of supporting communication in accordance with 3G wireless communication protocols such as a Universal Mobile Telephone System UMTS network employing Wideband Code Division Multiple Access WCDMA radio access technology. Some narrow band AMPS NAMPS as well as TACS network s may also benefit from embodiments of the present invention as should dual or higher mode mobile stations e.g. digital analog or TDMA CDMA analog phones .

The mobile terminal can further be coupled to one or more wireless access points APs . The APs may comprise access points configured to communicate with the mobile terminal in accordance with techniques such as for example radio frequency RF Bluetooth BT infrared IrDA or any of a number of different wireless networking techniques including wireless LAN WLAN techniques such as IEEE 802.11 e.g. 802.11a 802.11b 802.11g 802.11n etc. WiMAX techniques such as IEEE 802.16 and or ultra wideband UWB techniques such as IEEE 802.15 and or the like. The APs may be coupled to the Internet . Like with the MSC the APs can be directly coupled to the Internet . In one embodiment however the APs are indirectly coupled to the Internet via a GTW . Furthermore in one embodiment the BS may be considered as another AP . As will be appreciated by directly or indirectly connecting the mobile terminals and the computing system the origin server and or any of a number of other devices to the Internet the mobile terminals can communicate with one another the computing system etc. to thereby carry out various functions of the mobile terminals such as to transmit data content or the like to and or receive content data or the like from the computing system . As used herein the terms data content information and similar terms may be used interchangeably to refer to data capable of being transmitted received and or stored in accordance with embodiments of the present invention. Thus use of any such terms should not be taken to limit the spirit and scope of embodiments of the present invention.

Although not shown in in addition to or in lieu of coupling the mobile terminal to computing systems across the Internet the mobile terminal and computing system may be coupled to one another and communicate in accordance with for example RF BT IrDA or any of a number of different wireline or wireless communication techniques including LAN WLAN WiMAX UWB techniques and or the like. One or more of the computing systems can additionally or alternatively include a removable memory capable of storing content which can thereafter be transferred to the mobile terminal . Further the mobile terminal can be coupled to one or more electronic devices such as printers digital projectors and or other multimedia capturing producing and or storing devices e.g. other terminals . Like with the computing systems the mobile terminal may be configured to communicate with the portable electronic devices in accordance with techniques such as for example RF BT IrDA or any of a number of different wireline or wireless communication techniques including USB LAN WLAN WiMAX UWB techniques and or the like.

In an exemplary embodiment data associated with a Java application or other application may be communicated over the system of between a mobile terminal which may be similar to the mobile terminal of and a network device of the system of or between mobile terminals. As such it should be understood that the system of need not be employed for communication between mobile terminals or between a network device and the mobile terminal but rather is merely provided for purposes of example. Furthermore it should be understood that embodiments of the present invention may be resident on and executed solely at a communication device such as the mobile terminal or may be resident on and executed at a network device or other device.

Referring now to a system for providing memory footprint reduction for classes of an application programming interface or application is provided. The system includes one or more class file modification tools in communication with a class file selection element . A class file modification tool may be any device or means embodied in either hardware software or a combination of hardware and software that is capable of modifying at least a portion of bytecode for a particular class file. In an exemplary embodiment the one or more class file modification tools may include a first class file modification tool a second class file modification tool and a third class file modification tool . In other words according to one exemplary embodiment the one or more class file modification tools may include a Java bytecode optimizer e.g. Bytecode Level Optimizer and Analysis Tool BLOAT Soot JoGa JCMP etc. and or a Java obfuscator e.g. JShrink DashO ect. However any number of class file modification tools may be used and any other known types of Java bytecode optimizers obfuscators and or compilers may be included with and or substituted for any of the class file modification tools listed above. Additionally one or more of the class file modification tools may be preceded by a class file generation tool see such as a Java compiler e.g. javac Jikes Eclipse ecj GCJ GNU Janino etc. The Java compiler may modify a reference file or generate a reference file. Reference files may also be generated by other class file generation tools such as a default class file generation tool. The class file modification tools and class file generation tools may be considered as class file output tools since both class file modification tools and class file generation tools produce an output including either a modified class file or a reference class file respectively.

A bytecode optimizer tool may be any device or means embodied in either hardware software or a combination of hardware and software that is capable of transforming bytecodes inside a class file to a more optimized form in terms of the performance of the bytecode. Typically the bytecode optimizer tool is designed to provide performance improvement for each optimized class. As such the bytecode optimizer tool transforms class files internal to the particular class being optimized without affecting external classes. In some cases improving performance of the particular class may also result in reducing bytecode size. However whether a reduction in bytecode size occurs and or an amount of bytecode size reduction may vary from class to class and from bytecode optimizer tool to bytecode optimizer tool. As a result given two class files for example class file A and class file B the first class file modification tool may increase a size of class file A by 1.2 while decreasing a size of class file B by 0.8 . Meanwhile the second class file modification tool may decrease a size of class file A by 0.2 while increasing a size of class file B by 2.5 .

A compiler may be any device or means embodied in either hardware software or a combination of hardware and software that is capable of transforming Java source code into Java bytecode. Although compilers often generate un optimized bytecode it is possible that certain compilers may produce class files having a smaller size e.g. memory footprint than other compilers.

An obfuscator may be any device or means embodied in either hardware software or a combination of hardware and software that is capable of obfuscating code. An obfuscator may be designed to inhibit reverse engineering of the code including source code such as bytecode by converting it to obfuscated code. Obfuscated code is far less readable and therefore less apt to decompilation. However obfuscation typically alters class file symbolic data which may for example change the way a class file interfaces with other classes. As such embodiments of the present invention may be practiced in the context of obfuscators as class file modification tools only in situations where the obfuscator functionality is disabled such that the obfuscator only handles bytecode.

The class file selection element may be any device or means embodied in either hardware software or a combination of hardware and software that is capable of selecting for each class a file having the smallest size from among the class files produced by class file output tools. In this regard the class file selection element may be configured to receive reference class files and or one or more modified class files that are produced by the class file output tools. In an exemplary embodiment the class file selection element may be configured to select for each class a file having the smallest size from among the reference class file and one or more modified class files based at least in part on profiling data associated with the reference class file. Accordingly the class file selection element may be configured to determine an optimized class set given a reference class file and one or more modified class files. In an exemplary embodiment the optimized class set may be defined as a collection of the smallest class file among the reference class file and the one or more modified class files for each class. In an alternative exemplary embodiment the optimized class set may be defined as a collection of the smallest class file among the reference class file and the one or more modified class files for each class having profiling data indicating that the corresponding class is not performance critical.

The profiling data may be determined previously as a result of testing with respect to each of the classes. In this regard if a particular class is determined to be performance critical profiling data indicating the same may be included with the particular class. Accordingly any modification of the class may be limited to performance enhancement modifications. In other words size alone may not determine selection of class file selected for a performance critical class.

In an exemplary embodiment the class file selection element may further include a processing element a comparing element and a set selection element . In an exemplary embodiment the processing element could be the controller or a processor of a build machine which may control the operation of the comparing element and the set selection element . The comparing element and the set selection element may each be any device or means embodied in either hardware software or a combination of hardware and software that is capable of performing the corresponding functions of the comparing element and the set selection element respectively as described below. The comparing element may be configured to compare one or more modified class files to each other and or to the reference class file to determine which of the one or more modified class files and or the reference class file has the smallest memory footprint for each class. The set selection element may be configured to select the file determined to have the smallest memory footprint for each class to form an optimized class set . In an exemplary embodiment the set selection element may be further configured to select the file determined to have the smallest memory footprint for each class to form the optimized class set based on profiling data as described above.

Each of the class file modification tools and the class file selection element may include and operate under the control of a corresponding processing element. Alternatively some or all of the class file modification tools and or the class file selection element may operate under the control of a common processing element such as for example the controller of or the processor of a build machine. Processing elements as described herein may be embodied in many ways. For example a processing element may be embodied as a processor a coprocessor a controller or various other processing means or devices including integrated circuits such as for example an ASIC application specific integrated circuit . Alternatively a processing element such as the controller may perform all the functions of the class file selection element .

Operation of the embodiment shown in will now be described for purposes of example with reference to . is a diagram illustrating operation of the system according to an exemplary embodiment of the present invention. As shown in the system may apply the class file modification tools to a series of class files. For example a first class file e.g. class A may be applied to the first class file modification tool to produce a first modified class file e.g. class A to the second class file modification tool to produce a second modified class file e.g. class A and to the third class file modification tool to produce a third modified class file e.g. class A . A second class file e.g. class B may be applied to the first class file modification tool to produce a first modified class B file e.g. class B to the second class file modification tool to produce a second modified class B file e.g. class B and to the third class file modification tool to produce a third modified class B file e.g. class B . Additional class files e.g. class n may each receive similar treatment to that described above with respect to the first and second class files.

The class file selection element may be configured to select a smallest one from among each of the reference class files and the modified class files for each class. The selected file for each class may then be combined with the selected file for each other class to form the optimized class set . For example the class file selection element may be configured to select a smallest one from among class A class A class A and class A and a smallest one from among class B class B class B and class B etc. The selection of the smallest file may be accomplished by performing operations such as MIN A A A A MIN B B B B MIN n n n n etc. The optimized class set may therefore comprise the selected class file of each of the classes e.g. class A selected class B selected class n selected etc. .

In an exemplary embodiment the class file selection element may further include a profiling data analysis element . The profiling data analysis element may be any device or means embodied in either hardware software or a combination of hardware and software that is capable of examining profiling data associated with each corresponding reference class file e.g. class A class B etc. to determine whether the corresponding reference class is performance critical. The profiling data may indicate whether the reference class file corresponds to a class that is performance critical. In this regard the profiling data may be a list of classes that are performance critical. However in an exemplary embodiment each class could include metadata corresponding to the profiling data . Performance critical files may be determined during testing of class operation and marked as such with profiling data. As such when loading or preparing to load each class the profiling data associated with each corresponding reference class file may be examined to determine whether the corresponding reference class file and or corresponding modified class files should be size optimized. According to one example the class file selection element may receive reference class files and corresponding modified class files and discriminately select for each class a smallest file based on the corresponding profiling data . For example if class A is associated with profiling data indicating that class A is a performance critical class the class file selection element may be configured to disregard size in selecting a class file for inclusion in the optimized class set . In this regard the class file selection element or another element could be configured to select one of the class files having optimized characteristics in accordance with predefined performance criteria. Alternatively if the class file modification tools are optimizers i.e. devices performing transformations for performance enhancement the class file selection element may be configured to select a smallest one of the optimized class files for inclusion in the optimized class set e.g. MIN A A A MIN B B B etc. .

As stated above romizing does not reduce bytecode size in a class file. However embodiments of the present invention may be used in combination with bytecode optimizers or other class file output tools that are configured to or otherwise capable of reducing bytecode size of corresponding class files. Accordingly after optimizing class files for each class a size optimized one of either the reference class file or a modified class file may be selected in order to create an optimized class set which includes class files having a reduced memory footprint. The optimized class set may then be romized to reduce the footprint of the final stored class library. Accordingly when romizing is used in addition to embodiments of the present invention overall reductions in memory footprint size for class files may be achieved.

Accordingly blocks or steps of the flowcharts support combinations of means for performing the specified functions combinations of steps for performing the specified functions and program instruction means for performing the specified functions. It will also be understood that one or more blocks or steps of the flowcharts and combinations of blocks or steps in the flowcharts can be implemented by special purpose hardware based computer systems which perform the specified functions or steps or combinations of special purpose hardware and computer instructions.

In this regard one embodiment of a method of providing memory footprint reduction for classes of application or API code may include receiving a reference class file and one or more modified class files for each of a plurality of classes at operation . One of the one or more modified class files or the reference class file may be selected based at least in part on a size of each of the one or more modified class files and the reference class file as a selected file for each corresponding one of the classes at operation . At operation a class set may be formed including the selected file for each corresponding one of the classes. In an exemplary embodiment the method may further include romizing the class set at operation .

The above described functions may be carried out in many ways. For example any suitable means for carrying out each of the functions described above may be employed to carry out embodiments of the invention. In one embodiment all or a portion of the elements of the invention generally operate under control of a computer program product. The computer program product for performing the methods of embodiments of the invention includes a computer readable storage medium such as the non volatile storage medium and computer readable program code portions such as a series of computer instructions embodied in the computer readable storage medium.

Many modifications and other embodiments of the inventions set forth herein will come to mind to one skilled in the art to which these inventions pertain having the benefit of the teachings presented in the foregoing descriptions and the associated drawings. Therefore it is to be understood that the embodiments of the invention are not to be limited to the specific embodiments disclosed and that modifications and other embodiments are intended to be included within the scope of the appended claims. Although specific terms are employed herein they are used in a generic and descriptive sense only and not for purposes of limitation.

