---

title: API communications for vertex and pixel shaders
abstract: A three-dimensional API for communicating with hardware implementations of vertex shaders and pixel shaders having local registers. With respect to vertex shaders, API communications are provided that may make use of an on-chip register index and API communications are also provided for a specialized function, implemented on-chip at a register level, that outputs the fractional portion(s) of input(s). With respect to pixel shaders, API communications are provided for a specialized function, implemented on-chip at a register level, that performs a linear interpolation function and API communications are provided for specialized modifiers, also implemented on-chip at a register level, that perform modification functions including negating, complementing, remapping, stick biasing, scaling and saturating. Advantageously, these API communications expose these very useful on-chip graphical algorithmic elements to a developer while hiding the details of the operation of the vertex shader and pixel shader chips from the developer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07659902&OS=07659902&RS=07659902
owner: Microsoft Corporation
number: 07659902
owner_city: Redmond
owner_country: US
publication_date: 20060626
---
This application is a continuation of U.S. patent application Ser. No. 10 937 031 filed Sep. 9 2004 entitled API COMMUNICATIONS FOR VERTEX AND PIXEL SHADERS which is a continuation of U.S. patent application Ser. No. 09 801 079 filed Mar. 6 2001 now U.S. Pat. No. 6 819 325 entitled API COMMUNICATIONS FOR VERTEX AND PIXEL SHADERS which claims priority to U.S. Provisional Patent Application Ser. No. 60 187 535 filed Mar. 7 2000 entitled ASSEMBLY LANGUAGE FOR PROCEDURAL SHADERS IN AN IMMEDIATE MODE GRAPHICS API . The entireties of the aforementioned applications are incorporated herein by reference.

The present invention is directed to a three dimensional 3 D graphics application programming interface API that provides new and improved methods and techniques for communications between application developers and procedural shaders such as vertex and pixel shaders.

Computer systems are commonly used for displaying graphical objects on a display screen. The purpose of three dimensional 3 D computer graphics is to create a two dimensional 2 D image on a computer screen that realistically represents an object or objects in three dimensions. In the real world objects occupy three dimensions. They have a real height a real width and a real depth. A photograph is an example of a 2 D representation of a 3 D space. 3 D computer graphics are like a photograph in that they represent a 3 D world on the 2 D space of a computer screen.

Images created with 3 D computer graphics are used in a wide range of applications from video entertainment games to aircraft flight simulators to portray in a realistic manner an individual s view of a scene at a given point in time. Well known examples of 3 D computer graphics include special effects in Hollywood films such as Terminator II Jurassic Park Toy Story and the like.

One industry that has seen a particularly tremendous amount of growth in the last few years is the computer game industry. The current generation of computer games is moving to 3 D graphics in an ever increasing fashion. At the same time the speed of play is driven faster and faster. This combination has fueled a genuine need for the rapid rendering of 3 D graphics in relatively inexpensive systems.

Rendering and displaying 3 D graphics typically involves many calculations and computations. For example to render a 3 D object a set of coordinate points or vertices that define the object to be rendered must be formed. Vertices can be joined to form polygons that define the surface of the object to be rendered and displayed. Once the vertices that define an object are formed the vertices must be transformed from an object or model frame of reference to a world frame of reference and finally to 2 D coordinates that can be displayed on a flat display device such as a monitor. Along the way vertices may be rotated scaled eliminated or clipped because they fall outside of a viewable area lit by various lighting schemes and sources colorized and so forth. The processes involved in rendering and displaying a 3 D object can be computationally intensive and may involve a large number of vertices.

To create a 3 D computer graphical representation the first step is to represent the objects to be depicted as mathematical models within the computer. 3 D models are made up of geometric points within a coordinate system consisting of an x y and z axis these axes correspond to width height and depth respectively. Objects are defined by a series of points called vertices. The location of a point or vertex is defined by its x y and z coordinates. When three or more of these points are connected a polygon is formed. The simplest polygon is a triangle.

3 D shapes are created by connecting a number of 2 D polygons. Curved surfaces are represented by connecting many small polygons. The view of a 3 D shape composed of polygon outlines is called a wire frame view. In sum the computer creates 3 D objects by connecting a number of 2 D polygons. Before the 3 D object is ultimately rendered on a 2 D display screen however the data of sophisticated graphics objects undergoes many different mathematical transformations that implicate considerably specialized equations and processing unique to 3 D representation.

As early as the 1970s 3 D rendering systems were able to describe the appearance of objects according to parameters. These and later methods provide for the parameterization of the perceived color of an object based on the position and orientation of its surface and the light sources illuminating it. In so doing the appearance of the object is calculated therefrom. Parameters further include values such as diffuse color the specular reflection coefficient the specular color the reflectivity and the transparency of the material of the object. Such parameters are globally referred to as the shading parameters of the object.

Early systems could only ascribe a single value to shading parameters and hence they remained constant and uniform across the entire surface of the object. Later systems allowed for the use of non uniform parameters transparency for instance which might have different values over different parts of the object. Two prominent and distinct techniques have been used to describe the values taken by these non uniform parameters on the various parts of the object s surface procedural shading and texture mapping. Texture mapping is pixel based and resolution dependent.

Procedural shading describes the appearance of a material at any point of a 1 D 2 D or 3 D space by defining a function often called the procedural shader in this space into shading parameter space. The object is immersed in the original 1 D 2 D or 3 D space and the values of the shading parameters at a given point of the surface of the object are defined as a result of the procedural shading function at this point. For instance procedural shaders that approximate appearance of wood marble or other natural materials have been developed and can be found in the literature.

The rendering of graphics data in a computer system is a collection of resource intensive processes. The process of shading i.e. the process of performing complex techniques upon set s of specialized graphics data structures used to determine values for certain primitives such as color etc. associated with the graphics data structures exemplifies such a computation intensive and complex process. For each application developer to design these shading techniques for each program developed and or to design each program for potentially varying third party graphics hardware would be a Herculean task and would produce much inconsistency.

Consequently generally the process of shading has been normalized to some degree. By passing source code designed to work with a shader into an application a shader becomes an object that the application may create utilize in order to facilitate the efficient drawing of complex video graphics. Vertex shaders and pixel shaders are examples of such shaders.

Prior to their current implementation in specialized hardware chips vertex and pixel shaders were sometimes implemented wholly or mostly as software code and sometimes implemented as a combination of more rigid pieces of hardware with software for controlling the hardware. These implementations frequently contained a CPU or emulated the existence of one using the system s CPU. For example the hardware implementations directly integrated a CPU chip into their design to perform the processing functionality required of shading tasks. While a CPU adds a lot of flexibility to the shading process because of the range of functionality that a standard processing chip offers the incorporation of a CPU adds overhead to the specialized shading process. Without today s hardware state of the art however there was little choice.

Today though existing advances in hardware technology have facilitated the ability to move functionality previously implemented in software into specialized hardware. As a result today s pixel and vertex shaders are implemented as specialized and programmable hardware chips. Exemplary hardware designs of vertex and pixel shader chips are shown in and are described later in more detail. These vertex and pixel shader chips are highly specialized and thus do not behave as CPU hardware implementations of the past did.

Thus a need has arisen for a 3 D graphics API that exposes the specialized functionality of today s vertex and pixel shaders. In particular since present vertex shaders are being implemented with a previously unheard of one hundred registers it would be advantageous to have a register index for indexing the registers of the vertex shader. Also since realistic simulations require the precision of floating point numbers it would be advantageous to provide specialized vertex shading functionality with respect to the floating point numbers at a register level. For example it would be desirable to implement an instruction set that causes the extremely fast vertex shader to return only the fractional portion of floating point numbers. Similarly with respect to pixel shaders it would be desirable to provide specialized pixel shading functionality as well. More particularly it would be desirable to provide a function that performs a linear interpolation mechanism. Furthermore it would be desirable to use operation modifiers in connection with an instruction set tailored to pixel shaders. For example negating remapping biasing and other functionality would be extremely useful for many graphics applications for which efficient pixel shading is desirable yet as they are executed as part of a single instruction they are best expressed as modifiers to that instruction. In short the above functionality would be advantageous for a lot of graphics operations and their functional incorporation into already specialized pixel and vertex shader sets of instructions would add tremendous value from the perspective of ease of development and improved performance.

In view of the foregoing the present invention provides a three dimensional 3 D API for communicating with hardware implementations of vertex shaders and pixel shaders having local registers. With respect to vertex shaders API communications are provided that may make use of an on chip register index and API communications are also provided for a specialized function implemented on chip at a register level which outputs the fractional portion s of input s . With respect to pixel shaders API communications are provided for a specialized function implemented on chip at a register level that performs a linear interpolation function and API communications are provided for specialized modifiers also implemented on chip at a register level that perform modification functions including negating complementing remapping biasing scaling and saturating. Advantageously the API communications of the present invention expose very useful on chip graphical algorithmic elements to a developer while hiding the details of the operation of the vertex shader and pixel shader chips from the developer.

The present invention provides a 3 D graphics application programming interface API enabling software applications to control hardware in a way that is intuitive to software designers. This new method represents the hardware registers that control fixed function logic as a set of procedural instructions. This enables it to provide a consistent programming model for fixed function hardware as well as for hardware that actually supports programmability.

The present invention provides a 3 D graphics application programming interface API providing new and improved methods and techniques for communications between application developers and 3 D hardware such as vertex and pixel shaders.

As related in the background the specialized nature of today s graphics requirements creates a need for improved interfaces that can easily and efficiently exploit the ultra high performance characteristics of 3 D chips. One aspect of the 3 D API of the present invention is the incorporation of sophisticated programmable shading capabilities via programmable shaders . In this current model there are two programmable shaders defined vertex shaders and pixel shaders. Programmable vertex shaders can be used for operations such as complex environment mapping procedural geometry such as displacement meshes and enhanced matrix palette skinning which enables more realistic characters e.g. by making knees look like knees when the leg bends rather than having the leg appear as a rigid collection of line segments. Programmable pixel shaders also enable a number of interesting graphical effects such as true reflective bump mapping a variety of per pixel lighting algorithms including distributed light sources and special effects. This opens up the possibility of hardware accelerated procedural textures i.e. textures that are calculated rather than stored as bitmaps. The present invention fills a gap with respect to interfacing with a hardware programmable pixel shader. The 3 D API of the present invention thus delivers 3 D programmers or developers the performance equivalent of register level access to the hardware on a high performance graphics card without having to know the internal specifications of the card. While at the same time presenting complex hardware to the developer as a small processor ALU a paradigm that all software developers work with daily. The present invention was thus developed in an effort to ease these types of tasks via a 3 D graphics API in view of the sophisticated nature of today s game s rendering quality requirements.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as ROM and RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through an non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

As mentioned a computer such as described above can be deployed as part of a computer network. Further the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. Thus the present invention may apply to both server computers and client computers deployed in a network environment having remote or local storage. More and more graphics applications are becoming deployed in network environments. thus illustrates an exemplary network environment with a server in communication with client computers via a network in which the present invention may be employed. As shown a number of servers etc. are interconnected via a communications network which may be a LAN WAN intranet or the Internet with a number of client computers etc. In a network environment in which the communications network is the Internet for example servers can be Web servers with which the clients etc. communicate via any of a number of known protocols such as hypertext transfer protocol HTTP . The invention may also leverage peer to peer networking techniques. Each client computer and server computer may be equipped with various application program modules other program modules and program data and with connections or access to various types of storage elements or objects across which files may be stored or to which portion s of files may be downloaded or migrated. Each client computer and server computer may also be connected to additional storage elements such as a database. Thus the present invention can be utilized in a computer network environment having client computers for accessing and interacting with a network and server computers etc. for interacting with client computers.

The present invention provides software application programming interfaces APIs for use in connection with the architectures for the specialized hardware implementations of today s vertex and pixel shaders respectively. Pixel and vertex shaders give a more realistic and higher quality end result. The present invention is directed to an API that incorporates the features and power of the advanced rendering techniques of pixel and vertex shaders.

Similar to the way that RISC architectures define a novel minimal instruction set for processing use the present invention provides minimal and efficient sets of syntax for unique instructions used in connection with communications of today s vertex and pixel shaders. There are several unique functions that have been expressed for use with such procedural shaders which are of tremendous value in graphics applications to both developers whose coding is greatly simplified and to users of graphics applications that reap the performance benefit. In particular these procedural shaders do not access main memory or a stack on the host system but rather perform their operations efficiently with respect to a set of local registers. In accordance with the present invention an efficient instruction set has been designed to exploit the performance advantages of this architecture. illustrates the 3 D API of the present invention whereby there is no requirement to access main memory or stack of host in order to communicate with graphics IC at a register level. Thus API enables a developer D to interface with shader and its associated registers and bypass the relatively slower accessing and processing of data in host memory or stack .

Two main improvements with respect to vertex shader communications include the use of an on chip register index RI and the implementation of a function that returns the fractional portion of floating point number s processed at the register level. While the use of indices in connection with mapping to elements stored in host main memory is known the concept of using an index to map registers of a vertex shader has never been implemented in 3 D hardware. This is an outgrowth of the efficiency of bypassing main memory described above. Today s vertex shader design includes for example approximately one hundred registers. In an exemplary implementation there are 16 input registers 96 constant registers 12 temporary registers 1 address register and output registers corresponding to each rasterizer. These registers are in memory banks or files such as register storage . Previously there was no memory accessible inside the vertex shader and thus the implementation and storage of a register index RI inside the vertex shader is new and advantageous for fast access and local mapping to the elements stored in the registers of the vertex shader

In a preferred embodiment the register index RI may be stored in a register file and the register file is utilized in connection with the instructions delivered by API of the present invention. The register index RI is stored in a memory bank that has a counter which points to the appropriate registers for various arguments of instructions that are passed into the vertex shader via API . Similarly the index RI can be placed into an array or any other data structure suitable to mapping arguments to registers for use in processing operations of the vertex shader . Thus the use of a register index RI inside the vertex shader in accordance with the present invention provides local fast access to vertex shader registers and otherwise improves vertex shader performance. API facilitates the use of the register index RI by providing commands understandable to the graphics board or procedural shader while hiding any particular details regarding addressing and use of the register index RI from the developer.

Furthermore a special instruction for use in connection with today s vertex shader designs that has never before been implemented as part of a unique set of instructions for a vertex shader language includes the function frc which takes floating point number s as argument s . As illustrated in frc uniquely returns multiple fractional parts of numbers e.g. if presented with 3.14259 it returns 0.14259 effectively truncating off anything to the left of the decimal point. In a preferred embodiment it like the other instructions takes a single 4 element vector input argument and returns a 4 element vector of corresponding fractional parts. Previously to perform this operation additional host resources were implicated and this operation could not leverage the high performance characteristics of direct IC register access.

With respect to the improvement of communications with specialized hardware pixel shaders a special instruction for use in connection with today s pixel shader designs that has never before been implemented as part of a unique set of instructions for a pixel shader language includes the function lrp which performs a linear interpolation technique. As illustrated in the example of the lrp function taking three inputs or arguments s sand s and returning one output d performs the transformation d s s 1 s swhich essentially represents the proportion so between sand s wherein so is between 0 and 1. is a graphical representation of the exemplary functionality of illustrating the computation of point d between s and s. The lrp operation is useful in connection with a myriad of graphics operations including blend and fade for example. While previously this operation could be performed by utilizing host processing and or through multiple instruction custom coding of a software technique to perform this task never before has this operation been able to leverage the high performance register level access characteristics of a hardware pixel shader

There is also a set of unique modifiers for supporting the various instructions used in connection with pixel shaders . The prior art does not teach the use of modifiers in connection with an instruction set tailored to register level access to hardware pixel shaders . For exemplary modifiers snegates s and 1 sprovides the complement of s. The modifier  bx2 performs a remap function y x 0.5 2 and the modifier  bias provides stick bias i.e. it performs the remap function y x 0.5 which takes as an input a number previously between 0 and 1 and centers it between 0.5 and 0.5. Still other operation modifiers include  sat  x2 4 and  d2.  sat is a saturation modifier that clamps a result to the range from 0 to 1.  x2  x4 and  d2 are scaling modifiers for inputs whereby the output is scaled by two times four times and one half of the input value respectively. In short these are advantageous modifiers in graphics operations and have sometimes been custom coded by the developer to achieve the desired results. In accordance with the present invention the above listed modifier techniques can utilize the ultra high speed processing and register storage resident on today s pixel shader IC graphics chips thereby avoiding the use of costly host processing or more generally slower CPU processing. The incorporation of these modifiers into an already specialized pixel shader set of instructions for a hardware pixel shader adds tremendous value from the perspective of ease of development and improved performance. They enable a programmer expecting a software paradigm to have a clear idea of the cost of each instruction executed. This is because in most hardware implementations they are performed in the same logical clock cycle as an instruction so representing them to the programmer as separate instructions would make them appear to consume additional clock cycles. As illustrated in the special modifier functions of the present invention include negator M complementor M remapper M stick biasor M saturation modifier M and scalors M to M.

Some exemplary code or definitional pseudocode for a procedural shader such as a vertex shader is provided below. The declaration portion of an exemplary procedural shader defines the static external interface of the procedural shader. The information in the declaration includes assignments of vertex shader input registers to data streams. These assignments bind a specific vertex register to a single component within a vertex stream. A vertex stream element is identified by a byte offset within the stream and a type. The type specifies the arithmetic data type plus the dimensionality 1 2 3 or 4 values . Stream data that is less than four values are preferably expanded out to four values with zero or more 0.F values and one 1.F value.

The information in the declaration also includes assignment of vertex shader input registers to implicit data from the primitive tessellator. This controls the loading of vertex data which is not loaded from a stream but rather is generated during primitive tessellation prior to the vertex shader.

Moreover the information in the declaration also includes loading data into the constant memory at the time a procedural shader is set as the current procedural shader. Each token specifies values for one or more contiguous 4 DWORD constant registers. This allows the procedural shader to update an arbitrary subset of the constant memory overwriting the device state which contains the current values of the constant memory . Note that these values can be subsequently overwritten between DrawPrimitive calls during the time a procedural shader is bound to a device via the SetVertexShaderConstant method.

Declaration arrays are single dimensional arrays of DWORDs composed of multiple tokens each of which is one or more DWORDs. The single DWORD token value 0xFFFFFFFF is a special token used to indicate the end of the declaration array. The single DWORD token value 0x00000000 is a NOP token with is ignored during the declaration parsing. Note that 0x00000000 is a valid value for DWORDs following the first DWORD for multiple word tokens.

The stream selector token is desirably followed by a contiguous set of stream data definition tokens. This token sequence fully defines that stream including the set of elements within the stream the order in which the elements appear the type of each element and the vertex register into which to load an element.

Streams are allowed to include data which is not loaded into a vertex register thus allowing data which is not used for this shader to exist in the vertex stream. This skipped data is defined only by a count of DWORDs to skip over since the type information is irrelevant.

Placing of tokens other than NOPs between the Stream Selector and Stream Data Definition tokens is disallowed.

While the above exemplary computer executable instructions have been described in the context of a procedural shader these concepts and principles may be applied to any 3D hardware rendering device utilized in connection with a graphics display system.

The term graphics data as used herein is intended to cover not only video and or audio data in any pre processed processed or compressed form but is additionally intended to cover communications of data of any kind along the graphics pipeline among the developer the software interface of the present invention and various hardware and or software components utilized incident to the graphics system.

The various techniques described herein may be implemented with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computer will generally include a processor a storage medium readable by the processor including volatile and nonvolatile memory and or storage elements at least one input device and at least one output device. One or more programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

The methods and apparatus of the present invention may also be embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer a video recorder or the like the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates to perform the indexing functionality of the present invention. For example the storage techniques used in connection with the present invention may invariably be a combination of hardware and software.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. One skilled in the art will recognize that the present invention is not limited to the hardware pixel shader and vertex shader designs illustrated and described above but rather the invention applies to the incorporation of specialized syntax and novel functionality into an API for communicating with any ultra high performance graphics hardware chips that have register level processing. In such circumstances and according to the present invention the functions syntax and the desirability of their use remains applicable. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate. Therefore the present invention should not be limited to any single embodiment but rather construed in breadth and scope in accordance with the appended claims.

