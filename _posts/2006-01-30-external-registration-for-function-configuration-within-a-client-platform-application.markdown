---

title: External registration for function configuration within a client platform application
abstract: A method, system and computer program and method for modifying functionality of a computer program. In one embodiment, configuration files include configuration directives for removing and replacing computer executable codes. The configuration directives include code identifiers pointing to the computer executable codes for execution by the computer program. A lookup module is configured to recursively search for configuration files within plug-in packages. A control module is configured to modify the program flow of the computer program in accordance with the configuration directives.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08108851&OS=08108851&RS=08108851
owner: International Business Machines Corporation
number: 08108851
owner_city: Armonk
owner_country: US
publication_date: 20060130
---
The present invention relates generally to computers computer programs and methods therefore and more specifically to modifying functionality of a computer program by connecting external units of computer code referred to as plug ins.

The Eclipse platform also referred to herein as Eclipse is a computer program that provides a highly extensible computing environment. Eclipse is typically employed as an Integrated Development Environment IDE . An IDE is a computer program product that helps computer programmers develop other computer programs. The use of an IDE generally enables programs to be developed more quickly with fewer errors and at a lower cost. The Eclipse platform was designed to be as generic and extensible as possible to facilitate its use in developing programs in a wide variety of programming languages. This extensible nature as well as specific functionality such as user interface functionality provided by Eclipse has encouraged programmers to use Eclipse as the basis of applications never envisioned by the original developers.

Present versions of Eclipse execute within the Java Virtual Machine JVM runtime environment. Pre defined functionality called libraries to perform a wide variety of tasks is often made available to the JVM. Historically it has been necessary to design a separate version of a computer program product for each type of computer and operating system on which it is to be run. The JVM addresses this limitation by allowing programs written in Java to run on any computer or operating system with little to no modification. Therefore Eclipse can run on most if not all computer systems which support the Java platform.

At its core the Eclipse platform provides minimal functionality to its user. The platform provides various frameworks and significant user interface capabilities but it generally does not provide specific implementations of anything. In fact the Eclipse platform itself does not know how to process any specific computer language. Most functionality offered by Eclipse based applications is provided via a technological device known as a plug in. A plug in is a unit of computer code which provides specific well defined functionality. A plug in may also specify configuration settings. It is even possible for a plug in to contain configuration settings but no program logic. The reasons for doing so are discussed below. Each plug in typically has a unique identifier which distinguishes it from any other Eclipse plug in.

The manner in which a plug in relates to the remainder of an Eclipse based application is defined in a special file called a manifest. The manifest specifies the unique identifier as discussed above. It also specifies the location of the actual computer code for the plug in. The manifest is typically a text file in Extensible Markup Language XML format. XML is a technology which provides a basic structure applicable to various types of data. Within this basic structure a technological device referred to as a schema may be used to define rules of syntax for more specific types of data. Unlike files produced by word processors and other common data entry applications XML files often require a high degree of technical skill to edit due to the precise nature of the file format.

Plug ins connect to each other in a hierarchical fashion. Indeed an Eclipse based application is structured as a hierarchical tree of plug ins all directly or indirectly linked to the Eclipse platform itself. To allow plug ins to connect to each other each plug in may define one or more extension points. An extension point is a specification that one or more plug ins each referred to as an extension may connect to the original plug in. The extension point also defines the interface which is the exact manner in which the extensions connect to and communicate with the original plug in. The purpose in connecting an extension to a plug in is to allow the extension to contribute its own functionality and configuration settings to the original plug in s functionality. Notably the Eclipse platform does not require any given extension point to have an extension connected to it.

The connections between extension points and extensions are defined in the plug in manifest files discussed above. However once an extension has been connected to an extension point by the plug in manifests the Eclipse platform does not define a method to remove that extension or replace it with a different extension.

The present invention addresses the above mentioned limitation of the prior art by introducing a technique for replacing an extension with a different extension. The technique also allows removing an existing extension.

Thus one exemplary aspect of the present invention is a method for modifying the functionality of a computer program. The method includes a receiving operation for inputting a first plug in package. The first plug in package contains a first code identifier and the first code identifier points to a first computer executable code for execution by the computer program. Another receiving operation receives a second plug in package. The second plug in package includes a configuration directive for removing or replacing the first computer executable code. To identify the first computer executable code the configuration directive includes the first code identifier. A modifying operation alters the program flow of the computer program in accordance with the configuration directive.

In one embodiment of the method a loading operation loads the configuration directive from a file within the second plug in package. When replacing the first computer code the method may include a replacing operation that replaces the first computer executable code with a second computer executable code. Furthermore the configuration directive contains a second code identifier pointing to the second computer executable code. When removing the first computer code a removing operation removes the first computer executable code and the configuration directive includes a null value. The method may include creating a key value entry in a key value listing with the key value entry including the first code identifier.

Another exemplary aspect of the present invention is a system for modifying the functionality of a computer program. The system includes a lookup module configured to recursively search for configuration files within plug in packages. The configuration files are composed of configuration directives for removing and or replacing computer executable codes and the configuration directives include code identifiers pointing to the computer executable codes for execution by the computer program. A control module is configured to modify program flow of the computer program in accordance with the configuration directives.

Yet a further exemplary aspect of the invention is a computer program product for modifying the functionality of a computer application. The computer program product includes computer readable program codes configured to receive a first plug in package and a second plug in package. The first plug in package includes a first code identifier pointing to a first computer executable code for execution by the computer application. The second plug in package includes a configuration directive for removing and or replacing the first computer executable code as well as the first code identifier. The computer program product also includes code to modify program flow of the computer application in accordance with the configuration directive.

The foregoing and other features utilities and advantages of the invention will be apparent from the following more particular description of various embodiments of the invention as illustrated in the accompanying drawings.

The following description details how the present invention is employed to allow plug ins to be replaced with other plug ins or removed entirely in an existing plug in based application. Throughout the description of the invention reference is made to . When referring to the figures like structures and elements shown throughout are indicated with like reference numerals.

The invention includes a technological device called the system configurator. The system configurator manages the replacement and removal of plug ins. It acts as a layer between the plug in functionality and the association of plug ins to extension points.

The environment includes an operating system . A Java platform runs on top of the operating system . Utilizing the Java platform is an Eclipse platform . Plug ins provide most of the Eclipse environment s actual functionality. They connect hierarchically to the Eclipse platform and to each other .

In one embodiment of the invention the system configurator is itself a plug in. Specifically the system configurator is a special plug in which specifies how other plug ins connect to each other. One or more configuration files specify plug ins to be replaced and removed. Generally for each configuration file a plug in exists and contains a parameter specifying the precise location of the configuration file within a storage medium. Each such plug in connects to an extension point of the system configurator provided for this purpose. Additional details about the configuration files are provided below.

The system configurator after reading all configuration files stores the association of plug ins with their replacement plug ins in a key value data structure . This process is explained in detail below. In a particular embodiment of the present invention this key value structure is stored within the system properties provided by the Java platform. The system properties functionality is a standard feature of the Java environment allowing data pertaining to the system state to be stored in a key value structure. Java offers predefined methods to query the system properties. For example the java.util.Properties application programming interface API provided in Sun Microsystems J2SE 1.5 platform may be employed by the present invention. Each plug in may utilize these methods in order to query for the unique identifier of an extension to determine whether it is to be replaced by another extension or removed.

In a particular embodiment of the present invention the system configurator offers a function call which accepts as input the unique identifier of a plug in. If the specified plug in is to be replaced by a different plug in the function returns as output the unique identifier of that plug in. If the specified plug in is to be removed a special value is returned as output indicating that no plug in exists. It is contemplated that this value is null a special value in Java and other programming languages indicating the absence of a specific value. If the specified plug in is neither replaced nor removed its unique identifier will be returned as output to indicate that it indeed should be used.

A plug in which wishes to utilize an extension first queries the key value structure . The extension is itself a plug in. For simplicity the immediate discussion refers to the first plug in as simply the plug in and the second plug in which extends the first plug in as the extension. The key which is queried is the unique identifier of the extension as specified by the underlying technology. If the key value structure contains a value corresponding to this key the plug in acts as specified by the returned value. If this value is the unique identifier of a different extension the plug in utilizes this extension instead of the original extension. Alternatively the value corresponding to this key may be a special value indicating that no plug in exists. For example the value of the key value pair may be set to null a special value in Java and other programming languages indicating the absence of a specific value. In this case the plug in acts as if no extension is present. If the key value structure does not contain a value corresponding to the key the plug in utilizes the original extension.

The system configurator in one embodiment uses the unique identifiers of the plug ins themselves not of the extension points. An extension point may have multiple extensions which differ from each other and therefore have different unique identifiers. By using the unique identifiers of the plug ins themselves the configurator can replace or remove one of the extensions without impacting the other extensions at the extension point.

There are three general cases for how the key value structure may be used to match the plug in to the appropriate extension. The first case is where the extension s unique identifier is not specified in any configuration file . depicts this case with plug in as the plug in being extended. The dotted line indicates that in the underlying technology plug in is extended by plug in . This association is correct in actuality because as discussed below nothing has superseded it. However plug in does not rely on the underlying technology. Instead the configurator queries the key value structure using the unique identifier of the extension plug in as the key. This query is depicted by the solid line . Because the extension s unique identifier was not specified in any configuration file it is not present in the key value structure . The query returns the fact that no value corresponds to the given key. As a result plug in correctly utilizes plug in as its extension.

Turning now to an example of how an embodiment of the present invention is used to replace a first logon dialog plug in with a second logon dialog extension is demonstrated. This example utilizes Eclipse as the underlying plug in technology. However it is emphasized that alternate embodiments of the present invention designed for underlying plug in technologies other than Eclipse will also behave as demonstrated herein.

In accordance with the example shown the first logon dialog plug in to be replaced includes a unique identifier com.ibm.commerce.telesales.logonDialog. The first logon dialog extends a parent plug in at an extension point identified as com.ibm.commerce.telesales.ui.dialogs. The purpose of this first logon dialog plug in is to provide a default dialog for users to log in or authenticate themselves to a computer program product. A plug in manifest defines the basic structure of the default dialog. The id attribute of the dialog element specifies the plug in s unique identifier com.ibm.commerce.telesales.logonDialog. The point attribute of the extension element specifies that the plug in is connected to the com.ibm.commerce.telesales.ui.dialogs extension point. The class attribute of the dialog element specifies that the actual computer code for the plug in is located in the Java class com.ibm.commerce.telesales.logonDialog whose source code is located in the file com ibm commerce telesales logonDialog.java .

The first plug in is replaced by a second plug in having the unique identifier com.mycompany.logonDialog. The purpose of this extension is to provide a customized authentication dialog which replaces the default authentication dialog. This extension also has its own plug in manifest . In a particular embodiment of the present invention the path attribute of the configurator element of the plug in manifest specifies the location of the configuration file within a storage medium. The attribute contains a path to a subdirectory which is relative to the base directory housing the plug in. The configuration file is located in this subdirectory and is named config.ini . In the example shown the relative path is config and the plug in base directory is com mycompany . Therefore the configuration file is found at com mycompany config config.ini on the storage medium.

The configuration file contains machine readable codes representing a key value data structure. A key value data structure associates members of one set of data known as keys with members of another set of data known as values. Each key in the key value data structure is uniquely associated with a value. The converse is not true however the same value may be associated with more than one key. A key value data structure is also known as an associative array.

In the key value data structure the keys are the unique identifiers of the plug ins which are to be reassigned. Two possibilities exist for the value associated with a particular key. If the value is the unique identifier of another plug in the plug in specified in the key is to be replaced by the plug in specified in the value. If the value is a special value indicating the lack of a plug in the plug in specified by the key is to be removed. It is contemplated that this value may be null a special value in Java and other programming languages indicating the absence of a specific value. In a particular embodiment of the present invention the configuration file uses the file format specified by the java.util.Properties class of the Java platform. This file format represents a key value data structure. Moreover the java.util.Properties class provides program logic to read the file format from storage media to random access memory and to otherwise manipulate the file.

During program operation the time interval required to determine the extension for a given plug in may need to be as short as possible. In general the time to access data from a storage medium is quite long. Therefore it is contemplated that the contents of the configuration files can be loaded into random access memory during initialization in order to minimize this time interval. Moreover the system configurator can initialize an optimized data structure to further minimize this time interval. It is contemplated that a key value data structure may be used here just as it was for the configuration files themselves. The key value data structure or associative array is especially efficient and powerful when implemented in random access memory. Special techniques such as hashing may be utilized to minimize the time to find the associated value. It is possible to add a new key and its values to an associative array edit the value for an existing key or remove a key and its value entirely. Thus the key value data structure is one ideal data structure for storing the configuration files in random access memory contemplated by the present invention.

More than one configuration file may be specified. If this is the case all the configuration files are combined into one key value data structure in random access memory. It is contemplated that the configurator may sort this list applying rules to handle error situations such as when a single plug in is identified to be replaced with two conflicting plug ins or where a plug in is identified to be both replaced and removed. For example the configurator may associate priorities to various configuration files to arbitrate conflicting replace remove directives.

If a plug in is not replaced or removed in any configuration file it continues to exist and to be associated with other plug ins as specified in the underlying technology. This is reflected in the key value structure by the fact that the unique identifier of the unaffected plug in is not a key in the structure.

The plug in manifest for the customized authentication dialog plug in defines the basic structure of the customized dialog. The id attribute of the dialog element specifies the unique identifier com.mycompany.logonDialog. The point attribute of the extension element specifies that the plug in is designed to connect with the com.ibm.commerce.telesales.ui.dialogs extension point. Note that the extension point of the replacement plug in is identical to the extension point of the plug in being replaced. The class attribute of the dialog element specifies that the actual computer code for the plug in is located in the Java class com.mycompany.logonDialog whose source code is located in the file com mycompany logonDialog.java .

In the example above wherever the plug in with the unique identifier com.ibm.commerce.telesales.logonDialog was specified as the extension of another plug in in the underlying technology the plug in with the unique identifier com.mycompany.logonDialog is used instead. As a result the program logic specified in com mycompany logonDialog.java powers any request for com.ibm.commerce.telesales.logonDialog. It is important to note that the once the plug in has been replaced the program logic of the first plug in including both the XML and Java computer code is not executed when requesting the plug in com.ibm.commerce.telesales.logonDialog.

Turning now to a flowchart illustrates the program flow of one embodiment of a system configurator. It should be remarked that the logical operations shown may be implemented 1 as a sequence of computer executed steps running on a computing system and or 2 as interconnected machine modules within the computing system. Furthermore the operations may be performed on a virtual machine abstracted in a computer platform such as the Java Virtual Machine JVM executing over a native operating system. The implementation is a matter of choice dependent on the performance requirements of the system implementing the invention. Accordingly the logical operations making up the embodiments of the present invention described herein are referred to alternatively as operations steps or modules.

Operational flow begins with initialization operation . The initialization operation prepares the system configurator for processing plug in packages. This operation may entail allocating memory initializing variables and opening file streams. It is contemplated that the exact operations carried out in initializing operation is dependent of the specific program employing the system configurator. After initialization operation is completed control passes to loading operation .

At loading operation the system configurator searches for and loads a program plug in that modifies the functionality of the underlying computer program in accordance with the configurator s specifications. For example the plug in may include a plug in manifest file that includes an extension definition for an extension point of the system configurator. Furthermore the extension definition may indicate a configuration file within the plug in package containing directives for modifying the functionality of the underlying computer program. Thus using the plug in manifest the configurator can determine which plug ins require modification to the underlying program s functionality. Upon completion of loading operation control passes to receiving operation .

At receiving operation the system configurator receives configuration directives within the plug in package for modifying the underlying program s functionality. As mentioned earlier the configuration directives may be stored in the plug in package under analysis. In a particular embodiment of the invention the plug in manifest provides the exact location of a configuration file holding the configuration directives. The system configurator opens a file stream to the configuration file and retrieves the configuration directives.

As discussed above a configuration directive may be simple expressions substituting one code identifier for another code identifier. Such an expression may be for example com.ibm.commerce.telesales.logonDialog com.mycompany.logonDialog. Alternatively a configuration directive may indicate removal of program functionality by equating a code identifier with NULL or similar value. It should be stated that a configuration file may include more than configuration directive.

Next at adding operation the system configurator converts the configuration directive to a key value pair and adds this pair to a key value list. In a particular embodiment of the invention the system configurator utilizes the java.util.Properties API to generate the key value list. The key value list may be maintained in random access memory as discussed above. After adding operation is completed control follows to determining operation .

At determining operation the system configurator queries if additional plug in packages at modify the underlying program s functionality remain to be processed. If so control returns to loading operation where the step described above are repeated. After the last plug in has been processed by the configurator control passes to modifying operation .

At modifying operation the system configurator modifies the program flow of the underlying computer program in accordance with the processed configuration directives. During modifying operation the system configurator queries the key value data structure and directs the underlying program to the appropriate extension point of the processed plug in packages. After modifying operation is completed the process ends.

Turning now to an exemplary system configurator application for associating plug ins with appropriate extensions as contemplated by one embodiment of the present invention is shown. The system configurator application may be embodied in various tangible media known in the art including but not limited to read only memory random access memory optical and magnetic memory and the like.

The system configurator application includes a lookup module an internal cache and a control module . The lookup module is configured to recursively search for configuration files within plug in packages. The configuration files as discussed above include configuration directives for removing and or replacing computer executable codes. In addition the configuration directives include code identifiers pointing to the computer executable codes for execution by the underlying computer program.

The lookup module is further responsible for the actual association of plug ins to extensions. Upon initialization the system configurator application searches a storage medium which is external to the application to find all the relevant configuration files . It processes these files into an internal format a key value data structure which is stored in an internal cache . The internal cache may be implemented in random access memory data streams optical and magnetic memory or any other form of memory to which new data may be written. The procedure by which the files are processed and the format of the data structure are as discussed above. During runtime the lookup module is capable of accessing the data stored in the internal cache . It incorporates all business logic necessary to determine the appropriate plug in to use.

The system configurator application also includes a control module . The control module is configured to modify the program flow of the computer program in accordance with the configuration directives. The control module further provides a means for external plug ins to query for the appropriate extension. It is contemplated that this means can be provided via a function call. The unique identifier of the extension is passed to the control module via an argument to the function call. In an alternative embodiment of the present application the interface may be provided as a direct hardware based connection to a version of the application implemented in hardware.

A plug in which wishes to determine the appropriate extension to use passes the unique identifier of that extension to the control module . The control module accepts the external function call. In turn it queries the lookup module for the unique identifier. The lookup module determines the unique identifier of the appropriate plug in and returns it to the control module . The control module returns the unique identifier of the appropriate extension to the external plug in .

The foregoing description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed and other modifications and variations may be possible in light of the above teachings. As discussed above although the techniques discussed herein were made with specific reference to Eclipse it is contemplated that similar techniques may be utilized in various other computer programs.

The embodiments disclosed were chosen and described in order to best explain the principles of the invention and its practical application to thereby enable others skilled in the art to best utilize the invention in various embodiments and various modifications as are suited to the particular use contemplated. It is intended that the appended claims be construed to include other alternative embodiments of the invention except insofar as limited by the prior art.

