---

title: Systems, methods, and computer program products for packing instructions into register files
abstract: Embodiments of the present invention may provide for architectural and compiler approaches to optimizing processors by packing instructions into instruction register files. The approaches may include providing at least one instruction register file, identifying a plurality of frequently-used instructions, and storing at least a portion of the identified frequently-used instructions in the instruction register file. The approaches may further include specifying a first identifier for identifying each of instructions stored within the instruction register file, and retrieving at least one packed instruction from an instruction cache, wherein each packed instruction includes at least one first identifier. The packed instructions may be tightly packed or loosely packed in accordance with embodiments of the present invention. Packed instructions may also be executed alongside traditional non-packed instructions. Further, the use of packed instructions and instruction register files may provide a level of indirection that enhances the security of the embodying software.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07765342&OS=07765342&RS=07765342
owner: Florida State University Research Foundation
number: 07765342
owner_city: Tallahassee
owner_country: US
publication_date: 20060907
---
The present invention claims benefit of U.S. Provisional Application Ser. No. 60 714 959 filed Sep. 7 2005 and entitled Systems Methods and Computer Program Products for Packing Instructions which is hereby incorporated by reference in its entirety as if fully set forth herein.

This invention was made with Government support under CCR0208892 and EIA0072043 awarded by the National Science Foundation. The Government has certain rights in the invention.

The invention relates generally to processors and more particularly to architectural compiler and security approaches involving the packing of instructions into instruction register files.

Embedded systems are subject to a variety of design constraints. Performance must be sufficient to meet the timing constraints for the application. Power consumption should be minimized often to be less than a specified target. The size of read only memory ROM may have rigid limits to minimize cost. Unfortunately it is often difficult to improve one parameter without negatively affecting others. For example increasing clock frequency to enhance performance also increases energy consumption. Likewise code compression techniques may improve the code density but may increase the execution time. In addition voltage scaling reduces energy consumption but at the cost of increased execution time. While energy consumption code size and execution time has been the prevailing design environment for embedded processors the same design constraints may also apply to general purpose processor design as well.

According to an embodiment of the present invention there is a computerized method of optimizing processors. The method includes providing at least one instruction register file identifying a plurality of frequently used instructions and storing at least a portion of the identified frequently used instructions in the instruction register file. The method further includes specifying a first identifier for identifying each of the instructions stored within the instruction register file and retrieving at least one packed instruction from an instruction cache where each packed instruction includes at least one first identifier.

According to an aspect of the present invention the first identifier may include an index specifying one of the plurality of instructions stored within the instruction register file. According to another aspect of the present invention the method may further include identifying a plurality of frequently used immediate values and storing at least a portion of the identified frequently used immediate values in an immediate table. The method may further include specifying a second identifier for identifying each of the plurality of immediate values stored in the immediate table where at least one packed instruction includes a second identifier. According to yet another aspect of the present invention at least one packed instruction may include a second identifier associated with the first identifier where the second identifier identifies an immediate value stored in an immediate table.

According to another aspect of the present invention at least one of the packed instructions may include a plurality of first identifiers. According to another aspect of the present invention the instruction cache may include one or more of an L1 instruction cache and a ROM. According to still another aspect of the present invention a first format of the instructions stored in the instruction register file may be different from a second format of the instructions stored in the instruction cache. According to another aspect of the present invention the instruction register file may includes a plurality of data registers for storing the frequently used instructions and at least one frequently used instruction in the instruction register file may identify a data register by a position of a previous instruction relative to a position of a current instruction of the instruction cache. According to yet another aspect of the present invention one of the frequently used instructions stored in the instruction register file may include a no operation nop instruction.

According to another embodiment of the present invention there is a computer implemented method for packing instructions. The method includes partitioning an application having a plurality of instructions identifying a set of frequently used instructions for each partition and storing each set of frequently used instructions within each partition in one of a plurality of instruction windows. The method further includes specifying within each instruction window an identifier for each instruction stored in the instruction window and providing one or more packed instructions for each partition where each packed instruction includes at least one identifier corresponding to a frequently used instruction stored in each instruction window for the corresponding partition.

According to an aspect of the present invention at least one instruction window may be associated a plurality of hardware registers. According to another aspect of the present invention the plurality of hardware registers may form an instruction register file. According to another aspect of the present invention the method may further include providing at least one pointer specifying one of the plurality of instruction windows. At least one packed instruction may include a pointer to one of the plurality of instruction windows. According to yet another aspect of the present invention the at least one instruction window may be implemented with software.

According to yet another embodiment of the present invention there is a computer implemented method for providing secure software. The method includes providing a plurality of instruction register file IRF instructions specifying a first identifier for each IRF instruction in the instruction register file and providing memory instructions that include one or more packed instructions where the packed instructions include at least one first identifier. The method farther includes packaging the plurality of IRE instructions and the memory instructions into at least one first distribution file.

According to an aspect of the present invention the method may further include packaging the IRF instructions and the memory instructions into at least one second distribution file wherein an ordering of IRF instructions of the first distribution file is different from an ordering of IRF instructions of the second distribution file. According to another aspect of the present invention one of the plurality of IRF instructions for the instruction register file may include a no operation nop instruction. According to yet another aspect of the present invention an intrusion detection module may be provided for determining when an IRF instruction is not accessed via a first identifier.

Embodiments of the present invention may provide for micro architectural designs instruction set design improvements and or compiler optimizations for meeting varying constraints associated with energy consumption code size and execution time. The present inventions now will be described more fully hereinafter with reference to the accompanying drawings in which some but not all embodiments of the invention are shown. Indeed these inventions may be embodied in many different forms and should not be construed as limited to the embodiments set forth herein rather these embodiments are provided so that this disclosure will satisfy applicable legal requirements. Like numbers refer to like elements throughout.

Embodiments of the present invention may utilize instruction packing methods for meeting design constraints of one or more of energy consumption code size execution time and enhanced security. illustrates an exemplary system for utilizing such instruction packing methods in accordance with an embodiment of the present invention.

Referring to there is a program counter PC an instruction cache an instruction fetch instruction decode IF ID module an instruction register file IRF an immediate table IMM an instruction table and an instruction buffer . During operation of the system the PC may hold an address for the instruction to be fetched from the instruction cache which may be implemented using memory such as L1 instruction caches ROMs and the like known to those of ordinary skill in the art. Instructions referenced or addressed from instruction cache may also be referred to as memory ISA instruction set architecture or MISA instructions. As will be described in further detail below these MISA instructions stored in the instruction cache may be packed according to various embodiments of the present invention. According to an embodiment of the present invention the MISA instructions may via the IF ID module reference one or more instructions stored in the instruction register file which may also be referred to as register ISA or RISA instructions. The instruction register file may contain registers that store frequently accessed or referenced RISA instructions. According to an embodiment of the present invention the instruction register file may be a 32 instruction register file although one of ordinary skill will recognize that fewer or more than 32 instructions may be utilized as necessary e.g. 16 instructions 64 instructions etc. . The instruction register file may be implemented using one or more random access memory RAM structures which may be one or more SRAM structures. Many memory structures for register file are known to those of ordinary skill in the art and may be equally utilized without departing from embodiments of the present invention. Instructions retrieved for decoding from the instruction register file may be placed in the instruction buffer for execution.

In addition to the instruction register file the system also includes an immediate table which may include commonly used immediate values in the program. Like the instruction register file the immediate table may be implemented using SRAM structures or other similar memory structures. According to an embodiment of the present invention there may be 32 immediate values in the immediate table although fewer or more than 32 immediate values may be utilized. In addition to the RISA instructions described above the MISA instructions stored in the instruction cache may also reference one or more immediate values from the immediate table .

One of ordinary skill in the art will recognize that many variations of the system are possible. For example while the instruction fetch instruction decode stages have been illustrated as consecutive stages of a single IF ID module the instruction fetch instruction decode stages may be separated by intervening stages. According to an alternative embodiment of the present invention the instruction register file may be placed at the end of the instruction fetch stage instead of at the end of the instruction decode stage. Further alternative embodiments of the present invention may store partially decoded instructions in the instruction register file perhaps if the decode stage is on the critical path of the processor implementation.

As described with reference to the MISA instructions stored in the instruction cache may be stored in a packed instruction format according to an embodiment of the present invention. The packed instruction format may allow multiple RISA instructions to be specified using a single packed MISA instruction.

Each respective instruction identifier of may be used to reference a particular RISA instruction stored in the instruction register file . In particular the instruction identifier may include a small register specifier used to index the RISA instructions stored in the instruction register file . For example if the instruction register file includes 32 instructions then the small register specifier may be 5 bits. Similarly the instruction identifier may include at least 5 bits to accommodate the 5 bit small register specifier. Accordingly the use of these small register specifiers for the instruction identifiers may allow multiple USA instructions to be specified e.g. packed within a single MISA instruction fetched from the instruction cache .

In addition to specifying one or more instruction identifiers the tightly packed instruction format may optionally include one or more parameter identifiers . The parameter identifier may reference perhaps via an index value a particular immediate value from the immediate table . If the immediate table includes 32 entries then the parameter identifier may be at least 5 bits as illustrated in . According to an aspect of the invention additional instruction opcodes and or other instruction bits such as S bit within the tightly packed instruction format may specify which instruction corresponding to a particular instruction identifier utilizes the specified parameter identifier for the immediate value in the immediate table . In addition or in the alternative default immediate values for instructions specified by the instruction identifiers may be utilized where no immediate values are specifically provided for. Further as illustrated in an instruction identifier may be substituted for a parameter identifier without departing from embodiments of the present invention.

According to an exemplary embodiment of the present invention the tightly packed instruction format may be a 32 bit instruction format utilized with a MIPS ISA according to an exemplary embodiment. One of ordinary skill in the art will recognize that the format of the MISA instructions fetched from the instruction cache may be different from the format of the RISA instructions stored in the instruction register file . In addition or in the alternative an instruction in the instruction register file may identify a data register by the distance between a prior use in a previous instruction and the current instruction.

In addition to a tightly packed instruction format the instruction sets in accordance with embodiments of the present invention may additionally or alternatively be extended to support a loosely packed instruction format. A standard MIPS instruction may generally be modified to include at least 5 bits available for an additional RISA reference analogous to instruction identifier in . For instance an immediate value field of a MIPS instruction may be reduced from 16 bits to 11 bits such that 5 bits may specify an instruction register. Accordingly the RISA instruction may be executed following the original MISA instruction thereby allowing two instructions to be fetched for the price of one. If no meaningful RISA instruction is to be executed or specified by the MISA instruction then the entry in the instruction register file corresponding to a nop no operation is used or referenced in the MISA instruction. Accordingly there is no performance penalty if the RISA reference in the MISA instruction is a nop since no instruction will be executed from the instruction register file and fetching will continue as normal. While a goal of the tightly packed instruction format is the improved fetch of frequently executed instruction streams the loosely packed instruction format helps in capturing the same common instructions when they are on infrequently executed paths and not surrounded by other packable instructions.

In order to more effectively pack instructions for applications with diverse function and phase behavior the instruction register file may be extended to support a plurality of windows which may be hardware windows according to an exemplary embodiment of the present invention. If the windows are implemented in hardware then registers and pointers specifying each instruction register file window may be utilized. Using windows for the instruction register file may increase the size of the instruction register file without requiring changes to the packed instruction formats which as described above may be tightly or loosely packed. Accordingly if there are 4 windows with up to 32 instruction registers per window then there are may be a total of 128 available physical instruction registers according to an exemplary embodiment of the present invention. Only 32 of these registers are accessible at any single point in time based upon a particular window however so the remaining 96 registers can be kept in a stand by mode perhaps in a low power mode in which they retain their values but cannot be accessed. On a function call and or return the target address uses a win field illustrated in which may be 2 bits according to an exemplary embodiment of the present invention to distinguish which instruction window to be accessed. All function addresses are updated at link time according to which window of the instruction register file they will access. Likewise according to an exemplary embodiment of the present invention the immediate table for each instruction register file window described above may be the same. However other embodiments of the present invention may similarly utilize a plurality of windows for the immediate table as well.

Many other modifications of the packed instruction formats are available. For example while the packed instruction formats have been described with respect to 32 bit examples embodiments of the present invention similarly apply to smaller and larger instruction formats perhaps to 64 bit and larger formats. In addition in alternative embodiments of the present invention packed instructions that are currently terminated by a conditional branch may be modified. Currently such packed instructions that are terminated by a conditional branch are not followed by any instructions. However in accordance with embodiments of the present invention such packed instructions terminated by a conditional branch may now be followed by a RISA instruction that should execute only if the branch is not taken. This form of instruction predication may not result in a code size increase. According to another alternative embodiment of the present invention the instruction file can be split into at least two files the opcodes can be placed in a first file and the associated operands can be placed in a second file. The plurality of opcodes can be indexed by a first identifier and the plurality of operands can be indexed by a second identifier. A packed instruction can then include one or more first identifiers and one or more associated second identifiers.

1. Promotion of Instructions to the Instruction Register File and Immediate Values to the Immediate Table by the IRF Analysis Tool

Instruction promotion is the process of selecting which instructions should reside in each instruction register file window as well as which immediate values should reside in the immediate table . In accordance with an embodiment of the present invention the IRF Analysis Tool e.g. a selection and layout toot may perform such an instruction promotion process by analyzing the static profile data and or the dynamic profile data . Functions are partitioned and certain instructions are placed into statically allocated instruction register file windows by the IRF Analysis Tool according to a selection algorithm which may include a greedy algorithm. This algorithm may operate by estimating the potential cost benefit of packing the instructions of a function into each particular instruction register file window and then greedily selecting the most beneficial function to assign to a window until each function has been allocated.

According to an exemplary embodiment of the present invention the benefit of promoting an instruction to the instruction register file may be determined by the IRF Analysis Tool by quantifying the possible potential improvement perhaps based upon both of code size and fetch energy requirements. For instance a tightly packed instruction cannot achieve any further benefit so its potential improvement is 0. A parameterized packable instruction which utilizes the immediate table has a potential improvement of 1 since it could be promoted with its immediate value as the default. A loosely packable instruction has a potential improvement of 3 since it normally would occupy approximately 4 of the slots in a MISA instruction with the remaining slot available for a single RISA reference. Finally an instruction that is not loosely packable like lui has a potential improvement of 4 since packing it into a single RISA entry will free up 4 additional slots in the MISA instruction. By calculating the potential improvements in this manner means are provided for multiple I type instructions that differ only in default immediate value to reside in the instruction register file simultaneously. This allows each entry to remain loosely packable which can be beneficial if each operation occurs very frequently. While the embodiment above has been discussed with respect to promoting an instruction to the instruction register file based upon both of code size and fetch energy requirements other embodiments may determine promotion based solely upon either code size or fetch energy requirements.

In addition the promoting of an instruction may be based upon an analysis of static profile data dynamic profile data or a combination thereof. More specifically dynamic profiling using dynamic profile data may exposes the kernel loops of the application and correspondingly the most frequently executed instructions from these loops. On the other hand static profiling using static profile data may likewise reveal those instructions that that comprise the greatest portion of the application s code. Further a combination of dynamic profiling and static profiling may yield an adequate balance between code size savings and energy reduction especially when dealing with a highly constrained embedded design space.

As described above the VPO Compiler may perform an instruction selection process which may include choosing or selecting which instruction or instruction sequence to use for a particular semantic operation. The VPO compiler may operate on register transfer lists RTLs that have a one to one correspondence with machine instructions. In accordance with an embodiment of the present invention instruction selection can be modified to increase the amount of redundancy in the code without negatively impacting code size or performance.

There are several methods for using instruction selection according to embodiments of the present invention. First equivalent parameterizable operations can be chosen to replace simple operations such as encoding move operations as additions with 0. Second commutativity rules may be applied to make sure that all semantically equivalent instruction instances use the same order for operands. Third parameterization may be applied to the destination registers of R type instructions which were previously unable to be parameterized.

Choosing equivalent parameterizable instructions over simple instructions is a transformation technique that can be applied to instruction packing in accordance with an embodiment of the present invention. The benefits of these transformations in increasing the instruction redundancy within an application may be quantified. Most of the equivalence transformations may occur for the mov and li pseudo instructions. Register moves may be normally performed using the addu instruction with the hard wired register zero as the second source argument. Instruction selection may instead generate this operation as an addiu instruction with zero as the immediate operand in accordance with an embodiment of the present invention. Load immediate instructions with small constants may interchangeably be generated as addiu instructions or ori instructions that use register zero as their first source operand. To increase code redundancy the profiling pass may convert these instructions to an addiu format. Each of these transformations may increase the number of opportunities that parameterization will have for packing various sequences of instructions.

Simple transformations may also be used to increase redundancy by reducing or completely eliminating instruction diversity. The native MIPS ISA may use PC relative addressing for branches and absolute addressing for jumps. However absolute addressing may pose problems with instruction packing since there can be quite a diverse set of jump target addresses. To increase the ability for frequent jumps to be placed in the instruction register file short distance jumps 16 to 15 instructions may be converted into branches that compare register zero to itself in accordance with an embodiment of the present invention. These instructions can then be parameterized in the same manner as conditional branches. If short distance jumps occur frequently in the application then only a single RISA entry is necessary to parameterize each of them.

Transformations may also be applied to place the operands for commutative operations in the same order for each instruction. If the destination register is also a source register then that register is placed first in the operand list. If all registers are different then the operands may be ordered from lowest to highest number. This transformation may unify equivalent commutative operations to further increase the level of instruction redundancy. In addition to parameterization of I type RISA instructions to the instruction register file embodiments of the present invention may also provide for parameterization to R type destination registers. The parameterization of R type destination registers may operate by consuming an additional RISA slot in the tightly packed instruction format to specify the replacement value 5 bits for rd. The requirements for supporting such a feature may be minimal as the existing parameterized instructions may not require any modifications. Only a small amount of additional hardware may be necessary primarily in the form of multiplexers going to the instruction decoder see e.g. instruction fetch instruction decode module .

Compilers often attempt to minimize register usage in order to keep additional registers available for further optimizations. Since the VPO compiler applies optimization phases repeatedly it also rigorously attempts to minimize the number of distinct registers used in each particular function This strategy may lead to different register usage patterns in the generated code for similar but slightly different functions due to the varying register pressure.

A small difference in register numbering can eliminate the possibility of instruction packing for a sequence of instructions. Although the instruction register file supports a limited ability to parameterize registers register re assignment can be beneficial by replacing entire register live ranges. With re assignment in accordance with an embodiment of the present invention these registers can be adjusted to match existing instruction register file instructions leading to increased pack density. Thus in accordance with an embodiment of the present invention registers may be re assigned to make instructions match existing instruction register file entries when possible. Alternative embodiments of the present invention may involve renaming register files.

The instruction register file register reassignment algorithm in accordance with an embodiment of the present invention may use a register interference graph to calculate the entire inter block live range span for each register. When constructing the register interference graph registers that are used and set within a single RTL are split into two distinct live ranges. This splitting may allow registers to be reassigned in a more fine grained manner than the merging of these live ranges would have allowed. Shorter live ranges may have reduced potential for conflicts which may limit the effectiveness of such a transformation. A greedy algorithm may be utilized in accordance with an embodiment of the present invention for selecting the candidates for register re assignment. Basic blocks may be ordered from most frequently executed to least frequently executed based on the dynamic profile data . With this information each potential re assignment may be examined perhaps individually. Live ranges of registers that cannot be altered e.g. calling conventions may be marked so they are not re assigned in any manner. Since multiple renames may not be performed simultaneously it may first be verified that the target register that is to be re assigned is not live at any adjacent node in the graph. Using the register interference graph the register substitution may be performed on the appropriate portion of each given RTL. Note that it may not be possible to change all references when splitting uses and sets within a single RTL into multiple live ranges of the same register number.

Instruction scheduling is an optimization that involves reordering the instructions in a basic block in an attempt to eliminate pipeline stalls due to long operation dependences. The actual scheduling often employs a directed acyclic graph DAG to maintain instruction dependence relationships. Once the DAG is constructed instructions may be issued based on priorities relating to future dependences. Instructions that have no incoming arrows in the DAG are considered to be in the ready set as they have no dependences on which to wait. Packing multiple RISA instructions into a single MISA instruction is somewhat similar to very long instruction word VLIW scheduling. In addition to physical hardware constraints the instructions in a VLIW word may be executed simultaneously so dependences may have to be placed in separate VLIW words leading to a great deal of fragmentation.

Scheduling for the instruction register file in accordance with an embodiment of the present invention may resemble VLIW instruction scheduling but a difference is that dependent instructions can be packed together in a single pack since the individual RISA references will still be sequentially issued.

Although conventional instruction scheduling may not include transformations that move instructions across basic blocks instruction register file packing may benefit from inter block scheduling. Instructions may be packed using a forward sliding window and thus the final instructions in a block can be left with unused instruction register file slots. Although intra block scheduling may be an attempt to reclaim unused RISA reference slots there are two cases where inter block movement of instructions can lead to improved pack density. The first improvement is duplicating code for an unconditional successor block in each predecessor. Typically code duplication only serves to increase code size but packed instructions that lead off a basic block can potentially be moved into unused slots in each predecessor. The second improvement may be the addition of instructions after a packed branch. Each of these inter block techniques may attempt to more densely pack blocks that have already been scheduled. Although the code size may remain the same by moving these operations earlier in the control flow graph CFG the ability to pack instructions in the current block may be improved. Inter block scheduling techniques in accordance with embodiments of the present invention may be similar to filling delay slots in a RISC architecture particularly the annulled branch feature of the SPARC. A benefit of inter block instruction packing is that duplication of code can lead to an overall code size reduction.

According to an exemplary embodiment of the present invention the baseline MIPS ISA that underlies the IRF architecture may not have support for predicated execution of instructions. With compiler transformations however predication may be mimicked by packing instructions after conditional branches. If a forward conditional branch is taken then the following instructions within the pack will be skipped. If it is not taken then they will be executed normally just as the fall through block normally is. Backward branches are assumed to execute the additional RISA slots only when they are taken. The baseline instruction register file implementation reserves 5 bits for loosely packing each I type instruction except lui and the original compiler may not support cross block packing.

Thus according to an exemplary embodiment of the present invention branches may not loosely pack an additional instruction and branches within tight packs may force termination of the pack execution. This may serves to decrease the overall packing density. Note that multiple branches or jumps together might not be packed together in order to have the branch predictor and branch target buffer to be associated with the overall MISA instruction address. One benefit of this style of predicated execution is that no additional bits in the traditional instruction formats may be required for predicates. Furthermore these predicated instructions need not be fetched decoded or even executed if the predicate is false.

According to another embodiment of the present invention a conditional branch may be specified where the conditional branch includes at least one parameter. A location of a memory instruction can be specified for the parameter. At least one instruction register file IRF instruction can be provided following the conditional branch. Accordingly the memory instruction will be executed if the conditional branch is taken and the IRF instruction will be executed if the conditional branch is not taken.

In accordance with an embodiment of the present invention the use of an instruction register file may provide for additional security against malicious attacks including protection against malware and buffer overflow attacks. More specifically as will be described in further detail below the use of an instruction register file may provides a level of indirection between an instruction reference and the actual instruction content.

The MISA instructions that reference the instruction register file do so in packed instructions that use small indices to the instruction register file such as a 5 bit index for a 32 entry instruction register file . In accordance with an embodiment of the present invention this presents a viable option for implementing variation with a single software program by permuting the placement of instructions within the instruction register file for each distributed executable of the program. Assuming the processor has a 32 entry instruction register file with one entry reserved to represent a nop instruction the remaining 31 instructions can be placed in the instruction register file in 31 factorial combinations. This pool from which unique executable versions can be created is vastly greater than the number of possible distributions. The corresponding packed instructions in the executable must be updated to use the appropriate indices however performing this update requires only a simple mapping. By design a significant percentage of the instructions in a program can be executed from an instruction register file thus this permutation results in a substantial quantity of variation between each executable version. The actual instructions to be placed in the instruction register file can be encrypted or distributed separately from the executable.

Since the only change in actual packed instructions is in indices to the instruction register file this variation in program versions comes with absolutely no variance in the program behavior between each version nor in the program performance on a given processor. Since the software author has knowledge of the instruction register file contents and permutations distributed there is no impact on the maintenance or packing of the versions which are fundamentally identical in code logic. Accordingly embodiments of the present invention may provide for an instruction register file as efficient solution to software security.

In addition to providing variation the permutation of instruction register file contents also serves as obfuscation of program code thus further thwarting analysis by malware authors. Since a significant portion of program instructions become simple instruction register file index references malware authors are denied a view of the actual instructions being executed. Malware authors must infer actual instruction contents from nameless indices that give no indication as to their purpose. Furthermore most of the branch jump and return operations are likely to be packed which makes most of the control flow within an application more difficult to detect. Hiding the control flow is recognized as one of the most effective means to obfuscate an application. And again this comes at no penalty in performance.

Logically any instruction that exists in the instruction register file should never be executed as a normal instruction but always by reference even in the case of single packed instructions . By enforcing such a requirement in an instruction register file system and detecting violations malware is prevented from performing short branches implementing system calls and many other instructions that are the most commonly executed and so by definition will be contained within the instruction register file . Malware authors are thus further hindered in their task and must endeavor to determine instruction register file contents but must do so with individually unique executables.

In accordance with another embodiment of the present invention there may also be intrusion protection module for detecting when malware is attempting to execute instruction register file instructions directly and when detected terminating execution of the program. Such intrusion protection modules may detect violations of security policy by monitoring and analyzing system behavior which includes recognizing that the direct execution of an instruction that resides in the instruction register file is anomalous and possibly intrusive behavioral characteristic.

According to embodiments of the present invention the intrusion protection modules may support differentiated executables according to the many permutations of the instruction register file . Accordingly the intrusion protection module would identify when instruction fetched from memory look suspicious such as when a MISA instruction is fetched that could have been more efficiently fetched because it also resides in the instruction register file . The only reason this would occur is that this portion of the code was not generated by the compiler which knows the contents of the instruction register file . This makes it a likely candidate for malware and the intrusion protection module will vector to a service routine to determine the reason for the unusual behavior or to terminate the application.

Many modifications and other embodiments of the inventions set forth herein will come to mind to one skilled in the art to which these inventions pertain having the benefit of the teachings presented in the foregoing descriptions and the associated drawings. Therefore it is to be understood that the inventions are not to be limited to the specific embodiments disclosed and that modifications and other embodiments are intended to be included within the scope of the appended claims. Although specific terms are employed herein they are used in a generic and descriptive sense only and not for purposes of limitation.

