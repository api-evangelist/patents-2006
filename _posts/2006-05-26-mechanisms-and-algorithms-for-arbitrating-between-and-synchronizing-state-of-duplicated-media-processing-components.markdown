---

title: Mechanisms and algorithms for arbitrating between and synchronizing state of duplicated media processing components
abstract: The present invention is directed, in various embodiments, to a hardware supported duplication token for arbitrating active and standby module states, a weighted state of health exchange for identifying unhealthy module states and relative module health states, and a packet sequence number synchronization technique for maintaining desired levels of synchronization between the active and standby modules.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07912075&OS=07912075&RS=07912075
owner: Avaya Inc.
number: 07912075
owner_city: Basking Ridge
owner_country: US
publication_date: 20060526
---
The invention relates generally to converged communications networks and particularly to alternate communication paths for voice communications.

IP networks generally provide an excellent infrastructure for geographically distributing components of a telecommunication system. The underlying IP network is optimal for transmission for control signaling and when bandwidth is available can provide an acceptable Quality of Service or QoS or Grade of Service or GOS for voice communications.

One of the problems of Voice over IP or VoIP communications surrounds system reliability. Existing solutions concentrate on providing call processing capacity with redundant gateways or media network path redundancy without synchronization. The Audiocodes Median Gateway for example supports N 1 redundancy which typically requires setting up the calls on the board made active not 1 1 hot standby for call preservation . Call state synchronization solutions are available in some media gateways but selection of the active component is done by a co resident control plane not the processing components. Such solutions are based on heartbeat messages with associated timeouts often requiring complete failure for an interchange to occur. This third party or software message model is implemented by software cluster solutions such as Veritas GoAhead and HA Linux vendors such as Monta Vista .

In redundant systems rapid failure detection and operational control between two devices is difficult to ensure without a third entity acting as tiebreaker or to actually manage the selection of the active device. In a failure situation the control decision requires ensuring one device is no longer active before enabling the standby device and that usually requires a timeout of some heartbeat because a failing device may not be capable of notifying a peer that it is no longer providing service. Making that timeout period too short leads to conflict incorrect failure detection false positives and more overhead with critical time deadlines. Longer timeouts enable more reliable operation but incur more data loss and associated service disruption particularly in VoIP applications.

In VoIP systems fault detection and reporting is considered difficult to generalize. With the increase in demand for highly available systems some vendors have developed third party libraries and tools to enable the application of failure detection and response to very generalized systems. Unfortunately these solutions themselves are capable of great complexity and as a result they consume system resources and can be difficult to implement reliably requiring stronger processors and more overhead. For example GoAhead advertises different states for the software objects representing critical system resources and requires 3.7 Mb of runtime memory and 10 Mb of disk space. In many cases GoAhead uses only two states namely simple or failed and multiple hierarchical relationship and redundancy policies to define behaviors when faults occur. Other script based systems are capable of simple generalization but quickly become complex as multiple objects or events interact to determine fault behavior and are synchronized between redundant systems. These systems also require interpreted languages typical of workstation class systems. The complexity of the various systems is surprising in light of the fact that software development studies have shown a direct correlation between complexity and errors in implementation.

Other systems concentrate on database synchronization between servers. These systems are too large for smaller embedded systems.

These and other needs are addressed by the various embodiments and configurations of the present invention. The present invention is directed generally to controlling and effecting transitions between active and standby processing systems. The processing systems may be in use in VoIP gateways or in other types of solutions including without limitation call control servers supporting functions such as audio video conferencing or announcements.

In a first embodiment of the present invention a method for operating a duplicated processing system includes the steps 

 a a first processing system determining whether a duplication token e.g. hardware supported semaphore has been asserted by a second processing system during a selected time interval 

 b when the duplication token has been asserted by the second processing system during the selected time interval maintaining the first processing system in the standby state and

 c when the duplication token has not been asserted by the second processing system during the selected time interval changing the state of the first processing system from the standby state to the active state thereby causing the first processing system to assume control of a function performed previously by the second processing system.

In one configuration the duplication token is a hardware supported semaphore that is used to signal unequivocally that the processing system is in possession of a TDM resource s and network address es . It is maintained by the operating system tick function which maintains the hardware watchdog of the system. Thus when the tick fails to refresh the semaphore the hardware will reset itself shortly and until the processing system has been reset the processing system maintains control of the semaphore. The semaphore signal is latched by the hardware e.g. Field Programmable Gate Array or FPGA on the standby processing system in the same tick function and resolves to a single memory value. The single memory value indicates whether the semaphore is owned contended or available. The duplication management process on the standby processing system reads this value periodically e.g. every 200 milliseconds to determine when the standby system needs to become active. This limits the controlled health timeout to a short time interval e.g. second even when the embedded software encounters an exception and is present but not participating. As will be appreciated shorter time intervals may be employed such as 50 milliseconds. Prior art mechanisms do not detect the internal reset until a heartbeat timeout.

 a determining for each of first and second processing systems a bit array including multiple bit sets each bit set corresponding to a one or more functional parameters each of the which defines a state of a functional aspect of a corresponding processing system a first type of functional parameter indicating a critical functional aspect and a second type of functional parameter indicating a noncritical functional aspect 

 b for each of the first and second processing systems arithmetically assigning based on the values of the corresponding plurality of bit sets first and second cumulative health state values respectively 

 c when the second cumulative health state value equals or exceeds the first cumulative health state value maintaining the second processing system in an active state and

 d when the first cumulative health state value exceeds the second cumulative health state value changing the state of the first processing system from a standby to the active state and the state of the second processing system from the active to the standby state.

In one implementation the first and second cumulative health state values are derived by arithmetically summing the corresponding bit array. When the selected processing system determines that its health state value is less than the other processing system s health state value and the other processing system s health state value is greater than a threshold value indicative of a minimum state of health the selected processing system effects a change of state of itself and the other processing system.

In one configuration the bit mapping health mechanism is used to evaluate local board health status for transitions periodically e.g. every 125 milliseconds or eight times per second . If a transition is detected the bit mapped values are transmitted to the standby board on a private serial link. If either a bit map update or a local transition is detected the bit maps are summed to a numerical value and a simple arithmetic comparison performed to determine which device should be active. The simplicity of the comparison is a significant advance over the prior art. As will be appreciated there is a direct and documentable correlation between complexity and errors in software systems.

The arithmetic value also indicates the severity of the fault detected and when the severity is above a threshold that indicates that the board is no longer capable of providing service it disables access to the common resource s and clears the semaphore. If the active board is not capable of disabling access due to the nature of the fault the active board executes a self reset and the standby board detects the reset within a short period e.g. 200 milliseconds . If the standby board receives indication of a fault on the active board or health updates are not exchanged for a selected period of time e.g. 1.5 seconds over either the private serial link or the IP network the standby board issues a request for the active board to release the semaphore. A short time e.g. one second later if the active board has not released the semaphore the standby board will issue a backplane reset of the active board to force release of the semaphore. As will be appreciated both boards driving a single shared TDM bus is less desirable than neither driving the board i.e. noise is less desirable than silence . The semaphore effects control of the bus to avoid dual concurrent use. When the semaphore is free a board knows that the TDM bus is clear.

In yet another embodiment a method for implementing a duplicated processing system includes the steps 

 a providing first and second processing systems the second processing system being in the active state and the first processing system being in the standby state the second processing system having for each call a transmit packet stream and a second transmit packet sequence number and transmit rollover counter value wherein the first processing system has for each call a first transmit packet sequence number and transmit rollover counter value the first transmit packet sequence number being representative of the second transmit packet sequence number and the first transmit rollover counter value being representative of the second transmit rollover counter value 

 b the first processing system incrementing the first transmit packet sequence number and rollover counter while in the standby state and

 c upon the occurrence of a trigger event adjusting the first transmit packet number and or rollover counter values by a shift value representative of a temporal drift between the relative values of the first and second transmit packet number values.

In one configuration drift between the transmit sequence numbers on the active and standby boards is accounted for using the shift value. In the absence of silence suppression the transmit sequence numbers of both the active and standby boards should track one another with a constant shift between the numbers. When silence suppression is enabled the lack of inbound RTP data can cause a difference in outbound packet generation if the echo cancellation algorithm removes background signal on the active but not the standby board s transmit packet streams. Upon switchover the newly active board uses a packet sequence number higher than the last sequence number used by the formerly active board thereby providing switchover transparency to the parties to the call.

As used herein at least one one or more and and or are open ended expressions that are both conjunctive and disjunctive in operation. For example each of the expressions at least one of A B and C at least one of A B or C one or more of A B and C one or more of A B or C and A B and or C means A alone B alone C alone A and B together A and C together B and C together or A B and C together.

The above described embodiments and configurations are neither complete nor exhaustive. As will be appreciated other embodiments of the invention are possible utilizing alone or in combination one or more of the features set forth above or described in detail below.

With reference to a telecommunications architecture is depicted according to an embodiment of the present invention. The enterprise has separate independent and active or primary call control server and standby call control server with resident call controller functionality. The enterprise also includes a plurality of digital circuit switched stations and analog circuit switched stations a plurality of IP or Internet Protocol stations a gateway and a firewall all interconnected by a Local Area Network or LAN . The gateway is interconnected by Wide Area Network or WAN and Public Switched Telephone Network or PSTN to external packet switched and circuit switched communication devices and respectively.

Each of the subscriber digital and analog stations and and packet switched stations and external packet switched and circuit switched communication devices and can be one or more wireline or wireless packet switched and or circuit switched communication devices as appropriate. For example the digital stations can be digital telephones such as Digital Communications Protocol or DCP phones Integrated Services Digital Network ISDN endpoints BRI and PRI terminal equipment including telephones and video endpoints voice messaging and response units traditional computer telephony adjuncts and wired and wireless circuit switched telephones the analog stations can be a Plain Old Telephone Service or POTS and the packet switched stations can be any packet switched communication device such as Avaya Inc. s IP phones such as 4600 Series IP Phones IP softphones such as Avaya Inc. s IP Softphone Personal Digital Assistants or PDAs Personal Computers or PCs laptops and H.320 video phones and conferencing units.

The media gateway is an electronic signal repeater and protocol converter that commonly provides a telephone exchange service supporting the connection of the various types of stations and outside packet switched and or circuit switched telephone lines such as analog trunks ISDN lines E1 T1 voice trunks and WAN route IP trunks . Telephone lines are typically connected to the gateway via ports and media modules on the chassis with different media modules providing access ports for different types of stations and lines. Voice and signaling data between packet switched and circuit switched protocols is normally effected by the media modules converting the voice path to a TDM bus inside the gateway. An engine such as a Voice Over IP or VoIP engine converts the voice path from the TDM bus to a compressed or uncompressed and packetized VoIP typically on an Ethernet connection. Each gateway commonly includes a number of port and trunk circuit packs for performing selected telecommunications functions such as DTMF tone detection tone generation playing audio music and or voice announcements traffic shaping call admission control and a media processor and one or more IP server interfaces. Examples of gateways include Avaya Inc. s SCC1 MCC1 CMC G350 G600 G650 and G700 . As will be appreciated the gateway and server may be co residents as in the G700 and S8300 .

The primary and spare call control servers controlling the gateway can be any typically converged architecture for directing circuit switched and or packet switched customer contacts to one or more stations. As will be appreciated the primary call control server normally controls the gateway. Commonly the call control servers are stored program controlled systems that conventionally include interfaces to external communication links a communications switching fabric service circuits e.g. tone detectors and generators announcement circuits etc. memory for storing control programs and data and a processor i.e. a computer for executing the stored control programs to control the interfaces and the fabric and to provide automatic contact distribution functionality. Illustratively the call control servers can be a modified form of the subscriber premises equipment disclosed in U.S. Pat. Nos. 6 192 122 6 173 053 6 163 607 5 982 873 5 905 793 5 828 747 and 5 206 903 all of which are incorporated herein by this reference Avaya Inc. s Definity Private Branch Exchange PBX based ACD system Avaya Inc. s IP600 LAN based ACD system or an S8100 S8300 S8500 S8700 or S8710 call control server running a modified version of Avaya Inc. s Communication Manager voice application software with call processing capabilities and contact center functions. Other types of known switches and servers are well known in the art and therefore not described in detail herein.

The LAN and WAN are packet switched networks. The LAN is typically governed by the Ethernet protocol while the WAN is typically governed by the Transport Control Protocol Internet Protocol suite of protocols.

A state of health agent collects state of health parameters regarding the corresponding module generating a bitmap including values of the state of health parameters forwarding the bitmap to the other module and comparing the bitmap of the selected module to the bitmap of the other module to determine which module is healthier and or should be the active module.

An arbitration agent monitors a register of the FPGA for a duplication token asserted by the other module asserts a duplication token in an FPGA register of the other module and notifies the duplication management agent of the duplication token state. The token unequivocally signals that a module is in possession of the TDM bus and the virtual network addresses. The token is latched by the FPGA of the receiving module and resolves to a single memory value that indicates the state of the token. The token is cleared by the agent and will not be set again until a module initiates another token cycle. The state may be available meaning that the corresponding module can by asserting the duplication token be the active module owned meaning that the other module has already asserted the duplication token and is the active module and contended meaning that the duplication token is neither available nor owned and both modules are currently attempting to assert the token and become the active module .

In one configuration the FPGA defines four memory mapped registers to provide the token functionality. The first register is an address register loaded with the value of the slot number of the current module. The second register is an address register loaded with the value of the slot number of the peer module. A third register is written to set the token based on the address of the current module. This register is latched by the hardware until the hardware token cycle is completed and then cleared by the hardware. The fourth register latches the hardware token cycle of the current module and the peer module. These token assertions are represented by two bits in the token status register.

A packet sequence synchronization agent depending on the state of the module e.g. whether active or standby generates and sends events containing the current RTP packet sequence number and roll over counter referred to as reliability data or information for both receive and transmit packet flows of each call or channel to the other module s agent and uses the reliability information to synchronize the state on the standby module to ensure that the roll over counter of the receive stream matches the source for secure RTP flows and to ensure that the values sourced by the standby module when it becomes active are consistent with the currently expected values at the receiver. Reliability information is exchanged when a call is established on demand from the other agent or periodically based on a configurable time.

An operating system tick function and reset agent provide a hardware watchdog functionality. The tick function of the operating system generates periodically a time tick interrupt signal that is used for module processing and self monitoring operations. If a time tick interrupt signal is not received by the reset agent at the appropriate time the reset agent causes a reset of the corresponding module. The time tick function further provides timing information which can be used to determine when to assert or look for a duplication token in the appropriate register of the FPGA.

The arbitration mechanism used to set module state will now be discussed with reference to . Prior to discussing the operation of the arbitration agent it is important to understand a number of requirements of module duplication. The state transition between boards is preferably performed quickly enough that the user who is on a call be unaware of any interruption in service. To avoid unnecessary delays the state of the modules is preferably not arbitrated by a third party. Because no third party is arbitrating the relative states of the two modules the modules need to be able to effect arbitration between themselves relatively quickly. Moreover because both of the modules share the same TDM bus the state change of the modules is preferably performed so that both modules are not using the bus at the same time. Concurrent use of the TDM bus can cause a system wide failure. Thus if the active module fails in such a way that it is unable to notify the other module that it is relinquishing the TDM bus the other module preferably can cause the other module to reset itself and thereby relinquish the TDM bus. The foregoing functions are effected using a duplication token such as a semaphore.

Terminology used in FIGS. and further needs to be clarified. The duplication token also referred to as a soft bit refers to the bit value asserted in the FPGA while a token grab refers to a bit stored in the memories of each of the first and second modules that determines whether or not the corresponding module will attempt to obtain ownership of the duplication token.

When the module is powered on the module starts in the initial state. In the initial state the module establishes its public interfaces and waits for a command from the higher level call control software such as Communication Manager by Avaya Inc. to proceed to either the simplex unduplicated or duplication mode. When a module is in the simplex mode it will necessarily be in the active state and not recognize a peer or standby module. In the simplex mode the agent merely verifies that both the local process control and the higher level control software are aware of the completed transition to the simplex mode and the agent will continue to process duplication downlink messages but only a mode change to duplex will cause a mode and or state transition. When a module is configured for duplication it requires a virtual IP and virtual MAC address duplication peer IP address of the other module and peer TDM address. This information is generally provided by the higher level control software.

In the initialization state the module configures and initializes its internal components. After internal initialization the agent monitors for messages from higher level control software and accepts status and mode commands but rejects interchange commands which cause the modules to effect an interchange of control or to transition from the active to the standby state and vice versa . A status command causes the module to be locked or unlocked and a mode command can request a mode update and or cause the module to transition to a different mode.

Before the duplex mode can be entered by the module the agent ensures that all required data has been received. If so the agent then proceeds to the arbitrate state to determine whether or not the module should be in the active or standby state. To prevent oscillation when the last module reset resulted from a request of the peer module or a self reset the module sets a damper timer and will not attempt to arbitrate for ownership of the soft token until the timer has expired. Additionally if the higher level control software has configured the module to be locked in the standby state or if the peer module has already acquired the soft token the board will not attempt to arbitrate but go directly to the standby state. If the module is configured as simplex it will transition to the simplex state without examining the last reset or any additional configuration data.

When the stimulus occurs the agent proceeds to decision diamond and determines whether the module is in the simplex mode. When the module is in the duplex mode the agent proceeds to decision diamond and determines whether the module is in the locked standby state. In the locked standby state the module is commanded by the higher level control software to reject any interchange commands and remain in the standby state.

When the module is in the simplex mode or when the module is in the locked standby state the agent proceeds to decision diamond and determines whether the token grab bit has been set. When the token grab is set the agent clears the token grab bit in step and returns to step . When the token grab is not set or when the module is not in the locked standby state the module proceeds to decision diamond .

In decision diamond the agent determines whether a token update is required. This step is intended to ensure that enough time has passed between the time that the soft bit has been asserted to permit the peer module to receive and recognize the asserted soft bit. For example if the stimulus is an event the event may have occurred before this needed time has passed. When a token update is required the agent returns to step . When a token update is not required the agent proceeds to decision diamond .

In decision diamond the agent determines the state of the token grab. When the token grab is clear or not set the agent proceeds to decision diamond and determines whether the module mode is already set to simplex. When the module mode is already set to simplex the agent proceeds to the simplex mode. When the module mode is not currently set to simplex the agent in step sets the local module process controller which controls the messages passing between the DSPs in the module and the higher level control software and or which sets and tears down VoIP calls to standby and sends a standby notification to the higher level software control. The agent then proceeds to the standby state.

Returning to decision diamond when the token grab is not clear or is set the agent proceeds to decision diamond and determines whether the peer module has asserted the duplication token by transmitting a pulse that is latched by the FPGA of the host module . If the peer module has not yet asserted the duplication token the agent proceeds to step sets the virtual IP address and local module process controller on the host module to active and sends an active notification to the higher level software control. The agent then proceeds to the active state meaning that the duplication token is owned by the host module because the agent has concluded that there is not contention with the peer module.

Returning to decision diamond when the peer module has asserted the duplication token meaning that the token state is contended the agent proceeds to decision diamond where it determines whether the peer module s address which may be peer IP or TDM address is less than the host module s corresponding address. As will be appreciated other arbitration criteria can be used such as module hardware identifier e.g. serial number and some other configurable parameter or setting. When the peer module s address is less than the host module s address the agent in step clears the token grab and returns to step . When the peer module s address is greater than the host module s address the agent in step sets a flag indicating that a token update is required and starts a timer for a token contention period.

In decision diamond the agent determines whether the token contention period has expired. If so the agent concludes that the peer module has obtained ownership of the duplication token and proceeds to step . If not the agent returns to step .

Referring now to the state of health agent and bitmap will now be described. The bitmap is a configurable bit array representing between 5 and 40 critical functional parameters defined such that if a fault were to occur in that functional element the entire module would be unsuitable to provide a set of functions typically its critical functions and between 8 and 64 relative functional parameters defined such that degraded service is possible if that functional element were to be faulted . A parameter is an object associated with a hardware or software state. An example of a critical fault would be removal of the Ethernet link which would prevent the module from making calls. An example of a relative fault is failure of one of the DSPs. Although the call capacity of the module is reduced calls can still be supported by other DSPs. The relative parameters are weighted in fixed groupings between 2 and 8 elements wide permitting equivalency and differentiation between these partial faults. Each parameter in the bitmap has a binary state that is either GOOD or FAULTED.

Each health parameter has between 1 and 32 input state parameter monitors. A monitor is an object that is associated with a health parameter and is used to update the state of the associated parameter. The health parameters and associated monitors are preferably implemented as a library Application Programming Interface and not a task. Relative faults have differing levels of severity from 7 high to 0 low that are used by the agent to determine which module is healthier. For example the DSP fault can be given a higher severity than another fault that indicates that a DSP status query has failed. If these faults occur on two different modules the difference in severity allows the agent to know that the module with the status query failure should be the active module because when compared to the other module s fault it is not as severe.

Health parameters represent a group of related health monitors by OR ing the state of the health monitors to determine the overall state of the health parameter. In other words if any health monitor is in a faulted state the corresponding health parameter is also in a faulted state. This design provides many different monitors to maintain the health of individual faults. At the same time the design groups the diverse inputs into classes or parameters that quickly identify the type of fault that has occurred.

The parameter monitors are modeled to represent three types of hardware switches namely Normally Open Normally Closed and Toggle . These represent three types of action. Normally open switches also known as heartbeat monitors must be constantly activated to remain in a contact closure state. This type of construct is suitable for a heartbeat function. In one configuration the heartbeat monitor is in the FAULTED state by default and normal operational software must be used to keep the monitor in the GOOD state. This type of monitor is used to ensure that management of critical hardware is occurring. Normally closed switches also known as fault monitors are in a contact closure state unless activated and must be constantly activated to maintain an open state. This construct is suitable for time decay functions like damper events. In one configuration the fault monitor is in the GOOD state by default. If a test passes nothing need be done. If the test fails a fault monitor can be placed in the FAULTED state. As long as the test continues to fail the monitor will stay in the FAULTED state. When the error condition has cleared and the test passes the fault monitor will automatically return to the GOOD state. Toggle switches also known as edge monitors are simple on off constructs and are the most common switch type. In one configuration edge monitors record the state of a monitor as GOOD or FAULTED. Edge monitors are used to manage health status indications that are always in a GOOD or FAULTED state and require no further verification or additional analysis. One example is an Ethernet link or LAPD link that is either up GOOD or down FAULTED . In addition to type behavior each monitor has a debounce period which is the inter event timeout for opened or closed monitors and the delay between any edge and the propagation of the transition into the monitor state for toggle monitors.

The 32 parameter monitors have a flat relationship to the parameters that is all monitors of a parameter must be GOOD for the parameter to be good. This permits a variety of independent monitoring activity for each parameter. For example a temperature control parameter may have a clocking monitor to ensure valid readings are available and it may have a limit monitor to ensure the actual temperature in the operational range. Furthermore the same event may have multiple parameters with different debounce periods so that a temperature clocking fault may be relative until some later time when it becomes critical. With 32 monitors per parameter the system supports between 160 and 1280 critical fault events and between 256 and 2048 relative fault events.

By inverting the natural on 1 off 0 of the parameter and monitor bits evaluation of the aggregated state of all monitors and parameters is done by arithmetically summing the words of the bitfields into a single 32 bit representation. It is evident that with negative logic a minimum value is required to establish suitability of the module for operation and that an arithmetic comparison of each device relative to another indicates the best or worst device of a set with higher numbers representing better state. Additionally the inversion permits new monitors and parameters for existing systems because until it is represented it cannot be faulted which is the basis of the evaluation.

The state of health mechanism provides an active bias value that can be used to modify the effect that a relative parameter has on the decision to interchange the module states. Each relative parameter has a weight value that is equal to a power of two based on the priority level of the parameter. For example a level two parameter has a weight of two squared or four. The sum of the faulted relative parameters weights must be greater than the active bias value to affect the decision to interchange. For example an active bias value set to 31 would require a relative health parameter to be a level five or greater to have an instant impact on the interchange decision. Any relative parameters lower than level five need to summed with other relative parameters to exceed this value and cause an interchange.

Application of the fault monitoring system requires definition of the parameters and associated monitors which are then updated in real time on the running system. The output of the evaluation engine is then fed into a management function that may be used to drive an interchange or alarm. The evaluation engine and management functions are both part of the state of health agent. This system is simple efficient and extensible.

To prevent unnecessary module state interchanges from occurring when the same fault occurs almost simultaneously on the active and standby modules a delay may be selectively applied before recording the fault on the active module. This delay allows the fault to be recorded on the standby module first and then the active. Thus when the agent compares the states of health of the two modules it will always see the standby module as the less healthy of the two modules and do nothing. The length of the delay depends on how far apart the simultaneous fault can be detected by both modules. When the fault is cleared the process is reversed that is the fault is cleared on the active module first and then on the standby module.

The bit array of one configuration is shown in . Each parameter name column represents a different word of memory. The array includes sets of critical and relative parameters.

Critical parameters are task monitor refers to a set of monitors that are responsible for verifying the health and normal processing flow of the host processor e.g. task sanity faults task deleted fault task exception fault task suspended fault and task panic fault critical link refers to a set of monitors that detect a fault with one or more selected critical links that may be localized to the module no DSP refers to a set of monitors that determine when all DSP parameters are in the FAULTED state board Out Of Service or OOS refers to a set of monitors that determine when the module is out of service hardware refers to a set of monitors that identify failures indicative of a problem detected by hardware devices and reported in various hardware registers e.g. core sanity faults Phase Locked Loop faults and clock faults aggregator communication refers to a set of monitors detecting a failure when packets are transmitted to or received by the aggregator and firmware resource refers to a set of monitors that identify an unexpected runtime failure e.g. message buffer pool faults network buffer faults message queue faults and duplication token fault .

Relative parameters are relative link refers to a set of monitors that detect a fault with one or more selected non critical links first DSP refers to a set of monitors that identify a fault of the first DSP e.g. a core fault DSP reset fault and DSP out of service fault second DSP refers to a set of monitors that identify a fault of the second DSP e.g. a core fault DSP reset fault and DSP out of service fault third DSP refers to a set of monitors that identify a fault of the third DSP e.g. a core fault DSP reset fault and DSP out of service fault fourth DSP refers to a set of monitors that identify a fault of the fourth DSP e.g. a core fault DSP reset fault and DSP out of service fault software state of health refers to a set of monitors that indicate a fault condition when an alarm is raised against the module denial of service attack refers to a set of monitors that detect an attack on the module e.g. an attack on the real interface can affect service because certain types of packets are sent over the interface IP conflict refers to a set of monitors that detect a conflict for the IP address for the real interface and network configuration refers to a set of monitors that identify when specified types of control messages fail e.g. a request to update valid network configuration parameters .

In step the agent in the selected module collects the states of selected health parameters from various associated monitors and populates the bit array.

In optional decision diamond the agent determines whether the bit array has changed since the last notification to the other module. If so the agent in step sends a representation of the bit array to the agent of the other module. In one configuration the values of the integer values of the 4 words or 32 bit memory words are sent to the other module. The transmission is preferably made over the private link . If that link is down the transmission is made over the LAN . In one configuration step is performed whether or not the bit array has changed. If the bit array has not changed or after performing step the agent in decision diamond determines whether a state transition is required. This determination is performed by a two tiered query. First is the selected module s cumulative health state value and greater or less than the peer module s cumulative health state value and second whether the two modules respective cumulative health state values are at least a minimum threshold value.

To perform the first query the agent compares the bit array of the selected module with the bit array of the other module and determines whether the selected module is healthier. In one configuration if the selected module is already the active module it increases the sum of its weighted parameters by a selected value to bias the comparison in its favor. In one configuration this comparison is only made if either the bit array of the other module has been updated and or a local transition of a parameter has been detected. To perform the second query the agent determines whether a critical parameter is FAULTED. In one configuration the sum of the representative integers or words must have a minimum value represented by each of the critical parameters being set or GOOD. That minimum value represents a module that is healthy enough to be the active module. Above this health threshold the relative health is determined by the sum of the relative parameters. When a critical parameter is FAULTED the agent generates and sends a fault notification to an appropriate address. If the selected module is healthier and both modules have at least a minimum state of health the selected module if not already the active module sets its state to active and assumes control of the TDM bus. If the active module is incapable of disabling TDM access due to the nature of the fault it executes a self reset and the other module detects the reset within a short time typically 200 milliseconds. If the other module is the active module and is deemed to be not as healthy as the selected module or if a health update is not received from the active module with a selected time the selected module requests the active module to relinquish the TDM bus and the duplication token. If no reply is received within a configurable time the selected module transmits a reset command over one of the links and causes the reset agent of the other module to reset the module to force release of the duplication token. The reset agent is typically implemented in hardware to maximize the probability of correct operation in a faulting system.

After performing either step or the agent proceeds to decision diamond and determines whether a message with a timeout has been received. In particular a message will cause the processing loop to execute before time has expired. In one configuration the time interval is 125 milliseconds. If the message has been received the agent returns to and repeats decision diamond .

The methodology for transitioning between the active and standby states will now be described with reference to . is the logic for the host module transitioning from the active to passive state and is the logic for the host module transitioning from the passive to the standby state.

In the methodology the arbitrate state is the state used to determine whether the host module can become the active module or enter into the active state in a duplicated system. In the arbitrate state the host module ensures that its peer connection is configured and starts trying to exchange peer health and status messages. In the arbitrate state the state of health agent also needs to obtain and maintain local health status to exchange the status with the peer module and evaluate the host module s suitability to be the active board. The host module remains in the arbitrate state long enough to ensure that it has enough information to make a decision about its suitability to be the active module and that it has exclusive ownership of the duplication token. The hardware token has a relatively slow update cycle typically greater than 50 milliseconds and the update cycles are not synchronized between modules. To ensure exclusive ownership requires waiting at least two update cycle times.

For example with respect to assume that a first module with the higher address has apparently acquired the duplication token without contention from the second module. If the second module now enters the arbitrate state it will expect in decision diamond that the first module in step will clear its token grab and relinquish ownership of the duplication token. The first module however will have already proceeded to the active state and will not relinquish the duplication token. After several contention periods have expired the second module as a result of decision diamond will yield the duplication token and proceed to the standby state.

Preferably a duplication token is not asserted with every timing signal from the tick function due to high processing overhead. Typically a tick occurs every five milliseconds and a duplication token is asserted every 200 milliseconds or about every 40 ticks . This limits the controlled health timeout to second even when the embedded software encounters an exception and is present but not participating.

Referring now to the process task loop stimulus in step is the receipt from the higher process control software of a mode status or interchange message in the message queue or a timeout. As can be seen from step the agent has reached the active state and is no longer acting upon token contention. Transition from the active state is initiated by either an interchange command an abdicate request issued by the peer module or through notification from the state of health agent that the health comparison indicates a failover is desired. An abdicate request is a request to the standby module from the active module to transition to the active state for a specified reason including a failed health check by the active module. When the stimulus occurs the agent proceeds to decision diamond .

In decision diamond the agent determines whether the host module is in the locked state or a damper timer is set. Upon entry into the active state the agent sets a damper timer to prevent rapid oscillation between the modules. When the host module is in the locked state or the damper timer is not yet expired the agent returns to step .

When the host module is not in the locked state and the damper timer has expired the agent in decision diamond determines whether a transition engine which is a part of the agent s logic is active. The transition engine sequences through the steps required to accomplish an abdication. These steps include for example taking the host module off of the TDM backplane or all of the talk channels and causing the host module to cease signaling using the virtual address and commence signaling using the module s local address. These steps are discussed with reference to steps and below. When the transition engine is unable to ensure that abdication is successful such as due to a failed interface or corrupt driver the engine will drive a module reset to disable traffic flow. When the reset occurs the duplication token will be released by the reset module and the peer module will become active. When the transition engine is active the agent proceeds to step and enables the transition engine.

In decision diamond the agent determines whether the transition period has expired. As noted any state transition must be completed within a selected period of time or transition period. This prevents the agent from hanging while waiting for a component to respond to a command or request. When the transition has expired without completion of the transition the agent causes the module to reset itself. When the transition has not yet expired the agent in steps and configures the local process controller to be on standby and requests the local controller to disable the host module s use of the virtual TDM and LAN interface.

In decision diamond the agent determines whether the TDM and LAN interfaces are disabled for duplication. If so the agent in step requests a flush packet to be sent to clear the buffers of any messages that are addressed to the now disabled TDM or LAN interface. The flush packet is sourced to the corresponding interface address in a loopback mode. When the packet returns to the host module the agent confirms that every packet addressed to the virtual address is no longer capable of being sent.

In decision diamond the agent determines whether the loopback has been completed. If so the agent in step clears the token grab and sends an abdicated notification to the peer module.

After step or when loopback has not been completed in decision diamond the agent proceeds to decision diamond discussed below .

Returning to decision diamond when the transition engine is not active the agent in decision diamond determines whether the reason for the state transition is a result of a command from the higher level control software an abdicate request from the peer module or a failed state of health check. When the reason for the state transition is one of the foregoing the agent proceeds to step and commands the local controller to go from active to base mode disable the virtual interface of the host module and then go to standby.

When the reason for the state transition is not one of the options in decision diamond the agent in decision diamond determines whether the host module is in simplex mode. If so the agent proceeds to step . If not the agent proceeds to decision diamond .

In decision diamond the agent determines whether the duplication token is clear or the host module does not currently own the token. If the duplication token is clear the agent returns to step . If the duplication token is not clear the agent in decision diamond determines whether the token grab is clear. If so the agent proceeds to the arbitrate state. If not the agent performs a self reset of the host module.

Turning now to the stimulus in step is the same as that in step . The agent processes mode status and interchange commands. The typical reason for the passive module transitioning to the active state is one or more of a command from the higher level control software a failed health check by the peer module or an abdicated notification from the peer module.

When a stimulus occurs the agent performs decision diamond . In decision diamond the agent determines whether the reason for the transition is a demand from the higher level software or a failed health check by the peer module. When the reason is a demand or failed health check the agent in decision diamond determines whether an abdicate timer is active. If not the agent in step sends an abdicate request to the peer module and starts the timer.

Returning to decision diamond when the reason is a demand or failed health check the agent performs decision diamond . When the host module is in simplex mode the agent proceeds to step and performs the same set of functions as in step above. The agent then proceeds to the arbitrate state.

When the abdicate timer is active decision diamond or the host module is not in the duplex mode decision diamond the agent in decision diamond determines whether an abdicated notification has been received. If so the agent in step sets the token grab and in step sets the virtual interface of the host module to active sets the local controller to active and sends an active notification to the higher level software. The agent then goes to the active state.

Returning to decision diamond when an abdicate notification has not been received from the peer module the agent in decision diamond determines whether the duplication token is free. When the token is free the agent in step sets the token grab and returns to step .

When the token is not free the agent in decision diamond determines whether the host module has acquired the soft token. As will be appreciated when a first module owns the token and fails to refresh the token by asserting the token at the proper time the first module resets itself automatically due to the hardware watchdog functionality whereby the module is reset automatically if the software fails to perform a specified operation within a specified time of a given tick and as long as the first module has not been reset and the tick function is operating properly the token is maintained by that module.

When the token has not been acquired by the host module the agent in decision diamond determines whether both modules are asserting the duplication token meaning that the modules are in contention. If so the agent proceeds to the arbitrate state. If not the agent proceeds to decision diamond and determines whether the abdicate timer has expired. When the timer has expired the agent in step causes the peer module to be reset. After step or when the abdicate timer has not yet expired the agent returns to step .

The operation of the packet sequence synchronization agent will now be discussed. Prior to discussing the agent s operation it is important to understand the importance of packet sequence synchronization during module transitions. As used herein packet sequence synchronization refers to continual or periodic updates of packet sequence numbers on either or both of the transmit and receive channels. As will be appreciated the packet sequence number in RTP is a 16 bit value capable of representing a number between 0 and 65 535. The number increases in time based on the size of the RTP frame designated in the codec used to set up the call. When the RTP sequence number reaches its limit of 65 535 it resets to zero and increments the sequence number rollover counter maintained independently by both the sender and receiver of the packet flow.

When the standby module becomes the active module it must assume seamlessly the encryption functions of the formerly active module. Thus the newly active module needs the decryption and encryption keys of the formerly active module which requires the newly active module to know approximately the packet sequence numbers in the transmit and receive packet streams for each communication session. As will be appreciated the roll over counter is used in the key. An error in packet sequence number synchronization can cause encryption and decryption errors.

Additionally it is important that the newly active module not repeat previously used sequence numbers after assuming the active role. Although a jump forward in packet sequence numbers is handled during normal operation provided that the jump forward does not exceed a definable value a jump backward causes frames to be dropped until the flow reaches the currently expected sequence number. If the jump forward exceeds the definable value packets may be discounted as out of order packets and discarded.

In the absence of silence suppression the active and standby modules sequence numbers should be relatively close to one another. Calls to IP endpoints are normally set up on both modules concurrently. The agent on the modules knows that the call is a duplicated call and whether or not the host module is in the active or standby state must track call state information for any states that are kept on the module and not reported to the server and keep the call state synchronized between the modules. In this configuration the active module processes inbound RTP packets into PCM data for the TDM backplane and PCM data from the TDM backplane into RTP packets. The standby module does not accept packets from the packet switched network on the virtual interface and sends no packets to the packet switched network on the virtual interface. The standby module continues to listen to the TDM bus and processes packets to the aggregator which will drop the packets for the virtual interface. While the standby module is not processing inbound packets and therefore has no knowledge of the inbound or receive packet sequence number on the active module both modules increment the outbound or transmit packet sequence number. The talk channels of the standby module are disabled on the TDM side. In the event of a failure or in response to a command the active module stops issuing RTP packets on the virtual interface and disables PCM flows to the TDM backplane. The standby module then activates the same MAC and IP addresses used by the formerly active module and begins issuing RTP packets generated from the same backplane TDM time slots used on the formerly active module. When the packet switched network sees the RTP packets sourced from the newly active module the network will relearn the MAC address and automatically begin to forward the far end RTP packets to the newly active module.

The gap in sequence number value between the active and standby modules will vary in time differently for the receive and transmit packet flows. The receive sequence number on the standby module is synchronized with the active module at the time the active module sends its current receive sequence number and from that point the gap between the receive sequence number of the active and standby modules increases at a rate defined by the codec frame size with the active module moving forward in time. The synchronization period for the receive sequence number is preferably short enough to ensure correct handling of the sequence number boundary condition e.g. the roll over counter value in the event of a fail over to the standby board. The standby module s sequence number will normally be behind the active module s number due to the delay between processing the packet and propagating the information to the standby module. This natural drift ensures that the standby module can always assume a jump forward to the sequence number of the first packet it receives if it becomes active as long as the gap does not become excessive . The transmit packet sequence number on the standby module needs to be synchronized with the initial value on the active module plus a shift value to ensure that in the event of a failover the packets seen at the remote endpoint represent a jump forward in sequence number. This jump is preferably small enough to ensure correct handling of the sequence number boundary but large enough to cause the receiver to flush its buffers and immediately re acquire the flow. In selecting the shift value drift between the transmit sequence numbers on the active and standby modules must be accounted for. In the absence of silence suppression both modules should track with a constant shift between the active and standby modules. When silence suppression is enabled the lack of inbound RTP data can cause a difference in outbound packet generation if the echo cancellation algorithm removes background signal on the active but not the standby module. As a result the transmit packet sequence number of the standby module will drift ahead of its counterpart on the active module causing the shift value to be a negative number.

Referring to the operation commences when a first trigger event occurs. The first trigger event can be one or more of the passage of a selected period of time e.g. every 100 to 200 milliseconds the establishment of a call on the active module validation by the active module of data associated with an established call and on demand. In step the agent in the active module will collect reliability data associated with the call and propagate the reliability data to the standby module. The reliability data can include the codec frame size defined for the call the current transmit and receive packet sequence numbers for the call endpoint identifier of the source endpoint timestamp resolution defined for the call shift value which may be time based or a packet sequence number and or the rollover counter value. In decision diamond the agent on the standby module looks for a channel with the endpoint identifier. If no channel is associated with the endpoint identifier the agent discards the data in step . If the channel is located the agent in decision diamond next determines whether the identified channel has been set up completely e.g. open on the VoIP subsystem . If the channel has not been set up completely the data is discarded in step . If the channel has been set up completely the agent records the reliability information in its local channel structure associated with the identified channel adjusts the packet transmit sequence number and timestamp by the shift value and sends it to the VoIP subsystem in a reliability information change request. The agent in the standby module commonly converts the time based shift value received from the active module into a transmit sequence number value and timestamp by converting the shift time into a sequence number using the codec frame size defined for the call and converting the shift time to the timestamp resolution defined for the call. The active module must then send new update information at a frequency that ensures that the gap between the transmit sequence numbers on the active and standby modules does not widen beyond an acceptable limit. In one configuration these computations are performed by the agent of the active module and the results are provided by the reliability information update to the agent of the standby module.

Referring now to a second trigger event commences the operation. The second trigger event can be one or more of the passage of a selected period of time e.g. every 100 to 200 milliseconds the establishment of a call on the standby module and validation by the standby module of data associated with an established call. In step the agent of the standby module sends a sync request to the active module for the channel with the endpoint identifier. The sync request includes the endpoint identifier associated with the call. In response the agent in the active module looks for a channel with the referenced endpoint identifier. In decision diamond the agent on the active module determines whether a channel with the endpoint identifier exists. If no channel is associated with the endpoint identifier the agent discards the request in step . If the channel is located the agent in decision diamond next determines whether there is valid reliability data saved in the local corresponding channel structure. If not the agent proceeds to step . If so the agent in step collects reliability data associated with the call and adjusts the transmit sequence number and timestamp based on the difference between the timestamp of the data and the time of the request. It then generates the reliability information update for the adjusted channel and in step forwards the update to the standby module. Upon receipt and validation the standby module in step updates its local channel structure associated with the call.

The receive sequence number is updated using a time based approach in which the active module periodically forwards a reliability information update to the standby module containing the endpoint identifier and current packet sequence number value.

When the standby module takes over the RTP packet streams the formerly active and standby modules calculate the same starting SSRC using the endpoint identifier and UDP port.

Whenever an interchange occurs all channels on the newly standby module are closed and reopened with a refresh from the server. If this unrefresh refresh operation is omitted the newly standby module would be required to perform a self resynchronization by going through each active channel and calculating new transmit sequence number and timestamp values for each channel by applying both the difference between the current time and the time of the last locally recorded information event plus the standby shift value.

A number of variations and modifications of the invention can be used. It would be possible to provide for some features of the invention without providing others.

For example in one alternative embodiment dedicated hardware implementations including but not limited to Application Specific Integrated Circuits or ASICs programmable logic arrays and other hardware devices can likewise be constructed to implement the methods described herein. Furthermore alternative software implementations including but not limited to distributed processing or component object distributed processing parallel processing or virtual machine processing can also be constructed to implement the methods described herein.

It should also be stated that the software implementations of the present invention are optionally stored on a tangible storage medium such as a magnetic medium like a disk or tape a magneto optical or optical medium like a disk or a solid state medium like a memory card or other package that houses one or more read only non volatile memories. A digital file attachment to e mail or other self contained information archive or set of archives is considered a distribution medium equivalent to a tangible storage medium. Accordingly the invention is considered to include a tangible storage medium or distribution medium and prior art recognized equivalents and successor media in which the software implementations of the present invention are stored.

Although the present invention describes components and functions implemented in the embodiments with reference to particular standards and protocols the invention is not limited to such standards and protocols. Other similar standards and protocols not mentioned herein are in existence and are considered to be included in the present invention. Moreover the standards and protocols mentioned herein and other similar standards and protocols not mentioned herein are periodically superseded by faster or more effective equivalents having essentially the same functions. Such replacement standards and protocols having the same functions are considered equivalents included in the present invention.

The present invention in various embodiments includes components methods processes systems and or apparatus substantially as depicted and described herein including various embodiments subcombinations and subsets thereof. Those of skill in the art will understand how to make and use the present invention after understanding the present disclosure. The present invention in various embodiments includes providing devices and processes in the absence of items not depicted and or described herein or in various embodiments hereof including in the absence of such items as may have been used in previous devices or processes e.g. for improving performance achieving ease and or reducing cost of implementation.

The foregoing discussion of the invention has been presented for purposes of illustration and description. The foregoing is not intended to limit the invention to the form or forms disclosed herein. In the foregoing Detailed Description for example various features of the invention are grouped together in one or more embodiments for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed invention requires more features than are expressly recited in each claim. Rather as the following claims reflect inventive aspects lie in less than all features of a single foregoing disclosed embodiment. Thus the following claims are hereby incorporated into this Detailed Description with each claim standing on its own as a separate preferred embodiment of the invention.

Moreover though the description of the invention has included description of one or more embodiments and certain variations and modifications other variations and modifications are within the scope of the invention e.g. as may be within the skill and knowledge of those in the art after understanding the present disclosure. It is intended to obtain rights which include alternative embodiments to the extent permitted including alternate interchangeable and or equivalent structures functions ranges or steps to those claimed whether or not such alternate interchangeable and or equivalent structures functions ranges or steps are disclosed herein and without intending to publicly dedicate any patentable subject matter.

