---

title: Visual designer for telephony applications
abstract: An application server system is provided having a core engine connecting one or more protocol providers to one or more applications. In a preferred embodiment, the one or more applications run on a respective one or more virtual machines having their own execution threads. A thread pool may be used to spawn instances of applications or scripts. Preferably, the core engine, the protocol providers, and each of the one or more virtual machines run in separate AppDomains. In another embodiment, a visual designer is provided preferably having XML conversion capability and interactive debug capability.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08687789&OS=08687789&RS=08687789
owner: Cisco Technology, Inc.
number: 08687789
owner_city: San Jose
owner_country: US
publication_date: 20060608
---
The present application is a continuation of U.S. patent application Ser. No. 10 999 888 filed Nov. 30 2004 now U.S. Pat. No. 7 593 980. U.S. patent application Ser. No. 10 999 888 is incorporated by reference.

The present invention relates to platforms for developing or hosting telecommunications applications of various types.

There are a variety of computer platforms that host telephony applications. Such applications include voice mail messaging and multi party calls and many others. IP telephony internet protocol telephony applications introduce the telephone as a node on the IP network. In addition to point to point calling telephones can serve as the origin or destination of a variety of network services. Further telephones are no longer limited to voice communications or touch tone menus. Modern IP phones sport rich interfaces with interactive touch screen color displays.

There is however a limited selection of applications available for use on such phones. Such lack of applications stems partly from the expensive architectural upgrades Installing a new feature such as voice mail meant purchasing expensive new hardware for each circuit.

As a consequence telephony applications appeared first at the edges of the network in small offices or remote communities. Such proliferation helped catapult the rise of the PBX or Private Branch eXchange as the internal telephony interconnect within a building or organization.

A PBX originally served two purposes. First it permitted a large number of end users to share access to a small number of outbound lines. Second it connected internal users without having to make a complete circuit to the telephone company and back. As the PBX became more powerful and commonplace it began to include additional services such as call forwarding and voice mail. The increasing number of PBX vendors helped drive costs down but also resulted in each vendor utilizing proprietary systems for application development making application development for widespread use prohibitively expensive.

Two principal issues plague application development for PBX systems. First there is the lack of standards in programming language development environment and signaling protocols. Communication with PBX hardware often involves closed proprietary signaling protocols. Second most PBX systems have extensibility and scalability problems.

In the 1980 s and 1990 s the industry worked to resolve this issue with the development of a standard for telephony application development TAPI the Telephony Application Programming Interface. TAPI and its successor JTAPI Java TAPI are difficult to use since they required developers to have a deep understanding of the telephony switching to perform even the most basic functionality. Consequently many developers and IT organizations avoided the standard and continued to invest in vendor specific PBX systems.

The gradual adoption of Voice over Internet Protocol VoIP technologies in recent years helps reduce networking costs and potentially bridge voice and data networks. Modern VoIP PBX systems can communicate with IP telephones using the same data network shared by computers. However such VoIP PBX systems continue to lack sufficient programmability flexibility and scalability. Further modern VoIP protocols add to the number of protocols that application developers need to employ to be widely compatible.

What is needed therefore is a telephony application platform that enables communication over a variety of protocols with a scalable application server. What is also needed is an application development environment that enables easy development across multiple protocols for the same application platform.

An application server system is provided having a core engine connecting one or more protocol providers to one or more applications. In a preferred embodiment the one or more applications run on a respective one or more virtual machines having their own execution threads. A thread pool may be used to spawn instances of applications or scripts. Preferably the core engine the protocol providers and each of the one or more virtual machines run in separate AppDomains.

In another embodiment a visual designer is provided having a design canvas for visually building applications. The visual designer converts the applications into XML versions for installation on an application server. An assembler process is provided for to assemble and install the application. A preferred embodiment has a debug interface to the application server is provided

Applications designed for MCE reside within an application pool or script pool in application server . The platform provides automatic management of application state handles side by side existence of varying application versions supports seamless installation of new applications and trouble free un installation of any application not currently in use.

The software based media server provides the full functionality of hardware based media servers but with a pure software implementation. Inherent in this software only design is the ability to automatically keep pace with inevitable advancements in processor speed and capabilities. Further the design provides interoperability with standard telephony and networking protocols such as RTP real time transport protocol as well as scalability and redundancy through multiple media server installations on parallel servers.

In this embodiment each media server installation supports up to 120 simultaneous connections which equates to dozens of simultaneous user sessions spread across various applications. In this embodiment as many as eight media servers may be paired with one application server . Such scalability provides ability to handle additional service levels by simply adding additional media servers .

Preferably media server includes a variety of powerful features to enable complex telephony applications including support for media streaming DTMF dual tone multi frequency interpretation multi party conferencing and recording. Other features may be included in media server such as for example text to speech speech recognition and Voice XML extensible markup language support. Media server will be further described with regard to later referenced .

In this embodiment MCE simplifies the process of developing and deploying applications through use of visual designer . Developing an application with visual designer preferably does not involve paging through extensive lines of program code and preferably does not require a deep understanding of call control or media processing. Instead visual designer presents a graphical user interface canvas where application components may be created and interconnected using a mouse or other pointing device. Finished applications can be deployed to MCE via a menu selection or uploaded using the system control panel as further described with regard to later referenced Figures.

Applications may communicate with telephony interfaces including voice over IP and other communications interfaces via protocol provider modules . Such interfaces or modules may be third party systems. Protocol provider modules may interface over various protocols such as for example an H.323 provider for first party call control a TAPI telephony applications protocol interface provider for third party call control an HTTP provider for network communication a Timer provider for creating event driven delays a Cisco DeviceListX provider for caching CallManager device information and finally a Media server provider for communication with media server .

Microsoft Exchange Integration Provide alerts when meeting events occur by ringing users on their mobile phones.

Instant Messaging and Collaboration Integration Start collaborative conference calls from instant messaging sessions.

Conferencing Employ media server to support instant recordable conferencing with participant mute and kick.

Click To Talk Extend a desktop PIM personal information manager client such as Microsoft Outlook with a protocol provider to enable one click calling between parties in the PIM s address book.

Location Based Forwarding Integrate with enterprise IT authentication system to automatically forward incoming calls to a user s home phone mobile phone desk phone or forward based on a user s presumed location from the system login trail.

Referring still to in this embodiment system control panel permits administrators to manage the configuration of MCE install and remove applications and provider modules and control other aspects of operation.

Application server handles communication between components processes user input controls the media servers and provides interfaces for the system control panel and visual designer . The primary functional units of application server are preferably grouped into subcomponents. In this embodiment such subcomponents include script pool assembler OAM operations and maintenance module provider framework virtual machine and core engine . Each element communicates with other components through a messaging infrastructure controlled by the core engine . Such interconnection is depicted with arrows drawn between each component and the Core engine .

Applications within MCE interact with the outside world through protocol providers providers . Providers offer a family of services typically associated with a communication protocol. Providers may open network ports and allow the Application Server to communicate with numerous other devices on a network. For example the HTTP provider enables applications to accept incoming web traffic and respond accordingly or make HTTP requests to other hosts elsewhere on the network.

Providers preferably execute within their own virtual process space and facilitate communication between application server and external systems. Preferably providers are the sole means in which applications may execute asynchronous operations and are the only sources for unsolicited events. Such events will be further described referring to later Figures. Typically a protocol provider utilizes an underlying protocol stack and then implements an API layer to translate the action and events flowing to and from Application Server s core engine so they conform to a defined interface.

In this embodiment providers have two primary functions. First they must respond to actions received from applications executing within application server . Secondly they handle data received from external services and generate events to be handled by applications within application server .

Provider framework is preferably a well defined API application protocol interface that enables third party developers to build extensions to MCE . By implementing the interfaces defined within provider framework developers may extend Metreos Communications Environment to external systems or protocols.

In this embodiment OAM module handles communication with system control panel and visual designer . Using OAM component MCE exposes a management API that may be employed to integrate third party network management tools.

In this embodiment assembler working in conjunction with the core engine prepares new applications for use by application server by distributing application components across MCE . This includes separating out scripts databases media resources and the installer from each new application and performing initial tests for correctness and resolving any versioning issues. Scripts databases and media resources will be further described with reference to later Figures. Preferably once an application has been extracted and tested for data integrity assembler takes each script contained within the application and transforms the XML intermediate language into instructions executable by virtual machine . During this step the assembler checks the syntax of the intermediate language to ensure the script is well formed. Assembler then signals the core engine that application is valid. Core engine then prepares any application databases. If an application installer is present it is executed setting up any configuration parameters for application and setting default values as provided by the developer. Also core engine negotiates procurement and provisioning of any media resources so applications which need to play audio through Media servers will have assured access to these files. Finally assembler passes on scripts associated with application to script pool .

Preferably application scripts reside within script pool fully prepared for execution. Script pool is notified by the core engine when it is time to start executing a particular script . Core engine makes this determination by comparing incoming events from protocol providers with triggering criteria defined for the installed scripts . Once core engine informs script pool that an event has come in for a particular script script pool passes a copy of the script to virtual machine . Such a copy is called a script instance.

In this embodiment virtual machine manages the running code of any active applications . In a preferred embodiment multiple instances of virtual machine are employed . Within the constraints of system resources any number of scripts each with any number of script instances may be executed simultaneously. Such capability ensures that multiple applications may run in parallel and that multiple users may be accessing any one application at the same time. Virtual machines also ensure system stability by segmenting applications from one another. This segmentation mechanism helps ensure that an unstable application cannot adversely affect other applications. Preferably once virtual machine determines that an application is in an unstable state the application is unloaded and will not trigger again until the problem is resolved and the application is reinstalled. Other error control mechanisms may be used. For example an unstable application may be terminated but other instances allowed to run. An application error log may be used to alert administrators of applications that exhibit excessive instability.

In this embodiment all communication between components as well as subcomponent control and resource management occurs within core engine . In addition core engine preferably manages other application components.

In this embodiment application server is built with Microsoft s .NET development platform. The dotted lines represent AppDomain boundaries in a preferred architecture. An AppDomain is a capability of the .NET platform which enables creation of a virtual process boundary and then communicate across it. Other architectures may be used. For example another preferred embodiment uses a similar application domain boundary capability of Java. Preferably such architecture ensures that if a component within an AppDomain crashes the rest of the system remains stable. In this embodiment the AppDomain boundaries are placed such that they isolate core engine from the protocol providers and applications .

In this embodiment core engine has provider manager which is preferably a sub component of Action Event Router . Provider manager is responsible for instantiating and managing protocol providers . Preferably application server is not limited to a particular number of protocol providers . Core engine is typically not aware of what protocol providers will be loaded. Instead when the Application Server starts provider manager searches the providers directory for assemblies preferably dynamic linked libraries DLLs which conform to a well defined protocol provider API. When provider manager finds a suitable assembly it loads the assembly. Likewise protocol providers may be loaded or unloaded at any time via the system control panel .

Preferably provider manager is also responsible for distributing actions to the proper provider by way of namespaces. For example a provider may start up and register the namespace Metreos.Providers.H323 as its namespace. When the provider manager receives the action Metreos.Providers.H323. MakeCall it is programmed to send the action to the provider registered with the Metreos.Providers.H323 namespace.

Core engine and applications are not typically aware of any specific protocol provider API ahead of time. Protocol providers preferably use attributes to describe the actions and events they can handle to applications through core engine . Preferably users are provided with a tool which inspects provider assemblies and generates an XML file for each provider which describes the provider s API based on the attributes in the code in the provider s assembly. Visual designer then reads the XML file and generates icons for the actions and events described therein. Visual designer will be further described with reference to later Figures.

Provider manager also handles some basic system housekeeping such as pinging providers to see if they have crashed and if so restarting them automatically.

Referring still to core engine has action event router . event router router . Applications specify to core engine a set of criteria on which they are configured to trigger. Applications preferably must trigger on an event. After an application triggers router must retain state information for all instances of such application so it can route all subsequent events properly until the instance terminates.

In order for router to start and interact with applications applications must register their triggering criteria. Such registration is preferably done when application is installed or application server is started. Router preferably keeps track of the triggering criteria in a table. Such a table preferably lists parameter values or ranges matched with certain event types and applications.

For example the best match for the incoming event in is App because it has more matching parameters than App and App has a mismatched parameter. In this exemplar if App did not exist App would be triggered since it would have the most matching parameters without any mismatches. Other application triggering algorithms may be used.

In this example router does not yet recognize the Routing GUID so it matches the event to an application based on the criteria specified in its routing tables . Router then forwards the event to the virtual machine where the selected application resides. The selected virtual machine virtual machine application runtime application runtime environment then creates a new instance of the script seeds it with the incoming event information and begins executing it. Virtual machine application runtime will be further discussed below.

At some point in script s execution it decides to send an action to the HTTP provider . Preferably the application is not limited to using only the provider which triggered it. Since the action is routed based on namespace the application may issue actions to any and all providers it wishes. In this example application sends an action to HTTP provider . Provider manager matches the namespace and forwards the action. Typically a provider is obligated to send a response to any received actions. In this case provider sends Success .

As another exemplar if provider were to send some other event which needed to go to this script instance it would reuse the same Routing GUID. In preferred embodiments when router receives an event with a Routing GUID it has seen before it forwards the event on to the corresponding script instance previously associated with the GUID.

In this exemplar when script has finished everything it needs to do it terminates itself with an EndScript action. This action signals application runtime to reset all session state associated with this script instance return it to the script pool and send a message to router indicating that the script is no longer running. When router gets the message that script is ended it removes all session related information from its routing tables but it retains the triggering information so it can start new instances of script . Preferably only when the application is uninstalled does router remove the triggering criteria for each of the application s scripts from the routing tables.

Referring again to in this embodiment administrators can configure application partitions which are sets of data associated with a particular application . Once an application is installed a default application partition is created. That partition contains the triggering information for each script in the application as specified at design time. Preferably an administrator may then change or augment the triggering parameters. The triggering event name however preferably cannot be modified. Further the administrator may specify a call control protocol to use when a script triggered by the criteria in this partition wishes to use call control services. Examples of such protocols are H.323 SCCP CTI JTAPI and SIP. Other protocols may be included if appropriate protocol providers are configured on application server .

Configuration config component is preferably a singleton class not a thread which exposes methods which are called directly by nearly all components in application server . The config class acts as the core engine s gateway to a system config database. The config class is preferably the only component which has access to the config database. Such a scheme helps ensure that all database operations are thread safe atomic and maintain referential integrity.

As an exemplar when a provider loads it may wish to advertise a configuration value that an administrator can use to adjust provider s behavior. In such a case provider by way of a standard base class makes a call to the config class which tells it to add the config item. The config class then updates one or more database tables keep track of database locks and otherwise manage addition of the configuration item.

Referring still to in this embodiment telephony manager is interconnected with more than one virtual machine . Other embodiments may have only one. Telephony manager exposes a common API preferably referred to as the CallControl API for all call control stacks in use with application server . The CallControl API specifies a specific set of actions and events which a provider must be able to handle in order to utilize telephony manager .

As discussed above providers may define their own API which identifies the actions and events they can handle. In this embodiment providers which conform to the CallControl API implicitly declare all the actions and events contained in the CallControl API and thus only explicitly declare any actions or events which are proprietary to that provider . Preferably providers indicate that they wish to participate with the CallControl subsystem using a special flag when they register their namespace at load time. When Provider Manager sees that a provider has elected to participate in the CallControl subsystem it notifies the Telephony Manager so it will know how to handle CallControl actions which are destined for the type of call control protocol specified.

In this embodiment the application runtime is programmed to forward all actions with the namespace Metreos.CallControl to telephony manager . Likewise router forwards all events with the namespace Metreos.CallControl to the telephony manager . Such a namespace represents a generic telephony service and other namespaces and access schemes may be used. When the telephony manager receives an action it looks up what call control protocol is configured for the application partition that sent this action. It then looks to see if a provider has registered as a handler for that protocol. Once the associated provider and its real namespace are identified the telephony manager translates the action name so it will be routed to the configured provider and then sends the action on to Provider Manager .

As an exemplar an action is received by the telephony manager having parameters with values as follows Action Metreos.CallControl.MakeCall AppPartition NewYork To 5124377913 callmanager.mycompany.com. The telephony manager finds that the control protocol configured for the destination application s partition is H.323. A provider registered as Metreos.Providers.H323 claims to handle this protocol. So the telephony manager translates the action to 

Action Metreos.Providers.H323. MakeCall. Telephony manager leaves the rest of the parameters as they were and forwards the action to Provider Manager for routing to the H.323 provider.

The telephony manager preferably has the capability to handle an almost infinite number of possible combinations of actions and events and force them to conform to the common API. To provide such capability this embodiment has a telephony manager implemented as a script engine. Preferably the telephony manager script engine is hard coded with handlers for the well defined finite set of actions which can appear in scripts so no input parameters are necessary. Telephony manager script engine keeps track of all the data it knows about a given call and includes as much relevant information as possible in the actions and events it generates.

In this embodiment a scripting language is provided to for programming telephony manager . Preferably the scripting language provided is a state description language. A high level definition of such scripting language is provided in several following tables. The language described is merely exemplary and other languages containing other syntax or features may be used to implement a telephony manager in other embodiments.

Table 1 contains a list of the valid tags which can be used to start any line in a state description. Table 2 contains a syntax definition for the tags listed in Table 1. Table 3 contains the order in which next state conditions are evaluated by the execution engine. Usage recommendations follow each condition.

Table 4 contains preferred valid values for the data field. The field type follows the name in parenthesis. For uint fields any uint value can be specified after the comparator or . For bool values true or false can be specified. All other values can only be compared to null.

Referring again to in this embodiment application server has an assembler application manager for installing and configuring applications . Assembler will be further described with reference to later Figures.

In this embodiment application server has a management interface . Preferably management interface listens on a socket and accepts TCP connections from system control panel . Control panel uses this interface primarily to notify core engine of changes to the Application Server configuration via XML messages. In a preferred embodiment management interface exposes the following functions 

Referring still to the preferred embodiment depicted in application server has virtual machines . Virtual machine is the component that starts executes terminates and manages application script execution. Virtual machines execute inside a child AppDomain indicated on the diagram as bordered by dotted lines. The diagram shows two copies of virtual machine for exemplar purposes. In a preferred embodiment there are as many virtual machines on an application server as there are applications installed on that application server . When there are no applications installed there are no virtual machines present. There is preferably no set limit to the number of applications and thus virtual machines which may be loaded. Virtual machines will be further described with regard to later referenced Figures especially .

The embodiment in also has a logger component to manage log messages. Preferably logger is closely tied to .NET tracing functions and uses .NET trace listeners to route log messages to various log sinks based on configurable criteria. Another preferred embodiment uses a Java implementation. The log sinks included with the Application Server are preferably as follows 

The list of log writers is preferably extensible. A new logging assembly which implements a well defined log sink interface may be deployed via the system control panel management website. The website places the assembly into a configured directory and the Application Server startup process picks it up via a directory watcher and installs it.

In step development application is created in visual designer development environment. In step build visual designer prepares application for use by converting diagrams into a proprietary XML based intermediate language and then compiled code and additional application data such as media resources an installer and any needed databases are combined into a single archive file. In step deployment the archive file is uploaded to application server either through system control panel or via direct deployment in visual designer . In step installation the archive is unpackaged and resources are allocated to handle all components of the new application . Application scripts are copied into script pool where they wait for events. In step execution application server processes the application generated from the user s initial design.

Each of these five steps occur in different locations throughout the MCE platform. Some steps may involve two or more components.

Referring still to the embodiment depicted as a flow chart in an application preferably begins its existence step in visual designer where the application logic is formed. Visual designer will assist the programmer by applying certain rules automatically to ensure that applications are well formed. For example if a developer drops an action on the canvas which generates callback events visual designer will automatically generate functions for the developer to use when implementing those event handlers. Development in visual designer will be further described referring to later Figures.

Once the developer has completed application or completed enough application components to test some aspect of functionality they instruct visual designer to build or compile application step . Such building converts application s representation as data and logical flow from a visual representation of boxes and arrows to a linear description in an XML based proprietary intermediate language. Functions which lack proper exits un initialized variables or unspecified execution paths will all cause errors to appear during compilation.

In this embodiment after the application is successfully compiled into XML all XML code and other application components are packaged into a single unified archive file. Such a packaging process simplifies transporting applications and related data by rolling everything into a single file including databases media resources installer information the application custom code and related versioning data. In a preferred embodiment the archive files retain the extension .MCA for Metreos Communications Archive. Packaging may be accomplished through visual designer or through a packager command line tool.

Packaging errors can occur when the additional resources such as installers databases custom code and media resources appear malformed or contain conflicting information. While the packager typically cannot catch all possible errors many types of resource problems can become evident during step .

Referring to deployment step packaged archives are preferably installed to the application server either through visual designer or system control panel . Application server receives the archive through OAM component which handles all configuration and administrative communications. OAM component in turn routes the complete package to the assembler which unpacks the contents and routes individual components throughout application server . Assembler prepares a memory map an executable version of application using an assembly process described in more detail later.

The installation or assembly step step unpacks the archive file and prepares its elements for provisioning throughout the system. Any databases in the package arrive in the core engine which determines based on versioning data whether or not existing databases from previous installations will affect this install. Then core engine attempts to create or update the data and schemas defined by the new application . Such a creation process could return database creation errors which result from malformed SQL structured query language or resource allocation problems from overloaded application servers . Preferably installers are routed to core engine and immediately processed. Syntax errors or unsupported installer commands generate errors which are then returned to the user through OAM component .

During installation media resources are preferably likewise passed along to core engine . Core engine in turn contacts the media servers associated with the respective application server . To ensure optimum performance all such media resources are preferably installed on each media server in the particular MCE . In another embodiment media files may be stored on a centralized repository or file server. Core engine may report problems if the media servers lack sufficient resources to store the media files or if the server s are not reachable.

In this embodiment script pool registers each script with core engine in order that appropriate incoming events can initiate script execution. This registration process ends the Installation Phase.

In step each time an event fires whose event signature matches a script s triggering event signature the corresponding script is executed by virtual machine . Any number of instances of the same script may be created within configuration and resource limitations. Each instance maintains separate memory storage and distinct access to resources.

During execution any detected runtime or logic errors are preferably logged in an application server log. When a script instance finishes execution relevant state information is reset and it returns to script pool awaiting the next triggering event. Other embodiments may work with temporary copies of scripts .

In this embodiment each application consists of up to four types of components scripts an installer databases and media resources . The latter three component types are optional and may be included in any combination to meet an individual application s requirements.

Preferably all application logic either occurs within scripts or is directed by scripts . Use of scripts gives programmers the ability to alter execution paths with control structures store data in script wide or function scope variables access external resources and indirectly accept input from users.

An application may have a single installer containing instructions to direct installation. In a preferred embodiment installer is represented as an XML configuration file which preferably is automatically prepared by the visual designer upon request. Application developers may wish to include special instructions to MCE regarding the desired setup and deployment of their services. Such instructions may concern requirements like dependencies on external protocol providers configuration settings and licensing restrictions.

Databases provide applications ability to retain data beyond the execution of an individual script . Applications within MCE may include any number of associated SQL structured query language databases which enable developers to store relational data in application . Information stored within databases persists across any downtime periods or other connectivity issues which can occur making databases particularly useful for storing long term data such as call records access permissions and other general storage items.

MCE preferably has an embedded SQL engine designed for high speed retrieval of data for use in high performance telephony applications. For applications requiring report generation integration with existing databases or other advanced database features MCE may also provide connectivity to remote data stores through an external collection of classes such as ADO.NET activeX data objects classes in addition to using the embedded database engine. Such connectivity is provided in another preferred Java embodiment with the JDBC API Java Database Connectivity .

Media resources contain data regarding media items such as audio prompts. Examples of such media resources are pre recorded greetings error messages and status messages. MCE lets developers bundle any necessary audio prompts with an application easing the deployment process further. Preferably media resources are .vox or .wav files. Any number of files may be included within an application . In a preferred embodiment such files are 8 bit 8 khz to maximize performance.

MCE monitors a variety of events which may arise. Such events include telephone calls HTTP messages and announcement status information among others. When these occurrences manifest within MCE an event is generated. Examples of events include CallControl.IncomingCall and Providers.Http.GotRequest. Any number of events may fire simultaneously and of course a single event may fire in rapid succession. Programs within the MCE typically respond to a small subset of the possible events which may be raised but developers can select any combination of events based on business requirements.

Events originate from protocol providers and reach applications by way of the event distributor or router. Such a router is preferably part of core engine . A preferred embodiment of core engine including a router or event distributor is further described with reference to .

In this embodiment MCE presents three distinct types of events to developers with a fourth hybrid type for technical completeness. The three fundamental event types are triggering events unsolicited events and asynchronous events. Some events may be used as both triggering events and unsolicited events even within the same application. These are called hybrid events. Typically no asynchronous events occur as triggering or unsolicited events.

For each script within applications one particular triggering event starts the script . MCE preferably generates new script instances automatically each time a triggering event occurs. Each script instance preferably operates independently of other scripts so script state and script level variables are automatically preserved. Preferably MCE will not execute an application if it finds more than one application with the same triggering event parameters.

Unsolicited events can occur at any time during script execution. Such events typically indicate an action which was taken by an external user. For example a script which triggers on CallControl.IncomingCall must be prepared to receive the CallControl.Hangup unsolicited event at any time. Script designers may anticipate however multiple unsolicited events of the same type. For example if a script places several calls multiple CallControl. Hangup unsolicited events may occur. If each event needs to be handled differently script may have branching code to properly interrogate each event signature and follow the necessary course of action. Such branching is one use of the userData parameter in actions which generate unsolicited events. MCE automatically propagates information about parameters such as the userData information back to the event handler.

Asynchronous events differ from unsolicited events in that they typically occur only after a corresponding action has executed. For example calling the action MediaServer.PlayAnnouncement will attempt to play an audio stream to a specified destination. If the media cannot be played for any reason within a fraction of a second the MediaServer.PlayAnnouncement Failed event will respond back to the same script which made the request. However if the announcement was played successful the MediaServer.PlayAnnouncement Complete event will occur. These two callbacks will not occur before the MediaServer. PlayAnnouncement action has executed and one or the other is guaranteed to occur if the action executed successfully. This differs from unsolicited events which may not ever occur depending on the circumstances.

In the example depicted in event may have different combinations of associated parameters. Such parameters are compared with event signatures to find the closest event signature. A match if forwarded to the event handler associated with the closest event signature. An event handler may be defined for an exact range of parameters of interest. Such a range of parameters may be matched with a particular event signature. For example if a script should only begin when calls are placed to a particular set of phone numbers the firing event can be interrogated to see if it matches the signature set of phone numbers needed by script . Expressions such as for example regular expressions may also be used to specify event signatures.

Events within MCE may also be characterized according to a protocol session scheme. Such a scheme groups activities that are related by one common element often the same user or user agent. For example a visit to a website might constitute a session with a clear beginning and end and data exchanged throughout. Similarly the collection of TCP IP packets transmitted to download a single image on one page of that visit might also be considered a session. Generally speaking protocol providers within MCE may present some concept of a session. The start of a new session is typically associated with a triggering event . Events which arise during the course of a session and are handled by applications are either unsolicited events or asynchronous events .

The complimentary component to events actions are used to send data outside of MCE or carry out specialized application logic. An action is preferably an inter thread message generated by the application runtime environment on behalf of a script . The message contains the action name and all parameters specified in the script in addition to an Action GUID. An Action GUID is preferably a concatenation of the Routing GUID which triggered this session and the Action ID. All actions preferably require responses. A provider or some component in the core must send a response of some sort usually success or failure upon receiving an action. Like an action or event responses are similar inter thread messages. Application scripts are typically constructed using conditional logic by linking together one or more actions. In a preferred embodiment there are two main categories of actions provider actions and native actions.

Typically calling a provider action blocks script s execution until a response is returned. This sequence is indicated by the two execution arrows directly below the provider actions in the diagram. Simple actions which only involve this execution path are called synchronous actions. However some calls to a provider action may only be able to offer a provisional response. In such a case the final response occurs later in the form of asynchronous event. This class of action is called an asynchronous action.

Preferably from the time the original action request is sent until the time a response is received the script instance is in a wait state pending a response to the action . Such a scheme works well for the majority of actions because the time it takes to process the request is typically very short. Some types of actions may not have such a short processing time. For such actions an asynchronous model is more appropriate.

The provisional response indicates that the provider is processing the request but that it may take some indeterminate amount of time. Once the provisional response is received the script instance continues executing normally. Using the example presented above when a call is placed the provisional response indicates that the initial call request was successful and that the call is proceeding.

Protocol provider then tries to fulfill the request. When the provider is finished executing the asynchronous action request it constructs an asynchronous event or callback event and sends it to the script instance . The receipt of an asynchronous callback event indicates that the action transaction is complete. Asynchronous callbacks are a special type of unsolicited event in application server . They contain specific information that allows the virtual machine to map the event to the appropriate script instance and event handler. MCE retains application state by ensuring that actions may call back their initiating script . Asynchronous callback events preferably eliminate the need for polling systems and help minimize resource utilization.

A native action is preferably always synchronous and is typically used for building application logic that does not need to maintain state beyond the lifetime of the script instance and does not need to monitor any external network service. Unlike provider actions native actions actually cause virtual machine to execute the action logic within the context script instance.

Preferably all scripts within an application are independent and invisible to one another. There is preferably no way to execute code access variables or interrogate the elements of one script from another. In this embodiment communication between scripts must occur through a database through an external messaging component such as protocol provider or using a shared object called SessionData in a Master Slave script configuration.

In this embodiment the configuration settings defined by installer are globally available from anywhere with application but cannot be changed by the application itself. Instead using the system control panel an administrator can modify configuration settings for an application .

Preferably databases may be accessed from within any script within the database s associated application . Such access permits scripts to communicate with one another or to share data which will persist even after all script instances have ended.

Preferably all media resources may be accessed and played through any script within application . Multiple scripts may play the same media resource at the same or overlapping times.

In preferred embodiments communication between applications must occur through an external service such as a protocol provider or an external database or using the SessionData object in a Master Slave configuration.

In this embodiment scripts contain global variables and functions . Global or script level variables and functions may be accessed by any function within the same script but not by other scripts . Functions comprise the lowest level scope in MCE and thus preferably have access to all other levels above them. Functions may also contain variables which can be set or modified by function elements but not by other functions even those within the same script . Function to function communication should be performed by using script level variables or function parameters and return values.

As described with reference to scripts may call actions of various types. A request for such a call put a script instance in state until the appropriate response is received from the action. Processing and queuing of received events is preferably handled by the core engine s router event distributor .

New script instances are executed within the application server s virtual machine and each script instance preferably executes in a separate thread or virtual thread. In an application called myApp contains two scripts A and B. Each time a triggering event is received MCE places a new instance of script A into virtual machine . Whenever a script instance exits it is removed from virtual machine . Script processing typically occurs inside functions. While a script may contain many functions preferably only one of those functions serves as the event handler for the application script s triggering event.

As described referencing above Figures a triggering event is an unsolicited event whose signature corresponds to a script residing in the script pool . Triggering events are a combination of the type of event and specific event parameters required to start a new instance of an application script type. In a preferred embodiment a triggering event must be unique across application server and be matched with only one application script for execution by virtual machine .

Preferably an application executed by virtual machine is a collections of scripts . A script specifies a single triggering event and any number of functions. Functions are collections of actions and loops of actions. Functions loops and script structure are further described with reference to later Figures.

In a preferred embodiment a particular script only has one virtual thread of execution and thus only one function can be running at a time. A call stack is maintained when one function calls another. If a non triggering event is received while a function is executing it is placed into a queue until that function has completed and a suitable non triggering event handler can then be located. An application may contain any number of scripts and all those scripts may be executing in parallel handling different triggering events.

In one embodiment scripts may be master or slave scripts. Such a scheme allows data to be shared between separate script instances. Slave scripts are in every way the same as master scripts with one important exception they are not registered with router at install time. Instead when the master script starts executing it must enable the slave script explicitly and may at that time modify the triggering parameters of the slave script. When a triggering event comes in for the slave script the slave script is given a SessionData object. Such an object is preferably given to all scripts at runtime and contains the connections to any databases the application may have defined the application name the name of the application partition in which the current script is running and a hash table that the script can do with as it pleases. A hash table is a contiguous section of memory with a number of addressable elements in which data can be quickly inserted deleted and found. A slave script preferably gets a reference to the exact same SessionData instance as the master script which enabled it. In this way the master and slave scripts may share data back and forth via the shared hash table in real time.

Some applications need many threads to handle many sessions at once. For example a particular application may wish to place a large number of calls. One script having only one thread of execution will typically not be able to handle a large number of calls in a timely fashion. Executing a slave script for each call represents one solution. In a preferred embodiment however slave scripts are only triggered by their own triggering events.

A special action called SendEvent allows applications to generate such triggering events. Preferably the SendEvent action is actually a direction to the virtual machine . The SendEvent action allows a script to send a triggering or non triggering event as if it were a provider.

Using the SendEvent action a script may place a large number of calls. For example script A sends 500 triggering events of type NewCall. Script A was designed to interact with another script B which is registered to handle NewCall events as a triggering event. In this example 500 instances of script B will run to handle the triggering events generated by script A.

Further a script may employ an action called the Forward action. The Forward action terminates the current script and forwards all subsequent messages to the designated script instance.

Referring to and also to there are two significant subcomponents to be found associated with virtual machine in a preferred embodiment. These components are script pool and script scheduler A. When an virtual machine is first constructed by the Application Manager it places all scripts in the application script pool in memory map form. Script pool then immediately makes copies of them and puts them in a separate area where they await execution. The original master copies remain in another area and are only used to make additional script copies when necessary.

When a triggering event arises for a script in this application the script pool gives scheduler A the waiting copy and immediately begins making a new copy from the master. Scheduler A then seeds the script with the data from the triggering event initializes any global variable values from config initializes any function variables from the event parameters and executes the first action.

Scheduler A preferably schedules script instances in the same way a multi tasking operating system schedules processes. Instead of using timeslices scheduler A treats each action as an atomic operation. Native actions executed to completion in one cycle of scheduler A. Provider actions simply create an inter thread message and send it down into the core for handling. Scheduler A preferably does not wait for provider responses. When the provider response is received it is placed on in coming response queue and handled when that script s turn comes back around. Provider actions which take a long time are broken into three parts instead of the usual two Action response and asynchronous callback . Metreos.CallControl.MakeCall is an example of one such action. It sends a response provisional to indicate that it is trying the number so the script can go on executing in the interim. When the remote party answers the phone an asynchronous callback is sent to application to indicate the answer along with all the pertinent data. Application handles this in the same way it does a non triggering event.

In a preferred embodiment there is only one scheduler A part of the virtual machine for each application . Scheduler A schedules all instances of all scripts currently running for that application . Alternatively if the were no scheduler each script would have its own execution engine and run in its own thread. Such an embodiment is not however preferred. In situations such as the example above describing calls such an embodiment would be unwieldy and may violate operating system limitations if each instance actually had its own thread.

Preferably each scheduler A uses a thread pool to avoid being bogged down under heavy load. Each scheduler A creates a pool of five threads which is dynamically expandable to a configurable limit. The threads are used to execute actions. Thus the number of threads in the pool represents the number of actions which may the executing simultaneously. In such a scheme scripts preferably have no direct relationship to threads. A script may be assigned a different thread each time an action in the script is executed. Under heavy load the thread pool will automatically begin spawning new dynamic threads. These threads are preferably set to decay or self destruct after a configurable period of dormancy. Thus if the system is idle for a while all the thread pools will contract back to the initial five threads.

A script can handle as many non triggering events as many times as it wants. It is up to the functions themselves to determine when it is time for the script to end.

In this embodiment multiple script types may trigger on the same event type and even the same event parameters. Preferably the matching criteria such event parameters must be unique. Such unique parameters are known as the triggering event signature. The triggering event signature must contain at least an event type. Further triggering event declarations in the intermediate code must always include the name of the function that should be called to handle the triggering event.

Further most of the elements apparent on the application canvas of visual designer correspond in a one to one relationship with XML elements. Visual designer converts a particular visual design for an application consisting of actions events and routing options to the compiled XML version of the same application . An XML version of the Hello World program depicted in is listed in Table 7.

In this embodiment visual designer stores information that contains all of the necessary data to not only generate the application XML but also to render the application properly on the screen for development. When the visual designer compiles application from the local source code it generates XML formatted according to a Metreos Application Script XML schema. Other schemas may be defined and used. This XML document can be thought of as the intermediate code used by application server for execution.

Such an XML application storage naturally retains the wide array of benefits provided by XML. Applications may be easily stored on any modern platform transported across virtually any network infrastructure and parsed due to a well defined schema. XML technology may require however significant overhead which may waste resources or increase the potential for error. Preferably MCE addresses such issues through the use of an application assembler which converts bulky XML into streamlined object code while checking for correctness and rejecting malformed applications .

Like many programming languages MCE allows developers to group application logic into functions. In a preferred embodiment visual designer allows application developers to utilize two types of functions event handling and standalone. Table 8 shows a listing of how a standard standalone function declaration is represented in the intermediate XML code generated by visual designer .

Event handling functions are only executed in response to an event that is received by the script instance. Table 9 shows a listing of the declaration of a function that will handle the Metreos.Providers.Http.GotRequest event.

The presence of the tag line 2 indicates to virtual machine that the function should start when an HTTP GotRequest event is received by the script instance. It is important to note that other GotRequest events may be received by the application server and unless they are specifically destined for the script instance they will be treated as potential triggering events. In other words event handling functions are specifically for handling unsolicited events for currently executing script instances.

In a preferred embodiment a function also contains a signature that must be present in the input parameters passed to the function when it is started. Function parameters behave the same when used in both standalone and event handling functions. To indicate that a function takes an input parameter a element must be added and that element must include an initWith parameter as shown in the code listing of Table 10.

Preferably a function may have as many input parameters as the application developer chooses to add. If the function is marked as an event handler and also includes input parameters then the elements must be included to indicate the matching criteria for the event handler as shown in Table 11. The function and optionally its parameters and type of event that it may handle constitute the function signature.

In a preferred embodiment function signatures much like the triggering event signature must be unique. The primary difference between the two is their scoping. Triggering event signatures must be unique across the entire system. In other words each application script type must have a different triggering event signature. In contrast function signatures must be unique within the application script itself.

For example given the event handling functions shown in Table 11 it is apparent that both functions handle the HTTP GotRequest event. Furthermore both functions declare an event parameter that must match against the urn field in the incoming event. The first function HttpEventHandlerA will be executed when a GotRequest event is received that was destined for some url . If the request was sent to another url then the second event handling function HttpEventHandlerB will be executed. If neither function matches then the event will not be handled and will in this example be ignored. Application server will pick the best matching event handler for the specified parameters.

In a preferred embodiment a function is displayed in visual designer as a web of interconnected action icons such as for example those depicted in . Each of the connections is labeled. Those labels indicate the path that execution will follow depending on the result of the prior action. All actions must return a result. That result is preferably a freeform string. If there is no path defined for a particular value of result the default path is taken. Within the context of a loop an action may point to the edge of the loop bounding box indicating that execution should return to the first action in the loop i.e. continue or the next action after the loop if the loop count has been reached. Alternately an action within a loop may point to an action outside the loop to indicate that execution should leave the loop unconditionally i.e. break .

One or more actions may reside inside a loop. A loop may be designated in visual designer as a dashed rectangle around the set of actions. In the generated XML loops have their own section within a function declaration. A loop has only one property the loopCount. There are three different types of loop counts.

A loop count of Literal int type is eventuated in a standard for loop. The index is an integer referenced as loopIndex which starts at zero and increment until loop count minus one.

In this embodiment the other two loop counts are types Enumerable IEnumerator and Dictionary IDictionaryEnumerator . Another preferred embodiment uses the Java equivalent. These loop count types can only be derived from variable or C or Java loop count declarations. It is preferably not possible to specify an Enumerable or Dictionary loop count with a literal value. Preferably the loop count for loop type Enumerabe must resolve to an object which implements System.Collections.Ienumerable or the Java equivalent. This type of object is preferably a one dimensional collection over which loop may iterate. The loop index referenced as loopEnum is initialized with the enumerator for the collection and positioned at the first item. The current item in the collection is referenced as loopEnum.Current . The loop continues until the enumerator reaches the end of the collection.

The Dictionary type loop count works the same as enumerable except that it works with name value collections like Hashtable. The Dictinary loop count is referenced as loopDictEnum and the current values are referenced as loopDictEnum.Key and loopDictEnum.Value .

Using such a loop count scheme it is possible to loop for a constant amount of time or iterate over any collection of unknown size. The names mentioned above for referencing the current index can be used inside of any C or Java code segment i.e. Native action UserCode action or C action parameter .

Only one function is designated to start when a script begins. From there it may call other functions. When the main function is complete the script may exit or it may wait for non triggering events. Any number of functions can be defined to handle any number of non triggering events.

For example application called MyApp contains one script HandleIncomingCall . That script has a function OnIncomingCall which is set to execute when the triggering event Metreos.CallControl.IncomingCall is received. The function executes and then exits without terminating the script. The script has another function called OnHangup which is set to begin executing when the non triggering event Metreos.CallControl.Hangup is received. When that non triggering event comes in the OnHangup function executes then elects to terminate the script . At that point the virtual machine removes the script from the scheduler s execution queue.

Variables allow application developers to store and manipulate data within their application scripts. Variables may either be initialized with a default value or initialized using incoming event parameters. Furthermore variables may be globally or locally scoped. A global variable is visible and useable in all functions whereas a local variable is visible and usable only within the function where it is defined.

The code listing in Table 12 shows how global and local variables are represented in a preferred embodiment MCE s application script XML intermediate language. A global variable declaration appears in line 5. Notice that line 5 is within the script listing but is not within the function declaration beginning at line 9. The function declaration at line 10 is a local variable within the function declared at line 9.

Global and local variables act differently when they contain initWith attributes. When global variables are initialized using initWith application server attempts to retrieve configuration values from the configuration database to store in the global variable. For an example see the global variable declaration shown in the code listing of Table 13.

When a new script instance of a script type containing the code in the preferred scheme of Table 13 starts execution the application server will attempt to initialize myGlobalVariable with the value of the SomeConfigEntry configuration parameter line 3 . If it is unable to do so the script instance will not start. If Table 13 had instead declared a local variable within a function the application server would attempt to initialize it with a value from the incoming event message. The message would be searched for a parameter named SomeConfigEntry and if found its value would be placed into myGlobalVariable.

Preferably a large part of most application scripts is the conditional logic constructed by linking together actions. Actions were previously discussed in context of the application server s execution model. Table 14 shows how a simple action map would be represented in the application script s intermediate XML code. In a preferred embodiment each action is comprised of two mandatory elements actionName and nextAction. Each action may also define zero or more act ionParam elements.

In this embodiment the flow of the application script is defined by how the actions link to one another as represented by the nextAction elements lines 6 and 7 line 14 . Each nextAction element contains a returnValue attribute which indicates which path to take based on the result of the action.

The user may create diagrams on application canvas using application elements from toolbox such as for example actions control structures and variables. Such elements are linked to form the design of an application . A particular diagram for an application may become much larger than the user s screen. Application canvas may be panned up and down or left and right using scrollbars to accommodate such large views.

Tabs are provided to further accommodate viewing a large application and to separate application diagrams logically or structurally. Tabs in operate to change the view on application canvas . Some exemplar views are depicted as separate blocks A B and C in .

In a preferred embodiment script view A shows the entire diagram of a script. Function view B shows a diagram of a particular function which may be entered by the user or pulled from a library another program or other sources. View is preferably a view of the first triggering event function in application . Function n view C depicts the possibility of further function views which are preferably accessible in sequential order according to their appearance in the application. Other views are possible. Examples of such other views are data views and screen views. Other viewing schemes are further described with reference to later Figures.

Project explorer presents a tree view of application components which may be navigated through interaction with explorer . Preferably project explorer lists all chief components of the currently loaded application grouped by category. Components may include scripts installers databases and media resources . Project explorer acts as the main navigation system for visual designer permitting developers to switch between each piece of a large application .

In this embodiment application components or elements reside in toolbox . A user adds an element to an application by clicking on the appropriate category heading listed in toolbox and then dragging and dropping the desired element onto application canvas . In a preferred embodiment third party components may be added to toolbox by developing new protocol providers .

Overview window in this embodiment displays a small representation of the current application canvas . A rectangle overlaid on overview window indicates the area of the canvas currently visible onscreen. Users may click and drag a new rectangle to change the viewing area of application canvas . Users may also drag rectangle or move it with arrow keys to navigate canvas .

Variables tray displays variables that are local to the current function or script displayed on canvas . Users may change various property settings associated with an element using properties window . A user may focus property window onto a particular element by clicking on a specific instance of the element on application canvas or by clicking on the original element item in toolbox . Different elements types of elements will present different properties for modification. Such properties may be for example initialization values or return values. Property window permits modification of properties for actions events variables scripts and projects.

When a user compiles an application for eventual installation to application server the compiler may generate information warning or error messages. Such messages preferably appear in output window . Preferably a user can click on a message to navigate to an associated element.

Remote console window may be activated to show the console view interface screen remotely for a particular MCE system to which visual designer may be connected. Such a view may be useful for debugging operations and maintenance.

Still referring to a preferred embodiment of visual designer call stack docking window provides a user with detailed information on protocol stack or call stack of calls within application . Such information may be useful for debugging. Breakpoints docking window allows a user to manage breakpoints within an application for debugging purposes. Watch docking window shows debugging values of variables or elements on which a user has set a watch. Debugging within visual designer is further described with reference to later Figures.

Application framework comprises a main module including a menu manager and dialog manager for visual designer . Application framework also has a number of satellite window managers for managing the various windows above with reference to .

Utility managers manage various housekeeping aspects of visual designer including a Web Services Description Language WSDL Manager. Packages manager manages the various packages that may be installed with visual designer including third party toolboxes and packages. Event router generates routes for various events associated with script functions. Further applications framework includes various resources employed by visual designer .

Drawing framework includes managers . Managers include a project manager for encapsulating projects within visual designer a script manager and a canvas tab manager. Further included are various serializers such as for example an XML serializer and a database serializer. Such serializers are known in the art and are operational to convert the drawing layouts and other objects in visual designer to code.

Drawing framework further includes canvases modules for implementing the various visual interfaces to visual designer . Also included in drawing framework are various node modules to implement nodes which make up the various applications.

Dialogs module manages various dialogs which may be presented to the user. Debugger module includes various submodules for implementing interfaces to MCE and to visual designer users and modules to provide debugging functionality. Debugging will be further described with reference to .

Further visual designer includes various other modules such as custom editors which may be launched by visual designer to allow editing of third party components or custom views. A custom properties module allows developers to add and manage custom properties to the various objects included in an application.

In step the user selects a new project from within visual designer . Preferably visual designer uses a project metaphor to aid developers in organizing applications and applications and application components into a logical system. Creating a new project within the visual designer requires creating a folder on the developer s system or a shared network drive usually with the same name as the application . Within this folder visual designer stores all the application components. The folder contains files which represent all the scripts used in application the files with configuration and installation data for application and the files containing SQL code for databases required by application . After creation of the project any installed provider and native actions are displayed in Designer s Toolbox. The user may also specify a triggering event at this step.

In step the user constructs a new application script . This step further involves dragging and dropping any global variables onto the canvas. In step the user defines the functionality of the application which is typically a VoIP application. Other types of applications may also be built with visual designer such as for example PSTN telephony applications. Defining functions includes in step drag and drop actions and variables from Toolbox onto canvas . In step the user sets properties of each element using the property window . In step the user defines logic flow among the various functional elements. Step typically involves dragging arrows between elements visually setting arrows branch conditions and dragging and dropping other logical constructs from the Toolbox such as loops and function calls.

Steps and are iterated for functional elements until the function is complete step . Additional functions are added by repeating the process until the script is complete step . Further scripts are added until the application is complete step .

A completed application is built and tested according to step . In step to compile the application the user preferably selects build from the Designer menu or hits a build button. In step users correct any resulting errors. Deploying the application in step involves Select Deploy from the Designer menu. The application is installed to Application Server by a process described further below. User s may employ debugging capabilities of application server and visual designer to test the application in step .

In step in the traditional function view building blocks are actions which are dragged from the Toolbox and dropped onto a function canvas as described with reference to and further with reference to . Logic flow is indicated by dragging arrows between action nodes and visually setting a branch condition for each such arrow. Transfer of control is specified by dragging from the toolbox to the canvas logical constructs such as for example Call Function Loop End Function Label Compare and Switch.

In step the user may switch to Phone View to see the application as it appears on an IP phone display. User drags graphical building blocks from the toolbox onto the phone view such as Menu Softkey Image Directory Button and Text. Handler functions may be defined for softkeys. The user may then switch to Function View to define the handlers. User interface objects such as images may be visually repositioned and resized. Further Images directory text menu text button text etc. may be bound to database content.

In step the user may switch to IVR interaction voice response view. This view allows the user to build an application script by visually specifying call flow through a tree of IVR prompts and menus. Nodes in the tree may be linked to media prompts.

In step the user may switch to a Site Map View to see and build the mapping between soft keys and application pages in VoIP application or other application involving interactive pages.

In step visual designer presents a dialog in which user specifies a URL or path to a remote or local web service description file. If the web service is found user presses Next to continue.

In step visual designer presents a dialog in which each method of the located web service is displayed. The user verifies that the methods are as expected enters a name to describe the web service on the local machined and presses Next to continue.

In step visual designer interprets the web service description file creating a local proxy method for each method in the web service. Visual designer also presents a dialog displaying each method proxied and solicits the name of a new or existing Designer Toolbox tab under which to insert tools for each such method.

In step visual designer Designer installs the web service as a Designer Package and inserts a tool for each proxied method onto the selected Toolbox tab. The user presses Finish to commit changes or Back to undo changes. Such navigation preferably is available between all steps presented by visual designer as part of the web services wizard.

In step the user may now use the web services tools by dragging and dropping onto application canvas connecting and setting properties as described above.

Applications are usually deployed from visual designer . The usual sequence of events is that a developer uses visual designer to create an application packages it and deploy it to application server . When visual designer packages an application it invokes the same static script compiler the Application Server uses just to ensure that there are no errors in the application. Then it locates any custom actions and or types that the user has linked into this application and zips it all up into one file using the name of the application as the filename and a .mca extension step .

It then connects to Application Server preferably via an application deployment Secure FTP interface and transfers the archive to the destination MCE . Step . Assembler has a deploy watcher which watches the deployment directory for new files. It is also possible to install a packaged application via the system control panel management website or by direct connection using a standard SFTP client. Use of visual designer is preferred.

Assembler begins by extracting the archive into a temporary directory. Next it checks to see if this application is already installed. If it is then the existing application is uninstalled and its data prepared for upgrading. Otherwise it inserts any configuration items that application has defined into the configuration database step . Such items may then be viewed and modified from the system control panel management website. Next assembler creates any databases the app has defined step . Then assembler sends out copies of any media files included in the archive to all configured media servers via SFTP step .

Assembler next compiles the scripts into memory maps and creates a new AppDomain and virtual machine runtime environment . Then the default application partitions are created in the configuration database with the dev time triggering criteria step . Assembler finishes by feeding the scripts to script pool . The virtual machine then registers all the scripts with the Router and the script is ready for execution on application server .

Similarly assembler application manager responds to requests from the system control panel management website via the management interface to uninstall applications. It does so by first sending the virtual machine in question a message telling it to uninstall. Virtual machine responds by notifying router that it is about to be uninstalled and unloading any running scripts. Next Application Manager deletes the respective AppDomain .

Referring in more detail to step in script compilation is the process of converting an XML representation of a script into a memory map object. As described above a script is a collection of functions which are each a collection of actions. In a preferred embodiment there are three types of actions and the compiler must handle each type differently as they are encountered provider actions native actions and UserCode actions.

Provider actions are actions in which the XML specifies in plain text strings the name of the action and all the parameters as name value pairs. To compile a provider action the assembler has to these strings into a class. The virtual machine will see this at runtime and generate an inter thread message to send to the designated provider.

A native action is a class which conforms to a well defined interface which contains an Execute method which will be called directly by the virtual machine at runtime. The parameters and return values of a native action are defined by decorated properties with set and get accessors as appropriate. Such properties are preferably implemented as a formal .NET or Java construct. MCE includes many native actions to assist developers. Additionally developers may include custom built actions by creating a reference to them in visual designer . Visual designer then includes these assemblies in the application package. When the assembler sees this it places them in a NativeActions directory under the application install directory.

The compiler locates the assembly containing the action in question using reflection preferably implemented with .NET or Java instantiates the action and stores a reference to it as the entry for this action in the memory map.

UserCode actions similar to native actions concerning how virtual machine treats them but instead of the developer providing a pre compiled assembly with the action code in it they supply the code itself in un compiled form as a single function. So assembler creates an in memory code block CodeDom and appends these snippets of code as abstract classes with a single static Execute method as it finds them. When all the actions have been processed assembler compiler invokes a C or Java compiler to compile this block of accumulated code. Assembler then goes back to each of the UserCode actions and searches the generated assembly for the compiled functions. As it finds them it adds method references MethodInfo as that respective action s entry in the memory map.

When the virtual machine encounters UserCode actions it preferably treats them differently than provider actions. Since the UserCode action is preferably comprised of only a single function it does not have properties. Thus the parameters of the Execute method serve as the parameters for the action. The name of the parameter must be a variable name and the type must be correct for that variable. Then the virtual machine passes that variable value into the function. In a preferred embodiment a UserCode action can only take variables as parameters there is no way to pass in literals or C or Java expressions. There are however a few special parameters UserCode actions can include to get runtime information or services LogWriter log int loopIndex IEnumerator loopEnum IDictionaryEnumerator loopDictEnum and SessionData sessionData . Preferably only one of the loop parameters may be used at a time and it must be the correct one for the type of loop this action is contained in. The other special parameters are preferably always available.

With continuing reference to the assembly process with respect to variables variable types must be declared. A type within the context of an MCE application is a class which conforms to a well defined interface. The class must be capable of being assigned a string resolving to a string and being reset. Further the type may include and publish any number of proprietary methods which are useful for this type.

Like native actions most common types are included with MCE . These types string bool int etc preferably behave like native .NET or Java types. These types are preferably implement a different interface which when encountered signals the virtual machine to extract their underlying type and use that instead of the artificial wrapper. Developer built types are referenced in visual designer and packaged in the same way native actions are. Assembler puts developer built types in a NativeTypes directory under the application install directory. When creating a variable of that type the class for the type is instantiated and a reference is stored in the variable information object which is stored in a variables section in the memory map.

Referring now to assembler s handling of action parameters action parameters can be one of three types literal variable and a code expression preferably either C or Java .

If a literal value is specified for an action parameter virtual machine will pass it as a string if the action is a Provider action. It is the provider s responsibility to cast or parse its parameters as necessary. Otherwise virtual machine will attempt to cast or parse is to the required type for a Native action.

A variable action parameter merely identifies the variable who s value should be passed in. The virtual machine will search for the variable by looking first at the function variables then at the global variables. When it finds the designated variable it passes the value as it is into the action regardless of whether it is a Provider Native or UserCode action.

A C or Java action parameter is a snippet of code similar to a UserCode action except that it can only be a single statement which must resolve to an object. When assembler encounters this it stubs out a class and a function which initializes all the local and global variables in addition to the special parameters mentioned for UserCode actions so they are available to the snippet and places the snippet just after the return statement so it will be evaluated and return with the function. Then just like a UserCode action a method reference MethodInfo is saved for that action parameter so it can be evaluated later at runtime.

In step the user begins debugging of the application script by selecting Start Debugging from a menu or by pressing the F5 key. The application begins execution in debug mode.

In step when an action is reached on which a breakpoint has been set and enabled execution pauses before execution of the action and a halo is drawn around the action on canvas . The state of global variables and variables local to the current function are displayed in the Watch window . the user selects Continue or Step from a menu to resume execution.

In step the user can single step from action to action starting either at the beginning of the application or at a current break action. Stepping is selected via menu or function key. When stepping execution pauses at each node visited and a break halo is drawn around the node on canvas . If the action is Call Function selecting Step Into will single step into the body of the called function. If the user selects Step Over the function executes and execution pauses at the next action after the function return point.

To stop debugging in step the user selects Stop Debugging from a menu or function key and the application exits. The debugging process described herein is merely exemplary and other scenarios and control means may be used.

In a preferred embodiment application server implements the described debugging capability as follows. Upon receipt of the command to start debugging visual designer establishes communication to debug module and OAM module on the target application server .

A debugging session begins when the visual designer acting as a client sends a StartDebugging command to OAM module acting as a server. When virtual machine gets this message it creates a new type runtime data structure to handle debug related state information and associates it with the specified script not an instance yet . The next time a script of that type starts becomes a script instance virtual machine will link the debug information object to it and that script instance will then be in debug mode.

Before debug mode occurs visual designer user preferably will set some breakpoints. The user does this by simply right clicking an action in a script and selecting Set Breakpoint . Visual designer translates such an request into a command and an action ID and sends it to the application server where that information is stored in the debug information object. Application manager preferably routes debug messages.

Table 16 contains a list of possible debugging commands in a preferred embodiment. Breakpoints may be set and cleared at any time. A developer can set all desired breakpoints at once or only set one and once that is reached set the next one. When virtual machine sees that an action is marked as a breakpoint it does not execute the action. Instead it sends a HitBreakpoint command to the connected client. The client may then elect to do any number of things. The client can send a Run command if they wish for execution to continue to the next breakpoint or script end.

The client may send a StepInto or StepOver to execute only one action. The difference between StepOver and StepInto is only made if the action is a CallFunction. StepOver will execute the called function and break on the next action in the current function. StepInto will step into the function an break on the first action. Regardless of which was chosen a HitBreakpoint command will be sent to the client along with the state of all the variables and SessionData to indicate that execution has stopped again.

At any time in script execution the client may issue a Break command. The Break command will cause virtual machine to halt execution at whatever action it is on and send all the state information variable values and SessionData information to the client in a HitBreakpoint message. Virtual machine will then wait for further instruction.

While script is paused on an action due to any debug command the client may elect to send an UpdateValue command. This will cause the value of the specified variable to change to the specified value in that script instance in real time. When script finishes executing the server will send a StopDebugging command to the client to indicate this. If the client no longer wishes to debug script it may issue a StopDebugging command to the server which will clear any breakpoints and put script back in a running state.

Command map is the source of requests to and local sink responses from the remainder of media server s architecture. Command map and protocol adapters translate media requests to the media server s API. Client manager and server manager manage media requests through queues . Such a scheme allows a protocol adapter to leave a request on the server queue and not be required to wait for a response.

Session manager conference manager setup and manage sessions. The session manager observes connection threads and performs management tasks such as identifying connections which may be in limbo terminating them to make their connection thread available. The conference manager associates connections with conferences and is responsible for accessing HMP resources to start and terminate conferences adjust conference parameters and add and remove connections to and from conferences.

Session pool and service thread pool make available a number of threads of execution each of which may be responsible for handling media firmware service requests and results through media manager and event manager . Media firmware interacts with media manager according to the HMP protocol and provides access to various media resources.

Although the present invention has been described in detail it will be apparent to those skilled in the art that many embodiments taking a variety of specific forms and reflecting changes substitutions and alterations can be made without departing from the spirit and scope of the invention. The described embodiments illustrate the scope of the claims but do not restrict the scope of the claims.

