---

title: Compression of data transmitted between server and mobile device
abstract: A remote wireless device receives a compressed message including an application definition file. The application definition file is associated with an application executing at a computing device and contains definitions for: a user interface format; a format for network messages; and a format for storing data. Using these definitions, the wireless device may receive data generated by the application and formatted in accordance with the definitions. The wireless device may then present a user interface for the application. Preferably, the application definition file is an XML file. Similarly, application-specific network messages provided to the device are also formed using XML. Data generated by the application may be presented at the mobile device under control of a virtual machine that uses the application definition file. For efficiency, the network messages received at, and transmitted by, the wireless device may be compressed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07920852&OS=07920852&RS=07920852
owner: Research In Motion Limited
number: 07920852
owner_city: Waterloo, Ontario
owner_country: CA
publication_date: 20060721
---
The present disclosure relates to software devices and methods allowing varied mobile devices to interact with server side software applications and more particularly to compression of data transmitted between server and mobile device.

Wireless connectivity is a feature of the modern telecommunications environment. An increasing range of people are using a wide variety of wireless data networks to access corporate data applications.

However there are numerous competing mobile devices that can be used to achieve this. Each device has its own operating system and its own display characteristics. Operating systems are not mutually compatible nor are the display characteristics some are color some are black and white some are text only some are pictorial.

At the same time an increasing number of mobile device users are people without a technical background or high level of educational achievement. Such people are often intimidated by the need to run complex installation programs. Furthermore at present such installation programs generally depend on cable connections to a personal computer by the means of a cradle or other such device.

Therefore a mechanism whereby a mobile client for a server side application may be enabled for multiple wireless devices with minimal modification of the application at the server is required. Further the ability to install and upgrade the application onto mobile devices wirelessly without the need for human intervention or connection to PCs is desirable.

In accordance with aspects of the present disclosure data from an application executing at a computing device is presented at a remote wireless device. The device is provided with an application definition file that contains definitions for a user interface format for the application at the wireless device a format of network messages for exchange of data generated by the application and a format for storing data related to the application at the wireless device. Using the definitions the wireless device may receive data from the application and present an interface for the application. Preferably the application definition file is an Extensible Markup Language XML file. Similarly application specific network messages provided to the device are also formed using XML. For efficiency the application specific network messages may be compressed using known compression schemes. In the preferred embodiment the data from the application is presented at the mobile device by virtual machine software that uses the application definition file.

In accordance with an aspect of the present disclosure there is provided a method of presenting data at a remote wireless device from an application executing at a computing device. The method includes receiving at the wireless device a first compressed package including a text file where the text file defines a format of a user interface for the application at the wireless device a format of network messages for receipt of data generated by the application and a format for storing data related to the application at the wireless device. The method further includes decompressing the first compressed package receiving a second compressed package including data from the application in accordance with the format of network transactions decompressing the second compressed package and presenting the data at the wireless device using the user interface. In another aspect of the application a wireless mobile device is provided to carry out the method.

In accordance with another aspect of the present disclosure there is provided a wireless mobile device. The wireless mobile device includes a processor and memory in communication with the processor. The memory stores software that adapts the wireless mobile device to receive a first compressed package including a text file the text file defining a format of a user interface to an application executing at a remote computing device a format of network messages for receipt of data generated by the application and a format for storing at the wireless device data related to the application. The software also adapts the wireless mobile device to decompress the first compressed package receive a second compressed package including data from the application the data formatted in accordance with the format of network messages decompress the second compressed package generate a screen according to the format of the user interface and present on the screen the data.

Other aspects and features of the present disclosure will become apparent to those of ordinary skill in the art upon review of the following description of specific embodiments of the application in conjunction with the accompanying figures.

The storage memory at the device further stores virtual machine software exemplary of an embodiment of the present disclosure. The virtual machine software when executed by the mobile device enables the device to present an interface for a server side application provided by a middleware server as described below. Specifically a virtual machine see which exists through an execution of the virtual machine software on the processor interprets a text application definition file defining a user interface controlling application functionality and the display format including display flow at the device for a particular server side application the format of data to be exchanged over the wireless network for the particular server side application and the format of data to be stored locally at the device for the particular server side application. The virtual machine uses the operating system software and associated APIs to interact with the device in accordance with the received application definition file. In this way the device may present interfaces for a variety of server side applications executed at a variety of servers. Moreover multiple wireless devices may use a common server side application as each wireless device executes a similar virtual machine that interprets an application definition file to present a user interface and program flow specifically adapted for the device.

As such and as will become apparent the exemplary virtual machine software is specifically adapted to work with the particular mobile device . Thus if the device is a PalmOS or WinCE device the virtual machine that results from executing the exemplary virtual machine software is correspondingly a PalmOS virtual machine or a WinCE virtual machine. As further illustrated in the virtual machine is capable of accessing the local storage at the device .

Other applications libraries and software may also be present within the memory or the local storage and are not specifically illustrated. For example the device may store and execute personal information management PIM software including calendar and contact management applications. Similarly the device could store and execute software allowing the device to perform a number of functions. Software could for example interact with the hardware at the device to allow the device to act as a multimedia player allowing the device to print allowing the device to interact with other incorporated hardware not specifically illustrated including but not limited to a Bluetooth interface a Global Positioning Satellite GPS Receiver and the like. The memory may also store software components in the form of object classes that may be used to extend the functionality of the virtual machine . As will become apparent these external software components in the form of object classes allow the virtual machine to become extensible. The object classes may for example allow the virtual machine to access additional hardware or software local to the device .

As detailed below an exemplary application definition file may be formed using a markup language such as the known XML or a variant thereof. In accordance with an embodiment of the present disclosure defined XML entities are understood by the virtual machine . Defined XML entities are detailed in Appendix A FIGS. A JJ of US Patent Application Publication 2003 0060896 A9. The defined XML entities are interpreted by the virtual machine and may be used as building blocks to present an interface at the mobile device to server side applications as detailed herein.

Specifically as illustrated in the virtual machine software includes conventional XML parser software event handler software screen generation engine software compression engine software and object classes. The virtual machine software when executed leads to the virtual machine which includes an XML parser an event handler a screen generation engine a compression engine and instances of the object classes . The object classes correspond to XML entities supported by the virtual machine software and possibly other XML entities contained within an application definition file. Supported XML entities are detailed in Appendix A of previously referenced US Patent Application Publication 2003 0060896 A9. A person of ordinary skill will readily appreciate that those XML entities identified in Appendix A are exemplary only and may be extended shortened or modified as desired.

The XML parser may be formed in accordance with the Document Object Model or DOM available at www.w3.org DOM the contents of which are hereby incorporated by reference. The XML parser enables the virtual machine to read an application description file. Using the XML parser the virtual machine may form a binary representation of the application definition file for storage at the mobile device thereby eliminating the need to parse text each time an application is used. The XML parser may convert each XML tag contained in the application definition file and its associated data to tokens for later processing. As will become apparent this may avoid the need to repeatedly parse the text of an application description file.

The screen generation engine orchestrates the display of initial and subsequent screens at the mobile device in accordance with an application description file as detailed below.

The event handler allows the virtual machine to react to certain external events. Example events include user interaction with presented screens or display elements incoming messages received from a wireless network or the like.

The compression engine enables the virtual machine to compress an XML package before transmitting the XML package as will be discussed below. Equally the compression engine enables the virtual machine to decompress a received XML package as will be discussed below. Through the use of the compression engine the virtual machine may exchange a lesser amount of data with other network components thereby resulting in reduced transmission times and more efficient operation. The compression scheme need not be specific to the type of data to be exchanged. For instance known compression schemes such as PKZIP or data folding may be used.

The object classes define objects that allow the mobile device to process each of the supported XML entities. Each of the object classes includes attributes which are used to store parameters defined by the XML file and functions allowing the XML entity to be processed at the mobile device as detailed in Appendix A of previously referenced US Patent Application Publication 2003 0060896 A9 for each supported XML entity. So as should be apparent supported XML entities are extensible. The virtual machine software may be expanded to support XML entities not detailed in Appendix A . Corresponding object classes could be added to the virtual machine software .

As detailed below upon invocation of a particular application at the mobile device the virtual machine presents an initial screen on the user interface based on the contents of the application definition file . Screen elements are created by the screen generation engine by creating instances of corresponding object classes for defined elements. The object class instances are created using attributes contained in the application definition file . Thereafter the event handler of the virtual machine reacts to events for the application. Again the event handler consults the contents of the application definition file for the application in order to properly react to events. Events may be reacted to by creating instances of an associated action object class from the object classes.

Similarly the object classes of the virtual machine software further include object classes corresponding to data tables and network transactions defined in the Table Definition and Package Definition sections of Appendix A of previously referenced US Patent Application Publication 2003 0060896 A9. At run time instances of object classes corresponding to these classes are created and populated with parameters contained within the application definition file as required.

Using this general description persons of ordinary skill in the art will be able to form the virtual machine software for any particular device. Typically the virtual machine software may be formed using conventional object oriented programming techniques and existing device libraries and APIs as to function as detailed herein. As will be appreciated the particular format of the screen generation engine and the object class instances will vary depending on the type of virtual machine software the device operating system and the APIs available at the device. Once formed a machine executable version of the virtual machine software may be loaded and stored at the mobile device using conventional techniques. The machine executable version of the virtual machine software can be embedded in ROM loaded into RAM over a network or loaded into RAM from a computer readable medium. Although in the preferred embodiment the virtual machine software is formed using object oriented structures persons of ordinary skill will readily appreciate that other approaches could be used to form suitable virtual machine software. For example the object classes forming part of the virtual machine software could be replaced by equivalent functions data structures or subroutines formed using a conventional i.e. non object oriented programming environment. Operation of the virtual machine while consulting an application definition file containing various XML definitions is further detailed below.

Virtual machines like the virtual machine executed at the first example mobile device execute on each of the further example mobile devices and communicate with a middleware server by way of a first example wireless network a second example wireless network a first example network gateway and a second example network gateway . The example gateways are generally available as a service for those people wishing to have data access to wireless networks. An example network gateway is available from Broadbeam Corporation of Cranbury N.J. in association with the trademark SystemsGo . The wireless networks are further connected to one or more computer data networks such as the Internet and or private data networks by way of the example gateways . As will be appreciated the application may work with many types of wireless networks. The middleware server is in turn in communication with a data network that is in communication with the example wireless networks . The communication protocol used for such communication may be an HTTP transport over TCP IP. As could be appreciated other network protocols such as X.25 or SNA could equally be used for this purpose.

The mobile devices communicate with the middleware server in two ways. First the virtual machine at each device may query the middleware server for a list of applications of which a user of an associated mobile device can make use. If a user decides to use a particular application the corresponding mobile device can download a text description in the form of an application definition file for the particular application from the middleware server over its wireless interface. As noted the text description is preferably formatted using XML and compressed before transmission. Second the virtual machine at each device may send receive present and locally store data related to the execution of applications or its own internal operations. The format of exchanged data for each application is defined by an associated application description file. Again the exchanged data is preferably formatted using XML in accordance with the application description file and compressed before transmission.

The middleware server in turn stores text application description files for those applications that have been enabled to work with the various mobile devices in a pre defined format understood by the corresponding virtual machines. Software providing the functions of the middleware server in the exemplary embodiment is written in Delphi and uses an SQL Server database.

As noted text files defining application definitions and data may be formatted in XML. For example XML version 1.0 detailed in the XML version 1.0 specification second edition dated Oct. 6 2000 and available at the internet address www.w3.org TR 2000 REC xml 2000 1006 the contents of which are hereby incorporated herein by reference may be used. However as will be appreciated by those of ordinary skill in the art the functionality of storing XML description files is not dependent on the use of any given programming language or database system.

Each application definition file is formatted according to defined rules and uses pre determined XML markup tags known to both the virtual machine executed at the mobile device and the complementary server software executed at the middleware server . Tags define XML entities which are used as building blocks to present an interface to an application at a mobile device. Knowledge of these rules and an understanding of how each tag and section of text should be interpreted allows the virtual machine executed at the mobile device to process an XML application definition file and thereafter provide an interface to an application executed at an application server as described below. The virtual machine effectively acts as an interpreter for a given application definition file.

Defined XML markup tags correspond to XML entities supported at a mobile device and are used to create an application definition file . The defined tags may broadly be classified into three categories corresponding to the three sections and of an application definition file .

Example XML tags and their corresponding significance are detailed in Appendix A of previously referenced US Patent Application Publication 2003 0060896 A9. As noted above the virtual machine software at the mobile device includes object classes corresponding to each of the XML tags. At run time instances of the object classes are created as required.

 this tag defines a screen such that a SCREEN tag pair contains the definitions of the user interface elements buttons radio buttons and the like and the events associated with the screen and its elements 

 this tag defines an event to be processed by the virtual machine events can be defined against the application as a whole individual screens or individual items on a given screen sample events include receipt of data over the wireless interface and an edit of text in an edit box and

 this tag defines a particular action that might be associated with an event handler sample actions include navigating to a new window and displaying a message box. .

The second category of example XML tags may be used in the network transaction definition section of the application definition file . These may include the following example XML tags 

 using this tag the application developer can define an update that is performed to a table in the device based local storage attributes of this tag allow the update to be performed against multiple rows in a given table at once and

The third category of XML tags are those used to define a logical database that may be stored in local storage at the mobile device . The tags available that may be used in the local data definition section are 

 this tag along with its attributes defines a table contained within a pair of tags are definitions of the fields contained in that table the attributes of a table control such standard relational database functions as the primary key for the table and

 this tag defines a field and its attributes attributes of a field are those found in a standard relational database system such as the data type whether the field relates to a field in a different table the need to index the field and so on .

The virtual machine may from time to time need to perform certain administrative functions on behalf of a user. In order to do this one of the object classes is associated with a repertoire of tags to communicate needs to the middleware server . Such tags differ from the previous three groupings in that they do not form part of an application definition file but are solely used for administrative communications between the virtual machine and the middleware server . XML packages using these tags are composed and sent due to user interactions with configuration screens of the virtual machine . The tags used for this include 

 this tag allows the application to register and deregister a user for use with the middleware server 

 using this tag a mobile device can register or deregister for an application and have the application definition file downloaded automatically or remove the application definition file from the device based local storage and

 using this tag the user is allowed to identify the device that the user is currently using as the active device if the user s preferred device is malfunctioning or out of power or coverage the user may need a mechanism to tell the middleware server to attempt delivery to a different device .

As such the middleware server stores a master definition file for a given server side application. This master definition file contains an example user interface definition section for the first example mobile device of an example user interface definition section for the mobile device of an example user interface definition section N for an Nth mobile device a description of the network transactions that are possible in the network transactions definition section and a definition of the data to be stored locally on the mobile device in the local data definition sections . Preferably the network transactions definition section and the local data definition sections will be the same for all example mobile devices . . . N.

For the first example mobile device the middleware server composes the application definition file by querying the device type and adding the user interface definition section for the first example mobile device to the definition sections for the network transactions and the device local data. For the second example mobile device the middleware server composes the application definition file by adding the user interface definition section for the second example mobile device to the definition sections for the network transactions and the device local data.

The master definition file for a given application is likely to be created away from the middleware server and loaded onto the middleware server by administrative staff charged with the operation of the middleware server . Master definition files could be created either by use of a simple text editor or by a graphical file generation tool. Such a tool might generate part or all of the file using knowledge of the XML formatting rules based on the user s interaction with screen painters graphical data definition tools and the like.

The network interface hardware enables the middleware server to transmit and receive compressed data over a data network . Compressed transmissions are used to communicate with both the virtual machine of the first example mobile device via the wireless networks and the wireless gateways and a backend application server which may be considered representative of one or more application servers. The backend application server may be considered both the end recipient of data received by the middleware server from the mobile devices and the generator of data that is to be sent by the middleware server to the mobile devices.

The storage memory at the middleware server further stores middleware server software exemplary of an embodiment of an aspect of the present disclosure. The middleware server software when executed by the processor of the middleware server enables the middleware server to compose and understand XML packages that are sent by and received by the middleware server . These XML packages may be exchanged between the middleware server and the first example mobile device or between the middleware server and the backend application server .

As mentioned above communication between the backend application server and the middleware server may use HTTP running on top of a standard TCP IP stack. An HTTP connection between a running application at the backend application server and the middleware server may be established in response to receipt of an XML package from a mobile device. The server side application executed at the backend application server provides output to the middleware server over this connection. The server side application output may be formatted by the server side application into appropriate XML packages understood by the virtual machine at the first example mobile device .

That is a given server side application or an interface portion of the server side application formats server side application output into an XML package in a manner consistent with a format defined in the application definition file for the given server side application. Alternatively an interface component separate from the server side application could easily be formed with an understanding of the format for output for the given server side application. That is with a knowledge of the format of data provided by and expected by the given server side application at the backend application server an interface component could be a produced using techniques readily understood by those of ordinary skill. The interface component could translate the output of the given server side application to an XML package as expected by the middleware server . Similarly the interface portion may translate an XML package received via the middleware server from the mobile device into a format understood by the given server side application.

The particular identity of the mobile device on which the interface to the server side application is to be presented may be specified by a suitable identifier contained in a header prefixed to the server side application output XML package. This header may be used by the middleware server to determine the appropriate mobile device to which to forward the XML package. Alternatively the identity of the connection between the backend application server and the middleware server could be used to determine at the middleware server the appropriate mobile device to which to forward the XML package.

For data requested from the middleware server the device under software control by the virtual machine software transmits compressed requests to the middleware server see also which compressed requests pass over the first wireless network to the first network gateway . The first network gateway passes the compressed request to the middleware server . The processor of the middleware server responds by executing a database query on the server database . The response to the query is an indication of the applications that are available to the user and the mobile device . Data representative of the indication is compressed and subsequently passed by the middleware server to the first network gateway . The first network gateway forwards the compressed data representative of the indication to the mobile device over the first wireless network .

In response to being presented with the list of available applications a user at the first example device may choose to register for an available server side application in the list. When the user chooses to register for an application the virtual machine at the device composes a registration request XML package containing a registration request for the selected application. The compression engine then compresses the registration request XML package and the wireless interface hardware transmits the compressed registration request XML package to the middleware server data flow . The registration request XML package may contain a tag. The name of the application is specified in the registration request XML package. The middleware server in response to receiving the registration request XML package queries the server database for a user interface definition associated with the specified application and the first example mobile device . Thereafter the middleware server creates the application definition file as detailed with reference to . Then the middleware server composes an XML package including the composed application definition file compresses the XML package and transmits the XML package to the mobile device data flow .

The user is then able to use the functionality defined by the application definition file to send and receive data.

After receiving the compressed XML package including the application definition file the compression engine may decompress the XML package. Subsequently the XML parser of the virtual machine may parse the XML text of the application definition file to form a tokenized version of the application definition file. That is each XML tag of the application definition file may be converted to a defined token for compact storage and to minimize repeated parsing of the XML text file. The tokenized version of the application definition file may then be stored for immediate or later use by the device .

Thereafter upon invocation of an interface to the particular application for which the device has registered the screen generation engine of the virtual machine locates the definition of an initial screen for the particular application. The initial screen may be identified within the application definition file for the particular application as corresponding to a tag with an associated attribute of First screen yes .

Exemplary steps performed by the virtual machine in processing the initial screen and any screen are illustrated in . As illustrated the screen generation engine generates an instance of an object class defining a screen by parsing the section of the application definition file corresponding to the tag in step S. Supported screen elements may be buttons edit boxes menus list boxes and choice items as identified in sections 5.3 5.4 and 5.5 of Appendix A of previously referenced US Patent Application Publication 2003 0060896 A9. Other screen elements such as images and checkboxes as detailed in Appendix A may also be supported. However for clarity of illustration the processing of the other screen elements by the screen generation engine is not detailed. Each supported tag under the SCREEN definition section in turn causes creation of instances of object classes within the virtual machine . Typically instances corresponding to the tags used for creation of a screen result in presentation of data at the mobile device . As well the creation of such instances may give rise to events e.g. user interaction and actions to be processed at the device .

Each element definition causes the virtual machine to use the operating system of the mobile device to create a corresponding display element of a graphical user interface as more particularly illustrated in . Specifically for each element the associated XML definition is read in step S S S S and S and a corresponding instance of a screen object class defined as part of the virtual machine software is created by the virtual machine in steps S S S S and S in accordance with steps S and onward illustrated in . Each interface object is created in step S. Each instance takes as attribute values defined by the XML text associated with the element. A method of the object is further called in step S and causes a corresponding device operating system object to be created. Those attributes defined in the XML text file and stored within the virtual machine object are applied to the corresponding display object created using the device operating system in steps S S. These steps are repeated for all attributes of the virtual machine object. For any element allowing user interaction giving rise to an operating system event the event handier of the virtual machine is registered to process operating system events as detailed below.

Additionally for each event as identified by an tag and action as identified by an tag associated with each XML element the virtual machine creates a corresponding event object and action object forming part of the virtual machine software. The virtual machine further maintains a list identifying each event object and each action object and an associated identifier of an event in steps S to S.

Steps S S are repeated for each element of the screen in steps S S S S and S as illustrated in . All elements between the definition tags are so processed. After the entire screen has been so created in memory it is displayed in step S using conventional techniques.

As will be appreciated objects are specific to the type of device executing the virtual machine software. Functions initiated as a result of the XML description may require event handling. This event handling is processed by the event handler of the virtual machine in accordance with the application definition file . Similarly receipt of data from a mobile network will give rise to events. The event handler associated with a particular application presented at the device similarly processes incoming messages for that particular application. In response to the events the virtual machine creates software objects and calls functions of those objects as required by the definitions contained within the XML definitions contained within the application definition file giving rise to the event.

As noted the virtual machine software includes object classes allowing the virtual machine to create objects corresponding to an tag. The event object classes include methods specific to the mobile device that allow the device to process each of the defined XML descriptions contained within the application definition file and also allow the device to process program event flow resulting from the processing of each XML description.

Events may be handled by the virtual machine as illustrated in . Specifically as the event handler has been registered with the operating system for created objects upon occurrence of an event steps S and onward are performed in response to the operating system detecting an event.

An identifier of the event is passed to the event handler in step S. In steps S S this identifier is compared to the known list of events created as a result of steps S S. For an identified event actions associated with that event are processed in step S S. That is the virtual machine performs the action defined in the tag associated with the tag corresponding to the event giving rise to processing by the event handler . The may cause creation of a new screen as defined by a screen tag a network transmission a local storage or the like.

New screens in turn are created by invocation of the screen generation engine as detailed in . In this manner the navigation through the screens of the application is accomplished according to the definition embodied in the application definition file.

Similarly when the user wishes to communicate with the middleware server or store data locally the event handler creates instances of corresponding object classes of the virtual machine software and calls methods of the instances to transmit the data or store the data locally using the local device operating system. The format of the data stored locally is defined by the local data definition section the format of XML packages transmitted or received is defined in the network transaction package definition section . The event handler may also pass the data to the compression engine for compression before transmission.

For example data that is to be sent to the wireless network is assembled into XML packages using methods of an XML builder object. Methods defined as part of the XML builder object allow creation of a full XML package before passing the completed XML package to the compression engine . The compression engine may then pass the compressed XML package to a message server object. The message server object uses the device s network APIs to transmit the completed XML package across the wireless network.

Compressed XML packages received from the data network give rise to events processed by the event handler . Processing of the receipt of XML packages is not specifically illustrated in . However the receipt of a XML package triggers a data event recognized by the device operating system see . This data event is passed to the virtual machine and the event handler inspects the received XML package. Upon determining that the received XML package is compressed the event handler may pass the received compressed XML package to the compression engine which decompresses the XML package and passes the decompressed XML package to the event handler for further inspection. As long as the data received is a valid XML data package as contained within the application definition file the virtual machine inspects the list of recognized XML entities.

The compression scheme used by the compression engine may be specific to the application and data being exchanged. For instance in addition to providing common compression mechanisms such as PKZIP known structures of the XML data package may be reduced. For instance if both the compression engine and a corresponding compression engine at the middleware server know the format of the data being sent in response to a request the compression engine at the middleware server may shrink data to be sent into a format wherein the XML tag names are removed.

If it is known that an tag can only contain tags that the tag has a standard set of attributes and which of these attributes are required the compression engine at the middleware server may reduce the XML data package before using a standard compression algorithm to further reduce the size of the XML data package. For example under normal circumstances an XML data package may read as follows.

In an exemplary scenario a user could trigger the transmission of a login request data flow by interacting with an initial login screen defined in the application definition file for the application. The login request data flow would be passed by the middleware server to the backend application server . The backend application server according to the logic embedded within its application would return a login response data flow which the middleware server would pass to the virtual machine . Other applications running on the same or other application servers might involve different interactions the nature of such interactions being solely dependent on the functionality and logic embedded within the backend application server and remaining independent of the middleware server .

A first example message is representative of a message sent by the mobile device to request the list of applications that the middleware server has available to that user on that device. The first example message specifies a type for the mobile device using text contained by the tag pair. A second example message is representative of a message sent to the mobile device by the middleware server in response to the first example message . The second example message contains a set of tag pairs each tag pair enveloping an identity of a single application that is available to the user at the device . A third example message is representative of a message sent from the mobile device to the middleware server to request registration for a single server side application. The tags specify information about the user and the mobile device . A fourth example message is representative of a message sent to the mobile device by the middleware server in response to the third example registration request message . The tag pair envelope a code indicating success or failure. In the fourth example message shown a success is indicated by CONFIRM and is followed by an interface description for the application enveloped by the tag pair. This interface description may then be stored locally within the storage memory of the mobile device .

As noted when a user starts an interface to an application an application definition file for which has been downloaded in the manner described above the virtual machine reads the interface description section of the application definition file. The virtual machine identifies the screen that should be displayed on startup and displays the elements of the screen as detailed in relation to . The user may then use the functionality defined by the application definition file to send XML packages to and receive XML packages from the associated backend application server via the middleware server .

For the purposes of illustration illustrate the presentation of a user interface for a sample screen on a Windows CE Portable Digital Assistant. As illustrated in a first XML portion of the application definition file is an interface description for a screen with the name NewMsg . This interface description may be contained within the user interface definition section of the application definition file associated with the server side application. The screen is defined to have a single button identified by a tag which is identified as item D in with attributes NAME OK CAPTION Send INDEX 0 X 0 Y 15 HT 18 and WT 50 . This button gives rise to a single event identified by the tag that has two associated actions one defined by the tag with attribute TYPE SAVE and one defined by the tag with attribute TYPE ARML . The latter action results in the generation of an XML package defined by the tag with attribute TYPE ME which has a data format as defined enveloped by the tag pair. The package is defined to begin with a TAG with attributes MSGID FROM and SUBJECT. Additionally the interface description for the screen includes definitions for three edit boxes as enveloped by the tag pair. The definitions for the three edit boxes are identified in as lines of XML code labeled A B and C.

Upon invocation of the interface to the server side application at the mobile device the screen generation engine of the virtual machine processes the interface definition for the screen as detailed with reference to . That is for XML tag D the screen generation engine creates a button object in accordance with steps S S. Similarly for XML tag pairs A B and C within the application definition file the virtual machine creates edit box objects i.e. steps S S see . The data contained within the objects reflects the attributes of the relevant button and edit box tags contained in the application definition file associated with the server side application.

The resulting screen presented by the user interface of the mobile device is illustrated in . The user interface depicts a screen called NewMsg which uses interface items that provide a user with an ability to compose and send data. The screen illustrated in has an edit box named To corresponding to XML tag pair A in an edit box named Subject corresponding to XML tag pair B in and an edit box named Body corresponding to XML tag pair C in . The screen illustrated in also incorporates a button named OK corresponding to XML tag D in .

Call backs associated with the OK button cause graphical user interface application software as part of the operating system at the mobile device to return control to the event handler of the virtual machine . Thus as the user interacts with the user interface the user may input data within the presented screen using the mobile device API. Once data is to be exchanged with the middleware server the user may press the OK button and by doing so invoke an event which is initially handled by the operating system of the mobile device . However during the creation of the OK button in steps S S any call back associated with the button was registered to be handled by the event handler of the virtual machine . Upon completion the virtual machine receives data corresponding to the user s interaction with the user interface and packages this data into an XML package using corresponding objects. The XML package is populated according to the rules within the application definition file .

The event handler in turn processes the event caused by user interaction with the OK button in accordance with the tag and corresponding tag associated with the tag referenced as XML tag D associated with the OK button . The events and associated actions are listed as data items associated with the relevant user interface item within the application definition file .

An tag of TYPE SAVE causes the virtual machine to save the contents of the edit box named To the edit box named Subject and the edit box named Body into variables denoted by the SAVENAME attribute of each respective edit box tag.

An tag of TYPE ARML causes the virtual machine to create an object that forms an XML package for transmission to the middleware server in accordance with the format defined within the tag pair. That is a template defined beginning with the tag with attribute TYPE ME for the XML package to be sent is defined within the tag pair for a given user interface item. This template specifies the format of the XML package to be sent and may include certain variable fields. The variable fields in the formatted XML package take on contents that vary according to the values received in data entry fields on the current and previous screens. The definition of the template specifies which data entry field should be interrogated to populate a given variable field within the XML package that is to be sent.

According to the template some of the variable fields of the XML package are filled dynamically from data inserted by the user into edit boxes presented on the display of the mobile device . The template includes placeholders delimited by square brackets i.e. and . These placeholders reference a data source from which data for filling the corresponding section of the template should be obtained. A suitable data source might be a user interface field on the current screen a user interface field on a previous screen or a table in a device based logical database. The virtual machine after reading the data source name searches for the field corresponding to the referenced data source and replaces the placeholder with data contained within the named field. For example the SUBJECT attribute of the tag in the first XML portion references NewMsg.Subject . As such content for the SUBJECT attribute may be read from the edit box field named Subject on the screen named NewMsg . This process is repeated for each such placeholder until the virtual machine reading through the template has replaced all placeholders in the template with content to form an XML package.

An exemplary XML package containing data obtained as a result of input provided to the fields of the NewMsg screen is illustrated in . The exemplary XML package may have been created responsive to user interaction with the NewMsg screen which user interaction may be considered to have been culminated by interaction with the OK button see corresponding to XML tag D in the first XML portion . In this case the user has entered the text steven nextair.com into the edit box named To the text Hello Back into the edit box named Subject and the text I am responding to your message into the edit box named Body .

The virtual machine using the template inspects these three edit boxes and places the text contained within each edit box in the appropriate position in the template. For example the placeholder NewMsg.Subject is replaced by Hello Back . The virtual machine creates the exemplary XML package by invoking functionality embedded within an XML builder software object to populate the variable fields of the template contained in the first XML portion . Once the exemplary XML package has been assembled in this fashion the compression engine is employed to compress the exemplary XML package and a relevant method of the message server object is then invoked to transmit the compressed exemplary XML package across the network.

When an XML package is received the event handler of the virtual machine is notified. In response the virtual machine uses the compression engine to decompress the XML package. Subsequently the virtual machine uses the XML parser to build a list of name value pairs contained within the received XML package. Thereafter methods within an object class for processing incoming XML packages are invoked that allow the virtual machine to inspect the XML package to determine a server side application to associate with the XML package and select a corresponding application definition file. The methods within the object class for processing incoming XML packages also allow the virtual machine to inspect the application definition file to identify the fields in the device based logical database and the user interface screens that may need to be updated with new data received in the XML package. In the case wherein the user interface screens are updated such updating may be accomplished according to the procedures normal to the particular device.

Handling of incoming XML packages is defined in the application definition file . That is for each of the possible XML packages that can be received the application description file includes definitions of device based logical database tables and screen items that should be updated as well as which section of the package updates which device based logical database table or screen item. After an XML package has been received and decompressed the event handler uses rules based on the application description file to identify which device based logical database tables or screen items need to be updated.

Two example tables are defined in the second XML portion of for formatting the logical database for the e mail application. A first XML item E of the second XML portion corresponds to a first table labeled SENTITEMS in . A second XML item F of the second XML portion corresponds to a second table labeled RECIPIENTS in . The first table stores details of sent e mail messages and has four fields. The second table stores recipients of sent e mail messages and has three fields.

The third XML portion includes a first section and a second section . The first section defines how fields of a received XML package may be used to update the first table of . An example line defines how the MSGID field of the received XML package may be used to update a field named LNGMESSAGEID in the first table of . Similarly the second section defines how the fields of the received XML package may be used to update fields of the second table of .

The third XML portion is contained by an tag pair. Attributes of the tag provide rules that instruct the virtual machine as to whether data contained within an XML package of a given XML package type should be used to update tables in the device based logical database. These rules may be applied whenever an XML package of the given XML package type is sent or received.

As can be seen from the preceding description and example such an approach has significant advantages over traditional methods of deploying applications onto mobile devices. First the definition of an application s functionality is separated from the details associated with implementing such functionality thereby allowing the implementers of a mobile application to concentrate on the functionality and ignore implementation details. Second application definition files can be downloaded wirelessly wherever the device happens to be at the time at which the functionality is required. This greatly improves the usefulness of the mobile device by removing reliance on returning the device to a cradle and running a complex installation program. Third the use of application definition files allows flexible definitions for numerous applications. Server side applications may be easily ported to a number of device types.

It will be further understood that the application is not limited to the embodiments described herein which are merely illustrative of preferred embodiments and which is susceptible to modification of form arrangement of parts steps details and order of operation.

