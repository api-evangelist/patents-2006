---

title: Packaging multiple groups of read-only files of an application's components into multiple shared libraries
abstract: Multiple groups of read-only files, for use by various components of an application program in a computer, are packaged as follows. Several executable files are prepared, each executable file corresponding to a group of read-only files used by one or more components. Each executable file includes an array that has sufficient space to accommodate the group of read-only files to be packaged therein. Each array in each executable file is overwritten with data from a corresponding group of read-only files. The presence or absence of each executable file for a group of read-only files is indicated by an index that is developed during initialization of components. Retrieval of data is from the executable files, if the index indicates, on first accessing each read-only file, that the corresponding executable file is present. If the executable file is indicated by the index as being absent, then the read-only file is directly accessed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08522205&OS=08522205&RS=08522205
owner: Oracle International Corporation
number: 08522205
owner_city: Redwood Shores
owner_country: US
publication_date: 20060519
---
This application is a continuation in part application of claims priority from and incorporates by reference herein in its entirety U.S. patent application Ser. No. 10 848 635 filed on May 18 2004 and entitled PRODUCT PACKAGING AND INSTALLATION MECHANISM by Mohammad Shoaib Lari et al.

Applicant s hereby rescind any disclaimer of claim scope in the parent application namely U.S. application Ser. No. 10 848 635 or the prosecution history thereof and advise the US Patent and Trademark Office USPTO that the claims in this continuation application may be broader than any claim in the parent application. Accordingly Applicant s notify the USPTO of a need to re visit the disclaimer of claim scope in the parent application and to further re visit all prior art cited in the parent application including but not limited to cited references over which any disclaimer of claim scope was made in the parent application or the prosecution history thereof. See Hakim v. Cannon Avent Group PLC 479 F.3d 1313 Fed. Cir. 2007 . Moreover any disclaimer made in the current application should not be read into or against the parent.

Installing a software product such as tax preparation software e.g. TurboTax available from Intuit Inc. in a personal computer requires the copying of numerous files in numerous directories. Specifically when TurboTax is being installed at C Program Files TurboTax a number of subdirectories also called folders are created. For example one subdirectory is created for holding the executable ttax.exe and related shared libraries which are files with extension .dll such as cdac14ba.dll clientmesndll.dll and mvmg13n.dll another subdirectory is created for holding image files which are files with the extension .bmp such as fidelityinvestments0.bmp and cititrade0.bmp and yet another subdirectory is created for holding tax forms such as fdi02f05.1pe and fdi02ttx.1pe. Although only a handful of subdirectories have been mentioned there may be an entire tree of such subdirectories which is several levels deep. Moreover although only a few files have been mentioned above a typical installation of today s software products requires the set up and copying of 100s of files or even 1000s of files depending on the software product.

The process of installing a software product containing such a vast number of files in numerous subdirectories of which the end user has no knowledge is simplified in today s computers by use of software that is typically called an installer . The installer not only copies all necessary files from a storage medium such as one or more CD ROMs or floppy disks but also decompresses the files if necessary . The installer may also update one or more configuration files and or environment variables which reside in the computer irrespective of the software product being installed.

One prior art installer is described in U.S. Pat. No. 6 131 192 granted to Henry on Oct. 10 2000 and entitled Software Installation . According to U.S. Pat. No. 6 131 192 see column 1 lines 30 56 a single executable file containing the prior art installer may be transferred from a source such as a website on the Internet to any disk drive that can be written to and is associated with the computer to which the software product is to be installed. U.S. Pat. No. 6 131 192 also states see column 1 lines 56 62 that the same single executable file may also contain the source of a tree of files in addition to the prior art installer called shell program by U.S. Pat. No. 6 131 192 .

Such a shell program or installer of the prior art may be executed to first install the software in a temporary directory followed by among other steps a decompressing one or more individually compressed files in the tree of files b modifying the computer s configuration files and c installing of decompressed files in a target directory at which the software product is to be permanently installed . U.S. Pat. No. 6 131 192 also describes see column 3 lines 23 30 an improved installer that contains software materials necessary for the installation of a software product on a computer and that once executed searches for and uses only a small amount of temporary storage space in the process of getting the files of the software product in the target directory causes the software product to be set up on the computer and cleans up the temporary storage space. U.S. Pat. No. 6 131 192 is incorporated by reference herein in its entirety as background to this invention.

See also U.S. Pat. No. 6 718 373 granted to Bearden et al. on Apr. 6 2004 and entitled Method and system for installing files in a computing system that is also incorporated by reference herein in its entirety as background to this invention.

In accordance with the invention multiple groups of read only files are packaged for distribution to end users by preparing several executable files each executable file corresponding to a group of read only files. Each group of read only files is selected for packaging into an executable file based on any criteria e.g. files that are to be kept together for installation in the end user s computer as a single shared library also called package . Each executable file includes an array that has sufficient space to accommodate the group of read only files to be packaged into that executable file. After each executable file is created it s array is overwritten with data from the corresponding group of read only files thereby to accomplish their packaging. In some embodiments each executable file is first created by compiling a corresponding source file in which an array of the appropriate size is declared followed by overwriting of read only data of the to be packaged files into the array s location in the executable file.

Also in accordance with the invention the multiple executable files are used by a single application program that requires data from the read only files as follows. The application program such as a relational database is modified with initialization instructions which set up an index indicative of presence or absence of each executable file in a computer executing the application program. The application program is further modified to use the index whenever a read only file is first accessed e.g. via a file open function to identify an executable file if present that contains that read only file s data and to further identify a location within the executable file of data of the read only file being accessed. Thereafter read only data is accessed from the appropriate location in the executable file if present . In some embodiments all executable files containing such read only data are loaded as shared libraries by the operating system and automatically shared e.g. among multiple processes which may belong to same or different components in the application. A component is any portion of the application program that supplies a known functionality of the application program. A component typically has a directory named after it and the directory is located immediately below a root directory of the application program.

In several embodiments each component is configurable to use or not use when accessing its read only data an executable file of the type described above e.g. as a shared library. When any component is configured to not use the executable file that component stores and retrieves data to from files in the operating system in the normal manner of a programmed computer i.e. using normal file input output functions in the operating system . When the component is configured to use an executable file for its data that component is modified as described above to retrieve read only data from the executable file. The presence or absence of an executable file for each component is identified in the index.

Acts are performed in several embodiments in accordance with the invention to package a number of files A of data that can be shared e.g. by multiple instances of an application or by multiple applications which form s a software product into a single executable file A . In some embodiments all of acts are performed manually. In other embodiments some acts are preformed manually while other acts are performed automatically. Finally it is also possible for all acts to be performed automatically under manual supervision and or manual control e.g. via scripts or commands from humans . In one embodiment only acts are performed automatically specifically by a software utility executing in a computer of the type shown in called genezi which is described below in greater detail.

The genezi utility may be used either by a vendor of the application s or by an intermediary such as an Original Equipment Manufacturer OEM or by a Value Added Reseller VAR or even an information technology IT department of a large corporation . The availability of the genezi utility may be limited to only the application vendor in case of some operating systems such as Windows but available to such intermediaries in case of other operating systems such as Unix . Moreover acts and are performed manually in most embodiments. Also acts and are performed by the vendor of application s in many embodiments. However in other embodiments acts and can be performed by an intermediary of the type described above e.g. if source code is available to the intermediary. Finally acts are performed manually at an end user s computer in most embodiments. The end user may be either a customer of the application vendor or may be an employee of a corporation that employs the intermediary. An example of the application and product is the database management system called ORACLE Database 10 g available from Oracle Corporation of Redwood Shores Calif.

The files A that may be packaged by performing acts are ideally files that are read only such as files containing text and or graphic information to be displayed to humans e.g. error messages. Such files are accessed on demand basis and significant amount of disk I O takes place for events which are not really error conditions but happen routinely such as in the case of end of data null truncation and other warnings and information only messages. Using a shared library as described below to hold the data of files provides automatic caching of the data by the operating system. A shared library when referred to by a name that is operating system independent is also called a package in the following description.

Files that are to be packaged into a single executable file of some embodiments are grouped e.g. depending on whether they are used by a component which is one of several components of an application program. Each component typically supplies a well known functionality of the application program. One example of an application program is a database program such as Oracle database management system. Examples of components in a database program are 1 a command line interface for interpretation of commands input by a database administrator such as SQL Plus available from Oracle Corporation 2 import and export utilities for storing data in and retrieving data from a database such as IMP and EXP available from Oracle Corporation 3 a database interface utility which allows access to data in the database from another application program executing in the same computer such as ODP also available from Oracle Corporation which allows WINDOWS programs to access data in an Oracle database 4 database management system software such as relational database management system RDBMS software also available from Oracle Corporation and 5 Application Programming Interface API support for the database such as Oracle call interface OCI for use in operations on the database such as logon execute parse and fetch.

Read only files which are specific to each component are traditionally maintained in a subdirectory for each component under a default directory such as a directory identified by an environment variable called ORACLE HOME for the application program and each subdirectory is typically identified by that component s name. In the above described example directory ORACLE HOME ODP holds read only files used by the ODP component and directory ORACLE HOME IMP holds read only files for the IMP component. As noted elsewhere some read only files of a given component are used only by that component although other read only files of the component may be used by other components of the application program. Therefore a component has a high order directory relative to root directory ORACLE HOME e.g. located in the root directory as a subdirectory therein .

In one illustrative embodiment data in each top level ORACLE HOME directory or subdirectories thereof is packaged in only one data shared library. In this embodiment each top level directory in ORACLE HOME is considered a component and a component s files cannot be split across multiple shared libraries. For example files having names that match ORACLE HOME oracore mesg .msb and ORACLE HOME oracore zoneinfo .dat are only packaged in the same shared library because both of these sets of files belong to the same component oracore . This embodiment does not permit packaging of oracore mesg files into one shared library and oracore zoneinfo files into another shared library. In this embodiment it is possible and recommended to package read only data from several components into a single data shared library. For example the file called libociei.so for the OCI Instant Client data shared library contains data from each of ORACLE HOME rdbms mesg .msb ORACLE HOME oracore mesg .msb ORACLE HOME oracore zoneinfo .dat and ORACLE HOME nls data .nlb. Hence the file libociei.so contains data from each of the following components rdbms oracore and nls.

An act is performed in some embodiments of the invention to identify a group of files A for packaging into an executable file based on a subdirectory in which these files are traditionally maintained e.g. only the read only files for a specific component of the application program are identified in some embodiments by an application vendor or OEM as the group of files to be packaged. After a group of files A identified in act are packaged for a given component as described below in reference to act these acts are repeated for another component wherein another group of files B are identified in act resulting in another executable file B.

Although only two groups of read only files A and B and two executable files A and B are shown in note that repeated performance of acts and by looping as shown by branch in generates any number of executable files one executable file for each group of read only files identified in act i.e. one executable file for each iteration of branch . The read only files identified in act as forming a group to be packaged need not be limited to the files of a single component and instead an application vendor and or OEM may choose to identify read only files of multiple components as a group of files to be packaged when performing some embodiments of act .

Note that files A that are to be packaged may be selectively packaged by an intermediary depending on the nature of the end users to whom the shared library is to be released. For example if the end users of the shared library are Japanese then the intermediary may select as per act in only files containing information in the Japanese language e.g. only files containing error messages in the Japanese language as being the files A that are to be packaged. Selection performed in act excludes files containing the same error messages in other languages such as French German Italian Spanish and Korean.

While language is just one attribute that may be used to limit the files to be included in a shared library as will be apparent to the skilled artisan numerous such attributes e.g. character set such as ASCII or Unicode may be used by an intermediary to appropriately customize the shared library to the end user. In contrast an application vendor may include in a shared library that the vendor creates a complete set of files for a full installation of the application as to be packaged files A so that the application may be sold to a wide range of end users e.g. all languages . Note that act is an optional act and is not performed in some embodiments although in other embodiments act is performed.

An executable file that is sufficiently large to hold all such files A identified in an act as the group to be packaged is created in these embodiments by performing acts and . Specifically in act a source file A is prepared in a high level language such as the C language to contain therein at least a statement A declaring an array . The array is declared to have sufficient space to accommodate all files A that are to be packaged. The size of the array used in act depends on whether or not act is performed because act significantly reduces the size of the array to be created in act .

The size of the array declared in statement A may be determined in some of these embodiments based on the total space occupied by to be packaged files on a disk or other storage media . An array that is larger than the total size of files A may be declared in statement A depending on the embodiment to accommodate additional information such as a directory and or a listing of the names of all the files and or a description of the version of each file. However in certain embodiments such additional information may be stored in a different file in which case an array of size precisely equal to the total size of files A may be declared in statement A.

Also in some embodiments the array size may be declared in statement A to be larger than the total size of files A by a certain percentage e.g. 10 or by a fixed amount e.g. 1 MB to accommodate future needs in case of growth of data in one or more of files A for example in case a patch is applied . The precise size of the array declared in statement A is not a critical aspect of the invention as long as it is greater than or equal to the total size of files A. Note that the size of the array is typically on the order of several MBs e.g. 10 MB or 65 MB for typical applications being distributed and installed in today s world.

Source file A containing an declaration A of an appropriately sized array is then compiled and linked into an executable file A e.g. by use of a C compiler and OS linker if the source file A contains instructions expressed in the C programming language. Executable file A contains an array A that may be located after a header A that has a specific format depending on the operating system OS . Also depending on the operating system the instructions of executable code obtained by translation of source file A into machine language may be located anywhere relative to header A and array A or e.g. such code may be located following array A or preceding array A but following header A. Embodiments that are based on Linux operating system use the industry standard Executable and Linking Format ELF format for executable file A while embodiments based on the WINDOWS operating system from MICROSOFT Corporation use the Portable Executable PE standard for file A. Although the two formats differ in their inner structures both formats define a file that is divided into several parts one of which is the header A.

Embodiments that are knowledgeable about a particular operating system s executable file format find the location of array A from use of information within header A. Embodiments that do not rely on knowledge of the executable file format may use a marker to denote the beginning of array A e.g. by storing a unique bit pattern in the first few bytes of the array as discussed in greater detail in reference to . Note that in some embodiments a common marker is used in all executable files being prepared by a given application vendor and or OEM so that multiple components can use the executable files in an identical manner. The just described two classes of embodiments OS knowledgeable without marker or OS agnostic with marker have their respective advantages and disadvantages as will be apparent to the skilled artisan e.g. the latter embodiments need less maintenance .

Regardless of how the location of array A is found in the various embodiments all embodiments determine an offset for the beginning of array A relative to the beginning of executable file A. This offset is hereinafter referred to as a base address of certain space in executable file A that is available for storing the data of files A and optionally for storing the above described additional information such as a directory . Next as per act in executable file is opened for write access and array A is overwritten with data from each file being packaged file data thereby to result in file A .

At this stage as will be apparent to the skilled artisan in view of this disclosure overwritten executable file A contains the data of numerous files that were otherwise being distributed to end users. As noted above the files A whose read only data is present in executable file A may be selected by performance of act in which case the number of files A that are packaged is smaller than if all such files of a component were included. Distribution of a single executable file A for one or more components eliminates the need to distribute the numerous read only files as was done for each prior art component. Therefore several embodiments distribute just one pair of executable files for each of several components of an application namely a data file A and a code file . Data file A contains the read only data needed by the component while code file contains software instructions to be executed by computer to perform functionality of the component. Hence in many embodiments of the invention code file has been modified to access its read only data directly from the above described array in data file A thereby to eliminate extraction of a read only file from data file A and installation of each individual read only file .

Specifically as illustrated by act in application files in source form are edited manually in most embodiments although automatic editing can also be done in some alternative embodiments to replace within each component s each file input output command that is normally serviced by the operating system with software to access and use one or more files in that component s executable file. Note that in some embodiments the changes are limited to a low level layer of software in which file input output instructions are changed. In one such embodiment the changes to the application are to use a set of functions called virtual file system which conditionally use a shared library e.g. file A for component X and file B for component Y both files are shown in on a predetermined library path as discussed in detail below .

While the applications of some embodiments are programmed to access the files A and B only conditionally e.g. after checking that the respective files A and B exists and if one of them doesn t exist then defaulting to the operating system other embodiments use the files A and B unconditionally i.e. not rely on the operating system for any of files A that have been packaged into file A or for any of files B that have been packaged into file B .

Next the modified application files not shown in are compiled in the normal manner as per act in resulting in one or more executable files for the modified application s . Therefore it is these modified application executable files that are distributed to end users along with the overwritten executable files A and B for the respective components X and Y. Note that only one executable file A may be distributed to an end user that uses only the corresponding component X i.e. executable file B need not be supplied to an end user if that end user does not use component Y .

In several embodiments in act the end user s operating system is instructed to treat the overwritten executable files A and B of the type described above as shared libraries e.g. as .so files in Solaris or Dynamic Link Library e.g. as .dll files in WINDOWS . In doing so the operating system loads the executable files A and B in a shareable manner as illustrated in . Specifically although any given executable file A or B may be fairly large e.g. 65 MB in size that particular file is not loaded into physical memory in its entirety when a process A of application A executes. Instead a process A of a component X reserves address space of the size of the executable files it will access such as files A and B in preparation for addressing the file data located herein but only one or more pages of files A and B are loaded by the operating system into physical memory as and when needed. For this reason in only a single page J of file A and only a single page K of file B are shown loaded in memory and in use by process A of component X.

In many embodiments of the invention application files contain a low level layer of software which in turn contains initialization instructions to set up an index for one or more executable files A C that may be present in the computer in which the application program executes. The index is created when each of processes A C executes initialization instructions which set up the index in a read write memory of the respective processes. In several embodiments each process A B and C has its own copy of the index in its own private read write memory. Indices are created for each process on an as needed basis in these embodiments. Hence if process A uses component X then it only has a copy of the index for X. It is the usage of an index by a process that determines the creation of the index for that process. However in an alternative embodiment a common index is used in all the processes and this common index has the same size and the same entries in each process regardless of component.

The index identifies for example the name of the component to which a current process belongs a name of a corresponding executable file and whether or not the executable file is present in computer . An illustrative example of entries in such an index are provided in the following table with the status indicator flag value of 1 indicates shared library mode indicating presence of the executable file whereas 0 indicates default mode using read only files in the normal manner.

In some embodiments initialization instructions use a predefined syntax to convert each component s name into the corresponding executable file s name e.g. by adding lib before the component s name and by adding .dll or .so after the component s name . Initialization instructions further check for the presence or absence of executable files needed by the current process in a predetermined path such as the default directory for the application e.g. the logical name ORACLE HOME and record the result of checking in the index.

Depending on the embodiment the index may be implemented in the memory of computer in any manner such as a hash table or alternatively as a linked list as illustrated in Appendix C below. For a small number of components and packages a linked list approach is faster because the hash tables have overhead of computing the hash function and organizing buckets etc. However for a large number of components and packages the link list approach becomes costly especially for components or packages stored at the end of the list. For a fixed number of components for packages an array can also be used. This will cost more memory and will not be extensible beyond the array size but it will be the fastest approach. Further depending on the embodiment the index may be held in volatile or non volatile memory and accessed by a predetermined data structure and or predetermined software of the type required for a hash table or a linked list . Also depending on the embodiment the index may or may not be maintained in a global memory e.g. SGA memory or PGA memory in case of the Oracle database that is available to all components in the application. When read only data is first needed from a corresponding read only file each process executes instructions to first use the predetermined data structure to access the index to find out whether or not the corresponding executable file is present for the read only data being sought and thereafter executes accordingly.

When another process B of component X that also uses files A and B is executed this process B also reserves address space of the size of files A and B. If process B needs the same read only data as process A or read only data from the same pages J and K then the operating system does not load additional copies of pages J and K into the physical memory for use by process B. Instead the operating system automatically translates the virtual addresses in process B to physical addresses which access the physical memory appropriately as shown by arrows A and B in to enable process B to directly access pages J and K that are already in memory. Therefore instructing the operating system to treat files A and B as shared libraries as per act in uses less memory than if each process were to receive its own copy of files A and B in physical memory.

In the example illustrated in executable file B holds the read only data for component Y whereas executable file A holds the read only data for component X. Note that component X uses not only its own read only data but also uses component Y s read only data. For this reason process A of component X has been shown in as having accessed and loaded into memory the two pages J and K from the two files A and B. At this stage if a process C of component Y needs the read only data in page K of file B and as this page is already loaded into physical memory by process A as a shared library the operating system automatically translates as shown by arrow C the virtual addresses in process C to physical addresses which access the read only data from page K in physical memory. For example if component X is SQL Plus then it loads not only it s own executable file but also the executable file of another component Y namely OCI and so when an OCI process C is started it simply uses the read only data loaded into memory by the SQL Plus process A .

Therefore when files A C are installed as shared libraries multiple instances of an application or multiple applications efficiently use as per act in a single copy of each file or a portion thereof which is in physical memory. Note however that in other embodiments of act one or more of executable files A C may be installed as non shareable files. And in still other embodiments instead of an executable file a data file is used to hold read only data of multiple read only files via memory mapping I O in an alternative act to support a virtual directory as discussed in the next paragraph in which case the above described acts of preparing a source file as per act in and compiling the source file as per act are avoided.

An alternative embodiment in accordance with the invention creates a data file containing read only information from to be packaged files A in the normal format of a binary file and the data file is used directly via memory mapping functions of the operating system in the end user s computer. Note that in this alternative embodiment the data file is created instead of creating an executable file A or overwritten file A and for this reason the data file does not have header A for example. Since the data file of this embodiment contains read only data so this data file is mapped by the application in a share able manner such as using the MAP SHARED flag on Unix. A virtual directory also included in the data file of this embodiment provides information about the memory region where each of packaged files A is mapped offset and size and the memory mapping function of the operating system such as mmap on Unix returns a memory pointer to the data of each individual read only file after the mapping is done. The Unix mmap function allows access to resources using address space manipulations instead of the read write interface.

Once a file is mapped by mmap all a process has to do to access the file is simply use data at the address to which the file is mapped. In this embodiment a virtual file system is implemented with a read function e.g. lfvread that simply copies data from the location of a given file which is a memory location to the end user s buffer just as it does in embodiments that use overwritten executable file A. When a file is closed by the application the alternative embodiment s virtual file system implements a close function to unmap the address space of the specific file that is being closed by using the operating system s memory unmap function such as munmap on Unix .

Another embodiment also does not use a compiler linker but does in fact create an operating system specific executable file e.g. the ELF format or PE format file as described above . In this embodiment an application is knowledgeable about the executable format of the end user s operating system and uses this format to directly generate file A for example by opening a file for write access followed by writing of header A followed by writing of a blank array with array size determined from the total size of files A as noted above. File A may be directly generated in this manner either as an object file or as an executable file depending on the implementation.

As noted above in this embodiment when generating executable file A directly a compiler linker is not used because a source file is not even created . Thereafter data from files A is used to overwrite executable file A in a location therein where the array is present resulting in overwritten executable file A. During overwriting the array s location as known from knowledge of the executable file s format may be used in some implementations although other implementations may use a marker as described above.

Yet another embodiment directly generates an executable file A that already contains the information from files A without generating file A. Specifically this embodiment uses the known file format to insert all the necessary information for header A followed by insertion of information from files A at the location where the array would have been located followed by any necessary information at the end of file A such end of file information e.g. a checksum may or may not be present depending on the individual file format .

Although several embodiments have been described above in reference to one exemplary embodiment is described below in reference to with the understanding that this description is merely illustrative and is not to be used to limit the scope of the invention. Specifically in the exemplary embodiment of an overwritten executable file is prepared in a manner similar to that discussed above for file A except for a few differences as noted below. File includes a marker that helps in locating the beginning of the array. Moreover the array of file is used to store therein not only the file data of all the files being packaged but also certain additional information about these files in two additional structures one structure is called virtual directory and is further illustrated in while another structure is a list of null terminated character strings of the names of all files.

Virtual directory structure of this exemplary embodiment contains an entry i.e. record with four fields for each file stored in overwritten executable file an offset of where each file s data begins in the executable file file address another offset of where each file s name begins in file list structure the size of each file and file attributes such as the version number of the file and or creation date . The just described offsets are relative to the beginning of the above described base address of the array in file . For example the file address of the first file in directory is equal to the sum of the size of directory and the size of file names list and the offset of the first file s name is simply the size of directory . The size of directory may be calculated as the number of files 4 bytes 3 128 bytes assuming there are three fields two offsets and one size of size 4 bytes and one field attributes of size 128.

In the exemplary embodiment calculation of the size of the directory depends on the number of files that are to be packaged. Therefore a directory tree on a disk where the files are currently located is traversed to accumulate all information necessary to prepare the source file not shown in . Specifically during such traversal as illustrated by act in the size of each file s data is determined by end user s computer to obtain an estimate of the size of file data and the size of each file s name is also determined to obtain an estimate of the size of file names list . As noted above the number of files is also determined to obtain an estimate of the size of virtual directory structure . Thereafter as per act the size of the array to be declared is determined as the sum of the size of each file s data the size of each file s name and the number of files to be packaged size of an entry in directory structure .

In addition during the tree traversal the file names are also accumulated for future use in act discussed below . Next as per act the source file is prepared to contain an array of the size that is determined in act . The source file of this embodiment is also prepared to include a marker such as predetermined bit pattern that is for example 16 bytes long. Next the source file is compiled as per act resulting in an executable file that is overwritten as discussed next.

Specifically as per act the executable file is opened for write access by computer of an application vendor. Next as per act the executable file is scanned until the marker is found. Then space in the executable file sufficient to accommodate the virtual directory i.e. size of directory calculated as noted above is skipped and the names of all files that are to be packaged are written as per act into the list . In this particular embodiment the file names that were accumulated in act are sorted in alphabetical order and the sorted names are written into list although in other embodiments the file names may be written unsorted.

Also as per act the above described directory tree is traversed again although this time the files are read in alphabetical order and the data in each file is copied into the executable file starting with the first file s data located immediately after file list . After each file is copied the actual number of bytes that have been copied for the file as well as the offset for beginning of the file data for this file are stored in a data structure in memory that has the same structure as the virtual directory of except for being located in memory rather than on disk . Note that the offset for the file name was already inserted in this structure at the time the file names were written into list . Next the offset for the beginning of a next file is calculated and used in the next iteration for copying the data of the next file. After the data of all files has been copied the data structure in memory is written to the disk as per act i.e. into the space for virtual directory in the executable file .

Executable file that has been overwritten as discussed above is then distributed with the application files to end users for installation in their computers. After installation the file data in executable file is used by one or more application s as follows if the shared library is present a binary search is performed on virtual directory to find an entry for a file of a given name e.g. the file name is compared with a file name at the center of directory and if on the left side then the process is repeated on the left side and if on the right side the process is repeated on the right side . Once an entry for the file is found then the corresponding offset of file data is used as a file pointer and file data is read sequentially until the file size amount of data has been read .

In act computer checks to see if a shared library with a name for the executable file corresponding to the current component s name e.g. obtained by use of a predetermined syntax is present in computerl wherein the application program is executing. For example computer may use the component name SQL Plus to obtain the executable file name libsqlplusic.so for use in the Unix operating system as follows. Computer prepends the string lib and appends the string ic.so to the component name. Next computer invokes a function dlopen of the UNIX operating system. Note that in the WINDOWS operating system computer prepends ora and appends the release number and further appends .dll to the component name e.g. resulting in executable file name orasqlplusic10.dll for the component SQL Plus .

Depending on the embodiment act can check a the presence of the shared library in a library path of the operating system or b a setting in an environment variable such as LD LIBRARY PATH or c the presence of the library in a directory determined by an environment variable. For example computer may attempt to load the shared library from a location specified in an environment variable that is identified in the initialization instructions of the application program .

If the answer in act is no computer goes to act and marks the current component for DEFAULT mode operation. Note that when a component operates in the DEFAULT mode normal file input output functions in the operating system are used e.g. normal file I O is performed . Thereafter computer goes to act to check if all components in the application have been initialized and if not returns to act described above . If all components in the current application have been initialized computer goes to operation which uses the index to access read only data from the executable files for which entries have been made in the index as described after the following paragraph.

In act if the answer is yes computer goes to act to initialize the virtual file system in the shared library mode for the current component e.g. by loading shared library package for current component. Thereafter the computer goes to act to associate shared library package with component e.g. by making an entry for the current component in the index with the status indicator flag set to SHARED LIBRARY MODE and the file handle for the executable file of the current component to the value for the file handle returned by the function call to the operating system. Next computer proceeds to act described above .

An illustrative implementation of operation is provided in wherein computer performs act whenever a read only file is to be accessed. In act computer receives a full path name of the read only file and thereafter goes to act . In act computer retrieves the component s name from within the full path name of the read only file e.g. by parsing the full path name into its portions such as the initial portion identifying the default directory and the remaining portion identifying a path relative to the default directory i.e. a relative path followed by checking if the environment variable for the current location of the process is same as the relative path and if so then extracting the first token from the relative path and using that first token as the component name. Then computer uses the just retrieved component name to lookup the index which is a hash table in the embodiment illustrated in . Note that in some embodiments entries in the index are stored sorted in lexical order e.g. based on alphanumeric codes for characters in path names . The just described sorting enables binary search of the index at runtime based on the component name. Next in act the computer checks to see if the component is operating in the shared library mode as indicated by a value for status indicator flag received from the index.

If the answer in act is no computer goes to act to use a normal file input output function of the operating system such as fopen i.e. operates in DEFAULT mode . If the answer in act is yes the computer goes to act to retrieve from the index the handle in the operating system for the executable file which contains the read only data that is currently sought. Next computer goes to act to load into memory if necessary and use the executable file in the shared library mode to access and use the read only data therein.

Note that although several acts are shown in the attached figures as being performed one after another there may be any number of acts that occur between such acts. For example although after performance of act the next act is performed directly thereafter as shown in in some embodiments additional acts are performed as discussed next. Specifically in act the executable file is scanned even after the marker is found in act to see if the end of file EOF is reached or if another copy of the marker is found as per act . If another copy of the marker is found which is an unlikely coincidence then a different marker is selected as per act followed by preparation of the source file now using this different marker as per act . If in act another copy of the marker is not found then act is performed in the above described manner.

In some embodiments acts shown in are automatically performed in a computer that is programmed with a utility function called genezi which is described next for details see Appendices A and B which are incorporated by reference herein in their entirety . Specifically the utility genezi takes as input the list of directories and file extensions to locate all the read only files of one or more components that are to be packaged into the shared library executable file . The utility genezi is executed from a home directory e.g. as specified in the environment variable ORACLE HOME and all the directories in the argument list are with respect to the current directory. For example to create the ociei.c file the genezi utility is invoked as 

The flag create means to create the ociei.c source file A described above in reference to . The first argument is a string containing a space separated list of directories and the second argument is another string containing a space separated list of file extensions. Please note that the path separator character such as on Unix is platform specific.

The utility genezi first determines the list of files by searching the specified directories for any files with the specified extensions. It stores the relative path names and sizes for each file internally. It then adds all file sizes and names plus directory information to come up with the size of the array . In computing the sizes each file size is rounded up and so is a file names array. The file names array is a serial byte array of offsets to all file names i.e. pointers where a null terminated string for each file name is stored. Pseudo code for the create routine in the utility genezi is listed in Appendix A located at the end of this detailed description just before the claims.

Secondly the source .c file such as ociei.c created in the above step is compiled and linked into a shared library such as libociei.so using the C compiler and the native linker of the operating system. Note that the shared library at this stage is empty because the large array in the data segment of the library does not have any data in it. As noted below in greater detail in some embodiments the text segment of the library has a callback routine that can be called from any module that has loaded the shared library using a loader. Specifically one embodiment uses a Load Program Module LPM which tries to locate and load a shared library based on the name i.e. package s name . In this embodiment the package name such as ociei gets translated to an operating system specific shared library name such as libociei.so on Unix or oraociei10.dll on Windows etc. . LPM of this embodiment also exports entry point callbacks from the package so that users of the shared library can call functions in the shared library.

The callback routine described in the previous paragraph takes a filename relative to a root directory of a read only file whose data is being sought and returns file size and pointer to the beginning of read only data for that file. As noted above several embodiments use ORACLE HOME as the root directory and all components are installed in this root directory. In these embodiments all file requests happen with respect to the root directory i.e. ORACLE HOME. Hence the application program prepares all its file I O requests using the value of the ORACLE HOME directory as a prefix to create an full absolute path name that is then used to do the file I O. File open routines which service the file I O requests based on use of the executable file in the shared library mode discard the root directory name i.e. ORACLE HOME from the full path name to get the relative path name and search the shared library for the file.

In some embodiments a root directory name i.e. ORACLE HOME is no longer necessary when all data has been bundled into shared libraries initialization of the environment variable for the root directory name i.e. ORACLE HOME is not required. Hence when the root directory name i.e. ORACLE HOME is not set then the application program internally sets it to a placeholder value such as . . This way the file names are still generated using the environment variable i.e. ORACLE HOME. In this situation the environment variable ORACLE HOME is a virtual name because it is internally set to a temporary name.

In a third step utility genezi uses the same list of directories and file extensions that were used to create the empty shared library in the earlier phase . As before utility genezi must be executed from the home directory e.g. ORACLE HOME and all file names in the argument list are with respect to ORACLE HOME. For example to store the files in the empty shared library created in the earlier phase the utility is invoked as 

The flag store means to store the data files in the shared library. The first argument is the platform specific filename of the shared library to be operated upon and the second argument is a string containing a space separated list of directories. The third argument is another string containing a space separated list of file extensions. Please note that the path separator character such as on Unix is platform specific.

The utility genezi first locates the marker e.g. defined OCIEI PATTERN within the shared library. Once pattern is uniquely found the beginning of the array also called ocieiFileBuffer array is located. The utility genezi then iterates over all the file names specified by the directory and extension lists and stores them in an internal fnames array. This array is then sorted in alphabetical order so that the callback function also called ocieiGetFileBuffer routine in the shared library can perform a binary search to locate file records. After the sort the sorted names array is written into the shared library at the appropriate places in the ocieiFileBuffer array.

The utility genezi then iterates over the sorted names list to read each file and writes its data in the file data area in the ocieiFileBuffer array. The actual number of bytes and its offset in the ocieiFileBuffer is noted in an internal frecs records array which contains directory information for all files. After contents of all the files have been written the frecs record is written in the shared library executable file . Pseudo code for the store routine in the utility genezi is listed in Appendix B located at the end of this detailed description just before the claims.

A virtual file system is implemented in some embodiments to provide a transparent interface to application s that access the read only files data in the executable file in the same manner as if the read only files were located in a directory and accessed through the operating system e.g. file open file seek file read and file close are implemented on the executable file as discussed next. Specifically a low level layer of file input output functions that is already used by the application is modified to check for installation of a given component s executable file as a shared library. If the shared library exists then each file open by a process of the component results in the low level layer making an invocation of a callback function such as the ocieiGetFileBuffer routine in the shared library that provides access to file data in executable file .

Such a call back function may be located in executable file for example between the header and the marker or alternatively after the file data but before the end of file. The callback function returns a pointer to the beginning of the file data of the named file. After that the low level layer function translates every file read by the application to accessing bytes from the array in file . A simulated file pointer is kept in the low level layer for each file thus opened and the low level layer also checks for reading beyond the available data e.g. by use of file size as an upper limit on the application s file pointer relative to the file data offset . A simulated EOF is promptly returned by the low level layer when all the data from a file has been read.

Specifically in one embodiment the application tries to load the executable file. If the executable file can be successfully loaded then virtual file system initialization such as function lfvinit in Appendix C which appendix is also incorporated by reference herein and is listed just before the claims makes an entry in the index to indicate the existence of shared library file to the virtual file system e.g. sets a status indicator flag in an index implemented as a hash table to the constant LFV SHL MODE . The callback descriptor of the function in executable file also called ociei package is passed to the initialization function in the virtual file system such as the function lfvinit in Appendix C for usage in calling the package s ocieiGetFileBuffer callback function.

The virtual file system LFV see Appendix C uses it s own data structures for error handling and returns error codes for error conditions. Examples of error conditions are file not found or file not accessible due to insufficient privileges etc. The virtual file system LFV generates its own file handles of type lfvf e.g. see Appendix C . The file handle has a pointer to file data in the shared library and the file size information. A position cursor is maintained in the lfvf file handle for read and seek operations. Upon completion of read operations the file handles are closed to free storage allocated for them. The virtual file system LFV is read only.

During operation if an environment variable called ORACLE HOME is not set then it is set to . i.e. the current directory. This is because file I O routines in the files generate an absolute filename by prepending ORACLE HOME to it so a virtual ORACLE HOME is necessary. The LFV layer removes the ORACLE HOME substring from the file path of a specific file to determine the relative file path. To keep track of the current ORACLE HOME the ORACLE HOME value is also passed to the virtual file system initialization function lfvinit. In this embodiment the value of ORACLE HOME has to be passed to the virtual file system LFV so that the LFV functions can remove it from the path names that they receive on being invoked.

Although in some embodiments an executable file is used to hold data from files such an executable file can also be used to hold a file A of other information such as information about the version of each file being packaged and or patches applied to the packaged file s . This file A which identifies the version of each of the remaining files is also called inventory file . This file A may be stored in a corresponding executable file that is called inventory library executable file which is different from the executable file containing read only data of the remaining files A .

In preparing the inventory library executable file the above described virtual file system is used by creating a .c file for the inventory library executable file and this .c file contains an array of characters to hold the inventory file A. This character array in the inventory library executable file is updated during the build of the shared library executable file to a meaningful version string.

In one particular embodiment a version banner e.g. in the form of a 5 digit number is included in the inventory file. Moreover in this embodiment a function to get the library s version banner is included in the inventory library executable file and when invoked it returns a string representation of the version of shared library executable file which depends on the platform as follows 32 bit platform Client Shared Library 32 bit 10.01.00.02.00 for 32 bit 64 bit platform Client Shared Library 64 bit 10.01.00.02.00 for 64 bit

Moreover another function similar to the above described function is also included in the inventory library executable file and this function returns a pointer to a string value of the version as well as any related data stored in the shared library.

One example of storage of related data is storage of the Patch information. Patch information is maintained in some embodiments as follows. First an inventory file which lists the version of all files being packaged is generated as follows by use of a utility called opatch 

Next an archiver utility called ar is used as shown below. This ar utility included in for example the operating system SunOS 5.6 available from Sun Microsystems Inc. of Santa Clara Calif. maintains groups of files combined into a single archive file. Its main use is to create and update library files. Therefore the ar utility is used to extract an object file named with the extension .o from an archive file called libclient10.a while maintaining the version as follows 

Next inventory entries now in opatchinv.out which was generated from opatch utility as noted above are added into the object file which was generated by the ar utility as follows 

Computers and described above can be implemented by hardware that forms a computer system as illustrated in . Specifically computer system includes a bus or other communication mechanism for communicating information and a processor coupled with bus for processing information. Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

As described elsewhere herein product packaging and installation is provided by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Common forms of computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . Local network may interconnect multiple computers as described above . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and network both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface . In accordance with the invention one such downloaded application provides for implementing product packaging and installation of database management systems as described herein.

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

Note that some embodiments avoid parsing overhead of file pathnames by limiting each executable file to storage of read only data to files accessed only relative to a default directory for the application e.g. as specified in the environment variable ORACLE HOME . Again for the same reason in some embodiments read only data in each component s directory or subdirectories thereof under the default directory are packaged in only one data shared library i.e. only one executable file. Hence if each top level directory in ORACLE HOME can be considered a component then a component s files are prohibited from being split across multiple shared libraries. For example files matching ORACLE HOME oracore mesg .msb and ORACLE HOME oracore zoneinfo .dat can be packaged in the same shared library because both of these sets of files belong to the same oracore component. Hence one cannot package oracore mesg files in one shared library and oracore zoneinfo files in another shared library.

Moreover some embodiments package data from several components into a single data shared library. For example a shared library in an executable file of name libociei.so for the OCI Instant Client data contains read only data from ORACLE HOME rdbms mesg .msb ORACLE HOME oracore mesg .msb ORACLE HOME oracore zoneinfo .dat and ORACLE HOME nls data .nlb. Hence this is an illustration wherein a single executable file libociei.so contains data from the following multiple components rdbms oracore and the nls.

Numerous modifications and adaptations of the embodiments described herein will be apparent to the skilled artisan in view of the disclosure. For example although in some embodiments the acts of are performed automatically by a programmed computer in other embodiments one or more of such acts are performed by the computer under manual direction by a human .

Although in some embodiments a single executable file is used as described above in other embodiments the above described file address and or file size and or file name are stored in one or more file s that are in addition to the executable file in which the above described file data is stored . For example the virtual directory may be stored in a different file altogether. As another example file names list may also be stored in the different file containing the virtual directory or in yet another different file. The just described different files may each be a simple data file or another executable file of the type described above. Alternatively each file name may be stored adjacent to where ever the data for each file is written either preceding such data or following such data although such storage is likely to cause the pages containing each file name to be loaded in memory during a search to locate the file.

Furthermore although in some embodiments the data of all to be packaged files A of one or more components is placed into a single array in a single executable file A in other embodiments such files are grouped into two or more subgroups and data from each subgroup of files is then stored in its own executable file A thereby resulting in as many executable files A for a given component as there are subgroups.

Some embodiments use a predetermined criterion such as a sub directory name or a file extension to enable an application vendor or an intermediary to identify and hence select each group of files that are to be packaged in a corresponding executable file. In such embodiments the virtual file system LFV described above is enhanced to handle multiple executables as follows. In one embodiment a selected file path prefix such as ORACLE HOME rdbms of the to be packaged files and a corresponding executable file which is to contain files in the file path prefix is registered to by identification to a function in the virtual files system LFV. In many such embodiments the prefix and the executable name are stored in a hash table.

In the just described embodiments that create multiple executable files any subsequent file open request to the virtual file system by invocation of a function such as lfvopen parses the full file path identified in the request and locates from among several executables in the hash table one executable file that matches the registered file path prefix. For example all files belonging to ORACLE HOME rdbms can be packaged in an executable file of the name librdbms.so. Then invocation of the function lfvopen in the virtual file system with ORACLE HOME rdbms mesg english.msb as the argument uses the hash table to return a file buffer in the librdbms.so executable file.

Although some implementations of the correspondence being made between partial file paths and executable file names use a hash table other implementations can use a sorted array with two fields in each element of the array the fields being partial path name and a pointer to a call back routine in the corresponding executable . Moreover alternative embodiments can use file extensions suffixes instead of file path prefix to be associated with i.e. correspond to a matching executable file.

Moreover although in some embodiments an array is declared in order to generate an executable file that is sufficiently large to hold the files being packaged in other embodiments such an array may be not declared. Instead an source file that has a function to access the file data is first created and this source file does not have i.e. is devoid of any statement declaring the array. After the executable file is created that executable file is extended beyond its end to accommodate the file data and related information e.g. virtual directory and file names list and the size of this information being added is stored at a predetermined location relative to the new end of file e.g. immediately there before . For more information on extending an executable file see the article entitled Writing custom data to executable files in Windows and Linux by Daniel Polistchuck available on the Internet at community.borland.com article 0 1410 27979 00.html. This article is incorporated by reference herein in its entirety.

Also storage and use of the file size field in the virtual directory may be avoided in some embodiments e.g. if a special bit pattern e.g. one or more EOF characters is used to denote where each file s data ends in the executable file. Moreover in some embodiments other information may also be stored in executable file e.g. a version number of the executable file is itself stored in one embodiment e.g. between the marker and the virtual directory.

Some embodiments do not use an executable file as a shared library and instead the executable file which contains read only data is linked with the code file which contains software instructions of a component so that a single binary image is generated for the component. Such use of the executable file makes the component self sufficient eliminating the need to invoke the operating system whenever read only data needs to be accessed. Although the file size of such a component may be large due to presence of the entire read only data that may be needed by the component such a file resides on disk and read only data is loaded into memory on an as needed basis one page at a time in the normal manner by the operating system. In several such embodiments the above described use of an index is maintained unchanged in such a binary image for the component which includes the read only data whereas other embodiments eliminate initialization and use of an index because no checking is needed when the read only data of a component is known to be locally present within the binary image which also contains the software instructions for the component.

In some embodiments instead of packaging read only data files into a data shared library which is separate from the file s containing software instructions the read only data files are packaged directly into the code shared library of the component. Also for statically linked applications which do not use a shared library the data files are packaged into the .a file of the component. Also some embodiments provide a facility to third party clients of OCI component to package their read only data files into a data or code shared library or statically linked executable. See and the related description above.

Many embodiments use multiple data shared libraries i.e. multiple executables to facilitate development and integration of shared libraries across and within organizations. In some embodiments LPM implements a limit of 100 packages i.e. executable files for data shared libraries . In such embodiments OCI reserves packages for its dynamic user callbacks and reserves packages for future enhancements and so LFV only allows registration of up to a maximum of 80 libraries in the index e.g. hash table or linked list of a single application.

Dynamic User Callbacks described in the previous paragraph is a feature of OCI that allows user created code shared libraries to be loaded at OCI Initialization time to register callbacks for OCI function calls. This feature also uses the Load Program Module LPM described above. Hence the limitation of 80 shared libraries packages .

Some embodiments use the utility genezi with the following functionality. In addition to creating an LPM loadable data shared library the genezi utility supports packaging read only data files in an object file that can be linked into either the code library of the component or a statically linked executable using the component. The genezi utility supports listing of all the data files in a code or data shared library or executable file. The genezi utility extracts an individual file s data from the packaged data files in the executable file which is useful for retrieving patching maintenance information. Moreover the just described genezi functions are made accessible to third party libraries and executables.

In some embodiments a data shared library is regenerated in an ORACLE HOME directory of the application vendor and or OEM. However in other embodiments the end user s computer has a compiler and linker available and the end user s computer actually compiles and links the .c file generated by genezi.

In some embodiments the directory ORACLE HOME lib appears on the Library Path and ORACLE HOME lib is located after the directory which contains the executable files e.g. the executable files are kept in ORACLE HOME . Moreover the components which use executable files have version numbers newer or at the same level as the versions of the components that use individual read only files in the component s subdirectory under ORACLE HOME. Such configuration of the directories and files has the effect of invoking components that use executable files if present but rest of the components operate from their ORACLE HOME subdirectories in the normal manner.

Some embodiments of initialization instructions such as the function lfvini keep the status indicator flag of a component in global shared memory of the application such as LFV global and usage of a data shared library to access read only data is made transparent to the component. In some such embodiments the component s file I O routine queries LFV global using the function lfvtype to find out if the function lfvopen needs to be used while in other embodiments the components use a low level file I O layer and it is the low level file I O layer which is changed to use the data shared library transparently. Please note that for new code application can simply use lfv for both regular and virtual file I O.

In a first variation of the just described embodiments initialization instructions simply return a component data library handle to its caller. This handle is a handle to the package returned by LPM. That is this is the context by which the entry point BufferCallback can be invoked to get data from the package. If this handle is not NULL then this component library handle is used with the file opening function lfvopen to open the file etc. While architecturally elegant this approach makes all components very much aware of their use of executable files to hold read only data. That is the components of such embodiments keep track of the component data library handle and pass it to the lowest level file I O routine. Such embodiments require code changes in components that use shared data libraries.

The second variation of the just described embodiments makes LFV general enough that any default directory rather than ORACLE HOME can be used. In this case the definition of a component is not based on the environment variable ORACLE HOME. Hence any directory path can be registered in the index as the home of a component that matches a given library name. In these embodiments the function lfvopen parses the full path name to match any portion thereof with any of the registered homes and in case of a match identifies the appropriate data shared library. In these embodiments the parsing overhead has a slight performance impact to support the flexibility.

So while the components are ORACLE HOME based the LFV Directory interface for third party executables allows a generic directory to be used as a HOME but then it cannot use the full pathname based lfvopen. The directory based approach has to use lfvinid to get a directory handle and then open files using lfvopend in the context of the directory handle.

Note that Appendix D below illustrates in pseudo code form an example of a source file A described above in reference to .

