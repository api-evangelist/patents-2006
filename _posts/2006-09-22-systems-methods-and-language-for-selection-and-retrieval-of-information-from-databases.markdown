---

title: Systems, methods, and language for selection and retrieval of information from databases
abstract: The invention provides a system configured to enable a first entity to query a second entity for a result, the system comprising a language specification component and an interface between the first entity and the second entity. The language specification component defines a communications language by which the first and second entities can communicate with each other. The interface is operable to receive from the second entity an instance of a generic request that is specific to the second entity, the instance of the generic request providing information about at least one query element that is supported in a second-entity specific request; and convert a first query from the first entity to the second entity into a second query, wherein the second query includes the at least one query element that is supported in the second-entity specific request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07747569&OS=07747569&RS=07747569
owner: Raytheon Company
number: 07747569
owner_city: Waltham
owner_country: US
publication_date: 20060922
---
Embodiments of the invention generally relate to devices systems and methods for databases and methods for accessing such databases. More particularly the invention relates to systems and methods that enable applications to query and retrieve data from databases having varying architectures and interfaces.

Interoperability is one of the biggest problems facing businesses and agencies that operate in data rich environments. One common problem is that many new systems that come on line can only communicate with other systems if the new system develops custom interfaces to the other systems. Many businesses and government organizations are continually working to get data such as intelligence data from the collection source into the hands of users such as analysts in an efficient manner. For example the Intelligence Community is continually searching to find a way to make their programs interoperable. Data is being collected yet is not finding its way to the appropriate analysts. Frequently this is due to incompatibility between the data source and the analysis application. Other times the problem is a matter of geography. For example an analyst is at one site and the archive is at another with no means to query between the two.

Although efforts are being expended to resolve geographical issues issues relating to incompatibility are rarely addressed adequately. Further because of tight budgets at many government agencies features such as interoperability are sometimes viewed as an unnecessary luxury.

Another reason that past efforts have not always succeeded is that there often is little to no benefit to the developers of the data archive systems to make their data more accessible. Rather limiting accessibility to data can provide a strategic or business advantage to the holder of a data archive system. For example by maintaining a firm hold on the data from collection through analysis these developers can exercise monopolistic control over who and what can see their data.

Past efforts to resolve some of these problems have focused on using so called data brokers object brokers network control programs and other forms of middleware having varying levels of complexity. Middleware can for example include software that sits between two or more types of software and translates information between them software that provides a common application programming interface API and or software development tools that enable user to create programs by selecting services and linking the services with a scripting language. While solutions such as middleware sometimes work in the short term effort has to go into maintaining those tools and updating them when new data sources come online. Also many middleware data brokers and complexity levels are developed and or centered on a specific Community of Interest COI and unfortunately may not be as useful to some other communities such as the Intelligence community.

In addition some middleware is information centric attaching meaning to the data that it is linking or translating. This so called heavyweight middleware tends to use significant amounts of memory and processor resources which may increase the complexity cost and size of the middleware.

While solutions such as those described above may be adequate in the short term they are very costly to maintain and place a large amount of overhead on the data query and retrieval process.

The following presents a simplified summary in order to provide a basic understanding of one or more aspects of the invention. This summary is not an extensive overview of the invention and is neither intended to identify key or critical elements of the invention nor to delineate the scope thereof. Rather the primary purpose of the summary is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.

In one aspect the invention includes an Intelligence Selection and Retrieval Language ISRL a common open language to search for and retrieve any type of intelligence data which provides a revolutionary means of solving problems such as at least some of the interoperability problems described herein. This language helps bridge the communications gap while allowing more money to be spent higher in the value chain. At least one market for the invention includes groups such as the United States Government Service Organization GSO groups within the Intelligence community and the Intelligence Community IC as a whole. Further embodiments of the invention are useful in virtually any application that involves getting data from any source such as working accessing or searching a database or other collection of information.

In a first embodiment the invention provides a way to access information without the necessity of using so called middleware or data brokers. Instead this embodiment of the invention uses a common language and a set of lightweight tools to allow any application to get data from any source using a language that is referred to herein for purely illustrative purposes as the Intelligence Selection and Retrieval Language ISRL . ISRL is a grammar language specification for forming data selection requests and for formatting the results of those requests. Using ISRL any application can talk to any data source via the common ISRL language.

In addition the ISRL in one embodiment works with one or more tools that help reduce the time and cost required to develop interfaces that speak this new language. One tool is referred to herein for purely illustrative purposes as the ISRL Developer s Kit IDK . The other tool is referred to herein for purely illustrative purposes as the Application Connector Interface ACIF . In one embodiment the IDK and the ACIF can be provided e.g. via license to any application or data source developer. In another embodiment of the invention the ISRL is provided without the ACIF and IDK tools wherein users develop ISRL interfaces without use of these tools.

Embodiments of the invention may provide advantages of presently available products. For example embodiments of the invention that implement the above described ISRL generally require little to no additional maintenance above the cost of maintaining data sources and applications as long as text and data can be transferred over a network ISRL can be used. ISRL can be implemented so as to be developer independent similar to the features of Hyptertext Markup Language HTML and Extensible Markup Language XML .

In one embodiment the invention provides a method for a client to query a data source the method comprising receiving from the data source an instance of a generic request that is specific to the data source the instance of the generic request providing information about at least one query element that is supported in a data source specific request and converting a first query from the client to the data source the first query having a first format to a second query to the data source where the second query has a second format that includes the at least one query element that is supported in the data source specific request.

The instance of the generic request can be analyzed to determine at least one publicly accessible query element supported at the data source. The query element can comprise at least one element selected from the group consisting of a field class interface and method. The first format can be a format different from the second format and the first format can comprise a format associated with a predetermined communications language.

receiving an initial request from the client to the data source the initial request being written in a first language 

if the first language is not the same as the predetermined communications language converting the initial request into a corresponding initial request written in the predetermined communications language and

The predetermined communications language can be constructed and arranged to enable a client and a data source to communicate with each other without substantial advanced knowledge of each other s architecture or interfaces. For example the predetermined communications language can be characterized by at least one standard to which both the client and the data source agree to adhere such as a standard that defines a message written in the predetermined communications language the message selected from the group consisting of request messages and response messages. The standard can include a repository of variables used by at least one of the client and the data source the repository of variables comprising at least one variable selected from the group consisting of parameters parameter names parameter precision parameter value parameter units parameter relationships types filters minimum values maximum values ranges and units of measurement.

In one embodiment the invention provides a system configured to enable a first entity to query a second entity for a result the system comprising a language specification component and an interface between the first entity and the second entity. The language specification component defines a communications language by which the first and second entities can communicate with each other. The interface is operable to receive from the second entity an instance of a generic request that is specific to the second entity the instance of the generic request providing information about at least one query element that is supported in a second entity specific request and convert a first query from the first entity to the second entity into a second query wherein the second query includes the at least one query element that is supported in the second entity specific request.

In a further embodiment the language specification component further comprises a repository of information relating to at least one parameter used in the system and a message format for messages written in the communications language the message format comprising a data description section defining for a query the preferred format of a result and defining for a response to the query the actual format of a returned result. The interface can be operable to convert a query message written in the communications language into a format specific to the second entity. The repository can further comprise at least one parameter name and wherein the interface is operable to convert the message provided that the second entity uses the at least one parameter name specified in the repository. The interface can be operable to convert the message provided that the second entity implements an interface capable of saving the state of an object in a manner that enables the object to be recreated at a different place or time.

In one embodiment the invention provides a system enabling a requester to query a data source the system comprising 

means for defining a communications language that allows the requester and data source to communicate with little or no a priori knowledge of each other s architecture or interfaces and

means for converting a message written in the communications language to a format usable by either or both of the requester and the data source.

The drawings are not necessarily to scale emphasis instead generally being placed upon illustrating the principles of the invention.

Before discussing the details of the invention a preliminary discussion is provided giving an overview of the type of computing environment in which at least some embodiments of the invention are realized. Systems and methods in accordance with the invention can be implemented using any type of general purpose computer system including but not limited to a personal computer PC laptop computer server workstation personal digital assistant PDA mobile communications device interconnected group of general purpose computers and the like running any one of a variety of operating systems. An example of a general purpose computer system usable with at least one embodiment of the present invention is illustrated in .

Referring briefly to the general purpose computer system includes a central processor associated memory for storing programs and or data an input output controller a network interface a display device one or more input devices a fixed or hard disk drive unit a floppy disk drive unit a tape drive unit and a data bus coupling these components to allow communication therebetween.

The central processor can be any type of microprocessor such as a PENTIUM processor made by Intel of Santa Clara Calif. The display device can be any type of display such as a liquid crystal display LCD cathode ray tube display CRT light emitting diode LED and the like capable of displaying in whole or in part the outputs generated in accordance with the systems and methods of the invention. The input device can be any type of device capable of providing the inputs described herein such as keyboards numeric keypads touch screens pointing devices switches styluses and light pens. The network interface can be any type of a device card adapter or connector that provides the computer system with network access to a computer or other device such as a printer. In one embodiment of the present invention the network interface enables the computer system to connect to a computer network such as the Internet.

Those skilled in the art will appreciate that computer systems embodying the present invention need not include every element shown in and that equivalents to each of the elements are intended to be included within the spirit and scope of the invention. For example the computer system need not include the tape drive and may include other types of drives such as compact disk read only memory CD ROM drives. CD ROM drives can for example be used to store some or all of the databases described herein.

In at least one embodiment of the invention one or more computer programs define the operational capabilities of the computer system . These programs can be loaded into the computer system in many ways such as via the hard disk drive the floppy disk drive the tape drive or the network interface . Alternatively the programs can reside in a permanent memory portion e.g. a read only memory ROM chip of the main memory . In another embodiment the computer system can include specially designed dedicated hard wired electronic circuits that perform all functions described herein without the need for methods from computer programs.

In at least one embodiment of the present invention the computer system is networked to other devices such as in a client server or peer to peer system. The computer system can for example be a client system a server system or a peer system. In one embodiment the invention is implemented at the server side and receives and responds to requests from a client such as a reader application running on a user computer.

The client can be any entity such as a the computer system or specific components thereof e.g. terminal personal computer mainframe computer workstation hand held device electronic book personal digital assistant peripheral etc. or a software program running on a computer directly or indirectly connected or connectable in any known or later developed manner to any type of computer network such as the Internet. For example a representative client is a personal computer that is x86 PowerPC PENTIUM based or RISC based that includes an operating system such as IBM LINUX OS 2 or MICROSOFT WINDOWS made by Microsoft Corporation of Redmond Wash. and that includes a Web browser such as MICROSOFT INTERNET EXPLORER NETSCAPE NAVIGATOR made by Netscape Corporation Mountain View Calif. having a Java Virtual Machine JVM and support for application plug ins or helper applications. A client may also be a notebook computer a handheld computing device e.g. a PDA an Internet appliance a telephone an electronic reader device or any other such device connectable to the computer network.

The server can be any entity such as the computer system a computer platform an adjunct to a computer or platform or any component thereof such as a program that can respond to requests from a client. Of course a client can be broadly construed to mean one who requests or gets the file and server can be broadly construed to be the entity that sends or forwards the file. The server also may include a display supporting a graphical user interface GUI for management and administration and an Application Programming Interface API that provides extensions to enable application developers to extend and or customize the core functionality thereof through software programs including Common Gateway Interface CGI programs plug ins servlets active server pages server side include SSI functions and the like.

In addition software embodying the present invention in one embodiment resides in an application or other program running on the computer system . In at least one embodiment the present invention is embodied in a computer readable program medium usable with the general purpose computer system . In at least one embodiment the present invention is embodied in a data structure stored on a computer or a computer readable program medium. In addition in one embodiment the present invention is embodied in a transmission medium such as one or more carrier wave signals transmitted between the computer system and another entity such as another computer system a server a wireless network etc. The present invention also in an embodiment is embodied in an application programming interface API or a user interface. In addition the present invention in one embodiment is embodied in a data structure.

Having described examples of computing environments illustrative embodiments of the invention will now be described. Note that in the following description the communications language described herein is illustratively shown as a database retrieval language and is given the name of Intelligence selection and retrieval language ISRL by way of example only. Those of skill in the art will recognize that this name is in no way limiting. The communications language can be used with applications other than database retrieval and use with the Intelligence community is but one application of the invention. At least some of the embodiments of the invention described herein including the described intelligence selection and retrieval language have applicability and utility in virtually any type of environment where a first entity is required to communicate with a second entity such as when a user is required to access one or more data sources. Further at least some of the embodiments of the invention described herein are particularly useful when the first entity and the second entity have little or no a priori knowledge of each other s architecture or interfaces.

The ISRL system includes three components each of which helps to contribute to the functionality of the ISRL language. These components include the ISRL language specification ISRL Spec Application Connector Interface ACIF and the ISRL Developer s Kit IDK . A requester such as an application another computer system a user or another entity communicates with one or more data sources via the system .

The ISRL spec defines the ISRL which provides in accordance with one embodiment of the invention an XML based special purpose communications language that allows data sources and applications to communicate with little or no a priori knowledge of each other s architecture or interfaces. The ISRL itself is characterized by one or more standards documents to which implementing programs agree to adhere. For example in one embodiment the standards documents include an ISRL Schema and an ISRL Definitions File which together provide all of the information necessary to communicate using ISRL. Advantageously the ISRL Schema and ISRL Definitions file can be versioned and configuration controlled by a single entity where users such as members of the Intelligence community can make change requests. In other embodiments the ISRL is implemented in an open source manner permitting users to maintain and change the standards documents.

The ISRL schema operates as a grammar for the ISRL and defines two broad categories of IRSL messages request messages A and result messages B. Each message category has common base structure which is a header followed by message data .

The ISRL header contains the following sets of information a request identification request ID section a user information user ID section a system information section and a data description section . Note that although depicts the sets of information in the ISRL header as sequential adjacent fields the illustration is purely for illustration only and not intended as limiting.

The Request Identification section contains an ASCII string that uniquely identifies the ISRL request. Since not all ISRL requests will result in a synchronous response the Request Identification allows the client and server to do transaction management.

The User Information section of the ISRL header contains authentication information used by the system . In the illustrated example embodiment the authentication information consists of a user ID. Optionally the authentication information includes a public key encryption PKI user certificate. If a PKI user certificate is not present the request preferably comes from a requester or other entity known to be trusted by the receiver where a receiver can be any entity or system receiving the request. This trust is established outside of ISRL but is confirmed in the System Information section of the header described below .

The ISRL header contains a System Information section that allows the receiver e.g. a data source to verify that the request came from a valid hostname and IP address. In addition a server PKI certificate is passed to the receiver for system validation. While the ISRL system of the illustrated embodiment generally does not itself establish trust or verify user credentials the ISRL system provides a number of mechanisms by which implementing systems can do so.

The last part of an ISRL header is a Data Description section . The Data Description section is the section of the ISRL header that helps allow clients e.g. requester to request information from data sources without knowing anything about the data source and vice versa. The Data Description section defines the preferred request or actual result format in which results should be formatted. For example this format can be a custom XML or CSV based record format or it can be one of numerous existing formats. Provided that the receiver can return results in the requested format the actual data description returned from a request will match the description sent in the Data Description section . In the event that the format requested cannot be provided the data source responding to a Request A makes its best effort in the response B to fulfill the request A as completely as possible. Thus the Data Description section of the response B reflects the actual results that were returned in the response instead of the requested format that had been requested in the Data Description section of the request A.

In addition to data format specifications the Data Description section also is used to define the way in which the results should be returned and the limits on how much data to return. Transfer mechanism definitions are useful when the results are very large and streaming them as part of the data result is not practical. The limits specified in the Data Description section of a request message A are complimented by a size field returned in the Data Description section of the response B that reports how much data or how many records are being returned.

The message data section the body of the message is where the requests A and results B messages also referred to herein as responses B differ drastically. The message data section of a request message A preferably includes a time filter and any number of other parametric filters. The time filter specifies a date time range from which to select data for retrieval. The parametric filters define the type of match for example single value match range match and or multiple value matches. For example if a time filter is a used a requester i.e. the entity generating a request message A can specify if data matching the filter should be included in the results or excluded from the results. The requester also can specify the precision and units of the filter values. Advantageously few restrictions are placed on the filters in a request message A and the only restriction on the filters is that the parameter name and units match a value defined in the ISRL Definitions File.

The message data section of a result message B can take several forms. For example in the event that no results were selected or the results were sent to the requester along another path then the message data section of the result message B contains no body at all. Alternately the message data section of a result message B contains the actual results of the query. These query results may be binary data or text records.

Referring again to the ISRL Definitions File also referred to as the ISRL repository is a storehouse of variables e.g. all known parameters units of measurement and parameter relationships used with the system e.g. variables that can be part of a message . Although the embodiment of illustrates only a single ISRL Definitions File other embodiments of the invention include different and or additional optional repositories A B e.g. for different Communities of Interest COI such as Counter Terror Non Proliferation etc. as those of skill in the art will appreciate.

The ISRL Definitions File contains XML records for each parameter or unit of measurement. Additional units or parameters can easily be added at any time. Tables 1 and 2 below are examples of a parameter definition and some unit definitions.

Referring again to the system also includes an ISRL Developer s Kit IDK which is a tool including its own suite of tools built upon the ISRL language. The IDK aids programs and or data source developers in writing translators that convert ISRL requests and responses to program and or data source specific formats. For example the IDK provides all of the tools that a data source developer needs to quickly and easily make a data source ISRL compliant. Advantageously the system implements a single IDK that can be licensed and used by entities that want to develop an ISRL interface. Licensing and using the IDK can be the most cost effective way for many entities to develop an ISRL interface however in at least some embodiments of invention an ISRL interface can be developed without using the IDK .

There are six components that make up the IDK a Web Services Endpoint WS ISRL also referred to herein as an ISRL Server an ISRL Core a Translation Engine A an IDK Application Programming Interface IDK API an Authentication Module API and a Java Native Interface JNI Layer . Each of these is described further below.

The Web Services Endpoint is an application that provides a near plug and play web service capability to data sources . This application referred to herein for illustrative purposes as ws ISRL is installed into a Java 2 platform Enterprise Edition J2EE compliant application server or deployed within a web server capable of supporting servlets and JavaServer pages JSPs such as a Jakarta Tomcat J2EE container available as an open source product from the Apache Software Foundation Forest Hill Md. or via http www.apache.org . For example in one embodiment the Web Services Endpoint is implemented as a Tomcat based server that actually is provided with the IDK . The Web Services Endpoint accepts web service requests and translates passes the requests to an implementing service.

Once installed the ws ISRL application of the Web Services Endpoint listens for incoming ISRL messages and passes them to a message handler. In one embodiment this message handler is a custom message handler developed specifically for a given data source . In the illustrated implementation of the IDK developers of a data source can choose to execute any of a number of pre defined behaviors upon receipt of a message by altering the ws ISRL configuration file described further herein shows the flow of data between the ws ISRL application of the Web Services Endpoint and the data source .

Referring again to the ISRL Core component is an implementation of the ISRL language. Advantageously the ISRL Core component can be a proprietary component that is licensed to data source developers Implemented in Java. The ISRL Core component contains all of the classes necessary to process any ISRL message and return a properly formatted result. In addition the ISRL Core component provides the base abstract classes that when implemented by a data source allow for rapid translation between ISRL and custom data source implementations.

The ISRL Core contains packages e.g. collections of related objects or components corresponding to a model of the request XML message a model of the response XML message base object and implementation classes and a parameter and init definition model. For example the packages in the ISRL core map to the different XML documents and contain objects and methods for reading and interpreting the respective XML document s with which the packages are associated. The ISRL Core component also contains a set of test GUIs that can perform data requests parse results and validate messages.

The Translation Engine A also referred to herein as a translator translates ISRL formatted messages into data source specific formats. This is a powerful capability that provides a fast easy to use and reliable way to translate into data source specific formats. As explained further herein in connection with the Translation Engine A provides a two pass translation from an ISRL common format to an implementation specific format. In one embodiment the Translation Engine A takes advantage of the introspection capabilities that are native to the Java language to be able to translate a request into any implementation specific format that follows certain coding standards explained further below.

Utilizing Java s introspection capabilities the Translation Engine A takes an ISRL message and translates it into a data source specific format provided that the data source provides an implementation class that meets two very basic requirements first the implementing class must implement an interface capable of encoding or writing or saving the state of an object in a structured way so that the object can be saved or transmitted as data and recreated at another place time such as a Serializable interface second the implementing class must use parameter names specified in the ISRL Definitions File. Provided that those two requirements are met the implementing system does not need to know anything else at all about ISRL. described further below is a flow diagram that further details how the Translation Engine A works.

Referring again to the IDK API of the IDK is a component that lies on top of all of the other components that is the IDK API is a component that logically encapsulates the IDK and provides a publicly exposed interface through which all components of the IDK are accessed and is the so called public face of the IDK . That is in this embodiment the IDK API is a component as is the Authentication API described below that is completely public and open i.e. accessible to developers such as data source providers .

In an example embodiment the IDK API is implemented almost entirely via documentation examples of the types of such documents could include 

The Authentication Module API of the IDK is a component that helps enable legacy systems to operate in a secure environment. The authentication Module API provides a set of authentication modules that can be plugged into the ws ISRL component of the Web Services Endpoint to ensure that all messages are property authenticated. In an example embodiment the Authentication Module API of the IDK is implemented using a set of simple authentication modules that includes 

In addition the IDK provides an open API for the creation of other authentication modules so each data source and make sure they meet their own specific security requirements.

The JNI Layer allows the IDK to work with systems developed in C or C . This is advantageous because many archive systems applications and data brokers have some level of C or Java compatibility. Thus the JNI layer helps to make the IDK suitable for many users. The JNI layer is a set of interfaces and libraries that expose the IDK API to C developers. In addition a set of documentation and examples exists to make it easier for C developers to quickly create ISRL capable interfaces.

Referring again to the system includes an ACIF . The ACIF which is intended for use by application developers and maintainers complements the functionality of the IDK . For example where the IDK includes tools to aid the data source developer in creating an ISRL compliant interface the ACIF provides a similar level of support for application development. The ACIF provides a set of tools that take ISRL Common Formatted Results which are explained further herein and turns the results into legacy formats for use by applications. As illustrated in the ACIF includes a Query Creator a Streaming Interface a Data Conversion Engine an IDK Core and a Translation Engine B. Each of these is further explained below.

The Query Creator is a graphical user interface GUI tool that assists developers especially developers new to ISRL to develop ISRL language request templates for use by applications that they are developing and to develop implementing Java classes for plug ins to the application. In addition the Query Creator also supports custom results definitions and or selection of a pre existing results format. Supporting custom results definitions and or selection of a pre existing format can help reduce the development time and effort required to make an application capable of working with ISRL capable.

The Streaming Interface is a connector that allows legacy applications to become ISRL compliant. For example some legacy applications and or tools expect data queries to be synchronous. The Streaming Interface acts as a wrapper around ISRL that mimics a synchronous interface for legacy applications that need to be able to do requests as a single transaction i.e. the Streaming Interface acts as a proxy to ISRL. Once the Streaming Interface receives a data request from the application e.g. from a Requester the Streaming Interface submits an ISRL data request to the applicable server or servers. The Streaming Interface then issues status requests a special form of data request to the servers for the data source and compiles results as they come back. Once all of the results are in the Streaming Interface calls the Data Conversion Engine to translate the results into the selected format and returns the results to the application.

While a number of asynchronous operations can take place in the above described scenario the scenario in actuality appears to be totally synchronous to the application i.e. the tools enable dynamic loading of data based on user requests . In addition to being useful for legacy applications the Streaming Interface can be used by new application developers that only require a simple search and retrieval interface and don t want to bother with status tracking and the like.

The Data Conversion Engine is a utility that transforms converts ISRL results or other supported data formats into user requested formats e.g. one of many commonly used formats. . As those of skill in the art will appreciate many different types of data conversion utilities are available commercially e.g. programs that convert spreadsheet documents into comma separated text files programs that convert proprietary word processing formatted files e.g. MICROSOFT WORD document into device independent and resolution independent fixed layout document formats e.g. portable document format PDF etc. . Data conversion utilities can be used as plug ins to the Data Conversion Engine . The Data Conversion Engine in the embodiment of is built on top of the Translation Engine B and contains a number of customized result classes that can output ISRL results in one of many formats that are currently in use by existing applications.

The Translation Engine B operates similarly to the Translation Engine A described previously in connection with the IDK . Likewise the IDK Core operates similarly to the ISRL Core described previously in connection with the IDK .

To form a truly interoperable enterprise it is advantageous for the ISRL system to be able to be adapted and or implemented in various differing operational situations. is block diagram of an enterprise layout that illustrates how the system of can be implemented and adapted in an enterprise environment that includes varying operational situations. Referring to examples of such operational situations include but are not limited to 

Note also that in all communications between and among the ACIFs A B IDKs A B and C ISRL compatible application and ISRL compatible archive which communications are shown via dotted lines in are done using a common communications language ISRL. These communications are illustrated in via a dotted line.

Data brokers such as Data Broker are commercially available to communities such as the Intelligence Community as a way to provide access to a number of data sources from a single interface. Conventionally a data broker takes an incoming request for data and federates it to all of its associated data sources. Data brokers can be implemented for example to have a programmatic interface to applications or other systems or a direct user interface.

In Data Broker uses IDK A to handle ISRL formatted messages. These ISRL formatted messages can come directly from a system entity with built in ISRL capability e.g. ISRL Compatible App or from a system entity that has used an IDK as an ISRL compatible interface e.g. App A and or System  . To become ISRL capable the Data Broker is adapted such as by the developer of the Data Broker by taking the following actions 

Once the interface e.g. IDK A is active any application or system within the enterprise can issue an ISRL request for data to the data broker by sending an ISRL Data Request message to the web service Referring to both and upon receipt of the ISRL message e.g. a request for data from a data source the IDK A and Data Broker perform the following actions in a first data flow in accordance with an embodiment of the invention.

Referring again to it can be seen that some data sources such as Archive System Z C are not connected to the data broker . One reason that this arrangement can exist is that it can be expensive to add data sources to a data broker. With the embodiment of the invention shown in it may be more economical to develop a new archive with ISRL support. Any ISRL compatible client can then query this new archive without the need for an intermediary such as a data broker. Developing a new archive with ISRL support further has the added benefit of increasing query responsiveness since middleware is being removed.

The scenario where a new archive e.g. Archive System Z C is developed with ISRL support operates in a manner similar to the data broker scenario described above. To become ISRL capable the developer of this archive does the following 

Once the interface e.g. IDK C in to the new archive Archive System Z C is active any application or system within the enterprise can issue an ISRL request for data to the archive by sending an ISRL Data Request message to the web service. Referring to upon receipt of the message the IDK C and Archive System Z perform the following actions 

Some systems especially within the Intelligence Community can serve as both Applications and Data Archives. These are referred to herein as dual use systems. An example of a dual use system is System  in . Dual use systems act as applications in various ways for example dual use systems provide an analysis capability to users and or may provide access to either locally stored or acting as a data broker data e.g. consumer data from other systems. In either the analysis capability or the situation where data is obtained from other systems it is beneficial to use the ACIF to connect the dual use system to other ISRL capable data sources. Dual use systems act as data archives in various ways such as by performing a value added function to the incoming data and storing it or acting as a short or long term archive for another system.

The operational scenario for a dual use system is the same as the operational scenario for an application utilizing IDK and an archive utilizing ACIF.

Referring again to many applications through the ACIF can quickly become ISRL capable compatible e.g. ISRL Compatible App . It is possible in accordance with the principles of the invention for an application to use all or most of the ACIF components to rapidly become ISRL capable. Doing so can also reduce cost. The first step to becoming ISRL capable is to install ACIF and configure the components. One way to do this is as follows 

Once the ACIF e.g. ACIF B in is installed and configured the application e.g. ISRL Compatible App is ready to request data from any ISRL capable archive. For example referring to when a user executes the application s ISRL query function the following events occur 

Even though use of the ACIF and the IDK is a cost effective way to add ISRL capability to an application or archive it is possible in accordance with at least some embodiments of the invention for a program to be developed and or written to be ISRL capable compatible. One reason that this is possible because ISRL is preferably an open language. Although each custom interface can be unique to the system that is developing it the following steps help a system to become ISRL capable without relying on the ACIF or IDK 

Generally for a system to be ISRL capable the developers of the system should take at least these actions 

In the example of the user is an individual named John F. Doe who is a marketing analyst for an organization named Manly Man Publishing . Note however that the user could instead be another system a computer application or any other entity including any entity ies acting on Doe s behalf. Manly Man Publishing has a Manly Man Web Portal that is accessible to users such as Doe. In this example Doe wants to find out how many subscribers of Manly Man s most popular magazines and . . . live in Huntington N.Y. The magazine was recently acquired from an entity named Homme Inc. and uses a lightweight directory access protocol LDAP type of data store for its customer information database named Dude Data . . . . uses an ANSI standard SQL relational database named Uhhh Data .

As illustrates Manly Man Publishing has additional systems which may or may not have portals or other access points associated with them on its networks that are accessible to various users although not necessarily accessible to all users . As shown in two of these additional systems are the Billing System and its Human Resources Database . Manly Man Publishing uses ISRL across its enterprise to allow a single interface protocol to all of its databases. Thus for example a user with appropriate access rights can access Billing System e.g. via the Manly Man Web Portal or any compatible access method as are well known to those of skill in the art and search the Accounting System database which uses its own unique query processing system indicated by the arrow with the word other in . In another example the user with appropriate access rights can access the Human Resources System to access the HRMS database which uses a Simple Object Access Protocol SOAP .

Referring to at block the user e.g. Doe interacts with the application Manly Man Web Portal as shown by the arrow labeled in . When the Manly Man Web Portal application receives the form from the user block the Manly Man Web Portal application interacts with an ACIF A block via an API A and a Connector A using Java. The Connector defines how the application will form requests and interpret results and an application developer e.g. a licensee of the ACIF can write code to create a Connector . More details about this interaction labeled as B in block are found in which are themselves described more fully below.

The ACIF submits an and ISRL query to data source services block a process explained in more detail in . Referring again to for each data source the data source services receives an ISRL query block and the data source searches for matching data block . The data source returns results block and the IDK formats results block into a results message block . The processing occurring in blocks through is explained further herein in connection with . Referring again to after the IDK returns a results message block if there are more data sources block the processes of blocks are repeated. If there are no more data sources then the ACIF returns results block . described further herein illustrates how the ACIF returns results. Referring again to when the results are returned the application e.g. Manly Man Web Portal responds to the user block and the user is able to view the results block .

For block of an example of an interaction between the user and the application of block is shown in . Referring to the user or any other entity using the application views and or loads a web page with a search form block . This search form could for example be a generic search form designed to be appropriate to many different types of data sources. Alternately a user may select or be given a search form appropriate to the application being used and or the data source s being accessed. The user fills out the form block and submits the form to the application block . In block the ACIF A submits an ISRL query to Data source services.

Although not described in detail herein those of skill in the art will appreciate that many different types of interactions are possible in the implementation of and similar implementations. For example a user could search one or more other databases e.g. the HRMS and or the Accounting System via the portal . In addition the ACIF A or any of the other ACIFs B C can access any one or more of the IDKs A B C D to be able to query any one of more of the databases.

Referring to and the web services endpoint ws ISRL at the IDK e.g. an IDK A B C D in for the given data source receives a request from the ACIF A block . The request is in the form of an ISRL query. The IDK passes the request to a data source specific request handler block such as the MyWSHandler GenericWSHandler of via a method such as Java method HandleRequest ISRLRequest . The data source specific request handler initializes a source specific query block such as via java method Create. In the example of the source specific query is MyRequest GenericRequest . If the query is not ISRL compliant block a result message is returned to the requester with an error status block .

If the query is ISRL compliant the request handler translates the ISRL request into a source specific request block such as via Java method translate ISRLRequest MyRequest . The translation process which is shown as G in block is detailed more fully in which are described more fully below. Referring again to after the ISRL request is translated into a source specific request block the source specific request is populated with the fields of the ISRL request block such as via Java method setField value . The implementing component which could be for example a data source as in or a data broker in communication with a data source as in is then asked to process the request such as via Java method process MyRequest . The results of the query are returned from the data source block such as via Java method return MyResponse. The results can be returned in a custom format or in a manner specified in the request e.g. via SFTP .

If the results of the query are in ISRL format processing proceeds to block . If the results of the query are not in ISRL format block the request handler MyWSHandler GenericWSHandler uses a translator e.g. Translation Engine A of to convert the results into ISRL format block such as via Java method translate MyResponse . In block the request handler MyWSHandler GenerticWSHandler passes the results of the query to the IDK service ws ISRL such as via Java method return ISRLResponse. The IDK service IDK service ws ISRL sends the results back to ACIF A block such as via Java method return ISRL response.

The translation process referred to in block of is explained in greater detail in . is a flow diagram showing translation of in detail for the embodiment of and is a flow chart showing translation of an ISRL request into a data source specific request for the embodiment of . Referring now to in block the translator e.g. translation engine A of receives the ISRL request for a given data source such as a third party server. Note that the data source can be any entity capable of providing an implantation class that at least 1 implements the Java Serializable interface and that 2 uses parameter names specified in the ISRL Definitions file . An example ISRL request for access to a data source is the Java method translate ISRLRequest ImplementationName .

The translator queries the data source for the data source to provide an example of a generic request to that data source block . In response to the query from the translator the data source provides to the translator an instance of a generic request that is specific to that data source block . In the example of the instance of the generic request is named MyRequest . The instance MyRequest i.e. the instance of the generic request includes information about all available and or accessible classes interfaces fields and methods at the data source. That is the data source provides information to the translator about fields that are supported e.g. by providing read write properties for fields that are supported . Based on an analysis of the instance of the generic request the translator determines the fields that are supported block and uses the information about the supported fields to translate the original ISRL request block into a data source specific request block which in the example of is named MyRequest. That is the translator inspects an object that it may never have seen before and creates an ISRL translation of it. This is done by examining the object to determine which fields and methods it has. These are compared with the definitions file to find items that match or have equivalents. Using these matches or equivalents an ISRL language version of the object is created. For translation from ISRL to a custom object the flow is the reverse.

As those skilled in the art will recognize the invention described herein can be modified to accommodate and or comply with any many different technologies and standards. In addition variations modifications and other implementations of what is described herein can occur to those of ordinary skill in the art without departing from the spirit and the scope of the invention as claimed. Further virtually any aspect of the embodiments of the invention described herein can be implemented using software hardware or in a combination of hardware and software.

It should be understood that in the Figures of this application in some instances a plurality of system elements or method steps may be shown as illustrative of a particular system element and a single system element or method step may be shown as illustrative of a plurality of a particular systems elements or method steps. It should be understood that showing a plurality of a particular element or step is not intended to imply that a system or method implemented in accordance with the invention must comprise more than one of that element or step nor is it intended by illustrating a single element or step that the invention is limited to embodiments having only a single one of that respective elements or steps. In addition the total number of elements or steps shown for a particular system element or method is not intended to be limiting those skilled in the art will recognize that the number of a particular system element or method steps can in some instances be selected to accommodate the particular user needs.

It should also be appreciated that the flow diagrams and flow charts provided herein do not depict the syntax of any particular programming language although in some instances methods from the Java programming language have been provided by way of example . Rather the flow diagrams and flow charts illustrate the functional information one of ordinary skill in the art requires to fabricate circuits or to generate computer software to perform the processing required of the particular apparatus. It should be noted that many routine program elements such as initialization of loops and variables and the use of temporary variables are not shown. It will be appreciated by those of ordinary skill in the art that unless otherwise indicated herein the particular sequence of steps described is illustrative only and can be varied without departing from the spirit and scope of the invention.

Further in describing the embodiments of the invention illustrated in the figures specific terminology is used for the sake of clarity. However the invention is not limited to the specific terms so selected and each specific term at least includes all technical and functional equivalents that operate in a similar manner to accomplish a similar purpose.

Although the invention has been described and pictured in a preferred form with a certain degree of particularity it is understood that the present disclosure of the preferred form has been made only by way of example and that numerous changes in the details of construction and combination and arrangement of parts may be made without departing from the spirit and scope of the invention as hereinafter claimed.

