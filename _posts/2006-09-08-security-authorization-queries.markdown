---

title: Security authorization queries
abstract: In an example implementation, a bifurcated security scheme has a first level that does not allow usage of negations and a second level that does permit usage of negations. In another example implementation, an authorization query table maps respective resource-specific operations to respective associated authorization queries. In yet another example implementation, authorization queries are permitted to have negations, but individual assertions are not.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08060931&OS=08060931&RS=08060931
owner: Microsoft Corporation
number: 08060931
owner_city: Redmond
owner_country: US
publication_date: 20060908
---
Computers and other electronic devices are pervasive in the professional and personal lives of people. In professional settings people exchange and share confidential information during project collaborations. In personal settings people engage in electronic commerce and the transmission of private information. In these and many other instances electronic security is deemed to be important.

Electronic security paradigms can keep professional information confidential and personal information private. Electronic security paradigms may involve some level of encryption and or protection against malware such as viruses worms and spyware. Both encryption of information and protection from malware have historically received significant attention especially in the last few years.

However controlling access to information is an equally important aspect of securing the safety of electronic information. This is particularly true for scenarios in which benefits are derived from the sharing and or transferring of electronic information. In such scenarios certain people are to be granted access while others are to be excluded.

Access control has been a common feature of shared computers and application servers since the early time of shared systems. There are a number of different approaches that have been used to control access to information. They share a common foundation in combining authentication of the entity requesting access to some resource with a mechanism of authorizing the allowed access. Authentication mechanisms include passwords Kerberos and x.509 certificates. Their purpose is to allow a resource controlling entity to positively identify the requesting entity or information about the entity that it requires.

Authorization examples include access control lists ACLs and policy based mechanisms such as the eXtensible Access Control Markup Language XACML or the PrivilEge and Role Management Infrastructure PERMIS . These mechanisms define what entities may access a given resource such as files in a file system hardware devices database information and so forth. They perform this authorization by providing a mapping between authenticated information about a requestor and the allowed access to a resource.

As computer systems have become more universally connected over large networks such as the Internet these mechanisms have proven to be somewhat limited and inflexible in dealing with evolving access control requirements Systems of geographically dispersed users and computer resources including those that span multiple administrative domains in particular present a number of challenges that are poorly addressed by currently deployed technology.

In an example implementation a bifurcated security scheme has a first level that does not allow usage of negations and a second level that does permit usage of negations. In another example implementation an authorization query table maps respective resource specific operations to respective associated authorization queries. In yet another example implementation authorization queries are permitted to have negations but individual assertions are not.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure API arrangement protocol etc. implementations are described herein.

In a described implementation security scheme can be overlaid and or integrated with one or more devices which can be comprised of hardware software firmware some combination thereof and so forth. As illustrated d devices with d being some integer are interconnected over one or more networks . More specifically device device device . . . device are capable of communicating over network .

Each device may be any device that is capable of implementing at least a part of security scheme . Examples of such devices include but are not limited to computers e.g. a client computer a server computer a personal computer a workstation a desktop a laptop a palm top etc. game machines e.g. a console a portable game device etc. set top boxes televisions consumer electronics e.g. DVD player recorders camcorders digital video recorders DVRs etc. personal digital assistants PDAs mobile phones portable media players some combination thereof and so forth. An example electronic device is described herein below with particular reference to .

Network may be formed from any one or more networks that are linked together and or overlaid on top of each other. Examples of networks include but are not limited to an internet a telephone network an Ethernet a local area network LAN a wide area network WAN a cable network a fibre network a digital subscriber line DSL network a cellular network a Wi Fi network a WiMAX network a virtual private network VPN some combination thereof and so forth. Network may include multiple domains one or more grid networks and so forth. Each of these networks or combination of networks may be operating in accordance with any networking standard.

As illustrated device corresponds to a user that is interacting with it. Device corresponds to a service that is executing on it. Device is associated with a resource . Resource may be part of device or separate from device .

User service and a machine such as any given device form a non exhaustive list of example entities. Entities from time to time may wish to access resource . Security scheme ensures that entities that are properly authenticated and authorized are permitted to access resource while other entities are prevented from accessing resource .

As illustrated device A includes two security related components a security token and an application . Security token includes one or more assertions . Device B includes five security related components an authorization context a resource guard an audit log an authorization engine and a security policy . Security policy includes a trust and authorization policy an authorization query table and an audit policy .

Each device may be configured differently and still be capable of implementing all or a part of security scheme . For example device A may have multiple security tokens and or applications . As another example device B may not include an audit log or an audit policy . Other configurations are also possible.

In a described implementation authority issues security token having assertions to entity . Assertions are described herein below including in the section entitled Security Policy Assertion Language Example Characteristics . Entity is therefore associated with security token . In operation entity wishes to use application to access resource by virtue of security token .

Resource guard receives requests to access resource and effectively manages the authentication and authorization process with the other security related components of device B . Trust and authorization policy as its name implies includes policies directed to trusting entities and authorizing actions within security environment . Trust and authorization policy may include for example security policy assertions not explicitly shown in . Authorization query table maps requested actions such as access requests to an appropriate authorization query. Audit policy delineates audit responsibilities and audit tasks related to implementing security scheme in security environment .

Authorization context collects assertions from security token which is are used to authenticate the requesting entity and security policy assertions from trust and authorization policy . These collected assertions in authorization context form an assertion context. Hence authorization context may include other information in addition to the various assertions.

The assertion context from authorization context and an authorization query from authorization query table are provided to authorization engine . Using the assertion context and the authorization query authorization engine makes an authorization decision. Resource guard responds to the access request based on the authorization decision. Audit log contains audit information such as for example identification of the requested resource and or the algorithmic evaluation logic performed by authorization engine .

In a described implementation entity authenticates itself to resource guard with a token security token . Resource guard forwards the token assertions to authorization context . These token assertions are assertions of of security token . Security policy provides the authorization query table to resource guard . The authorization query table derives from authorization query table module . The authorization query table sent to resource guard may be confined to the portion or portions directly related to the current access request.

Policy assertions are extracted from trust and authorization policy by security policy . The policy assertions may include both trust related assertions and authorization related assertions. Security policy forwards the policy assertions to authorization context . Authorization context combines the token assertions and the policy assertions into an assertion context. The assertion context is provided from authorization context to authorization engine as indicated by the encircled A .

An authorization query is ascertained from the authorization query table. Resource guard provides the authorization query auth. query to authorization engine . Authorization engine uses the authorization query and the assertion context in an evaluation algorithm to produce an authorization decision. The authorization decision auth. dcn. is returned to resource guard . Whether entity is granted access to resource by resource guard is dependent on the authorization decision. If the authorization decision is affirmative then access is granted. If on the other hand the authorization decision issued by authorization engine is negative then resource guard does not grant entity access to resource .

The authorization process can also be audited using semantics that are complementary to the authorization process. The auditing may entail monitoring of the authorization process and or the storage of any intermediate and or final products of e.g. the evaluation algorithm logically performed by authorization engine . To that end security policy provides to authorization engine an audit policy from audit policy . At least when auditing is requested an audit record having audit information may be forwarded from authorization engine to audit log . Alternatively audit information may be routed to audit log via resource guard for example as part of the authorization decision or separately.

Generally a device may represent any computer or processing capable device such as a client or server device a workstation or other general computer device a PDA a mobile phone a gaming platform an entertainment device one of the devices listed above with reference to some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media include processor executable instructions .

In a described implementation of device I O interfaces may include i a network interface for communicating across network ii a display device interface for displaying information on a display screen iii one or more man machine interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Printing device interfaces may similarly be included as part of I O interfaces . Examples of iii man machine interfaces include those that communicate by wire or wirelessly to man machine interface devices e.g. a keyboard a remote a mouse or other graphical pointing device etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device .

Thus realizations for security related implementations may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects components metadata and definitions thereof data structures application programming interfaces APIs schema etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

Processor s may be implemented using any applicable processing capable technology. Media may be any available media that is included as part of and or accessible by device . It includes volatile and non volatile media removable and non removable media and storage and transmission media e.g. wireless or wired communication channels . For example media may include an array of disks flash memory optical media for longer term mass storage of processor executable instructions random access memory RAM for shorter term storing of instructions that are currently being executed link s on network for transmitting communications e.g. security related data and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein including those actions that are illustrated in the various flow diagrams. By way of example only processor executable instructions may include a security token at least one of its assertions an authorization context module a resource guard an audit log an authorization engine a security policy e.g. a trust and authorization policy an authorization query table and or an audit policy etc. some combination thereof and so forth. Although not explicitly shown in processor executable instructions may also include an application and or a resource .

This section describes example characteristics of an implementation of a security policy assertion language SecPAL . The SecPAL implementation of this section is described in a relatively informal manner and by way of example only. It has an ability to address a wide spectrum of security policy and security token obligations involved in creating an end to end solution. These security policy and security token obligations include by way of example but not limitation describing explicit trust relationships expressing security token issuance policies providing security tokens containing identities attributes capabilities and or delegation policies expressing resource authorization and delegation policies and so forth.

In a described implementation SecPAL is a declarative logic based language for expressing security in a flexible and tractable manner. It can be comprehensive and it can provide a uniform mechanism for expressing trust relationships authorization policies delegation policies identity and attribute assertions capability assertions revocations audit requirements and so forth. This uniformity provides tangible benefits in terms of making the security scheme understandable and analyzable. The uniform mechanism also improves security assurance by allowing one to avoid or at least significantly curtail the need for semantic translation and reconciliation between disparate security technologies.

A SecPAL implementation may include any of the following example features 1 SecPAL can be relatively easy to understand. It may use a definitional syntax that allows its assertions to be read as English language sentences. Also its grammar may be restrictive such that it requires users to understand only a few subject verb object e.g. subject verb phrase constructs with cleanly defined semantics. Finally the algorithm for evaluating the deducible facts based on a collection of assertions may rely on a small number of relatively simple rules.

 2 SecPAL can leverage industry standard infrastructure in its implementation to ease its adoption and integration into existing systems. For example an extensible markup language XML syntax may be used that is a straightforward mapping from the formal model. This enables use of standard parsers and syntactic correctness validation tools. It also allows use of the W3C XML Digital Signature and Encryption standards for integrity proof of origin and confidentiality.

 3 SecPAL may enable distributed policy management by supporting distributed policy authoring and composition. This allows flexible adaptation to different operational models governing where policies or portions of policies are authored based on assigned administrative duties. Use of standard approaches to digitally signing and encrypting policy objects allow for their secure distribution. 4 SecPAL enables an efficient and safe evaluation. Simple syntactic checks on the inputs are sufficient to ensure evaluations will terminate and produce correct answers.

 5 SecPAL can provide a complete solution for access control requirements supporting required policies authorization decisions auditing and a public key infrastructure PKI for identity management. In contrast most other approaches only manage to focus on and address one subset of the spectrum of security issues. 6 SecPAL may be sufficiently expressive for a number of purposes including but not limited to handling the security issues for Grid environments and other types of distributed systems. Extensibility is enabled in ways that maintain the language semantics and evaluation properties while allowing adaptation to the needs of specific systems.

As illustrated at the top row of assertion format an example assertion at a broad level includes a principal portion a says portion and a claim portion . Textually the broad level of assertion format may be represented by principal says claim.

At the next row of assertion format claim portion is separated into example constituent parts. Hence an example claim portion includes a fact portion an if portion n conditional factportions . . . and a c portion . The subscript n represents some integer value. As indicated by legend c portion represents a constraint portion. Although only a single constraint is illustrated c portion may actually represent multiple constraints e.g. c . . . c . The set of conditional fact portions . . . and constraints . . . on the right hand side of if portion may be termed the antecedent.

Textually claim portion may be represented by fact if fact . . . fact c. Hence the overall assertion format may be represented textually as follows principal says fact if fact . . . fact c. However an assertion may be as simple as principal says fact. In this abbreviated three part version of an assertion the conditional portion that starts with if portion and extends to c portion is omitted.

Each fact portion may also be further subdivided into its constituent parts. Example constituent parts are an e portion and a verb phrase portion . As indicated by legend e portion represents an expression portion. Textually a fact portion may be represented by e verbphrase.

Each e or expression portion may take on one of two example options. These two example expression options are a constant and a variable . Principals may fall under constants and or variables .

Each verb phrase portion may also take on one of three example options. These three example verb phrase options are a predicate portion followed by one or more eportions . . . a can assert portion followed by a fact portion and an alias portion followed by an expression portion . Textually these three verb phrase options may be represented by predicate e. . . e can assert fact and alias e respectively. The integer n may take different values for facts . . . and expressions . . . .

Generally SecPAL statements are in the form of assertions made by a security principal. Security principals are typically identified by cryptographic keys so that they can be authenticated across system boundaries. In their simplest form an assertion states that the principal believes a fact is valid e.g. as represented by a claim that includes a fact portion . They may also state a fact is valid if one or more other facts are valid and some set of conditions are satisfied e.g. as represented by a claim that extends from a fact portion to an if portion to conditional fact portions . . . to a c portion . There may also be conditional facts . . . without any constraints and or constraints without any conditional facts . . . .

In a described implementation facts are statements about a principal. Four example types of fact statements are described here in this section. First a fact can state that a principal has the right to exercise an action s on a resource with an action verb . Example action verbs include but are not limited to call send read list execute write modify append delete install own and so forth. Resources may be identified by universal resource indicators URIs or any other approach.

Second a fact can express the binding between a principal identifier and one or more attribute s using the possess verb. Example attributes include but are not limited to email name common name group name role title account name domain name server service DNS name internet protocol IP address device name application name organization name service name account identification identifier ID and so forth. An example third type of fact is that two principal identifiers can be defined to represent the same principal using the alias verb.

 Qualifiers or fact qualifiers may be included as part of any of the above three fact types. Qualifiers enable an assertor to indicate environmental parameters e.g. time principal location etc. that it believes should hold if the fact is to be considered valid. Such statements may be cleanly separated between the assertor and a relying party s validity checks based on these qualifier values.

An example fourth type of fact is defined by the can assert verb. This can assert verb provides a flexible and powerful mechanism for expressing trust relationships and delegations. For example it allows one principal A to state its willingness to believe certain types of facts asserted by a second principal B . For instance given the assertions A says B can assert fact0 and B says fact0 it can be concluded that A believes fact0 to be valid and therefore it can be deduced that A says fact0 .

Such trust and delegation assertions may be i unbounded and transitive to permit downstream delegation or ii bounded to preclude downstream delegation. Although qualifiers can be applied to can assert type facts omitting support for qualifiers to these can assert type facts can significantly simplify the semantics and evaluation safety properties of a given security scheme.

In a described implementation concrete facts can be stated or policy expressions may be written using variables. The variables are typed and may either be unrestricted e.g. allowed to match any concrete value of the correct type or restricted e.g. required to match a subset of concrete values based on a specified pattern .

Security authorization decisions are based on an evaluation algorithm e.g. that may be conducted at authorization engine of an authorization query against a collection of assertions e.g. an assertion context from applicable security policies e.g. a security policy and security tokens e.g. one or more security tokens . Authorization queries are logical expressions which may become quite complex that combine facts and or conditions. These logical expressions may include for example AND OR and or NOT logical operations on facts either with or without attendant conditions and or constraints.

This approach to authorization queries provides a flexible mechanism for defining what must be known and valid before a given action is authorized. Query templates e.g. from authorization query table form a part of the overall security scheme and allow the appropriate authorization query to be declaratively stated for different types of access requests and other operations actions.

Existing security policy languages follow one of two approaches. Some prevent the use of negations in all ways and at all times. This approach does reduce the attendant inconsistencies and uncertainties that can arise from negations. However it is also limiting inasmuch as many security scenarios are rendered far more difficult to handle and some security scenarios simply cannot be handled at all. The other approach places no limitations on the use of negations. Although this approach is more flexible it presents the possibility of establishing security policies that are convoluted or even nondeterministic.

In contrast a described implementation creates a security scheme with multiple levels. In a bifurcated security scheme implementation for example there are two levels. A first level forbids the use of negations. This can be enforced using for example validations on syntax. A second level permits the use of negations. This bifurcated security scheme combines the safety and certainty of ensuring that security assertions are tractable and determinable with the flexibility of handling exclusionary security rules.

In a described implementation assertion level is populated with assertions . Assertions may be any type of declarative security statement at the assertion level. Examples of assertions include but are not limited to token assertions and policy assertions. These two assertion types are illustrated separately and explicitly in . Negations are not allowed within security assertions . Syntactic validator analyzes each assertion to check if a negation is present. If a negation is present within a given assertion then the given assertion is rejected or disallowed.

Query level is populated with authorization queries such as example authorization query . Authorization queries of query level are permitted to include negations such as NOT operator . Authorization queries may be structured in any manner. Although not specifically shown in authorization queries may in general include one or more logical constraints.

In example authorization query the query is structured as a Boolean logical operation. Such Boolean logical operations may include any number of asserted facts any number of logical operators and so forth. The asserted facts logical operators etc. may be combined in any manner. Example logical operators include but are not limited to AND OR NOT and so forth. As illustrated example authorization query includes three asserted facts two AND operators and one NOT operator .

Whether or not an asserted fact is true depends on whether or not a valid matching assertion can be deduced. After this matching determination procedure is completed the resulting logical Boolean operation is evaluated. In the case of example authorization query NOT operator is applied to the TRUE FALSE determination of the far right asserted fact prior to applying AND operators . If the overall Boolean operation is evaluated to TRUE then the authorization decision is affirmative. If the overall evaluation of the Boolean operation is FALSE then the authorization decision is negative.

An example interrelationship between assertions and authorization queries e.g. example authorization query is presented below in the description of . An authorization query is ascertained responsive to a request which may include or otherwise be associated with one or more assertions . The authorization query is then evaluated in conjunction with an overall assertion context which includes assertions . The assertion context typically includes token assertions and policy assertions.

In a described implementation authorization context includes an assertion context . Assertion context is a collection of assertions . Specifically assertion context includes token assertions T and policy assertions P. Token assertions T derive from a security token e.g. security token of . The security token may be passed as part of and or along with a resource access request. Policy assertions P derive from a trust and authorization policy e.g. a trust and authorization policy module of of security policy .

Assertion context is forwarded to resource guard . A request is presented to resource guard . Request is a request to access some resource. Resource guard translates the request into an operation. The operation is provided to authorization query table . Authorization query table maps resource specific operations to authorization queries. In an example implementation each operation is associated with a single authorization query. In response to the provided operation security policy ascertains the associated authorization query and returns authorization query to resource guard . Ascertaining authorization query using an authorization query table is described further herein below with particular reference to .

Hence resource guard includes both assertion context and authorization query . Resource guard forwards assertion context and authorization query to evaluation algorithm of authorization engine . Evaluation algorithm comprises logic that is capable of evaluating authorization query in conjunction with assertion context . The logic may be implemented with hardware software firmware some combination thereof and so forth.

Thus assertion context is applied to authorization query in evaluation algorithm . After a logical analysis evaluation algorithm produces an authorization decision . Evaluating an authorization query in conjunction with an assertion context is described further herein below with particular reference to .

Generally a security language having the characteristics as described herein makes complex access control criteria relatively simple to write in a declarative manner and relatively simple to understand. It is compatible with any authorization algorithm that exposes a set of valid facts deduced based on an input policy and authenticated requestor data. As described further herein it is based on the concept of an authorization query that is combined with an authorization decision algorithm in conjunction with an assertion context.

In a described implementation generally an authorization query includes a set of asserted facts along with a constraint. The asserted facts are of the form A says fact . They express a requirement that a matching valid assertion can be deduced e.g. from the assertion context . If such a matching valid assertion is known then the asserted fact is satisfied and evaluates to the Boolean value True otherwise it evaluates to False. In some implementations the assertor of the fact may be known implicitly based on the evaluation context. In these cases it may be omitted. A constraint is an expression that returns a Boolean value. This may include variables used in the asserted facts as well as references to environmental values e.g. time location etc. . The constraint is typically used to express variable equalities and inequalities.

There is at least one asserted fact in each query. If multiple asserted facts are present they may be combined using logical operators such as AND OR and NOT. The optional constraint is logically ANDed with the asserted facts.

A consequence of this approach is that the basic access control policy may be written in terms of positive statements about the access each principal is authorized without concern for the higher level structural requirements. Thus in multiple principal policies one can write each policy stating what rights to a resource each principal should potentially have. Such security policies are monotonic in the sense that the addition of new policy statements does not remove any existing access right. Moreover one can write positive access policies indicating what rights a principal has to a set of resources without worrying about potential conflicts or inconsistencies. The authorization query provides the higher level semantics for combining these access control rules.

For example if one required i a user with a fabrikam.com email address and ii the application with code digest value ABC to grant read access to Foo the access control rules may be written as follows 

Similarly to require two authorized principals with fabrikam.com email addresses to have requested access to Foo the following security policy may be written 

Denies or exclusions may be appropriately handled using this approach. For example it is given that members of group A have read access to Foo and members of group B have read access to Bar but simultaneous access is not allowed. One can enable the desired access with a security policy having two policy assertions written as follows 

In a described implementation request is a request to access some identified resource . Request is translated via a translation function into a resource specific operation . This translation function may be performed by for example resource guard of . Examples of resource specific operations include by way of example but not limitation i reading and or writing a file ii sending data through a communications port iii utilizing a processor iv executing an application and so forth.

Generally operation is provided to authorization query table . Security policy for example may be responsible for applying operation to authorization query table and retrieving the associated authorization query . Authorization query is produced as a result and returned to resource guard .

More specifically authorization query table includes multiple fields . Each field maps a resource specific operation to an associated authorization query template. As illustrated there are f with f being some integer fields . . . in authorization query table . A retrieved authorization query template is returned to resource guard . Resource guard then performs a substitution procedure to produce authorization query . In other words to create authorization query resource guard substitutes the actual requesting principal the actual requested resource etc. into predetermined corresponding slots of the associated authorization query template.

As illustrated example authorization query evaluation includes an example assertion context an example authorization query a resulting Boolean operation and an answer . Assertion context includes i three token assertions T T and T and ii two policy assertions P and P . Example authorization query includes three asserted facts and two AND operators one NOT operator and one constraint .

During an evaluation authorization engine of attempts to determine if a valid matching assertion can be deduced for each asserted fact of authorization query . This matching determination process may be iterative recursive and or branching as one valid assertion leads to another possibly valid assertion. After some definite period of time the matching determination process converges.

Example authorization query evaluation of illustrates a simplified evaluation algorithm to facilitate a general understanding of the conceptual underpinnings of evaluating an authorization query. A more specific and technically accurate explanation is presented below after the description of . Moreover a relatively rigorous logical description of an example implementation is presented herein below after the description of .

In example authorization query evaluation it is determined by authorization engine that token assertion T is valid and matches asserted fact . It is also determined that policy assertion P is valid and matches asserted fact and that token assertion T is valid and matches asserted fact . Although token assertion T and policy assertion P do not explicitly match a particular asserted fact they may have been used in the matching determination process. Additionally a TRUE FALSE determination is made with respect to constraint .

After and or during the matching determination process a TRUE FALSE replacement process is carried out to create a Boolean operation . If a particular asserted fact has a matching valid assertion the particular asserted fact is replaced with TRUE . If not the particular asserted fact is replaced with FALSE . Any constraints are likewise replaced with their determined TRUE or FALSE status. Although not specifically shown with authorization query constraints are logically ANDed to the remainder of the authorization query.

For example authorization query evaluation authorization query may be textually indicated as follows asserted fact AND operator asserted fact AND operator NOT operator asserted fact and constraint . After the replacement process the resulting Boolean operation may be textually indicated as follows TRUE AND TRUE AND NOT TRUE AND TRUE. This reduces to TRUE AND TRUE AND FALSE AND TRUE which is logically FALSE.

Consequently answer for Boolean operation is FALSE . Hence authorization decision is to deny the request. If on the other hand there had not been for example a matching assertion for asserted fact Boolean operation would have reduced to TRUE AND TRUE AND TRUE AND TRUE which is logically TRUE. In this case answer would be TRUE and authorization decision would be to permit the request. Although not explicitly shown or described there are other permutations in which Boolean operation would evaluate to being logically FALSE e.g. if it were determined that there is no valid and matching assertion for asserted fact .

A more technically accurate example implementation for evaluating an authorization query is described here. Firstly the asserted facts inside an authorization query are evaluated one at a time and not necessarily all at once prior to a complete replacement process. Secondly the evaluation of a single asserted fact inside an authorization query returns a set of variable substitutions that make the asserted fact true. Thus in general the returned value is not immediately a TRUE FALSE status because facts are actually denoted as having a TRUE FALSE status with respect to a given variable substitution.

If the connective between two asserted facts inside an authorization query is AND as is the case in the example of the returned value i.e. the set of substitutions of the fact on the left hand side is applied to the fact on the right hand side. Afterwards the fact on the right hand side is evaluated as necessary. The resulting sets of substitutions are then combined by substitution composition. A result of evaluating the entire authorization query is a set of substitutions each substitution of the set of substitutions capable of making the authorization query true.

In a described implementation at block a request to access a resource is received. For example a request that identifies a resource may be received. At block the request is translated to an operation on resource. For example a resource guard may translate request into a resource specific operation .

At block the operation is provided to an authorization query table. For example resource specific operation may be provided to authorization query table . At block an authorization query that is associated with the operation is ascertained. For example a field that includes resource specific operation may be located. The associated authorization query may ten be retrieved from the located field .

More specifically the retrieved authorization query may comprise an authorization query template. The associated authorization query template is converted into the authorization query by substituting actual principals resources etc. into predetermined corresponding slots of the authorization query template based on the security tokens provided by the requester. In an example implementation resource guard which knows the actual variable information from request performs this conversion by substitution.

At block an assertion context and the authorization query are combined in an evaluation algorithm. For example an assertion context and authorization query may be jointly submitted to evaluation algorithm .

At block the valid assertions of the assertion context are matched to asserted facts of the authorization query in a matching determination process. For example one or more token assertions T and or policy assertions P which are deducible from assertion context i.e. originally present therein and or otherwise derivable there from that are found to be valid may be attempted to be matched to asserted facts in a matching determination process. Any constraint portions of authorization query are also analyzed to determine whether they are TRUE or FALSE. As noted above in the technical description each assertion may be analyzed separately and or sequentially.

At block a TRUE FALSE replacement into the authorization query is performed responsive to the matching determination process. For example asserted facts that are determined to have a valid matching assertion may be replaced with TRUE and asserted facts that are not determined to have a valid matching assertion may be replaced with FALSE in a Boolean operation . It should be understood that the action s of block may be performed in a manner that is fully or partially overlapping with the performance of the action s of block .

At block the authorization query is logically evaluated. For example Boolean operation may be logically evaluated as part of evaluation algorithm to determine if its answer is TRUE or FALSE. It should be understood that a result of Boolean operation may be determinable and indeed may be determined without replacing each asserted fact and or constraint with a TRUE or FALSE status.

At block it is determined if the authorization query logically evaluates to TRUE . If so the authorization decision at block is that the request is granted. If on the other hand it is determined that the authorization query logically evaluates to FALSE the authorization decision at block is that the request is denied. It should be understood that an algorithmic evaluation of an authorization query that may have a TRUE status may return a set of variables that renders the authorization query TRUE .

Security authorization queries may also be described from a relatively rigorous logical perspective. In a described logical implementation of security authorization queries authorization requests are decided by querying an assertion context which contains local as well as imported assertions. In an example implementation an authorization query may comprise a collection of atomic queries of the form A says fact and constraints c. These atomic queries and constraints are combined by logical connectives including negation. Example logical connectives include the following 

The resulting query language is more expressive than in other logic based languages where only atomic queries are considered. For example separation of duties threshold and denying policies can be expressed by composing atomic queries with negation and constraints. Negation is not allowed at the assertion level of the language because coupling negation with a recursive language results in semantic ambiguities and often to higher computational complexity or even undecidability. By restricting the use of negation to the level of authorization queries rather than adding these features to the assertion language proper the negation is effectively separated from recursion thereby circumventing the problems usually associated with negation.

The semantics of queries are defined by the relation AC q. In the following let AC be an assertion context. Also let be a substitution and let be the empty substitution. Let Dom be the domain of the substitution . If X is a phrase of syntax let Vars X be the set of variables occurring in X. An example formal semantics for authorization queries is as follows 

Given a query q and an authorization context AC an authorization algorithm returns the set of substitutions such that AC q. If the query is ground the answer set is either empty meaning no the request is denied or a singleton set containing the empty substitution meaning yes the request is granted . If the query contains variables then the substitutions in the answer set are the variable assignments that make the query true.

With regard to authorization query tables they may be part of the local security policy and may be kept separate from imperative code. The table provides an interface to authorization queries by mapping parameterized method names to queries. Upon a request the resource guard calls a method e.g. instead of issuing a query directly that gets mapped by the table to an authorization query which is then used to query the assertion context.

The formal evaluation of security authorization queries may also be described from a relatively rigorous logical perspective. The following description assumes the existence of another algorithm that returns the set of substitutions for which a given statement of the form e says fact is deducible from an authorization context AC. Such an algorithm may for example rely on translating AC into another logical language such as Datalog. The function AuthAnsis defined on authorization queries as follows 

The following theorem shows that AuthAnsis an algorithm for evaluating safe authorization queries. This theorem represents the finiteness soundness and completeness of authorization query evaluations For all safe assertion contexts AC and safe authorization queries q 

The devices actions aspects features functions procedures modules data structures protocols components etc. of are illustrated in diagrams that are divided into multiple blocks. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses APIs protocols arrangements etc. for security authorization queries.

Although systems media devices methods procedures apparatuses mechanisms schemes approaches processes arrangements and other implementations have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

