---

title: Method and apparatus for robust efficient parsing
abstract: The present invention provides a method for improving the efficiency of parsing text. Aspects of the invention include representing parse tokens as integers where a portion of the integer indicates the location in which a definition for the token can be found. In a further aspect, an integer representing a token points to an array of tokens that can be activated by the token. In another aspect, a list of pointers to partial parses is created before attempting to parse a next word in the text string. The list of pointers includes pointers to partial parses that are expecting particular semantic tokens.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07574347&OS=07574347&RS=07574347
owner: Microsoft Corporation
number: 07574347
owner_city: Redmond
owner_country: US
publication_date: 20060111
---
This application is a divisional of and claims priority from U.S. patent application Ser. No. 09 934 223 filed on Aug. 21 2001 and entitled METHOD AND APPARATUS FOR ROBUST EFFICIENT PARSING.

The present invention relates to natural language understanding. In particular the present invention relates to semantic and syntactic parsing of text strings.

In natural language understanding computerized language systems attempt to identify a logical representation for a text string. In some systems a semantic or meaning based representation is formed by performing a semantic parse of the text. In other systems a syntactic or grammar based representation is formed by performing a syntactic parse of the text.

In many systems the logical representation takes the form of a parse tree that has the words of the text as leaves and that has tokens at each of the nodes in the tree. Each token represents a logical abstraction for the words and tokens that are spanned by the token. A single token is at the root of the tree and spans the entire text.

In one type of parse the parse tree is formed by selecting one word at a time from the text string. With each word the parser first identifies those tokens that begin with the word. These tokens are then added as possible partial parses for the text string. In addition the parser determines if any partial parses can be extended based on the word. At times a word will complete a parse for a token. When this occurs the completed token is used to identify other tokens that begin with the completed token. In addition the partial parses are examined to determine if they can be extended by the completed token.

In the past the process of identifying tokens that could use a completed token was computationally intensive and therefore slowed the parsing of the text. In addition to identify which partial parses could be extended by a word or completed token all of the possible partial parses were examined under the prior art. Since there can be a large number of possible partial parses this also slows the parsing of the text.

Lastly for systems that have a large number of semantic or syntactic tokens a large number of hypothesis tokens can be generated during the parse. The large number of hypotheses makes the parse more complex and takes up a substantial amount of memory in the parsing system. Because of this an effective tool is needed for managing parsing hypotheses.

The present invention provides a method for improving the efficiency of parsing text. Aspects of the invention include representing parse tokens as integers where a portion of the integer indicates the location in which a definition for the token can be found. In a further aspect of the invention an integer representing a token points to an array of tokens that can be activated by the token. In another aspect of the invention a list of pointers to partial parses is created before attempting to parse a next word in the text string. The list of pointers includes pointers to partial parses that are expecting particular semantic tokens.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Memory is implemented as non volatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is preferably allocated as addressable memory for program execution while another portion of memory is preferably used for storage such as to simulate storage on a disk drive.

Memory includes an operating system application programs as well as an object store . During operation operating system is preferably executed by processor from memory . Operating system in one preferred embodiment is a WINDOWS CE brand operating system commercially available from Microsoft Corporation. Operating system is preferably designed for mobile devices and implements database features that can be utilized by applications through a set of exposed application programming interfaces and methods. The objects in object store are maintained by applications and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

Communication interface represents numerous devices and technologies that allow mobile device to send and receive information. The devices include wired and wireless modems satellite receivers and broadcast tuners to name a few. Mobile device can also be directly connected to a computer to exchange data therewith. In such cases communication interface can be an infrared transceiver or a serial or parallel communication connection all of which are capable of transmitting streaming information.

Input output components include a variety of input devices such as a touch sensitive screen buttons rollers and a microphone as well as a variety of output devices including an audio generator a vibrating device and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition other input output devices may be attached to or found with mobile device within the scope of the present invention.

In step of the first word in the text string provided to seeding unit is marked as activating a wildcard token if a symbol in the grammar can begin with a wild card. After the marking the first word in the string is selected by seeding unit at step and is placed in a candidate list at step .

At step the word or token placed in the candidate list at step is examined to determine if it is marked as activating a wildcard token. A wildcard token is a token that can represent any word provided by the user. If the entry activates a wildcard token a wildcard token is added to the candidate list at step . If not the process of continues at step .

At step the top entry in the candidate list is popped or removed from the candidate list by a rule engine . Rule engine uses the popped word to access a rule set to identify tokens and related rules that are activated by the popped token. A token is said to be activated by a word or other token according to a related rule when the word or other token is the first child node in the related rule for the token. In a left to right parser the first child node is the left most child. For example the semantic token is defined with rule where is the left most child node and is the right most child node.

At step the activated tokens together with the related rule are placed in a chart . If the activated token is fully defined by the current word the token is also placed in candidate list .

The word from the candidate list is also compared to partial parses in chart at step to determine if the partial parses can be extended by the popped word. Partial parses that can be extended but not completed by the word are extended which results in new partial parses that are placed in chart . Partial parses that are completed by the word results in full parses that are placed in candidate list .

Under many embodiments before a token is placed in candidate list it is scored by a metric calculator based on some scoring metric. Under one embodiment the scoring metric is based on the span of words covered by the token the number of levels of tokens formed beneath the token and the total number of tokens beneath the token. The score provided to a token is used to order the tokens in candidate list so that tokens that are more likely to appear in the final parse are popped before other tokens.

After the parses have been extended in step the next word in the text string is marked as activating a wildcard if any of the partial parses in chart is expecting a token that can begin with a wildcard. This is shown as step in . Rule engine then checks candidate list at step to determine if there are any other tokens that should be popped. If there are more tokens the process of returns to step .

Rule engine continues to remove the tokens placed in the candidate list one at a time. For each token rule engine determines if another token is activated by the popped token and whether any partial parses can be extended based on the popped token. It then updates the chart and candidate list. This continues until all of the tokens have been removed from the candidate list. When the candidate list is empty at step the next word in the text string is selected at step and the process returns to step .

Aspects of the present invention improve the efficiency of rule engine by reducing the amount of time needed to locate the definition for a token by reducing the time needed to identify tokens that are activated by a popped word or token from the candidate list and by reducing the time needed to identify partial parses that can be extended by a popped word or token. In addition aspects of the invention provide a way to reduce the number of partial parses that are formed by allowing some completed tokens to be pruned from further consideration.

One embodiment of the present invention improves the efficiency identifying the definition of a token by representing the token as an integer that points to its definition. As shown in this embodiment converts a token into a token id using a token hash table .

Under one embodiment the token id for a token contains two parts. This can be seen in where token ID is shown to contain a first part and a second part and token ID is shown to contain a first part and a second part . Second parts and which in many embodiments are formed by the last three bits of the token ID each point to a table such as tables and respectively that contain definitions for non terminals. First parts and provide offsets within their respective tables to the beginning of the definition for the token such as definition of table .

Note that by using a token id that provides a pointer to a table the present invention is able to accommodate different formats for the definitions of different kinds of non terminals. Thus definitions for tokens in one table could be of a different format from the definitions of tokens in a second table. This flexibility is made possible by the fact that the token id s pointer to the table indicates to rule engine the type of token that is being accessed and thus the format of the token s definition.

For example if the grammar includes semantic class tokens that are non terminals of semantic significance and wildcard tokens that are non terminals that can match anything the format of the definitions in a semantic class token table can be different from the format of the definitions in a wildcard table .

Thus the token IDs of the present invention provide quick access to the definition for a token. These definitions can include a number of different types of information about the token. For example in token definition is shown as containing properties and rules . Properties can include such information as whether or not the token can begin with a wildcard as shown by property entry in . This information is used in step to determine if a next token in a partial parse can begin with a wildcard. Rules provide a set of rules that are each formed of a sequence of token IDs representing non terminals and or words that can be parsed to form the token defined by token definition . Thus token ID represents the first token in a string of tokens that can be parsed to form the token of definition . Similarly token ID represents the first token in a second sequence of tokens that can be parsed to form the token of definition .

In a second embodiment of the invention the token IDs are used to identify tokens that can be activated by a token. This improves the efficiency of step in which rule engine places tokens in chart that are activated by the token popped from the candidate list. An embodiment for performing this function is shown in the block diagram of .

Under the embodiment of the token IDs are not used directly because they are not consecutive. This occurs because the last three bits of the Token IDs point to the table and unless there are 8 tables and an equal number of token definitions in each table the Token IDs will not be consecutive.

Instead of using the nonconsecutive token IDs the embodiment of converts the token IDs into a set of consecutive global token IDs. Thus when rule engine is trying to find the tokens that are activated by a token it converts the token ID for the token into a global token ID using a token ID to global token ID converter .

The global token ID represents an offset into an array of cells which contains a separate cell for each token. The offset identifies the cell for the token and the cell in turn contains a pointer to a second array such as array of .

Each element of array provides a separate token ID of a token that can be activated by the token popped from the candidate list. For example cell of array provides the token ID of a token B that can be activated by a token A popped from the candidate list. This token ID is used to locate the definition for the activated token B . Element also contains an offset to the location of the rule in the token definition that licenses the activation of the token B by the popped token A . This allows rule engine to quickly identify the tokens that will be added to the chart as the partial parse of the activated token. This partial parse will indicate which tokens have been popped from the candidate list and which tokens are still needed to complete the parse. Note that the first token ID in the rule pointed to by element should be the token ID of the popped token A .

By utilizing integers to represent tokens the present invention is able to improve the efficiency of identifying tokens that are activated other tokens. In particular the present invention does not require that a textual representation of the tokens be used to identify the other tokens that can be activated. Instead the integer representation is used to point to an array of tokens that can be activated by the token.

A third embodiment of the present invention provides an efficient mechanism for identifying partial parses in chart that can be extended by an entry popped from the candidate list. In particular as partial parses are formed or extended a pointer to the partial parse is placed in a hash table assigned to the word that was last popped from the candidate list. The hash table maps a token ID to an array of partial parses that need that token ID to be extended. Thus if two partial parses required the same token to be extended the hash table would map the token ID for the token to an array containing the two partial parses.

Token ID mapping for token A provides a partial parse array that contains a single partial parse for a token F . In the partial parse of token F is indicated by an equation with the token F on the left side of the equation and the tokens or words that form token F on the right side of the equation. In a dot is placed to the right of the last token or word that was received for the partial parse. Thus the token or word to the right of the dot represents the next token or word that is needed to extend the partial parse.

Like mapping mappings and include pointers to arrays and respectively that each include a single partial parse. Mapping for token C includes a pointer to an array that includes two partial parses and . Partial parse is for a token J and partial parse is for a token M . Both partial parse and partial parse need a token C to extend their parses.

Any partial parses that are newly created based on the current word or that are extended but not completed at the current word position are examined to determine the token ID that is needed to extend them. Partial parses that need the same token ID are grouped together in an array. Mappings between the token ID s and their respective partial parse arrays are then stored in a hash table for the next word position.

Under some embodiments robust parsing is supported by allowing for word skipping. Under such embodiments hash tables for past word positions are examined when a token is popped from the candidate list. If one of the past hash tables points to a partial parse that can be extended by the current token ID the partial parse is extended while skipping the words popped between the current word and the position of the past hash table.

By using mappings to the partial parses the present invention is more efficient than the prior art in that the system does not have to search through all of the partial parses to determine if any of them are waiting for a word or token popped from the candidate list. Instead the token ID of the popped word or token can be used to link directly to an array of all of the partial parses that are expecting that token or word. If the popped token or word does not have a mapping in the hash table then there are no partial parses that are expecting the token or word. In prior art systems a popped token or word would have to be compared to each partial parse to determine if the partial parse is expecting the token or word. As such the present invention is faster than most prior art systems.

Another aspect of the present invention provides an efficient means for pruning tokens to reduce the complexity of parsing text. Under one embodiment this pruning is achieved by limiting the number of same tokens that can span the same set of words in the input text string. Thus the number of tokens A that span from word n to word n i is limited.

The possible spans for a token are shown in the structure of where each node such as nodes and represents a different span of input text segment schedule a meeting for two o clock . For example node spans the single word a while node spans the words a meeting for two . To find the words spanned by a node the lines extending down from the node are simply followed to the two words they end at. For example to find the span for node line is followed to the word schedule and line is followed to the word meeting . Thus node spans the section of text schedule a meeting .

If the PC token of has previously been popped from the candidate list a pointer to the structure would have been added to a table such as the table of . If the PC token of was later popped from the candidate list the token and its span would be used to access the table of to determine if the same token had been popped for the same span before.

In an embodiment where only a single pointer is allowed a decision must be made between the previously stored structures and a structure that will exceed the limit of allowed structures for a token and span. For example if only one structure is allowed for a token and span then a decision would have to be made between the structure of and the structure of .

Under embodiments of the present invention several criteria can be used for selecting between two structures for the same token and span. In particular preferences can be given to those structures that skip fewer input words that skip fewer symbols in the parse tree include fewer nodes and have fewer levels in that order . Thus the structure of would be preferred over the structure of since the structure of has fewer nodes.

If a newly popped token is selected over a previously stored token the previously stored token must be replaced with the newly popped token in all of the partial parses that use the previously stored token.

Note that the sequential order in which tokens are popped from the candidate list is important under the present invention. In particular the inventors have discovered that tokens that represent smaller spans should be taken from the candidate list before tokens that represent larger spans. In addition for tokens with the same span the one with high score should be given high priority. In addition tokens that cover the word closest to the sentence start position should be given priority over tokens that have a span that is later in the sentence.

By limiting the number of same tokens that may span the same set of words the present invention reduces the complexity of the parser by limiting the number of parse structures that have to be maintained in the chart. This increases the speed of the parser.

Although the present invention has been described with reference to preferred embodiments workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention.

