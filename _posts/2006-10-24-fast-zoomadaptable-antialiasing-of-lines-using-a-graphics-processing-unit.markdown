---

title: Fast zoom-adaptable anti-aliasing of lines using a graphics processing unit
abstract: A method, system, and computer-readable storage medium are disclosed for performing anti-aliasing operations on lines using a graphics processing unit (GPU). Input comprising a plurality of vertices may be received at a GPU. The plurality of vertices may represent one or more line segments. One or more anti-aliased line segments may be generated based on the input. In generating the one or more anti-aliased line segments, the intensity of a first edge and a second edge of each line segment may be modified based on application of an anti-aliasing function. A maximum intensity of a central portion may be maintained for at least one of the line segments, wherein the central portion is between the two edges and is greater than one pixel in thickness.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07605825&OS=07605825&RS=07605825
owner: Adobe Systems, Incorporated
number: 07605825
owner_city: San Jose
owner_country: US
publication_date: 20061024
---
The present invention is directed to computer systems and more particularly it is directed to utilization of graphics processors associated with computer systems for anti aliasing operations.

As the power and complexity of personal computer systems increase graphics operations are increasingly being performed by dedicated graphics rendering devices referred to as graphics processing units GPUs . As used herein the terms graphics processing unit and graphics processor are used interchangeably. GPUs are often used in removable graphics cards that are coupled to a motherboard via a standardized bus e.g. AGP or PCI Express . GPUs may also be used in game consoles and in integrated graphics solutions e.g. for use in some portable computers and lower cost desktop computers . Although GPUs vary in their capabilities they may typically be used to perform such tasks as rendering of two dimensional 2D graphical data rendering of three dimensional 3D graphical data accelerated rendering of graphical user interface GUI display elements and digital video playback. A GPU may implement one or more application programmer interfaces APIs that permit programmers to invoke the functionality of the GPU.

To reduce demands on central processing units CPUs of computer systems GPUs may be tasked with performing operations that would otherwise contribute to the CPU load. Accordingly modern GPUs are typically implemented with specialized features for efficient performance of common graphics operations. For example a GPU often includes a plurality of execution channels that can be used simultaneously. A GPU may also include dedicated structures or built in program instructions for anti aliasing rendered objects. Anti aliasing is any technique for minimizing the jagged pixilated or aliased edges of objects. Typically aliasing occurs on objects with non orthogonal edges and anti aliasing may be used to provide a smoother appearance for those edges on a display screen or other rendered image. GPUs with dedicated anti aliasing features often use techniques such as multi sampling and super sampling. However these techniques may require extensive use of the GPU s built in memory and resources. Additionally these techniques are approximations that may not result in high quality anti aliasing.

An alternative approach developed by Eric Chan Fast Antialiasing Using Prefiltered Lines On Graphics Hardware Massachusetts Institute of Technology Feb. 28 2004 also published as Fast Prefiltered Lines 2 pages 345 359 described a technique for anti aliasing of thin lines using a GPU. The Chan technique involves drawing the line with its width increased by a fixed amount executing a pixel shader program on the GPU to index into a one dimensional texture containing an anti aliasing function and modifying the intensity of each pixel so that pixels near the center of the line have the highest intensity while pixels near the edge have the lowest intensity. An anti aliasing function can be calculated once for a number of samples and stored in the one dimensional texture for efficient re use. However because the anti aliasing function is applied to the entire line regardless of its thickness this prefiltered line technique is limited in scope.

Various embodiments of systems methods and computer readable storage media for performing anti aliasing operations on lines using a graphics processing unit GPU are disclosed. According to one embodiment input comprising a plurality of vertices may be received at a GPU. The plurality of vertices may represent one or more line segments. One or more anti aliased line segments may be generated based on the input. In generating the one or more anti aliased line segments the intensity of a first edge and a second edge of each line segment may be modified based on application of an anti aliasing function. A maximum intensity of a central portion may be maintained for at least one of the line segments wherein the central portion is between the two edges and is greater than one pixel in thickness.

According to one embodiment each line segment may be expanded by a radius r on both the first edge of the line and the second opposite edge of the line. The value of the radius may represent a desired thickness of the smoothed or blurred edges of the anti aliased line segment. Additional vertices may be added to the line segment s in the expansion process. The array of vertices may be sent from the CPU to the GPU in a single batch. The geometry may be stored on the GPU so that additional transfers from the CPU to the GPU are not required. For example if a zoom factor of the line segment s changes then the anti aliasing function may be modified by the zoom factor and the zoomed line segment s may be redrawn efficiently after retrieving the stored vertices.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

The GPU may include a host interface configured to communicate with a data source e.g. a communications bus and or processor s of a host computer system or the host system itself . For example the data source may provide input data and or executable program code to the GPU . In some embodiments the host interface may permit the movement of data in both directions between the GPU and the data source . The GPU may also include a display interface for providing output data to a data target . For example the data target may comprise a display device and the GPU along with other graphics components and or interfaces may drive the display by providing graphics data at a particular rate from a frame buffer.

In one embodiment the GPU may include internal memory . The GPU memory also referred to herein as video memory or VRAM may comprise random access memory RAM which is accessible to other GPU components. As will be described in greater detail below the GPU memory may be used in some embodiments to store various types of data and instructions such as input data output data intermediate data program instructions for performing various tasks etc. In one embodiment the GPU may also be configured to access memory of a host computer system via the host interface .

In one embodiment the GPU may include a plurality of execution channels A N as illustrated in . Using the plurality of execution channels A N the GPU may process a plurality of tasks in a substantially parallel manner such that a plurality of the execution channels A N are simultaneously in use. Each of the execution channels A N may perform tasks independent of the other execution channels A N. The GPU may be configured to process multi channel input and produce multi channel output. Multi channel input may comprise vectorized input and multi channel output may comprise vectorized output. In one embodiment the data in one channel of the multi channel input may be processed by the GPU independently of the data in the other channels. In one embodiment the multi channel input and multi channel output may comprise graphical data having a plurality of channels. For example the plurality of channels may represent RGBA data data comprising separate channels for red green blue and alpha data vertices textures etc. The plurality of channels may comprise overlapping channels in a rectangular area of graphical data. In one embodiment the number of the channels in the multi channel input and multi channel output may be equal to the number of execution channels in the GPU for optimal parallel processing. In one embodiment the GPU may include additional components configured to control the plurality of execution channels A N such as by distributing portions of the multi channel input to individual execution channels. In this manner the GPU may perform operations on multi channel input data.

The GPU may also be configured to perform single channel operations on single channel data using only one of the plurality of execution channels A N. A single channel operation may comprise an operation on non vectorized input or input having only one channel e.g. graphical data having only one channel . When the GPU is used in this manner however the remaining execution channels may be idle.

By performing the anti aliasing on the GPU the computational load on the host CPU may be reduced. Program code comprising instructions for performing the anti aliasing may be provided to the GPU . The program code may be stored in the GPU memory and executed by one or more of the execution channels A D. The program code may be configured to fetch and process a plurality of channels of input data in a parallel manner. In one embodiment the program code may be provided to the GPU by the CPU or other components of the computer system shown in . In another embodiment the program code may be native to the GPU .

The program code may comprise a vertex shader and or a pixel shader. A vertex shader comprises program instructions that are executable by the GPU to determine properties e.g. position of a particular vertex. A vertex shader may expect input such as uniform variables e.g. constant values for each invocation of the vertex shader and vertex attributes e.g. per vertex data . A pixel shader comprises program instructions that are executable by the GPU to determine properties e.g. color of a particular pixel. A pixel shader may expect input such as uniform variables e.g. constant values for each invocation of the pixel shader and pixel attributes e.g. per pixel data . In rendering the anti aliased lines both the vertex shader and the pixel shader may be executed at various points in the graphics pipeline.

In one embodiment the anti aliasing system and method described herein may provide for the rendering of anti aliased lines having substantially any thickness. The line thickness and rendering resolution may be taken into account such that an intensity gradient is applied to the two edges of the line while the central portion of the line may be left substantially unaltered. By contrast the prefiltered line technique described by Chan applies the intensity gradient through the entire thickness line from one edge to the other edge regardless of line thickness.

The value r may comprise the filter radius for the anti aliasing function. As will be shown in greater detail below the value of the filter radius may represent a desired thickness of the smoothed or blurred edges of the anti aliased line. In various embodiments suitable values of r may include 0.5 pixels 0.75 pixels etc. The value of r may be hard coded for all line segments or may vary from line segment to line segment.

The line segment s may be tessellated i.e. reduced to polygons at the new line width of w 2r. In one embodiment additional vertices may be added to the line segment s in the expansion process. illustrates an expanded line segment with additional vertices according to one embodiment. Vertex A and vertex B define the original line segment. Vertex C and vertex D define an expanded top edge. Vertex E and vertex F define an expanded lower edge. If vertex A and or vertex B is shared with another line segment then the appropriate additional vertices may be shared as well. In one embodiment each line segment may be tessellated as a pair of adjacent rectangles such that the segment is split in half lengthwise around the original line segment defined by vertices A and B.

For purposes of illustration the line segment shown in has a relatively wide stroke such that w 4r. However the system and method described herein may be applied to a line segment having a thinner or thicker stroke. The line segment of may be orthogonal or non orthogonal to either the X or Y axis of the two dimensional space in other words the line segment may have any orientation with respect to the X or Y axis.

A one dimensional texture coordinate may be added to each vertex with the line width of w 2r as its absolute value. The sign of the texture coordinate may be toggled to distinguish between vertices that lie on the edges of the line segment i.e. vertices C D E and F as opposed to the vertices that lie in the center of the line segment i.e. vertices A and B . In the example of therefore the texture coordinate may be w 2r for vertices A and B and w 2r for vertices C D E and F.

A current zoom factor may be stored during tessellation. In one embodiment the zoom factor may be represented as a uniform variable which is associated with all the line segments in the artwork tree. If the zoom factor changes in future redraws of the line segment s the ratio of the new zoom radius with the tessellation zoom radius may be calculated and sent as a uniform variable to the vertex shader on the GPU.

In one embodiment the operation represented by block may be performed by a CPU on the host computer system. As shown in block of the vertices including any uniform variables and per vertex values may be sent to the GPU for rendering. The GPU may be instructed to draw the vertices as quads or as triangles. In one embodiment the anti aliasing system and method described herein may use batch processing for efficient use of system resources. Using a single API call an array of vertices may be sent by the CPU to the GPU only once in a contiguous portion of memory. The geometry may be stored on the GPU so that additional transfers from the CPU to the GPU are not required. Based on the stored geometry the plurality of lines may be re drawn using a single API application programming interface call. This vertex buffering technique may yield much faster processing and re processing of anti aliased lines that the prefiltered line technique described by Chan which uses immediate mode drawing. In one embodiment the anti aliasing technique described herein is not dependent on per segment uniform variables. Instead the information usable for computing the intensity values may be stored directly in the vertex texture data. Therefore the anti aliasing system and method may avoid making expensive API calls to transfer data from the CPU to the GPU for each line segment.

The vertex shader on the GPU may take as input the position of each vertex and its one dimensional texture coordinate i.e. the line width w 2r plus the sign indicating whether the vertex is an edge vertex or a central vertex . As shown in block the vertex shader may determine two output values for each vertex. The output values may be represented as a two dimensional texture coordinate. In one embodiment the output values may comprise a filter lookup value and a pivot lookup value for each vertex.

The filter lookup value may comprise the intensity of the vertex as produced by an anti aliasing function. In one embodiment if a box filter is used for the anti aliasing function then the intensity is a linear function of the line width. Therefore no texture lookup is needed if a box filter is used for the anti aliasing function in one embodiment. For other types of filters a new texture coordinate may be calculated that will be used to index into a one dimensional anti aliasing function texture. The texture may comprise a gradient e.g. a grayscale spectrum . In one embodiment the edge vertices may be assigned a minimum intensity value e.g. fully transparent as the filter lookup value and the center vertices may be assigned a maximum intensity value e.g. fully opaque as the filter lookup value. The minimum intensity may be 0.0 and the maximum intensity may be 1.0. Values between 0.0 and 1.0 may sample the appropriate pixels in the one dimensional texture and values may be interpolated between available pixels if necessary.

In one embodiment the filter lookup value of a center vertex e.g. vertices A and B may be greater than 1.0 depending on the thickness of the line segment. In the example line segment shown in for example the filter lookup value of vertex A and vertex B may be 1.5. Filter lookup values less than 0.0 may be clamped to 0.0 and filter lookup values greater than 1.0 may be clamped to 1.0. illustrates a graph of lookup values for a segment e.g. as shown in having a central intensity of 1.5 e.g. at vertex A according to one embodiment. illustrates a modified graph of lookup values for a line segment according to one embodiment. In the example of the intensity of 1.5 has been clamped to 1.0.

The pivot lookup value may comprise the lookup value e.g. intensity at the original or true line edge as if the line segment had never been expanded. The pivot lookup value may also be referred to as the pivot point. The pivot lookup value may comprise a linearly interpreted value between the minimum intensity and the maximum intensity. In one embodiment the pivot lookup value may be a constant value e.g. 0.5 that is not calculated anew for every vertex. In the example graphs of and the pivot point is associated with a value of 0.5.

As shown in block the one or more line segments may be rasterized by the GPU to generate a plurality of pixels. In the rasterization step the two texture coordinates output by the vertex shader may be bilinearly interpolated. The filter lookup values at the vertices may be bilinearly interpolated across pixels depending on the positions of the pixels relative to the positions of the original vertices. The pivot lookup values may be constant across all pixels along the true edge of the line segment.

As shown in block the pixel shader may use the pixel s desired color the filter lookup value and the pivot lookup value to determine the final color of each pixel generated in block . The pixel shader may use the filter lookup value to index into the anti aliasing filter texture to determine the intensity. The final intensity may be clamped between 0.0 and 1.0. As discussed above the anti aliasing function is essentially the identity function if a box filter is used. The intensity may be multiplied by the pixel s alpha value to produce a final color value for the pixel. The adjusted pixel alphas may result in a high quality anti aliasing effect for the line segment s .

As shown in block the anti aliased line segment s may be displayed on a display device. Alternatively the anti aliased line segment s may be included in a bitmap which is stored in a memory and not immediately displayed. illustrates an anti aliased line segment produced by the method of according to one embodiment.

In one embodiment the vertex array generated by the CPU in block may be stored in a memory e.g. the GPU memory . Accordingly the one or more line segment s may be rendered again without retessellation by the CPU. By accounting for a zoom factor the anti aliasing system and method described herein may quickly and efficiently maintain the quality of rendered anti aliased lines when dynamically zooming in. When an anti aliased line segment is initially rendered a zoom factor may be associated with the displayed artwork e.g. as a uniform variable comprising a floating point value and stored on the GPU. The zoom factor may be generated during the initial tessellation.

In conjunction with a desired zoom redisplay of one or more line segment s may be invoked with a single API application programming interface call. After a zoom operation is invoked the stored vertex array may be retrieved. The vertex shader may use a new world matrix or other technique to transform the vertices from their original positions to their new zoomed positions. In one embodiment the vertex shader may again determine the filter lookup values and pivot lookup values. The stored zoom factor may also be retrieved and compared to the zoom factor of the desired zoom. The zoom ratio i.e. the ratio between the new zoom factor and the old zoom factor may be sent to the pixel shader. The zoom ratio may be provided to the pixel shader as a uniform variable associated with a plurality of line segment s .

For example if the zoom ratio is 2.0 then the one or more line segment s will be redrawn at twice their original size. However the original radius r is now twice as thick and the unadjusted smoothed edges of the anti aliased line segment s would be too large in relation to the rest of the line segment s . Therefore to adjust the size of the anti aliased edges the slope of the graph of lookup values may be multiplied by the zoom ratio while maintaining the pivot point . The resulting graph may be clamped between 0.0 and 1.0. Effectively this adjustment of the anti aliasing function by the zoom ratio may scale down the width of the anti aliased edge while ensuring that it converges at the pivot point i.e. the true line width . illustrates a graph of lookup values for a zoomed anti aliased line segment relative for example to the graph of according to one embodiment. illustrates a zoomed anti aliased line segment relative for example to the anti aliased line segment of according to one embodiment. In one embodiment the updated lookup value j may be calculated by the pixel shader on a per pixel basis as j p R i p where p is the pivot lookup value R is the zoom ratio and i is the original lookup value.

In one embodiment the GPU may be included in a specialized graphics card or other graphics component which is coupled to the processor s . Additionally the computer system may include one or more displays . In one embodiment the display s may be coupled to the graphics card for display of data provided by the graphics card .

Program instructions that may be executable by the processor s to implement aspects of the techniques described herein may be partly or fully resident within the memory at the computer system at any point in time. As is described with reference to another set of program instructions may be provided to the GPU for performing anti aliasing operations on the GPU . The memory may be implemented using any appropriate medium such as any of various types of ROM or RAM e.g. DRAM SDRAM RDRAM SRAM etc. or combinations thereof. The program instructions may also be stored on a storage device accessible from the processor s . Any of a variety of storage devices may be used to store the program instructions in different embodiments including any desired type of persistent and or volatile storage devices such as individual disks disk arrays optical devices e.g. CD ROMs CD RW drives DVD ROMs DVD RW drives flash memory devices various types of RAM holographic storage etc. The storage may be coupled to the processor s through one or more storage or I O interfaces. In some embodiments the program instructions may be provided to the computer system via any suitable computer readable storage medium including the memory and storage devices described above.

The computer system may also include one or more additional I O interfaces such as interfaces for one or more user input devices . In addition the computer system may include one or more network interfaces providing access to a network. It should be noted that one or more components of the computer system may be located remotely and accessed via the network. The program instructions may be implemented in various embodiments using any desired programming language scripting language or combination of programming languages and or scripting languages e.g. C C C Java Perl etc. It will be apparent to those having ordinary skill in the art that computer system can also include numerous elements not shown in as illustrated by the ellipsis shown.

In various embodiments the blocks shown in may be performed in a different order than the illustrated order. In any of the operations described in the blocks may be performed programmatically i.e. by a computer according to a computer program . In any of the operations described in the blocks may be performed automatically i.e. without user intervention .

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

