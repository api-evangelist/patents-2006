---

title: Methods and apparatus to perform process placement for distributed applications
abstract: Methods and apparatus to perform process placement for distributed applications are disclosed. An example method comprises determining a mapping between a communication graph representative of communications of a distributed application and a topology graph representative of communication costs associated with a computing network, and executing the distributed application with the processes of the distributed application assigned to the processing entities of the computing network based upon the mapping.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07644142&OS=07644142&RS=07644142
owner: Intel Corporation
number: 07644142
owner_city: Santa Clara
owner_country: US
publication_date: 20060504
---
This disclosure relates generally to distributed applications and more particularly to methods and apparatus to perform process placement for distributed applications.

A message passing parallel application i.e. a distributed application is cooperatively implemented via generally contemporaneous execution of two or more machine accessible instructions e.g. processes by one or more processors and or cores. A distributed application often has a non uniform number of messages and or data to be communicated between the two or more of processes that collectively implement the distributed application.

Symmetric Multi Processor SMP clusters multi clusters and or computing networks are commonly used to execute and or implement distributed applications. Such computing networks often have non uniform communication costs associated with the transmission of messages and or data between the processors cores and or computing nodes that form the computing network. For instance an example computing node contains multiple processors and or cores and has high bandwidth and or low latency i.e. low communication cost communication paths that connect the processors and or cores. However communication paths between processors and or cores of this example computing node and another processor and or core associated with any other computing node may have substantially lower bandwidth and or substantially higher latency i.e. a higher communication cost . For example messages and or data passed between two computing nodes may traverse through multiple Ethernet switches and or communication links and thus exhibit relatively higher latency and or lower bandwidth.

Given the non uniformity of communication requirements for a distributed application and the non uniformity of communication costs for a computing network the assignment of processes of a distributed application to processors cores and or computing nodes of a computing network has a direct and or potentially significant impact on the performance e.g. execution speed of the distributed application.

In the example system of one or more processors and or cores are implemented within a computing node e.g. a dual processor and or dual core computer server and or workstation with a plurality of computing nodes forming the example computing network . For simplicity the term processing entity will be used herein to refer to processors cores and or computing nodes. The processes of a distributed application may be developed using any variety of programming tool s and or language s and may be used to implement any variety of distributed application s . Further example processing entities of the example computing network of may execute any variety of operating system s . It will be readily appreciated by persons of ordinary skill in the art that the methods and apparatus to perform process mapping disclosed herein may be applied to any type topology and or size of computing networks and or to any variety of distributed applications.

To characterize the communication requirements for an example distributed application the example system of includes a communication profiler . Example communication requirements include a number of messages a number of bytes etc. sent between any two of the processes implementing the example distributed application for for example a representative time period function s etc. In the illustrated example of the example communication profiler profiles the communication requirements of the example distributed application while the distributed application is executing on the example computing network . Using any variety of method s technique s application programming interface s and or user interfaces s the communication profiler analyzes trace information collected by any variety of tracing tool such as for example the Intel Trace Analyzer and Collector or the Intel message passing interface MPI library. Alternatively the example communication profiler may characterize the distributed application by analyzing the source code of the distributed application and or by relying on information and or parameters provided by for example a programmer of the distributed application.

It will be readily apparent to persons of ordinary skill in the art that the communication requirements for a distributed application may vary. That is the communication requirements for a first portion of a distributed application may be different than those for a second portion. As such the example communication profiler of may be used to profile all or any portion of a distributed application. For example the communication profiler may be used to profile a portion representing the substantially largest communication needs and or computational processing. The communication profiler may also be used to profile an entire distributed application and thus the communication requirements represent a sort of overall average of the communication requirements. Moreover if a distributed application is modified e.g. changed number of processes application is scaled re distribution of workload amongst the processes etc. its communication requirements may change and thus it may be required desired and or beneficial for the communication profiler to re determine the communication requirements for the modified distributed application.

The example communication profiler of compiles the communication requirements into a communication graph having a plurality of graph edges that represents the communication requirements between each pair of the processes that implement the example distributed application. In the example of the example communication graph is stored as for example a data structure e.g. a matrix an array variable s register s a data table etc. in for example a memory and or a machine accessible file that is accessible to a graph mapper . An example data structure to store a communication graph is discussed below in connection with .

To characterize the communication costs associated with the example computing network the example system of includes a network profiler . Example communication costs include a maximum bandwidth a latency e.g. microsecond per kilo byte Kbyte an overhead etc. between each pair of the processing entities e.g. processors cores computing nodes etc. that implement the example computing network . The example network profiler of profiles the communication costs of the example computing network using any variety of topology discovery mechanism s method s and or technique s such as for example any variety and or combination of a message passing parallel ping pong tool a trace collector and or an MPI library. For example a trace collector could be used to characterize a message passing parallel ping pong tool thus discovering the topology of a computing network. For example outputs of the message passing parallel ping pong tool could be used to directly characterize the communication costs associated with the topology. Additionally or alternatively the example network profiler of could characterize the communication costs based upon a priori information regarding the communication device s communication paths and or communication links used to connect the processing entities of the example computing network . Example a priori information includes a bus transfer speed the delay and or latency through an Ethernet and or ATM switch etc.

It will be readily apparent to persons of ordinary skill in the art that if the size topology etc. of the example computing network is altered changed and or otherwise modified its communication costs may change and thus it may be desired and or beneficial for the network profiler to re determine the communication costs for the modified computing network . Moreover the communication costs may change over time depending on for example whether and or how other distributed application s processes jobs etc. are running and or scheduled on the example computing network .

The example network profiler of compiles the communication costs into a topology graph having a plurality of graph edges that represents the communication requirements between each pair of the processing entities that implement the example computing network . In the example of the example topology graph is stored as for example a data structure e.g. a matrix an array variable s register s a data table etc. in for example a memory and or a machine accessible file that is accessible to the graph mapper . An example data structure to store a communication graph is discussed below in connection with .

To determine a mapping between processes of an example distributed application and processing entities of the example computing network the example system of includes the graph mapper . The example graph mapper of determines a mapping of the vertices of the communication graph for the example distributed application to the vertices of the topology graph for the computing network that reduces the total and or overall communication cost for the example distributed application. In the illustrated example of for a particular mapping of processes i.e. nodes of the communication graph to processing entities i.e. nodes of the topology graph the total and or overall communication cost of a distributed application is computed as the sum of the costs associated with each of the edges resulting from a particular mapping. The example graph mapper uses for example a linear matrix M that is indexed with the numbers of processes to represent the mapping between processes and processing entities. An example matrix M 1 3 2 4 corresponds to the example mapping illustrated and discussed below in connection with . For purposes of explanation a linear matrix M will be used herein however persons of ordinary skill in the art will readily recognize that any other variety of data structure array matrix variable s register s and or table could be used to represent a mapping between processes and processing entities.

In the example system of the cost of a resulting mapped edge is computed using any variety of method s and or technique s such as for example multiplying the associated communication requirements and communication costs. The example graph mapper of locates a mapping that reduces the sum of these resulting map edge costs. In particular the example graph mapper locates a mapping that representing a minima of the following mathematical expression f W d EQN. 1

where wis the communication graph edge value between processes i and j dis the topology graph edge value between processing entities k and l where k M i and l M j and f for example is a function that multiples the two values wand d.

Starting with an initial random mapping M the example graph mapper sequentially considers alternative mappings. In particular the example graph mapper of considers alternative mappings that result from a switch of the mapping of two processes. For example if a first mapping maps processes i and j to processing entities M i and M j respectively an example alternative mapping maps processes i and j to processing entities M j and M i respectively. The improvement and or decrements i.e. gain resulting from such a mapping switch can be computed as a difference of the value of the mathematical expression of EQN. 1 before and after the considered pair switch. In particular components gain i j of a gain matrix that represents the swapping of all pairs of processes i and j can be computed using the following mathematical expression 

Starting with an initial random mapping M the example graph mapper uses the following process to locate the lowest overall cost mapping of processes to processing entities. The example graph mapper first computes the gain matrix using EQN. 2 and then selects a process pair swap that results in the largest gain i.e. the maximum gain matrix entry and has processes that have not yet been swapped. The example graph mapper saves the gain matrix entry i.e. the gain that would result from a swap of the selected process pair and then recalculates the entire gain matrix to model the mapping if the process swap was made. The example graph mapper continues selecting process pairs to swap and re computing the gain matrix until all of the pairs of the processes of the distributed application i.e. vertices of the communication graph have been swapped. The example graph mapper then determines which of the pair swaps resulted in the largest saved gain. The pair swap providing the largest saved gain is retained and all others swaps are discarded. The example graph mapper repeats the process described above until no additional swaps can be identified that result in an improvement to the overall communication cost for the distributed application i.e. a local minima has been identified . As discussed below to reduce the likelihood of finding a local minima as opposed to an overall minima the process may be repeated starting from one or more additional random mappings and then selecting the result that provides the lowest overall communication cost.

In the illustrated example of the number of processes of the distributed application and the number of processing entities of the example computing network are equal. If the number of processes is not equal to the number of processing entities then dummy vertices can be inserted into the smaller of the communication graph or the topology graph to equalize the sizes of the matrices.

The example graph mapper of stores the resulting graph mapping into any variety of data structure e.g. a matrix an array variable s register s a data table etc. in for example a memory and or a machine accessible file that is accessible to any variety of software entity and or tool associated with and or a part of the example computing network that is responsible for setup and initialization of a distributed application. In the example of the mapping data is simply a list associating particular processes of the distributed application with particular processing entities of the example computing network . In the example of the Intel Cluster Toolkit is used to read the mapping data and to setup and or initialize the distributed application based upon the mapping of processes to processing entities determined by the example graph mapper .

It will be readily apparent to persons of ordinary skill in the art that the memories and or machine accessible files and or may be implemented using any number of memories and or machine accessible files. For example a single memory may be used to store the communication graph the topology graph and the mapping data .

To measure the performance of a distributed application the example system of includes any variety of performance profiler . Using any variety of technique s and or method s the example performance profiler of determines the execution speed e.g. in seconds and or bandwidth e.g. Mega flops per second of the distributed application. For example the performance profiler may be used to measure the performance improvement of a distributed application resulting from a process to processing entity mapping.

Although an example system to map processes of a distributed application to processing entities of a computing network and to execute the distributed application based on the mapping has been illustrated in distributed application systems may be implemented using any of a variety of alternative and or additional devices entities modules etc. Further the devices entities modules elements etc. illustrated in may be combined re arranged and or implemented in any of a variety of ways. For example the communication profiler and tracing tool may be implemented using a single computing device and or platform. Further still any or all of the example tracing tool the example communication profiler the example graph mapper the example network profiler and or the example performance profiler may be implemented by hardware software firmware and or any combination of hardware software and or firmware.

While the methods disclosed herein do not directly identify deficiencies and or beneficial changes to a computing network the resulting communication costs e.g. the edges of associated with the mapping of a communication graph e.g. to a topology graph e.g. may be used by for example a programmer and or analysis program and or process to identify one or more ways that a computing network and or distributed application could be alternated changed enhanced to improve the performance of the mapped distributed application. For example the resulting communication costs could be used to determine the benefit of adding additional process es additional processing entity ies additional communication link s etc. Moreover the methods disclosed herein could additionally or alternatively be used to evaluate and or characterize possible performance and or communication improvements resulting from a change in a distributed application and or computing network.

The example machine accessible instructions of begin with the graph mapper reading and or accessing the communication graph for a particular distributed application block and reading and or accessing the topology graph for a particular computing network to which the distributed application is to be mapped block . To increase the likelihood of locating the best solution as opposed to a local minimum the graph mapper creates an initial random mapping M of the processes to the processing entities block .

The graph mapper then calculates the entries of a gain matrix for the initial mapping using for example the mathematical expression of EQN. 2 block . The graph mapper then locates the matrix entry having the largest value and not corresponding to a process that has already been temporarily swapped block . The graph mapper saves the identified matrix entry i.e. the gain that would result if the processes were swapped block and temporarily swaps the corresponding entries in the mapping matrix M block . The graph mapper then recalculates all of the entries of the gain matrix using for example the mathematical expression of EQN. 2 block . If not all processes have been temporarily swapped block control returns to block to locate the matrix entry having the largest value and not corresponding to a process that has been temporarily swapped.

When all processes have been temporarily swapped block based on the matrix entries saved at block i.e. gains for each of the temporary process swaps the graph mapper determines which process mapping swap resulted in the largest gain block . If the gain due to the selected swap is positive block the graph mapper discards all of the temporary process swaps except for the swap having the largest saved gain block . That is the graph mapper changes back the changes temporarily made to the mapping M while retaining the swap having the largest gain. Control then returns to block to repeat the process. If the gain due to the selected swap is less than or equal to zero block the graph mapper discards all of the temporary process swaps since the prior mapping already represented a local minima. The example machine accessible instructions of are then ended.

Alternatively after block the example graph mapper could save the current mapping and control could then return to block to locate another mapping starting from another initial random mapping. The better of the two mappings i.e. the mapping providing the lowest overall communication cost could then be selected. The graph mapper could repeat this process to determine any number of candidate mappings using any number of initial mappings. For example all possible mappings could be tested in which case the initial mapping need not be random.

The processor platform of the example of includes a general purpose programmable processor . The processor executes coded instructions present in main memory of the processor e.g. within a RAM . The processor may be any type of processing unit such as a processor from the Intel families of processors. The processor may execute among other things the example machine accessible instructions of to implement the example graph mapper of .

The processor is in communication with the main memory including a read only memory ROM and the RAM via a bus . The RAM may be implemented by dynamic random access memory DRAM Synchronous DRAM SDRAM and or any other type of RAM device and ROM may be implemented by flash memory and or any other desired type of memory device. Access to the memory and is typically controlled by a memory controller not shown in a conventional manner. The RAM may be used to store for example the example communication graph and or the example topology graph .

The processor platform also includes a conventional interface circuit . The interface circuit may be implemented by any type of well known interface standard such as an external memory interface serial port general purpose input output etc.

One or more input devices and one or more output devices are connected to the interface circuit . For example the input devices may be used to provide and or output the example mapping data .

Although certain example methods apparatus and articles of manufacture have been described herein the scope of coverage of this patent is not limited thereto. On the contrary this patent covers all methods apparatus and articles of manufacture fairly falling within the scope of the appended claims either literally or under the doctrine of equivalents.

