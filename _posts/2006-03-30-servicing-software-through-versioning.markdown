---

title: Servicing software through versioning
abstract: Software typically changes over its useful lifetime. New versions of software are created to change or improve functionality, to add functionality, to correct coding errors, improve performance, to adapt to new hardware and for many other well-known reasons. The process of delivering new versions of software to users is called servicing the software. The operating system decides which version(s) of a piece of software satisfy dependencies of other software by creation of a context. The context may be used to organize and manage versions of software, to declare activation policies concerning the use of different versions of software and to service the versioned software. The context may include an activation service that maintains and manages resolution polices, resolves dependencies, constructs the environment in which an application runs and initiates the running of the software.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08060871&OS=08060871&RS=08060871
owner: Microsoft Corporation
number: 08060871
owner_city: Redmond
owner_country: US
publication_date: 20060330
---
Software typically changes over its useful lifetime. New versions of software are created to change or improve functionality to add functionality to correct coding errors improve performance to adapt to new hardware and for many other well known reasons. The process of delivering new versions of software to users is called servicing the software.

A typical operating system does not know what executable software resides on the machine nor does it know what system or software resources are needed by the software to execute. It follows therefore that the operating system can have no knowledge of how or if one piece of software depends on another and will be unable to determine if a particular piece of software will run. This state of affairs makes it difficult to properly service software. For example in the course of installing new software one version of a program relied on by an existing piece of software may be overwritten with a new version rendering the existing piece of software inoperable. The operating system is unable to prevent this from happening because it does not know that the existing piece of software needs a different version of the program.

The operating system manages a set of software entities by creating a construct called a context that organizes and manages software related state and enables software to be serviced through versioning. Software related state includes the condition of the software entities themselves their property settings versioning information and the setting of activation policies. The context may include an installation service and an activation service. The installation service is responsible for installing uninstalling and servicing software entities within its context. The installation service keeps track of what software is installed and available within the context the version of the installed software what resources are needed by the software to run and makes installed software entities available to the activation service. The activation service maintains and manages resolution polices resolves dependencies constructs the environment in which an application runs and initiates the running of the software.

One type of software entity managed by the context is a software item. A software item is a uniquely identified unit comprising a piece of program code source and or executable accompanied by metadata. The metadata may be provided in the form of a manifest. Metadata may include versioning information dependencies and other information. A dependency refers to the requirement of one software entity for a second software entity. A software item may have a dependency on one or more other software items. One or more ranges of versions of software items which can be used to satisfy a dependency may be expressed as part of a dependency declaration. When multiple ranges of versions satisfy a dependency an order of preference may be provided for the ranges. Also ranges of versions of software items which are inadequate to solve the dependency may be declared.

A software item comprising code and metadata is received by an installation service. A global policy table provides a mechanism for system administrators to set policy. A calculated local dependency table is created for each software item by filtering software dependencies reflected in the local dependency table through entries in the global policy table. An activation service includes a dependency resolution mechanism that resolves conflicts between dependencies and returns a solution set. Each solution of the solution set includes a set of software items with all their dependencies satisfied under the restrictions described in the policy as well as in the dependency requirements of the included software. A single solution is selected from the set of possible solutions. An activation schema is generated using the selected solution

An operating system according to some embodiments of the present invention is aware of what executable software resides on the machine and what resources including other software entities are needed by the software to execute. The operating system is aware of how or if one piece of software depends on another and is able to determine if a particular piece of software will run. The operating system is aware of what other software is needed for the software to run.

Servicing software entities makes a different usually newer version of the software available to the system and may include the installation of the newer version of the software. New versions of software may be made available to reduce defects improve function provide new functions modify previously provided functions accommodate new hardware or for other well known reasons.

When software A expects to use the functionality of software B to perform its function it is said that software A has a dependency on software B. Servicing a piece of software introduces the problem of determining if and how changing the software will affect other software that depends on it. In accordance with embodiments of the invention the operating system manages and controls installing and servicing software. A software item comprising code and metadata is received by an installation service. A global policy table provides a mechanism for system administrators to set policy. A calculated local dependency table is created for each software item by filtering software dependencies reflected in the local dependency table through entries in the global policy table. An activation service includes a dependency resolution mechanism that resolves conflicts between dependencies and returns a solution set. Each solution in the solution set includes a set of software items with all their dependencies satisfied under the restrictions described in the global policy as well as in the dependency requirements of the included software. In some embodiments the set of software items returned as the solution does not include software items which are not required or are duplicative. A single solution is selected from the set of possible solutions. In some embodiments of the invention the single solution is selected based on policy set in the computing environment. An activation schema is generated using the selected solution.

Although not required the invention can be implemented via an application programming interface API for use by a developer and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . A graphics interface such as Northbridge may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU or host processing unit and assumes responsibility for accelerated graphics port AGP communications. One or more graphics processing units GPUs may communicate with graphics interface . In this regard GPUs generally include on chip memory storage such as register storage and GPUs communicate with a video memory . GPUs however are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

One of ordinary skill in the art can appreciate that a computer or other client device can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

The operating system manages a set of software entities by creating a construct called a context. A context is used to organize software related state and to declare policies in a system. The context enables the operating system to decide which versions of a software entity satisfy the dependencies of other software entities and to install the appropriate software entities. A context may represent a system context developer context manager context user context or other type of context.

A context may include an installation service and an activation service. illustrates one embodiment of a system for servicing software through versioning. System may reside on a computer such as computer described above with respect to . In a context includes an installation service and an activation service .

One type of software entity that can be managed by a context such as context is a software item . A software item is a resource known to the operating system by a unique name or identifier. In some embodiments of the invention it includes program code and associated data including version information typically presented as a number that is incremented as changes are made to the software over its lifetime packaged into a unit. The software item may include source and or executable code and metadata. Software items that provide code to be executed within a defined environment are called executable software items e.g. a file that ends in .EXE is one type of file that represents the code portion of an executable software item . Collections of shareable code and data are called framework software items e.g. a file that ends in .DLL is one type of file that represents the code portion of a framework software item . An executable or framework software item may depend on or require one or more additional executable or framework software items for execution. In some embodiments of the invention each executable software item and each framework software item is expected to declare the set of other executable software items and framework software items that it depends on. The set of software items on which the software item depends is referred to as its dependencies.

As stated above the software item may also include metadata. In some embodiments of the invention the metadata accompanying the code is provided in a manifest . The metadata may include versioning information of the software item and dependency information. The metadata may also include the dependency list for the software item. For example a software entity such as a software item e.g. Software Item D may require the presence of another software item e.g. Software Item C in order to run. It will be appreciated that Software Item C is likely to have its own dependencies. For example software item C may itself have two dependencies dependency 1 satisfied by software item A and dependency 2 satisfied by software item B. Thus assuming that A and B have no new dependencies of their own to run software item D software items A B C and D must be available. The dependency may be required or optional. For example instead of being required Software Item C may add functionality but not be necessary for Software Item D to run. For example a word processing program may have an optional thesaurus installed but the word processing program may not require the thesaurus to run. Dependencies may have version requirements e.g. Software Item C version 2 must be present for Software Item D version 4 to run . In some embodiments of the invention the version requirement may contain a number of ranges of versions preferred to satisfy a certain dependency. Also in some embodiments of the invention ranges of versions inadequate to solve the dependency may be included. The list of software items that are used to satisfy each dependency may be calculated when the software item is installed. Each time a software item is installed the way dependencies are satisfied may be altered requiring the re computation of at least some of the dependencies.

Metadata may also include a property set a list of property name value type pairs. In some embodiments the code of the software item can access only the declared properties via the established property names. The values assigned to the properties for a particular context may be referred to as configuration data. Metadata may also include resources the code may need to run and other information.

An installation service e.g. installation service keeps track of what software is installed and available within the context the version of the installed software what resources are needed by the software to run and what configuration properties or settings have been defined for the software entity. The installation service also installs removes and services software entities and makes the installed software items available to the activation service. When a software item such as software item is received by the installation service for installation the code may be stored in the installation store . Once a software item is installed it may be immutable. That is once a software item is stored in the installation store no system event will alter the existing software item. Installation of a new or different version of the software item will not affect the existing software item. In some embodiments software not installed by the installation service cannot be executed on the computer.

When a software item is received by the installation service the metadata of the software item e.g. perhaps provided in the form of a manifest maybe entered into a local dependency table not shown . The local dependency table may be filtered by a global policy table to create a calculated local dependency table . For example a manifest may be received by the installation service . The manifest may include information about dependencies of the software item. For example the manifest may indicate that software item A has dependencies and . The manifest may represent the experience of the publisher of the software item for example the publisher of the software may have determined that the software item A works with versions 1 and 3 of dependency 2 but not with version 2. This information may be included in the manifest. Similarly the information may be presented in ranges e.g. software item A works with versions 3 5 of dependency 2 . From the manifest a local dependency table may be generated. The local dependency table is filtered by global policies represented in a global policy table to created a calculated local dependency table e.g. local dependency table 

The global policy table enables policy to be set across the entire system or across one or more contexts. That is global policy can dictate which software items the system allows for activation and which software items can substitute for other software items. When multiple options exist the global policy table can establish a preference of which option to select. The global policy table may provide a mapping function whereby use of one or more versioned software item is re mapped to sets of preferred software items. For example a global policy table may specify that whenever any version of software item A is encountered version 1 of software item A should be used instead. Similarly the global policy table may specify that whenever software item B version 2 is encountered software item B version 4 should be substituted for software item B 2.

In some embodiments of the invention the substitution takes place in a calculated local dependency table . That is for each dependency of a software item installed into the context the installation service determines a set of software items represented in the local dependency table. The local dependency table is filtered by the global policy table creating a calculated local dependency table . In some embodiments of the invention the rows of the calculated local dependency table represent software items and the columns represent the dependencies of the software items. For example a local dependency table may include the following information 

The activation service constructs the environment in which an application will run e.g. execution environment and initiates the software. Before a software item can be activated a set of acceptable values for the dependencies of the software items and the dependencies of their dependencies and so forth must be determined. In some embodiments the dependency resolver of the activation service resolves dependencies determines if all dependencies are satisfied and loads the software items satisfying the dependencies received from the installation service into the execution environment . A software item may not be activated unless all of the required dependencies are satisfied. Software item resolution may occur at least in part when the software item is installed. The resolution may be saved or persisted and reused whenever the item is activated. Alternatively software item resolution may occur at activation time. Activation of an executable includes creating an isolated process by providing the execution environment with the code the executable software item carries with it. Activation of a framework software item includes loading one or more of the framework codes within a particular process memory space so that it can be executed. Dependencies between software items mean that activation of a software item may require that other framework software items are loaded along with the software item.

The inputs to a resolution mechanism that performs the above functions include the calculated local dependency table which provides a table including a set of alternatives for satisfying dependencies. The resolution mechanism returns a set of possible solutions . In some embodiments of the invention a single solution is selected. Considerations for selection of the single solution from the set of solutions may include the following 

Appropriate policy settings in the computing environment may be used to select the particular consideration or set of considerations to take into account. An activation schema e.g. activation schema may be generated from the selected single solution.

In some embodiments of the invention in addition to the above listed components of a context another component called a configuration service is included. The configuration service maintains manages and mediates configuration settings associated with the software. Before a software entity is activated its properties must be initialized to proper values. The process of setting these values is called configuration. In some embodiments of the invention property values for a software entity such as a software item are stored in a configuration store not shown . The set of property values for an application in a context contributes to application state. Configuration settings are provided to the activation service for a software item and its dependencies when a software item is to be executed.

versioning information a description of the configuration data the code uses resources the code may need to run dependencies and other information. At a local dependency table is created. The local dependency table may include information received from the manifest concerning dependencies of the software item. At the local dependency table may be filtered by information presented in the global policy table. The global policy table enables policy to be set across the entire system or across one or more contexts. That is global policy can dictate which software items the system allows for activation and which software items can substitute for other software items. When multiple options exist the global policy table can establish a preference of which option to select. The global policy table may provide a mapping function whereby use of one or more versioned software item is re mapped to sets of preferred software items. Filtering the local dependency table with the global policy table may result in changes to the local dependency table and creation of a calculated local dependency table . At the calculated local dependency table is provided as input to a dependency resolver. The dependency resolver generates a set of potential solutions to the dependency requirements of the software item and its dependencies at as described above with respect to . At one of the solutions is selected and an activation schema is generated therefrom . At the software items described in the activation schema are loaded into an execution environment from the installation store.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects of the present invention e.g. through the use of a data processing API or the like are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. Therefore the present invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

