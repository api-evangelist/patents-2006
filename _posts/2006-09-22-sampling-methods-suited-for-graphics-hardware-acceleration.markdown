---

title: Sampling methods suited for graphics hardware acceleration
abstract: Embodiments of the invention provide sampling methods suited for graphics hardware acceleration. A graphics application may specify a grid of pixels to be rendered. The graphics application may supply a graphics rendering engine with one or more sets of camera parameters. Each set of camera parameters is used to alter the position of the pixel grid relative its original position so that a grid of samples can be generated at the new grid position. The graphics rendering engine then renders a grid of samples at the new grid position. Each sample grid may be used sampled to determine a set of intermediate color values that may be blended together to generate a final color value for each pixel in the pixel grid.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07742060&OS=07742060&RS=07742060
owner: Autodesk, Inc.
number: 07742060
owner_city: San Rafael
owner_country: US
publication_date: 20060922
---
The present invention generally relates to graphics processing. More specifically the present invention relates to techniques for rendering an image using sampling methods suited for graphics hardware acceleration.

In computer graphics rendering is the process of determining color values of the pixels of a two dimensional graphics image based on a three dimensional graphics scene typically generated by a graphics application. When graphics images are rendered various artifacts such as jagged edges may ultimately appear in the image. A number of anti aliasing techniques exist that blend the colors of pixels adjacent to one another in an image to mask artifacts in the image. For example such blending can make jagged edges appear smoother to the human eye. Typical anti aliasing techniques use multiple color values or samples to determine the final color value of each pixel in the graphics image so that there is a more gradual transition between the different objects and colors in the graphics image.

Currently random and pseudo random sampling methods have been used to reduce aliasing effects when generating images using a software based rendering engine. This approach has the advantage of using a random sampling pattern for anti aliasing so that the sampling frequencies are less likely to correlate with the spatial frequencies in the graphics image but requires that the image be rendered by software routines that execute on a general purpose central processing unit CPU . While effective the software approach is significantly slower than using hardware based rendering techniques.

In contrast to software renderers dedicated graphics processing units GPUs typically use a fixed sampling pattern to perform anti aliasing operations. GPUs are specifically designed to process image data much more quickly than a CPU. However the sampling patterns used by GPUs may introduce moir ringing or animation artifacts for some images. Moir effects are most often generated when the sampling frequency of the anti aliasing grid pattern correlates with one or more spatial frequencies present in the graphics image. For example images that include regular patterns such as roof lines or brick walls checkerboards or any other repeating pattern in an image may lead to moir effects when using anti aliasing techniques that rely on grid based sampling.

Accordingly what is needed in the art is a sampling technique suited for graphics hardware acceleration that is not as prone to artifacts such as moir effects as current hardware based sampling techniques.

Embodiments of the invention provide an anti aliasing sampling method suited for graphics hardware acceleration.

One embodiment of the invention includes a method for determining color values for pixels in a graphics image. The method generally includes receiving an initial location of a pixel grid and one or more sets of camera parameters. Each set of camera parameters may be used to perturb the initial location of the pixel grid to define a sample grid. The method further includes rendering each sample grid to a generate a color value for each sample within each sample grid and sampling each sample grid to determine a set of intermediate color values for each pixel in the pixel grid. The sets of intermediate color values may then be combined to generate a final color value for each pixel in the pixel grid. For example in a particular embodiment as each sample grid is sampled to determine the set of intermediate color values accumulating the set of intermediate color values for each pixel in the pixel grid in a memory buffer. After each of the sample grids is sampled the accumulated value for each pixel may be divided by the number of sample grids to determine a final color value for each pixel in the pixel grid.

Another embodiment of the invention includes a computing device configured to generate color values for pixels in a graphics image. The computing device may generally include a central processing unit coupled to a system memory and a graphics processing unit coupled to the central processing unit and including a graphics rendering pipeline. The graphics rendering pipeline may be configured receive an initial location of a pixel grid and one or more sets of camera parameters. Each set of camera parameters may be used to perturb the initial location of the pixel grid to define a sample grid. The graphics rendering pipeline may be further configured to render each sample grid to generate a color value for each sample within each sample grid sample each sample grid to determine a set of intermediate color values for each pixel in the pixel grid and combine the intermediate color values in each set of intermediate color values to generate a final color value for each pixel in the pixel grid.

Advantageously embodiments of the invention provide an anti aliasing technique that leverages the rendering speed of hardware graphics pipeline without relying on a regular grid or repeating pattern to generate a color value for a given pixel. Thus not only is overall performance generally increased relative to prior art software rendering techniques the occurrence of moir effects and other artifacts may be reduced thereby increasing overall image quality relative to prior art rendering techniques.

Embodiments of the invention provide sampling methods suited for graphics hardware acceleration. In one embodiment a graphics application specifies a grid of pixels to be rendered where the pixel grid represents a portion of a two dimensional graphics image being rendered from a three dimensional graphics scene generated by the graphics application. The graphics application may be configured to supply one or more sets of camera parameters. Alternatively sets of camera parameters may be determined by a graphics driver or even the by graphics hardware directly. Each set of camera parameters is used to alter the position of the pixel grid relative to its original position so that a grid of samples can be generated at the new grid position. For example the camera parameters may specify to translate rotate scale and or skew the original pixel grid. A graphics rendering engine then renders a grid of samples at the new grid position. The values of the different samples in a particular sample grid reflect the colors of the three dimensional graphics scene at a camera position defined by the set of camera parameters associated with the sample grid. A final rendering step is then performed where each sample grid is sampled to determine a set of intermediate color values for each pixel in the pixel grid. The intermediate color values are blended together to generate a final color value for each pixel in the original pixel grid. Alternatively sample grids may be accumulated into single storage location as each sample grid is rendered. Once intermediate values for each of the sample grids has been accumulated the resulting values may be divided by the number of sample grids to generate a final color value for each pixel in the original pixel grid.

This rendering technique enables standard graphics hardware to implement a sampling pattern when rendering a set of pixels that is more irregular than the sampling patterns typically implemented by the hardware. Irregular sampling patterns reduce the incidence of moir effects and other artifacts in rendered graphics images since the likelihood of having a sampling frequency that strongly correlates with a spatial frequency of a rendered graphics image is substantially reduced. Thus overall image quality is enhanced. At the same time however a graphics rendering engine may quickly manipulate and render the various sample grids thereby maintaining overall system performance. This is particularly the case for graphics hardware having multiple graphics pipelines allowing multiple sample grids to be rendered simultaneously.

As shown computing device includes without limitation a central processing unit CPU connected to a system memory a graphics processing unit GPU and a frame buffer connected to GPU and to a display device . GPU includes at least one rendering engine that incorporates at least one graphics rendering pipeline used to process graphics data. Frame buffer stores data processed by GPU . When a display frame is completed the contents of frame buffer may be output to display device for display. Typically display device is a CRT or LCD display. Persons skilled in the art will recognize that any system having one or more processing units configured to implement the teachings disclosed herein falls within the scope of the present invention. For example computing device may be without limitation a desk top computer a laptop computer a mobile telephone a set top box or a personal digital assistant device. Thus the architecture of computing device in no way limits the scope of the present invention.

Graphics application may include calls to a graphics application programming interface API . Well known graphics API s include the OpenGL and Direct3D APIs however no particular graphics API is required for the present invention. Graphics API provides a collection of function calls and data structures to graphics application that may be used to draw and manipulate complex two dimensional or three dimensional scenes from simple primitives. In turn a driver implements the functions and data structures defined by graphics API for a particular set of graphics hardware . Thus graphics API provides a common interface which allows any application that uses the functions of graphics API to run on any graphics hardware with a driver written to graphics API .

One family of functions provided by graphics API may allow an application developer to supply a set of camera parameters used to control the location of a pixel grid within the graphics scene being generated by graphics application . In one embodiment multiple sets of camera parameters are each used to perturb the position of the pixel grid relative its original position. The camera parameters may specify any combination of rotation translation scaling or skewing that should be used to alter the location of the pixel grid. The resulting translated rotated and or scaled pixel grid is referred to herein as a sample grid. As is well understood by changing the position of the camera within the graphics scene the color values generated when a particular sample grid is rendered may change relative to the color values that would have been genreated had the pixel grid been rendered at its original position. Alternatively graphics API may expose some of the camera parameters to the application while computing others internally. For example graphics API may allow graphics application to set the number of sample grids but compute random rotation translation scale internally. Of course other combinations of camera parameters that may be specified through graphics API may be appropriate for a particular case. As described in greater detail herein the color values for the pixels in the original pixel grid may be determined by combining intermediate color values that are generated by sampling each of the sample grids created from the sets of camera parameters. Further even though each sample grid may have a regular geometric pattern the combination of samples in the different sample grids used to determine the final color value for a pixel in the pixel grid has a pseudo random quality thereby reducing moir and other artifacts in the rendered graphics image.

As shown the positions of pixels and in pixel grid have moved from initial positions to the ones shown by samples and in sample grid . When sample grid is rendered the color values generated for samples and may be different than the color values that would be generated for pixels and by rendering pixel grid . The color values generated for samples and along with intermediate color values generated from additional sample grids are used to determine a final color value for each pixel in pixel grid .

Method begins at step where the pixel grid to be rendered is defined. The pixel grid may encompass any selection of pixels up to and including the complete display resolution of a screen image to be generated. Alternatively a developer may identify regions of an image where moir or other anti aliasing artifacts are occurring and define a pixel grid to encompass such regions. The ultimate size of the pixel grid and associated sample grids is generally limited only the capability of the graphics hardware.

At step one or more sets of camera parameters may be supplied to perturb the location of the pixel grid defined at step from its initial location. Each set of camera parameters is supplied by an end user through a graphics application such as graphics application and may include any combination of parameters used to translate rotate and or scale the pixel grid defined at step . Note although the example below uses three sets of camera parameters any number may be used so long as the resulting number of sample grids can be supported by the graphics hardware.

At step a graphics rendering pipeline such as the graphics rendering pipeline may be used to generate a sample grid for each set of camera parameters. Each sample grid is defined relative to the original pixel grid defined in step by perturbing the pixel grid from its original coordinate position based on the camera parameters associated with the sample grid being generated. Once defined graphics rendering pipeline may be used to render the sample grid. During the rendering process color values for the different samples in the sample grid are generated. As each sample grid is rendered the color values of the samples in the sample grid are stored in a memory local to the GPU such as frame buffer . Additionally graphics hardware commonly provides multiple graphics rendering pipelines. In such a case multiple sample grids may be passed to different pipelines for parallel rendering.

At step the final color value for each pixel in the pixel grid is computed by sampling each of the sample grids generated in step in a final rendering pass and blending the results. The type of sampling used is determined by the sampling functionality implemented in the graphics rendering pipeline. For example if the graphics hardware implements a simple point sampling algorithm then for each pixel in the pixel grid the color value of the sample in each sample grid located closest to the pixel is assigned to the pixel producing a plurality of intermediate color values for the pixel. In the case where there are three sample grids for each pixel three intermediate color values are generated. The intermediate color values are then weighted and blended to compute the final color value for the pixel.

In alternative embodiments the graphics hardware may implement more complicated sampling algorithms such as bilinear or trilinear sampling. For example if bilinear sampling is used then for each pixel the color values of the four samples in each sample grid located closest to the pixel are blended together using bilinear filtering techniques to produce a plurality of intermediate color values for the pixel. Again in the case where there are three sample grids for each pixel three intermediate color values are generated. The intermediate color values are then weighted and blended to compute the final color value for the pixel. As persons skilled in the art will appreciate the type of sampling functionality implemented by the graphics rendering pipeline in no way limits the scope of the present invention.

At step a sample grid is rendered for one set of camera parameters. At step the sample grid is sampled to determine an intermediate value for each of the pixels in the original pixel grid. The results may be accumulated into a memory local to the GPU such as frame buffer . In one embodiment before being accumulated into memory each sample grid may be filtered. For example a small blur e.g. with a radius between 1 2 pixels may help to further reduce the occurrence of moir and or animation artifacts.

At step if more sets of camera parameters remain the method returns to step and repeats steps and for another set of camera parameters. At step once each sample grid has been rendered and the results stored in memory the final color values for the pixels in the original pixel grid may be determined by dividing the accumulated values by the number of sample grids. Advantageously this approach requires the use of only a single additional buffer regardless of the number of sample grids used.

The output of setup engine includes triangles transformed and projected onto a two dimensional surface sometimes referred to as screen space corresponding to a window on the viewer s screen. As described above the content of the screen space depends at least in part on the position of the camera. The geometric primitives in screen space emitted by setup engine are decomposed by rasterization engine into fragments corresponding to screen space pixels that are least partially covered by the geometric primitives. Additionally rasterization engine may be configured to determine the screen space coverage and alignment of each geometric primitive.

Shader engine receives fragments from rasterization block and processes the fragments according to shading instructions specified by the graphics application. The processed fragments may be transmitted to Raster OPerations ROP block for further processing. ROP block conducts any depth and stencil testing on the shaded pixels as specified by the graphics application. Pixels surviving depth and stencil testing are written to frame buffer . Then a video refresh element not shown scans data stored in frame buffer out to display device of .

Persons skilled in the art will understand that the different sample grids described herein may be genreated in step of by passing the pixel grid defined in step through the graphics rendering pipeline along with each of the sets of camera parameters designated in step . As shown in shader engine includes a texture unit that is configured to sample the different sample grids to generate the set of intermediate color values for each pixel of the pixel grid as set forth in step of . Additionally texture unit is further configured to perform the blending or weighting process to determine the final color value for each pixel in the pixel grid as set forth in step of .

Advantageously embodiments of the invention provide an anti aliasing technique that leverages the rendering speed of hardware graphics pipeline without relying on a regular grid or repeating pattern to generate a color value for a given pixel. Thus not only is overall performance generally increased relative to prior art software rendering techniques the occurrence of moir effects and other artifacts may be reduced thereby increasing overall image quality relative to prior art hardware rendering techniques.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

