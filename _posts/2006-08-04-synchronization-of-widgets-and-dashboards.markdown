---

title: Synchronization of widgets and dashboards
abstract: Systems, methods, computer-readable mediums, user interfaces and other implementations are disclosed for synchronizing widgets and dashboards.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08566732&OS=08566732&RS=08566732
owner: Apple Inc.
number: 08566732
owner_city: Cupertino
owner_country: US
publication_date: 20060804
---
This application is a continuation in part of U.S. patent application Ser. No. 10 877 968 for Unified Interest Layer For User Interface filed Jun. 25 2004 now U.S. Pat. No. 7 490 295 which patent application is incorporated by reference herein in its entirety.

This application is related to the following jointly owned and co pending patent applications each incorporated herein by reference in its entirety 

A hallmark of modern graphical user interfaces is that they allow a large number of graphical objects or items to be displayed on a display screen at the same time. Leading personal computer operating systems such as Apple Mac OS provide user interfaces in which a number of windows can be displayed overlapped resized moved configured and reformatted according to the needs of the user or application. Taskbars menus virtual buttons and other user interface elements provide mechanisms for accessing and activating windows even when they are hidden behind other windows.

Although users appreciate interfaces that can present information on a screen via multiple windows the result can be overwhelming. For example users may find it difficult to navigate to a particular user interface element or to locate a desired element among a large number of onscreen elements. The problem is further compounded when user interfaces allow users to position elements in a desired arrangement including overlapping minimizing maximizing and the like. Although such flexibility may be useful to the user it can result in a cluttered display screen. Having too many elements displayed on the screen can lead to information overload thus inhibiting the user to efficiently use the computer equipment.

Many of the deficiencies of conventional user interfaces can be reduced using widgets. Generally widgets are user interface elements that include information and one or more tools e.g. applications that let the user perform common tasks and provide fast access to information. Widgets can perform a variety of tasks including without limitation communicating with a remote server to provide information to the user e.g. weather report providing commonly needed functionality e.g. a calculator or acting as an information repository e.g. a notebook . Widgets can be displayed and accessed through a user interface such as a dashboard layer which is also referred to as a dashboard. Widgets and dashboards are described in co pending U.S. patent application Ser. No. 10 877 968 entitled Unified Interest Layer For User Interface. 

Due to the large number of widgets available to a user a virtual desktop or dashboard can become cluttered and disorganized making it difficult for the user to quickly locate and access a widget. Moreover the user may have to invoke multiple widgets to perform a single task which can lead to an inefficient use of widget resources. In some cases the user may not readily recognize the relationship between two widgets which leads to additional inefficiencies when using widgets.

Systems methods computer readable mediums user interfaces and other implementations are disclosed for synchronizing widgets and dashboards.

In some implementations a method comprises receiving a first set of widget information associated with a first device and synchronizing the first set of widget information with a data source.

In some implementations a method comprises receiving a first set of dashboard information associated with a first device and synchronizing the first set of dashboard information with a data source.

In some implementations a method comprises identifying configuration information associated with one or more widgets and updating the configuration information.

In some implementations a system includes a first device a second device and a sync engine. The first device includes a first dashboard including a first set of widgets. The second device includes a second dashboard including a second set of widgets. The sync engine is operatively coupled to the first and second devices and configurable to synchronize the first and second dashboards.

In some implementations an apparatus includes a computer readable medium adapted for storing a first set of dashboard information and a sync engine operatively coupled to the computer readable medium and configurable for synchronizing the first set of dashboard information with a data source.

Other implementations are disclosed which are directed to systems methods computer readable mediums and user interfaces.

The computer also includes a local storage device and a graphics module e.g. graphics card for storing information and generating graphical objects respectively. The local storage device can be a computer readable medium. The term computer readable medium refers to any medium that participates in providing instructions to a processor for execution including without limitation non volatile media e.g. optical or magnetic disks volatile media e.g. memory and transmission media. Transmission media includes without limitation coaxial cables copper wire fiber optics and computer buses. Transmission media can also take the form of acoustic light or radio frequency waves.

While widgets are described herein with respect to a personal computer it should be apparent that the disclosed implementations can be incorporated in or integrated with any electronic device that is capable of using widgets including without limitation portable and desktop computers servers electronics media players game devices mobile phones email devices personal digital assistants PDAs televisions etc.

A dashboard system and method for managing and displaying dashboards and widgets can be implemented as one or more plug ins that are installed and run on the personal computer . The plug ins can be configured to interact with an operating system e.g. MAC OS X WINDOWS XP LINUX etc. and to perform the various dashboard and widget functions as described with respect of . The dashboard system and method can also be implemented as one or more software applications running on a computer system e.g. computer . In some implementations a dashboard system can be another widget that is configurable to communicate with other widgets applications and or operating systems. The dashboard system and method can also be characterized as a framework or model that can be implemented on various platforms and or networks e.g. client server networks stand alone computers portable electronic devices mobile phones etc. and or embedded or bundled with one or more software applications e.g. email media player browser etc. .

For illustrative purposes widgets including linked widgets are described as a feature of an operating system. Widgets however can be implemented in other contexts as well including e mail environments desktop environments application environments hand held displays and any other display devices.

In response to such invocation the current state of the user interface is saved the user interface is temporarily inactivated an animation or effect is played or presented to introduce the dashboard and the dashboard is displayed with one or more widgets . If applicable a previous state of the dashboard is retrieved so that the dashboard can be displayed in its previous configuration.

In some implementations the dashboard is overlaid on an existing user interface UI e.g. a desktop UI . When the dashboard is activated the existing UI may be faded darkened brightened blurred distorted or otherwise altered to emphasize that it is temporarily inactivated. The existing UI may or may not be visible behind the dashboard. The UI can also be shrunk to a small portion of the display screen while the dashboard is active and can be re activated by clicking on it. In some implementations the UI is shrunk and presented as a widget. The UI can be re activated by clicking on the widget. In some implementations the UI remains active when the dashboard is active.

The user interacts with and or configures widgets as desired . In some implementations the user can move widgets around the screen and can resize widgets if applicable. Some widgets are resizable and some have a fixed size. A widget author can specify whether a widget can be resized. Some widgets automatically resize themselves based on the amount or nature of the data being displayed. Widgets can overlap and or repel one another. For example if the user attempts to move one widget to a screen position occupied by another widget one of the widgets is automatically moved out of the way or repelled by the other widget. In some implementations a user can link widgets together using a widget link manager as described with respect to .

In some implementations the user dismisses the dashboard by invoking a dismissal command which causes the UI layer to return or re present itself to the display screen. In some implementations the dashboard is dismissed when the user presses a function key or key combination which may be the same or different than the key or combination used to activate the dashboard or clicks on a close box or other icon or clicks on negative space within the dashboard e.g. a space between widgets or moves an onscreen cursor to a predefined corner of the screen. Other dismissal methods are possible.

In some implementations the dashboard is automatically dismissed i.e. without user input after some predetermined period of time or in response to a trigger event. An animation or other effect can be played or presented to provide a transition as the dashboard is dismissed . When the dashboard is dismissed the current configuration or state of the widgets e.g. position size etc. is stored so that it can be retrieved the next time the dashboard is activated. In some implementations an animation or effect is played or presented when re introducing the UI. The UI is restored to its previous state so that the user can resume interaction with software applications and or the operating system.

In some implementations the dashboard is configurable. The user can select a number of widgets to be displayed for example by dragging the widgets from a configuration bar or other user interface element onto the dashboard. The configuration bar can include different types of widgets and can be categorized and or hierarchically organized. In some implementations in response to the user dragging a widget onto the configuration bar the widget is downloaded from a server and automatically installed if not previously installed . In some implementations certain widgets can be purchased so the user is requested to provide a credit card number or some other form of payment before the widget is installed on the user s device. In some implementations widgets are already installed on the user s device but are only made visible when they have been dragged from the configuration bar onto the dashboard. The configuration bar is merely an example of one type of UI element for configuring the dashboard. Other configuration mechanisms can be used such as an icon tray or menu system.

It should be apparent that there are many ways in which dashboards and widgets can be displayed other than those implementations described herein. For example widgets can be displayed on any surface user interface or user interface element including but not limited to desktops browser or application windows menu systems trays multi touch sensitive displays and other widgets.

In some implementations the widgets are displayed using HTML and related web technology. The dashboard server manages and launches the dashboard client processes. Each dashboard client loads a widget e.g. an HTML webpage and related resources needed to display the page. In some implementations the dashboard clients display the widgets without a conventional window frame menu bar or other components typically associated with on screen windows. This technique provides a clean straightforward display of the overall dashboard to reduce confusion and clutter. The dashboard clients display their respective widgets by rendering web pages into a WebView as described in U.S. patent application Ser. No. 11 148 010 entitled Preview and Installation of User Interface Elements in a Display Environment. The size of each WebView can be defined as metadata associated with the corresponding widget . The server provides data for rendering the dashboard layer that can be overlaid on a desktop user interface. In some implementations the widgets are rendered into the dashboard layer which is drawn on top of the desktop user interface so as to partially or completely obscure the desktop user interface while the dashboard layer is active.

The dashboard server also referred to as server can be a stand alone process or embedded in another process. The server can be located at the computer or at the remote server . In some implementations the server provides functionality for one or more processes including but not limited to non widget UI management window management fast login event management loading widgets widget arbitration Core Image integration and widget preference management as described in U.S. patent application Ser. No. 11 148 010 entitled Preview and Installation of User Interface Elements in a Display Environment. 

In some implementations a dashboard client is a process that uses for example objects that are defined as part of a development environment such as Apple Computer s Cocoa Application Framework also referred to as the Application Kit or AppKit for the Mac OS operating system. In some implementations the dashboard clients can be implemented as simplified browser screens that omit conventional interface features such as a menu bar window frame and the like.

In one implementation each widget is implemented as an HTML file. The HTML file can reference other local and remote resources such as style sheets e.g. Cascading Style Sheets other HTML files JavaScript files images and the like. Widgets can be implemented using for example a flat bundle file format or a packaged HTML file format. In some implementations the Flat Bundle format includes an info.plist file.

The Info.plist files describes a widget and provides an identifier for a widget . Table I provides an example of Info.plist file contents.

The keys AllowFileAccessOutsideofWidget AllowFullAccess AllowInternetPlugins AllowJava AllowNetworkAccess and AllowSystem are Boolean types that can be set by a widget author to enable certain levels of resource access.

In some implementations the Info.plist file includes N WidgetLinkInfo strings for storing the names of widgets that can be linked to the widget associated with the Info.plist file. This information can be used to automatically link widgets as described with respect to . Note that the additional widget link information can be included in the Info.plist file and or one or more other files bundled with the widget depending upon the widget design.

In some implementations the user can drag the icon to any location on the screen and the position of the icon will remain persistent from one invocation of the dashboard layer to the next. The user can click on the icon to activate the configuration bar as shown in . The configuration bar provides access to various widgets that can be placed on the dashboard. In some implementations a text label is shown for each available widget e.g. calculator stocks iTunes etc. . In some implementations an icon is shown for each available widget e.g. calculator icon . If many widgets are available the widgets may be arranged hierarchically by type e.g. game widgets utility widgets etc. or alphabetically or by any other categorization methodology. For example a number of categories may be displayed and clicking on one of the categories causes a pull down menu to be displayed listing a number of widgets in that category. In some implementations a buy widget is also available allowing the user to select widgets from an online store or website.

Note that the particular configuration and appearance of configuration bar in is merely exemplary and that many other arrangements are possible. For example widgets can be installed from other locations other applications or other environments without requiring that they first be part of the configuration bar . The user can dismiss the configuration bar by clicking on dismissal button or icon .

Elements including user interface elements such as widgets can be displayed as discussed below. One display a dashboard layer will be used for illustrative purposes. Installation can include a preview operation as is discussed below. Installation can include selection of the element such as by a drag and drop action. Other selection means can be used. In one example a user can drag widgets from configuration bar onto the surface of the dashboard in other words anywhere on the screen using standard drag and drop functionality for moving objects on a screen.

In some implementations widgets in the configuration bar are smaller than their actual size when installed. When the user clicks on a widget and begins to drag it into a dashboard or other display the widget can be animated to its actual or installed size to assist the user in the real time layout of the dashboard. By animating the widget to its actual size the user will know the actual size of the widget prior to its installation.

In some implementations an animation such as a ripple animation is shown when the user drops a widget by releasing a mouse button or equivalent input device to place a widget at the desired location. In one implementation the dragging of the widget to the dashboard layer invokes an installation process for installing the widget including previewing. After installation the user can move a widget to any other desired location or can remove the widget from the screen for example by dragging it off the screen or dragging it back onto the configuration bar by invoking a remove command disabling a widget in a menu associated with a widget manager or canceling the installation during the preview. In some implementations the position state and configuration of a widget are preserved when the dashboard layer is dismissed so that these characteristics are restored the next time the dashboard layer is activated.

In some implementations widgets and or dashboard layers including widgets can be installed from within a running application. For example a widget and or dashboard including widgets can be an attachment to an email. When the user clicks the attachment an installation process is invoked for the widget and or dashboard which can also include a preview.

Widgets can be created or instantiated using an installer process. The installer process can include a separate user interface or an integrated user interface e.g. integrated in the display area or separate from the display area for example in another display area associated with another application such as an email application for selecting and installing widgets in a display area. For example a widget received as an email attachment can be launched by a user from directly within a user interface of the email application.

Widgets can be created or instantiated using an installer process. The installer process can include a separate user interface or an integrated user interface e.g. integrated in the display area or separate from the display area for example in another display area associated with another application such as an email application for selecting and installing widgets in a display area. Thus the installation area for the widget can be embedded within an application display area or window. For example if a user receives a widget as an attachment to an email the user can invoke and install the widget from within the email message window without the need for a separate installation window.

In general an installer process is used to provide additional functionality to the creation instantiation process beyond the simple drag and drop operation describe above. Additional functionality can include preview linking security and deletion functionality in a singular interface. The installer process can be a separate process or combined in another process. The installer process can itself be a separate application that is executable to install widgets or other elements in a display area. As used herein the term process refers to a combination of functions that can be implemented in hardware software firmware or the like.

The use of nested display areas associated with different dashboard environments enables users to organize dashboards into hierarchies. For example a dashboard environment including widgets for use with operating system utilities can include nested display areas for displaying widgets associated with particular types of utilities e.g. date and time memory management network resource management etc. 

In some implementations the user interface includes a background image a menu bar and other UI common features e.g. windows icons etc. . The user can activate the dashboard layer by selecting an item from the menu bar or by clicking an icon or by pressing a function key or key combination or by some other means for invoking activation. In some implementations a configuration bar is displayed which includes one or more widget icons and a widget link manager icon . The configuration bar can be scrolled from left to right to reveal more widget icons. A user can install a widget by dragging its associated widget icon from the configuration bar and dropping it in the dashboard layer or by using other installation techniques as described with respect to .

In some implementations two or more widgets are automatically linked in response to a trigger event. A trigger event can be generated by downloading installing previewing launching manipulating updating operating or otherwise interacting with a widget. A trigger event can also be generated by exercising the functionality of a widget.

Widgets can be automatically or manually linked together based on any suitable criteria or no criteria. For example widgets can be linked based on the type of data or information the widgets use or share e.g. time date place etc. the origin of the widgets e.g. received from friends downloaded from a common website etc. and the time when the widgets were downloaded e.g. widgets downloaded at the same time of day . Widgets can be linked based on their membership in a widget class e.g. financial widgets stock market widgets etc. . Widgets can also be linked based on their participation in a process or workflow e.g. a stock market widget providing data to a 3D graph widget .

The concept of linked widgets can be illustrated by the following example involving a search widget a map widget and a weather widget . When the user installs the search widget in the dashboard layer a trigger event is generated which causes the map widget and the weather widget to be automatically linked to the search widget and displayed in the dashboard layer . A user enters a search query in a search box of the search widget to determine the location of a favorite restaurant. The search widget returns location information e.g. address coordinates etc. for the restaurant which is shared with the map widget and the weather widget . The map widget uses the address to generate a map and driving directions. The weather widget uses the address to determine the current weather for the location of the restaurant. If the map and weather widgets are already installed and launched in the dashboard layer when the search widget is installed then the links are established directly without re installing and launching the widgets . If the widgets are not installed then the widgets are installed and launched before or after being linked. If the widgets are not available on the computer system a message is displayed instructing the user on how to obtain the widgets from another source. For example the message can include a link to a website where the widgets can be downloaded to the computer system .

Generally any two widgets can be linked and share information. The amount and type of information shared is dependant on the widgets that are linked. For example the widgets and could share location information e.g. address latitude longitude etc. .

The widgets and are examples of widgets that can be linked based on the type of information the widgets use and share i.e. location information . Other examples of widgets that can be linked include but are not limited to a calendar widget that can be linked to a scheduling widget a dictionary widget that can be linked to a word processing widget a telephone directory widget that can be linked to dial up widget a stock widget that can be linked to a graph widget for presenting stock information in different types of graphs e.g. pie graph bar graph etc. an image processing editing widget that can be linked to a picture frame widget for viewing a digital image and a media player widget that can be linked to a ticket vending widget e.g. a Ticketmaster widget for providing a touring schedule and a mechanism for purchasing concert tickets to see an artist whose song is currently playing in the media player widget.

In some implementations widgets can be linked to one or more non widget applications and can interact with and receive data from those applications. A non widget application can also provide a bridge between two or more widgets. For example when an application is invoked e.g. a word processor can search for widgets that can support the application or specific feature of the application e.g. dictionary or thesaurus widgets . The widgets can communicate directly with each other and or indirectly through the application.

In some implementations links are established between widgets only if one or more conditions events or triggers are satisfied. For example a link may only be established upon completion of one or more tasks or at a certain time of day or only between widgets that are currently running or only between widgets in the same dashboard layer etc. The conditions for establishing links can be a set of rules that should be satisfied before a link is established. The rules can be generated manually by the user or programmatically at run time. Rules can also be dynamically generated by a running widget or non widget application that is associated with widgets. The rules can be stored in a widget file or other data structure. The rules for linking widgets can be different based on the type of device where the widgets reside e.g. a portable device mobile phone etc. .

Linked widgets can be located in the same dashboard or different dashboards in a multiple dashboard environment. In some implementations linked widgets can communicate even when installed in different display areas. Linked widgets can reside on a single device or on multiple devices and communicate over a network connection established between the devices e.g. Internet Ethernet wireless etc. .

In some implementations linked widgets include a link element e.g. a button which if selected disables links to other widgets. For example clicking on the link element of the search widget causes the map and weather widgets to be unlinked to the search widget . In some implementations when widgets are unlinked they are altered or obfuscated in the dashboard layer e.g. grayed out dimmed made semi translucent etc. . Alternatively unlinked widgets can remain visible but a link indicator e.g. a virtual lamp etc. is altered to indicate a widget s link status. For example the link indicator can change color e.g. from green to red to assist users to visually identify the link status of a widget. In other implementations the icon associated with a widget is modified to indicate the widgets link status e.g. the icon change colors or displays informative text .

In some implementations widgets that are linked or that are capable of being linked have a gravitational or magnetic attraction or repulsion to each other. For example when two widgets are linked together the widgets positions in a dashboard layer or other user interface can be automatically adjusted so the linked widgets are adjacent or proximate to each other. Under such a simulated gravitational attraction or repulsion widgets can cluster together in the dashboard layer or user interface to indicate their linked status. The clustering visually indicates to the user that the widgets are linked or not linked or that the widgets can be linked. A visual indication of the strength of a link or the potential to link can be displayed by changing one or more properties of the widgets such as the color of the widgets or the distance between widgets. For example red widgets could indicate a strong link or potential to link and green widgets could indicate a weak link or potential to link . Also a shorter distance between linked widgets in a dashboard layer or user interface could indicate a stronger link or potential to link than widgets that are separated by a greater distance. If the user moves a widget around a dashboard layer or a user interface other widgets in the dashboard layer or user interface can be attracted to or repulsed by the moving widget to indicate their link status or link potential.

Widgets can be linked in a variety of topologies. For example a single widget can be linked to multiple widgets and configured to provide those widgets with common or personalized information e.g. a broadcasting widget . In some implementations a widget can behave like a server server widget and interact and exchange information with one or more client widgets.

In some implementations widgets can be linked at several levels and conceptually organized into a widget hierarchy for example forming a tree structure where the widget at the top of the tree is a root widget and the other widgets are leafs or node widgets.

In some implementations the linkage between two or more widgets can be bi directional so that each widget in a pair of linked widgets can be invoked e.g. launched installed updated etc. by the other widget in the pair. Also each widget in a widget pair can transmit and receive information from the other widget in the pair.

In some implementations the user interface can be obfuscated to reveal a dashboard layer containing only linked widgets. For example the user can press a predetermined key combination or other input mechanism which causes the appearance of unlinked widgets to be altered or otherwise obfuscated so that only linked widgets are visible on the display screen. A key combination can be specified by the user in a preference pane or other user input mechanism.

In some implementations a widget link manager enables a user to manually establish and edit widget links as described with respect to . A widget link manager icon for invoking the widget link manager can reside anywhere in the desktop user interface and or in the configuration bar as shown in . The icon can be used to toggle between a dashboard layer or desktop and a user interface for the widget manager.

When a link is manually or automatically established between the phone book widget and the sports widget information can be exchanged between the phone book widget and the sports widget . For example the sports widget can send the phone book widget the name of a sports venue. The phone book widget can then use the name of the sport venue to look up the address and telephone number of the sports venue. Once the address and number are retrieved the phone book widget sends the address and telephone number to the sports widget where the information can be used to augment or enhance the sporting event information .

The process begins when a widget linking trigger event is detected . A widget linking trigger event can generated e.g. by a dashboard server in response to the downloading installation previewing launching updating manipulation operation and or interaction with a widget. A widget linking trigger event can also be the exercise of a feature or functionality of one or more widgets. A widget linking trigger event can be generated by user input or programmatically by software e.g. operating system application etc. or hardware e.g. mouse click hardware plug in etc. .

In response to a trigger event the process determines a set of candidate widgets that can be linked . Candidate widgets can be determined from predetermined or dynamically generated link information. In some implementations predetermined link information can be stored in the dashboard configuration information as shown in . The link information can be included by a widget s author in files associated with each widget e.g. info.plist or created by the user with the widget link manager as described with respect to . Link information can also be dynamically created while a widget is running or not. For example widgets that are running can be forming new links terminating or reviving existing links generating or receiving new data sources and the like. This dynamically generated link information can be stored during runtime in memory or other computer readable medium e.g. hard disk .

In some implementations a dashboard can scan for installed widgets to create a collection of linkages or possible linkages which are stored during runtime. In some implementations the user can control the linkages which can be stored by the dashboard server. For example the user can manually establish linkages using a widget link manager or bridging elements as described with respect to .

When a set of candidate widgets is determined the process automatically links and installs and launches if necessary the candidate widgets . In some implementations a manual step can be used in combination with the process by automatically presenting a user interface that includes a list of candidate widgets that can be linked to a particular widget e.g. the widget that generated the trigger event . The candidate widgets can be organized into a file system that can be navigated. For example launched widgets that are running on the host device can be listed separately from widgets that are residing on the host device but have not been launched.

The user can manually select one or more widgets from the candidate widget list for linking. In other embodiments a link or other mechanism can be provided in the dashboard layer and or in a configuration bar that the user can select to invoke the user interface having candidate widgets and or to direct the user to another source of candidate widgets e.g. a link to a website .

In some implementations a communication channel is established between the linked widgets using known object oriented programming OOP techniques and languages e.g. Java C Smalltalk etc. for transmitting and receiving messages . In some implementations each widget in a linked pair of widgets can pull information from the other widget push information to the other widget or both i.e. bidirectional communication . In other implementations each widget writes information to a shared memory or storage location e.g. local storage where it can be read by other widgets. The type and amount of information shared is dependent on the needs of the widgets that are linked. An examples of shared link information would be the coordinate or location data between the widgets and as described with respect to .

In some implementations the widgets share security information e.g. keys secret data etc. for secured communications. When widgets share information there is a danger that malicious widgets will gain access to restricted information. If confidential information is to be shared between widgets then the widgets can be signed and undergo an authentication procedure during linking using one or more known authentication techniques e.g. Digital Signature Algorithm DSA .

When communication between linked widgets is established the process monitors the link status for changes. Changes could be failed links temporarily disable links new links etc. The process detects any changes and modifies the link information as appropriate. For example if a new link is established the process will add the link to the link information associated with the widgets forming the link as described with respect to Table I.

The widget linker is responsible for implementing the process as described with respect to . In some implementations the widget linker monitors the downloading installation previewing and launching of widgets and detects trigger events for linking. In response to a trigger event the widget linker can match a unique widget identifier e.g. a hash for the trigger widget with a list of candidate widgets that can be linked to the triggering widget candidate link widgets . In some implementations the widget linker can store and maintain a link flag or link key for each candidate link widget together with a memory address for accessing shared information. Setting the flag will cause the widget to read information from the address provided by the widget linker . The widget linker will also install and or launch the candidate linked widgets widgets with set link flags if the candidate link widgets have not been installed and or launched. An example data structure for linked widgets is show in Table I below.

Referring to Table I an exemplary data structure includes a Name field a Widget ID field a Linked To field and a Sharing field. More or fewer fields can be used as desired. The Name field stores the name of the widget the Widget ID field stores a unique ID for the widget e.g. a fingerprint or hash the Linked To field includes the Widget IDs for all the widgets that are linked to the widget identified in the Name and Widget ID fields. The Sharing field includes a description of information to be shared by the widget having the Widget ID. The data structure can be stored as a text file in a directory where it can be edited by a user through for example a text editor.

In some implementations the widget linker keeps track of the physical and or logical address locations of shared information the types of data that can be shared and the widgets that are allowed to share data. In some implementations the user or a system administrator can prevent a widget from sharing its data with any other widget e.g. as a security precaution by setting the sharing field to None. Content feeds and other external information sources can be similarly protected. In some implementations some widget data can be shared and other widget data can remain private. Such an implementation can be realized by adding one or more additional fields in the data structure shown in Table I. For example one or more fields can be added that list the source of a trigger event or that stores instantaneous IDs for multiple instances of widgets.

The process begins when the user selects a first widget for linking . In some implementations the first widget includes a linking mechanism e.g. menu item button which when selected e.g. mouse clicked configures the widget for linking with other widgets and invokes a widget link manager for manually establishing links with other widgets. In other implementations the widget flips when the linking mechanism is selected and a widget link manager user interface is presented on the backside of the widget. An example of a user interface for a widget link manager is described with respect to .

After the first widget is selected the user can select information belonging to the first widget which can be shared with other widgets. In some cases the user may desire to keep certain widget information private but allow other widget information to be made public i.e. shared with other widgets . In some cases there may be restrictions on the number and types of widgets that can be linked to the first widget. For example widgets that have access to certain local or network resources e.g. file systems private information etc. may be restricted by the user or the user s privileges from linking with other widgets for security reasons. For example a user can turn off automatic widget linking for all or some widgets or restrict certain widgets from linking with certain other widgets. Such restrictions or any other security methods can be specified or set by a user or administrator through a security preference pane or other input mechanism. These restrictions can be placed in a widget file that is distributed with the widget e.g. info.plist or added at a later time by a system administrator or user through a widget manager as described with respect to .

The user selects a second widget for linking with the first widget . The user can also select information belonging to the second widget which can be shared with the first widget. Once the first and second widgets are specified including a specification of shared data the widgets can be linked .

In some implementations the widget link manager is invoked by clicking on the widget link manager icon or other input mechanism e.g. key combination menu option etc. . The widget link manager can be closed by clicking the button or other input mechanism. When invoked the widget link manager provides a display area including a search panel and a link panel . The search panel includes a search box for searching for widgets. For example a user can put name of a widget in the search box and click a Go button to run a search for the search widget . Alternatively the user can browse a directory structure for widgets using techniques commonly employed by file systems to search for files e.g. Mac OS Finder or Spotlight .

When the search widget is selected its icon or other identifier can be displayed in the search area . To link the search widget with the map widget the user can for example drag the icon for the map widget from the configuration bar and drops the icon in the link area . In some implementations the widget link manager determines whether the map widget can be linked to the search widget by for example examining link information for the widgets. If the map widget can be linked the map widget can appear in a list of linked widgets in the link area . If the map widget cannot be linked to the search widget the map widget is not displayed in the list and the user is notified e.g. by an alert message . A link failure could occur if the map and search widgets are restricted from being linked to each other or if there is insufficient link information available for one or both widgets or for any other reason e.g. security restrictions . Note that the link information shared is dependant on the widgets that are linked. For example the search map and weather widgets would share location information e.g. address latitude longitude etc. .

It should be apparent that other implementations of the widget link manager are possible. For example all or part of the functionality of the widget link manager can be accessible on the flip side of a widget. If a user wants to link widgets the user can flip the widget to display the search area and link area .

When the end of the first bridging element is over or in the proximity of the dock the user releases the mouse button and the bridge between the widgets and is completed resulting in the widgets and being linked. The user can repeat the same procedure using a second bridging element and docks and . In some implementations the bridging element is displayed until the widgets are linked at which time is removed or otherwise obfuscated. For example once the widgets have been bridged the bridging element can disappear or be obfuscated and the widget s properties or characteristics can be altered to indicate link status e.g. the widgets change color .

In some implementations the widgets can be unlinked by clicking on each widget of a link which causes the bridging element to be displayed again. The user can then manually snip the bridging element by clicking on it with a mouse or other pointing device. Other techniques for removing links using bridging elements are possible.

Users may have several devices that utilize widgets and dashboards. For example a user may have a desktop computer with certain dashboards and widgets installed and a portable computer with the same or different dashboards and widgets installed. The system allows a user to synchronize dashboards and widgets installed on a host device network or storage media to one or more data sources. Data sources can be any source that provides data for creating installing operating or managing widgets and or dashboards or any data used or presented by widgets and or dashboards. In the example shown the host device host device A can synchronize directly with the host device host device B using a known or standard bus technology e.g. USB FireWire or indirectly through the network server and network .

In some implementations a synchronization service can be used to non destructively synchronize widgets and or dashboards between two devices. In the example shown the host device has installed widgets A B and C. Widget A is installed on a user interface provided by for example an operating system or application running on the host device . The widgets B and C are installed in a dashboard layer referred to as dashboard . The host device can be connected directly to the host device and a synchronization can be initiated by the host device . Synchronization can be initiated manually by user or automatically on a scheduled based or in response to a trigger event. Manual synchronization can be initiated by selecting an option from a menu or other user interface element e.g. virtual button presented on a display device of the host device and or by a hardware mechanism e.g. a mechanical button switch key . When synchronization is initiated the user can be presented with several options for synchronization. For example the user can be presented with a list of items e.g. dashboards widgets files database records etc. that can be synchronized with corresponding checkboxes that can be checked by the user to allow the item to be included or excluded from the synchronization process. Once the synchronization process has begun the user can be presented with a dialog reporting the progress of the synchronization and a summary of the synchronization results. In some implementations the synchronization results provides a list of potential conflicts and allows the user to manually resolve the conflicts. For example a conflict may arise between two different versions of the same widget and or dashboard. The user can be prompted in real time to resolve the conflict by selecting one version over another version. In some implementations such conflict resolutions and other specifications for synchronization can be pre selected by the user through a preference pane or other dialog.

The synchronization process can be performed using known synchronization technologies and or services. An example of a suitable synchronization service is Sync Services provided by Apple Computer Inc. Sync Services is a framework containing components needed by a developer to sync an application and devices. Data can be synced with other applications and devices on the same device or other devices over a network using for example .Mac a web based service provided by Apple . Sync Services is publicly available as an Objective C Application Programming Interface API for Mac OS X version 10.4 and later. The architecture and logic of Sync Services is described with reference to . An example of a widget dashboard synchronization process using a network server is described in reference to .

In some implementations the system can use peer to peer or network less syncing. In such an implementation the network device that is used for syncing may or may not be independent of the target device which is receiving the synced data. For example Apple Computer Inc. s Sync Services can sync information to a device or to Mac and then to another device. In the former case there is no network other than the network formed by the two devices being synced. In the latter case there is a network server that holds the information before it is synced to the target device. In some implementations two peer to peer devices can sync in an ad hoc network where no network server is available.

A desirable feature of the system is the ability to synchronize non destructively. For example assume that Widgets A B and C are installed on host device and Widgets B C D and E are installed on host device but not Widget A. If host device initiates a synchronization with host device then Widget A will be added to host device and Widgets B and C on host device will be replaced with Widgets B and C on host device assuming the user or an application has specified such a replacement . After synchronization has completed the host device will have Widgets A B C D and E. Now if the host device initiates a synchronization with the host device then Widgets D and E will be added to the host device Widgets B and C will be replaced and Widget A will remain unaffected. Since Widget A is not removed from the host device the synchronization is referred to as non destructive. 

In some implementations local configuration information e.g. parameter data can be identified as related to dashboards and or widgets on a host device and evaluated for consistency with master configuration information stored locally on the host device or remotely on for example a network device e.g. network server . If the information is different then local configuration information can be updated with master configuration information or vice versa.

In some implementations different versions of the same widget dashboard and or different widget dashboard can be synced based on sync preferences which can be specified by a user. If a device does not have a widget dashboard installed then the settings for the widget dashboard can be synced so that when the widget dashboard is later installed the widget dashboard is invoked with the correct settings. If a widget cannot be synced e.g. it is a purchased widget then a dummy widget can be synced and the user can be provided instructions on how to obtain the widget.

In some implementations a removable storage media can be synchronized with a host device. In the example shown the removable storage media which includes Widget A can be synchronized with the host device which also includes a version of Widget A. Examples of removable storage media include but are not limited to external hard drives USB flash drives Firewire drives floppy disks compact discs an any other storage media that can be plugged into or otherwise connected with a host device. In some implementations the system can be used with Portable Home Directories PHDs as provided by Apple Computer s Mac OS X Tiger operating system or similar technologies.

In some implementations the host device scans for removable media . If detected the host device mounts the removable media and searches for widgets dashboards to be synchronized. If found then the configurations for the widgets dashboards can be compared against master information stored locally on the host device or remotely on a network device and a synchronization process can be initialized manually e.g. by the user or automatically such as the synchronization process described in reference to .

The use of removable media allows users to maintain widgets and dashboards on multiple devices and to transfer changes made to widgets and dashboards on one device to other devices. For example a user could carry their customized dashboards and widgets on a USB flash drive. The user can plug the drive into any device capable of supporting dashboards and widgets and install or cause to be installed the customized dashboards and widgets. The user can then make changes to widgets and dashboards which can be stored on the USB flash drive. When the user plugs the drive into another device the changes are detected and synchronized to the new device or other user devices through a network synchronization process such as is described with reference to .

In some implementations the network server can act as a centralized repository for information relating to a user s widgets and dashboards which can be downloaded to a device through a network connection. The user can manage the information using the device.

In some implementations one or more uses can subscribe to a synchronization service. The service can provide a web site where a user can login and specify certain synchronization services. The service can be part of a service that aggregates and distributes widgets and dashboards. For example a user device could receive updated versions of widgets and or dashboards by syncing with a network device. The syncing can be initiated by the user device sync client or by the sync service and changes to widgets and or dashboards can be either pushed by or pulled from a sync engine running on the network device as described in reference to . In some implementations the synchronization services can be part of a broader service offering such as described in U.S. patent application Ser. No. 11 499 494 for Management and Generation of Dashboards filed Aug. 4 2006.

It should be apparent that the widgets and are different or disparate and that it is the data associated with the widgets and that is synced. This process can be compared to the example synchronization process described in reference to where additional widgets dashboards were added to a device or existing widgets dashboards were replaced with updated versions of the same widget dashboard.

In some implementations the sync engine merges changes to be pulled by different sync clients . The sync engine can be invoked on a scheduled basis or triggered by an event. A network based sync engine can coordinate the requests of multiple sync devices simultaneously and can notify a dependent sync device that an observed sync device is syncing and allow the sync device to join a sync session.

In some implementations the sync engine selects an appropriate sync mode for each client . In a slow syncing mode the first time a sync client syncs it pushes all its widget dashboard information in a bundle to the sync engine and pull changes computed by the sync engine . In a fast syncing mode while a client is pushing and pulling information the sync engine keeps track of the client s state using for example a snapshot so that subsequent syncs can be more efficient. The next time a client syncs only changes are pushed and pulled. In some implementations the sync engine assumes the client is fast syncing unless the client negotiates another sync mode or some state has changed that requires a different mode. Intelligence can be built into the sync engine to resolve conflicts and duplicates without requiring user input. In some implementations the sync engine is a differencing engine that processes changes to individual parameters associated with a widget or dashboard. If two clients modify the same parameter for a widget or dashboard the sync engine can generate a conflict.

In some implementations the truth database contains an aggregate of all the client s widget and dashboard information. The truth database can use a canonical scheme that is an aggregate of all the widget and dashboard schemas used by all the clients .

It will be understood by those skilled in the relevant art that the above described implementations are merely exemplary and many changes can be made without departing from the true spirit and scope of the present invention. Therefore it is intended by the appended claims to cover all such changes and modifications that come within the true spirit and scope of this invention.

