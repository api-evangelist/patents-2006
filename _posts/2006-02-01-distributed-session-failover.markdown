---

title: Distributed session failover
abstract: A distributed session failover mechanism is disclosed for facilitating the replication and retrieval of session information. A first server, in a trusted network, providing a single sign-on (SSO) solution, stores session information pertaining to a particular client requesting services associated with the server. In order to provide session failover, the first server sends a copy of the session information to a bus mechanism, which is connected to one or more persistent repositories. When a second server attempts to validate the client, the second server may discover that the first server failed. The second server then requests a copy of the session information pertaining to the client from the bus mechanism. The bus mechanism retrieves the copy from a persistent repository and provides the copy to the second server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08051179&OS=08051179&RS=08051179
owner: Oracle America, Inc.
number: 08051179
owner_city: Redwood City
owner_country: US
publication_date: 20060201
---
Websites have greatly proliferated in recent years. The number of services provided by websites has also grown quite rapidly to the point that almost any type of service may now be obtained via the Internet. The growth in the number of websites has largely occurred without any concerted effort to integrate the various sites. That is each website has typically been created and maintained as a standalone site and has generally not been constructed to interact cooperate or share information with other websites. As a result users generally have to maintain a separate and distinct user account on each website. For example a user may have one account on a book vending website another account on a computer system vending website yet another account on a travel agency website and so on. Having all of these accounts generally forces the user to remember a user name and password for each account. In addition because each website is its own standalone site the user typically has to log in separately to each website to use the services provided thereon. Furthermore the user generally has to provide the same set of information e.g. first name last name address etc. over and over again to the various sites which can be time consuming and tedious.

In an attempt to enable separate websites to interact and share information with each other thereby easing the burden on the user an organization known as the Liberty Alliance has been formed. The Liberty Alliance is a standards organization that has established a Liberty standard which governs interaction between various websites. The Liberty standard sets forth standard protocols and schemas that can be used to facilitate such interaction. As it currently stands the Liberty standard comprises two major aspects a federation framework and a web services framework.

The federation framework makes it possible to set up a circle of trust among a plurality of websites. Within this circle of trust account linking can be implemented such that an account on one website can be mapped to an account on another website. With such account linking it is possible to achieve single sign on SSO whereby a user logs in to an account on just one of the websites within the circle of trust and can thereafter access accounts on other websites within the circle of trust without having to log in to those websites. While the accounts on the various websites are linked the information in the accounts is not necessarily shared unless the parties specifically agree to share some or all of the information . Thus with the federation framework the information in each account remains private to its associated website.

The web services framework enables information to be easily shared among a plurality of websites. With the web services framework a user can maintain information in a central repository located at one of the websites and can direct other websites to consult that central repository to obtain information pertaining to the user. For example a user can maintain his personal profile information e.g. name address phone number etc. at a website A. When the user visits a website B which may for example be a website that sells certain goods and website B requires certain information about the user for example an address to which to ship a purchased item website B can request the user information from website A. With the web services framework the user does not have to provide his information to each website that he patronizes.

Some application servers that provide SSO service include BEA s Weblogic IBM s Websphere and Sun s Access Manager . Sun s Access Manager may also be used in conjunction with i.e. run on top of other application servers and web servers to provide the SSO services. Access Manager AM servers implement SSO at a different level than other application servers and are thus able to employ SSO and capabilities independent of the application servers on which they might be executing. AM servers will be used hereinafter in discussing SSO and a failover mechanism associated with SSO.

When a client process requests access to resources from an AM server the client may be a dumb client such as a web browser or one or more intelligent clients such as some applications. Using a web browser as an example when a user first requests access to an account and authenticates herself a cookie is created on the web browser. Also a session is created on the AM. The AM that creates the session owns the session. If the user logs out there must be a single authority to say whether the session is still valid.

A session contains information related to the user s authentication when the user logged on how long the user has been idle the expiry time and other attributes. In the case of a dumb client the session information also maintains the work that the client has performed thus far. However an intelligent client is intelligent enough to retain its own state or the work performed thus far.

When the user accesses a second AM server in the trusted network with a web browser either within the same enterprise or a different enterprise the cookie is presented to the second AM server. The cookie contains a session token which is typically a 64 bit number that specifically identifies the session originally created when the user first logged on. The second AM validates the session token by making a back channel call to the first AM server which owns the session. The first AM server verifies to the second AM server that the user has been authenticated and that the particular session associated with the user has not expired. The second AM server then allows the user access to resources provided by the server associated with the second AM server. This communication between the AM servers is transparent to the user thus the user can travel amongst different websites without having to re authenticate and without knowledge of the validation process.

When the second AM server makes the back channel call to validate a user the second AM server may discover that the first AM server the owner of the session in question crashed. If an AM server fails or crashes all the session information stored on the AM server is lost. This means the user may lose all the work done thus far and the user would have to re authenticate.

One failover approach to recover the lost session information is to initially replicate the session information on all AM servers. illustrates a system wherein session information pertaining to a client is replicated on each AM server in a SSO trusted network. Client and session servers in the SSO trusted network may be communicatively coupled via a network which may be a Local Area Network LAN or a Wide Area Network WAN such as the Internet.

Each server in the SSO trusted network has a copy of each session created in the SSO trusted network. If server crashes then every other server continues functioning without losing SSO capability and without a significant change in network performance. However given normal network usage the implementation of system suffers from increased network latency due to sending session copies to each server in the SSO trusted network. Also depending on network usage a significant amount of memory is consumed by each server in the SSO trusted network when the total number of servers reaches four and above.

Another approach is to have one or more persistent repositories such as databases store all the sessions for each AM server. illustrates a system wherein session information pertaining to client is replicated and wherein a session server e.g. server directly sends a copy of session information to each persistent repository. For example client initiates a session on server via network . Server then sends information pertaining to the session directly to a database such as a database . If there are multiple databases to ensure that there is not a single point of failure with respect to the databases then a copy of the session is sent to each database such as databases .

Subsequently client requests resources from server via network . In order to validate client without requiring client to re authenticate server determines that server owns the session and sends a request to server to determine if a session pertaining to client is open. If server determines that server is somehow unavailable then server requests a copy of the session information directly from one of the databases e.g. databases .

This latter approach suffers from at least three undesirable shortcomings. The first is that when a server sends a copy of session information to each database the server must know about each database and communicate directly with each database i.e. peer to peer . This means that the server must wait for a COMMIT message from each database to ensure that the copy of the session information was properly saved before the server can return to its regular task of storing session information and providing SSO capability. This synchronous trait becomes a significant performance bottleneck to each server.

The second undesirable feature occurs when a server holding a large number e.g. 100 000 of sessions fails. There could be for example five servers requesting copies of desired session information from the same database. Each server would have to wait their respective turn in order to obtain the copy of the session information from the database.

Third each server in the SSO trusted network of is required to be aware of each database. Thus information pertaining to each database needs to be maintained as well as persistent connections between each server and each database. System is thus not scalable since m database connections need to be created whenever a new server is added to the SSO trusted network of . Correlatively n server connections need to be created whenever a new database is added to the SSO trusted network. Furthermore if the new database uses a different protocol than that which is used for any of the other databases in system then the logic of each server in the SSO trusted network of needs to be updated in order to be able to communicate with the new database.

In the session failover context the steps of replicating and retrieving session information from persistent repositories can be a source of significant performance degradation. In the case where each server replicates session information on one or more other servers adding additional servers with SSO and failover capability increases network latency and memory consumption.

In the case where each server has a peer to peer connection with each database increasing the number of servers and databases in the system e.g. system in increases the time required to store and retrieve copies of session information. Also when a server must directly communicate with multiple persistent repositories e.g. databases in order to send and request session information system performance significantly degrades. Existing failover mechanisms indeed are not very scalable.

In light of this observation one embodiment of the present invention provides a highly scalable mechanism for storing and retrieving session information in a failover context. An asynchronous interaction model is provided wherein a first server stores session information pertaining to a session associated with a client by providing a copy of the session information to a bus mechanism. The bus mechanism handles the request to store the copy of the session information and ensures that the information is stored in each of the databases in case of a server crash. The first server not only does not interact with any of the databases it is not even aware of the databases. Therefore the improved failover mechanism provides faster delivery of copies of session information when storing the copies in a persistent repository.

Upon the failure of the first server a second server which is attempting to service the request of the client whose session is owned by the first server determines that the first server is down. The second server then sends a request to the bus mechanism to obtain the copy of session information pertaining to the client. The bus mechanism ensures that the necessary copy of session information is retrieved from one of the databases and is forwarded to the second server. The bus mechanism determines which database is best able to handle the request. Again the second server does not interact with any of the databases and is unaware of the databases. Thus multiple session servers will never make direct connections to any particular database which would result in a significant decrease in performance. Therefore the improved failover mechanism provides faster recovery of session information when a server offering a SSO solution fails.

When client requests resources from a different web or application server in the SSO trusted network of another session server such as server may validate client i.e. determines whether the client has signed on previously . Server may be part of the same enterprise e.g. network as server or part of a different enterprise as depicted in .

A load balancer may determine which server will serve the client s request by determining which server is least loaded. A load balancer may be implemented as its own layer between client and session servers in the SSO trusted network or the load balancer may be implemented on client .

Upon receiving a request from client to access one or more services block server makes a back channel call to server to determine whether client has already been authenticated and or is still authenticated without prompting client to re authenticate block .

One way to determine which server originally authenticated client is to use cookies stored locally on client . Client reveals its cookie to server upon the client s request for resources. The cookie contains a number typically 64 bit that identifies which server authenticated client .

Upon discovering that server has failed block server requests a copy of the sought after session information from bus mechanism block . In the case where the client had already been authenticated and the session information was stored properly bus mechanism returns a copy of the session information to server block . Client may then be validated without having to re authenticate if other factors indicate that the session created for client has not lapsed block .

Thus the distributed session failover system disclosed herein is highly scalable because any number of servers and persistent repositories such as databases may be added without experiencing a significant increase in network traffic or complexity. For example suppose a peer to peer system such as system of is employed and there are n session servers and m persistent repositories. Further suppose that another session server providing failover capabilities is added to system . In such a case m additional connections would have to be made wherein each connection is from the new session server to a persistent repository among the m persistent repositories.

According to an embodiment of the invention a single additional connection to the bus mechanism is required to handle all the pushing and pulling of requests between the new server and bus mechanism . In contrast if a single persistent repository is added to a session failover system employing a peer to peer mechanism then n additional connections would have to be made instead of just one connection using the mechanism disclosed herein. Furthermore each of servers may continue

According to an embodiment of the invention bus mechanism is comprised of APIs and and bus that comprises multiple brokers. Bus mechanism may be implemented using the Java Message Service JMS bus. JMS includes a JMS provider e.g. bus and a set of message interfaces e.g. APIs and that allow clients e.g. servers to send publish and receive subscribe messages.

Server initially sends a message containing a copy of session information to bus via API . APIs and allow clients to invoke the brokers of bus mechanism . A broker is a process with its own queue that may operate in a First In First Out FIFO manner. The broker is responsible for the reliable delivery of each request.

With APIs and such as the interfaces defined by JMS and described below a particular broker is used to forward from a session server i.e. publisher the message containing the copy of session information to the one or more persistent repositories such as databases . Brokers are configured with the session server. Either the session server is explicitly supplied with a list of brokers or brokers are stored in a JNDI context. In the former case the session server merely passes this list to the JMS API i.e. API in . The APIs determine which broker to contact.

In the latter case JMS clients look up configured JMS objects using the JNDI or Java Naming and Directory Interface API. JMS administrators use provider specific facilities for creating and configuring these objects. This division of work maximizes the portability of clients by delegating provider specific work to the administrator. It also leads to more administrable applications because clients do not need to embed administrative values in their code.

Alternatively if server determines that server has failed then a session server i.e. subscriber sends a message for requesting a copy of session information from bus mechanism via API . Once a suitable broker is determined the broker forwards the message via API to a persistent repository e.g. database among the one or more persistent repositories to retrieve a copy of session information. Specifically the broker publishes the request to each of the persistent repositories and at least one of the two things may happen. One all the persistent repositories that have the session may respond and those repositories that that don t have the session never respond and the recipient session server i.e. subscriber uses the first response that came from persistent repositories. Or two one of the persistent repositories can be designated as the responder based on a predefined arrangement.

Enterprise messaging products treat messages as lightweight entities that consist of a header and a body. The header contains fields used for message routing and identification the body contains the application data being sent. Within this general form the definition of a message varies significantly across products. There are major differences in the content and semantics of headers. Some products use a self describing canonical encoding of message data others treat data as completely opaque. Some products provide a repository for storing message descriptions that can be used to identify and interpret message content others don t.

Generally JMS messages are composed of a header and a body. Standard header fields contain values used by both clients and providers to identify and route messages. In addition to the standard header fields messages provide a built in facility for adding optional header fields to a message such as application specific header fields provider specific header fields. JMS also defines several types of message bodies which cover the majority of messaging styles currently in use.

The interfaces provided by JMS include a TopicConnectionFactory TopicConnection Topic TopicSession TopicPublisher and TopicSubscriber. A TopicConnectionFactory is an administered object used by a client to create a TopicConnection which is an active connection to a JMS provider e.g. bus .

A TopicSession is a single threaded context for sending and receiving messages. A TopicSession provides methods for creating TopicPublishers TopicSubscribers and TemporaryTopics. It also provides the unsubscribe method for deleting its client s durable subscriptions. If there are messages that have been received but not acknowledged when a TopicSession terminates then a durable TopicSubscriber must retain and redeliver them a nondurable subscriber need not do so.

A TopicPublisher is an object created by a TopicSession that is used for sending messages to a destination. Lastly a TopicSubscriber is an object created by a TopicSession that is used for receiving messages sent to a destination.

A Topic object encapsulates a provider specific topic name. It is the way a client specifies the identity of a topic to JMS methods. A Topic object gathers and distributes messages addressed to it. By relying on the Topic as an intermediary message publishers are kept independent of subscribers and vice versa. The Topic automatically adapts as both publishers and subscribers come and go. Publishers and subscribers are active when the Java objects that represent them exist. JMS also supports the optional durability of subscribers that remembers the existence of subscribers while they are inactive.

A TemporaryTopic is a unique Topic object created for the duration of a Connection or TopicConnection. TemporaryTopic is a system defined Topic that can be consumed only by the Connection or TopicConnection that created it.

Many publisher subscriber Pub Sub providers group topics into hierarchies and provide various options for subscribing to parts of the hierarchy. JMS places no restrictions on what a Topic object represents. It might be a leaf in a topic hierarchy or it might be a larger part of the hierarchy for subscribing to a general class of information . The organization of topics and the granularity of subscriptions to them is an important part of a Pub Sub application s architecture. JMS does not specify a policy for how this should be done. If an application takes advantage of a provider specific topic grouping mechanism it should document this. If the application is installed using a different provider it is the job of the administrator to construct an equivalent topic architecture and create equivalent Topic objects.

Bus mechanism allows the session servers in the SSO trusted network to invoke and query e.g. push and pull session information to and from persistent repositories without having to know about the individual persistent repositories. Thus the session servers in the SSO trusted network are not required to interact directly with any of the persistent repositories. In fact the session servers do not even have to be aware of the existence of any persistent repository.

Furthermore a session server in the SSO trusted network is assured that once it has submitted a set of session information to bus mechanism the set of session information will be stored in the one or more repositories. This is because bus mechanism has multiple brokers for fault tolerance if one broker goes down the session information is still stored in the one or more repositories e.g. by a backup broker . Thus the session server may continue operating without having to wait on the persistent repositories to each individually commit their push operations.

Another benefit from utilizing bus mechanism in a SSO failover context is that when a session server transfers responsibility to the broker for saving session information on each of the persistent repositories the session server does not have to wait for the session information to save properly and return an acknowledgement of that such saving occurred. The session server may continue providing SSO capabilities even before the session information is saved in any of the persistent repositories. Therefore bus mechanism helps to free up computing resources for each of servers that bus mechanism serves.

In one embodiment the servers in the SSO trusted network and bus mechanism may be implemented using hardware logic components or may take the form of sets of instructions that are executed by one or more processors. If they take the form of sets of instructions shows a block diagram of a computer system upon which these sets of instructions may be executed. Computer system includes a bus for facilitating information exchange and one or more processors coupled with bus for processing information. Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions by processor . Computer system may further include a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

In computer system bus may be any mechanism and or medium that enables information signals data etc. to be exchanged between the various components. For example bus may be a set of conductors that carries electrical signals. Bus may also be a wireless medium e.g. air that carries wireless signals between one or more of the components. Bus may further be a network connection that connects one or more of the components. Any mechanism and or medium that enables information signals data etc. to be exchanged between the various components may be used as bus .

Bus may also be a combination of these mechanisms media. For example processor may communicate with storage device wirelessly. In such a case the bus from the standpoint of processor and storage device would be a wireless medium such as air. Further processor may communicate with ROM capacitively. Further processor may communicate with main memory via a network connection. In this case the bus would be the network connection. Further processor may communicate with display via a set of conductors. In this instance the bus would be the set of conductors. Thus depending upon how the various components communicate with each other bus may take on different forms. Bus as shown in functionally represents all of the mechanisms and or media that enable information signals data etc. to be exchanged between the various components.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable medium as used herein refers to any medium that participates in providing data that causes a machine to operate in a specific fashion. In an embodiment implemented using computer system various machine readable media are involved for example in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory .

Common forms of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CDROM DVD or any other optical storage medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a LASHEPROM any other memory chip or cartridge or any other physical medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and transmit the data to the appropriate circuitry which can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

At this point it should be noted that although the invention has been described with reference to a specific embodiment it should not be construed to be so limited. Various modifications may be made by those of ordinary skill in the art with the benefit of this disclosure without departing from the spirit of the invention. Thus the invention should not be limited by the specific embodiments used to illustrate it but only by the scope of the issued claims and the equivalents thereof.

