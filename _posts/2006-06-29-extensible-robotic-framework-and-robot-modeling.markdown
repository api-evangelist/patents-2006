---

title: Extensible robotic framework and robot modeling
abstract: Various technologies and techniques are disclosed that provide a framework for developing and deploying distributed robotic applications. The framework allows a robotic application to be distributed across robotic services. Communications with a robotic service are performed via a URI. An operation is performed on a data element exposed through the robotic service. The system facilitates asynchronous operations of a robotics application across services. A development environment allows the user to create a robotics project that uses the distributed framework. A visualization/simulation environment allows for communication with virtual devices and real world devices for simulating the operation of asynchronous robotic applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07590680&OS=07590680&RS=07590680
owner: Microsoft Corporation
number: 07590680
owner_city: Redmond
owner_country: US
publication_date: 20060629
---
Software engineering tends to lag behind the other robotic sciences and in most cases has resulted in robotic applications that are monolithic with highly centralized processing and tight binding to the robotic hardware. Monolithic structure and tight binding to the hardware significantly reduces reuse application transportability and fail tolerance. Further unlike PC software applications to interact with the physical surroundings the robotic application must process numerous sensory inputs simultaneously make decisions and coordinate orchestrate the reaction across potentially multiple actuators. Sensors and actuators could be connected through multiple computational units. Current program structures make it difficult to develop applications for this environment.

Various technologies and techniques are disclosed that provide a framework for developing and deploying distributed robotic applications.

In one implementation the framework facilitates the composition of structured applications through the assembly of software pieces called services that provide device level abstraction isolation concurrency distribution and fail tolerance. The framework allows a robotic application to be distributed across robotic services. Data exchange between services that run on the same or different computation units is facilitated through strongly typed messaging. An operation is performed on a data element or device by sending a message to associated robotic service. Each service is identifiable via a URI. Message types along with behavioral patterns are described in service contracts which are externally discoverable.

A development environment allows the user to create a robotics project that uses the distributed framework.

A visualization simulation environment allows for communication with virtual devices and real world devices for simulating the operation of asynchronous robotic applications.

This Summary was provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

For the purposes of promoting an understanding of the principles of the invention reference will now be made to the embodiments illustrated in the drawings and specific language will be used to describe the same. It will nevertheless be understood that no limitation of the scope is thereby intended. Any alterations and further modifications in the described embodiments and any further applications of the principles as described herein are contemplated as would normally occur to one skilled in the art.

In one implementation an extensible software development framework is provided for vertical robotic application development. The framework facilitates the composition of structured applications through the assembly of software pieces called services that provide device level abstraction isolation concurrency distribution and failure tolerance. In this environment applications are a collection of services that orchestrate the interaction between these services by implementing the program logic. provides an example of one such distributed robotic application of one implementation.

The application structure is brought forth by layering that is based on functionality and computational requirements e.g. real time hardware assisted processing etc . In a robotic computational environment layers or services that are associated with a layer could be executed on different hardware platforms computational units that are specifically engineered or have characteristics that are suited for the computation. In the example shown in there are two different computational units and respectively . These computational units can be on the same or different devices. Decomposition of applications along the lines of requirements and the distribution of the computation through the robotic fabric yields componentized concurrent and distributed applications. Data exchange between services that run on the same or different computational units is facilitated through strongly typed messaging. Message types along with behavioral patterns are described in service contracts which are externally discoverable.

Device level abstraction via services permits the categorization of devices based on the functionality exposed. With this model services are capable of aggregating input from multiple devices and exposing virtual devices with higher order abstraction and functionality. As shown in distributed application includes three services and respectively which are located on two different computational units and respectively . Since services are runtime discoverable and bind able applications can be architected based on the device sensor or actuator type rather than exact knowledge of the device. This facilitates the decoupling of robotic applications from their tight binding with the hardware platform and increases component reuse.

In one implementation one or more of the techniques described herein are implemented as features within applications that run software applications that were created based upon the framework. In another implementation an integrated development environment captures and manages projects that contribute to the multiple layers of the robotic solution. The development environment includes robotic specific project elements such as graphical designers technological libraries down loaders debuggers etc. In yet another implementation a visualization and or simulation environment allows robotic applications to be visualized and or simulated.

As shown in an exemplary computer system to use for implementing one or more parts of the system includes a computing device such as computing device . In its most basic configuration computing device typically includes at least one processing unit and memory . Depending on the exact configuration and type of computing device memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. This most basic configuration is illustrated in by dashed line .

Additionally device may also have additional features functionality. For example device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by device . Any such computer storage media may be part of device .

Computing device includes one or more communication connections that allow computing device to communicate with other computers applications . Device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well known in the art and need not be discussed at length here. In one implementation computing device includes one or more parts of robotic framework application which will be described in further detail in . In another implementation computing device includes one or more parts of a robotic development application as described herein. In yet another implementation computing device includes one or more parts of visualization simulation application as described herein.

Turning now to a runtime environment of one implementation is shown that facilitates computational isolation and contention avoidance. The runtime is a lightweight message based concurrency library that provides coordination language constructs for joins choice interleave etc. In this environment messages form the interface to software pieces that asynchronously interact with each other. A lightweight SOAP based application protocol defines a flexible yet common foundation for defining services in terms of how they interact with each other in a manner suited for a decentralized environment. The model exposes simple protocols to handle common notion of service identity state and interactions with other services. In one implementation by exposing robotic application data through web protocols the development of rich browser based or client applications that are capable of interacting with the runtime is facilitated.

The runtime environment consists of the following Concurrency and Coordination Runtime decentralized system services robotic services orchestration application messaging transport and device services . In one implementation Concurrency and Coordination Runtime provides coordination of messages without the use of manual threading locks semaphores etc. This runtime component is based on asynchronous message passing and provides an execution context for services including a set of high level primitives for synchronizing messages. Decentralized system services are a collection of services that provide infrastructure functionality. In one implementation vertical applications utilize these decentralized system services and do not extend or replace these core services. In one implementation decentralized system services include the following services Activation Diagnostics Discovery Storage Terminal and User Experience .

The activation services enable services to be loaded created and initialized. The constructor service supports the CREATE verb and creates services based on the information passed in a CREATE request message. Services can either call the constructor directly or they can use a loader e.g. a manifest loader or other loader which provides a declarative mechanism for describing a set of services to create.

The discovery services allow a service to discover other services on a particular node. In one implementation each node has by default a single directory service with a well known name 

In one implementation services can insert or delete themselves from the well known directory at any point in time. Additional directories can be instantiated on demand as any other service.

The storage services allow services to persist state such as using the mount service. The mount service abstracts the local file system by exposing it through both a traditional HTTP and a lightweight message protocol. The mount service can be used by any service to persist data that the service may wish to retrieve at a later time for example when the service is created.

The diagnostics services facilitate debugging and diagnostics. A console service allows for structured data and filtered subscriptions. A non limiting example of a filtered subscription is an ErrorReporter service which subscribes for all problems encountered in the activation of a service. In one implementation the console service is always available at the location

The runtime diagnostics service provides a detailed look at the outstanding messages in the system port statistics and related information such as memory consumption etc. User Experience system services facilitates the interaction with the user interface.

The messaging transport service has a primary responsibility of providing resolution of a URI and delivering outbound or inbound messages across services or nodes . Typically the transport is the terminal end of the forwarder chain and where messages have to be converted to wire representation. The robotic services have a robot model service and visualization simulation services . Robotics services are a collection of services. Visualization and simulation services allow the robotic environment to be visualized and simulated. The visualization and simulation services can be used as part of the runtime environment and deployed to a robotics device to analyze validate and or predict parameters that are relevant to a robotics application.

The robot model service exposes the physical and logical shape of the robot and its components. The model is defined in the integrated robotics development environment and utilized by the runtime to make device service property associations. The robot model describes the robotic hardware software by providing information on the organization and physical characteristics of the robot.

In one implementation there exists a singular robotic model for a given solution. A graphical representation of the model is exposed through the Robot Model Editor as described in further detail in . As the robotic solution can span multiple computational units the robot model will span multiple runtime nodes that are either on a singular machine or spread across multiple machines. In one implementation the initial state for each these runtime nodes are specified in a manifest or other file that is deployed to each of the associated nodes. In one implementation the graphical representation and the device spatial organization are described through a mesh file. In one implementation the collection of files that build the robot model are specified in a .robot XML file.

Device services are responsible for abstracting interaction among a plurality of devices. In one implementation the manufacturer of a given device provides services as a template that go along with a particular hardware component such as a motor. By providing the manufacturer supplied or other source supplied interface for the particular hardware component the user does not have to create these details from scratch.

Orchestration application is responsible for orchestrating communications between robotics services . Administrative functions can be performed from a browser application and or other applications by communicating with the decentralized system services node as can user applications . These applications can communicate with the decentralized system services node through the designated HTTP or other port.

Turning now to with continued reference to robotic framework application such as one operating on computing device is illustrated. In one implementation robotic framework application is one of the application programs that reside on computing device . However it will be understood that robotic framework application can alternatively or additionally be embodied as computer executable instructions on one or more computers. Alternatively or additionally one or more parts of robotic framework application can be part of system memory on other computers and or applications or other such variations as would occur to one in the computer software art.

Robotic framework application includes program logic which is responsible for carrying out some or all of the techniques described herein. Program logic includes logic for decentralized system services which includes logic for providing an activation service for creating robotic services logic for providing a discovery service to allow services to discover each other on a particular node logic for providing a storage service to allow one or more services to persist state e.g. using a mount service and logic for providing a diagnostics service for facilitating debugging among the services . Program logic also includes logic for providing a messaging transport service for resolving URI s and delivering messages logic for providing a robot model service that provides robot characteristics logic for providing device services that abstract interaction among devices and other logic for operating the application . In one implementation program logic is operable to be called programmatically from another program such as using a single call to a procedure in program logic .

In one implementation the system performs the operation for the purpose of operating one or more robots. In another implementation the system performs the operation for the purpose of debugging a robotic application.

The framework is operable to allow communications with a second robotic service via a URI the second robotic service being located on a same robot device or a different device computer robot etc. than the first robotic service stage . The framework is operable to allow an operation e.g. get update or delete using REST etc. to be performed on the data through the second robotic service such as for purposes of operating one or more robots and or debugging them stage . The framework is operable to allow the first robotic service to be stopped and restarted without impacting the operation of any additionally operating robotic services stage . The process then ends and end point .

One is able to view services state or Node status by directing a web browser to the associated node via http port . This is a powerful mechanism as it facilities the developer to observe the operation of the system through simple tools and yields to rapid application development.

As a non limiting example of when the scenario depicted in might be used consider a warehouse which has deployed a robotic inventory control system. A centralized PC picks up orders via a server such as one running MICROSOFT Biztalk. This PC also runs an orchestration application and is aware of the locations of each Robot that is deployed in the warehouse and the tasks it is currently performing. When an order is received this orchestration application locates the most suitable robot to perform the task and sends an instruction to the specific robot. The robot autonomously navigates itself to the specified location and performs the task. When the robot completes the task or on realization that task cannot be completed for what ever reason the robot reports to the PC orchestration application that controls the behavior of the entire system.

Turning now to a process flow diagram for one implementation illustrates the stages involved in developing and deploying a robotic application. In one form the process of is at least partially implemented in the operating logic of computing device . The procedure begins at start point with starting a development tool. The user selects an option to create a robotic project such using a wizard or other option stage . In one implementation a wizard guides the user through a series of questions about the destination robotic device what type of devices is has and creates a template robot model that the user can further revise. The user navigates to the robotic model editor stage and defines the component organization and physical layout for the robotic device e.g. creates and or modifies the robot model optionally using a template and or details specified in wizard stage . In one implementation a physical robotic model is described at least in part using a template for a particular set of hardware associated with the destination robot. The user selects an option to navigate to an application designer stage . The user then defines the activities and control flow for the application stage when applicable and defines the activity logic stage when applicable.

The user selects an option to compile the program stage and if any errors are found by the system the user returns to defining the activity logic stage . If no errors are present then the user selects an option to navigate to the deployment editor stage and defines the deployment targets stage . In one implementation the deployment target is the actual destination robotic device. In another implementation the deployment target is a simulation mode which allows the user to simulate the destination robotic device. The user then selects an option to deploy and run the application stage and debugs the solution as appropriate stage . If any defects are discovered decision point then defect removal will move to any of the above stages stage . The process ends at end point .

Turning now to a logical diagram for components of a robot model of one implementation are shown. The robot package houses all robotic project specific user interface including robotic model editor application designer object model and verifier and tool box extensions .

In one implementation the robot package services XML files that contain information to construct the graphical design surface s . In other implementations files other than XML are used.

The DSS Package houses the code that facilitates communication between design and execution environment and includes decentralized system services debugging services and directory services . Through this DSS package the design environment can discover services that are available and their status running stopped etc capabilities and update service level properties e.g. using directory services . This package also facilitates core service message level debugging e.g. using debugging services .

In one implementation the user interface that is provided by the above packages tightly integrates with the development environment. For example menu structures properties displayed in the properties windows and selection in the project explorer are context sensitive. The projects are managed in the context of a development solution and the build system is leveraged for compilation.

The visual diagramming surface is serialized into a file that is associated with the robotic project. The elements placed on the design surface their properties and inter connections between design elements are accessible through the graphics design object model. The object model that is used for building robotic applications and a code generator that is used to build and deploy robotic solutions .

Turning now to a process flow diagram for one implementation illustrates the stages involved in providing a visualization simulation environment. In one form the process of is at least partially implemented in the operating logic of computing device . The procedure begins at start point with providing a framework for allowing a robotic application to be distributed across a plurality of robotic services stage . A simulation engine e.g. a physics engine is provided that is operable to use the framework to simulate an operation of a robotics application across asynchronous services stage . As described in visualization simulation services can be used during an actual simulation and or during a runtime environment for making predictions. The simulation engine is operable to communicate with virtual devices and real world devices e.g. to use a real world robotic device in a simulation and or to use real world environment information in a simulation stage . The process ends at end point .

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims. All equivalents changes and modifications that come within the spirit of the implementations as described herein and or by the following claims are desired to be protected.

For example a person of ordinary skill in the computer software art will recognize that the client and or server arrangements user interface screen content and or data layouts as described in the examples discussed herein could be organized differently on one or more computers to include fewer or additional options or features than as portrayed in the examples.

