---

title: Adjusting quantization to preserve non-zero AC coefficients
abstract: A video encoder identifies one or more AC coefficients of each of plural blocks in the picture. The encoder identifies a threshold quantization step size such that the identified AC coefficient(s) of each of the plural blocks are nonzero after quantization according to the threshold quantization step size. The threshold quantization step size is such that quantization according to the next higher quantization step size would result in at least one of the identified AC coefficient(s) of at least one of the plural blocks being zero. For example, identifying the threshold quantization step size comprises identifying n top AC coefficients in each of four blocks of a macroblock, determining the smallest AC coefficient among the identified n top AC coefficients of the four blocks, and iteratively evaluating the smallest AC coefficient with respect to candidate quantization step sizes until the threshold quantization step size is identified.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08130828&OS=08130828&RS=08130828
owner: Microsoft Corporation
number: 08130828
owner_city: Redmond
owner_country: US
publication_date: 20060407
---
With the increased popularity of DVDs music delivery over the Internet and digital cameras digital media have become commonplace. Engineers use a variety of techniques to process digital audio video and images efficiently while still maintaining quality. To understand these techniques it helps to understand how the audio video and image information is represented and processed in a computer.

A computer processes media information as a series of numbers representing that information. For example a single number may represent the intensity of brightness or the intensity of a color component such as red green or blue for each elementary small region of a picture so that the digital representation of the picture consists of one or more arrays of such numbers. Each such number may be referred to as a sample. For a color image it is conventional to use more than one sample to represent the color of each elemental region and typically three samples are used. The set of these samples for an elemental region may be referred to as a pixel where the word pixel is a contraction referring to the concept of a picture element. For example one pixel may consist of three samples that represent the intensity of red green and blue light necessary to represent the elemental region. Such a pixel type is referred to as an RGB pixel. Several factors affect quality of media information including sample depth resolution and frame rate for video .

Sample depth is a property normally measured in bits that indicates the range of numbers that can be used to represent a sample. When more values are possible for the sample quality can be higher because the number can capture more subtle variations in intensity and or a greater range of values. Resolution generally refers to the number of samples over some duration of time for audio or space for images or individual video pictures . Images with higher resolution tend to look crisper than other images and contain more discernable useful details. Frame rate is a common term for temporal resolution for video. Video with higher frame rate tends to mimic the smooth motion of natural objects better than other video and can similarly be considered to contain more detail in the temporal dimension. For all of these factors the tradeoff for high quality is the cost of storing and transmitting the information in terms of the bit rate necessary to represent the sample depth resolution and frame rate as Table 1 shows.

Despite the high bit rate necessary for storing and sending high quality video such as HDTV companies and consumers increasingly depend on computers to create distribute and play back high quality content. For this reason engineers use compression also called source coding or source encoding to reduce the bit rate of digital media. Compression decreases the cost of storing and transmitting the information by converting the information into a lower bit rate form. Compression can be lossless in which quality of the video does not suffer but decreases in bit rate are limited by the complexity of the video. Or compression can be lossy in which quality of the video suffers but decreases in bit rate are more dramatic. Decompression also called decoding reconstructs a version of the original information from the compressed form. A codec is an encoder decoder system.

In general video compression techniques include intra compression and inter or predictive compression. For video frames intra compression techniques compress individual frames typically called I frames or key frames. Inter compression techniques compress frames with reference to preceding and or following frames and inter compressed frames are typically called predicted frames P frames or B frames.

Microsoft Corporation s Windows Media Video Version 8 WMV8 includes a video encoder and a video decoder. The WMV8 encoder uses intra and inter compression and the WMV8 decoder uses intra and inter decompression. Windows Media Video Version 9 WMV9 uses a similar architecture for many operations.

The encoder then quantizes the DCT coefficients resulting in an 8 8 block of quantized DCT coefficients . Quantization is lossy. Since low frequency DCT coefficients tend to have higher values quantization typically results in loss of precision but not complete loss of the information for the coefficients. On the other hand since high frequency DCT coefficients tend to have values of zero or close to zero quantization of the high frequency coefficients typically results in contiguous regions of zero values. In addition in some cases high frequency DCT coefficients are quantized more coarsely than low frequency DCT coefficients resulting in greater loss of precision information for the high frequency DCT coefficients.

The encoder then prepares the 8 8 block of quantized DCT coefficients for entropy encoding which is a form of lossless compression. The exact type of entropy encoding can vary depending on whether a coefficient is a DC coefficient lowest frequency an AC coefficient other frequencies in the top row or left column or another AC coefficient.

The encoder encodes the DC coefficient as a differential from the DC coefficient of a neighboring 8 8 block which is a previously encoded neighbor e.g. top or left of the block being encoded. shows a neighbor block that is situated to the left of the block being encoded in the frame. The encoder entropy encodes the differential.

The entropy encoder can encode the left column or top row of AC coefficients as a differential from a corresponding left column or top row of the neighboring 8 8 block. This is an example of AC coefficient prediction. shows the left column of AC coefficients encoded as a differential from the left column of the neighboring in reality to the left block . The differential coding increases the chance that the differential coefficients have zero values. The remaining AC coefficients are from the block of quantized DCT coefficients.

The encoder scans the 8 8 block of quantized AC DCT coefficients into a one dimensional array and then entropy encodes the scanned AC coefficients using a variation of run length coding . The encoder selects an entropy code from one or more run level last tables and outputs the entropy code.

Inter compression in the WMV8 encoder uses block based motion compensated prediction coding followed by transform coding of the residual error. illustrate the block based inter compression for a predicted frame in the WMV8 encoder. In particular illustrates motion estimation for a predicted frame and illustrates compression of a prediction residual for a motion compensated block of a predicted frame.

For example in the WMV8 encoder computes a motion vector for a macroblock in the predicted frame . To compute the motion vector the encoder searches in a search area of a reference frame . Within the search area the encoder compares the macroblock from the predicted frame to various candidate macroblocks in order to find a candidate macroblock that is a good match. The encoder outputs information specifying the motion vector entropy coded for the matching macroblock. The motion vector is differentially coded with respect to a motion vector predictor.

After reconstructing the motion vector by adding the differential to the motion vector predictor a decoder uses the motion vector to compute a prediction macroblock for the macroblock using information from the reference frame which is a previously reconstructed frame available at the encoder and the decoder. The prediction is rarely perfect so the encoder usually encodes blocks of pixel differences also called the error or residual blocks between the prediction macroblock and the macroblock itself.

The preceding section mentioned quantization a mechanism for lossy compression and entropy coding also called lossless compression. Lossless compression reduces the bit rate of information by removing redundancy from the information without any reduction in fidelity. For example a series of ten consecutive pixels that are all exactly the same shade of red could be represented as a code for the particular shade of red and the number ten as a run length of consecutive pixels and this series can be perfectly reconstructed by decompression from the code for the shade of red and the indicated number ten of consecutive pixels having that shade of red. Lossless compression techniques reduce bit rate at no cost to quality but can only reduce bit rate up to a certain point. Decreases in bit rate are limited by the inherent amount of variability in the statistical characterization of the input data which is referred to as the source entropy.

In contrast with lossy compression the quality suffers somewhat but the achievable decrease in bit rate is more dramatic. For example a series of ten pixels each being a slightly different shade of red can be approximated as ten pixels with exactly the same particular approximate red color. Lossy compression techniques can be used to reduce bit rate more than lossless compression techniques but some of the reduction in bit rate is achieved by reducing quality and the lost quality cannot be completely recovered. Lossy compression is often used in conjunction with lossless compression in a system design in which the lossy compression establishes an approximation of the information and lossless compression techniques are applied to represent the approximation. For example the series of ten pixels each a slightly different shade of red can be represented as a code for one particular shade of red and the number ten as a run length of consecutive pixels. In general an encoder varies quantization to trade off quality and bit rate. Coarser quantization results in greater quality reduction but allows for greater bit rate reduction. In decompression the original series would then be reconstructed as ten pixels with the same approximated red color.

According to one possible definition quantization is a term used for an approximating non reversible mapping function commonly used for lossy compression in which there is a specified set of possible output values and each member of the set of possible output values has an associated set of input values that result in the selection of that particular output value. A variety of quantization techniques have been developed including scalar or vector uniform or non uniform and adaptive or non adaptive quantization.

According to one possible definition a scalar quantizer is an approximating functional mapping x Q x of an input value x to a quantized value Q x sometimes called a reconstructed value. shows a staircase I O function for a scalar quantizer. The horizontal axis is a number line for a real number input variable x and the vertical axis indicates the corresponding quantized values Q x . The number line is partitioned by thresholds such as the threshold . Each value of x within a given range between a pair of adjacent thresholds is assigned the same quantized value Q x . For example each value of x within the range is assigned the same quantized value . At a threshold one of the two possible quantized values is assigned to an input x depending on the system. Overall the quantized values Q x exhibit a discontinuous staircase pattern. The distance the mapping continues along the number line depends on the system typically ending after a finite number of thresholds. The placement of the thresholds on the number line may be uniformly spaced as shown in or non uniformly spaced.

A scalar quantizer can be decomposed into two distinct stages. The first stage is the classifier stage in which a classifier function mapping x A x maps an input x to a quantization index A x which is often integer valued. In essence the classifier segments an input number line or data set. shows a generalized classifier and thresholds for a scalar quantizer. As in a number line for a real number variable x is segmented by thresholds such as the threshold . Each value of x within a given range such as the range is assigned the same quantized value Q x . shows a numerical example of a classifier and thresholds for a scalar quantizer.

In the second stage a reconstructor functional mapping k k maps each quantization index k to a reconstruction value k . In essence the reconstructor places steps having a particular height relative to the input number line segments or selects a subset of data set values for reconstruction of each region determined by the classifier. The reconstructor functional mapping may be implemented for example using a lookup table. Overall the classifier relates to the reconstructor as follows 1 .

In common usage the term quantization is often used to describe the classifier stage which is performed during encoding. The term inverse quantization is similarly used to describe the reconstructor stage whether performed during encoding or decoding.

The distortion introduced by using such a quantizer may be computed with a difference based distortion measure d x Q x . Typically such a distortion measure has the property that d x Q x increases as x Q x deviates from zero and typically each reconstruction value lies within the range of the corresponding classification region so that the straight line that would be formed by the functional equation Q x x will pass through every step of the staircase diagram as shown in and therefore Q Q x will typically be equal to Q x . In general a quantizer is considered better in rate distortion terms if the quantizer results in a lower average value of distortion than other quantizers for a given bit rate of output. More formally a quantizer is considered better if for a source random variable X the expected i.e. the average or statistical mean value of the distortion measure Ed X Q X is lower for an equal or lower entropy H of A X . The most commonly used distortion measure is the squared error distortion measure for which d k Y x y . When the squared error distortion measure is used the expected value of the distortion measure is referred to as the mean squared error.

A non uniform quantizer has threshold values that are not uniformly spaced for all classifier regions. According to one possible definition a dead zone plus uniform threshold quantizer DZ UTQ is a quantizer with uniformly spaced threshold values for all classifier regions except the one containing the zero input value which is called the dead zone DZ . In a general sense a DZ UTQ is a non uniform quantizer since the DZ size is different than the other classifier regions.

A DZ UTQ has a classifier index mapping rule x A x that can be expressed based on two parameters. shows a staircase I O function for a DZ UTQ and shows a generalized classifier and thresholds for a DZ UTQ. The parameter s which is greater than 0 indicates the step size for all steps other than the DZ. Mathematically all sare equal to s for i 0. The parameter z which is greater than or equal to 0 indicates the ratio of the DZ size to the size of the other steps. Mathematically s z s. In z is 2 so the DZ is twice as wide as the other classification zones. The index mapping rule x A x for a DZ UTQ can be expressed as 

In some system designs not shown an additional consideration may be necessary to fully characterize a DZ UTQ classification rule. For practical reasons there may be a need to limit the range of values that can result from the classification function A x to some reasonable finite range. This limitation is referred to as clipping. For example in some such systems the classification rule could more precisely be defined as 

Different reconstruction rules may be used to determine the reconstruction value for each quantization index. Standards and product specifications that focus only on achieving interoperability will often specify reconstruction values without necessarily specifying the classification rule. In other words some specifications may define the functional mapping k k without defining the functional mapping x A x . This allows a decoder built to comply with the standard specification to reconstruct information correctly. In contrast encoders are often given the freedom to change the classifier in any way that they wish while still complying with the standard specification.

Numerous systems for adjusting quantization thresholds have been developed. Many standards and products specify reconstruction values that correspond to a typical mid point reconstruction rule e.g. for a typical simple classification rule for the sake of simplicity. For classification however the thresholds can in fact be adjusted so that certain input values will be mapped to more common and hence lower bit rate indices which makes the reconstruction values closer to optimal.

In many systems the extent of quantization is measured in terms of quantization step size. Coarser quantization uses larger quantization step sizes corresponding to wider ranges of input values. Finer quantization uses smaller quantization step sizes. Often for purposes of signaling and reconstruction quantization step sizes are parameterized as multiples of a smallest quantization step size.

As mentioned above lossy compression tends to cause a decrease in quality. For example a series of ten samples of slightly different values can be approximated using quantization as ten samples with exactly the same particular approximate value. This kind of quantization can reduce the bit rate of encoding the series of ten samples but at the cost of lost detail in the original ten samples.

In some cases quantization produces visible artifacts that tend to be more artificial looking and visually distracting than simple loss of fine detail. For example smooth un textured content is susceptible to contouring artifacts artifacts that appear between regions of two different quantization output values because the human visual system is sensitive to subtle variations particularly luma differences in smooth content. Using the above example consider a case where the luma values of the series of ten samples change gradually and consistently from the first sample to the tenth sample. Quantization may approximate the first five sample values as one value and the last five sample values as another value. While this kind of quantization may not create visible artifacts in textured areas due to masking effects in smooth regions it can create a visible line or step in the reconstructed image between the two sets of five samples.

In differential quantization an encoder varies quantization step sizes also referred to herein as quantization parameters or QPs in some implementations for different parts of a picture. Typically this involves varying QPs on a macroblock level or other sub picture level. The encoder makes decisions on how to vary the QPs and signals those decisions as appropriate to a decoder.

For example a VC 1 encoder optionally chooses differential quantization for compression. The encoder sends a bitstream element DQUANT at a syntax level above picture level to indicate whether or not the QP can vary among the macroblocks in individual pictures. The encoder sends a picture level bitstream element PQINDEX to indicate a picture QP. If DQUANT 0 the QP indicated by PQINDEX is used for all macroblocks in the picture. If DQUANT 1 or 2 different macroblocks in the same picture can use different QPs.

The VC 1 encoder can use more than one approach to differential quantization. In one approach only two different QPs are used for a picture. This is referred to as bi level differential quantization. For example one QP is used for macroblocks at picture edges and another QP is used for macroblocks in the rest of the picture. This can be useful for saving bits at picture edges where fine detail is less important for maintaining overall visual quality. Or a 1 bit value signaled per macroblock indicates which of two available QP values to use for the macroblock. In another approach referred to as multi level differential quantization a larger number of different QPs can be used for individual macroblocks in a picture.

The encoder sends a picture level bitstream element VOPDQUANT when DQUANT is non zero. VOPDQUANT is composed of other elements potentially including DQPROFILE which indicates which parts of the picture can use QPs other than the picture QP. When DQPROFILE indicates that arbitrary different macroblocks can use QPs other than the picture QP the bitstream element DQBILEVEL is present. If DQBILEVEL 1 each macroblock uses one of two QPs bi level quantization . If DQBILEVEL 0 each macroblock can use any QP multi level quantization .

The bitstream element MQDIFF is sent at macroblock level to signal a 1 bit selector for a macroblock for bi level quantization. For multi level quantization MQDIFF indicates a differential between the picture QP and the macroblock QP or escape coded absolute QP for a macroblock.

Numerous international standards specify aspects of video decoders and formats for compressed video information. Directly or by implication these standards also specify certain encoder details but other encoder details are not specified. Some standards address still image compression decompression and other standards address audio compression decompression. Numerous companies have produced encoders and decoders for audio still images and video. Various other kinds of signals for example hyperspectral imagery graphics text financial information etc. are also commonly represented and stored or transmitted using compression techniques.

Various video standards allow the use of different quantization step sizes for different picture types and allow variation of quantization step sizes for rate and quality control.

Standards typically do not fully specify the quantizer design. Most allow some variation in the encoder classification rule x A x and or the decoder reconstruction rule k k . The use of a DZ ratio z 2 or greater has been implicit in a number of encoding designs. For example the spacing of reconstruction values for predicted regions in some standards implies use of z 2. Reconstruction values in these examples from standards are spaced appropriately for use of DZ UTQ classification with z 2. Designs based on z 1 or at least z

Given the critical importance of video compression to digital video it is not surprising that video compression is a richly developed field. Whatever the benefits of previous video compression techniques however they do not have the advantages of the following techniques and tools.

The present application is directed to techniques and tools for preserving non zero AC coefficients in certain encoding scenarios. For example a video encoder identifies a threshold quantization step size that tends to preserve AC coefficients that help reduce contouring artifacts in smooth regions of a video picture. This can improve perceptual quality of the video picture at a relatively small bit rate cost.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In one aspect a video encoder computes plural transform coefficients for a video picture and identifies one or more AC coefficients of each of plural blocks in the picture. The encoder identifies a threshold quantization step size such that the identified AC coefficient s of each of the plural blocks are nonzero after quantization according to the threshold quantization step size. For example for each of the plural blocks the one or more AC coefficients are the one or more highest amplitude AC coefficients of the block and the identifying comprises determining the smallest AC coefficient of the highest amplitude AC coefficients and iteratively evaluating the smallest AC coefficient with respect to candidate quantization step sizes until the threshold quantization step size is identified. The encoder compresses at least a portion of the video picture using the threshold quantization step size. The threshold quantization step size is such that quantization according to the next higher quantization step size would result in at least one of the identified AC coefficient s of at least one of the plural blocks being zero. The video picture can be an intra picture or a predicted picture.

In another aspect for a macroblock comprising four blocks of the plural blocks a video encoder identifies a threshold quantization step size e.g. smaller than a default quantization step size for the picture for the macroblock such that for each the four blocks of the macroblock one or more AC coefficients are nonzero after quantization according to the threshold quantization step size. For example identifying the threshold quantization step size comprises determining an AC coefficient count n e.g. 4 or fewer identifying n top AC coefficients in each of the four blocks of the macroblock determining the smallest AC coefficient among the identified n top AC coefficients of the four blocks and iteratively evaluating the smallest AC coefficient with respect to candidate quantization step sizes until the threshold quantization step size is identified. The encoder compresses the macroblock using the threshold quantization step size. The quantization can use a uniform or non uniform quantizer.

In another aspect a video encoder identifies e.g. using a texture map a smooth region e.g. a gradient slope region of a video picture and for a portion of the smooth region selects a threshold quantization step size so as to preserve a gradient across the smooth region by retaining one or more AC coefficients for the portion that would otherwise be quantized to zero according to a next higher quantization step size. For example the one or more AC coefficients for the portion include the top n AC coefficients of each of plural blocks in the portion and the selection of the threshold quantization step size comprises iteratively evaluating candidate quantization step sizes until the threshold quantization step size is selected. The encoder compresses the portion using the threshold quantization step size.

The foregoing and other objects features and advantages will become more apparent from the following detailed description which proceeds with reference to the accompanying figures.

The present application relates to techniques and tools for efficient compression of video. In various described embodiments a video encoder incorporates techniques for encoding video and corresponding signaling techniques for use with a bitstream format or syntax comprising different layers or levels. Some of the described techniques and tools can be applied to interlaced or progressive frames.

Various alternatives to the implementations described herein are possible. For example techniques described with reference to flowchart diagrams can be altered by changing the ordering of stages shown in the flowcharts by repeating or omitting certain stages etc. For example initial stages an analysis e.g. obtaining texture information for a picture or performing texture analysis in detecting smooth regions can be completed before later stages e.g. making encoding decisions for the picture or performing temporal analysis in detecting smooth regions begin or operations for the different stages can be interleaved on a block by block macroblock by macroblock or other region by region basis. As another example although some implementations are described with reference to specific macroblock formats other formats also can be used.

The various techniques and tools can be used in combination or independently. Different embodiments implement one or more of the described techniques and tools. Some techniques and tools described herein can be used in a video encoder or in some other system not specifically limited to video encoding.

With reference to the computing environment includes at least one processing unit and memory . In this most basic configuration is included within a dashed line. The processing unit executes computer executable instructions and may be a real or a virtual processor. In a multi processing system multiple processing units execute computer executable instructions to increase processing power. The memory may be volatile memory e.g. registers cache RAM non volatile memory e.g. ROM EEPROM flash memory etc. or some combination of the two. The memory stores software implementing a video encoder with one or more of the described techniques and tools.

A computing environment may have additional features. For example the computing environment includes storage one or more input devices one or more output devices and one or more communication connections . An interconnection mechanism not shown such as a bus controller or network interconnects the components of the computing environment . Typically operating system software not shown provides an operating environment for other software executing in the computing environment and coordinates activities of the components of the computing environment .

The storage may be removable or non removable and includes magnetic disks magnetic tapes or cassettes CD ROMs DVDs or any other medium which can be used to store information and which can be accessed within the computing environment . The storage stores instructions for the software implementing the video encoder.

The input device s may be a touch input device such as a keyboard mouse pen or trackball a voice input device a scanning device or another device that provides input to the computing environment . For audio or video encoding the input device s may be a sound card video card TV tuner card or similar device that accepts audio or video input in analog or digital form or a CD ROM or CD RW that reads audio or video samples into the computing environment . The output device s may be a display printer speaker CD writer or another device that provides output from the computing environment .

The communication connection s enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer executable instructions audio or video input or output or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired or wireless techniques implemented with an electrical optical RF infrared acoustic or other carrier.

The techniques and tools can be described in the general context of computer readable media. Computer readable media are any available media that can be accessed within a computing environment. By way of example and not limitation with the computing environment computer readable media include memory storage communication media and combinations of any of the above.

The techniques and tools can be described in the general context of computer executable instructions such as those included in program modules being executed in a computing environment on a target real or virtual processor. Generally program modules include routines programs libraries objects classes components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer executable instructions for program modules may be executed within a local or distributed computing environment.

For the sake of presentation the detailed description uses terms like decide and analyze to describe computer operations in a computing environment. These terms are high level abstractions for operations performed by a computer and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.

The encoder processes video pictures. The term picture generally refers to source coded or reconstructed image data. For progressive video a picture is a progressive video frame. For interlaced video a picture may refer to an interlaced video frame the top field of the frame or the bottom field of the frame depending on the context. The encoder is block based and uses a 4 2 0 macroblock format for frames. As shown in macroblock includes four 8 8 luminance or luma blocks Y through Y and two 8 8 chrominance or chroma blocks U and V that are co located with the four luma blocks but half resolution horizontally and vertically following the conventional 4 2 0 macroblock format. For fields the same or a different macroblock organization and format may be used. The 8 8 blocks may be further sub divided at different stages e.g. at the frequency transform and entropy encoding stages. The encoder can perform operations on sets of samples of different size or configuration than 8 8 blocks and 16 16 macroblocks. Alternatively the encoder is object based or uses a different macroblock or block format.

Returning to the encoder system compresses predicted pictures and intra coded key pictures. For the sake of presentation shows a path for key pictures through the encoder system and a path for predicted pictures. Many of the components of the encoder system are used for compressing both key pictures and predicted pictures. The exact operations performed by those components can vary depending on the type of information being compressed.

A predicted picture e.g. progressive P frame or B frame interlaced P field or B field or interlaced P frame or B frame is represented in terms of prediction or difference from one or more other pictures which are typically referred to as reference pictures or anchors . A prediction residual is the difference between what was predicted and the original picture. In contrast a key picture e.g. progressive I frame interlaced I field or interlaced I frame is compressed without reference to other pictures.

If the current picture is a predicted picture a motion estimator estimates motion of macroblocks or other sets of samples of the current picture with respect to one or more reference pictures for example the reconstructed previous picture buffered in the picture store . If the current picture is a bi predictive picture a motion estimator estimates motion in the current picture with respect to up to four reconstructed reference pictures for an interlaced B field for example . Typically a motion estimator estimates motion in a B picture with respect to one or more temporally previous reference pictures and one or more temporally future reference pictures but B pictures need not be predicted from different temporal directions. The encoder system can use the separate stores and for multiple reference pictures.

The motion estimator can estimate motion by full sample sample sample or other increments and can switch the precision of the motion estimation on a picture by picture basis or other basis. The motion estimator and compensator also can switch between types of reference picture sample interpolation e.g. between bicubic and bilinear on a per frame or other basis. The precision of the motion estimation can be the same or different horizontally and vertically. The motion estimator outputs as side information motion information such as differential motion vector information. The encoder encodes the motion information by for example computing one or more predictors for motion vectors computing differentials between the motion vectors and predictors and entropy coding the differentials. To reconstruct a motion vector a motion compensator combines a predictor with differential motion vector information.

The motion compensator applies the reconstructed motion vector to the reconstructed picture s to form a motion compensated current picture . The prediction is rarely perfect however and the difference between the motion compensated current picture and the original current picture is the prediction residual . During later reconstruction of the picture the prediction residual is added to the motion compensated current picture to obtain a reconstructed picture that is closer to the original current picture . In lossy compression however some information is still lost from the original current picture . Alternatively a motion estimator and motion compensator apply another type of motion estimation compensation.

A frequency transformer converts the spatial domain video information into frequency domain i.e. spectral data. For block based video pictures the frequency transformer applies a DCT variant of DCT or other block transform to blocks of the sample data or prediction residual data producing blocks of frequency transform coefficients. Alternatively the frequency transformer applies another conventional frequency transform such as a Fourier transform or uses wavelet or sub band analysis. The frequency transformer may apply an 8 8 8 4 4 8 4 4 or other size frequency transform.

A quantizer then quantizes the blocks of spectral data coefficients. The quantizer applies uniform scalar quantization to the spectral data with a step size that varies on a picture by picture basis or other basis e.g. a macroblock by macroblock basis . Alternatively the quantizer applies another type of quantization to the spectral data coefficients for example a non uniform vector or non adaptive quantization or directly quantizes spatial domain data in an encoder system that does not use frequency transformations. Techniques and tools relating to quantization in some implementations are described in detail below.

In addition to adaptive quantization the encoder can use frame dropping adaptive filtering or other techniques for rate control.

The encoder may use special signaling for a skipped macroblock which is a macroblock that has no information of certain types e.g. no differential motion vectors for the macroblock and no residual information .

When a reconstructed current picture is needed for subsequent motion estimation compensation an inverse quantizer performs inverse quantization on the quantized spectral data coefficients. An inverse frequency transformer then performs the inverse of the operations of the frequency transformer producing a reconstructed prediction residual for a predicted picture or a reconstructed key picture. If the current picture was a key picture the reconstructed key picture is taken as the reconstructed current picture not shown . If the current picture was a predicted picture the reconstructed prediction residual is added to the motion compensated current picture to form the reconstructed current picture. One or both of the picture stores buffers the reconstructed current picture for use in motion compensated prediction. In some embodiments the encoder applies a de blocking filter to the reconstructed frame to adaptively smooth discontinuities and other artifacts in the picture.

The entropy coder compresses the output of the quantizer as well as certain side information e.g. motion information quantization step size QP . Typical entropy coding techniques include arithmetic coding differential coding Huffman coding run length coding LZ coding dictionary coding and combinations of the above. The entropy coder typically uses different coding techniques for different kinds of information e.g. DC coefficients AC coefficients different kinds of side information and can choose from among multiple code tables within a particular coding technique.

The entropy coder provides compressed video information to the multiplexer MUX . The MUX may include a buffer and a buffer level indicator may be fed back to a controller. Before or after the MUX the compressed video information can be channel coded for transmission over the network. The channel coding can apply error detection and correction data to the compressed video information .

A controller not shown receives inputs from various modules such as the motion estimator frequency transformer quantizer inverse quantizer entropy coder and buffer . The controller evaluates intermediate results during encoding for example estimating distortion and performing other rate distortion analysis. The controller works with modules such as the motion estimator frequency transformer quantizer and entropy coder to set and change coding parameters during encoding. When an encoder evaluates different coding parameter choices during encoding the encoder may iteratively perform certain stages e.g. quantization and inverse quantization to evaluate different parameter settings. The encoder may set parameters at one stage before proceeding to the next stage. Or the encoder may jointly evaluate different coding parameters. The tree of coding parameter decisions to be evaluated and the timing of corresponding encoding depends on implementation.

The relationships shown between modules within the encoder indicate general flows of information in the encoder other relationships are not shown for the sake of simplicity. In particular usually does not show side information indicating the encoder settings modes tables etc. used for a video sequence picture macroblock block etc. Such side information once finalized is sent in the output bitstream typically after entropy encoding of the side information.

Particular embodiments of video encoders typically use a variation or supplemented version of the generalized encoder . Depending on implementation and the type of compression desired modules of the encoder can be added omitted split into multiple modules combined with other modules and or replaced with like modules. For example the controller can be split into multiple controller modules associated with different modules of the encoder. In alternative embodiments encoders with different modules and or other configurations of modules perform one or more of the described techniques.

Video content can be characterized using a perceptual model. This can help an encoder to make appropriate encoding decisions for different kinds of video content. An encoder can analyze a picture before encoding to provide characterizations for the content in different parts of the picture e.g. blocks macroblocks etc. . For example relatively smooth parts of a video picture such as a blue sky may be characterized as less acceptable for introducing distortion because certain kinds of quality degradation e.g. quantization artifacts are more easily perceived by humans in smooth regions. In contrast distortion is generally less noticeable and thus more acceptable in texture regions.

With reference to a video encoder such as one described above with reference to implements adaptive encoding techniques in a process that characterizes portions e.g. blocks of macroblocks macroblocks or other regions of a video picture e.g. as a smooth region edge region texture region etc. and adapts one or more encoding techniques according to the characterization. Many of the described techniques provide adaptive encoding within a picture such as on a block macroblock or other region. The techniques use information to classify different parts of the image and to encode them accordingly. More particularly a video encoder characterizes portions of the picture to classify content based on its perceptual characteristics.

At the video encoder characterizes one or more portions of a video picture. For example the encoder characterizes a block of the video picture based on intensity variance within the block. In one implementation the encoder computes a sum of the differences between a pixel and its adjacent pixels for the pixels in the block or a down sampled version of the block. This sum of differences value measures intensity variance between a pixel and its surrounding pixels. For example surrounding pixels comprise two or more other pixels adjacent to or nearly adjacent to a pixel such as above or below to the left or right or diagonal to a pixel. The difference between a pixel s intensity and the intensities of its surrounding pixels is computed based on differences in luma and or chroma data. In other words the differences are computed with luma samples and or chroma samples. An average computed difference value is assigned to the pixel e.g. a pixel gradient . A difference value is computed in this way for pixels in a block e.g. a block gradient or for some sub sampled set thereof. The difference values assigned to pixels in a block are evaluated to determine a characterization or classification e.g. smooth edge or texture texture or non texture smooth or non smooth etc. for the block which can be expressed a block value. In one example the pixel gradients for pixels in a block are evaluated to determine a median difference value for the block gradient e.g. a block median . Thus intensity differences between pixels within a block provide a measure of intensity variance for a block macroblock or other video picture region.

A block median is not required to determine a block value. An intensity variance or block characterization may also be based on an average value for difference values assigned to pixels in the block e.g. a block average . The block median or average can be used to classify the block and or can be used as input to a finer grained control function. The characterization or control function adaptively varies one or more aspects of encoding.

Alternatively instead of computing an intensity variance to characterize a block the encoder uses another metric.

At the encoder adaptively encodes the video picture based on the characterizations. In one implementation encoding techniques for removal or reduction of contouring artifacts are performed based on block characterization. For example gradient slope detection DC shift detection AC coefficient preservation and adaptive differential quantization are performed for certain smooth regions and textured regions are quantized more strongly to conserve bit rate.

Although shows the characterizing stage preceding the adaptive encoding stage for multiple portions of a picture these stages may also occur iteratively on a block by block basis in the picture or be ordered on some other basis.

At the encoder signals the adaptively encoded bit stream. When differential quantization is used by the encoder to encode based on block characterization for example the video encoder encodes information in the compressed bit stream using a signaling scheme for signaling the differential quantization to a video decoder.

At a corresponding video decoder reads the adaptively encoded bit stream including the encoded data for the video picture. For example the video decoder reads signaled differential quantization information. At the decoder decodes the compressed bit stream for example dequantizing blocks according to signaled differential quantization information.

As shown in the down sampled luma block the intensity value of a luma sample for a pixel is compared to samples for four pixels near it in the down sampled luma block and an average sum of the difference between the sample for the pixel and the samples for its surrounding vertical and horizontal pixels is computed. In this example the pixel is located at position Y r c . The average sum of the differences for the luma intensity value for this pixel as compared to its surrounding pixels is 1 1 1 1 4 5 

As shown Y r c is the luma component of the pixel at row r and column c in the down sampled block Y . L r c provides an indication of how the pixel differs in luma intensity from its neighbors within the block Y . This luma intensity difference measurement is an example of a pixel gradient.

Optionally chroma data may be considered alone instead of luma data or may be considered together with luma data to determine intensity differences. The average sum of the differences for luma intensity values and chroma intensity values for pixel can be represented as the average of the differences in intensity values of samples for the surrounding pixels as shown in the following equation 

G r c is an example of a pixel gradient for the pixel located at r c in the down sampled block and the pixel gradient provides an indication of how the pixel differs in luma and chroma intensity from its surrounding pixel neighbors. In this example the pixel gradient value G r c is based on pixels that are immediately vertical or horizontal but does not consider other pixels in the neighborhood. It is contemplated that other pixel data may also be considered in creation of a pixel gradient in other variations. For example diagonal pixels could be considered as part of or instead of the provided arrangement. Or intensity differences across a longer stretch e.g. 2 or 3 pixels could be considered.

G r c provides an indication of how a single pixel differs from its neighbors in luma and chroma intensity. In order to characterize the intensity variance for an entire block the same analysis is performed on plural or all pixels within the block. In one such example a block of pixel gradients is created and a block gradient is derived therefrom. As noted computing a pixel gradient or a block gradient may include luma comparisons alone chroma comparisons alone or both luma and chroma comparisons together.

If desirable the above equation for finding G r c may be varied to account for missing block boundary values. For example samples outside the block may be extrapolated or assumed to be the same as other adjacent samples within the block when adapting the equation G r c to account for boundary values. Or the denominator of the equations may be reduced and surrounding samples in certain directions ignored in the comparisons for example where those surrounding samples are outside of the block. As shown a block of pixel gradients may provide pixel gradient data for all pixels in the block. Or a block of pixel gradients may include pixel gradient data for less than all pixels in the block.

A block value may be selected by ordering plural pixel gradients and selecting a median gradient value from the ordered values. For example a set of pixel gradients within a block such as 10 14 28 36 38 has a block value assigned equal to the median pixel gradient in the set or 28. In another example a block value is determined based on the average gradient in the set or 25.2 for the preceding numerical example. Of course the set may be obtained from a complete block gradient or a subset thereof.

Alternatively an encoder uses another characterization framework for example one including other and or additional characterizations for blocks or other portions of video pictures. For different gradients and metrics the framework can change in scale and or number of dimensions.

An encoder can use the characterizations of the blocks or other portions of video pictures when making encoding decisions. Table 2 relates features of an example adaptive coding scheme to block characterizations as described with reference to . As shown differently characterized blocks are treated differently in terms of one or more adaptive features.

The various adaptive features shown in Table 2 are discussed throughout this document and will be further discussed below. Alternatively an encoder uses another mapping of adaptive feature decisions to block characterizations. Moreover some features described herein need not take into account characterizations of video content.

In differential quantization an encoder varies quantization step sizes also referred to herein as quantization parameters or QPs in some implementations for different parts of a picture. Typically this involves varying QPs on a macroblock or other sub picture level. An encoder makes decisions on how to vary the QPs and can signal those decisions as appropriate to a decoder.

Previous encoders have used bi level differential quantization varying between two QPs and multi level differential quantization varying between three or more QPs . For example in one bi level differential quantization approach one QP is used for macroblocks at picture edges and another QP is used for macroblocks in the rest of the picture. This can be useful for saving bits at picture edges where fine detail is less important for maintaining overall visual quality. In a multi level differential quantization approach a larger number of different QPs can be used for individual macroblocks in a picture. For example an encoder can choose a QP for a macroblock and signal a differential between the QP for the current picture and the QP for the macroblock.

Perceptual sensitivity to quantization artifacts is highly related to the texture level of the video in both the spatial and temporal domain. High texture levels often result in masking effects that can hide quality degradation and quantization artifacts. However in regions with lower texture levels e.g. smooth regions degradation and quantization artifacts are more visible. Although previous encoders have made quantization adjustments for some parts of video pictures e.g. picture edges a more comprehensive content based differential quantization strategy as described herein provides improved rate distortion performance in many scenarios.

Accordingly many of the described techniques and tools use texture based differential quantization referred to herein as texture DQ to allocate bits based on various texture levels to achieve better perceptual quality. In texture DQ different QPs are chosen to code video based on texture information and in some cases based on other information such as temporal analysis information. An encoder analyzes texture information and possibly other information and applies texture DQ to appropriate regions texture DQ regions such as 8 8 blocks or macroblocks in a picture. Many of the described techniques and tools focus on smooth regions as potential texture DQ regions. Smooth regions include flat regions areas of constant or nearly constant color and gradient slope regions areas of color that vary at a constant or nearly constant rate across the region . Smooth regions may be considered smooth even when interrupted by small areas of noise film grains or other color variations.

At an encoder obtains texture information e.g. characterizations or block values that indicate whether different regions are smooth edge or texture regions for a current picture. At the encoder finds a texture DQ region e.g. a smooth region in which contouring artifacts may be present or texture DQ regions in the current picture. At the encoder applies texture DQ to the texture DQ region s and encodes the picture. For example smooth regions are coded with smaller QPs than high texture regions. If there are more pictures to encode the encoder takes the next picture at and selectively applies texture DQ to the next picture as appropriate. The encoder outputs encoded data for the video picture for example to storage a communication connection or a buffer.

Different texture DQ region detection techniques can be used to determine whether a region should be treated as a smooth region. For example an encoder can use different texture metrics and or different texture thresholds and can adjust thresholds adaptively to determine whether a particular region should be considered a texture DQ region. Adaptive quantization value mapping can be used to allocate bits for better perceptual video quality. Differential quantization decisions also can be based on temporal analysis i.e. looking at future pictures to make decisions based on characteristics of a region over time .

Differential quantization decisions can be made for both intra pictures and predicted pictures. For predicted pictures P and B picture differential quantization intervals between differentially quantized pictures can be controlled. Further by observing the texture of a picture when dominant high texture areas are present the smooth region texture threshold can be relaxed to code a relatively smooth region compared to the dominant high texture areas with a smaller QP.

Techniques similar to those described with reference to in Section III above can be used to generate a texture map for a current picture. For example the encoder calculates gradients for the texture levels for the picture as the first derivatives differences in the Y U and V channels for the picture as described in section III. When the macroblock format is 4 2 0 to speed up the calculation process the encoder can downsample the Y channel by a factor of 2 1 horizontally and vertically. The encoder sums the gradients of Y U and V for each pixel in both horizontal and vertical direction. For an 8 8 block in full resolution the encoder computes the mean of the sum of the gradients in the corresponding 4 4 block in the downsampled picture to use as the block gradient value. Computing the mean of the gradients has a lower computational complexity than computing the median as described in section III.

Alternatively an encoder obtains texture information for the picture in some other way. For example an encoder chooses different gradient directions for calculating gradients calculates gradients only for the luma channel etc. However the texture information is obtained or calculated it can then be used to make texture DQ decisions.

The texture map indicates the texture levels of the different parts of the picture. For example the texture map can be used to identify smooth regions e.g. blocks macroblocks edges or other areas and textured regions in the picture. Described differential quantization techniques can be performed on appropriate parts of the picture based on the information in the texture map. Alternatively an encoder use texture information without first creating a texture map.

In addition to texture information from a current video picture temporal analysis can be used to make accurate differential quantization decisions. One reason for using temporal analysis is that the impact of using a smaller QP on a smooth region will be greater if the smooth region remains smooth over several pictures especially when the other pictures reference the smooth region in motion compensation. Conversely one benefit of using a smaller QP will be lost if smooth blocks are replaced with high texture or edge blocks in future pictures. Accordingly an encoder looks at future pictures after finding a smooth region in a current picture and makes differential quantization decisions based on how smoothness of the region changes in the future pictures. The encoder can also look at previous pictures for example B pictures that precede a current video picture in display order but reference the current video picture in motion compensation.

At an encoder performs texture analysis on a current block in a current picture in a video sequence. For example the encoder looks at gradient information for the block. The encoder can compare the gradient information to a gradient threshold for the block and classify the block as smooth or non smooth e.g. texture edge where the gradient threshold is fixed or set dynamically for the current picture or other part of the video sequence. Alternatively the encoder performs texture analysis for some other portion in the current picture.

At the encoder performs temporal analysis. The encoder can perform the temporal analysis automatically or only if the current block is classified as a smooth block. For example the encoder determines if a smooth block in a current picture stays smooth in future pictures. If so the smooth region in the current picture is later coded with a smaller QP. Or the encoder determines if a smooth block in the current picture was also smooth in previous pictures or in both previous and future pictures.

The number of previous and or future pictures that the encoder analyzes can vary depending on implementation. If the smooth region is replaced in a future picture e.g. the next picture or some other temporally close picture by a textured region the smooth region in the current picture might be coded with a larger QP since the advantages of using a smaller QP are likely not as persistent. In one implementation temporally closer pictures are weighted more heavily than more distant pictures in making the differential quantization decision. The weighting and the number of previous and or future pictures that the encoder looks at can vary depending on implementation.

To simplify the calculations the encoder can find a single value to compare the current block and the corresponding block in a future picture. For example since luma values are fairly consistent within smooth blocks the mean of the luma values for the block is calculated to measure the similarity of corresponding blocks in future pictures. In the following example equation the strength S t of the future smoothness of corresponding blocks in a future picture is calculated by a sum of the weighted absolute difference between the mean luma values of the current block and the corresponding block in the future picture the mean luma values of the corresponding blocks in the two future pictures and so on.

Referring again to at the encoder uses results of the texture analysis and the temporal analysis to determine whether to classify the block as a texture DQ block. For example the encoder computes a smoothness strength S t for a smooth block but not other blocks and compares the smoothness strength S t to a temporal smoothness threshold. The temporal smoothness threshold can be fixed or dynamically set.

In if the encoder finds that the current block is a smooth block and that the corresponding block in previous and or future pictures is also smooth the encoder adds the current block to a count of texture DQ blocks at . The encoder can use the count of texture DQ blocks to determine whether to perform texture DQ on the picture. Alternatively an encoder uses temporal analysis in some other way to make a texture DQ decision.

If there are more blocks to analyze the encoder takes the next block at and repeats the process shown in . This continues until the encoder has evaluated the blocks of the current video picture. At that point the encoder uses the count of smooth blocks or other results of the temporal analysis in an encoding decision.

Although shows an encoder performing temporal analysis on a block by block alternatively the encoder performs temporal analysis on a macroblock by macroblock basis or some other region by region basis.

Whether or not the encoder uses temporal analysis the encoder can use several other mechanisms in deciding when to apply texture DQ. An encoder can use one or more prevalence thresholds e.g. percentages of smooth blocks in the picture to make decisions on whether to perform DQ and if so how fine the QPs for texture DQ regions should be. For example if the number or percentage of smooth blocks in a picture is above a threshold the encoder can choose a coarser step size in order to avoid spending too many bits encoding smooth content with small QPs. The encoder also may have a lower threshold to determine whether the number or percentage of smooth blocks is enough to use texture DQ in the picture at all.

Another way to reduce bit rate is to treat certain smooth blocks as texture blocks when the smooth blocks are in predominantly textured regions. This can be referred to as isolated smooth block filtering although a smooth block need not be completely isolated to be filtered in this way . For example a smooth block surrounded by textured blocks need not be coded with a smaller QP than the textured blocks since quantization artifacts in the smooth block are likely to be masked by the surrounding textured content. As a result an encoder can choose not to perform texture DQ on isolated smooth blocks. The encoder also can disregard isolated smooth blocks when calculating the number or percentage of smooth blocks in a picture.

At the encoder finds smooth blocks in the current picture. For example the encoder performs texture analysis and temporal analysis as described with reference to . Alternatively the encoder finds the smooth blocks in the current picture in some other way.

At the encoder performs isolated smooth block filtering. For example the encoder removes single smooth blocks that are surrounded in the current picture by non smooth blocks. An encoder can use many different decision models to perform isolated smooth block filtering. For example an encoder can choose to treat a smooth block as a textured block only when all its neighboring blocks are textured blocks. Or an encoder can choose to treat a smooth block as a textured block if a certain number of its neighboring blocks are textured. Or the encoder removes isolated smooth blocks in larger groups e.g. 2 or 3 and or using some other test for whether block s are isolated.

At the encoder checks the percentage of smooth blocks in the picture against a low threshold e.g. 1 2 of the total blocks in the picture . If the percentage of smooth blocks falls below the low threshold the encoder determines that texture DQ will not be used for this picture . If the percentage of smooth blocks is above the low threshold the encoder checks the percentage against a high threshold at . This higher threshold is used to pick a QP for the smooth blocks. If the percentage is higher than the high threshold the encoder performs texture DQ but chooses a coarser QP for the smooth blocks to reduce bit rate. Otherwise the encoder chooses a finer QP for the smooth blocks. If there are more pictures to analyze the encoder can repeat the process for other pictures. The number of thresholds and the threshold percentage values can vary depending on implementation.

Alternatively an encoder performs isolated smooth block filtering without using texture DQ thresholds or uses texture DQ thresholds without isolated smooth block filtering. Or an encoder performs texture DQ without isolated smooth block filtering or using DQ thresholds.

An encoder can use a fixed texture level or smoothness threshold to determine whether a given block should be considered a texture DQ block e.g. a smooth block . Taking into account the bit rate cost of DQ signaling e.g. one bit per macroblock in an all macroblock bi level DQ signaling scenario and the bit rate cost of quantizing some parts of a picture at a smaller QP the threshold acts as a check on the costs of texture DQ. For example an encoder obtains a block value using a technique described with reference to or some other technique for a block and compares the block value to a fixed texture level smoothness threshold value e.g. a threshold value described with reference to .

An encoder also can adaptively change texture level smoothness threshold values. For example since the perceptibility of smooth blocks may change in pictures with a lot of high texture content the texture level threshold for classifying a block as a smooth block can be relaxed in a medium texture or high texture picture. This is an example of an adaptive texture level threshold. An encoder may allow several different thresholds to be selected within a range of thresholds. In one implementation an adaptive texture level threshold for smooth blocks can be varied between a block value of 14 and a block value of 30. Different differential quantization mappings can be used for different texture level thresholds. An adaptive texture level threshold can be useful for allocating bits to smoother regions in higher texture frames to improve quality in the smoother regions.

Referring to an encoder obtains a texture information e.g. a texture level histogram for a picture at in an adaptive texture level threshold technique . For example the encoder obtains a texture map as described above and creates a texture level histogram from the information.

At the encoder checks whether the picture is a high texture picture. If the picture is a high texture picture the encoder adjusts the texture level threshold for the picture at . If the picture is not a high texture picture the encoder processes the picture without adjusting the texture level threshold . The encoder then can analyze and choose texture level thresholds for other pictures . Alternatively the encoder applies a sliding scale of different texture level thresholds for different levels of high texture content in the picture.

For example to check the extent of dominant high texture content in a picture an encoder computes a texture histogram for the picture. The encoder applies a sliding window in the texture histogram to calculate texture energy and determine a peak or prominent high texture band. Equation 8 shows one way for the encoder to calculate the texture energy in the window. The sliding window starts sliding from the minimum texture level threshold g which is by default 30 and the encoder computes the window value W g at g. The sliding window shifts 1 to the right after calculation of texture energy for that window and the encoder computes the next window value W g starting at the new value of g. This continues until the encoder reaches the maximum of the texture levels represented in the histogram.

Let F g be the histogram of texture level per pixel. Let E g be the texture energy for the texture level where E g F g g. The encoder calculates the texture energy of the sliding window W g as follows 

If the maximum sliding window energy W g exceeds a certain percentage threshold of overall picture energy g for that maximum sliding window energy W g is used to adjust the threshold for smooth regions.

Alternatively an encoder adaptively adjusts texture level thresholds in some other way e.g. with a different texture strength or energy metric without a sliding window with a differently configured sliding window with different threshold values in a table or other data structure without capping differences between adaptive thresholds capping differences in adaptive thresholds in some other way etc. .

Described differential quantization techniques and tools can be used separately or in combination on intra pictures and predicted pictures. The term I picture differential quantization I picture DQ refers to application of differential quantization to I pictures and the term P picture differential quantization P picture DQ refers to application of differential quantization to P pictures. The use of I picture DQ results in higher quality I pictures and the quality improvement can be maintained longer for predicted pictures that depend from those I pictures. P picture DQ can further improve P picture quality in both intra and inter blocks but the quality of those P pictures will also depend on the quality of the pictures from which they are predicted. Similarly the impact of P picture DQ on the quality of later predicted pictures will depend the similarity of the later predicted pictures to the pictures from which they are predicted.

Both I picture DQ and P picture DQ use one or more of the techniques described herein to decide whether to apply different QPs for different texture level blocks. To balance quality and bit usage a P picture DQ interval can be used to control the amount of bits that are spent on P picture DQ. For example an encoder chooses to use P picture DQ on one in every n P pictures where n 1 but skips P picture DQ for pictures in the interval between differentially quantized P pictures. The encoder spends bits on differential quantization to improve the perceptual quality of some P pictures and those quality improvements carry over into other predicted pictures. At the same time the DQ interval helps constrain the overall number of bits the encoder spends on differential quantization of predicted pictures.

Alternatively the encoder selects another interval. For example the encoder may choose to use P picture DQ on only one P picture per I picture or choose some other interval. The interval may be fixed or adaptive. For example the encoder may adaptively adjust the P picture DQ interval based on the type of content being encoded.

Among various visual artifacts introduced in video compression contouring is one particular artifact that can be caused by quantization. Contouring artifacts are perceived by human eyes as structured gradient discontinuities in what are otherwise continuous very smooth regions such as sky water etc. Such discontinuities can be very distracting and may lead a human observer to conclude that a whole picture is badly distorted even if other parts of the picture are coded with little visual distortion.

Gradient slope regions can give rise to contouring artifacts. According to one definition a region is considered to be a gradient slope region if the region is smooth or relatively smooth but pixel values change gradually within the region. Thus while both gradient slope regions and flat regions are considered to be smooth regions gradient slope regions differ from flat regions. According to one definition a flat region is characterized by constant or relatively constant pixel values throughout the flat region. Gradient slope regions typically lack strong edges and extensive texture detail.

Many existing video encoders use techniques that are applied to a whole video picture in an attempt to reduce contouring artifacts in the picture. Such techniques may result in over spending bits especially in regions that contain little or no contouring artifacts. Accordingly several described techniques and tools allow an encoder to detect gradient slope regions where contouring artifacts are likely to happen. When gradient slope regions are detected an encoder can make coding decisions that reduce or avoid introduction of contouring artifacts e.g. adjustments of QPs in the gradient slope regions. By doing so an encoder can allocate bits more effectively and achieve better visual quality.

At an encoder checks whether a current region is a smooth region. For example the encoder uses a texture map of the picture in which an 8 8 block is characterized as smooth if its assigned block gradient value is less than 30 or the encoder uses checks whether the current region is smooth using another technique described in section III or IV. When a region includes multiple blocks the region is considered to be a smooth region if all blocks contained in the region are smooth or alternatively if some minimum number of the blocks are smooth . Different implementations can use different criteria for determining whether a particular region or block is smooth. For example the criteria for determining whether a region is smooth may be different if the picture is down sampled.

If a region is not smooth the next region is processed . For a smooth region the encoder finds a gradient direction at . For example the encoder finds a gradient direction using a technique such as the one described with reference to . Alternatively the encoder finds the gradient direction with some other technique.

At the encoder makes a gradient slope decision for the region using thresholds and or decision making logic that depend on the technique and metrics used to find the gradient direction for the region. If there are more regions to be processed the encoder processes the next region . In one implementation after computing initial gradient directions for different regions in a picture the encoder generates a binary mask that indicates whether gradient slope is present in different regions by applying a sliding window in the picture. The information in the binary mask allows the encoder to make accurate gradient slope decisions.

Depending on picture size and potentially other factors the GSR detector determines whether to perform down sampling in down sampling module . Example down sampling techniques are described below.

The gradient calculator takes possibly down sampled pixel data and a texture map as input and calculates gradients for smooth regions. For example the gradient calculator uses a technique such as the one described with reference to or uses some other technique. An example region size in the gradient calculation is 16 16 but the size of regions can vary depending on implementation. Depending on whether and how much down sampling is applied the region for which a gradient is calculated can represent different amounts of area in the original picture . The gradient calculator outputs a map or other data structure indicating the gradient directions for smooth regions.

The consistency checker takes the calculated gradients for smooth regions and checks the angular consistency of those gradients for example as described below. The consistency checker produces a consistency map or other data structure indicating consistency information for the calculated gradients.

The decision module uses additional decision rules after consistency checking to determine whether smooth regions should be considered gradient slope regions. Example decision rules and criteria are described below. The decision module considers the consistency map or other data structure indicating consistency information and can also consider the calculated gradient directions or other information. The decision module outputs decision information in a map or other data structure for regions of the same or different size than the region size used in the gradient calculation.

The decision for each region is provided to mask generator which produces a gradient slope mask and or a binary gradient slope decision mask that indicates gradient slope decisions for regions in the picture. For example a mask comprises a bit equal to 1 for each gradient slope region and a bit equal to 0 for other regions. Accepting calculated gradients as input the mask generator can produce another mask that indicates final gradient slopes for different regions of the original picture accounting for down sampling and mask decisions. When the GSR detector performs down sampling before gradient calculation the mask generator can assign gradient slopes for down sampled regions to corresponding regions of the original picture.

The components of the GSR detector are shown as separate modules in but the functions of these components can be rearranged combined or split into different modules depending on implementation. Furthermore components of gradient slop detector can be omitted in other implementations. For example down sampling is not required. A GSR detector need not take a texture map as input and can instead get an indication of whether a region is smooth or not from some other source. A GSR detector need not use a consistency checker. Although a GSR detector will make some kind of decision as to whether a region is a gradient slope region the specifics of how decisions are made including decision rules in the decision module can vary depending implementation. Gradient slope decisions need not be included in a binary mask and may be communicated to other parts of the encoder in some other way.

Down sampling can be used prior to finding gradient directions for regions in order to reduce computational cost. In one implementation if the original picture width is greater than 1280 and the height is greater than 720 the original picture is 4 to 1 down sampled. For example in a 1080p arrangement with a picture width of 1920 pixels and a picture height of 1080 pixels a decoder produces a down sampled picture with a width of 480 pixels and a height of 270 pixels.

Typically a down sampled picture is divided into non overlapping rectangular regions of the same size. For example after downsampling each 16 16 region corresponds to 4 macroblocks 16 blocks of the original full resolution picture. A region in the down sampled picture is considered to be a smooth region if at least 12 blocks to which the region corresponds are smooth. Region sizes depend on implementation and the relation between regions in gradient estimation and regions in original pictures varies depending on down sampling ratio.

Down sampling also is useful for improving accuracy of gradient slope region detection despite the presence of anomalies such as film grains. For example consider a portion of a picture with DC values of blocks as shown in . The majority of the picture portion has consistent gradient slope directions as shown by the gradually increasing DC values from the top to the bottom of the picture portion. However the white sample values represent DC values affected by film grains that create anomalous gradient slope directions at full resolution. With simple 2 to 1 down sampling horizontally and vertically the dark bordered sample values are used to calculate the gradient slope direction. Because the down sampled values maintain a consistent gradient slope the film grains do not affect detection of the gradient slope.

Down sampling can be used for other picture resolutions and other down sampling ratios also can be used.

In one implementation to calculate gradient slope direction for a smooth region two 16 16 compass operators Kand K defined in are applied to the region. This produces two gradients g gfor the region one for the horizontal direction and one for the vertical direction. For a 16 16 region the compass operators give positive weights to some values of the region and negative weight to other values of the region. Alternatively the compass operators compute gradients in some other way.

An angular representation of the gradient direction denoted as is derived from the two gradients and mapped to an integer in 0 255 . The pseudo code in shows an example routing for computing the gradient direction for a region z denotes a per element product using the compass operators of . If the region is a textured region or edge region the routine returns 2. If the region is smooth but flat indicated by low absolute values for the gradients gand gfor the region the routine returns 1. Otherwise the routine computes the gradient slope as the arctangent of the vertical gradient gover the horizontal gradient g using offsets to differentiate between slope directions for same arctangent values e.g. whether a positive arctangent value indicates an above right slope or a below left slope and represent the range of slope values as positive numbers.

Alternatively the gradient direction is computed in some other way. For example the encoder uses different compass operators different thresholds for slope regions different logic to compute the slope and or a different representation for slope information.

An encoder can perform a gradient consistency check for regions in order to help make an accurate decision about whether a region should be considered a gradient slope region. The gradient consistency check helps to avoid false alarms in gradient slope content detection. In one implementation the gradient slope consistency check involves using a 3 3 sliding window three regions by three regions to determine gradient slope consistency.

At the encoder positions a sliding window at a current region in the picture. At the encoder checks the gradient directions of regions in the sliding window. Then at the encoder makes a consistency decision for the current region. For example given the gradient directions of detected smooth regions in a picture potentially down sampled a gradient consistency check is performed with the sliding window containing 3 3 neighboring regions. The window is moved in raster scan order positioning the window on a region in the picture e.g. by centering the window on the region performing the consistency check then moving the window from left to right across the picture . For a given window value the consistency check requires the difference between the maximum and the minimum gradientDirection see e.g. of all 9 regions within the window to be less than 32 equivalent to 45 degrees when slopes are represented by numbers from 0 to 255 . If this condition is satisfied the moving window value for the 3 3 set of regions is 1 otherwise it is 0. Alternatively the encoder uses a different mechanism to check consistency of slope directions for example using a different size sliding window different slope range threshold for maximum slope minimum slope different measure such as variance for slope consistency and or different checking pattern or computes a sliding window value for each region as opposed to sets of regions. The consistency check varies for different representations of slope information.

The encoder can then process the next set of regions . As output the encoder produces a mask or other data structure indicating decision information. For example the encoder produces a binary consistency mask referred to herein as consistencyMask obtained by positioning the sliding window and performing the consistency check on sets of regions in the picture and assigning each set of regions a decision of 1 consistent slope or 0.

Optionally the encoder performs further processing on the decision information. In some implementations an encoder performs morphological operations on a consistency mask to help refine gradient consistency decisions for a picture. Two possible morphological operations are Erode and Dilate.

For example an Erode operation is performed on every bit in the consistencyMask followed by a Dilate operation. In the Erode operation a bit initially marked as 1 is marked as 0 if in the four closest pixels here values in the consistencyMask more than one was initially marked as 0. In the Dilate operation a bit initially marked as 0 is marked 1 if in the four closest pixels more than one were initially marked as 1.

Alternatively an encoder generates masks without using morphological operations or other post processing of the decision information.

Even after performing consistency checking the incidence of smooth regions may be so low or the smooth regions may be so isolated that they would be inefficient to encode specially. For example even after applying morphological operations there may still be gradient slope regions represented in consistencyMask that are isolated enough to not need differential quantization. In some implementations an encoder uses decision rules including for example bucket voting to help decide whether DQ should be applied to gradient slope regions in the picture. In the GSR detector of decision module makes such decisions.

In one implementation the encoder makes one or more binary decisions regarding whether the current picture contains significant gradient slope based on consistencyMask. The mask consistencyMask is divided into 25 rectangular regions of the same size called buckets with 5 buckets in each row and 5 in each column. The bucket regions are hence larger than the regions used for decisions and regions used for gradient calculations. The 1s within each bucket are counted. Let Buckets i j be the number of 1s contained in the bucket at location i j where 0 i j 4. Horizontal and vertical bucket projections the number of 1s in each column of buckets and the number of 1s in each row of buckets respectively also are calculated according to the following relationship 

In this implementation the picture is considered to contain significant gradient slope if any of the following conditions are satisfied 

For example 16 16 regions for a down sampled picture of size 960 1440 are represented with a mask of size 20 30 each value for a 3 3 set of regions of the down sampled picture which is in turn divided into 25 buckets each bucket corresponding to a 24 regions of the consistency mask. Each bucket includes 24 bits from consistencyMask for a total of 25 24 600 bits. The encoder counts the number of 1s in each bucket with a distribution as shown in . The encoder checks whether the total number of 1s is more than 6 of all bits. In this case the total number of 1s as shown in is 83 which is more than 6 of all bits. Thus the encoder in the case would skip bucket projection due to satisfaction of condition 1 above. If the total number of 1s were below the threshold for condition 1 the encoder would whether 75 of the bits in any bucket were 1s condition 2 and if necessary check horizontal and vertical bucket projections condition 3 to determine whether the regions indicated as being gradient slope regions are such that a gradient slope mask and decision mask should be generated such as the macroblock level gradient slope masks described below.

Alternatively an encoder uses other decision rules for processing consistency information in a mask consistencyMask or other representation. For example the percentage thresholds shown in conditions 1 2 and 3 can vary depending on implementation. Or one or more of the conditions is omitted or the conditions are reordered replaced or supplemented by other conditions e.g. different directions for bucket projections etc. . Aside from checking consistency information the encoder can also consider gradient values and or other information when deciding whether or how much DQ should be applied to gradient slope regions in the picture. As another alternative an encoder can omit these decision rules altogether and simply use the consistencyMask when generating a gradient slope mask.

To provide gradient slope information in a form useful for later encoder decision making the encoder puts the information in maps masks or other data structures. The information can include gradient slope region presence absence information as well as actual gradient direction values for gradient slope regions.

For gradient slope presence absence information if gradient slope regions are detected the encoder produces a gradient slope mask. For example an encoder produces a macroblock level gradient slope mask referred to herein as MBSlopeMask by converting a region level mask such as consistencyMask back to macroblock level for the original picture considering possible down sampling. Note that each value in consistencyMask corresponds to 9 macroblocks in the original picture or 36 macroblocks if the picture is 4 to 1 down sampled. For each bit with value 1 in consistencyMask the encoder marks corresponding macroblocks as 1 in MBSlopeMask except for macroblock that are not smooth. Checking for smoothness again helps to avoid false alarms in gradient slope detection. For example in one implementation an encoder uses a texture map to obtain texture information for blocks in a macroblock and the macroblock is considered smooth only if all four blocks within the macroblock are smooth.

Alternatively the encoder provides gradient decision information in some other form and or uses some other decision for macroblock smoothness.

For gradient direction information a gradient direction map is generated by assigning each region s gradient direction to all its corresponding macroblocks that are smooth. In doing so the encoder accounts for possible size differences between macroblocks of the original picture and gradient regions due to down sampling before gradient calculation.

The generated gradient slope mask and gradient direction map are then used in the encoder to make better coding decisions. Generally speaking the results generated by a gradient slope region detector can be used by an encoder to make other coding decisions. For example an encoder can make quantization decisions based on a generated gradient slope mask and or gradient direction map. Some of the possible encoder decisions are described below.

Typically a picture is assigned a picture level quantization parameter by a rate control unit in an encoder. Using the same picture level QP the amount of bits used to represent a highly textured macroblock is typically much greater as much as 10 to 50 times greater than the amount of bits used to represent a low textured macroblock. Since the human visual system is less sensitive to distortion in a busy highly textured area than in a smooth low textured area however it makes sense to use a smaller QP for low textured macroblocks and a larger QP for highly textured macroblocks.

This leads to the often used strategy of classifying macroblocks according to human visual importance usually using variance of the blocks or the strength of the gradients inside the blocks and assigning a target number of bits proportional to some perceptual weighting. The quantization parameter for each macroblock to be modified is selected by modifying the picture level quantizer according to the weighting.

Experiments have shown that in smooth regions of very low variation blocks are often quantized to have energy only in DC coefficients with no non zero AC coefficients remaining even at a reasonably low QP. Surprisingly when DC values in adjacent blocks in extremely smooth regions vary by only 1 from block to block the perceived blocky contouring artifact are a lot more severe than one would expect with such a small difference in absolute terms. The occurrence of this type of artifact in relatively small regions inside an otherwise well coded picture can cause the overall perceived quality for the entire picture to be lowered.

Traditional rate distortion based and perceptual based macroblock QP selection techniques do not handle this situation well. With rate distortion optimization the smooth blocks would be considered well coded because of the small distortion in absolute terms and thus no further bits would be spent for these blocks. On the other hand typical perceptual based methods classify macroblocks into perceptual classes and assign a quantization parameter to each macroblock by adding or subtracting a pre defined offset to the picture level quantization parameter according to the perceptual class of the macroblock. Unless the pre defined offset is very aggressive e.g. reducing QP for smooth regions to 1 such methods cannot guarantee that smooth blocks with small variations will not be quantized to a single non zero DC coefficient with all AC coefficients quantized to zero. But setting a very aggressive offset can increase bits spent in macroblocks that may not need them to improve perceptual quality raising bit rate inefficiently and conflicting with the picture level quantization parameter selected by the encoder for rate control.

Accordingly several techniques and tools described below selectively and judiciously allocate bits within pictures such that enough bits are allocated to smooth regions to reduce or remove introduction of blocking or contour artifacts.

For example an encoder calculates QPs and selects a quantization parameter for each macroblock within an I picture to allocate enough bits to smooth blocks thereby reducing perceived blocking artifacts in the I picture. For each macroblock with one or more smooth blocks a QP is selected such that there are at least N non zero quantized AC coefficients per block of the macroblock where N is an integer greater than or equal to 1. Often the preserved AC coefficients are coefficients for the lowest frequency AC basis functions of the transform which characterize gradual value changes horizontally and or vertically across a block. This tends to help perceived visual quality for each block especially for smooth regions with low variation. In one implementation an encoder selects the largest QP not exceeding the picture QP that still preserves AC coefficients as desired. There may be situations e.g. very flat blocks that non zero AC coefficients are not preserved. In general however in this way the encoder is not overly aggressive in spending bits with smaller QPs and reduces or avoids conflict with the picture QP.

With reasonable values of N the selected QP does not change for most macroblocks it is the same as the picture QP for most macroblocks and only a few smooth blocks are affected. Reasonable values of N are 1 2 3 or 4. The selected QP is more likely to change for macroblocks with low texture. In one implementation N 1 or 2 improves perceived quality without too much increase in the picture s bit rate.

At the encoder finds the Nlargest AC coefficients of each luma block of the macroblock. For example the encoder finds the second largest AC coefficient of each of the four 8 8 blocks of a 16 16 macroblock if N 2. Let AC AC AC AC be the Nlargest coefficients for the four luma blocks and respectively. For different block organizations in a macroblock the Ncoefficients can come from more or fewer blocks in the macroblock.

At the encoder finds the minimum of these Ncoefficient values. For the Ncoefficients of four blocks AC min AC AC AC AC . For other numbers of blocks ACis computed differently.

At the encoder sets a QP for the macroblock such that ACis outside the dead zone threshold for that QP. The dead zone threshold is a cut off threshold for quantizing an AC coefficient to zero when the value of QP is used for quantization. The dead zone threshold is usually predetermined for and proportional to a given QP. The dead zone threshold is selected at some point between 0 and the first reconstruction point. When the encoder uses either a uniform quantizer or non uniform quantizer the first reconstruction point depends on the QP value and whether uniform or non uniform quantization is used. In one implementation the first reconstruction point is the reconstructed value of quantized coefficient level 1 which for uniform quantization is 2 QP and for non uniform quantization is 3 QP. For uniform quantization the cut off threshold thus lies between 0 and 2 QP. For non uniform quantization the cut off threshold thus lies between 0 and 3 QP. For example the dead zone threshold Z QP is selected as Z QP 6 QP 5 for uniform quantization and Z QP 2 QP for non uniform quantization. Alternatively other cut off thresholds can be used.

An AC coefficient AC will be quantized to zero if Abs AC Z QP is satisfied. If the inequality Abs AC Z QP is satisfied the encoder sets the threshold QP for the macroblock to be the first QP i.e. highest qualifying QP that satisfies the inequality. Alternatively the encoder uses other logic to compute the QP for the macroblock for example starting from the lowest QP or using a binary search of QP values.

The process of using QPto quantize all blocks in the macroblock can be referred to as unconstrained bit rate quantization. In a constrained bit rate quantization technique an encoder determines the maximum QP not greater than the picture QP needed to produce the desired number of non zero AC coefficients for each of the luma blocks of the macroblock separately e.g. QP QP QP and QPfor blocks and respectively as described above. It follows that QPequals the minimum of QP QP QP and QP. To reduce bit usage an encoder could use QPto quantize block i where i 0 1 2 3 etc. in place of QP. In an encoder that specifies a single QP for an entire macroblock the encoder can instead keep only those AC coefficients that are non zero when quantized using QPfor each block i when quantizing the block using QP preserving only the top N non zero AC coefficients in a given block even if other AC coefficients in the block would be preserved with quantization by QP. For the quantization process shown in the quantization process for each luma block can be performed as a two pass process. In the first pass the encoder thresholds DCT coefficients to zero if the coefficient is less than Z QP and otherwise keeps the same DCT coefficients. Then the thresholded DCT coefficients are quantized in the same manner using QP.

Alternatively an encoder preserves non zero AC coefficients in some other way. For example an encoder can select a QP on a basis other than a macroblock by macroblock basis e.g. block by block basis . The encoder can preserve AC coefficient for I pictures P pictures or B pictures or combinations thereof.

If at the minimum possible QP the number of non zero quantized coefficients is less than N N can be adjusted accordingly.

In a typical lossy encoding scenario not all quantized DC and AC coefficients can be recovered exactly after inverse quantization. For example in some video codecs DC coefficient values shift by one i.e. increase or decrease by one relative to their pre quantization value for some QPs and DC coefficient values. This phenomenon is an example of DC shift. Representations of some DC coefficient values are lossless through quantization and inverse quantization at one or more lower QPs but lossy in other higher QPs.

A region with several blocks in which all the AC coefficients are quantized to 0 and the DC coefficients cannot be recovered exactly can exhibit visible contouring artifacts in DC shift areas. Such regions with contouring artifacts are often smooth gradient slope regions such as sky water or light rays. is a diagram showing a DC shift in three neighboring blocks in a gradient slope region after quantization and inverse quantization. The DC values of three neighboring blocks in a gradient slope region are 68 69 and 70 respectively prior to quantization. After quantization and inverse quantization the DC value of block is shifted to 70. As shown in the DC values of the three neighboring blocks are now 68 70 and 70. When such blocks are in a gradient slope region the quantized DC values may cause perceptible contouring artifacts. For example referring again to the gradient slope region has been quantized resulting in a visible contouring artifact in . As shown in quantization of the DC coefficients for the top half blocks of macroblock results in uniform values reconstructed from a DC value of 68 while quantization of DC coefficients for the bottom half blocks results in uniform values reconstructed from a DC value of 70.

Accordingly several techniques and tools described below are used by a video encoder to detect DC shift areas and adjust quantization to reduce or avoid introduction of contouring artifacts in the DC shift areas.

At an encoder detects a shift area. The search for DC shift areas can be aided by previous gradient slope detection. For example the encoder detects DC shift areas by detecting one or more gradient slope regions or using previously computed gradient slope detection information then identifying DC shift blocks in the gradient slope region s as described below.

At the encoder adjusts quantization in the DC shift area. For example an encoder can use differential quantization DQ to code DC shift blocks in order to reduce or avoid introduction of contouring artifacts caused by DC shift. The encoder reduces QP for some macroblocks those with DC shift blocks but does not change QP for other blocks. Reducing QP for macroblocks having DC shift blocks can help keep DC values lossless for the macroblocks thereby reducing or avoiding introduction of contouring artifacts. An encoder can use bi level DQ or multi level DQ to resolve DC shift problems and thereby improve visual quality while controlling bit usage. If there are more pictures to analyze the encoder processes the next picture .

Alternatively the encoder adjusts quantization for DC shift areas on a macroblock by macroblock basis or some other basis.

Gradient slope detection can be used to identify one or more gradient slope regions in a picture. The gradient slope region s tend to exhibit contouring artifacts especially when blocks in the region s have non zero DC coefficient values and AC coefficients of only zero after quantization. Once found such region s can be checked for DC shift blocks that may contribute to contouring artifacts.

For example an encoder finds a gradient slope region using a technique described herein Section V or some other technique. If the only non zero coefficients in blocks are DC coefficients after quantization the encoder treats the blocks as candidates for DC shift area adjustment. Alternatively the encoder considers additional blocks as candidates for DC shift area adjustment.

The encoder identifies certain candidate blocks as DC shift blocks. The identification of DC shift blocks depends on details of the quantizer and QPs used to compress the blocks. For example some reconstructed DC coefficients will not shift from their original value at one QP but will shift at a coarser QP.

Examples of DC shift coefficients for different QPs in one encoder are provided in the following table. The table indicates DC coefficient values exhibiting DC shift for different values are QP is derived explicitly from the parameter PQIndex and potentially a half step parameter or implicitly from the parameter PQIndex and potentially a half step parameter . DC values not listed in the table are lossless for the indicated QP in the example encoder DC values for QPs under 3 which are not shown in the table are all lossless. The example encoder does not perform DC shift adjustment for QPs higher than those shown in the table. In the example encoder quantization of DC coefficient is the same for different quantizers e.g. uniform non uniform . Which DC coefficient values are DC shift coefficients will differ in different video codecs. Different quantizers e.g. uniform non uniform can result in different shift patterns if quantization of DZ coefficients is different in the different quantizers.

The example encoder with the DC shift coefficients shown in Table 3 generally uses different QPs for textured regions than for smooth regions. The example encoder typically uses a QP in the range of 3 5 to encode smooth regions. As shown in Table 3 above for QP 3 5 all the shifted DC values are 1 more than the original DC value. Other encoders may use different QPs for smooth regions versus texture regions.

To help reduce or avoid introduction of contouring artifacts when DC shift blocks are detected the sample encoder changes the QP for macroblocks containing DC shift blocks to keep the DC values lossless in those macroblocks. In particular the example encoder reduces the QP for macroblocks containing DC shift blocks to QP 2. Other encoders may use some other QP for DC shift areas. In general an encoder can select the largest available QP that results in lossless treatment of the DC coefficients of the blocks of the macroblock.

An encoder calculates a mean luma value per block to determine DC shift blocks in the gradient slope region s since the mean luma value corresponds to the DC shift value after compensating for expansion in the transform . The mean luma value allows the encoder to estimate or predict which blocks have DC shifts. Alternatively an encoder calculates real DC values and looks them up in the DC shift table to identify exactly which blocks will have shifts.

The encoder can perform additional processing to exclude certain isolated DC shift blocks in the gradient slope region s . In the example encoder once a current block is identified as a DC shift block located in a gradient slope region the surrounding four neighboring blocks are checked. If any of the surrounding four neighboring blocks is a smooth block and has a DC value lower than the shifted DC value of the current block the encoder uses QP 2 to for the macroblock containing the current block in order to keep the DC values lossless. Alternatively an encoder does not do a check of neighboring blocks or checks some other arrangement of neighboring blocks to determine whether to make a change in the QP for the DC shift area.

Bi level DQ and multi level DQ typically have different bit rate costs. In one implementation 1 bit per macroblock is used to signal a picture QP or alternative QP in all macroblock bi level DQ and at least 3 bits per macroblock are used to signal a picture QP or alternative QPs in multi level DQ.

Although an encoder can use multi level DQ to allow for reducing QP in a smooth region that contains DC shift blocks an encoder instead can choose to adjust the QP for all smooth regions e.g. to QP 2 and use a coarser picture QP for the rest of the picture in a bi level DQ scenario. For example an encoder may do this where the signaling costs of multi level DQ are found to be too expensive relative to the costs of bi level DQ.

In one implementation the following table is used to calculate the cost of smooth blocks that going from QP 3 4 5 and 6 respectively to QP 2.  iSmoothBlockDiffQPCost 4 18 22 28 36.

This table is used in the following example of bi level DQ cost B QP cost calculation. counts of total counts of biLevel Dquan counts of Shift Blocks  iSmoothBlockDiffQPCost 3 

The cost B QP accounts for the costs of per macroblock bi level cost signaling and estimates the increased bit cost of using QP 2 instead of a 3 4 5 or 6 for a block. Multi level DQ cost M QP is calculated as counts of frameQP3 counts of biLeveL Dquan of Shift Blocks 8 counts of Shift Blocks 3 The cost M QP accounts for signaling costs of multi level DQ assuming escape coding for some macroblock quantization parameters. If B qp 

Alternatively an encoder uses other costs models for different types or configurations of DQ. Or an encoder reduces QP for the entire picture when DC shift blocks are detected or uses some other technique to change quantization to reduce or avoid introduction contouring artifacts when DC shift blocks are detected.

In one example encoder multi level DQ requires 3 bits to signal any QP from picture QP to picture QP 6. Any QP outside of this range will be signaled with 8 bits through escape coding. Alternative QPs that are used for smooth regions are normally smaller than the picture QP and hence require escape coding.

Switching picture QPs can thus save coding overhead for multi level DQ. For example an encoder can choose a picture QP using the multi level DQ cost model described above. For example for a three level scenario e.g. a picture QP a smooth region QP and a DC shift QP multi level DQ cost is computed for different candidate values for a picture QP. An encoder can select the picture QP with minimum overhead cost.

Alternatively an encoder uses other criteria to switch picture QPs or does not perform picture QP switching.

If a decision is made to use multi level DQ coarse quantization can be used for high texture macroblocks by assigning them a higher coarser QP than the picture QP. The decision to use multi level DQ for the picture e.g. in order to use smaller QP for DC shift macroblocks means there is no additional overhead cost to signal a per macroblock coarse QP that is higher than the picture QP. For example picture QP 1 can used as the coarse QP to avoid noticeable differences in the quantization level or some other QP can be used. A texture threshold can be used to determine which macroblocks will be quantized with the coarse QP after the encoder has decided to use multi level DQ for the current picture.

Alternatively an encoder uses other criteria to determine whether certain regions e.g. macroblocks should use a coarse QP or does not use coarse QPs.

At an encoder detects one or more gradient slope regions in a current picture for example as described in Section V. At the encoder detects DC shift blocks in the gradient slope region s for example using a DC shift table.

The encoder then decides how to quantize the picture. At the encoder decides whether to use bi level DQ for the picture. If it does the encoder uses a QP smaller than the picture QP for DC shift areas and other smooth areas. Otherwise at the encoder decides whether to use multi level DQ for the picture. If it does the encoder uses a QP smaller than the picture QP for DC shift areas can use a different QP for other smooth areas and if high texture macroblocks are present uses a coarse QP such as one that is larger than the picture QP for the high texture macroblocks . If the encoder does not choose bi level or multi level DQ the encoder reduces the picture QP and uses the reduced picture QP for DC shift areas as well as other areas. Or the encoder skips QP reduction for the DC shift areas if the costs of bi level DQ and multi level DQ are both too high. When the encoder has chosen a quantization scheme the encoder compress the picture at and process the next picture if any pictures remain to be processed .

Having described and illustrated the principles of our invention with reference to various embodiments it will be recognized that the various embodiments can be modified in arrangement and detail without departing from such principles. It should be understood that the programs processes or methods described herein are not related or limited to any particular type of computing environment unless indicated otherwise. Various types of general purpose or specialized computing environments may be used with or perform operations in accordance with the teachings described herein. Elements of embodiments shown in software may be implemented in hardware and vice versa.

In view of the many possible embodiments to which the principles of our invention may be applied we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto.

