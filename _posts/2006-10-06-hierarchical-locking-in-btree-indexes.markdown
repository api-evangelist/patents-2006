---

title: Hierarchical locking in B-tree indexes
abstract: Portions of a B-tree index in a database are locked for concurrency control. In one example, hierarchical lock modes are provided that permit locking a key, a gap between the key and the next key, and a combination of the key and the gap. In another example, key range locking may be applied to the B-tree index using locks on separator keys of index nodes. In another example, key range locking may be applied to the B-tree index using locks on key prefixes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07577658&OS=07577658&RS=07577658
owner: Microsoft Corporation
number: 07577658
owner_city: Redmond
owner_country: US
publication_date: 20061006
---
Database systems use locks to maintain the consistency of databases when multiple users are accessing the same data at the same time. Before a transaction acquires dependency on the current state of a piece of data such as by reading or modifying the data the transaction must protect itself from the effects of another transaction modifying the same data. The transaction may request a lock on the data. The transaction holds the lock protecting the modification until the end of the transaction. Locks held by a transaction are released when the transaction completes either commits or rollbacks .

Hierarchical locking is widely used in database indexes. Hierarchical locking lets large transactions take large and thus few locks and lets many small transactions proceed concurrently by taking small locks. The standard lock hierarchy for B tree indexes starts by locking the table or view then may lock the index or an index partition and finally may lock a leaf page or individual key.

With the advent of disk drives approaching 1 Terabyte as well as very large databases and indexes traditional hierarchical locking schemes begin to show flaws. For example the current step from locking an index to locking its individual leaf pages or keys might prove too large. There may be millions of leaf pages and billions of keys in an index. Thus if a lock on an entire index is too large and too restrictive for other transactions thousands and maybe millions of individual locks are required. Conversely if a transaction already holds 10 000 locks and then escalates to an index lock to save on computing resources this index lock might inhibit hundreds of concurrent transactions. Current hierarchical locking schemes create a dilemma between locking an entire index and locking millions of individual leaf pages or keys.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

Embodiments herein provide hierarchical locking techniques for B tree indexes. In one embodiment hierarchical lock modes are provided that permit locking a key a gap between the key and the next key and a combination of the key and the gap. In another embodiment key range locking is performed via separator keys. In yet another embodiment locks on key prefixes are used to provide key range locking.

Many of the attendant features will be more readily appreciated as the same become better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present examples may be constructed or utilized. The description sets forth the functions of the examples and the sequence of steps for constructing and operating the examples. However the same or equivalent functions and sequences may be accomplished by different examples.

Operating environment includes a network . Network may include an internet an intranet and the like. A server may communicate with computing devices and over network . An example computing device is described below in connection with . Computing devices include client devices and or servers that may access data in the database hosted by server .

Server may include a server operating system OS . An embodiment of server OS includes Microsoft Windows Server . Server OS may support a database DB system . An embodiment of database system includes Microsoft SQL Server. A single server is shown for the sake of clarity but it will be understood operating environment may include multiple servers .

Database system may include a database engine . Database engine is a service for storing processing and securing data. Database engine provides access and transaction processing for data consumers. Database system may include others services not shown such as analysis services data mining tools replication services reporting services notification services and the like.

Server may access a database storage that stores data managed by database system . DB storage may be external to server as shown in internal to server or a combination thereof. While a single DB storage is shown for the sake of clarity but it will be understood that multiple DB storage units may be used. Further DB storage associated with database system may be local to server distributed across a network or any combination thereof.

Database system may include a lock manager . In one embodiment when database engine receives a transaction request database engine determines which resources are to be accessed. Database engine determines what types of locks are required. Database engine then requests the appropriate locks from lock manager . Lock manager grants the locks if there are no conflicting locks held by other transactions. As described herein data base engine may use various hierarchical locking techniques. Database engine may also perform other locking procedures such as lock escalation de escalation and lock granularity changes as described herein.

Additionally device may also have additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement embodiments of the invention may be stored in storage shown as DB engine . Storage may also store other computer readable instructions to implement an operating system an application program and the like.

Although not required embodiments of the invention will be described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects application programming interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

The term computer readable media may include communication media. Device may also include communication connection s that allow the device to communicate with other devices such as with other computing devices through network . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency infrared and other wireless media.

Device may also have input device s such as keyboard mouse pen voice input device touch input device laser range finder infra red cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments of the invention. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device . Those skilled in the art will also realize that all or a portion of the computer readable instructions may be carried out by a dedicated circuit such as a Digital Signal Processor DSP programmable logic array and the like.

Embodiments of the invention provide locking mechanisms for B tree indexes. An example B tree index is shown in . Table is a database object that organizes data in columns and rows. Each row represents a unique record and each column represents a field within the record. For example a table of contact addresses may include a row for each person and columns for first name last name street address city state and zip code.

B tree index is an index structure associated with table . B tree index has keys associated with one or more columns in table . The keys are stored in the B tree index in such a way to enable the data base system to quickly find the row or rows using particular key values.

B tree includes three levels a root node level a branch node level and leaf node level . A root node includes pointers to branch nodes. A branch node includes pointers to leaf nodes or other branch nodes. shows one branch node level for the sake of clarity but it will be understood B tree indexes may include multiple branch node levels and thus more than three levels total. In other embodiments a B tree may include less than three levels for example in the case where a single page is sufficient for a root index and leaves .

Index nodes such as root nodes and branch nodes include key pointer pairs. For example index node includes key pointer pair . Usually an index node includes a sorted sequence of keys and their associated pointers that divides the search space covered by the index node. An index node may contain no actual data but hold index information to guide a search for a given key value. The key pointer pair may be called a separator key because it separates key values at index node into two nodes leaf nodes in this example .

A leaf node such as leaf node includes index items and may also include pointers to neighboring leaf nodes. Leaf nodes may include one or more index items such as index item which contain a key and row information. The key represents the value of the indexed column for a particular row in table . The row information may include the actual data for the row in table or a pointer to such data i.e. a clustered index or an non clustered index .

Embodiments of the invention may include aspects of B tree indexing as follows. Embodiments herein may employ user transaction and or system transactions. A user transaction includes a database access request initiated by a user for example a human or a computing process . System transactions may modify the database representation but not its contents and therefore permit certain optimizations such as commit without forcing the transaction log.

In one embodiment a system transaction may be used to remove ghost records left behind after deletions by user transactions. Separation of logical deletion turning a record into a ghost and physical deletion reclaiming the record s space serve various purposes such as simplified rollback for the user transaction if required increased concurrency during the user transaction locking a single key value rather than a range and reduced overall log volume. If the ghost removal can capture record deletion and transaction commit in a single log record there is never any need to log undo information that is the deleted record s non key contents .

Embodiments herein include lock escalation and de escalation. Lock escalation and de escalation are useful due to unpredictable concurrency contention and due to inaccuracy of cardinality estimation during query optimization. Lock escalation reduces overhead for queries with unexpectedly large results. It saves both invocations of the lock manager and memory for managing the locks.

Lock de escalation reduces contention. In one embodiment lock de escalation requires that each transaction retain in transaction private memory the information required to obtain the appropriate fine grain locks. For example even if a transaction holds a shared lock on an entire index it must retain information about the leaf pages read as long as de escalation to page locking might become desirable or required.

Initial large locks combined with on demand lock de escalation can improve performance because detail locks can be acquired without fear of conflict and thus without search in the lock manager s hash table.

In some embodiments for large index order B tree scans the parent and grandparent nodes enable deep read ahead. Thus accessing those nodes and their separator keys does not incur any extra I O and it is conceivable to lock those nodes or separator keys if desired.

In some embodiments nodes may include fence keys. Each node split posts a separator key in the parent node but also retains a copy of the separator key the fence key in the two sibling nodes resulting from the split. Such fence keys aid B tree operations in multiple operations including key range locking and de fragmentation.

In embodiments of the invention all B tree entries are unique. It is not required that the declared search keys are unique however the entries must have identifying information such that a row deletion leads to deletion of the correct B tree entry. Standard mechanisms for this purpose are to add the row pointer in the sort order of non clustered indexes and to add uniquifier numbers to clustered index keys.

Embodiments of the invention include new lock modes for key range locking in B tree indexes. In key range locking a key range lock is placed on an index entry specifying a beginning or ending key value. The key range lock may block attempts to insert update or delete any row with a key value that falls in the range because those operations would first have to acquire a lock on the index. Embodiments of new lock modes discussed below provide a simplification for traditional key range locking avoid irregular complexities such as instant locks and insert locks and increase permitted concurrency when applied to keys in B tree leaves.

An intent lock mode may be used to establish a lock hierarchy. In general intent locks also referred to as intention locks are acquired before a lock at a lower level in the locking hierarchy to signal the intent to place locks at the lower level. Typical intent locks include intent shared IS intent exclusive IX and shared with intent exclusive SIX . Intent locks prevent other transactions from locking the higher level resource in a way that would contradict the lock at the lower level.

Compatibility matrix shows whether two locks may co exist on the same resource such as a key. For example two shared locks may co exist shown by a Yes Y at the row column intersection of the S locks in matrix . In another example X and S locks may not co exist shown by a No N at the row column intersections of the S and X in matrix . X and S lock modes are not compatible because when an X lock is held no other transaction may acquire a lock of any kind on that resource until the X lock is released. Using the lock modes in matrix the key value the gap between keys and the combination of key value and gap are three separate resources that are locked using different locks and thus separate invocations of the lock manager.

Referring to an embodiment of a lock compatibility matrix including new lock modes is shown. Embodiments of new lock modes described herein take advantage of the fact that the key value serves as identifier for all three resources i.e. key gap and key gap combination in the lock manager s hash table which permits employing only one resource and one invocation of the lock manager at the expense of additional lock modes.

The new lock modes shown in matrix permit locking a key and the gap between two keys separately. For the purpose of discussion herein the implied intent locks discussed below apply to the combination of key and gap between keys. The absolute locks can apply to the key the gap between keys or their combination.

The new lock modes may be thought of as having a key component and a gap component where the gap represents the gap between two key values not including the key values marking the ends of the gap. Matrix introduces the symbol which represents a null on either the key component or the gap component of the lock mode. The new lock modes include key shared S gap shared S key exclusive X gap exclusive X key shared gap exclusive SX key exclusive gap shared XS .

For example assume a key range based on last names of Albertson to Connor. An S lock on Albertson would put a shared lock on Albertson and no lock on the gap between Albertson and Connor excluding Albertson and Connor. An SX lock on Albertson would put a shared lock on Albertson and an exclusive lock on the gap between Albertson and Connor excluding Albertson and Connor. 

These new lock modes are identified by a key value but they represent locks on the key value itself the gap between key values and the combination of the key value and gap. For example the new lock mode S locks the combination of key and gap in IS mode the key in S mode and the gap not at all. Conversely S puts a shared lock on the open interval K K and leaves the key value unlocked where K is a key value .

The new lock mode X locks the key exclusively and the gap not all. Conversely X does not lock the key but locks the gap exclusively. Lock mode SX locks the key and gap combination in IX mode the key in S mode and the gap in X mode. Lock mode XS locks the key exclusively the gap in shared mode and the combination of key and gap in IS mode.

It will be noted that intention locks are not part of the names for the new lock modes but intention locks are implied. The new lock modes are identified by a key value but they represent locks on the key value itself the gap between key values and the combination of the key value and the gap. IS and IX lock modes are not shown because they do not apply to key values in this scheme other than implied by the new lock modes. The combination of the locking the key and the gap in a single lock may act as an intention lock for example IS or IX . Also one should avoid any confusion with combination lock modes such as SIX which represents two locks on the same resource.

The derivations of the compatibility values in matrix follow directly from the construction of the lock modes themselves. For example S and X are compatible because both take intention locks for the combination of key value and gap and one transaction locks the key value in S mode whereas the other transaction locks the gap in X mode. Similarly X and X are compatible as are S and SX.

Insertion of a new key and associated record may be implemented as a system transaction. The system transaction invoked for key insertion leaves behind a ghost record that the user transaction can lock in key value mode and then turn into a valid record to effect the logical insertion. This is analogous to key deletion implemented by turning valid B tree records into ghost records with asynchronous ghost removal using system transactions.

The system transaction places a lock on the gap for inserting the new key e.g. by placing an X lock on a pre existing key next to the gap . The value of the system transaction for key insertion is that it releases its lock on the gap between pre existing keys when it commits. The follow on user transaction inherits a lock only on the new key value not on the gap that is an X lock on the new key . By holding this X lock until it commits the user transaction can modify the record from a ghost to a valid record. In the case of a rollback the ghost record remains and may be removed like other ghost records for example upon request by a future user transaction that requires more space in the B tree leaf .

For example turning to a gap is shown between pre existing keys and it will be understood that gap is a logical gap and not a physical gap between the pre existing keys . Also pre existing keys and have associated records that are not shown for clarity.

To insert a new key between pre existing keys and a system transaction places an X lock on key to lock the gap between keys and . System transaction inserts new key and associated ghost record in gap . User transaction inherits an X lock on new key and then converts the ghost record to a valid record to complete the insertion. It will be understood that a lock may be placed on new key and its associated ghost record.

In the meantime another user transaction or a system transaction may lock the gap defined by the new key. Using an X lock on the new key which really locks the gap defined by the new key this other transaction may insert yet another key into the gap defined by the pre existing key. Thus embodiments herein support high insertion rates within a page and an index without any need to introduce irregular complexities such as instant locks and range locks that do not fit the traditional theories of two phase locking and of hierarchical locking.

Moreover the system transaction locks only the gap into which it inserts the new key it has no need to lock the pre existing key value that identifies the gap. Thus another transaction can concurrently read the record with the pre existing key. In another transaction can read the record associated with pre existing key concurrent with the insertion of new key . It can update and even delete the record with pre existing key if deletion is implemented by turning the valid record into a ghost record. Neither concurrent reading nor concurrent updates is possible in locking schemes without locks on the open interval between keys for example traditional key range locking . The system transaction of inserting a new key into a gap is compatible with any of these actions on the pre existing key as long as the key is not erased from the B tree. Thus interference among neighboring keys is minimized by use of ghost records and system transactions. One skilled in the art having the benefit of this description will understand that the new lock modes may also be used for deletion of a key and associated record e.g. turn a valid record into a ghost record and then reclaim the ghost record space .

A system transaction may be very efficient a single log record may cover transaction start key insertion and transaction commit. In workloads that append many B tree keys with predictable keys for example order number in an order entry application a system transaction may create multiple ghost records such that multiple user transactions each can find an appropriate ghost record that merely needs updating without creating a new record or a new lockable resource.

Embodiments of key range locking on separator keys exploits the tree structure of the B tree for multi level hierarchical locking. Separator key range locking may be used in interior index nodes e.g. branch nodes and root nodes . A lock on a separator key represents the entire key range from one separator key to its next neighbor but not including the neighbor. Both intention locks and absolute locks can be employed on separator keys as well as combinations e.g. SIX .

Locking key ranges at the parent level results in locking overheard and concurrency behavior similar to traditional locking on leaf pages. A key range lock at the grandparent level however covers a much larger key range. Depending on a node s fan out a range lock at the grandparent level may save tens or hundreds of locks at the parent level just like a key range lock in a parent node covers tens or hundreds of individual keys.

Traditional lock modes may be applied to separator keys and cover the half open range from the locked separator key inclusively to the next separator key exclusively . For the highest key value in a node a fence key may be used to delimit the range protected by the range lock. A fence key includes a copy of the separator key in the node s parent. For the lowest key range i.e. the node s left most child the fence key is required as it determines the key value to lock. Many systems retain the lowest separator key even if the systems do not employ fence keys in general.

Locks on separator keys in parents are identified by the index identifier the key value and the node level within the B tree. Node levels are commonly stored in each node s page header with level assigned to leaves. The node level one up from the leaf level i.e. the parent node is node level and so on.

Note that this identification of locks does not refer to a physical location for example a page identifier but a logical location in the B tree. Thus locks remain valid even if a separator key migrates into a new node when a node splits when two nodes merge or when two neighboring nodes balance their load.

A node split may occur when a new row is inserted into a leaf page that already has reached its maximum number of entries. In one embodiment the leaf page is split into two leaf pages and the entries from the original leaf page are distributed evenly between the two new leaf pages. A separator key between the two new leaf pages is pushed up to the index node that holds the pointer to the split leaf page.

An example of splitting is shown in . B tree results from the splitting of leaf in B tree of . Key value was to be inserted into leaf but since leaf was full leaf was split into leaves and . As a result a new separator record was added to parent index node .

Two leaf nodes may merge when the number of entries in a leaf page falls below a threshold for example 50 of maximum . The index items are copied from one leaf node to another and the separator record in the parent node is removed.

When a node splits a new separator key is inserted in its parent. This new separator key divides a prior gap between two neighboring separator keys and thus disturbs existing locks covering this range. In order to ensure that existing transactions are not materially affected their locks on the range are duplicated and applied to the new separator key. This procedure permits page splits at all levels without interrupting the flow of transaction processing. Also this procedure ensures that no transaction s locked predicate is modified due to a change in the physical B tree structure. Referring to the splitting in the locks on separator key have been duplicated and are applied to the new separator key 15 in separator record to maintain the locks over the same key ranges.

When two nodes merge the opposite procedure applies. As ranges merge with the removal of a separator key transactions end up holding locks on the entire range as if they had locked both original ranges equally. In this case the lock manager verifies that the combined set of locks does not include conflicts. For example assume an S lock on one original range and an IX lock in the other original range. In this example the node merge operation is delayed because the S and IX locks are not compatible refer to . The merge operation will be delayed until one of the locks is released and thus the conflict is eliminated.

Embodiments of locking on separator keys may include load balancing between neighboring nodes. In one design load balancing among two neighboring nodes may be accurate in its locking but fairly complex due to the shift in key ranges between neighboring nodes. In this case the load balancing logic determines the locks needed on the parents from locks held on the child node entries that migrate.

In another design load balancing may be made simple. The simple method models load balancing as a merge operation followed by a split operation. In other words the neighboring nodes are merged and then split back into two nodes having substantially equal entries. However the locking may not be as accurate.

Lock escalation converts many fine grain locks into fewer coarse grain locks. De escalation performs the inverse operations. Lock escalation reduces system overhead due to managing fewer locks while increasing the probability of lock conflicts. Escalation upgrades a lock from an intention lock to an absolute lock. Many fine grain locks resulting from de escalation reduce the odds of concurrency contention but increase lock management due to the increase in the number of locks. De escalation downgrades a lock from an absolute lock to an intention lock.

Embodiments of locks on separator keys may include lock escalation and de escalation functionality. Locking within a B tree may start with key locking in the leaves parents or it may start at the grandparent level in order to cover larger key ranges and thus require fewer locks in large range scans.

If range locking starts with intention locks on separator keys at the grandparent level for example IS locks and continues with absolute locks on separator keys at the parent level for example S locks both lock escalation for example lock escalation to absolute locks in the grandparents and de escalation for example lock de escalation to intention locks in the parents and absolute locks in the leaves may be required.

Referring to a B tree is shown having a grandparent level a parent level and a leaf level . In the example of B tree is indexed based on last name. Assume that B tree has intention locks IS or IX on key ranges in grandparent node absolute locks S or X on key ranges in parent node and no locks on keys in leaf nodes and . In an example shown in node has on IS lock on the half open key range interval D . . . N in node . Node has an S lock on the half open key range interval F . . . G in node . Node has no lock on the key Franklin in node .

Referring to for lock escalation the intention lock at grandparent node becomes an absolute lock an S lock in the example of . The only remaining locks will be absolute locks S or X on key ranges in grandparent node . The locks at parent level now become obsolete due to the absolute lock at grandparent level and may be eliminated. In one embodiment the locks at parent level may be erased. In another embodiment the locks at parent level may be retained in the lock manager or in transaction private memory for future lock de escalation which may be desired due to increasing contention or due to a partial transaction rollback.

In the example shown in in node the open interval IS lock has escalated to an S lock on key range D . . . N . Thus no locks are necessary on key range F . . . G at node and key Franklin in node .

Referring to for lock de escalation of the locks in the absolute locks at parent level become intention locks. In intention locks will be maintained in grandparent node . The absolute locks on parent node become intention locks and absolute locks will be placed in the leaves and . In the example shown in the S lock on key range F . . . G is de escalated to an IS lock and an S lock is placed on the key Franklin of node .

In one embodiment this de escalation includes proactive gathering of required leaf level key locks during initial processing before the de escalation actually occurs. These pre gathered leaf level locks may be stored in transaction private memory. During de escalation after these leaf level locks have been propagated from transaction private memory to the global lock manager s hash table the absolute lock on the separator key in the parent can be relaxed to an intention lock.

In one embodiment partial transaction rollback will not reverse this de escalation because reversal requires upgrading a lock which might fail due to locks held by concurrent transactions. In fact after lock de escalation due to contention by concurrent transactions it is likely that such a lock upgrade from an intention lock to an absolute lock in the parent nodes during partial transaction rollback will fail.

Existing designs for hierarchical locking employ a fixed set of levels at which locks are required. For example a hierarchy of physical containers might be database file page and record. A hierarchy of logical containers within a database might be table index index partition and key. Within each such hierarchy a transaction may request a lock at a lower granularity of locking e.g. a page only after acquisition of an appropriate intention lock on the next higher granularity of locking e.g. the file containing the desired page .

Embodiments herein use granularity changes to adjust the set of levels in a hierarchy. For example embodiments herein permit removing a granularity of locking from a hierarchy such as a change from table index index partition key to table index key. Inversely embodiments herein permit introducing a new granularity of locking into a hierarchy e.g. from table index key to table index index partition key. Embodiments herein permit such changes while transactions are active i.e. dynamically including transactions that hold or desire locks on the granularity of locking being removed or being introduced.

Embodiments herein may include granularity changes of separator key locks. A granularity change involves a change in the set of B tree nodes where ranges are locked. In embodiments herein a node may be marked for locking to lock the node s key ranges or a mark on a node may be removed to remove the lock on the node s key ranges.

As a comparison lock escalation and de escalation involve changing locks in a particular B tree node between an intention mode and an absolute mode. In examples of lock escalation de escalation above acquisition of the first locks occurred in the leaves grandparents. This starting point may be adjusted dynamically and online that is without disruption of transaction processing using granularity changes.

In grandparent node is not marked for locking and no locks are taken on separator keys in node . Parent node is marked such that key range locks are taken on separator keys in parent node . Leaf node is also marked for locking. The other nodes in have been set as mark or no mark but this is not shown for the sake of clarity. In one embodiment a node includes a Boolean mark no mark field.

Setting a mark on a node signals that a lock request is required to the lock manager for at least one separator key in the node along with the search path from the root node to the sought leaf node entry . It is emphasized that nodes are marked but locks are placed on one or more keys within a marked node.

Setting a mark on a node for example setting a mark on grandparent node may be either immediate or delayed. An advantage of the immediate method is that a transaction may request lock escalation even to a node in which no transaction has acquired locks. However the delayed mode takes substantially less search in the lock manager s hash table than the immediate method.

In one embodiment the immediate method searches in the lock manager s hash table for active transactions that ought to hold intention locks. These transactions can be found by searching for locks on separator keys in the node s children for example nodes and that are children to node . For all such transactions appropriate intention locks for the appropriate separator keys in the present node are inserted into the lock manager. Thus intention locks may be set on separator keys in node where the separator key points to a child node that already has separator key locks.

While the search for such transactions is time expensive acquisition of the new intention locks is very fast as there is no need to search for conflicting locks. The correctness of the immediate method relies on its correct acquisition of all intention locks that would have been held already if the mark had been set on the node before any of the active transaction began.

In one embodiment the delayed method forces all new transactions to acquire intention locks and prevents acquisition of absolute locks in the node until all older transactions have completed. To do so the delayed method employs two system transactions. The first system transaction marks the node for locking thus forcing all future transactions to acquire intention locks when descending the B tree. In node is marked for locking. A second concurrent system transaction obtains IX locks on all separator keys in the node for example node observes the set of currently active transactions waits until the last one of those has finished and then commits the IX locks. For the duration of these IX locks no transactions may acquire an absolute lock on keys in the child nodes recall from that IX locks are incompatible with S and X locks . The correctness of the delayed method relies on a system transaction holding IX locks on all keys on behalf of all active transactions whether those transactions actually require them or not.

When a non leaf mode is split for example grandparent node or parent node both resulting nodes inherit the mark from the original node. A split operation can proceed even while a granularity change is on going whether the immediate or delayed method is employed.

For two nodes to merge they must be marked equally first that is a modification in the granularity of locking might be needed prior to a node merge operation.

Removing a node s mark for example removing the mark on node in follows a procedure similar to the delayed method above. One system transaction erases the mark so that future transactions do not acquire locks while another system transaction obtains IX locks on all keys in the node waiting for other transactions to release their absolute locks if any on those keys and then commits.

Embodiments of granularity changing may occur dynamically. In other words the introduction and removal of levels in a lock hierarchy may occur on demand by the database engine and without disrupting transaction processing. These dynamic changes may be exploited in many ways. For example assume in order to maximize transaction processing performance only keys in leaf nodes are locked by default. However if the database engine determines that a transaction would benefit from a larger granularity of locking for example locking the key range of an entire leaf page instead of numerous individual locks in the leaf page then key range locking can be introduced specifically in those parents and grandparents that benefit the transaction. When no longer advantageous the granularity of locking may be adjusted as appropriate to continually maximize transaction processing performance.

Both setting and removing a node s mark are local operations that hardly affect data availability. Note that new user transactions can lock keys in a node while a system transaction holds IX locks these IX locks do not conflict with other intention locks only with absolute locks.

The set of nodes marked for locks on separator keys has few restrictions. For example it is possible that a node is marked but some of its siblings are not or that a leaf s parent is not marked but its grandparent is skip level locking . These examples may seem counter intuitive but they might be appropriate intermediate states while an entire B tree is converted to a different granularity of locking or they might be permanent states tuned for skew in the data distribution or in the access pattern.

In one embodiment policies may be used to govern granularity changes. For transaction processing systems an initial policy might start with locking keys in the leaves only and locking separator keys in the upper B tree nodes only inasmuch as necessary for lock escalation. In other words non leaf nodes are marked as described above only on demand. Similarly marks are removed after their benefit ceases that is nodes remain marked only during demand. For relational data warehousing locks in parent and grandparent nodes seem like a reasonable default depending on the amount of incremental online information flow from business processes.

Embodiments herein may lock separator keys in non leaf B tree nodes. Locking separator keys scales with the size and the height of the B tree index. The stepping factor is fairly uniform across all levels of the index even in an index with a non uniform key value distribution. Typical values for the stepping factor may be 100 to 1 000 the latter value requiring large pages or very short keys for example due to aggressive prefix or suffix truncation . Thus the database administrator or the automatic tuning component of the database engine may adjust the granularity of locking accurately.

Embodiments of locking on key prefixes exploit the key structure of a B tree to provide key range locking. Consider for example a B tree index for a multi column compound key with columns a b c d and with specific values a b c d . Any leading prefix such as a b could be employed as a resource that locks all index entries with keys starting with these specific key values. In general a key prefix includes a subset of the key value starting at the beginning of the key value that is reading the key value left to right . Examples discussed below use a column as a prefix of a compound key. However one skilled in the art will appreciate that a key based on a single column may also have a key prefix. For example the letters Jo are a key prefix for key values Johnson and Jones. 

It will be appreciated that locks on key prefixes may match with query predicates. For example a query clause where a aand b b would match the lock on a b discussed above. More complex predicates map to only a few very precise locks. For example a query with the clause where a in a a a and b in b b b b requires only 12 locks independent of the size of the table and the index.

Locking key prefixes may be competitive with predicate locking and precision locking but without any need for predicate evaluation and concurrency control.

Locks on key prefixes provide efficient locking for single row updates because it is possible to lock a single B tree entry recall that all B tree entries are unique in order to permit accurate deletion .

A lock on a specific value covers all B tree keys starting with these values. In the example above a lock on the two column prefix a b locks all B tree keys starting with a b . In order to prevent phantom records in serializable transaction isolation however non existent key values also need locking. In short a phantom record may occur when a record is inserted in or deleted from a key range that is locked. A phantom record appears or disappears from a range after the range is accessed and thus creates non repeatable transactions.

In order to solve the problem of phantom records locks can be defined to cover only a specific prefix the gap between two actual prefix values or both. In one embodiment these locks may include traditional lock modes such as shown in in another embodiment these locks may include new locks modes as shown in .

In one embodiment existence of specific key values in the current B tree can be decided only after a B tree search has proceeded to the appropriate index leaf page. Thus key locking starts only after the navigation from the B tree root to the leaf. This navigation is protected by latches not locks including the inspection of the current leaf contents.

During insertion of a key in the B tree if a key prefix needs to be locked the lock mode depends on the existence of a prior B tree entry with the same prefix value as the new record. If such a prior B tree entry exists a key value lock suffices. If no such entry exists a range lock on the prior key is needed. Note that this range lock only needs to cover the open interval between two pre existing actual prefix values there is no need to lock either of the key values at the ends of the gap. A gap only lock such as discussed in connection with may be used.

For example in a B tree is indexed on a key having two columns last name and first name. As shown at existing records go from Johnson Mike to Smith Sarah with no records in between. To insert Johnson Sally a prefix key lock is placed on the prefix Johnson so no transactions on records with prefix Johnson may be made while Johnson Sally is inserted.

At to insert Miller Steve the gap between Johnson Mike and Smith Sarah is locked. The system locks the absence of the prefix Miller so another transaction does not insert a record having the prefix Miller or other last name between Johnson and Smith during the current insertion transaction. In one embodiment new lock mode X on prefix Johnson may be used to lock the gap between prefixes Johnson and Smith. 

The initial insertion can be a system transaction that does nothing but insert a ghost record leaving it to the user transaction to turn that ghost record into a valid record. While the system transaction requires a range lock the user transaction needs to lock only the new key value not the gap between keys. For example for the insertion shown at the gap may be locked using a system transaction for inserting a ghost record for Miller Steve and a follow on user transaction locks only Miller Steve to flip the ghost record to a valid record. Thus if a locked key prefix matches the definition of complex objects clustered in the B tree by shared key prefixes a new complex object can be inserted without ever locking its neighboring objects or any of their components.

Deletion may follow a similar pattern. A user transaction might simply mark a B tree entry as a ghost leaving it to a system transaction to erase the record and its key from the B tree or a user transaction might directly erase the record and the key. Erasing a record requires a lock on the record s key in the most restrictive mode thus ensuring that no other transaction holds any kind of lock on it. Moreover the gap between neighboring keys must remain locked in order to ensure successful transaction rollback if required. Gaps must be locked at all levels in the lock hierarchy for which a distinct value disappears.

Embodiments of locks on key prefixes may include lock escalation and de escalation functionality. Two aspects of escalation and de escalation for key prefix locking are noted. First the granularity of locking and the currently active components of the lock hierarchy are uniform across the entire index. Second structural modifications to the B tree such as splitting do not affect the set of locks required. These observations are based on the complete separation of the physical B tree structure and the locking hierarchy.

For lock escalation an intention lock is upgraded to an absolute lock for the appropriate key prefix and the prior absolute locks can be forgotten or retained for possible subsequent lock de escalation.

In the embodiment of B tree is indexed on compound key last name and first name . At a shared absolute lock is placed on each of Johnson Aaron Johnson Andrew and Johnson Brian. A shared intention lock is placed the prefix Johnson. After lock escalation as shown at the shared intention lock on prefix Johnson is escalated to a shared absolute lock. This makes the shared absolute locks on Johnson Aaron Johnson Andrew and Johnson Brian unnecessary.

For lock de escalation appropriate information must have been retained during the transaction s prior activities such that appropriate locks on longer prefixes can be inserted into the lock manager s hash table and the absolute lock on the short prefix can be downgraded to an intention lock.

When locking key prefixes the granularity of locking must be modified uniformly for the entire index. Changes of granularity in locking key prefixes affect the entire B tree. This is contrasted with locking separator keys in interior B tree nodes where modifying the granularity of locking affects each node individually. For example to add a level of granularity a lock on the two column prefix a b may be added to a lock hierarchy that has a lock on the three column prefix a b c . Thus the set of key prefixes that are locked has been changed increased in this example . Embodiments of granularity changes in key prefix locking include an immediate method and a delayed method. As discussed above with separator keys granularity changes of key prefix locks may occur dynamically.

Referring to a B tree is indexed using compound key last name first name middle initial . An absolute lock has been placed on key prefix Johnson Aaron as shown at . A granularity change proceeds as follows. At a new IS lock is added to all Johnson prefixes shown at . The IS lock is then escalated to an S lock on all Johnson prefixes and the S lock on key prefix Johnson Aaron may be removed as shown at . When a granularity change is made so that the absolute lock is changed to all Johnson prefixes then the number of records locked increases.

In the delayed method a system transaction locks all distinct key values at the new granularity of locking across an entire index. In contrast hierarchical locking based on separator keys can modify the granularity of locking one B tree node at a time.

The immediate method analyzes existing locks in order to acquire only those locks that are truly needed for specific active transactions. Hierarchical locking using key prefixes may be more precise than alternative locking methods and thus there are fewer locks to manage. Note that there might be transactions that do not need any new locks namely those transactions that own absolute locks at a granularity of locking larger than the granularity being added. This aspect also holds true for separator key locks.

When removing an existing granularity of locking it is necessary to wait for the release of absolute locks at that level. In one embodiment the database engine waits for an IX lock competing with each such absolute lock held by a user transaction.

Embodiments herein may perform hierarchical locking using key prefixes. Key prefix locking reflects the matching between query predicates and key prefixes. A single mechanism permits locking large ranges or individual B tree records and thus supports equally well decision support transaction processing and other applications with similar access patterns.

Key prefix locking matches with equality predicates and in predicates which are common both in single table selections and in joins. Thus often a single key prefix lock may cover precisely the index entries needed neither more nor less and consistency and serializability among such a set of index entries are guaranteed even in transaction isolation levels lower than strict serializability. This aspect is effective for using key prefix locking for non unique indexes including indexes on foreign key columns. This advantage pertains not only to searches on the full index key but for any prefix of the key. If the leading key column is not specified and multiple index probes are required a single lock per probe may suffice.

If master detail clustering is supported based on equality of search columns in a B tree locking key prefixes provides support for locking complex objects. For example if orders and order details are co located within a B tree index based on equal values in the common column of order numbers locking an order number locks an entire order object and all of its component records. A single lock can also cover a large object for example a customer with multiple orders shipments invoices and payments . Insertion and deletion of one complex object does not require any lock on its neighbors.

Locking prefixes may also be used with partitioned B trees. A partitioned B tree includes an ordinary B tree with an artificial leading key column that indicates partitions or during sorting and index creation run numbers. The first granularity of locking is the partition identifier which permits efficient operations on partitions such as merging partitions creating an entire partition during data import and dropping a partition while purging old data from a data warehouse.

Embodiments herein provide schemes for hierarchical locking. In one embodiment new lock modes are presented that enable locking of keys and gaps between keys. These new lock modes not only permit additional concurrency compared to earlier designs but also avoid unconventional locks modes that violate traditional two phase locking.

Embodiments herein include key range locking using separator keys found within a B tree structure. Key range locking in parent and grandparent nodes scales with additional B tree levels and adapts to skewed or unpredictable key distributions. The ability to lock a B tree in levels between a root node and individual keys eliminates the dilemma between the massive overhead due to many individual locks on keys and massive concurrency contention due to a single B tree index lock to lock the whole B tree. Moreover splitting pages at keys that minimize the size of truncated separator keys matches the key ranges in parent and grandparent nodes to clusters of records and complex objects. System transactions may be used for insertion and deletion of records in separator key locking.

Embodiments herein include key prefix locking of key ranges. Locking prefix values of search keys matches query predicates and complex objects in merged indexes. Insertions and deletions of records within the locked key range may be performed using system transactions.

Embodiments herein include dynamic granularity changes in separator key locking and in key prefix locking. Dynamic changes may be made in the lock hierarchy in response to skew in the data or in the access patterns. These dynamic changes are online and incremental such that they minimize disruption to ongoing transaction processing and they may be invoked on demand. Granularity changes may be performed using an immediate method or a delayed method.

Various operations of embodiments of the present invention are described herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment of the invention.

The above description of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the embodiments to the precise forms disclosed. While specific embodiments and examples of the invention are described herein for illustrative purposes various equivalent modifications are possible as those skilled in the relevant art will recognize in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification. Rather the following claims are to be construed in accordance with established doctrines of claim interpretation.

