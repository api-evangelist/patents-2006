---

title: System and method for communicating between an application and a database
abstract: A method for communicating between an application and a database by using a lightweight stored procedure data-binding framework for applications written in object oriented programming languages such as JAVA, significantly reduces the coding effort required to communicate with a relational database. Once the developer specifies the needed tabular data, the inventive framework generates all needed data objects and stored procedures to accomplish the interaction with that database data. The automatically generated code is then used by the application via a run-time component. This means the developer need only make simple calls in a few lines of code for database interaction. The encapsulated data model deals only with persistence and retrieval issues and is therefore de-coupled from the business model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08321467&OS=08321467&RS=08321467
owner: JP Morgan Chase Bank
number: 08321467
owner_city: New York
owner_country: US
publication_date: 20061211
---
This is a continuation application of U.S. patent application Ser. No. 10 308 792 filed Dec. 3 2002 entitled Method For Simplifying Databinding In Application Programs . The U.S. patent application Ser. No. 10 308 792 is incorporated herein by reference.

This invention relates to a method for the exchange of data between an application program and a database using a framework and in particular to a method using a databinding framework that automatically generates computer code for reducing the number of lines of application code that need to be written by the developer for database operations. The method is particularly useful with complex business and financial application programs.

Computer programs applications can be very complex. Such applications might perform calculations needed for financial transactions. For example financial applications can facilitate the buying or selling of business or financial instruments such as derivatives. The complexity involves the number and type of calculations performed by the application the large volume of data on which the application bases those calculations and the computed data representing the results of the application s computations. Software developers generally write these applications in a high level computer programming language. Object Oriented languages such as Sun Microsystems Java JAVA and its various versions as Sun Microsystems J2EE J2EE the enterprise edition are particularly well suited for very large complex applications.

The data that represents the inputs and outputs of the application can be voluminous. And in large companies and financial institutions it is likely that the data is shared by several applications. In such large and complex systems the data representing all of the information needed by the application inputs and processed information outputs is generally stored on one or more databases that are semiautonomous of the application i.e. the application does not directly read and write information to the databases. It communicates with the database through a database management program. Sybase Inc. Sybase SYBASE Microsoft SQL Server SQL SERVER and Oracle Corporation Oracle ORACLE are exemplary of such commercial database products.

One aspect of database programs is that the data is stored read and written in the form of tables. Database data is typically grouped in tables by similar characteristics and the database program maintains the relationships between the tables. For example the characteristics of a particular financial instrument might be found in one table while it s trading history can be found in another table. These tables can be then be related by the identifier of the instrument. Table based database systems are known as relational databases. Relational database programs are optimized for searching for reporting selected data from the database and for writing data to selected data tables.

Communication with commercial databases is typically done via a structured query language SQL . SQL lines can use variable input parameters such as the name of a financial instrument or a date or range of dates. Many lines of SQL code may be required for a given database operation. Stored procedures are lists of SQL code that allow for input parameters and generate tabular result sets. The stored procedures are generally stored in the database.

By contrast applications are usually written in high level object oriented languages. Object oriented languages such as J2EE offer very powerful and computationally efficient computing environments for solving business calculations. The calculations are typically presented to the application developer as a set of rules known as the business model . Object Oriented languages are designed to work with objects. Objects are programming structures of the application that contain both functions and the corresponding data for a given computational task. They are generally focused on solving a particular problem.

An application runs on one or more computers. During runtime it typically reads and writes large volumes of information in the form of data. After a particular run the program needs to save a great deal of information so that the next time it runs it continues one or more calculations from the previous ending state. Also some data within objects simply needs to be saved in the database. Persistence refers to the ability of the application to save various conditions of the application and data at the end of a run so that it is available to the application at the beginning of the next run.

Object oriented languages are becoming ever more rich in their ability to interact with other systems and programs such as commercial database programs. They do this by offering a suite of libraries that provide pre written application programming interfaces API for application developers. For example J2EE offers tools to communicate with database programs such as SYBASE. Even with these tools the Java programmer still must write many lines of JAVA code and then many lines of SQL code stored procedures to perform a given database operation. Depending on the complexity of the interaction it can literally take weeks for a programmer to write all of the needed code for an interaction between the application and the database as between JAVA and SYBASE. And because the stored procedures can comprise many lines of very detailed SQL code there is a very good chance for coding errors. Proof reading such code is difficult and time consuming.

Because the application handles information as part of its objects and the database handles information as tables the data structures must be converted for the two programs to communicate with each other. One approach is to provide a system that maps tabular data to objects in a way that is transparent to the programmer writing the application. This system of binding tabular data to objects is called databinding. In databinding objects can be written that deal only with the information to be exchanged. Similarly stored procedures can be written to only carry out the corresponding database interactions. The stored procedures are lightweight in the sense that they do not perform any business calculations. A method or framework to manage data for an application is ideally encapsulated . That is it is isolated from the application s business calculations the business model .

What is needed is a method that implements a lightweight stored procedure framework whereby the applications programmer solving a business model need only specify a few simple lines of code to communicate with the tabular data in a relational database.

A method for communicating between an application and a database by using a lightweight stored procedure data binding framework for applications written in object oriented programming languages such as JAVA. The method significantly reduces the coding effort required to communicate with a relational database. Once the developer specifies the needed tabular data the inventive framework generates all needed data objects and stored procedures to accomplish the interaction with that database data. The automatically generated code is then used by the application via a run time component. This means the developer need only make simple calls in a few lines of code for database interaction.

The encapsulated data model deals only with persistence and retrieval issues and is therefore de coupled from the business model. The developer can therefore concentrate on implementing a complex business object model. And changes to the business object models have no direct impact on the underlying persistence model. The encapsulated method provides a generic configurable means of persisting and retrieving objects to and from a relational database. While it is described in a JAVA SYBASE environment embodiment the method is applicable to other object oriented languages and database programs.

Automatic code generation reduces a developer s coding time by up to 90 . Moreover coding errors are virtually eliminated since the generated code is not prone to manual coding errors. Thus testing time is reduced as well.

It is to be understood that the drawings are for the purpose of illustrating the concepts of the invention and except for the graphs are not to scale. It is also understood that all application code other framework code the database program and data reside on tangible computer readable media and run on one or more computer systems.

The application is divided into two parts. Part I discusses the invention as a general framework solution for object oriented applications that access data from database programs using a structured query language SQL and groups of SQL calls as stored procedures. Part II of the application for those skilled in the art is an example of the inventive framework for the JAVA J2EE and SYBASE programming environments.

The inventive framework comprises two distinct components. A code generator is used during program development to automatically generate required stored procedures JAVA code and an XML data exchange and documentation middle layer. A second component the run time component integrates the generated code into the running business application as library routines so that the business program can retrieve store and persist data with very minimal JAVA code usually with only one or two lines of JAVA code.

The method of databinding database relational tables to application objects shown in . In Block A the application is provided and in Block B the database. The framework discussed in Parts I and II is provided in Block C. Using the method first databinding files are generated in Block D and finally those databinding files are integrated into the application at run time by the run time component of the framework provided in Block E.

The code generator is shown in . The developer supplies a list of needed data specified as database table names. By way of example the developer here is interacting with table table one . The data information corresponding to table one resides in relational database . The generating tool initially parses the required tabular data and generates table meta data in the form of database primary keys columns and data types.

Based on meta data the code generator creates three types of output files all of which are used later during the running of the business or financial application hereinafter application via the framework s run time component. The generated stored procedures are the part of the framework that communicate most directly with the relational database.

The generated XML files create a middle layer of the framework. They are written in the extensible Markup Language XML . These files act as the glue by defining what each stored procedure is called and what its input and output parameters are. At run time the XML documents configuration files reside between the stored procedures that directly access database and the JAVA code of the application. The XML documents can be read directly as text documents. Because XML documents are structured and nested they are also self explanatory and self documenting.

The code generator also writes value objects . The value objects generated beans in JAVA are part of an object class for exchanging data with the database. They provide the final links that ultimately map the tables of relational database to the application written in an object oriented language such as JAVA. Following the philosophy of frameworks created in object oriented programming environments the value objects perform only functions related to information exchange between database and the application. No business rules are calculated in these objects. Business rules can be computed solely by the application.

Blocks to further illustrate the roles of the each of the three generated sections of code. Block shows the generated stored procedures . The stored procedures of block communicate via the generated XML configuration files of XML code as shown by block with the application. The generated value objects for example Sun Microsystems Java Beans JAVA BEANS complete the databinding by providing the final mapped data in a form suitable for use in the run time object oriented environment of the application as shown by block . Thus the stored procedures of block are connected to the value objects of block by the generated XML middle layer .

Data Access Tier comprises the code generated by the code generator. Run time component integrates the generated code into the application. The generated stored procedures generated XML middle layer and generated value objects are tied together by run time component . Data Access Objects DAOs are the simplified lines of code calls from the objected oriented application. DAOs are hand written into the application by the developer.

Run time component comprises subcomponents . Caller provides interaction to the database via a unique identifier for each XML binding document. Connection manager provides for physical connections to the database. Binder Manager maps the stored procedures to the value objects during application startup. And Cache Manager can cache store procedure results as list of value objects in memory for a time for quicker application access.

Using the inventive framework the developer starts with an existing relational data model. Then the tables that will be used to persist the application s data are identified. A table of metadata is generated from the list of table names by the code generator from which the code generator creates the Load Save Delete LoadList Stored Procedures the Value Objects i.e. JAVABEANS and XML binding definitions. Finally the developer writes the Data Access Objects business model interface by hand in just a few lines of application code.

The benefits of the inventive framework are manifold. It generates both application code and stored procedures. In the best practices of object oriented programming the stored procedures and value objects contain no business logic. And the business model is de coupled from the underlying persistence model. There is simplified data access interface i.e. load loadList save delete. In the case of a JAVA solution it wraps the clunky JAVA DataBase Connectivity JDBC Stored Procedure interface. And a very important feature is that the framework significantly reduces error prone mundane data access stored procedure development. Thus the development effort gains more time to focus on the business model code because the data access build effort and cost are now 10 of what they would have been without the inventive framework. Also stored procedure logging can be easily implemented in this framework. And finally run time can be improved by built in memory caching.

Furthermore since routing human coding errors are virtually eliminated there is far less required data access testing. As will be shown in the example the framework is easily integrated into standalone JAVA applications or J2EE enterprise applications.

While the inventive framework can be adapted to all known business class object oriented languages and commercial database systems the embodiment of the example was coded using JAVA JAVA BEAN JDBC Reflection XML XML schema Castor SYBASE database Apache Commons and Apache Log4J.

The embodiment described here is called SPBinder. SPBinder is a lightweight Stored Procedure data binding framework for JAVA. Its main function is to significantly reduce the coding effort required to call database Stored Procedures by encapsulating the clunky JAVA DataBase Connectivity JDBC interface and providing a generic configurable means of persisting retrieving JAVA objects to from a relational database. The main advantage of encapsulating the data model is that it purely deals with persistence and retrieval and therefore becomes de coupled from the business model. This means the developer can concentrate on implementing a complex business object model without directly impacting the underlying persistence model. The SPBinder framework has two main components a code generation component for developers called GenUtils and run time component called SPBinder.

The GenUtils component is set of code generation utilities that take a list of database table names new or legacy as input and extracts the table metadata directly from a database where the tables are defined to generate associated JAVA BEANS Value Objects stored procedures loadList load save and delete and XML data binding definition documents.

The XML data binding document see Appendix for schema describes the relationship between stored procedure input output parameters result sets and associated JAVA BEANS Value Objects . This means that at run time Stored Procedure input parameters can be mapped directly from JAVA Object attributes and stored procedure result sets can be mapped to a list of JAVA Objects.

SPBinder is the run time component which uses the XML binding document and JAVABEAN Value Objects and encapsulates communication to the database via JDBC. It consists of four main components SPBinderManager SPConnection SPCaller and SPCacheManager.

SPBinderManager normally reads in the XML binding document once during application start up and builds a data binding mapping in memory using the unique identifier to reference each Stored Procedure and associated data binding JAVABEAN Value Object . This unique identifier can then be used by SPCaller to do the actual database access.

The SPConnection component handles the physical database connections and associated transaction management. It can also handle connection pooling in a J2EE environment.

SPCaller uses the unique identifier defined in the XML binding document to access the database and load save or delete data. The data is automatically extracted from or populated in the JAVABEAN Value Objects where appropriate. Using the XML definition above the example below shows how to load a list of users and their spids SYBASE process Id s example 

The SPCaller component has built in logging which can be used to trace Stored Procedure calls input parameters and result sets.

SPCacheManager is a component which manages a read only time expiry cache of list based data. This can be used to cache Stored Procedure result sets as lists of JAVABEAN Value Beans in memory for a period of time. The time to expire variable can be configured per Stored Procedure in the XML data binding document.

