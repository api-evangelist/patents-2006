---

title: Controlling computer program extensions in a network device
abstract: A network infrastructure element such as a packet data router or switch hosts an application program and one or more user program extensions to the application program. Logic in the network element is configured to perform creating and storing one or more default program security permissions; receiving a user-defined security policy that defines one or more user extension security permissions for the one or more user program extensions; creating and storing only each of the one or more user extension security permissions that do not conflict with the default program security permissions; receiving a request from one of the user program extensions to access a resource of the apparatus or the network; permitting the request to access the resource or the network only when the access does not violate the user extension security permissions and the default program security permissions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08239923&OS=08239923&RS=08239923
owner: Cisco Technology, Inc.
number: 08239923
owner_city: San Jose
owner_country: US
publication_date: 20060612
---
This application claims benefit under 35 U.S.C. 119 e of prior provisional application 60 692 715 filed Jun. 21 2005 the entire contents of which are hereby incorporated by reference for all purposes as if fully set forth herein.

This application is related to U.S. patent application Ser. No. 11 043 857 filed Jan. 25 2005 entitled APPLICATION LAYER MESSAGE BASED SERVER FAILOVER MANAGEMENT BY A NETWORK ELEMENT by Sunil Potti et al. U.S. patent application Ser. No. 10 991 792 entitled PERFORMING MESSAGE AND TRANSFORMATION ADAPTER FUNCTIONS IN A NETWORK ELEMENT ON BEHALF OF AN APPLICATION by Pravin Singhal et al. filed on Nov. 17 2004 U.S. patent application Ser. No. 10 997 616 entitled CACHING CONTENT AND STATE DATA AT A NETWORK ELEMENT by Alex Yiu Man Chan et al. filed on Nov. 23 2004 U.S. patent application Ser. No. 11 005 978 entitled PERFORMING MESSAGE PAYLOAD PROCESSING FUNCTIONS IN A NETWORK ELEMENT ON BEHALF OF AN APPLICATION by Tefcros Anthias et al. filed on Dec. 6 2004 U.S. patent application Ser. No. 11 007 421 entitled PERFORMING SECURITY FUNCTIONS ON A MESSAGE PAYLOAD IN A NETWORK ELEMENT by Sandeep Kumar et al. filed on Dec. 7 2004 U.S. patent application Ser. No. 11 007 152 entitled NETWORK AND APPLICATION ATTACK PROTECTION BASED ON APPLICATION LAYER MESSAGE INSPECTION by Sandeep Kumar et al. filed on Dec. 7 2004 U.S. patent application Ser. No. 11 009 127 entitled REDUCING THE SIZES OF APPLICATION LAYER MESSAGES IN A NETWORK ELEMENT by Ricky Ho et al. filed on Dec. 10 2004 U.S. patent application Ser. No. 11 009 270 entitled GUARANTEED DELIVERY OF APPLICATION LAYER MESSAGES BY A NETWORK ELEMENT by Tefcros Anthias et al. filed on Dec. 10 2004 U.S. patent application Ser. No. 11 031 106 filed Jan. 5 2005 entitled INTERPRETING AN APPLICATION MESSAGE AT A NETWORK ELEMENT USING SAMPLING AND HEURISTICS by Tefcros Anthias et al. filed on Jan. 5 2005 and U.S. patent application Ser. No. 11 031 184 filed on Jan. 6 2005 entitled DATA TRAFFIC LOAD BALANCING BASED ON APPLICATION LAYER MESSAGES by Hari Kathi et al. filed on Jan. 6 2005 the entire contents of which are hereby incorporated by reference for all purposes as if fully set forth herein.

The present invention generally relates to data processing techniques performed within network infrastructure elements such as routers and switches. The invention relates more specifically to techniques for securing or controlling the behavior of computer program extensions or other custom code in a programmable network element such as a router or switch.

The approaches described in this section could be pursued but are not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

Software applications operating in a network environment exchange application messages. An application message or simply message as used herein refers to a message emitted or consumed by a software element that is logically located at Layer 5 or higher of the OSI reference model. Messages may be contained in more than one data frame packet or segment. For simplicity the term packet is used to refer to a unit of organization under an internetworking protocol such as data frame packet or segment at Layer 2 3 or 4 of the OSI reference model.

Application end points such as clients and servers in a distributed system communicating over a network often need to authenticate users credentials presented in an application message and if the authentication succeeds authorize the users for specific privileges for using system or application resources. Authentication and authorization usually is done by application end points. Application end points or simply applications are required to perform authentication and authorization operations relating to messages received. Under this approach logic extracting user credentials from application messages is part of application processes. However to perform the extraction applications need to know specific details of application message formats such as where user credentials are stored.

Additionally authentication or authorization logic often communicates with one or more authentication or authorization service providers or data stores. Thus applications often need to know specific details of service providers or data stores such as where and how the user credentials extracted from messages can be compared with trusted user credentials kept by the service providers or data stores. To complicate the matter some service providers or data stores may not be based on industry standards in providing the authentication or authorization related services.

Applications needs for authentication and authorization may change. For example service provider may change. An application may need to support LDAP instead of Kerberos for authentication. Or an application may need to access a data store instead of a service provider.

Furthermore formats of application messages may change with respect to user credentials. User credentials may be specified in an application protocol header say HTTP header or SOAP header. Also they can come as a part of application message body in an application specific format or in a payload.

Generally in past approaches in order to handle any of these changes the implementation of the application has to be changed. This is time consuming and requires significant resources in programming labor.

Further in typical past approaches the number of points at which authentication and authorization are performed is proportional to the number of application endpoints. This is a waste of application processing resources.

Also in typical past approaches authentication and authorization by an application can only authenticate and authorize based on user credentials present in an application message. Since the application typically is ignorant of what user credentials may present below OSI layer 5 authentication and authorization for such user credentials typically has to be performed elsewhere. An example of such user credentials is an SSL certificate. This results in a fragmented processing waste of resources and potential inconsistent outcome.

In past approaches network elements such as routers and switches generally have had limited or no support for application program extensibility in which customers or users of the network elements can define their own software programs and upload the programs into the network element. To address the problems above relating to authentication and authorization and other problems Cisco Systems Inc. has introduced Application Oriented Network AON technology which provides an environment in which customers can create programs that can be dynamically loaded and executed on the network device.

The availability of extensible programs creates the possibility that a customer program will attempt to write system memory change configurations destroy disk files or perform other operations that may be harmful or disruptive to the network element. The network element should be protected from such harm.

One approach to allow custom code to be uploaded into a network element involves creating a new image containing the new functionality. Access control and security for such code is controlled at build time or by providing options to control behavior of the module via a command line interface. Thus the problem of code behavior is addressed in a static manner and cannot change dynamically after the code has been uploaded and executed. The standard security mechanism of the Java Virtual Machine JVM does not allow the running security policy to be changed dynamically. In other words changing the security policy requires the JVM to be restarted which is undesirable.

An apparatus and method for extensible authentication and authorization of identities present in an application message on a network are described. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

The needs identified in the foregoing Background and other needs and objects that will become apparent for the following description are achieved in the present invention which comprises in one aspect a data processing apparatus comprising a plurality of network interfaces that are coupled to a data network for receiving one or more packets therefrom and sending one or more packets thereto one or more processors a switching system coupled to the one or more processors and packet forwarding logic wherein the switching system and packet forwarding logic are configured to receive packets on a first network interface determine a second network interface on which to send the packets and to send the packets on the second network interface a computer readable storage medium having stored thereon an application program and one or more user program extensions to the application program and logic configured to perform creating and storing one or more default program security permissions receiving a user defined security policy that defines one or more user extension security permissions for the one or more user program extensions creating and storing only each of the one or more user extension security permissions that do not conflict with the default program security permissions receiving a request from one of the user program extensions to access a resource of the apparatus or the network permitting the request to access the resource or the network only when the access does not violate the user extension security permissions and the default system security permissions.

In another feature the logic further comprises instructions which when executed cause permitting the request to access the resource or the network only when the access also does not violate Java sandbox security permissions.

In still another feature the logic causes creating and storing only each of the one or more user extension security permissions that do not conflict with the default system security permissions except when the logic specifies that the user extension security permissions can override the default system security permissions.

In yet another feature the user defined security policy comprises one or more extensible markup language XML documents each comprising one or more permission definitions each comprising a permission type permission name and one or more actions and wherein each of the permission definitions is associated in the policy with a codebase identifier.

In another feature the logic further is configured to cause the processor to perform parsing the user defined security policy by storing the permission type permission name actions and codebase identifier in a policy store identifying a programmatic class of the user program extension that is associated with the request determining a location from which the identified class has been loaded determining a name of the resource from the request determining an action associated with the request searching the policy store for the location name and action based on comparing the identified class to stored codebase identifiers.

A related feature involves first determining whether the request violates the user extension security permissions and generating a user extension permission exception when a violation is determined and then determining whether the request violates the default system security permissions and generating a user extension permission exception when a violation is determined.

In other aspects the invention encompasses a machine implemented method and a computer readable medium configured to carry out the foregoing steps.

Referring first to a sender is coupled through a network to a receiver . The network comprises one or more network infrastructure elements such as routers or switches. Each of the network elements comprises one or more blades bladelets or other software elements alone or in combination with hardware or firmware elements that implement inspection at various OSI layers of packets received in association with an application message and related authentication and authorization functions as described herein.

A commercial embodiment of network elements A may comprise routers or switches from Cisco Systems Inc. San Jose Calif. with blades having Application Oriented Networking Services AONS capabilities. In some embodiments network elements A are termed AONS nodes or AONS endpoints. Other network elements B may be non AONS nodes. Further network elements A need not use Cisco AONS technology the network elements can comprise routers or switches that comprise other internal elements to perform extensible authentication and authorization functions as described herein. Thus the use of AONS in an embodiment is not required and all references herein to AONS elements are provided merely to illustrate a clear example and not as limitations.

In an embodiment the validation of an application message by network elements A involves accessing an authentication service provider A and an authorization service provider B.

The authentication service provider A may implement either standard based or proprietary technology based authentication services. Similarly the authorization service B may implement either standard based or proprietary technology based authorization services. Examples of the standard based authentication or authorization service providers include those based on LDAP Kerberos X509 or SAML. In some embodiments authentication or authorization service providers such as A or B may comprise database access routines and a database storing user credential and privilege information. Furthermore in some embodiments an authentication service provider and an authorization service provider can comprise a single authentication and authorization server.

As seen in sender is coupled through a local network to an internetwork that is coupled to another local network . Either of the local networks and may have network elements that implement the techniques herein. As an example router A in local network is equipped with an AONS blade available from Cisco Systems Inc. San Jose Calif. The AONS blade comprises one or more bladelets that form authentication and authorization logic . In certain embodiments all the network elements include authentication and authorization logic which comprises one or more computer programs programmatic objects or other software elements that implement the functions described herein.

Generally the authentication and authorization logic identifies user credentials in an application message. Examples of user credentials are peer SSL certificates HTTP basic authentication scheme and parameters or HTTP negotiate authentication data from message headers and user password token SAML token SPNEGO token or X509 token from a message body.

The authentication and authorization logic performs authentication and authorization based on the user credentials that were identified. If the authentication and authorization of the application message succeeds the application message is processed according to a policy. For example the message is forwarded to a receiving application server A. Thus in the arrangement of router is proximate to the receiving application servers A and can perform authentication and authorization for all the application servers. For example sender and other senders at different locations in networks might send different requests to different instances of applications on different application servers A. The authentication and authorization logic can perform application message authentication and authorization for all such requests relieving the application instances and application servers A from the processing burden of authentication and authorization for each request.

Alternatively if router is located in local network the router can perform application message authentication and authorization when sender emits messages and before the messages reach the application servers A. In all such cases the data processing efficiency of the application servers A is greatly improved because router is responsible for message authentication and authorization and the application servers are responsible only for performing substantive application functions.

When an application message authentication and authorization operation is performed in a network device the operation can be performed on a device that is closer to the application that is sending the message or the application that is receiving the message. As a result if there are multiple instances of an application running possibly on different hosts then a single device through which all the messages are passing can perform the needed authentication and authorization. Accordingly efficiency of the overall network is improved.

In some embodiments extensible authentication and authorization is provided by using a user configurable policy. In this approach the user configurable policy specifies how an incoming message should be authenticated or authorized.

In one embodiment through a user interface a user is enabled in the user configurable policy to define a plurality of message types and associations each of which associates between a particular authentication method with a corresponding message type. In one embodiment the policy is created at design time in advance of message processing based on known characteristics of incoming messages and outgoing messages. The policy associates authentication methods or authorization methods with respective message types. The policy can also associate user credential location definitions that specify locations of user credentials with respective message types. For example the policy can be created using AONS Design Studio ADS and downloaded to an AONS node via AONS Management Console AMC . An ADS designer can select an authentication method for a message type among LDAP and Kerberos SPNEGO X509 Certificate based authentication methods and extension authentication methods provided by extension packages as further explained herein. Similarly the ADS designer can select an authorization method for the message type among LDAP Group SAML Assertion and Rule based methods and extension authorization methods provided by extension packages. During runtime the authentication and authorization logic retrieves the policy and an incoming message. The authentication and authorization logic determines the application message type identifies user credentials in the message validates the incoming message by applying associated authentication and authorization methods and if successful directs other elements of the network element A to process the message according to a success policy e.g. to forward the message on a path to a receiving application server A.

Upon receiving an incoming message on any network interface of the router the credential extraction inspects the message. Credential extraction has access to user credential location definitions for various application message types. In a preferred embodiment credential extraction makes use of existing components in the network infrastructure element A that allow extraction or identification in packets associated with an application message of fields in various OSI layers. The search of user credential fields may be conducted on headers data or payloads at standard locations or non standard locations and additionally or alternatively using name value pairs or regular expressions. In one embodiment credential extraction identifies user credentials or a subset thereof in locations specified by standards. In another embodiment the credential extraction identifies the user credentials or a subset thereof based on user credential location definitions for the message type. In yet another embodiment credential extraction identifies the user credentials from both locations identified by the standards and by the user credential location definitions.

Credential validation authenticates an identity associated with the user credentials. In a preferred embodiment credential validation comprises a validator for built in authentication methods and an extension validator for non built in authentication methods which may be developed before or after the network infrastructure element A is deployed. For the built in authentication methods a user or policy specifies which one is to be used for a particular application message type. For example the authenticate bladelet embodiment of credential validation in an AONS bladelet has built in authentication methods based on LDAP Kerberos SPNEGO or X509 Certificate.

The extension validator can be configured to invoke an extension authentication in extension packages for authentication methods that do not have built in support. The extension packages for non built in authentication methods may be deployed before or after the installation of the router A in a network. In a preferred embodiment the authentication and authorization logic does not require the presence of a particular extension package unless a corresponding non built in authentication method is to be supported. However when a non built in authentication method is to be supported at runtime the extension validator is configured accordingly and the extension authentication is provisioned to the network infrastructure element A.

An extension authentication can be developed in a programming language that makes use of application programming interfaces APIs to support a particular authentication method. For example an extension authentication can be developed in JAVA that makes use of SiteMinder JAVA Agent APIs available from Computer Associates Inc. CA to support the SiteMinder Authentication. In a preferred embodiment the configuration that directs the extension validator to use the extension authentication thus developed can be specified in AONS Design Studio. Both the configuration and the extension authentication can be provisioned to the network infrastructure element A to form an extension package before its use by the extension validator at runtime. In a preferred embodiment the configuration and the extension package can be pre packaged into a downloadable file in AONS Design Studio and subsequently downloaded to an AONS node.

When the extension authentication is invoked it is made available all the required and optional parameters by the authentication and authorization logic . The extension authentication reads configuration parameters relevant to accessing an authentication service provider or a database that stores necessary information for authentication. In some embodiments the parameter list values and access routines for parameters are configured for a particular authentication method and authentication service provider in authentication and authorization logic . In a preferred embodiment the parameter list values and access routines for parameters can be pre packaged into a downloadable file in AONS Design Studio and subsequently downloaded to an AONS node. For example as a part of extension configuration in AMC a user configures necessary and optional parameters including those required for connecting to an authentication service provider such as SiteMinder Policy Server from CA.

At runtime the extension authentication uses the parameters performs the authentication method and returns the result to its caller.

The credential authorization can be invoked to authorize privileges to an identity associated with the user credentials. In a preferred embodiment the credential authorization comprises an authorizer for built in authorization methods and an extension authorizer for non built in authorization methods which may be developed later. For the built in authentication methods a user or policy specifies which one is to be used for a particular application message type. For example the authorize bladelet embodiment of credential authorization in an AONS bladelet has built in authorization methods based on LDAP Groups SAML Assertions or rules.

The extension authorizer can be configured to invoke an extension authorization in extension packages for authorization methods that do not have built in support. The extension packages for non built in authorization methods may be deployed before or after the installation of the router A in a network. In a preferred embodiment the authentication and authorization logic does not require a particular extension package unless a corresponding non built in authorization method is to be supported. However when a non built in authorization method is to be supported at runtime the extension authorizer is configured accordingly and the extension authorization is transferred to the network infrastructure element A.

An extension authorization can be developed in a programming language that makes use of application programming interfaces hereinafter APIs to support a particular authorization method. For example an extension authorization can be developed in JAVA that makes use of SiteMinder JAVA Agent APIs to support SiteMinder Authorization. In a preferred embodiment the configuration that directs the extension authorizer to use the extension authorization thus developed can be specified in AONS Design Studio. Both the configuration and the extension authorization can be provisioned to the network infrastructure element A to form an extension package before its use by the extension authorizer at runtime. In a preferred embodiment the configuration and the extension package can be pre packaged into a downloadable file in AONS Design Studio and subsequently downloaded to an AONS node.

When the extension authorization is invoked it is made available all the required and optional parameters by the authentication and authorization logic . The extension authorization reads configuration parameters relevant to accessing an authorization service provider or a database that stores necessary information for authorization. In some embodiments the parameter list values and access routines for parameters are configured for a particular authorization method and authorization service provider in authentication and authorization logic . In a preferred embodiment the parameter list values and access routines for parameters can be pre packaged into a downloadable file in AONS Design Studio and subsequently downloaded to an AONS node. For example as a part of extension configuration in AMC a user configures necessary and optional parameters including those required for connecting to an authorization service provider such as SiteMinder Policy Server from CA.

At runtime the extension authorization uses the parameters performs the authorization method and returns the result.

If the authentication and authorization tasks complete successfully the authentication and authorization logic directs the application message to a receiving application server A.

Thus the extension validator extension authorizer extension package which may include extension authentication or extension authorization represent an extensibility mechanism for the authentication and authorization logic .

There may be multiple extension packages deployed in a network infrastructure element A. In various embodiments an extension package may provide support for authentication only or for authorization only or both. Thus the SiteMinder extension package discussed above which supports both authentication and authorization is described solely to present a clear example and not as a limitation. Furthermore an extension package may provide support for authentication and or authorization using service providers other than SiteMinder as discussed. In one embodiment authentication and or authorization service is provided by Tivoli Access Manager from International Business Machine Corp. Armonk N.Y. Thus network elements A need not depend on a particular authentication and or authorization service provider such as SiteMinder. Any authentication and or authorization provider that is capable of performing authentication and authorization service upon a request by an extension package described herein is within the scope of the present invention. Thus the use of SiteMinder in an embodiment is not required and all references herein to SiteMinder are provided merely to illustrate a clear example and not as limitations.

In an embodiment support for a new authentication or authorization method by the network infrastructure element A can be disabled or enabled without requiring changes in implementation or re building of the network infrastructure element code. In this embodiment a user can easily enable or disable a method for business reasons such as a change in a business partner relationship involving an authentication or authorization service provider. Also a supplier for network infrastructure element A may need to enable or disable support for a specific method based on a licensing agreement or possibly different product bundling needs.

At step for each incoming message received from a data network coupled to the network infrastructure element A certain other steps are performed. In step the type of the application message is determined by the network infrastructure element A. The type of an application message may be determined on a number of attributes carried by the application message or the underlying packets associated with the application message. Attributes capable of identifying application message types include endpoints addresses or ports universal resource locations URL at HTTP level special fields in the message or regular expression patterns. Additionally or alternatively attributes capable of identifying application include any standard or proprietary tokens embedded in a message or underlying packet that identifies a particular type for an application message. For example a string constant denoting an application name may be embedded in an application message in a proprietary manner to identify a particular application type.

If the incoming message is not a type that has been configured for authentication and authorization in step the authentication and authorization logic passes the message to logic in the network infrastructure element A for further processing such as forwarding the message towards its intended destination. If the incoming message is a type of an application message that has been configured for authentication and authorization in step the credential extraction determines whether user credential location definitions should be consulted. For a plurality of application message types the user credentials may be located in standard locations. In step the credential extraction identifies the user credentials in those standard locations. For some application message types on the other hand the user credentials may be located in a proprietary locations or non standard locations. In step a user credential location is selected for definitions corresponding to one such application message type as appropriate and in step the user credentials in those locations are identified.

If step determines that the identification of user credential has failed then error handling is invoked at step . The error handling may include logging the error and suppressing the erroneous message from being further forwarded to its intended destination. If the identification of use credential is successful as determined at step then the credential validation is invoked and at step the process determines whether a built in or extension authentication method is associated with the message type. If the incoming message is of a type that associates with an extension authentication method then at step processing is passed to the extension validator which handles invocation of the extension authentication method provided by extension authentication in extension package and which passes all the parameters necessary or optional for the invocation of the extension authentication method. If the incoming message is of a type that associates with a built in authentication method at step then processing is passed to the validator for executing the specified built in authentication method.

At step the credential validation determines the result of the authentication method whether it is built in or extension. If the authentication method has failed to authenticate the identity processing is passed to step for error handling. If the user identity associated with user credentials has been successfully authenticated then credential authorization is invoked and at step determines whether an authorization method has been specified for the message type. If not the authentication and authorization logic passes the message at step to logic in the network infrastructure element A for further processing such as forwarding the message towards its intended destination.

If the incoming message is of a type that associates with an extension authorization method at step processing is passed to the extension authorizer which handles invocation of the extension authorization method provided by extension authorization in extension package and which passes all the parameters necessary or optional for the invocation of the extension authorization method. If the incoming message is of a type that associates with a built in authorization method at step processing is passed to the authorizer for executing the specified built in authorization method.

At step the credential authorization determines the result of the authorization method whether it is built in or extension. If the authorization has failed to authorize privileges required for the application message type for the identity for whatever reason processing is passed to step for error handling. Else if the user identity associated with user credentials has been successfully authorized for the privileges required for the application message type the authentication and authorization logic passes the message at step to a logic in the network infrastructure element A for further processing such as forwarding the message towards its intended destination.

In an embodiment AONS comprises a set of software modules hosted on a network infrastructure element such as a router or switch that can identify application messages from packet flows perform operations on the applications messages and perform application functions on behalf of applications clients and servers. Examples of operations and functions include format transformation payload changes based on policy performing load balancing decisions sending messages to monitoring stations and creating log entries notifications and alerts according to rules. AONS complements existing networking technologies by providing a greater degree of awareness of what information is flowing within the network and helping users to integrate disparate applications by routing information to the appropriate destination in the format expected by that destination enforce policies for information access and exchange optimize the flow of application traffic both in terms of network bandwidth and processing overheads provide increased manageability of information flow including monitoring and metering of information flow for both business and infrastructure purposes and provide enhanced business continuity by transparently backing up or re routing critical business data.

AONS integrates with network layer support to provide a more holistic approach to information flow and management mapping required features at the application layer into low level networking features implemented by routers switches firewalls and other networking systems. In an embodiment a data processing unit blade in a router or switch hosts and executes one or more AONS software modules bladelets to implement the functions herein.

According to one embodiment an AONS blade in a router or a switch performs the actions discussed herein.

Router A receives packet flows such as packet flows A B. More specifically packet flows A B received by router A are received by supervisor blade . Supervisor blade may comprise a forwarding engine and or a route processor such as those commercially available from Cisco Systems Inc.

In one embodiment supervisor blade classifies packet flows A B based on one or more parameters contained in the packets of those packet flows. If the parameters match specified parameters then supervisor blade sends the packets to a specified one of AONS blade and or other blades A N. Alternatively if the parameters do not match any specified parameters then supervisor blade performs routing functions relative to the particular packet and forwards the particular packet on toward the particular packet s destination.

For example supervisor blade may determine that packets in packet flow B match specified parameters. Consequently supervisor blade may send packets in packet flow B to AONS blade . Supervisor blade may receive packets back from AONS blade and or other blades A N and send the packets on to the next hop in a network path that leads to those packets destination. For another example supervisor blade may determine that packets in packet flow A do not match any specified parameters. Consequently without sending any packets in packet flow A to AONS blade or other blades A N supervisor blade may send packets in packet flow A on to the next hop in a network path that leads to those packets destination.

AONS blade and other blades A N receive packets from supervisor blade perform operations relative to the packets and return the packets to supervisor blade . Supervisor blade may send packets to and receive packets from multiple blades before sending those packets out of router A. For example supervisor blade may send a particular group of packets to other blade A. Other blade A may perform firewall functions relative to the packets and send the packets back to supervisor blade . Supervisor blade may receive the packet from other blade A and send the packets to AONS blade . AONS blade may perform one or more message payload based operations relative to the packets and send the packets back to supervisor blade .

In one embodiment executing the flow comprises executing each step i.e. bladelet action of the flow. If a bladelet is to be run within a separate context then AMEC framework may enqueue into bladelet specific queues and based on thread availability dequeue appropriate bladelet states from each bladelet queue.

In one embodiment the following tools are provided for creating extension package for authentication and authorization in an AONS node a custom bladelet software development kit hereinafter Custom Bladelet SDK a design studio or ADS and an admin tool or AMC all commercially available from Cisco Systems Inc. A designer uses Cisco Custom Bladelet SDK java editor or other third party tools to write Java code that will provide bladelet functionality. ADS is a visual tool for designing flows and applying message classification and mapping policies. AMC is a web based interface to perform all administration and configuration functions.

At step the designer interacts with ADS and creates an authentication authorization extension package. As a part of creating the package the designer provides a number of artifacts. First the designer provides one or more JAVA .jar files implementing an extended authentication method and necessary libraries. For example in case of a SiteMinder extension the designer provides the jar files implementing a SiteMinder Java Agent functionality and a number of library files referenced directly or indirectly by the SiteMinder Java Agent such as smjavaagentapijar smjavasdk2.jar libsmagentapi.so and libsmjavaagentapi.so for SiteMinder Release 5.5 commercially available from CA.

Additionally the designer provides bladelet extension info XML files for the custom bladelets using bladelet extension info schema defined in Cisco Custom Bladelet SDK. Table 2 shows an example bladelet extension info XML file for SiteMinder authentication that can be used in an implementation.

The designer further provides parameters that are needed to perform the extension authentication and authorization method. The parameters may be defined by an attribute domain. Table 3 shows an example attribute domain for SiteMinder authentication that can be used in an implementation.

In one embodiment the authentication authorization extension package created with the above artifacts is saved as a bar file on a disk.

At step an administrator uploads and registers the authentication authorization extension package to AMC . Once loaded and registered the authentication authorization extension package is available for use in ADS.

At step the designer causes ADS to synchronize with AMC to retrieve the authentication authorization extension package which has been enabled and made available by the AMC uploading and registering step .

At step the designer continues his or her designing tasks of defining message flows between bladelets message types user credential location definitions and any associations of user credential location definitions with the message types.

At step the administrator causes AMC to synchronize with ADS to retrieve the flows message types user credential location definitions and associations defined in step .

At step the administrator deploys to an AON blade the extension package and a policy comprising of the message flows message types user credential location definitions and associations of the user credential location definitions with the message types and enable the AON blade to use the authentication authorization method available in the extension package.

Embodiments of an approach for controlling computer program extensions in a network device are now described with reference to through inclusive. As background AON devices from Cisco Systems Inc. are believed to be the first programmable network devices in which program code can be dynamically uploaded to a running network device to extend the functionality available on the network device. In an embodiment techniques are provided to protect the network device against deployment of malicious code on the device that results in disrupting or preventing the normal behavior of the network device.

In an embodiment a control module is implemented as a Java program that controls security of the network device and ensures that the appropriate permissions are available. In this context a permission is a specific action that designated program code is allowed to perform. Various embodiments improve upon the JVM security implementation in several ways. In one embodiment the control module does not require the JVM to be restarted when new code is deployed to the network device for execution on the JVM and the when the new code is subject to different security policies. Other embodiments may be used with C C or other language environments.

In an embodiment the control module is configured using a novel XML based descriptor file that simplifies the editing and maintenance of the standard JVM security policy file. In an embodiment the control module allows multiple security policy files to be active in the JVM for multiple different code sources. In contrast a standard JVM implementation only allows a single security policy file.

In an embodiment the control process implements an inheritance mechanism that can be overridden by each code source. The control module determines which permissions can be overridden and which permissions cannot have an override. For example the Java call System.exit cannot be overridden by newly deployed code. However the ability to write to the local filesystem is disabled by default but the default write permission can be overridden to allow writing to the filesystem.

In an embodiment security policy is expressed as restrictions or permissions. In conventional Java security approaches resources must be granted explicit access when a security policy is in effect. For example if a user needs to restrict access to the usr temp directory on a filesystem then the Java security policy schema requires the user to explicitly grant access to all subdirectories in the usr directory. The restriction on usr temp is enforced by the fact that permissions have not explicitly been granted to that directory. In contrast in an embodiment herein the user can restrict access to usr temp by adding a new permission type to the Java security policy schema. In an embodiment a new control process interacts with the standard Java security manager to enforce restrictions system default permissions and user program extension permissions that override system default permissions.

As a result the approaches herein allow a network administrator or user to provision custom programs into a network device and provide a secure sandboxed environment in which custom programs can execute without harming the network device. The administrator can determine what external systems or resources a custom program can access and what operations the custom program can perform. The developer of a custom program can specify and apply the security policy for the custom program at runtime without stopping operation of the network element. The network element does not require a new image. Instead the program extensions and security policy can be installed by a third party developer after the network element is deployed. The approaches improve the security mechanism provided by a conventional JVM and allow security policies to be dynamically created and applied.

Certain embodiments provide significant benefits over prior approaches. For example embodiments provide a secure environment in which custom programs that are deployed in a network device can execute. An embodiment can provide a data driven approach to easily customize and extend the security capabilities of the device. An embodiment can provide a language independent mechanism to express security permissions so that the security can be leveraged regardless of the implementing language. An embodiment can create a programming paradigm and provide a container in which custom code can execute in a secure manner regardless of the implementing language.

Network equipment manufacturers may use the approaches herein to support dynamic deployment and execution of custom code in a network device.

Application program comprises any logic program code or other software element that performs a useful function on computer system and is capable of extension by other logic program code or other software elements. The user program extensions comprise custom code or other user defined methods objects routines or other software elements that extend features or functions of application program . For example user program extensions can comprise implementations of methods that are defined in an API of application program new methods to implement functions not found in application program or any other programmatic element. An example of an application program is an authentication process. An example of a user program extension is an authentication method that is not supported in application program when originally deployed.

In an embodiment a user creates user program extensions separate from computer system and then uploads and installs the extensions to the computer system. Any convenient mechanisms may be used to create upload and install the extensions.

In an embodiment application program and user program extensions are coupled to Java Virtual Machine . In other embodiments virtual program execution environments other than a JVM may be used. A control module is coupled to the JVM . The control module comprises one or more computer programs or other software elements that implement the functional approaches herein.

System default permissions and user extension permissions are coupled to control module . System default permissions represent security restrictions or permissions that apply by default. Typically the system default permissions are provided in the computer system when the computer system is initially deployed or shipped to a customer. Control module may incorporate logic that determines whether any of the system default permissions can be overridden by conflicting user extension permissions .

The user extension permissions comprise security restrictions or permissions that have been user defined and installed after resolving any conflicts with the system default permissions. Thus the vendor or creator of computer system can provide for a restrictive security policy using system default permissions but can allow the user extension permissions to override the default permissions. The control module informs the JVM about the permissions.

In this context although the term permissions is used herein in reference to and other embodiments a security policy may be defined and deployed in terms of restrictions upon program actions rather than permissions to perform program actions. Thus all instances of the term permissions herein include the use of restrictions as an alternative variation or addition. Further in the description herein a policy is an abstract statement of a security permission or restriction that is created and stored outside a network element and a permission or restriction is an embodiment of the policy within the network element that controls whether program actions can access or use specified resources functions or methods.

Java security manager comprises static security restrictions that are established at compile time or development time and implemented natively by the JVM . Control module can add permissions to Java Security Manager to modify the Java security model. In an embodiment control module is a Java class that extends Java Security Manager . When application program or user program extensions request access to a network resource Java Security Manager intercepts the request and then requests control module to determine whether permission is allowed. Based on user extension permissions the control module determines whether permission is allowed. Thus control module acts as an overriding security manager in this context.

Operating system hosts functional components that are shown above the OS in and controls access to one or more physical resources such as storage devices and I O devices. Physical resources may include one or more network interfaces to network which may comprise a LAN WAN internetwork or a combination thereof. One or more network resources are coupled to the network . Network resources may comprise web sites FTP sites server applications graphic images printers servers or any other documents systems or processes that are accessible over a network. Embodiments may control resources other than those physical resources and network resources that are enumerated in this paragraph such as programs local disk network storage etc. Embodiments may control actions performed on resources such as reading writing forking new programs etc.

A system program security policy and one or more user extension security policies may be coupled to network or stored in computer system . In one embodiment policies comprise electronic documents that express security policies in a structured or abstract written format. Generally security policies associate or map programs resources that the programs may or may not access and actions that the programs may or may not perform with respect to the resources. Control module includes logic to parse the policies and install permissions in computer system based on parsing the policies and resolving conflicts among the policies. Processes for performing parsing and conflict resolution are described further below.

The system program security policy typically is created by a vendor or creator of the control module and is not visible to a user of the computer system such as a customer or network administrator. In contrast a customer or software developer can create and modify the one or more user extension security policies . In this approach the vendor can define the system program security policy in a confidential manner so that the customer s user extension security policy cannot change or override certain permissions. Therefore certain critical processes of the computer system can be protected. Indeed in an embodiment the system program security policy can specify that a user program extension cannot overwrite a file containing the policy . In an embodiment documentation or written records can specify the default restrictions and default permissions so that the customer has knowledge of what it cannot override and what it can override.

For purposes of illustrating a clear example shows one user extension security policy and one set of user extension permissions . However other embodiments may use any number of policy documents and permissions.

In step one or more user program extensions are received and installed. For example a software developer creates and stores user program extensions in a development computer system and then uploads the extensions to the computer system . The approaches described above for implementing authentication extensions may be used to implement step .

In step a system program security policy is received and installed as one or more system default permissions. For example an XML document is received that defines a set of system default security permissions or restrictions. The policy document is parsed and one or more system default permissions are created and stored in computer system .

The default permissions and user extension permissions may be stored in an object model in memory. Thus in permissions represent data that has been parsed from the policies and stored in an object model. In an embodiment permission data may be stored in a cache. In an embodiment policies are provisioned into permissions using the provisioning approach described above for .

As seen in a codebase identifier is associated with one or more permissions or restrictions . Each permission or restriction has a type name and actions . Table 4 is an example system default security policy expressed in the form of an XML document 

The example policy document comprises a plurality of policies. In general the policy document specifies which security schema elements an extension program is permitted to override and which security schema elements an extension program cannot override. The tags or tags delimit each policy.

Each pair of tags defines a security schema element that an extension program can override which comprises a codebase declaration and one or more permissions. A codebase declaration specifies a filesystem location from which a program code module could be loaded thus the codebase declaration asserts that any program code module loaded from the specified filesystem location is permitted to override the schema element named in the permissions that are described next in the policy document.

The tags delimit resources or methods that a user extension program is not permitted to override. Thus in the example above the tags indicate that a user extension program cannot grant permission to access the exitVM Java method. No codebase identifier appears with the tags indicating that the restriction applies to all user extension program code. In one embodiment restrictions are imposed on exiting the JVM creating a Java policy security manager setting a custom security manager reflecting permissions and changing system streams.

Each permission comprises a name a target and one or more actions. The name identifies a security schema element that an extension program can override typically the name identifies a JVM security schema element. The target identifies one or more methods to which the associated permission applies. The actions specify one or more actions that a program is allowed to perform using the target methods such as read write etc.

In step a user extension security policy is received and parsed. The same parsing creating and storing process may be used for the user extension security policy as for the system program security policy. Table 5 is an example user extension security policy expressed in an XML document 

The example user extension security policy has the same structured format as described above for the example system default security policy except that a user extension security policy does not contain restrictions only permissions. Placing a security policy file such as Table 5 in a SCAR file causes all code in the SCAR file to be governed by the override permissions specified in the security policy file and by the default permissions.

As seen from both Table 4 and Table 5 embodiments provide a flexible mechanism for declaring editing and modifying a security policy of a JVM or other program environment. The use of an XML document with clear structured tags enables defining a security policy in a manner that is far more understandable than conventional approaches for declaring a JVM security policy using a program configuration file and arcane code declarations.

Further in conventional Java practice a single security policy is declared using the d compile time switch. Only one configuration file containing security policy may be specified in that approach. In contrast in the approach herein multiple user program extensions may be created and uploaded at different times and each of the extensions may define a different user extension security policy . For example a first user extension security policy could override a first default permission and allow a particular program extension to access a particular resource but a second user extension security policy need not grant permission to access the same resource for a different program extension. Different developers can create the first and second security policy at different times for different user program extensions.

In step a test is performed to determine whether any permission stated in the user extension security policy conflicts with a system default restriction. Thus the test of step determines whether the user extension security policy matches a policy declaration in the system default policy. If so then step determines whether the user extension policy is permitted to override the system default policy. Together steps determine whether the user extension security policy impermissibly attempts to override a system default security policy. For example in Table 2 the first permission declaration impermissibly attempts to override the exitVM method which has been declared in Table 1 as restricted.

If a conflict is found and a system override is not permitted then in step a warning is generated and the user extension security policy is rejected. Step may include any of a variety of warning mechanisms such as issuing a programmatic exception sending an error message event alert or other notification displaying a warning etc. Rejecting the user extension security policy may comprise not installing only the conflicting user extension permission rather than rejecting the entire policy document.

If no conflict is found or a conflict is found by a system override is permitted then in step the user extension security policy is installed as one or more user extension permissions. Using this approach the program security schema of a system such as computer system can be selectively extended by user action without introducing harmful careless or dangerous extensions of permissions.

Once user extension permissions are installed the extensions may be used to govern how extensions to application programs are allowed to access system resources and network resources. is a flow diagram of processing default and user extension permissions. In step a request is received from a user program extension to perform an operation. The request may comprise a programmatic request to read a file write a file open a resource etc. The request may comprise any mode or mechanism for attempting to obtain access to any form of computer resource.

Step tests whether the requested action is permitted according to any of the installed user extension permissions. In an embodiment user extension permissions are stored in a policy store of the computer system and step involves locating a matching permission based on the program request and determining if a matching action is specified in the permission. described further herein is one example of how to identify related user extension permissions.

If step is affirmative then in step one or more conventional Java sandbox permission controls are applied. Thus step represents one example implementation in which a Java application executes using the JVM and the JVM enforces standard Java sandbox controls. If enforcement of Java sandbox controls yields an error then an exception is generated at step . If no error occurs then in step the requested action is permitted and control ends at step . Permitting a requested action may involve permitting access to a programmatic method subroutine or other software element or permitting use or access to a system resource or network resource.

If step is negative then step tests whether the system default permissions permit the action. If so then control proceeds to step as described above. If the system default permissions do not permit the requested action then in an embodiment the action is inherently restricted and a system default permission exception is generated at step . Step may involve generating an error message exception message or any other form of event alert or notification. After an exception control returns to a calling process or program at step .

Alternatively actions may be permitted by default unless the system default policy specifies restrictions.

Step determines a location from which the identified class has been loaded. For example the classpath of the class of step is determined.

Step determines the name of a target resource that the user program extension is requesting to use. The target resource may comprise a method object system resource or network resource. Step determines what action the user program extension is requesting to perform. Example actions including reading writing connecting resolving etc.

Step searches a policy store based on the location name and action that have been determined. For example step involves matching the location name and action specified in a request of a method of a user program extension to key fields in a policy store that hold corresponding locations names and actions of installed permissions. As a result a matching permission may be found. A similar process may be used to locate a matching restriction.

Computer system includes a bus or other communication mechanism for communicating information and a processor coupled with bus for processing information. Computer system also includes a main memory such as a random access memory RAM flash memory or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk flash memory or optical disk is provided and coupled to bus for storing information and instructions.

A communication interface may be coupled to bus for communicating information and command selections to processor . Interface is a conventional serial interface such as an RS 232 or RS 422 interface. An external terminal or other computer system connects to the computer system and provides commands to it using the interface . Firmware or software running in the computer system provides a terminal interface or character based command interface so that external commands can be given to the computer system.

A switching system is coupled to bus and has an input interface and an output interface to one or more external network elements. The external network elements may include a local network coupled to one or more hosts or a global network such as Internet having one or more servers . The switching system switches information traffic arriving on input interface to output interface according to pre determined protocols and conventions that are well known. For example switching system in cooperation with processor can determine a destination of a packet of data arriving on input interface and send it to the correct destination using output interface . The destinations may include host server other end stations or other routing and switching devices in local network or Internet .

The invention is related to the use of computer system for extensible authentication and authorization in a network infrastructure element. According to one embodiment of the invention extensible authentication and authorization in a network infrastructure element is provided by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. One or more processors in a multi processing arrangement may also be employed to execute the sequences of instructions contained in main memory . In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infrared data communications.

Common forms of computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infrared transmitter to convert the data to an infrared signal. An infrared detector coupled to bus can receive the data carried in the infrared signal and place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Communication interface also provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the worldwide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface . In accordance with the invention one such downloaded application provides for extensible authentication and authorization in a network infrastructure element as described herein.

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

