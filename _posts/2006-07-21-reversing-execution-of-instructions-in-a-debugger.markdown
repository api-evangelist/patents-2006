---

title: Reversing execution of instructions in a debugger
abstract: A method can include receiving navigational debug input from a debugger interface including input to traverse input code in a plurality of modes; in response to receiving the navigational debug input, a) saving state of a program being executed in a corresponding debugger, including creating a child process from a currently executing process, and b) executing a portion of the program, wherein executing the portion of the program comprises suspending the created child process, and continuing to execute the currently executing process; receiving input to reverse execution of the portion of the program; and restoring the saved state of the program, wherein restoring the saved state of the program comprises suspending the currently executing process and activating the suspended child process. The navigation input can include input to single-step, step over a function, step into a function or set a breakpoint in programming code running within the corresponding debugger.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07836430&OS=07836430&RS=07836430
owner: Apple Inc.
number: 07836430
owner_city: Cupertino
owner_country: US
publication_date: 20060721
---
A computing system may perform numerous operations including receiving input processing the received input or other data in response to the received input and providing output. For example a general purpose computer may receive input from a keyboard mouse touch screen voice command processor or input sensor process the received input to manipulate for example text or graphics in a document numbers in a spreadsheet entries in a database or data of various forms e.g. multimedia retrieved from various sources e.g. a network or otherwise control other devices e.g. other computing devices other machines input or output devices etc. and provide output for example in the form of graphical output on a display screen audio output from a sound producing device hard copy output from a printing device digital output to a storage device or control output to control a physical machine.

To receive input process the input and provide output the computing system may employ a combination of physical resources e.g. hardware and various levels of programming code e.g. software . For example the computing system may employ hardware such as a controller or microprocessor physical memory and various input and output devices. The computing system may also employ an operating system that interacts directly with and manages the hardware and various application programs that run on top of the operating system and that perform operations involving receiving input processing the input and providing output.

Because of the typical complexity of application programming code that is used to implement many computing applications and because of the complexity of underlying hardware and software on which the application programming code may be executed application developers can employ a debugger to incrementally analyze and debug the application code. A debugger can enable the developer to execute small portions of the application programming code in various modes and to observe the effect of the execution of the small portions on the underlying hardware and software. For example the debugger can enable the developer to set a breakpoint in the code the debugger can execute code before the breakpoint then pause execution of the code at the breakpoint to allow the developer to inspect variables or files maintained by the code or to inspect lower level resources such as registers or pointer values maintained by for example hardware registers. As another example the debugger can enable the developer to single step through code to see the effect of execution of single instructions or small groups of instructions. As another example the debugger can enable the developer to step over a particular module of code e.g. a function to allow the developer to analyze the effect of execution of the particular module of code without forcing the developer to pause at each instruction or group of instructions in the module of programming code. As another example the debugger can enable the developer to step into a particular module of code to allow the developer to analyze in greater detail the effect of execution of small portions of the code.

In some implementations the debugger can also enable the developer to undo an operation previously performed by the debugger e.g. execution from a first breakpoint to a second breakpoint performance of a single operation performance of a step over operation performance of a step into operation etc. To undo the previously performed operation the debugger can cause the programming code and underlying hardware and software to be reset to a previous state without re executing a potentially large preceding portion of the code. Such a feature may be particularly useful if the previously executed code caused a serious or fatal error in execution that may otherwise force the developer to restart the debugging operation.

In some implementations a method includes receiving navigational debug input from a debugger interface including input to traverse input code in a plurality of modes in response to receiving the navigational debug input a saving state of a program being executed in a corresponding debugger including creating a child process from a currently executing process and b executing a portion of the program wherein executing the portion of the program includes suspending the created child process and continuing to execute the currently executing process receiving input to reverse execution of the portion of the program and restoring the saved state of the program wherein restoring the saved state of the program includes suspending the currently executing process and activating the suspended child process. The navigation input can include input to single step input to step over a function input to step into a function or input to set a breakpoint in programming code running within the corresponding debugger.

In some implementations a method includes executing a program in a debugger receiving navigational debug input from a corresponding debugger interface in response to receiving the navigational debug input a saving state of the program being executed in the debugger and b executing a portion of the program receiving input to reverse execution of the portion of the program restoring the saved state of the program and continuing execution of the program based on the restored saved state.

Receiving navigational debug input can include receiving input to single step step over a function step into a function or set a breakpoint in programming code running within the debugger. Saving state of the program can include forking a process corresponding to a currently executing process suspending the forked process and continuing to execute the currently executing process. Saving state of the program can include saving at least one of current register values of a processor executing the program a value of an instruction counter that stores addresses of successively executed instructions as the processor executes the program or a value of a stack pointer that points to a portion of a stack employed by the processor. Restoring the saved state of the program can include suspending the currently executing process and activating the suspended forked process. Receiving input to reverse execution of the portion of the program can include receiving input corresponding to selection of a reverse execution icon in the debugger interface.

The method can further include determining whether execution of the portion of the program comprises writing to or reading from shared memory or writing to or reading from an input output interface. The method can further include displaying the reverse execution icon in a first format if execution of the portion of the program comprises writing to or reading from the shared memory or writing to or reading from the input output interface and displaying the reverse execution icon in a second format if execution of the portion of the program does not comprise writing to or reading from the shared memory or writing to or reading from the input output interface. In some implementations the first format includes a first coloring and the second format includes a second coloring for example the first coloring can be red and or the second coloring can be green.

The method can further include saving supplemental state if execution of the portion of the program comprises writing to or reading from the shared memory or writing to or reading from the input output interface the supplemental state comprising a value read from or written to the shared memory or the input output interface. The method can further include receiving input to re execute the portion of the program after receiving input to reverse execution of the portion of the program and re executing the portion of the program in response to receiving the input to re execute the portion. Re executing the portion of the program can include re executing only those instructions in the portion of the program that do not write to or read from shared memory or write to or read from an input output interface.

The method can further include displaying a value from the supplemental state corresponding to an instruction that is not re executed. The method can further include displaying a re execution icon in the debugger interface wherein receiving input to re execute the portion of the program comprises receiving user input selecting the re execution icon. Displaying the re execution icon can include displaying the re execution icon in a first format if any instruction in the portion of the program includes writing to or reading from shared memory or writing to or reading from an input output interface and displaying the re execution icon in a second format if no instruction in the portion of the program comprises writing to or reading from shared memory or writing to or reading from an input output interface.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

To fetch instructions in the instruction fetch stage the computing system can use an instruction fetch unit a memory interface A and one or more memory mapped devices that store the instructions to be fetched. In some implementations as shown the memory mapped devices include temporary data storage and persistent data storage . The temporary data storage can be volatile memory such as SDRAM synchronous dynamic random access memory DDR double data rate memory devices or other memory devices that provide relatively fast access to data while the computing system is powered. The persistent data storage can be nonvolatile storage such as a hard disk drive or optical drive that retains data even when the computing system or persistent data storage device is not powered. Typically the persistent data storage has a larger capacity than the temporary data storage but the persistent data storage can also have longer data access times than the temporary data storage . In some implementations the computing system transfers programming instructions from the persistent data storage to the temporary data storage to facilitate faster access to programming instructions that are to be currently or imminently executed.

As depicted in the instruction fetch unit retrieves programming instructions from one of the memory mapped devices through the memory interface A. The memory interface A can receive an address that specifies a memory location e.g. a memory location that stores a programming instruction and access a specific memory device corresponding to the specified memory location. In some implementations the memory interface A includes a memory manager not shown that decodes and resolves addresses to individual memory devices based on a global memory map. In some implementations the memory interface A includes discrete address decoding logic that can be included in the specific memory devices themselves.

To track the next instruction to fetch the instruction fetch unit can in some implementations use a program address pointer sometimes referred to as an instruction pointer or program counter. Typically the program address pointer stores or points to an address of the next instruction to be fetched. In some implementations the program address pointer is automatically incremented by a fixed number each time an instruction is retrieved. The fixed number may depend on the number of bytes that are included in each instruction. For example in a system in which individual bytes are accessible and in which instructions are four byte words the program address pointer can be automatically incremented by four each time an instruction is fetched. The program address pointer can also be adjusted by other stages based for example on the contents of fetched instructions. In particular the decode stage can decode branch or jump or call instructions and can cause the program address pointer to be adjusted based on contents of an immediate value included in instructions the execution stage or write back stage can retrieve a value from one of the memory mapped devices or from a register registers described in more detail below and cause this value to be stored in the program address pointer .

Once an instruction is fetched the instruction can be decoded in the decode stage by for example an instruction decode unit . In some implementations the instruction decode unit can parse each instruction into for example an operation code opcode register operands or immediate values. Opcodes are in some implementations numeric codes that represent instructions that are predefined for a particular microprocessor or family of microprocessors. Based on the opcode the instruction decode unit can control other aspects of the computing system in particular an execution unit .

The execution unit can perform various operations on input operands to produce an output value. The operations can include for example mathematical operations e.g. add subtract or multiply logical operations e.g. AND OR XOR NAND or bit shifting operations. In some implementations the execution unit includes an arithmetic logic unit ALU not shown or a floating point unit FPU not shown to perform the above described operations. Generally the execution unit receives the input operands from registers and the specific registers from which the execution unit receives input and the specific operation to perform can be specified by the instruction decode unit . As an example a sequence of instructions may cause the execution unit to add a first number to a second number. In particular a first instruction may cause the first value to be stored in a first register register R not shown a second instruction may cause the second value to be stored in second register e.g. register R not shown a third instruction may cause the execution unit to add the values stored in R and R and save the result in a third register e.g. register R not shown .

Because results of execution of some instructions may be stored in memory rather than in a register the computing system includes a memory interface B. As shown the memory interface B is included in the write back stage . The memory interface B can cause data to be stored in one of the memory mapped devices . In some implementations the memory interface B also can retrieve data from one of the memory mapped devices and store the retrieved data in one of the registers or as described above in the program address pointer .

The memory interface B and the memory interface A can be part of the same overall memory interface or the memory interfaces B and A can be separate interfaces. Moreover the memory mapped devices can be mapped in one or more address spaces. For example a von Neumann architecture employs a single memory space for both data and instructions whereas a Harvard architecture employs separate memory spaces for data and instructions.

In operation the computing system can retrieve a sequence of programming instructions and decode and execute the instructions to perform operations that together make up a computing application. Typically the computing application involves interaction with a user or another device and to facilitate such interaction the computing system includes various input output devices of which a keyboard pointing device video display and network interface are examples. The computing system can interface with many other input output devices that are not shown e.g. printing devices networked storage facilities voice command processors machine sensors and actuators etc. 

As shown the various input output devices are memory mapped. That is the execution unit receives input from a device such as the keyboard or pointing device by retrieving data from a memory mapped location corresponding to the input device. Similarly the execution unit provides output to a device such as the video display by writing data to a memory mapped location corresponding to the output device. Other input and output schemes not involving memory mapped devices are also possible but are not illustrated in the figures or described in detail as any suitable input output scheme can be used.

At any given time the computing system has a state that characterizes its operation. In some implementations the state includes current values of the registers information that characterizes pending instructions e.g. information from the instruction decode unit and information about instructions that are about to be fetched e.g. contents of the program address pointer . State can be important to the operation of the computing system in cases where execution of a sequence of instructions is interrupted. For example the computing system may be required to process an interrupt a possibly asynchronous event that may be of higher priority than the currently executing sequence of instructions and that may require substantially immediate attention. To process the interrupt the computing system saves its current state processes the interrupt then restores the saved state and continues processing the sequence of instructions where it left off before the interrupt as captured by the saved and restored state. As another example a first sequence of instructions may repeatedly call a second sequence of instructions e.g. a function or procedure to perform a specific operation. Before calling the second sequence of instructions the computing system can save its current state execute the second sequence of instructions then restore the state and continue executing the first sequence of instructions based on the restored state. As described with reference to state can also be used to allow the computing system to execute several computing applications seemingly simultaneously.

In some implementations the operating system is the lowest level software run by the computing system generally the operating system directly interacts with the resources and provides an abstraction layer to higher level software applications such as applications A B or C. That is the operating system can provide a standardized interface to the resources regardless of the exact architecture or specifications of those resources. For example the operating system can employ an I O manager to provide application programs with a standard interface for displaying output to the video display or for receiving input from pointing device . The interface can be standard in the sense that common commands can be used in some implementations to provide output to for example a 19 flat panel display produced by one manufacturer or a 15 CRT display provided by a second manufacturer. To convert commands received by such a standard interface the I O manager can employ various specific drivers not shown which can be transparent to the application programs that provide output to the video display . Similarly the I O manager can employ other specific drivers to facilitate a common application programming interface API to the pointing device regardless of whether the pointing device is for example a two button wired mouse or a wireless three button mouse with a track wheel.

As shown the operating system employs a process manager and a memory manager to efficiently manage the resources and allow many application programs to run seemingly simultaneously. In some implementations the process manager allocates application program access to certain resources e.g. the microprocessor in time slices. That is each application or task can be allocated a slice of time during which programming instructions corresponding to that application or task are executed. At the end of the time slice the process manager can save state associated with the programming instructions associated with the time slice and start a new time slice in which different programming instructions corresponding to a different application or task can be executed. In the context of the operating system state generally includes more than just current values of registers in the microprocessor or information about instructions that to be fetched additional aspects of state will be described further below. After all pending applications or tasks have received access to the microprocessor the process manager can repeat the process restoring saved state as appropriate and allocating access to different applications or tasks in sequence. In this manner a large number of applications or tasks can be executed over a short period of time even in systems having only a single microprocessor or a single execution data path.

Because each application or task may require a substantial amount of temporary data storage memory the operating system can in the implementation shown employ a memory manager to ensure that each time slice has sufficient memory for the programming instructions to be executed in that time slice. In some implementations the memory is partitioned into units called pages and varying number of pages of temporary data storage are assigned to each application programmer task based on the amount of memory required by that application or task. If the total number of pages required by all of the pending application programs or tasks exceeds the available capacity of the temporary data storage the physical memory the memory manager can employ a swap file manager to swap an inactive page in the temporary data storage e.g. a page associated with an application program or task that does not currently have access to the microprocessor with another page from the persistent data storage sometimes referred to as virtual memory . In this manner currently executing application programs and tasks can have access to an amount of virtual memory that exceeds an amount of actual memory in temporary data storage . To maintain good performance e.g. low access times for data required by application programs and tasks with current access to the microprocessor the swap file manager can ensure that appropriate pages are always loaded in the temporary data storage .

In some implementations different applications or tasks may need to communicate with each other by passing data back and forth. To do so the operating system can in some implementations use a stack or shared memory . The operating system can allow a first application to push data on to the stack and allow a second application to pop the data off the stack in order to facilitate data transfer communication from the first application to the second application. Similarly the operating system can configure a portion of shared memory to be used as a communication facility between two or more applications or tasks.

As shown the stack is included in the temporary data storage and the shared memory is shown in the persistent data storage but this arrangement could be reversed or shared memory and a stack could be allocated in both the temporary data storage or the persistent data storage . In some implementations one or more of the registers holds information about the stack e.g. one register not shown may serve as a dedicated top of stack pointer and this information can be included in the state information that is saved and restored.

Some applications may process data files e.g. data files A or B which can be stored in the persistent data storage as shown or in the temporary data storage . Information about data files A B is also included in state information that is saved and restored. In particular the state information includes in some implementations files that are open and in use by particular application programs or tasks and can include pointers that identify particular locations within the data files to which information should be written to or read from next.

In some implementations the operating system as shown or one or more applications not shown includes debug resources . The debug resources can include a user interface by which a user e.g. a developer can debug code corresponding to different tasks the operating system or one or more of the application programs A B or C. In particular the debug resources can include the ability to control execution of individual programming instructions or groups of programming instructions. Example controls can include single stepping e.g. executing one instruction then pausing the execution setting a breakpoint and executing programming code up to the breakpoint stepping over code e.g. executing certain code such as programming code corresponding to a function or procedure then resuming a single step mode after the stepped over code has been executed stepping into code e.g. executing certain code such as programming code corresponding to a function or procedure in a single step mode or performing some other debug function. A corresponding debugger can also display various aspects of computing system state at different times. For example the debugger interface can in some implementations display register values stack pointer s or stack contents contents of shared memory information about currently executing processes information about open files pointers within such files states of physical or virtual memory or other information that may be useful to a developer debugging programming code.

In some implementations the debug resources are integrated in the operating system . In some implementations specific debug features can be included in application programming code e.g. applications A C if the programming code is compiled in a certain manner e.g. with debug flags set or with a certain compiler e.g. a special purpose debugging compiler . Various exemplary debugger features are now further described with reference to .

The user interface includes various information frames to allow a developer or other debugger user to track information about execution of certain programming instructions. For example a thread process frame can display information about various processes or threads that are tracked and periodically executed by the operating system . A variables frame can display information about variables or files maintained by software constructs e.g. in the currently executing application programming code or in the operating system or by the microprocessor e.g. register values or stack pointer values . A high level code frame can display information about lines of high level code that are currently being executed a machine code frame can display information about corresponding lines of machine code.

As used in this document high level code refers to programming code that is written in a so called high level programming language such as for example a compiled programming language like C or C or an interpreted programming language like JAVA. High level languages generally abstract the actual operation of the microprocessor that executes the programming code. In contrast low level or machine code languages refers here to programming code that is less abstract and more tied to the specific microprocessor that executes the programming code. In particular machine code generally is in the form of the native instructions of the specific microprocessor and refers to specific registers employed by that microprocessor.

In some implementations many lines of machine code correspond to a single line of high level programming code. In some implementations programming code can be single stepped at either the high level programming language level or the machine code level. When code is single stepped at the machine code level a developer who monitors the various information provided by the debugger can see the effect of each machine code programming instruction or the state of the computing device. When programming code is single stepped at the high level programming language level some implementations of the debugger interface display the overall effect of execution of a line of high level programming code other implementations automatically step through individual lines of the corresponding machine code at a user selectable rate allowing the user to see the effect of execution of programming code at a finer level of detail. The debugger interface shown in is merely exemplary the debugger interface can be configured differently and can include different controls and provide different information.

A description of how a sequence of programming instructions can be executed and then reversed is now provided with reference to . As shown in a sequence of instructions can include instructions that execute sequentially such as instructions A H branch instructions e.g. instruction that cause one of two or more execution paths to be taken based on some condition or instructions to call a function of procedure e.g. instruction or return from a function or procedure e.g. instruction . A sequence of instructions can include other types of instructions which are not described here in detail.

Each instruction can be identified by an address of a memory location that stores the instruction. For example as shown the instruction A has an address value of 01A0. In some implementations this address is what is stored in the program address pointer see and used by the instruction fetch unit to retrieve the next instruction. As described above the value of the address stored in the program address pointer can be automatically incremented by a fixed amount. In the case of a branch jump or call instruction that changes the execution flow e.g. instructions or a different value can be stored in the program address pointer and an appropriate corresponding instruction retrieved.

As depicted in instructions A H execute sequentially that is after each of the instructions A H is fetched the program address pointer is automatically incremented and the next instruction is fetched. In particular when the program address pointer stores the address 01A8 an instruction B is fetched the program address pointer is then incremented to 01AC and the instruction C is fetched. The branch instruction is retrieved when the program address pointer has a value of 01A4. Since the instruction is branch instruction the next instruction cannot be determined until a condition depicted by the decision box is evaluated. Once the condition is evaluated the program address pointer is updated with either 01A8 or 01B4 and either instruction B or instruction is retrieved. The call instruction is retrieved when the program address pointer has a value of 01B0. Once the retrieved call instruction is decoded the program address pointer is updated with the 4310 and the corresponding instruction G is retrieved e.g. a first instruction and a called function or procedure . When the program address pointer has a value of 4318 the return instruction is decoded and once this instruction is decoded the program address pointer is updated with a value of 01B4. 

As depicted in instruction C represents an instruction that causes the computing system to crash. In some implementations an instruction such as the instruction C causes an unexpected fault that locks up the resources the operating system or a currently executing application program. For example the instruction C may cause the execution flow to unexpectedly branch to an area of memory that contains no valid programming code. Whatever the result an instruction such as the instruction C is generally a target of a developer who is attempting to debug programming code.

To debug programming code the developer can use the debugger interface to for example set breakpoints in the sequence of instructions that cause the debugger to execute programming instructions up to the breakpoint then pause. At the breakpoint the developer can single step through individual lines of programming code in an effort to understand why the programming code is causing a crash or other error. For example the developer can use the debugger interface to set a breakpoint depicted by a stop sign symbol then single step through the code instruction by instruction.

In a first pass of single stepping the developer may execute instructions B and C the last of which leads to a crash of the computing system . In some implementations the crash is one that cannot be recovered from and the developer must restart the debugger and debugger interface to re execute instructions that precede the breakpoint . In other implementations however the debugger includes an undo feature that allows the debugger to reverse the effects of executing certain instructions. In particular such an undo feature can allow the developer to reverse the execution back to the instruction that precedes the instruction C causing the crash. Once the developer has reversed the execution he or she can explore information about state register values processes etc. in order to determine what caused the crash. For example referring to the developer can use the undo control to reverse execution to a previous instruction then use the variable frame to explore variable values register values stack information etc. in order to diagnose the cause of the crash. After the execution is reversed the developer can step back through the code in a second pass and monitor the effect of each instruction on the variable values register values stack information etc.

In some implementations the developer can use the debugger interface to manipulate registers or variable values. For example the developer may reverse execution to the branch instruction then manipulate a register value in order to for example cause the instruction to be fetched rather than the instruction B. Once the instruction is fetched the developer can select the step over control for example to cause instructions G H and to be executed in a non single step mode or the developer can select the step into control for example to single step through the instructions G H and .

To enable an undo feature reverse execution of programming code some implementations of the debugger save system state and this state can be restored in the event of a crash. In some implementations the debugger saves state in response to actions initiated by the debugger user. For example the debugger can automatically save state each time the user initiates a single step operation e.g. using the single step control a step over operation e.g. using the step over control a step into operation e.g. using the step into control or in response to other actions that are described in more detail below.

Various states corresponding to the computing system are depicted in . For example state depicts a state of the computing system as the instruction A is being executed state depicts a state of the computing system as the instruction C is executed state depicts a state of the computing system as the instruction G is executed. As shown in some implementations a state can include the values of the program address pointer both current and next values are shown in a process ID which can identify a process in which the current instruction is included and current values of various registers or pointers. Other information can also be saved with the state described above e.g. files that may be open pointers into open files stack pointers open network connection channels pointers to shared memory etc. 

The computing system can save state in a number of ways. In some implementations each aspect of state can be pushed onto a stack e.g. stack shown in and a number of stack pointers can be maintained including both the current top of stack pointer and a pointer corresponding to the last saved state. Other pointers can also be used to mark out other saved states in order for example facilitate multiple levels of reverse execution.

In some implementations sequences of instructions are executed as processes that are managed by the operating system and state can be saved through creation of new processes. In particular some operating systems can create child processes that include copies of critical aspects of the computing system state. For example a child process can store copies of the program address pointer all of the current register values and other aspects of state can be saved when a child process is created. In some implementations creation of a child process results in a substantially identical child process and parent process. The operating system can suspend one of the processes upon creation of the child process and allow the other process to continue executing. For example upon creation of a child process some operating systems suspend the child process and allow the parent process to continue executing. Because the child process can carry with it certain state information of the computing system at the time the child process is created resuming the suspended child process can have the effect of restoring certain previously saved state and in effect reversing the effect of execution of certain programming instructions executed by the parent process. In some implementations the child process can be created by a fork instruction through a process that is sometimes referred to as forking a process. In some implementations creating a child process by forking a currently executing process automatically suspends the resulting child process and causes the parent process to continue executing.

An example scenario in which a child process is created in order to save the computing system state is now described with continued reference to . The sequence of instructions can be executed under the control of the debugger. When the program address pointer has the value 01A0 and the instruction A is retrieved the computing system has state state . A child process can be created having identical state . The child process having state can be suspended and the parent process having state can continue executing resulting in the execution of instructions and B. When the computing system attempts to fetch and execute instruction C it crashes. Upon receiving undo input from the debugger interface e.g. input indicating selection of the undo control the debugger can resume the suspended child process with state essentially reversing execution of the process that caused the crash. A developer or other debugger user can then inspect appropriate state values in the variable frame to determine the cause of the crash.

The process whose execution caused the crash is in some implementations terminated. In other implementations the process is not terminated but saved in a suspended mode as a snapshot of system state as of the point of the crash. In some implementations the operating system only maintains a fixed number of state saving processes after which certain processes are terminated e.g. the oldest processes youngest processes or processes identified by an algorithm .

In some implementations receipt of input from the debugger interface to undo the execution of a portion of programming code causes a breakpoint to be set such that the sequence of code between the point at which the child process was created e.g. as instruction A was being processed and the newly set breakpoint can be redone. To redo the execution of code the debugger interface can employ a redo control not shown which is now further described.

In some implementations a redo control not shown can cause code whose execution has been reversed by an undo operation to be re executed. Referring back to the example scenario described above in which a child process that has state is created the instructions A B and C can be fetched and executed leading to the crash caused by the instruction C. When the debugger receives input to undo the execution of this code the suspended child process having state can be activated and a breakpoint can also be set to facilitate a redo. Upon selection of a redo control the debugger can cause the process having state to be activated and can continue executing up to the recently set breakpoint . Allowing the developer to repeatedly undo and redo the execution of portions of programming code can in some implementations help the developer to identify bugs in the code. Before activating the process having state another child process can be created having state to facilitate yet another undo level.

As described above execution of some instructions can be reversed by saving and restoring certain aspects of system state. However the effect of execution of some instructions cannot be undone as easily as the effect of execution of other instructions. For example if an instruction reads from shared memory e.g. shared memory shown in or writes to or reads from an input output interface e.g. the network shown in aspects of the computing system state may not be saved and as such restoring the computing system state may not restore the aspects that are not saved. For example a first process that reads from shared memory may be undone but not before in some implementations a second process causes the shared memory to be overwritten. In some implementations the shared memory will not be restored to its state prior to being written to by the second process unless the contents of the shared memory is saved with the state. Because saving the contents of shared memory can be very resource intensive this will not always be done. Thus if the first process is redone after being undone the subsequent read of the shared memory may not yield the same result as the first read of the shared memory. Similar problems can result if a process whose execution is undone writes to or reads from an input output interface. For example the input output interface may be configured to communicate data in a number of sequential steps. After a first step the input output interface may be configured to receive some handshake signal before executing a second step if the first step is re initiated e.g. because of execution of a process being undone and redone before the handshaking signal is received the input output interface may be transitioned to an illegal or unexpected state. In such implementations an undo or redo feature of the debugger can create new problems.

Some implementations of the debugger interface can flag scenarios in which undoing or redoing may cause new problems. In particular some debuggers detect when a currently executing process reads from shared memory or writes to or reads from an input output interface and provides an indication of this in the debug interface . More particularly some debug interfaces include a color coded undo control and optionally a color coded redo control . The undo control can have one color e.g. green when the programming code executed since the last state was saved e.g. when a child process was created does not include any reads from shared memory or reads of or writes to an input output interface the undo control can have another color e.g. red or yellow when the programming code executed since the state was saved does include reads of shared memory or reads of or writes to an input output interface. In this manner a debugger user can employ undo or redo debug features but be informed of the potential side effects of such features.

In addition to color coding the debug controls some debuggers provide two user selectable modes for when a portion of code that can otherwise be undone or redone includes reads of shared memory or reads of or writes to and input output interface. In a first mode as described above state is restored upon receipt by the debug interface of an undo command and each instruction in the programming code whose execution was undone can be re executed upon receipt of a redo command. In a second mode each instruction in the programming code whose execution was undone can be re executed following a redo command except those instructions that read from shared memory or read from or write to an input output interface such instructions can be skipped.

In order to provide a developer with useful information corresponding to the skipped instructions corresponding to the second mode described above the debugger can save and use supplemental state information to provide for example appropriate register values to the debugger interface . In particular in the first instance where a value is read from shared memory the value can be saved as part of a supplemental saved state. If the instruction is subsequently undone then redone actual execution of the read of shared memory can be skipped but corresponding register values can be retrieved from the saved supplemental state and displayed in the variable frame . In this manner the developer can see the original value of the shared memory location even if another process has subsequently modified the shared memory location. Because this approach in some implementations only minimizes rather than completely eliminates side effects of undoing or redoing reads of shared memory or writes to or reads from an input output interfaces the undo control and redo control can still be color coded as described above or possible side effects can be flagged in some other manner .

Navigational input to traverse portions of the programming code can be received from for example a corresponding debugger interface. For example the operating system can receive navigational input through the debug resources and the debugger interface . The navigational input can include input that indicates a single step control a step over control a step into control or a breakpoint control has been selected.

In response to receiving the navigation input state of the program can be saved and a portion of the program can be executed . For example the operating system can cause state to be saved. In particular state a can be saved as a result of the operating system creating a child process from a currently executing process where the child process has state and the parent process has state . To create the processes the operating system can employ the process manager possibly employing a fork operation. In some implementations actual state can be maintained by the process manager in a stack a file A or by some other resource of the resources or operating system . After state is saved a portion of the programming code can be executed . For example the instructions A B and C can be executed causing as depicted in a crash .

As the code is being executed a determination can be made as to whether any of the code causes a read from shared memory or read of or write to an input output device. For example the operating system can employ the debug resources to determine if any of the programming code reads from the shared memory or reads from or writes to an input output interface such as an interface associated with the pointing device the keyboard the video display or the network .

If it is determined that code being executed does not read from shared memory or read from or write to an input output interface a reverse execution icon can be displayed in a first format. For example the undo control can be displayed in one color such as green to imply that the programming code can be safely undone. A redo control if present can also be displayed in a similar manner.

If it is determined that code being executed does read from the shared memory or reads from or writes to an input output interface the reverse execution icon can be displayed in a second format. For example the undo control and optionally a redo control can be displayed in a different color such as red or yellow to imply reversing execution of or re executing the programming code may have unintended or unpredictable side effects.

In some implementations supplemental state can be saved when the programming code includes reads from shared memory or reads of or writes to input output interface. Such supplemental state can be subsequently used to display information about the reads or writes in a variable frame of the debugger interface even though the effect of actual reads or writes may not be reversed and even though the reads or writes may not be re executed when other portions of the programming code are reversed or re executed.

As shown the method includes receiving input to reverse execution of the portion of the program. For example the operating system can receive input from the debugger interface e.g. selection of the undo control to reverse previous execution of code.

In response to the received input the previously saved state can be restored . For example the operating system can cause state to be restored. In particular state can be restored in some implementations by resuming a previously suspended child process that was earlier created by a fork operation. The operating system can employ the process manager to resume the previously suspended process. In some implementations a new breakpoint is set before the state is restored . For example the operating system can employ the debug resources to set a new breakpoint .

The method includes determining whether input has been received to re execute the portion whose execution was previously reversed. For example the operating system through the debug resources and debugger interface can receive input that a user of the debugger has selected a redo control not shown in .

If it is determined that no re execution input has been received execution can be continued . For example execution of the sequence of programming instructions can be continued based on the restored state . In some implementations execution parameters can be modified following the reverse execution. For example in some implementations the debugger user can modify a value in the variable frame in order to affect a branch path. In particular with reference to the debugger user may modify a value to cause instructions A D etc. to be executed in place of instructions D and C .

If it is determined that programming instruction are to be re executed then the appropriate instructions can be re executed accordingly. For example the operating system can cause the previously executed and reversed instructions e.g. instructions A B and C to be re executed . This may result in another crash but it may also afford the debugger user a chance to monitor certain state information e.g. information in a thread process frame the variable frame the high level code frame or the machine code frame .

In some implementations the re execution can be performed from a point in the code at which state was last saved to a point at which a new breakpoint was set in response to a previous undo operation. In some implementations only the instructions that do not read from shared memory or read from or write to an input output interface are executed in such implementations certain state information in the variable frame can be update based on previously stored supplemental state information without actual re execution of the instructions that affect shared memory or the input output interface.

The method may also include determining whether additional commands to reverse or re execute programming code have been received for example from the debugger interface . If such input has been received the operating system can take appropriate action.

A number of embodiments of the invention have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly other embodiments are within the scope of the following claims 

