---

title: XNA relationship management
abstract: A data provider application programming interface (API) is configured for use with a game content editing application. An asset relationship management file, which is generated with the data provider API, includes information such as relationship references and annotations and is updated by the data provider API when a digital asset is edited. The asset relationship management file is then stored in a data store. An asset relationship graph is generated, based on the asset relationship management file in the data store. The asset relationship graph includes asset graph nodes that map dependency relationships between asset files. A graph API is also described. The graph API is configured for accessing the relationship graph through a server process to expose dependency relationships and annotations to a client process, such as an application. Thus, the effect of changes to one asset on other assets can readily be evaluated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07836055&OS=07836055&RS=07836055
owner: Microsoft Corporation
number: 07836055
owner_city: Redmond
owner_country: US
publication_date: 20060131
---
Media consoles such as those used for playing video games have achieved significant market penetration over the last few years. Consequently game developers are particularly concerned with producing games to bring to market in an expedient manner. However developing games and other media console software requires considerable effort by large teams of artists and programmers. Game development teams composed of artist and programmers often work on discrete portions of a new game without explicit knowledge of concurrent efforts of other artists and programmers within their own development groups. In such a development environment a game component developed by an artist may include several component elements that are also included in other components.

A number of components of a game or other software application may share software elements with different components having a dependency relationship with the same element file or data. For example the shape of a car in a game might be defined by an original car mesh to which several colors materials and textures are applied. For example a specific red may be employed for the car body color and chrome which may comprise both a texture and a color might be used for highlights on the car. In this example the color texture chrome will also likely be used for other cars and components of the game. Unfortunately during game development when an artist changes a color or texture element that is shared by other components it may not be possible to easily determine which other components are affected by the artist s changes. Furthermore multiple dependencies may not become apparent until an application has been compiled and executed rendering an unintended change apparent only during a quality review cycle. Moreover it may be difficult to determine the artist that actually caused an undesirable change when modifying a mutually shared component texture or color without reviewing each component of a game that would be affected prior to the step of compiling.

Changes are often made that result in texture files that were once used being no longer used in a game but still included in the file set for the game. As a result many games include surplus content and or orphaned files which are no longer used or needed by the game. Because it may not be clear what components would be adversely affected by deleting texture files game developers are hesitant to delete content during development. Accordingly there is a need within the game development industry for new approaches to be developed that facilitate managing game content and the relationships between components and files used in rendering those components. An approach is needed that is universally applicable at minimal cost and which address these and other related problems that arise during the development of games.

Several examples are provided below that describe implementations for managing digital game content relationship information. The game content relationship information is generally associated with a set of digital game content files that exist within a distributed processing system such as a client server game development environment for example.

One implementation described in more detail below includes steps such as providing a data provider API for communicating between a client process and a server process. The data provider API is described as being configured for use with a game content editing application or tool. Another step is directed to generating an asset relationship management file using the data provider API. In this exemplary implementation the asset relationship management file includes information such as a relationship reference and an annotation. The asset relationship management file is produced by the data provider API for a digital asset being edited by the client content editing process. This content and editing process can be for example part of an art editing or sound editing application. Yet another step is directed to storing the asset relationship management file to a data store. Finally the exemplary implementation includes the step of generating an asset relationship graph that is based on a set of asset relationship management files. The asset relationship graph generally includes asset graph nodes that map dependency relationships between digital game content files. Another exemplary implementation described below includes the step of providing a graph API for communicating between a client process and a server process in the distributed processing system. In this exemplary implementation the graph API is configured for accessing the relationship graph through a server process to expose asset relationship data and annotation data to the client process.

This Summary has been provided to introduce a few concepts in a simplified form that are further described in detail below in the Description. However this Summary is not intended to identify key or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Exemplary embodiments are illustrated in referenced Figures of the drawings. It is intended that the embodiments and Figures disclosed herein are to be considered illustrative rather than restrictive. Furthermore in the claims that follow when a list of alternatives uses the conjunctive and following the phrase at least one of or following the phrase one of the intended meaning of and corresponds to the conjunctive or. 

The following discussion is intended to provide a brief general description of a suitable computing environment in which certain methods discussed below may be implemented. Further the following discussion illustrates a context for implementing computer executable instructions such as program modules with a computing system. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The skilled practitioner will recognize that other computing system configurations may be applied including multiprocessor systems mainframe computers personal computers processor controlled consumer electronics personal digital assistants PDAs but likely not when a server functionality is required and the like. One implementation includes distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary system suitable for implementing various methods is depicted. The system includes a general purpose computing device in the form of a conventional PC provided with a processing unit a system memory and a system bus . The system bus couples various system components including the system memory to processing unit and may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM .

A basic input output system BIOS which contains the fundamental routines that enable transfer of information between elements within the PC such as during system start up is stored in ROM . PC further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a compact disk read only memory CD ROM or other optical media. Hard disk drive magnetic disk drive and optical disk drive are connected to system bus by a hard disk drive interface a magnetic disk drive interface and an optical disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable machine instructions data structures program modules and other data for PC . Although the described exemplary environment employs a hard disk removable magnetic disk and removable optical disk those skilled in the art will recognize that other types of computer readable media which can store data and machine instructions that are accessible by a computer such as magnetic cassettes flash memory cards digital video disks DVDs Bernoulli cartridges RAMs ROMs and the like may also be used.

A number of program modules and or data may be stored on hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program or other data . A user may enter commands and information in PC and provide control input through input devices such as a keyboard and a pointing device . Pointing device may include a mouse stylus wireless remote control or other user interactive pointer. As used in the following description the term mouse is intended to encompass any pointing device that is useful for controlling the position of a cursor on the screen. Other input devices not shown may include a microphone joystick haptic joystick yoke foot pedals game pad satellite dish scanner or the like. Also PC may include a Bluetooth radio or other wireless interface for communication with other interface devices such as printers or a network. These and other input output I O devices can be connected to processing unit through an I O interface that is coupled to system bus . The phrase I O interface is intended to encompass each interface specifically used for a serial port a parallel port a game port a keyboard port and or a universal serial bus USB . Optionally a monitor can be connected to system bus via an appropriate interface such as a video adapter . In general PCs can also be coupled to other peripheral output devices not shown such as speakers through a sound card or other audio interface not shown and printers.

Certain processes described in detail below can be practiced on a single machine although PC can also operate in a networked environment using logical connections to one or more remote computers such as a remote computer . Remote computer can be another PC a server which can be configured much like PC a router a network PC a peer device or a satellite or other common network node none of which are shown and a remote computer will typically include many or all of the elements described above in connection with PC although only an external memory storage device for the remote computer has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are common in offices enterprise wide computer networks intranets and the Internet. In one particular implementation PC is a component of a game development environment that includes other computing devices such as server computers other PCs databases and the like.

When used in a LAN networking environment PC is connected to LAN through a network interface or adapter . When used in a WAN networking environment PC typically includes a modem or other means such as a cable modem Digital Subscriber Line DSL interface or an Integrated Service Digital Network ISDN interface for establishing communications over WAN such as the Internet. Modem which may be internal or external is connected to the system bus or coupled to the bus via I O device interface i.e. through a serial port. In a networked environment program modules or portions thereof used by PC may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used such as wireless communication and wide band network links.

Server can be any computing device such as the exemplary computing device and or computer server discussed with reference to . Although it will be apparent to the skilled practitioner that server includes such components for clarity and to simplify the disclosure server is only illustrated as including a processor and a memory . Memory is shown including a relationship manager application that includes an object model module a relationship engine module and can also include an ARM graph API each of which will be discussed in detail below.

Client can be any computing device or system such as the exemplary computing device and or computer server discussed with reference to . In some implementations client is a PC coupled to a network such as a LAN or WAN or one or more other computing devices through a secure connection over the Internet not shown . In other implementations client can be any computing device configured to run applications such as art editors sound editors asset report generators and other productivity applications. As depicted in client includes an art editor application which may be used to access create modify and or manage digital content such as digital game components. A digital game component is one element of an executable game application including for example a mesh file a texture and or material file a sound file an artificial intelligence AI file or other logic file or any other digital asset file that can share dependencies with other game components. Art editor is shown as including an ARM data provider API . However ARM data provider API can be an add on component or module that is appended to art editor or merely accessed by art editor through an API call. It is intended that ARM data provider API will be readily configured to retrofit a broad range of existing applications in order to enable the provision of valuable asset relationship data in a development platform independent format.

ARM file can include any exportable information about a specific digital asset including a relationship reference and an annotation . Relationship reference is a logical statement and or an indicator that defines a dependency or referential relationship that the specific digital asset has with any other digital asset. For example if the specific digital asset is a mesh file relationship reference can be a logical statement that the mesh references a specific material file. However if the specific digital asset is instead the specific material file such as a file that defines a color the relationship reference can be a logical statement that the mesh depends on the specific material file. Annotation can include other information that may be useful to export. For example the annotation can include an asset version indicator an asset approval indicator e.g. indicating sign off by an artist an asset description an asset type indicator a rule associated with an asset and an attribute associated with the asset. The annotation can also provide specific information such as a color depth indicator compression algorithm information associated with the asset or a specific date such as for indicating the last edit of the asset or a final sign off date for example. In one implementation ARM file is a data structure embodied in an XML document according to an asset relationship management schema. In this implementation the schema defines a format for objects representing data written out from an asset file by the ARM data provider API such as asset identification relationship references associated with the asset and various annotations. Although XML is a widely accepted and application neutral document format it should be noted that the ARM file can be embodied in any appropriate document format and is not limited to an XML format.

Data store provides storage for and includes a plurality of data structures such as ARM file and asset file and asset relationship graph . ARM file can be any asset relationship management file as described in relation to ARM file . Asset file is generally a digital content file such as a mesh file a material file a sound file or another digital game component file. Asset relationship graph can include a plurality of nodes as illustrated in by nodes A B and C. By way of illustration shows that node A refers to node B and node C while node B refers to node C yet node C refers to neither node A nor node B. Furthermore nodes A B and C can include a tree structure that further defines a mapping of nodal dependencies and additional information such as annotations not shown .

By way of illustration and clarity server is shown as including a relationship manager which is depicted in as including an object model module and a relationship engine module . However in some implementations relationship manager is actually one executable module which provides the functionality of both object model and relationship engine . In other implementations object model and relationship engine are implemented as separate but operationally integrated modules. ARM graph API can optionally be located with object model and relationship engine on server or can be integrated into an operating system not shown of server or as part of an application or can be configured as a freestanding module. It is intended that ARM graph API be configured to retrofit a broad range of existing applications in order to enable access to asset relationship data in asset relationship graph thereby providing the beneficial functionality of this approach to these existing applications.

Object model is configured to provide an interface to asset relationship graph . In one implementation object model is configured to respond to a call from an ARM graph API requesting asset information by navigating the nodes of the asset relationship graph and returning dependency information to a calling application. In this instance the calling application can be any application enabled for communication with object model e.g. through the ARM graph API such as a third party tool various custom tools a game build system or even a game itself. Relationship engine is generally configured to aggregate the ARM files e.g. ARM file contained in data store and to generate a multi graph representation of all of the different relationships dependencies and content annotations described by the ARM files.

In one exemplary implementation relationship engine is configured to monitor data store in real time to identify new or modified ARM files as they are created. In this implementation the relationship engine can be configured to parse the ARM file and generate a node in the asset relationship graph that contains relationship information and annotations for an asset identified by the ARM file. In another implementation which is not shown in relationship engine is configured to instantiate a relationship graph in memory under its control on the fly in response to an ARM graph API call. In this implementation the asset relationship graph would reside in memory rather than within data store . This implementation may be preferable in terms of run time efficiency where a number of clients seek simultaneous access to asset relationship information that is rapidly changing and where the total number of nodes is not exceptionally large.

By way of further illustration is another functional block diagram of a suitable operating environment for enabling digital content relationship management. As depicted in server is again shown in communication with a data store and a client . The embodiment illustrated in depicts data store as again including ARM file asset file and asset relationship graph . Server is again depicted as including processor and memory with memory having relationship manager stored within it. As discussed above relationship manager includes object model and relationship engine . For a discussion of the functionality and capabilities of each of these elements reference can be made to the discussion above regarding . Client of represents a computing device such as discussed above with reference to . Although it will be apparent to the skilled practitioner that client device will incorporate many of the other components of for clarity only illustrates a processor and a memory used for storing an application . An ARM graph API is depicted within application . However ARM graph API need not be integrated into application and in some implementations is a plug in or a freestanding module for use with an application or an operating system not shown of client .

As was discussed above it is intended that ARM graph API can be configured to retrofit a broad range of existing applications and or operating systems to enable access to asset relationship data in the asset relationship graph from a process executing on the client device. In one example application is a reporting tool that can be used to generate asset dependency reports which can be utilized during game development to identify orphaned assets or to trace unwanted changes to asset files. In another implementation application may be a component application of a game build pipeline which can call the asset relationship graph through the ARM graph API in order to for example optimize the building or rebuilding of a game executable test functionality implement quality assurance tasks and implement a certification approval process.

Method begins at a step where a data provider API is provided for communicating between a client process and a server process in the distributed processing system. In one implementation the data provider API can be configured for use with a game content editing application or tool. Generally the data provider API can be provided as a plug in or add on component for use with an existing application or software module. The data provider API is enabled when it is installed and configured for operation with an application such as an art editor for mesh or sound editing.

In a step an asset relationship management file is generated with the data provider API. In some implementations an asset relationship management file can include a digital asset identification that uniquely identifies a specific digital asset file a relationship reference that describes linking and or dependency relationships with other digital asset files and an annotation which can include information related to or about the asset file. Generally the asset relationship management file is written out by the data provider API from a digital asset that is being edited by a client content editing process such as editing a mesh file or a sound file.

In a step the asset relationship management file is stored in a data store e.g. on a hard drive. The asset relationship management file can be stored at any time after it is generated. In some implementations the ARM file is first cached and then stored. In another implementation the ARM file is queued by a relationship engine prior to being stored in order to allow immediate processing of the file. Some implementations of the ARM file can include an asset relationship management schema that defines an annotation object and a relationship reference object. In one example the asset relationship management file is embodied in an XML document according to the asset relationship management schema. In another example an annotation can include one or more of an asset version indicator an asset approval indicator an asset description or a color depth indicator. In other examples an annotation can include one or more of compression algorithm data associated with an asset a date indicator an asset type indicator a rule associated with the asset or an attribute associated with the asset. Annotations can be any information that could be useful to write out from an asset and make available as a resource for other users in the processes.

In a step an asset relationship graph is generated based on the asset relationship management file. In some implementations the asset relationship graph is composed of a series of asset graph nodes that map dependency and referential relationships between a set of digital game content files. In one exemplary implementation the step of generating includes the step of first providing the asset relationship management file to a relationship management engine. In this implementation the relationship management engine can be configured for communication with the data store. This implementation also includes the step of parsing the asset relationship management file to identify each relationship reference and annotation. A final step of the implementation includes generating a node tree in the asset relationship graph. In this step the node tree is first associated with the asset relationship management file and then mapped to each asset node of the asset relationship graph that is associated with any relationship references and annotations that were identified in the step of parsing. Therefore each node of the asset relationship graph will correspond to a digital content file such as a game component and will map the relationship between itself and any other digital content file described by an ARM file accessible to the relationship management engine. Another exemplary implementation further includes the step of configuring the relationship engine to monitor the data store and identify each new asset management file and then invoke the relationship engine to map each identified new asset management file into an instantiation of the asset relationship graph as a unique node. It should be noted that the asset relationship graph can be instantiated within a data store or any other suitable memory location such as for example within server memory.

Another exemplary implementation further includes the step of providing a graph API for communicating between a client process and a server process in the distributed processing system. In some implementations the graph API can be configured for accessing the relationship graph through a server process in order to expose asset relationship data and annotation data to the client process. One implementation of the graph API includes a series of steps such as receiving a call to the graph API from a client process requesting information associated with a specific asset and issuing an asset information request from the graph API in response to the call. Further steps include interrogating the relationship graph for the information associated with the specific asset and then returning a response to the request to the client process from the graph API. In this implementation the response is associated with the specific asset and is based on the interrogation.

Another exemplary implementation includes a series of steps such as accessing an asset relationship object model through the graph API. In this implementation the asset relationship object model is configured to navigate the plurality of asset nodes of the asset relationship graph and then expose relationship references and annotations. The next step in this implementation includes identifying each relationship reference in the asset relationship graph that is associated with the specific asset.

In step an ARM graph call is issued by the client process. The ARM graph call can include one or more call parameters such as an asset identifier a data store identifier and a client requested function. The ARM graph call can occur at any time that a graph API is enabled. In some implementations the graph API can be located at either the client side or server side but can be invoked by a client process in both instances.

In a step a server process receives the ARM graph call and then parses the call to retrieve the parameters. In some implementations the ARM graph call immediately invokes a server process to parse the call and retrieve the parameters. In other implementations where multiple calls may arrive from different clients within a small window a call can be cached in a FIFO buffer or a queue and then served in the order of receipt.

In a step the server process loads an ARM graph in response to the ARM graph call. The ARM graph can be loaded from an existing ARM graph located in a data store or alternatively can be loaded as an instance generated on the fly based on the call. The ARM graph can be loaded immediately or queued based on whether another load process is executing. In one implementation the ARM graph is loaded by first accessing each ARM file in a data store that corresponds to a digital asset file and then extracting each reference to an asset file from each ARM file generating a node for each asset file and than mapping each relationship between asset files via the nodes.

In a step the server process interrogates the ARM graph in response to the ARM graph call. Generally the interrogation is based on parameters parsed from the ARM graph call. In one exemplary implementation the interrogation includes navigating one or more nodes of the ARM graph to identify one or more asset identifiers corresponding to specific asset files based on the parameters parsed from the ARM graph call and surface relationships and annotations related to the specific asset files. The interrogation can occur at any time after the call is received and an ARM graph is available for interrogation.

In a step the server process issues an ARM graph acknowledgment having a plurality of acknowledgment parameters including the asset identifier and at least one of an asset relationship reference and an annotation. In some implementations the acknowledgment parameters can include relationships and annotations determined by the ARM graph interrogation. In some implementations the server process can issue the ARM graph acknowledgment immediately upon completion of an interrogation. In other implementations the ARM graph acknowledgment can be queued and issued at a later time depending on external parameters.

In a step the client process receives the ARM graph acknowledgment. In some implementations the client process can receive the ARM graph acknowledgment at any time after the acknowledgment has issued and a client process is active for receiving communications. A further implementation includes the steps of parsing the ARM graph acknowledgment to retrieve the acknowledgment parameters and then providing the retrieved parameter to a client application process. In an example an ARM graph API can be configured to receive the ARM graph acknowledgment parse the acknowledgment parameters and then provide the retrieved parameters to a reporting application or art editor for example.

In one exemplary implementation a data structure stored on a tangible computer readable medium includes a first ARM graph node representing a first asset. In this implementation the first node can include a first asset identifier for uniquely identifying a first digital asset such as a game component a relationship reference defining a relationship to another asset and an annotation that can include information about the asset such as a binary name or root directory. In this implementation the data structure further includes a second relationship graph node representing a second asset the second asset including a second asset identifier and at least one of a second relationship reference mapping to at least the first relationship graph node and a second annotation.

In step an application process issues an ARM data provider call including one or more call parameters such as an asset identifier a client requested function a relationship reference and an annotation. In one implementation the client requested function is a request to write out one or more of the parameters to an ARM file. In one implementation the application process is associated with an editor such as an art editor or a sound editor or a report generating application.

In a step a client process receives the ARM data provider call and in response parses the call to retrieve the parameters and execute the client requested function. In one exemplary implementation the client process is associated with an API module.

In a step the client process issues an ARM file that includes the retrieved parameters. In one exemplary implementation the ARM file is an XML document formatted according to an asset relationship management schema which defines one or more objects corresponding to one or more parameters. In one example the asset relationship management schema is a simple list. In another example the asset relationship management schema is a tree of nodes. The ARM file can have any suitable document format and schema that allow the ARM file to be readily exchanged and utilized with a wide variety of off the shelf i.e. existing software packages.

In a step a server process receives the ARM file and stores the ARM file in a data store e.g. a hard drive . In some implementations the ARM file may be stored locally with other files including asset files related to the ARM file. In other implementations an off site repository may store ARM files for retrieval on an as needed basis. In yet other implementations the ARM files may be stored in a volatile or non volatile memory location controlled by an asset relationship engine to allow run time access for on the fly asset relationship graph creation.

By way of further illustration an exemplary application of the above described content management applications and components can be described with reference to a game development environment. For example a game development team composed of three separate groups is charged with developing a set of vehicles for a new video game. The first group is to develop a fire engine the second group is to develop a police car and the third group is to develop a racy sports car. The first team develops a fire engine mesh which is a wire frame that defines the shape of the fire engine. The team saves the mesh file to a central repository and begins developing a material file and a sound file which will be associated with the mesh file and used when the fire engine is rendered. After developing just the right shade of fire engine red the first group saves the mesh file with a link to the fire engine red material file and a link to a pre existing engine sound file. All of the files for the fire engine are saved to the same repository accessible to the other development groups.

Meanwhile the second group builds a police car asset file from an existing car mesh file selecting pre existing material files for black white and chrome portions of the police car and then creates a siren sound file all of which are referenced by the police car asset mesh file when it is saved to the central repository along with the referenced component files. The third group builds a new sports car mesh and links it to the fire engine red material file the chrome material file and to the preexisting engine sound file. However the third group decides during development that the pre existing engine sound file isn t appropriate to the deep throated roar of a sports car and opens the sound file for editing. The team wishes to know what the impact of such changes will be on any other files in the game but since the groups are working independently the third group has no idea whether the other groups are using the same content files or how a change made to the sound file for the engine sound may impact other assets of the game.

However with a game development system employing the concept described above when each of the above asset files is saved an ARM file is also created by the ARM data provider API which writes out essential relationships that the asset file has to other asset files and annotations containing useful information about the asset file to an XML document according to a relationship management schema. The ARM file is stored in a central data store along with other files such as the original asset file e.g. a material file such as a car mesh color texture and sound or logic files etc. that it represents. The ARM file can then be used to generate an asset relationship graph that maps all of the dependency relationships between the asset files represented by the ARM files. It is important to note that the ARM data provider API can be retrofitted to an existing game development or content editing suite and that the relationship management schema used to schematize the data contained in the ARM file can be applied quite easily across multiple platforms. This capability can provide different companies using different or even proprietary development tools the capability to export asset file dependency information and other data about a digital asset in a form that can be used by other parties.

For example as the third group discussed above accesses the pre existing engine sound file the content editing application can access a relationship graph via the graph API to determine that the engine sound file is relied upon by another asset file namely the fire engine asset file. The third group will thus recognize that the edited engine sound must be save to a new file to avoid changing the engine sound of the fire engine. Similarly as the third group accesses the chrome material file the ARM graph API can be employed to alert the group that the chrome material file is relied upon by the police car asset file and therefore the chrome material file should not be changed with the same file name because such changes will impact the appearance of the police car in the new game. As is evident from the above example multiple groups working on a game can track the asset files on which they are working such as mesh files material files sound files artificial intelligence AI files and the like in real time as the files are edited and created even across different development platforms. Furthermore through the ARM data provider API and the graph API it is possible to determine asset file dependencies prior to compiling a game and therefore eliminate orphaned files and redundancies to reduce software bloat streamline the development pipeline and improve quality assurance processes.

Although the present novel development has been described in connection with the preferred form of practicing it and modifications thereto those of ordinary skill in the art will understand that many other modifications can be made to the present concept within the scope of the claims that follow. Accordingly it is not intended that the scope of the concept in any way be limited by the above description but instead be determined entirely by reference to the claims that follow.

