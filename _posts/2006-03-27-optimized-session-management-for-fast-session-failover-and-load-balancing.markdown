---

title: Optimized session management for fast session failover and load balancing
abstract: A system and method of improving session management to facilitate failover and load balancing conditions. During the session, session data is segregated into a first set of core/non-derivable data and a second subset of data that can be derived from the core data. The core data is persistently stored. When a failover condition occurs, the recovering system is provided access to the core data to permit recreation of the session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07962566&OS=07962566&RS=07962566
owner: SAP AG
number: 07962566
owner_city: Walldorf
owner_country: DE
publication_date: 20060327
---
Embodiments of the invention relate to session management. More specifically embodiments of the invention relate to session management during failover and migration of sessions between servers in a load balancing situation.

The term session commonly refers to data representing an interaction between a client and a server. Another common term referring to the same kind of data is conversational state because the session comprises the state that was created on the server due to the conversation between client and server. Different session concepts are used in practice with the HttpSession of Java Servlets as one important example. While the Java Servlet concept for sessions is flat having no hierarchy inside the session data the web based SAP WebDynpro sessions can have different scopes building a hierarchy of sessions. The session data is normally associated with one particular user accessing the application on the server via the client.

Sessions are commonly implemented using a token that is transported between the client and the server with each request. The token for example may be a hyper text transfer protocol HTTP cookie or the username of the user using the client. A token is used as a key for an associative array for example java.util.Map that contains the session data. The data is typically organized as name value pairs with the name often restricted to a string and the value allowing nearly any kind of object. The data stored in the session is required to serve requests from the corresponding client. If the data is not available the client cannot be served. This makes the session data very important and necessitates additional mechanisms in case of server problems. One kind of problem a server may encounter is software or hardware errors. Another is high load situations. In either case the server may not be able to serve requests from the clients for which it is holding the session data. Therefore the requests must be served by another server but this requires a mechanism to move the session data to the new server. A common term for this movement in case of an error on the server is called failover but the same argument applies to high load and therefore load balancing situations. To support failover some implementations require the session data i.e. the objects in the session to be serializable. Movement of sessions between servers or server nodes always requires serialization copying or cloning of existing session data. The time required to perform the failover depends heavily on the size of the session. In existing systems large session sizes often preclude failover operations in productive environments.

A system and method of improving session management to facilitate failover is disclosed. During the session session data is segregated into a first set of core non derivable data and a second subset of data that can be derived from the core data. The core data is stored outside the server process. When a failover condition occurs the recovering system is provided access to the core data to permit recreation of the session.

The worker nodes within instance provide the business and or presentation logic for the network applications supported by the system. In case of a Java based application server each worker contains a Java virtual machine represented as virtual machines in to execute the business logic and to store the associated data. In case of non Java based server the architecture may not contain virtual machines. In one embodiment the dispatcher distributes service requests from clients to one or more of the worker nodes using request queues stored in shared memory . The request handler fills the queues with client requests and the worker nodes consume the requests from each of their respective queues. In another embodiment requests can be distributed to the worker nodes directly from queues maintained in the dispatcher s memory.

The worker nodes may be Java 2 Enterprise Edition J2EE worker nodes which support Enterprise Java Bean EJB components of EJB containers at the business layer and Servlets and Java Server Pages JSP at the presentation layer . In one embodiment the virtual machines implement the Java 2 Standard Edition Specification 1.3 published Jul. 27 2001 or subsequent versions thereof the J2SE Standard . It should be noted however that the embodiments of the invention described herein may be implemented in the context of various different software platforms including by way of example Microsoft.NET platforms and or the Advanced Business Application Programming ABAP platforms developed by SAP AG of Walldorf Germany.

In one embodiment a session manager is executed within the instance . The session manager includes the program code interfaces and data for implementing the various session management techniques described herein. The session manager stores data in a session context responsive to an application. Traditionally a great amount of the data in the session context is used like a cache for a particular user. While much of the data is not truly essential to handle user request recreating that data for each request from scratch is too expensive in terms of CPU usage. By segregating the essential core data from the nonessential data faster failover can be achieved. As used herein core when modifying data refers to data that is not otherwise derivable by the application or the system from other entries in the session. This data is essential to continue processing user requests. For example user entered data not persisted elsewhere in the system would be core data. If the data is derivable from the core data or elsewhere in the system it is referred to herein interchangeably as cache session data or derivable data.

One embodiment of the session manager manages session objects with session domains as described in detail below. Generally session manager receives requests to store data in the session from the application that is running on the worker nodes . An application within the application server may provide a hint to the session manager whether the stored data contains or does not contain core data. In one embodiment the session manager may include two methods a core method and a cache method to store core and cache data respectively. Core method refers to a method used to process the core data to create a core session object. Cache method refers to a method to process cache session or derivable data. The core method creates a core session object to retain the core data and adds core data to that object as additional core data is received. In one embodiment the hint may take the form of calling the respective method to handle the request.

In one embodiment the core session object is persisted in shared memory using for example Shared Closures. In another embodiment the core session object is persisted to persistent storage . In various embodiments core session may be persisted to a database or to a file system. The cache method handles the derivable data also referred to as the cache session data. This data may be managed as a separate object from the core session object. In one embodiment the data is merely maintained in the local cache of the server handling the session. In another embodiment the cache data may be retained in shared memory but is not passed copied to a receiving server in the event of failover and may in fact be lost during the failure condition necessitating failover. The merits of this latter embodiment depend on the cost e.g. in terms of CPU time of copying from shared memory as opposed to recreating the session from the core session object.

At block a determination is made and a failover is necessary. The session manager passes the core session object to an alternate instance of the application likely residing on a separate application server at block . In some embodiments the object may be passed to an application in a separate instance within the cluster. At block a determination is made if the session has ended. If it has not the next received request begins processing at block .

At block a determination is made and a failover is necessary. The session manager passes the core session object to an alternate instance of the application likely residing on a separate application server at block . In some embodiments the object may be passed to an application in a separate instance within the cluster. At block a determination is made if the session has ended. If it has not the next received request begins processing at block .

Elements of embodiments may also be provided as a machine readable storage medium for storing the machine executable instructions. The machine readable storage medium may include but is not limited to flash memory optical disks CD ROMs DVD ROMs RAMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable storage media suitable for storing electronic instructions. For example embodiments of the invention may he downloaded as a computer program which may be transferred from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals via a communication link e.g. a modem or network connection .

It should be appreciated that reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore it is emphasized and should be appreciated that two or more references to an embodiment or one embodiment or an alternative embodiment in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined as suitable in one or more embodiments of the invention.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

