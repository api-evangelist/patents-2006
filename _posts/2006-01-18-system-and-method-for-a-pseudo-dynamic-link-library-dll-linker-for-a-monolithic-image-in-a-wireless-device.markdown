---

title: System and method for a pseudo dynamic link library (DLL) linker for a monolithic image in a wireless device
abstract: The present disclosure relates generally to a system and method for a pseudo DLL linker. In one example, the method includes identifying a plurality of components forming an image and identifying all symbols exportable from each component and all symbols imported by each component from another component. A redirection mechanism is built containing an address of each symbol exported by a component that is imported by another component, and each component is modified to alter each direct reference to a symbol associated with another component to a reference to the redirection mechanism. A linker is called to link a final image based on the modified components.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07735075&OS=07735075&RS=07735075
owner: Samsung Electronics Co., Ltd.
number: 07735075
owner_city: Suwon-si
owner_country: KR
publication_date: 20060118
---
This application claims priority from U.S. Provisional Patent Ser. No. 60 741 334 filed on Dec. 1 2005 and entitled SYSTEM AND METHOD FOR A PSEUDO DLL LINKER which is incorporated herein by reference.

This application is related to U.S. Patent Application Ser. No. 11 333 847 filed on Jan. 13 2006 and entitled SYSTEM AND METHOD FOR A PATCH MINIMIZATION TOOL which claims priority from U.S. Provisional Patent Ser. No. 60 741 322 filed Dec. 1 2005 both of which are incorporated herein by reference.

Handsets and other wireless devices contain software in the form of executable instructions and non executable data stored in a memory. The software provides such devices with the ability to perform various functions such as communicate via a wireless network handle call features such as call waiting and call forwarding and maintain a calendar and address book.

However once a wireless device is provided to an end user it becomes difficult to provide additional software or to make corrections to the software already installed on the device. To address this problem firmware over the air FOTA was developed to enable a service provider to send software updates over a wireless network to a wireless device. Such updates may provide additional functionality to software already existing on the wireless device or may provide bug fixes to address problems with the existing software. However while an update process such as FOTA presents a way to send software to a wireless device using such an update process is not without problems. Accordingly the provision of software over an air interface to a wireless device is challenging.

In one embodiment a method for providing a monolithic image for use in a wireless device is provided. The method comprises identifying a plurality of components forming an image represented in machine code and for each component of the plurality of components building an export symbol list containing all symbols within the component that are accessible to other components and an import symbol list containing all symbols within other components that are needed by the component. The method also includes building a redirection mechanism containing an indirect reference to each symbol in each component s export symbol list that is in the import symbol list of at least one other component. For each component of the plurality of components each direct reference to a symbol in another component is altered to refer to the indirect reference associated with the symbol in the redirection mechanism but references internal to a component are not altered. A final image is created containing the altered components and the redirection mechanism.

In another embodiment a method for providing an executable image for a mobile device is provided. The method comprises receiving an image from an assembler and identifying a plurality of components forming the image. All symbols exportable from each component and all symbols imported by each component from another component are identified. A redirection mechanism is built containing an address of each symbol exported by a component that is imported by another component and each component is modified to alter each direct reference to a symbol associated with another component to a reference to the redirection mechanism. A linker is called to link a final image based on the modified components.

In yet another embodiment a method comprises building at least first and second components from a plurality of modules forming an image received in machine language code. An export symbol list and an import symbol list are built for each of the first and second components. The first component s export symbol list is compared with the second component s import symbol list and the second component s export symbol list is compared with the first component s import symbol list to identify any symbols that are on the export list of one of the first and second components and the import list of the other of the first and second components. A redirection mechanism is built containing a location of each identified symbol. The first component is modified to change each reference to an export symbol of the second component to a reference to the redirection mechanism and the second component is modified to change each reference to an export symbol of the first component to a reference to the redirection mechanism.

In still another embodiment a static monolithic image for a mobile device that is controlled by an operating system that does not support dynamic linking or dynamic sharing is provided. The image comprises at least one redirection mechanism containing an address of each symbol within the image that is imported by any component forming the image from any other component forming the image. The image also includes a plurality of components wherein each component has a direct reference to any symbol contained by the component itself and has a reference to the redirection mechanism for any symbol imported from another component.

In another embodiment a system comprises a processor a memory unit coupled to the processor and a plurality of instructions stored on the memory unit for execution by the processor. The instructions include instructions for converting a monolithic image for use with a wireless device from assembly code to machine code and building a plurality of components based on modules identified in the machine code. The instructions also include instructions for identifying each symbol exportable by each component and each symbol imported by each component and building a redirection mechanism containing every symbol that is exportable by one component and imported by another component. The instructions also include instructions for modifying each component to alter each reference to an export symbol associated with another component to a reference to the redirection mechanism and linking the modified components and the redirection mechanism to create a final version of the monolithic image.

It is to be understood that the following disclosure provides many different embodiments or examples for implementing different features of the invention. Specific examples of components and arrangements are described below to simplify the present disclosure. These are of course merely examples and are not intended to be limiting. In addition the present disclosure may repeat reference numerals and or letters in the various examples. This repetition is for the purpose of simplicity and clarity and does not in itself dictate a relationship between the various embodiments and or configurations discussed.

Referring to one embodiment of a system within which the present invention may be practiced is illustrated. The system includes an image creation system a wireless network and a wireless device . As will be described below in greater detail the image creation system provides functionality to create an image containing executable instructions and or data. The image is transferred via the wireless network to the wireless device . The wireless device then uses the image to provide functionality to a user and communicate with other devices via the wireless network . The image may contain various combinations of functionality and data and additional features and bug fixes may be used to update the image by the image creation system . The network may be any type of network including centralized and ad hoc networks and may use any type of network technology including Code Division Multiple Access CDMA Global System for Mobile communication GSM Orthogonal Frequency Division Multiplexing OFDM or similar communications technologies. In the present example the network is a packet based network but it is understood that the present disclosure applies to any type of transmission.

Referring to a computer is illustrated as one embodiment of the image creation system of . The computer may include a central processing unit CPU a memory unit an input output I O device and a network interface . The network interface may be for example one or more wireless and or wireline network interface cards NICs that are each associated with a media access control MAC address. The network interface may be coupled directly to the network or may be coupled via one or more other networks not shown . The components and are interconnected by a bus system .

It is understood that the computer may be differently configured and that each of the listed components may actually represent several different components. For example the CPU may represent a multi processor or a distributed processing system the memory unit may include different levels of cache memory main memory hard disks and remote storage locations and the I O device may include monitors keyboards and the like. Furthermore although shown within the computer it is understood that some components e.g. a keyboard may be physically located outside of the computer. In addition some or all of the components and may be distributed. Therefore a wide range of flexibility is anticipated in the configuration of the computer .

Referring to one embodiment of the wireless device of is illustrated. The wireless device includes a processor a memory and a wireless communication system . It is understood that the wireless device can be any mobile device including cellular phones personal digital assistants and laptop computers. An operating system may be used to control the wireless device and provide a user interface by which a user of the device can access and utilize various functions.

The memory of the wireless device includes a binary image of the executable instructions and data contained within the wireless device although it is noted that not all instructions and data may be included in the image. In the present example the image is a monolithic image that contains the instructions and data in a static relationship that is created prior to being transferred to the wireless device.

Although such an image is often used in a device having a relatively simple operating system that does not support dynamic linking e.g. dynamic link libraries DLLs or dynamic shared objects DSOs the use of a static monolithic image creates a number of problems when updating the wireless device . The problems often stem from image updates that occur when the image present on a device is updated with a new image. When an image update occurs the differences between the image on the device and the new image that is to be transferred to the device are referred to as the image delta e.g. the amount of change between the two images.

One such problem is a reference change propagation problem that occurs when an update of the image causes a change in a reference between two portions of the image. Because the image is static altering a portion of the image can break the image s functionality as calls may be made to program modules that are no longer at the same address.

The reference change propagation problem is not generally an issue with operating systems that support dynamic linking e.g. through the use of DLLs or DSOs . As is known a DLL may generally be defined as a file containing executable code and or data that is bound to a program at load time or run time rather than during linking. Multiple applications may share the code and data in a DLL simultaneously. DLLs are associated with the WINDOWS operating system WINDOWS is a registered trademark of Microsoft Corp. of Redmond Wash. . A DSO may be generally defined as a mechanism that provides a way to build a piece of program code in a special format for loading at run time into the address space of an executable program. The DSO gets knowledge of the executable program symbol set as if it had been statically linked with it. DSOs are associated with the UNIX LINUX operating systems.

The lack of support for DLLs and DSOs may cause a problem when updates are made to the image. Because the monolithic image is a fixed binary representation of the instructions and data the addresses of various elements are static once the image is complete. This makes it difficult to provide incremental updates to the image as addresses may change when such updates occur. For example a subroutine within the image is associated with a fixed address when the image is created. This address is inserted into other portions of the image that may need to call the subroutine. However an update may move the subroutine from the original address to a new address. Because the other portions of the image are statically linked to the original address they will no longer be able to call the subroutine and an error may occur. Accordingly this inability to propagate reference changes throughout the monolithic image while performing incremental updates may cause serious problems in the operation of the wireless device. This problem is illustrated in greater detail in 

Referring to one embodiment of a monolithic image is illustrated. The image includes instruction portions and and data portion . It in understood that the portions and are for purposes of illustration only and that any combination or organization of instructions and data may be provided. As illustrated each portion and of the monolithic image abuts the next portion and there is an available portion of memory following and contiguous with the instruction portion . However if any portion other than the portion is updated there is no available memory in which the update can be stored contiguously with the portion being updated.

With additional reference to the image of is illustrated with a segmented linking structure. The segmented linking structure breaks the image into various portions e.g. the portions and and separates each portion with a block of available memory. For example there is an available portion contiguous to the instruction portion an available portion contiguous to the instruction portion and the previously described available portion . It is noted that the available portion is now smaller due to the existence of the available portions and . The available portions allow for some expansion of the portions and without the need to recreate the entire monolithic image. This solution may be feasible in some situations but fails to solve the reference change propagation problem because the segments remain linked and is generally unable to solve the problem that occurs when the update needs more memory than has been reserved as is illustrated in

With additional reference to the instruction portion requires more space than originally allotted in the available portion . Accordingly if the portion is to remain as a contiguous block it will overlap with the data portion as indicated by the overlap portion . In the present example the portion may overwrite the portion the portion may be broken into a non contiguous portion and stored partly in non contiguous available memory or the portion will have to be moved. Obviously overwriting the beginning of the portion may destroy the functionality. As previously described moving the portion may also harm the functionality as statically linked references will be broken.

Although the segmented linking structure is generally a better solution than using an image file without the available contiguous memory spaces provided by segmented linking the structure does not satisfactorily solve the problems presented by the monolithic image. For example to generate the segmented linking structure a file such as a scatter file may be used. As is known a scatter file is used to tell a linker where to load files or objects in memory. It is generally time consuming to generate the scatter file. Furthermore the segmented linking structure tends to consume relatively large amounts of memory as the available spaces left between segments should be large enough to accept an expected size increase in the corresponding segment. Even then the available spaces may overflow relatively quickly due to updates and bug fixes which means that a new scatter file has to be generated. Moving a function between segments may also require that a new scatter file be generated. The complexity and free memory required for the segmented linking structure are generally proportional to the code size. It is generally not possible to perform segmented linking with respect to third party libraries. In addition the segmented linking structure maintains references between segments so modifying a segment may result in needing to update all references in the image. For these and other reasons changes to read write data read only data and uninitialized data may result in large changes to the image.

Generally there is little flexibility available for the software represented by the monolithic image. The image is created using tools outside of the wireless device and then transferred to the wireless device when complete. Because of the wireless device s relatively simple operating system and the use of a monolithic image updates such as additional features and bug fixes may require that the entire image be modified and transferred to the wireless device. This is often impractical for a number of reasons. Not only is it impractical to utilize a customer s bandwidth for a lengthy period of time but governmental regulations may limit the amount of time that an update may take. For example governmentally mandated 911 restrictions may require that an update take no more than five minutes. As such updating large portions of an existing image on a mobile device is often unfeasible.

Referring to a method illustrates one embodiment of a process for handling the reference change propagation problem when creating a static monolithic image. In step the method identifies multiple components that make up the image. As will be described later in greater detail the components represent modules that form the image and may have little or no correspondence to the segments of a segmented linking structure that would be formed from the same image. A component or module may be a default type or may be user defined.

In step an export symbol list and an import symbol list are built for each component. The export symbol list contains all symbols e.g. variables and functions that are available outside of the component. The import symbol list contains all symbols that the component will need to call from other components. It is understood that an export symbol list and an import symbol list are used for purposes of example and that other processes for identifying and tracking the symbols may be used. For example a single list containing all export symbols and their corresponding components may be used and another list may contain all import symbols and their corresponding components. In another example the lists may be combined into a single list. Other mechanisms for identifying symbols exportable from a component and symbols imported by a component from another component may also be used.

In step one or more redirection mechanisms e.g. jump tables or veneers are built based on the export and import symbol lists. A jump table is an array containing the addresses of subroutines e.g. provides an indirect reference to each subroutine . Accordingly if a component references a particular element of the array the component will be redirected to the corresponding subroutine. A veneer is a short sequence of instructions used to make a subroutine call. The calling component transfers control to the veneer using an instruction such as a limited range branch instruction. The veneer then transfers control to the destination subroutine by a mechanism that permits a transfer to the appropriate destination. Accordingly both a jump table and a veneer enable redirection. It is understood that other redirection mechanisms may be substituted although some modifications may be needed depending on the particular redirection mechanism used.

To build the redirection mechanism the method examines the export and import symbol lists to identify symbols that are contained in both an export symbol list and an import symbol list. Only symbols contained in both an export symbol list and an import symbol list are included in the redirection mechanism. In step all direct references between components are altered to point to the redirection mechanism. For example a component that contains a direct reference call to a function in another component would be modified to contain a reference call to the redirection mechanism which would then redirect the calling component to the appropriate function. Accordingly all direct references between components are removed and the image is provided with pseudo DLL functionality. Any change to a component may be reflected by changing the appropriate address in the redirection mechanism rather than changing each component that requires access to the changed component.

Referring to one embodiment of a compiling system uses various modules for compiling an executable program in the image creation system of . A software program is generally written using a high level language i.e. source code and converted into machine readable language i.e. object code . Although some variations in terminology and actual processing may occur the compiling system provides modules used in a common conversion process including a preprocessor a compiler an assembler and a linker . The preprocessor compiler assembler and linker are commonly used modules that are generally associated with a specific programming language and or platform. A pseudo DLL linker is inserted into the process between the assembler and linker to modify the output of the assembler before linking as is discussed below in greater detail. This placement enables the pseudo DLL linker for example to manipulate the various files before they become too large to easily manipulate.

The preprocessor is responsible for collecting different parts of a source program that is to be compiled. The compiler takes the output of the preprocessor and converts it into assembly language code and the assembler translates the assembly language code into machine language code. Traditionally the linker would then take the machine language code identify any libraries or other external modules referred to by the machine language code and bind these modules to the machine language code to form the final image .

In the present example the pseudo DLL linker receives the machine language code produced by the assembler modifies the code and then calls the linker to link the modified code. It is noted that the assembler and linker may be basically unchanged from a system that does not include the pseudo DLL linker . For example the assembler may be modified to call the pseudo DLL linker rather than the linker or the call from the assembler may be intercepted by the pseudo DLL linker. In other embodiments the assembler output may be written to a file and the pseudo DLL linker may operate on the file prior to calling the linker . The linker may be unchanged.

Because of the need to identify and manipulate code at the machine code level and because machine code is generally created for a specific platform architecture it is understood that a different pseudo DLL linker may need to be written for each platform for which the pseudo DLL functionality is provided. For example different pseudo DLL linkers may be provided as plug ins or modules to a programming tool used to manipulate object code such as BFD Binary File Descriptor . As is known BFD is a software tool that uses a library to allow an application to use a set of routines to operate on object files despite the format of the object files. A new object file format can be supported by creating a new BFD back end and adding it to the BFD library. BFD is split into a front end and one or more back ends with one back end for each object file format. The front end provides a user interface and manages memory and various canonical data structures as well as deciding which back end to use and when to call back end routines. Each back end provides a set of calls that the front end can use to maintain its canonical form. Accordingly each pseudo DLL linker for a particular platform architecture can be provided as a back end to a tool such as BFD.

Referring to in another embodiment a method may be used to handle the problem caused when changes to a monolithic image impact direct references present in the image. In the present example the method occurs between the assembling process and the linking process during compilation of the final image as illustrated above with respect to . After the method is complete the final image is a static monolithic image with a redirection mechanism. Although a jump table is used as the redirection mechanism in the present example for purposes of illustration it is understood that the jump table may be replaced by other redirection mechanisms e.g. veneer s although some modifications may be needed depending on the particular redirection mechanism used.

In step the image is received from an assembler. The pseudo DLL linker should be able to identify and manipulate portions of the machine language code produced by the assembler. As described above a different pseudo DLL linker may be needed for each particular platform architecture supported.

In step the method determines whether a definition file such as a component description file exists. The component description file enables a user to define some or all of the components that will be used to form the final image. In the present example a component is not limited to a file or object as defined by the assembler although it may be defined as such if desired . Each component may be a collection of modules where a module may be a relocatable object file and the collection may be predefined e.g. an archive . For example an archive often having a name of .a or .lib may be a library that includes multiple modules and the library itself may be identified as a component. To identify components the method examines the machine language code to identify affinities between various pieces of code and then unless otherwise directed builds the components based on those affinities.

If a component description file does not exist the method proceeds to step where it identifies and builds the components using default definitions. For example a default definition may define a component as a collection of related modules e.g. a single library or other defined collection with any non library files combined into a single component. Accordingly if there are two libraries and multiple non library files there would be three components identified in step .

However if a component description file does exist the method moves to step where it uses the component description file to identify and build the components as described in the file. This enables a user to define a component as desired. For example the user may combine multiple libraries into a single component divide a library into multiple components etc. It is understood that user defined and default definitions may be mixed with a user defining certain components and allowing other components to be defined according to the default definitions. For purposes of example with additional reference to the instruction portion and data portion are a component Component A and instruction portion is a component Component B .

In step the method builds an export symbol list for each component. In the present example a symbol is a variable or function. The export symbol list is a list of all symbols within a component that are accessible to another component e.g. any symbol associated with a component s application programming interface API .

Continuing the previous example of assume that the instruction portion includes three functions func func and func the data portion includes a variable X and the instruction portion includes a function func and variables Y and Z. This is illustrated below in Table 1.

Functions func and func are both accessible outside of component A i.e. both func and func are in component A s API but func is not. Variable X is available outside of Component A but Y is not. Function func and variable Z are both accessible outside of component B. Each of the functions and variables that are available outside of their component are placed in that component s export list. This is illustrated below in Table 2.

In step the method builds an import symbol list for each component. The import symbol list is a list of all symbols that a component may need to call from other components. Together the export and import symbol lists contain all possible references between components.

Continuing the previous example functions func and func only call functions func func and func e.g. the calls are internal to Component A but func makes a call to func that is contained in component B. In addition component A needs access to variable X within component A and component Z within component B . Component B needs access to func from component A. Each of the functions and variables that are called by a component from another component are placed in the calling component s import list. For example variable Z will be placed in Component A s import list because it is contained within Component B but variable X will not be in the import list because it is contained within the same component although a different module . This is illustrated below in Table 3.

In step all symbols that are in both an export symbol list and an import symbol list are identified and in step the identified symbols and their corresponding addresses are placed in the jump table. Accordingly the jump table only contains a reference to each export symbol that corresponds to an input symbol. Only a call to a symbol outside of the calling component e.g. any call that does not reference a symbol contained within the component itself has a reference in the jump table.

Continuing the previous example although func and func are both accessible outside of component A only func will ever be called in the current program because no other component needs to call func. Accordingly func will not be placed in the jump table. Function func and Z will also be placed in the jump table as they both may be called by external components. This is illustrated below in Table 4.

In step the method alters all direct references between components to refer to the jump table. For example all references in Component A to func and Z will be modified to refer to the jump table rather than directly to Component B and all references in Component B to func will be modified to refer to the jump table rather than directly to Component A. Accordingly changes to the image that result in a different address for func func or Z may be fixed by modifying the corresponding redirection address in the jump table instead of needing to modify each direct reference in the calling component.

In step a linker e.g. the linker of is called to link the final image. The final image will include the modified components and the jump table. Once complete the image may be transferred to a wireless device.

With additional reference to in the present example a monolithic image includes Component A denoted by reference number and Component B denoted by reference number . Component A is associated with a contiguous memory space and component B is associated with a contiguous memory space . The memory spaces and provide their corresponding components with some contiguous expansion room. There may be a single jump table for the monolithic image or multiple jump tables may be used as illustrated by the jump tables and in . For example in some embodiments a small jump table may require less space because it is able to provide an address corresponding to a symbol s location and a jump instruction in a single instruction. In contrast a large jump table may require separate load address and jump instructions. If smaller jump tables are used it is understood that the symbols contained in each table may be divided so that a particular component need only utilize one or two jump tables. However any combination of symbols and jump tables may be used.

For purposes of example the image itself may be approximately twenty two megabytes MB although it is understood that any size of image may be used. Each jump table assuming a jump table for each component may be approximately four kilobytes KB . The size of the available memory spaces and may be approximately four to sixteen KB and may be located after each four MB space containing one or more components. The remaining memory may constitute a contiguous memory space of between approximately two hundred and fifty KB and eight hundred KB. It is understood that these values are for illustration only and that the size of the image jump table s available memory spaces and remaining memory may be of any size desired.

Referring to in another embodiment a method may be used to patch i.e. update an existing image previously created with a redirection mechanism and stored on a wireless device. The method may be executed for example on the image creation system of . In step the method determines an image delta between the existing image and a new image to identify the differences between the two images. In step any change to the address of any symbol contained in the image s redirection mechanism is identified based on the image delta. In step the addresses in the redirection mechanism are updated to reflect the identified changes. In step any component and redirection mechanism updates are transferred to the wireless device. One process by which the size of the patch may be minimized is described in greater detail in previously incorporated U.S. Provisional Patent Ser. No. 11 333 847 and entitled SYSTEM AND METHOD FOR A PATCH MINIMIZATION TOOL. 

Although only a few exemplary embodiments of this disclosure have been described in details above those skilled in the art will readily appreciate that many modifications are possible in the exemplary embodiments without materially departing from the novel teachings and advantages of this disclosure. Also features illustrated and discussed above with respect to some embodiments can be combined with features illustrated and discussed above with respect to other embodiments. Accordingly all such modifications are intended to be included within the scope of this disclosure.

