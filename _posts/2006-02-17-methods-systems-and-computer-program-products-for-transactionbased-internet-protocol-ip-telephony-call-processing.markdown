---

title: Methods, systems, and computer program products for transaction-based internet protocol (IP) telephony call processing
abstract: Methods, systems, and computer program products for transaction-based IP telephony call processing are disclosed. According to one method, a signaling message associated with an IP telephony event is received at an IP telephony node. In response to receiving the signaling message, an IP telephony transaction instance is instantiated to process the signaling message. The signaling message is processed using the IP telephony transaction instance.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08850051&OS=08850051&RS=08850051
owner: Broadsoft, Inc.
number: 08850051
owner_city: Gaithersburg
owner_country: US
publication_date: 20060217
---
The subject matter described herein relates to multimedia call processing in a telecommunications environment. More particularly the subject matter described herein relates to methods systems and computer program products for transaction based Internet protocol IP telephony call processing.

Telecommunications systems have grown more complex as feature sets increase in both number and complexity. The deployment of new features within conventional sequential state machine based call models is increasingly difficult to accomplish due to an increase in the types of traffic carried coupled with subscriber demands for increased connectivity and rapid deployment of new features.

State machine based call models have traditionally been implemented for call processing because they facilitate the partitioning of call processing into a granular set of actions based upon the current state of the state machine and the corresponding state of a call. Conventional call models based upon state machines manage call events by call processing activity within a state in response to a call processing trigger event or by a transition to another state. State machines are often nested within other state machines and multiple levels of nesting with large numbers of states are common within state machine based call models. Because states of state machines have traditionally been designed to be sequential in nature and to rely upon certain timing constraints and actions of other states the states are highly inter dependent and rely upon one another to complete the respective partitions of call processing in a timely fashion.

As subscriber demands and the associated system complexity have increased overtime the nested state machine model has become increasingly difficult to maintain and modify. Each new feature that is added to the call model typically results in additional activity within a state a new state or a new nested state machine. Further new features often require concurrent processing of multiple actions a task that a single sequential monolithic state machine is inadequately designed to accommodate.

Voice over Internet protocol VoIP is an example of a technological advancement that has stressed difficulties associated with the conventional state machine based call model. As well feature sets such as call waiting and call forwarding have increased in number and complexity. Implementing these new technological advancements and features into the monolithic sequential state machine based call model has become increasingly difficult to accomplish because so many different timing aspects and states are involved. As new features are integrated into conventional state machines the state machines become unwieldy and even more difficult to modify for future enhancements. Even well designed synchronous state machines may experience problems if processing takes longer than what is allotted for a given call state.

Accordingly in light of these difficulties associated with conventional monolithic sequential state machine based call processing there exists a need for improved methods systems and computer program products for transaction based IP telephony call processing.

According to one aspect the subject matter described herein comprises methods systems and computer program products for transaction based Internet protocol IP telephony call processing. One method includes receiving at an IP telephony a signaling message associated with an IP telephony call event in response to receiving the signaling message instantiating an IP telephony transaction instance to process the signaling message and processing the signaling message using the IP telephony transaction instance.

The subject matter described herein providing transaction based IP telephony call processing may be implemented using a computer program product comprising computer executable instructions embodied in a computer readable medium. Exemplary computer readable media suitable for implementing the subject matter described herein include chip memory devices disk memory devices programmable logic devices and application specific integrated circuits. In addition a computer readable medium that implements the subject matter described herein may be distributed across multiple physical devices and or computing platforms.

In view of the problems described above with respect to monolithic state machine based call processing the subject matter described herein provides for transaction based IP telephony call processing. Where previously a monolithic state machine was responsible for managing all aspects of a call the methods systems and computer program products described herein operate on a transaction based model to provide a more flexible and more adaptive call model to accommodate the fast evolving IP networks new end user devices and new service features. By adapting the call model from the conventional state machine based model to a transaction based model call model management modification and evolution may be improved. Transaction based IP telephony call processing may operate based upon IP telephony events such as a SIP registration event a SIP call setup event or a SIP call teardown event.

SIP has become widely used for the signaling associated with the setup and teardown on IP based multimedia communications. Accordingly SIP will be used to describe the subject matter herein. However it is understood that the subject matter described herein may be used for other forms of call processing. For example the transaction based IP telephony call processing methods and systems described herein can be used with an IP telephony signaling protocol such as signaling transport SIGTRAN protocols like stream control transmission protocol SCTP SS7 over IP H.323 or any other protocol used for IP based calls.

When SIP device generates a SIP message it may be received by SIP node on a SIP interface and passed to a SIP stack . SIP stack may be a standard SIP stack capable of performing network parsing and re transmission services typically performed by user agent devices.

When SIP stack parses the SIP message and determines that it should be routed internally rather than re transmitted SIP stack may convert the SIP message to an application programming interface API compliant SIP message and forward the API based SIP message over an API interface to a message routing module . API interface may include any message based class oriented communication capabilities such as those available with C Java and other object oriented programming models. The conversion of the SIP message into an API based SIP message may allow for faster internal processing. Because SIP is a text based messaging format a text based SIP message would need to be parsed at each module that handles the message if it were preserved in the text based format. Accordingly by conversion of the text based SIP message into an API based message direct object to object communication with associated behavioral triggering may be achieved.

Message routing module may as will be described in more detail below further route the API based SIP message over an API interface to an application module . Application module may as will be described in more detail below determine the final destination of the API based SIP message and may reformat the API based SIP message to comply with any external communication interface such as a SIP interface for delivery to the SIP module . SIP interface may include any interface capable of communication to a SIP component. Application module may convert the API based SIP message to any desirable format. For example application module may convert the API based SIP message back to a text based SIP message for transmission over a standard SIP interface. As well application module may convert the API based SIP message to a binary version of SIP. A binary version of SIP may provide for faster parsing of SIP messages by destination components.

In contrast to conventional state machine based call management transaction based call model may manage calls on a transaction by transaction basis without many of the problems described above for state machine based call processing. As will be described in more detail below the granularity of transactions within transaction based call model may facilitate modularity of transaction definitions and may simplify support for simultaneous call flows.

A SIP component may be a class based component capable of being instantiated to represent a physical device. For example SIP component may be capable of representing a SIP phone a SIP gateway a SIP media server or any other device capable of communication using any form of SIP based communication. Transaction based call model may be implemented in any architectural manner capable of allowing object based communication. For example SIP component may be instantiated from a class definition such as for example a C or java class.

Data related to SIP component may be stored as attributes in an attributes area . Attributes stored in attributes area may include data representing the functional capabilities of the physical device modeled by SIP component . SIP component may be viewed as the central point of communication where outside SIP messages and internal messages are translated from one form to another to facilitate call setup call processing and call teardown. These translations may include translating from one protocol to another. For example SIP may be translated to media gateway control protocol MGCP skinny client control protocol SCCP and MITEL or these protocols may be translated to SIP. In order to facilitate these translations a transaction manager may be used to associate message triggers with appropriate translations and transactions. Transaction manager is an IP service based application server capable of instantiating instances corresponding to IP telephony components and IP telephony transactions using information stored for example in a database. Once a trigger condition is met transaction manager may direct a transaction factory within transaction factories to set up process or tear down a call as appropriate. Transaction manager is an entity that manages transactions and routes incoming signaling messages to the appropriate transaction for transaction based IP telephony call processing. Transaction manager may poll transaction factories within transaction factories until a transaction factory responds that it is interested in processing the incoming signaling message. Transaction factories are entities that may manage the instantiation of transaction instances. In response to determining that processing by an instance that may be instantiated by the respective transaction factory is appropriate the respective transaction factory may instantiate a transaction to process the incoming message as will be describe in more detail below. Exemplary transaction factories include phone line features transactions keep alive transactions session timer transactions invite inbound transactions and invite outbound transactions.

The processes of setting up processing and tearing down a call within transaction based call model will be described in more detail below. For now it should be noted that calls may be instantiated by SIP component in response to an incoming message that is not associated with an instantiated call. The transaction factories within transaction factories may then be called to determine whether any instantiated object should process the message. If no transaction is instantiated to process the incoming message the call may be destroyed.

SIP component may either be provisioned for static devices e.g. media gateways etc. or instantiated on demand as devices e.g. phones etc. register with a system. Alternatively a SIP component may be provisioned statically as devices e.g. phone etc. are placed into service at load time. Calls and the transactions that manage call functionality within transaction based call model may be instantiated on demand and released when their function has completed as will be described in more detail below.

A call with attributes stored in an attributes area may be instantiated to represent a call within transaction based call model . For example when a SIP INVITE message is received at a component such as SIP component call may be instantiated to process the SIP INVITE message and any subsequent messages associated with call . Many calls may co exist with call . Accordingly any number of calls up to and including a call N with attributes stored in an attributes area may co exist. As described above in a departure from the conventional state machine based call management model transaction based call model may manage calls in a transaction oriented fashion.

As a foundation for the transactional call model of transaction based call model each call may have a collection of transactions associated with it. Each transaction may manage a small portion of call processing for a call and may operate concurrently or sequentially. For example call may have a transaction a transaction up to a transaction N . Likewise call N may have a transaction a transaction up to a transaction N .

A transaction instance such as transaction may perform well defined call processing tasks like call setup call teardown collection of digits and other call related activities. A set of transactions may collectively implement a call model or a service feature such as call waiting call hold or call forwarding. Each transaction may be designed to be sufficiently modular to allow reuse in multiple features and multiple call models. By partitioning the functionality of transactions in a granular fashion modularity may be improved. Accordingly reuse of small transactions may be enabled with transactions viewed as building blocks of a call model or service feature.

A transaction instance may be instantiated in response to an incoming trigger and may destroy itself when its functional processing is completed thereby alleviating system overhead for the release of any associated resources. If any transactions are still active and the owner call gets destroyed the active transactions may also be destroyed thereby alleviating system overhead for the release of any associated resources.

One example of a modular transaction trigger that may be reused at multiple call processing stages is an Invite Inbound trigger. An Invite Inbound trigger and an associated transaction instance may be reused for call setup call hold call transfer session timers and other service features that respond to SIP INVITE messages.

As can be seen from SIP component may have one or more calls and each call may have one or more transactions associated with it. As described above transactions may operate concurrently or sequentially depending upon the call processing activity to be performed and the granularity provided within the set of call processing transactions.

Accordingly to facilitate call processing and to simplify modular transaction design a transaction may need to exchange data with another transaction to provide information for future stages of call processing. This data exchange may be achieved through a transaction specific data repository such as for example attributes area . Multiple attributes may be stored in attributes area and attributes may survive the termination of a transaction to be used by later instantiated transactions. Subsequent transactions may be responsible for cleaning up attributes area following use of attributes deposited by prior transactions. Multiple call attributes areas may be created to enable more complex call processing without departure from the subject matter described herein.

As an example of attribute based communication between transactions a Phone Register transaction may save an expiration time stamp in a call attributes area such as for example attributes area . At appropriate intervals another transaction may check this time stamp to determine whether it has expired. If the time stamp has expired the other transaction may take the phone out of service. As another example of inter transaction communication a Phone Hold transaction may save a call hold attribute to attributes area when a phone associated with a SIP component such as SIP component is put on hold. Another transaction may look at the call hold attribute in attributes area and may respond to the call hold attribute. For example a Phone Resume transaction may be triggered if a hold attribute is present in attributes area . Accordingly transactions may perform the majority of the work to manage call setup processing and teardown.

Message routing module may locate components within the system to send SIP messages to and may provide for the static and dynamic binding of components to routing table entries as will be described in more detail below. At system start up time all components within the system that model SIP devices such as SIP phones media gateways and media servers may be provisioned into a component locator database . Accordingly as will be described in more detail below a component may be found within component locator database when unavailable in other call processing databases.

In order to identify a target component associated with an incoming SIP message message routing module may perform a three level lookup sequence for any message received. A message manager may be responsible for initial receipt and subsequent forwarding of any SIP message. In order to determine how to route a received SIP message message router may begin the three level lookup in an active dialog call database to determine whether the target component is already associated with an in progress session call or dialog. If no entry is found within dialog call database for the in progress session call or dialog associated the target component message router may perform a second lookup in routing table to search for active components. If the target component for the SIP message is not found in routing table a third lookup may be performed in the provisioned component locator database . If the target component is found at any level of the three level lookup the SIP message may be routed to the target component by message manager . If the targeted component is not found within any of the three level lookup databases appropriate error handling procedures may be implemented. For simplicity error handling procedures will not be described herein.

As described above component locator database may be statically provisioned. Component locator database may also be dynamically loaded. For example most phones register with a call agent to allow SIP message routing within a system. Information in a SIP REGISTER message may be used to locate a SIP phone component entry in component locator database . A search of component locator database may be categorized based upon message types associated with any component type for increased performance. Once a target component is located in component locator database an entry in routing table may be made to improve performance for future message routing to the target component. Likewise when a target component is located within routing table in response to for example a SIP INVITE message a call or dialog instance may be created in dialog call database .

Routing table may be organized as a tree where a host name can have one or more user name entries. Accordingly each entry of routing table may have two key fields host name and user name as shown in table 1 below.

As can be seen from Table 1 the host name field may include a text entry describing the type of component and an IP address for the specific device. The user name field may include any entry usable for routing SIP messages. The user name field may also include a wild card entry such as for example an asterisk e.g. for use with devices that do not have a user name e.g. gateways etc. . Gateways usually statically register to routing table and host name routing using an IP address for the device may be used.

Phones may dynamically register to routing table . Phones dynamically provision due to the fact that phones typically use dynamic host configuration protocol DHCP which allocates a new IP address each time a phone registers. Accordingly the host name for a phone is an IP address that is dynamic in nature and routing table entries for phones may be dynamically created within routing table when a phone registers.

As described above dialog call database may store entries associated with active dialogs or calls. Dialog call database may store entries and be searched by the Call ID field of a SIP message.

When the target component has been identified by message router message manager may forward the SIP message as an API based SIP message over API interface to application module . At the core of application module is a transaction based call model such as for example transaction based call model . For example application module may instantiate the transaction based call model components illustrated in . Finely granularized transactions may be crafted to avoid monolithic class definitions and to facilitate transaction reuse. Complex state machines that were previously used in conventional state machine based systems to keep track of and support simultaneous call flows are no longer needed. As described above in relation to the application layer may include three logical sub layers a component sub layer a call sub layer and a transaction sub layer. These logical sub layers may be implemented within application module as will be described in more detail below.

A global transaction manager may manage transaction factory level actions and may track the instantiation of transaction instances. An instance database may be used to store any instantiated entities. For example instance database may store all transaction factory instances call instances and transaction instances. When a component is identified to process a call the component may be associated within instance database with the transaction factories that it requires to instantiate transactions for call processing. As well a call may be instantiated within instance database by the component and an appropriate transaction instance may be instantiated to process the signaling message. Global transaction manager may track all instantiated entities within instance database .

As SIP messages arrive directed toward components corresponding calls and transactions may be instantiated within instance database to receive the SIP message and process it. In the case of a call setup message for example a call instance and an associated call setup transaction may be instantiated as will be described in more detail below. As application module populates with instantiated components and as call loads increase global transaction manager may monitor component loads and generate statistics that may be used for performance enhancement activities and monitoring.

Global transaction manager may also list all transaction factories in the system by name. The transaction factories in turn may be responsible for instantiating specific transactions. A transaction may be instantiated by a component level transaction factory in response to events such as for example an Invite Inbound transaction in response to receiving a SIP INVITE message. Upon receipt of an incoming message the transaction manager associated with the component may poll transaction factories associated with the component to determine which transaction factory should instantiate a component to process the incoming message. As described above transactions may destroy themselves when processing is completed and destruction of calls may also destroy any associated transactions.

As an example of transactions which may be instantiated for a component a SIP media server may be described. A SIP media server component associated with a SIP media server device may have a transaction manager such as a transaction manager to manage four transactions a call setup transaction a call teardown transaction a re invite transaction and a play file transaction. Granularity of transaction class definition may be used to limit stateful behavior and to reduce complexity.

As described above in relation to an attributes area such as attributes area may be utilized to manage transactions and interactions between transactions. Any stateful behavior may be encapsulated within a transaction to remove state based interdependencies from transaction class design. Any data persistence may be achieved through the use of attributes area . Accordingly transactions may be made more manageable for reuse and enhancement over time.

With the description above of SIP node and transaction based call model message flows will now be described. is a message flow diagram illustrating exemplary messages associated with a triggering transaction that may be processed by SIP components instantiated by an application such as application according to an embodiment of the subject matter described herein. In an options timer at an application server an instantiated SIP phone component and a SIP phone are in communication with each other. Referring to in line 1 of the message flow diagram an options timer at an application server expires and formulates and a TIMER NOTIFY trigger to a SIP phone component . In line 2 of the message flow diagram SIP phone component formulates a SIP OPTIONS message and forwards the SIP OPTIONS message to a SIP phone . In line 3 of the message flow diagram SIP phone responds with a SIP 200 OK message. The message flow diagram of may be used when registration of SIP phone component expires. The TIMER NOTIFY event in line 1 triggers the creation of an Option transaction associated with SIP phone component and the Option transaction associated with SIP phone component in turn sends the SIP OPTION message as a ping message in line 2 to SIP phone . SIP phone sends the SIP 200 OK message in line 3 as a Keep Alive message. When SIP phone component receives the SIP 200 OK message in line 3 of the message flow diagram the Option transaction may be destroyed. As described above the Option transaction may destroy itself upon receipt of the SIP 200 OK message.

SIP phone may respond in line 3 of the message flow diagram with a provisional SIP 100 TRYING message to indicate that it is trying to process the SIP INVITE message. Via internal API messaging as described above the Invite Out transaction associated with SIP phone component may forward SIP 100 TRYING message to the Invite Inbound transaction associated with SIP phone component . SIP phone component may formulate and send a SIP 100 TRYING message in line 4 of the message flow diagram to SIP phone .

SIP phone has no requirement to respond to the provisional SIP 100 TRYING message in line 4 of the message flow diagram. In line 5 of the message flow diagram SIP phone may send a SIP 180 RINGING message that may be communicated via internal API messaging as described above by the Invite Out transaction associated with SIP phone component to the Invite Inbound transaction associated with SIP phone component . In response SIP phone component may formulate and send a provisional SIP 180 RINGING message in line 6 of the message flow diagram to SIP phone .

When SIP phone is answered SIP phone may send a SIP 200 OK message in line 7 of the message flow diagram to indicate that communication may begin and that a dialog between SIP phone and SIP phone may be established. As described above the Invite Out transaction associated with SIP phone component may communicate the SIP 200 OK message to the Invite Inbound transaction associated with SIP phone component via internal API communications. In response the Invite Inbound transaction associated with SIP phone component may formulate and send a SIP 200 OK message in line 8 of the message flow diagram to SIP phone .

In line 9 of the message flow diagram SIP phone may respond to the SIP 200 OK message with a SIP ACK message. The Invite Inbound transaction associated with SIP phone component may forward the SIP ACK message of line 9 to the Invite Out transaction associated with SIP phone component and the Invite Inbound transaction associated with SIP phone component may destroy itself thereby removing the instantiated resources from the system. The Invite Out transaction associated with SIP phone component may formulate and send a SIP ACK message in line 10 of the message flow diagram to SIP phone and may destroy itself thereby removing the instantiated resources from the system. Upon receipt of the SIP ACK message in line 10 of message flow diagram a SIP call has been established between SIP phone and SIP phone .

The interface between SIP phone and SIP phone component and the interface between SIP phone and SIP phone component may be text based SIP interfaces binary based SIP interfaces or any other proprietary protocol such as VIP. As well any other protocol suitable of communication with a physical device may be substituted for the messaging described above in without departure from the scope of the subject matter described herein. Furthermore the SIP devices represented may be other devices such as for example media gateways or other physical devices without departure from the scope of the subject matter described herein.

Referring to in line 1 of the message flow diagram SIP phone may send a SIP RE INVITE message to initiate a call hold transaction. In response SIP phone component may instantiate an Invite Hold transaction. Through internal API messaging SIP phone component may communicate the SIP RE INVITE message to SIP phone component . In response SIP phone component may instantiate an Invite Hold transaction and may formulate and send a SIP RE INVITE message to SIP phone in line 2 of the message flow diagram. In line 3 of the message flow diagram SIP phone may send a SIP 100 TRYING message which may be processed as described above by the respective Invite Hold transactions associated with SIP phone component and SIP phone component to formulate and send a SIP 100 TRYING message to SIP phone in line 4 of the message flow diagram.

In line 5 of the message flow diagram SIP phone may send a SIP 200 OK message which is communicated through the internal API between the two Invite Hold transactions to result in a SIP 200 OK message in line 6 of the message flow diagram from SIP phone component to SIP phone . In response SIP phone may send a SIP ACK message in line 7 of the message flow diagram. The Invite Hold transaction associated with SIP phone component may forward the SIP ACK message of line 7 in the message flow diagram through the internal API to the Invite Hold transaction of SIP phone component and the Invite Hold transaction associated with SIP phone component may then destroy itself and remove its instantiated resources from the system. In response to receiving the API based SIP ACK message the Invite Hold transaction associated with SIP phone component may formulate and send a SIP ACK message to SIP phone in line 8 of the message flow diagram and may destroy itself and remove its instantiated resources from the system.

At this point in the message flow the call between SIP phone and SIP phone has been placed on hold. Though not depicted in a message flow similar to that of including the creation of new Invite inbound and Invite Out transactions may be used to re establish the call communication.

Referring to in line 1 of the message flow diagram a SIP BYE message is sent from SIP phone to SIP phone component . In response SIP phone component may instantiate a Teardown transaction which may forward the SIP BYE message through the internal API based communication to SIP phone component . In response a Teardown transaction may be instantiated at SIP phone component and a SIP BYE message may be formulated and sent to SIP phone in line 2 of the message flow diagram. In response to receiving the SIP BYE message SIP phone may send a SIP 200 OK message in line 3 of the message flow diagram. Upon receipt the Teardown transaction at SIP phone component may forward the SIP 200 OK through the internal API based communication channels to SIP phone component .

Because this is a call teardown transaction the call may be destroyed after communicating the SIP 200 OK message through the internal API to SIP phone component . Accordingly in response to communicating the SIP 200 OK message through the internal API SIP phone component may destroy the call and thereby release all instantiated resources associated with the call including any transactions such as the Teardown transaction from the system.

In response to receiving the API based SIP 200 OK message SIP phone component may formulate and send a SIP 200 OK message in line 4 of the message flow diagram and may destroy the call instantiation associated with SIP phone component . As described above the destruction of a call instance will also destroy all transaction instances associated with it including for example the Teardown transaction and will release any instantiated resources associated with the call and any transactions from the system.

At block process may identify a component associated with the call. For example SIP component may be identified as associated with the call to be established by a SIP INVITE message.

At block process may forward the signaling message to the component. For example the SIP INVITE message may be forwarded over API based interface to SIP component .

At block process may in response to receiving the signaling message at the component instantiating at least one of a call instance and a transaction instance associated with the call to process the signaling message. For example for the case of a SIP INVITE message call and transaction may both be instantiated. For other messages call may already exist and transaction may be instantiated.

At block process may process the signaling message using the transaction instance. For example transaction may formulate and send a SIP based INVITE message to SIP module .

At block process may in response to processing the signaling message delete at least one of the transaction instance and the call instance. For example for a call teardown transaction both call and transaction may be deleted. For a call hold transaction transaction may be deleting without deleting call .

At decision point transaction based call process may wait for a message such as for example a SIP message to be received. In response to receiving a message transaction based call process may begin a three level lookup by determining whether an existing dialog or call that is associated with the message at decision point . When process determines that there is not an existing dialog or call associated with the received message process may perform a second level lookup by determining whether a component associated with the message has an active entry in a routing table at decision point . When there is no active entry for the associated component in the routing table at decision point process may perform a third level lookup by searching a component locator database at decision point to locate a component definition for the component associated with the received message. Though not shown in appropriate error handling procedures may be implemented in the event that a component definition may not be located at decision point .

When a component is located in a component locator database at decision point an entry may be created in a routing table at block . At block in response to either creating an entry in a routing table at block or locating a routing table entry at decision point process may create a dialog or call entry in a dialog call database.

Upon creation of a dialog or call entry at block or when an existing dialog or call associated with the message has been identified at decision point the received message may be forwarded to the component at block .

At decision point process may determine whether an active call associated with the received message exists. Upon a determination that an active call does not exist process may instantiate a call at block . In response to instantiation of the call at block or when an active call has been determined to exist at decision point process may determine whether a transaction for processing the received message exists at decisions point . When a transaction for processing the received message does no9t exist process may instantiate a transaction for message processing at block .

When either a transaction already exists as determined at decision point or when a transaction is instantiated at block process may determine whether any existing attributes are needed by the instantiated transaction in order to process the received message at decision point . If attributes are needed attributes may be retrieved from an attributes area at block . At block in response to retrieving attributes at block or upon a determination that attributes are not needed at decision point process may process the received message.

Upon completion of message processing by the instantiated transaction or at any time during processing of the received message process may determine whether to store attributes in an attributes area for use by a later instantiated transaction at decision point . Upon a determination to store attributes process may store attributes at block .

In response to storing attributes at block or a determination not to store any attributes for the call at decision point a determination may be made at decision point as to whether call processing is complete for the call associated with the received message. If the call has not been completed process may determine at decision point whether the transaction is completed. If the transaction is completed process may destroy the instantiated transaction at block . When the transaction is destroyed at block or when a determination has been made at decision point that the transaction is not complete process may return to decision point to await receipt of a new message. If a determination is made at decision point the call is complete process may destroy the call at block . As described above destroying a call may also destroy any associated transactions to release instantiated resources of both the call and any transactions from the system. As well any attributes that are associated with the call may also be destroyed when a call is destroyed while attributes associated with the component may persist. At block process may delete the dialog or call entry from the dialog call database and may return to decision point to await receipt of a new message.

It will be understood that various details of the subject matter described herein may be changed without departing from the scope of the subject matter described herein. Furthermore the foregoing description is for the purpose of illustration only and not for the purpose of limitation as the subject matter described herein is defined by the claims as set forth hereinafter.

