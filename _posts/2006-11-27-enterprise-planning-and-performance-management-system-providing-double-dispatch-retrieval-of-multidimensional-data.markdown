---

title: Enterprise planning and performance management system providing double dispatch retrieval of multidimensional data
abstract: An enterprise software system provides an innovative double dispatch data retrieval technique that facilitates determining type safety during compile-time. The system includes an object store for storing a multi-dimensional dataset object. The dataset object provides an interface having a first function for instantiating a non-type-specific indexer object and a second function that returns a type-specific value of the plurality of data element currently referenced by the indexer object. The system also includes an object model that stores the dataset object to the object store, invokes the first function to instantiate the indexer object within the object store, utilizes the indexer object to reference the data element of the dataset object, and invokes the second function to retrieve the type-specific value of the data element referenced by the indexer object. Because the dataset provides the second method by which a type-specific value is returned, compilers may quickly determine type-safety concerns.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07895150&OS=07895150&RS=07895150
owner: International Business Machines Corporation
number: 07895150
owner_city: Armonk
owner_country: US
publication_date: 20061127
---
This application claims the benefit of U.S. Provisional Application Ser. No. 60 842 906 filed Sep. 7 2006 the entire content of which is incorporated herein by reference.

The invention relates to enterprise computing environments and more particularly to enterprise performance management systems.

Enterprise software systems are typically sophisticated large scale systems that support many e.g. hundreds or thousands of concurrent users. Examples of enterprise software systems include financial planning systems budget planning systems order management systems inventory management systems sales force management systems business intelligence tools enterprise reporting tools project and resource management systems and other enterprise software systems.

Many enterprise performance management and business planning applications require a large population of users to enter data that the software then accumulates into higher level areas of responsibility in the organization. The system may perform mathematical calculations on the data combining data submitted by one user with data submitted by another. Using the results of these calculations the system may generate reports for review by higher management.

The voluminous planning data captured via the enterprise software system is typically stored in one or more multidimensional data cubes. Individual computers associated with the enterprise planning system maintain an object store of data objects such as a dataset object to access relevant portions of the multidimensional data within the data cubes. To facilitate data access and traversal of the multidimensional data sets the object model may also instantiate indexer objects to calculate and maintain references e.g. indices into the datasets based on their dimensionality. For example a typical indexer object provides an interface having methods to address to a next data element within the datasets and return the data element currently referenced by the indexer. Typically an indexer object iterates through the data store via the move next method and returns the currently referenced data element once a get current method is called.

Often a generic Indexer object is used that may be used to traverse and access datasets of a wide variety of class types. The generic Indexer object returns the referenced data element as a generic object type even though in actuality the data object may be of a specific object type such as an object of type Double or Integer. While the generic Indexer object is flexible i.e. may be utilized by a wide variety of calling classes by returning a generic object type safety verification may be difficult if not impossible to perform on the values returned by the generic Indexer object due to its ability to return only generic data types capable of being assigned to an object of any type.

The invention is directed to enterprise planning and performance management techniques that facilitate multidimensional data retrieval while ensuring type safety. For example double dispatch data retrieval techniques are described that enable an object model to safely retrieve type specific data elements from multidimensional datasets via a generic indexer object. That is the generic indexer object is a non type specific indexer object capable of referencing data of any type within a dataset object. Through the use of this technique the object model may be assured of type safety during compilation instead of run time which may avoid the occurrence of costly and time consuming type safety errors during run time.

According to the techniques the dataset object provides an interface having methods by which an indexer object may be instantiated within the object store and a type specific data value of one of the plurality of data elements currently referenced by the indexer object may be returned respectively. The object model invokes a first method such as a constructor to instantiate the indexer object within the data store and utilizes the indexer object to reference one of the plurality of data elements of the dataset object in response to a data access request. The object model next invokes a second method to retrieve the type specific value of the data element currently referenced by the indexer object. In this manner the object model may return type specific values in response to the data access request via this double dispatch data retrieval technique without causing errors associated with type safety. The technique is referred to herein as a double dispatch technique in that the object model utilizes the indexer object to reference a data element within the multidimensional dataset but the indexer object itself does not provide a method for returning the requested element. Instead after utilizing the indexer to reference the correct data element the object model passes the indexer object to the dataset via the invocation of a method provided by the dataset object so that the dataset object may return a type specific data element.

In one embodiment a computer implemented method comprises storing a multidimensional dataset object to an object store within an enterprise software system. The dataset object stores a plurality of data elements arranged according to a plurality of dimensions. The dataset object provides an interface having a first function for instantiating an indexer object for referencing the data elements of the dataset and a second function that receives as input the indexer object and returns a type specific value of one or more of the data elements based on the reference information maintained by the indexer object. The method further comprises invoking the first function to instantiate the indexer object within the object store utilizing the indexer object to reference one of the data elements of the dataset object and invoking the second function and passing the indexer object as a parameter to the second function to retrieve a type specific value of the data element referenced by the indexer object.

In another embodiment a computing system comprises an object store for storing a multi dimensional dataset object. The dataset object stores a plurality of data elements arranged according to a plurality of dimensions. The dataset object provides an interface having a first function for instantiating an indexer object for referencing the data elements of the dataset object and a second function that receives as input the indexer object and returns a type specific value of one of the plurality of data elements based on the reference information maintained by the indexer object. The computer system further comprises an object model that stores the multi dimensional dataset object to the object store invokes the first function to instantiate the indexer object within the object store utilizes the indexer object to reference one of the data elements of the dataset object and invokes the second function and passes the indexer object as a parameter to the second function to retrieve a type specific value of the data element referenced by the indexer object.

In another embodiment the invention is directed to a computer readable medium containing instructions. The instructions cause a programmable processor to store a multidimensional dataset object to an object store within an enterprise software system. The dataset object stores a plurality of data elements arranged according to a plurality of dimensions. The dataset object provides an interface having a first function for instantiating an indexer object and a second function that receives as input the indexer object and returns a type specific value of one or more of the data elements based on reference information maintained by the indexer object. The instructions further cause the processor to invoke the first function to instantiate the indexer object within the object store utilize the indexer object to reference one of the data elements of the dataset object and invoke the second function and pass the indexer object as a parameter to the second function to retrieve a type specific value of the data element referenced by the indexer object.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention will be apparent from the description and drawings and from the claims.

For exemplary purposes the invention will be described in reference to an enterprise planning and performance management system such as an enterprise financial or budget planning system. The techniques described herein may be readily applied to other software systems including other large scale enterprise software systems. Examples of enterprise software systems include order management systems inventory management systems sales force management systems business intelligence tools enterprise reporting tools project and resource management systems and other enterprise software systems.

In general enterprise planning and performance management system enables and automates the reconciliation of top down targets with detailed bottom up forecasts for an enterprise. Enterprise planning and performance management system implements and manages an enterprise planning process which can be divided into three functions 1 modeling 2 contribution and 3 reconciliation.

Initially high level enterprise managers or executives referred to as analysts define organizational targets and build planning models for the enterprise. The analysts may include for example financial analysts such as the chief financial officer senior financial analysts or product and sales analysts. More specifically the analysts develop a model having a number of hierarchically arranged nodes representing various cost centers within the organization such as business units or departments. The analysts specify corporate target data for each node of the organizational hierarchy. Corporate target data may include financial data revenue data order data inventory data and the like depending on the particular enterprise planning activity being carried out by the enterprise.

Next the analysts assign one or more enterprise users to each node such as managers supervisors sales representatives lab managers or the like that are responsible for enterprise planning for the cost center corresponding to the node. Each enterprise user may be designated as a contributor that provides planning data to enterprise planning and performance management system a reviewer that accepts or rejects contributions from the contributors or both. The contributors and reviewers may be authorized users within the enterprise or within other entities coupled to network such as suppliers or customers.

Typically enterprise users that are designated as contributors interact with enterprise planning and performance management system to input detailed forecasts in the form of contribution data. As described above enterprise users may provide detailed financial forecasts revenue forecasts order forecasts inventory forecasts estimated resource requirements and the like depending on the particular enterprise planning activity being carried out by the enterprise.

Enterprise planning and performance management system automates the reconciliation of the forecast data with the corporate target data provided by the analysts. In particular enterprise planning and performance management system operates in accordance with a defined model i.e. the enterprise planning model created by the analysts to provide a hierarchical planning process having multiple reconciliation levels. As each of the contributors provides his or her contribution data enterprise planning and performance management system automatically aggregates the contribution data across the enterprise in real time and provides access to the aggregated data to enterprise users designated as reviewers associated with higher levels of the enterprise. In particular upon receiving contribution data from the contributors enterprise planning and performance management system identifies all higher levels of the organizational model affected by the newly received contribution data and calculates new aggregate totals at each level in real time.

Consequently the reviewers view aggregated data across the enterprise in real time during the enterprise planning session. At each level enterprise planning and performance management system ensures that the reviewers as defined by the nodes of the enterprise model reconcile the target data with the forecast data. Each of the reviewers may for example reject or accept the contribution data in view of corporate targets provided by the analysts. This process continues until the contribution data is ultimately approved by the highest level of the organizational hierarchy thereby ensuring that the contribution data from the contributors reconciles with corporate targets provided by the analysts.

In this manner enterprise planning and performance management system may provide more accurate enterprise planning than with conventional techniques. For example enterprise planning and performance management system may improve the accuracy and predictability of enterprise planning by enabling organizations to reconcile corporate models and organizational targets with detailed forecasts. The techniques may provide a platform that delivers collaborative real time planning capabilities without requiring offline consolidation and aggregation of forecasts. Because enterprise planning and performance management system can aggregate contribution data in real time all users can be presented with an accurate up to date view of the numbers. Further the architecture of enterprise planning and performance management system can readily scale to thousands of users and may be designed around best planning practices. In addition the techniques enabling high participation by enterprise users i.e. the contributors and reviewers allowing accurate planning cycles to be reduced.

Enterprise users may utilize a variety of computing devices to interact with enterprise planning and performance management system via network . For example an enterprise user may interact with enterprise planning and performance management system using a laptop computer desktop computer or the like running a web browser such as Internet Explorer from Microsoft Corporation of Redmond Wash. Alternatively an enterprise user may use a personal digital assistant PDA such as a Palm organizer from Palm Inc. of Santa Clara Calif. a web enabled cellular phone or similar device.

Network represents any communication network such as a packet based digital network like the Internet. In this manner system can readily scale to suit large enterprises. Enterprise users may directly access enterprise planning and performance management system via a local area network or may remotely access enterprise planning and performance management system via a virtual private network remote dial up or similar remote access communication mechanism.

Enterprise planning and performance management system may utilize a cutdown process by which the multi dimensional data store is sliced for each user in accordance with the defined enterprise model. During this process enterprise planning and performance management system identifies areas of the defined model to which users are assigned either as contributors or reviewers and slices the data store based on the assignments. When a given user logs in and proceeds with an enterprise planning activity enterprise planning and performance management system communicates the respective data slice to the respective computing device for display to the user via the extended spreadsheet application. In this fashion enterprise planning and performance management system need not communicate the entire model to each of users thereby reducing communication time as well as resource requirements. Instead each user receives only relevant information. Users interact with computing devices to capture contribution data and to reconcile the contribution data with organizational targets.

As described herein each of computing devices provide an innovative double dispatch data retrieval technique that enables planning applications not shown in to safely retrieve referenced data elements of a dataset via an indexer object. Typically the planning applications interact with an object model interface and more particularly an application programming interface API to specify requests to an object model. Via these requests the planning applications cause the object model to store a dataset to an object store wherein the dataset defines a first function for instantiating an indexer object and a second function that returns a type safe value of an item currently referenced by the indexer object. While storing the dataset the object model invokes the first function to instantiate the indexer object. Upon receiving a subsequent request for a data element of the dataset the object model utilizes the indexer object to reference the requested data element and invokes the second function to safely retrieve the value of the item referenced by the indexer object.

This data retrieval technique is double dispatch in that the object model utilizes the indexer object to reference the requested data element but a method of the indexer object itself is not used for returning the requested element. Instead the object model passes the indexer object to the dataset as an input parameter to the second function provided by the dataset object so that the dataset object may return a type specific data element. This innovated double dispatch data retrieval technique enables type safety because unlike conventional indexer objects the indexer object does not return a data element of a generic data object type. Instead the double dispatch data retrieval technique described herein allows the indexer object to remain generic in that the object model may utilize the indexer object for any type specific dataset object while the more type specific dataset object provides a type specific data element referenced by the indexer object. Thus during compilation of such objects the compiler may ensure type safety as no data elements are returned of a generic object type. Moreover the double dispatch data retrieval technique may in some instances avoid computing the reference to the requested data element as described below in more detail.

Planning applications represent planning applications executing on computing device A. For example planning applications may include reporting tools modeling tools spreadsheet applications data collection templates business intelligence tools or other types of enterprise planning applications.

Object model interface comprises an application programming interface API that exposes object model . For example object model may be a metadata model for data cube . Object store may comprise memory such as a cache that stores specific instantiations of object model .

In general object model represents any hierarchy of data objects and may comprise a series of collections and objects within the collections. In other words object model may comprises a hierarchy of objects each of which contains a collection which in turn provides access to one or more objects. Object model may be wrapped to protect the objects within the collections. In this way user A and planning applications cannot directly alter the data within object model . Instead planning applications interacts with object model via object model interface and more particularly API to specify operations object model may perform. In particular object model interface receives operation calls from planning applications via API and may return the result of the operations to planning applications .

In the example of enterprise planning user A may interact with web browser to enter and manipulate enterprise planning data such as budget or forecast data. Data sets contain multidimensional planning data which may include top down targets and bottom up contribution data and allows all calculations for an enterprise planning session to be performed locally by computing device A. Therefore in this example a contributor can modify his or her respective contribution data and perform calculations necessary for the enterprise planning process without necessarily accessing enterprise planning system . User A may save the planning data locally and submit the planning data to enterprise planning system for aggregation with the planning data from other users .

Enterprise planning and performance management system automatically aggregates the contribution data across enterprise in real time and provides access to the aggregated data to reviewers associated with higher levels of the enterprise. This process continues until the contribution data is ultimately approved by the reviewers associated with the highest level of the organizational hierarchy thereby ensuring that the contribution data from the contributors reconciles with corporate targets.

In one embodiment calculation engine and data sets are loaded for use during the enterprise planning session. Calculation engine may for example comprise a forward calculation engine wrapped in an Active X object built in an array based language. In other embodiments calculation engine may be implemented by creating layered function datasets within object store .

As illustrated in object store includes datasets and indexers . Datasets each comprises a multi dimensional object stored in accordance with object model . Indexers may each comprise an indexer object referencing data elements within one of datasets where one or more of indexers may reference the same one of datasets . Datasets may each be instantiations of classes implementing the IDataset interfaces where the IDataset interface includes two methods. The first method may comprise a getIndexer method to instantiate one of indexers and associate the newly instantiated one of indexers to the calling one of datasets . In some embodiments the getIndexer method may return an instantiation of a previously defined custom indexer class that was dynamically generated with the appropriate references to dataset . That is the getIndexer method may dynamically generate a custom indexer class at runtime and then instantiate an instance of the custom indexer class. Subsequent invocations of the first function to instantiate the indexer object may not need to regenerate the custom indexer class. The second method may comprise a getElement method that accepts an Indexer as a parameter. Upon invoking the getElement method by passing an indexer the getElement method returns value of the data element referenced by the passed indexer .

Indexers may each be instantiations of classes implementing the IIndexer interface where the IIndexer interface includes a third method for referencing the next data element of the associated one of datasets . The third method may comprise a moveNext method whereupon invoking the moveNext method the calling indexer moves or updates its reference to an associated one of datasets such that the reference references the next data element within datasets . The moveNext method moves the reference to the sequential next data element of the associated dataset .

That is indexers reference datasets according to an order which may follow the order defined by the underlying dataset. In other embodiments a custom view of a dataset may be defined by selecting the data elements in accordance with a pattern. In some cases an indexer may sequentially follow the pattern described by the custom view yet traverse the underlying dataset in a non sequential pattern. Moreover the indexer may not necessarily traverse all of the elements of the dataset and may access some of the elements multiple times depending on the defined view. Examples of a virtual dataset capable of defining a custom view of a dataset are described in U.S. Patent Publication No. 2008 0046481 filed Nov. 28 2006 entitled VIRTUAL MULTIDIMENSIONAL DATASETS FOR ENTERPRISE SOFTWARE SYSTEMS the contents of which are incorporated herein by reference.

Planning applications specify operations via API that object model performs upon object store . These operations such as the select operation described below may require object model to instantiate datasets and indexers . In particular object model may instantiate datasets having IDataset interfaces for example. Once instantiated object model instantiates and associates an indexer by calling the getIndexer method described above using the newly instantiated one of datasets as the calling object. After instantiating dataset and an associated one of indexers object model may await further operations such as a data request issued from one of planning applications via API .

Upon receiving a subsequent data request for example object model may access the appropriate one of indexers that references the one of datasets that stores the requested data. Object model utilizes this indexer to reference the data element of the appropriate one of datasets that stores the requested data and more particularly invokes the moveNext method until the associated indexer references the requested data element. Once the associated indexer references the requested data element object model next invokes the second method or getElement method of the appropriate one of datasets passing the associated indexer as a parameter for the getElement method. Upon invoking the getElement method the appropriate dataset safely returns the value of the request data element referenced by the associated indexer . Safely above refers to safely returning a type specific object instead of a generic object which would not ensure type safety. Thus safely refers to type safety. This double dispatch data retrieval technique enables compilers to determine type safety of the underlying classes at compile time unlike conventional data retrieval techniques that do not support type safety determination during compile time. By enabling type safety checks at compile time object model may safely invoke a generic indexer without fear of violating type safety concerns during run time unlike conventional data retrieval techniques that may encounter debilitating type safety issues during run time with little recourse.

Each of datasets may comprise a collection of data elements A N data elements storing multi dimensional data. Alternatively as shown in this example datasets include one or more virtual datasets. Virtual dataset N for example may be referenced and manipulated as multidimensional data set. However instead of storing actual multidimensional data the virtual datasets contain reference information for resolving to all or portions of one or more underlying multi dimensional data sets when necessary. The virtual datasets may be manipulated in the same manner as a real dataset that stores multidimensional data. In this regard the virtual datasets are generally indistinguishable from real datasets from the view of enterprise software applications. The enterprise software applications can create virtual datasets and perform intermediate operations to manipulate the virtual datasets without necessarily resolving the virtual datasets to the multidimensional data contained within the underlying datasets. In this manner the virtual datasets do not consume vast amounts of resources by storing multidimensional data. Further the virtual datasets avoid any consistency and synchronization issues that may arise when separate datasets storing multidimensional data are created and manipulated.

In the example of each of indexers maintains respective indices or other reference information to address and traverse the multidimensional data of their constituent datasets based on the dimensionality of the respective dataset. For example indexer N maintains pointers A B and identifier ID . As discussed in further detail below indexer N maintains a pointer B to traverse the ordered reference information of virtual data set N and maintains an additional pointer A to reference data elements of dataset A from which the data elements N were selected. Typically pointers A B store a memory address that references the beginning memory address of a referenced data element A N. Alternatively indices may be maintained to identify particular data elements along the dimensions of the datasets. ID represents an identifier or handle that identifies indexer N to the one of datasets that originally instantiated it i.e. dataset N in this example.

Initially object store may comprise no datasets or indexers . Object model may receive requests to instantiate datasets via API . For example via API object model may receive the following select operation to create a virtual dataset 

where the resultant dataset N represents a virtual dataset dataset A represents a source dataset and dataset B represents a selector dataset. Upon receiving the above select operation object model instantiates virtual dataset N. However in this example data elements of dataset N are not actual data elements but instead represent reference information that when resolved contains indices to the underlying selection of data elements of dataset A as defined by selector dataset B.

Upon instantiating datasets in some embodiments object model automatically instantiates one of indexers for each of datasets so as to reference data elements stored within datasets . In other embodiments object model may not automatically instantiate one of indexers for each of datasets but may await a data access request from planning applications via API before instantiating an indexer for the one of datasets that stores the requested data in its data elements .

Assuming indexers are instantiated in response to receiving a data access request object model instantiates indexers via a getIndexer method defined within the IDataset interface. The getIndexer method may allow object model to define patterns so as to satisfy the particular data access request. Returning to the virtual dataset example described above in response to a data request for data elements of virtual dataset N object model may invoke the getIndexer function as follows 

Indexer N in this instance is associated with virtual dataset N and its ID links indexer N to virtual dataset N. Pointer B comprises an address into virtual selection dataset N and in particular the address of data element A of dataset N.

Upon receiving the data access request and instantiating one of indexers A object model calls the getElement method via the appropriate one of datasets to retrieve the value stored to the one of data elements A N currently referenced by pointers A B. For example object model may make the following call to retrieve a data element 

In this instance example indexer N determines that the referenced dataset i.e. dataset N invoked the getElement method is a virtual data set. Instead of utilizing pointer B which references virtual data elements within virtual dataset N indexer N utilizes pointer A to directly access data element A from the underlying dataset A. In other words for virtual dataset N indexer N maintains a second internal pointer A in addition to pointer B. In response to the getElement call indexer N recognizes that the dataset being traversed is a virtual dataset and instead of using pointer B which maintains a location within the ordered selection utilizes pointer A instead to retrieve data directly from the underlying non virtual dataset A. In this embodiment when moveNext is called indexer N increments pointer B to traverse the ordered virtual data elements of virtual dataset N and performs the necessary computations to update pointer A according to the pattern i.e. custom view defined by the selection used to create virtual dataset N. Object model repeats this process until the data access request is satisfied. In this manner embodiments optimizations may occur within object store such that indexers does not need to re compute pointers upon being passed into a getElement method of its originally instantiated one of datasets . For example as discussed above a selected order of data elements may be sequentially traversed with an indexer using a moveNext call. However provided the indexer has knowledge of the structure of the underlying datasets as in the above example the indexer need not recompute the pointer s into the underlying dataset s in response to a getElement call even though data elements are selected from those underlying datasets in a non linear pattern. In this manner the double dispatch data retrieval technique may allow for quick and efficient data retrieval via the above described optimization as well as facilitate type safety concerns.

Initially object model of computing device A may instantiate any number of datasets within object store for access to one or more data cubes storing multidimensional data . In some embodiments object model instantiates datasets during the cut down process described above and instantiates datasets according to the user logging into enterprise planning and performance management system . In other embodiments object model instantiates object model with datasets only upon receiving requests from planning applications to access or manipulate all or portions of multidimensional data from the data cubes. Assuming indexers are only instantiated upon receiving a data access request from planning applications via API object model awaits a data access request from planning applications .

Upon receiving a data access request object model instantiates an indexer A for example to reference the appropriate one of datasets via a first method which in this case it is assumed dataset A represents the appropriate one of datasets because it stores the requested data in data elements A N . As described above the first method includes a getIndexer method which instantiates and associated indexer A with dataset A.

Upon instantiating indexer A object model may invoke a second method e.g. a moveNext method to initialize indexer A to the first data element which may be defined by a pattern or a custom view of the underlying data set . If that method does not return false i.e. the pattern has not been completely traversed no of the object model invokes a third method e.g. a getElement method to retrieve the value of the data element referenced by pointer A . As described above the optimization may apply to this process whereby ID A may enable dataset A to quickly return a type safe data value without having to re compute pointer A even after invoking the moveNext method.

After object model receives either a type safe data value or a generic object the object model invokes the moveNext method and determines whether it has satisfied or finished processing the data access request . If object model determines it is not finished NO it again next invokes the getElement method to retrieve the next portion of requested data determines if it is finished and continues this process until it retrieves all requested data .

If object model determines that it finished processing or satisfied the data access request it returns the requested data to the one of planning applications that issued the data access request.

In this manner by implementing the double dispatch data retrieval technique object model may utilize a generic indexer yet assure type safety of requested data as it was previously assured during compilation unlike conventional data retrieval techniques that must face type safety issues during runtime. Moreover because indexers remain generic numerous type specific indexers each instantiated according to their type specific class are not needed to ensure type safety thereby keeping the complexity of the interface relatively low. Finally the optimization discussed above may enable quick and efficient data retrieval despite implementation of the more sophisticated double dispatch data retrieval technique.

Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

