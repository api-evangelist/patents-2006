---

title: Ontology-driven information system
abstract: An ontology-driven information system includes a plurality of models, each of which expresses an aspect of a business domain using concepts and relationships between concepts. An ontology, which is in communication with each of the plurality of models, provides uniform definitions for the concepts and relationships between concepts used in the plurality of models. A method for executing an interaction flow model includes receiving an event and categorizing the received event. Once the event is categorized, a situation that matches the categorized received event is identified. One or more tasks are then executed for the situation. The execution of the one or more tasks can include either an interpretation of a model or the execution of a method of an object. The information system also includes a user and application interface and a reasoning engine that is in communication with the user and application interface. A knowledge manager is in communication with the user and application interface and is interfaced with the reasoning engine. A distributed information service also is in communication with the reasoning engine, the knowledge manager, and the user and application interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07567915&OS=07567915&RS=07567915
owner: 6100198 Canada Inc.
number: 07567915
owner_city: West Vancouver
owner_country: CA
publication_date: 20061020
---
This is a division of application Ser. No. 09 642 200 filed Aug. 18 2000 now U.S. Pat. No. 7 200 563 entitled Ontology Driven Information System which claims the benefit of U.S. Provisional Application No. 60 150 204 filed Aug. 20 1999 entitled Ontology Driven Information System and U.S. Provisional Application No. 60 165 147 filed Nov. 12 1999 entitled Ontology Driven Information System all of which are incorporated herein by reference.

The present invention relates generally to computers and more particularly to an ontology driven information system.

Since the development of the Internet s World Wide Web the web the number of companies engaged in electronic commerce e commerce has steadily increased. Indeed companies now offer a multitude of products and services online. By conducting business on the web companies can decrease operational costs and expedite business activities. The web is also an effective medium for presenting information to and gathering information from customers.

To gain an edge in the increasingly competitive marketplace companies must interact with their customers in an intelligent personalized and productive manner. One way for companies to further this objective is to create meaningful interactions with customers on the web. At present many e commerce systems do not enable companies to create meaningful two way interactions with customers but instead merely implement one way transactions e.g. processing an order or a service request initiated by the customer. As such these e commerce systems do not help companies interact effectively with their customers on the web.

To enable meaningful interactions with customers on the web an e commerce system should provide the following functionality. First the system must access data that is distributed across numerous sources and react to events coming from numerous sources. In the case of a large enterprise the data may reside in relational database management systems RDBMSs flat files and large scale packaged applications. The events may come from Internet feeds news services and e commerce systems exchanges . In addition the events may come from event based Internet middleware. Second the system must analyze the distributed data and transform such data into an intelligent personalized recommendation in real time. If the analysis is not conducted in real time then the customer will have to wait for the intelligent personalized recommendation. Any significant delay e.g. a few minutes decreases the likelihood that the customer will act on the recommendation. Third the system must accommodate frequent changes in business conditions. In particular it must be easy to change the business rules and business processes used to transform the data into the intelligent personalized recommendation. If the business rules and business processes cannot be easily changed then the system will not be able to keep up with the way the company is doing business.

Unfortunately existing e commerce systems do not provide the above described functionality. One known e commerce system generates personalized recommendations by matching business rules against customer attributes e.g. age group geographic region and buying history. In this e commerce system however it is difficult to change the business rules to adapt to changing business conditions. To illustrate this point examples of the business rules used in this system are shown below 

In the event that business conditions change Rule Nos. 1 and 2 must be changed to reflect the new business conditions. For example consider a situation in which market analysis shows that the age group breakdowns in Rule Nos. 1 and 2 should be changed from 18 30 years old and 31 50 years old to 18 34 years old and 35 50 years old respectively. To implement this change it would be necessary to change each occurrence of 18 30 years old to 18 34 years old and to change each occurrence of 31 50 years old to 35 50 years old. As there are only two business rules in this simplified example making the required changes is not a major undertaking. To adequately model any non trivial domain however hundreds or thousands of business rules may be required. Thus in real world applications the process of changing myriad business rules in the form of Rule Nos. 1 and 2 is not only tedious but also prone to error. Moreover because the business rules are typically entered on a logic language level skilled computer personnel is generally required to implement the changes. This is problematic because non technical business managers may not be able to change the business rules as quickly as needed to keep up with the way the company is doing business.

Another example of changing business rules is the occurrence of additional context that requires that a different result be implemented when a given rule is satisfied. For instance the system may be required to incorporate a customer s purchase history to formulate an intelligent recommendation. By way of example if a customer has recently purchased a tent then a recommendation suggesting that the customer purchase a tent would normally not be considered to be an intelligent recommendation.

In view of the foregoing what is needed is an e commerce system that analyzes distributed data and transforms such data into intelligent personalized recommendations in real time using flexible business rules that can be easily adapted to ever changing situations.

Broadly speaking the present invention fills this need by providing an information system that transforms raw data from disparate sources into intelligent personalized recommendations that may be used to drive business transactions.

In accordance with one aspect of the invention an ontology driven information system is provided. This information system includes a plurality of models each of which expresses an aspect of a business domain using concepts and relationships between concepts. An ontology which is in communication with each of the plurality of models provides uniform definitions for the concepts and relationships between concepts used in the plurality of models. The use of the uniform definitions in the plurality of models avoids redundancy in the models provides consistency between the models and enables the plurality of models to provide an overall model of the business domain that is more expressive than an overall model based on a plurality of models that does not use uniform definitions. In one embodiment the uniform definitions in the ontology can be changed on the fly by a business manager.

In accordance with another aspect of the invention a method for executing an interaction flow model is provided. This method includes receiving a plurality of events and categorizing the received event events. Once the events are categorized a situation that matches the categorized received events is identified. One or more tasks are then executed for the situation. The execution of the one or more tasks can include either an interpretation of a model e.g. a rule base or the execution of a method of an object.

In accordance with yet another aspect of the invention an information system is provided. The information system includes a user and application interface and a reasoning engine that is in communication with the user and application interface. The system further includes a knowledge manager that is in communication with the user and application interface and is interfaced with the reasoning engine. A distributed information service also is in communication with the reasoning engine the knowledge manager and the user and application interface. The reasoning engine may be configured to work in conjunction with the knowledge manager to enable the reasoning engine to handle events by executing one or more specific tasks prescribed by the knowledge manager to handle the events most appropriately. In one embodiment the knowledge manager includes an interaction flow model that is a repository for abstract situations to handle the events received by the reasoning engine with the situations defining the one or more tasks that are to be executed by the reasoning engine.

In another embodiment the information system includes a reasoning engine and a knowledge manager. The reasoning engine may be configured to derive a set of conclusions using a set of premises and to execute actions that are attached to the set of conclusions. The set of premises may be encoded using a plurality of models. The knowledge manager serves as a repository of the plurality of models. Each of the plurality of models is configured to define situations that occur in decision making to achieve a goal state. The knowledge manager includes an ontology which is a collection of concepts and contexts used to provide a common vocabulary for defining rules querying disparate data sources and making actionable recommendations. As such the ontology provides consistency between the plurality of models.

In accordance with a further aspect of the invention a computer readable media having program instructions for executing an interaction flow model is provided. The computer readable media includes program instructions for receiving an event or a plurality of events program instructions for categorizing the received events program instructions for identifying a situation that matches the categorized received events and program instructions for executing one or more tasks for the situation. The execution of the one or more tasks includes one of an interpretation of a model and execution of a method of an object.

The information system of the invention enables e market participants to apply business rules to data captured from disparate sources e.g. existing enterprise databases and the Internet to match buyers interests with sellers expertise taking into account goals preferences behaviors and market context. In this manner the information system provides more accurate and timely recommendations that increase the likelihood that a transaction will occur at the moment of contact. Such accurate and timely recommendations also increase customer satisfaction and thereby reduce customer attrition. Another advantage of the information system is that it uses business rules that are constructed using ordinary terms that can be changed on the fly by a non technical business user. This helps reduce maintenance costs and increase responsiveness.

It is to be understood that the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention as claimed.

Several exemplary embodiments of the invention will now be described in detail with reference to the accompanying drawings.

Distributed information service interacts with database enterprise information systems EIS and other resource managers not shown . In one embodiment distributed information service uses J2EE specified contracts to interact with these components. In one embodiment database includes one or more relational database management systems RDBMS . Additional details of distributed information service are set forth below with reference to .

Knowledge manager provides the functionality that is required to store and manipulate ontologies and other models of a domain. As part of an ontology knowledge manager maintains concepts and relationships to construct business rules constraints and processes. Business models use these rules constraints and processes to capture knowledge about a specific business domain. This knowledge may be used to reason about the domain and to derive actions to achieve stated goals. The use of concepts and relationships provides a higher abstraction on which business models can be built. This is advantageous because it enables the business models to be built more efficiently and to be managed more easily. Knowledge manager communicates with distributed information system and user and application interface through architected contracts. Additional details of knowledge manager are set forth below with reference to .

Distributed information service provides the functionality that is required to access heterogeneous distributed data sources. More particularly distributed information service is a collection of services that shield other modules of information system as well as external applications from the details of accessing disparate information resources. Thus distributed information service provides a uniform and simple way to access these information resources. Each information resource may be accessed via a Uniform Resource Identifier URI which is a logical name that hides the location and the access protocol from the resource consumer. Furthermore transaction and security management is handled outside the application. Distributed information service manages a repository of information about the resource and uses that information to locate the external resource manager to establish a connection with the resource manager and to interact with the resource manager to e.g. store and retrieve data. This augmentation information also is used to translate the external data into a uniform format that can be processed by client applications as well as various presentation channels. Distributed information service communicates with reasoning engine knowledge manager and user and application interface through architected contracts. Additional details of distributed information service are set forth below with reference to .

In one embodiment the architecture of user and application interface is based on three technologies Java Components XML based access protocols and Business Model Languages. Java Components are Java objects that offer an interface to call methods which implement or make accessible the functionality provided by information system . These components may be implemented using EJB which is the standard component model for Java. Suitable XML based access protocols include but are not limited to 1 HTTP with HTML or a specific XML content format and 2 JMS with specific XML content format. The Business Model Languages deal with the capturing of knowledge that is entered into the system by a business user. This component of user and application interface is concerned with representing the business rules processes and constraints that form a model of the business.

User and application interface provides components to access services that are implemented in other modules e.g. the distributed information service. The intrinsic functionality of user and application interface also may be accessed via components. As used in connection with the description of the invention the term component refers to an object that provides access to data or logic or assembles data or logic. Thus the data or logic need not be implemented by the component. Generally speaking it must be possible to access the components through a remote client. By way of example this remote client may be a browser or another application. To this end the interface components may be implemented as EJB components. These components which provide access for multiple remote clients where each client is isolated from the activity of other clients encapsulate the state of a client session. In one embodiment the intrinsic functionality of user and application interface is abstracted by a set of commands. These commands may be accessed via a component or a command language interpreter.

System administration interface contains commands to configure the resource environment and to monitor running services. As such system administration interface provides the functionality that is required to let a user enter resource naming and location information. Each information collection that can be retrieved from information system can be specified using a Uniform Resource Identifier URI which is mapped and located by distributed information system as described in more detail below. Table 1 illustrates exemplary commands contained in system administration interface .

Application deployment interface is the process that configures a specific application for its runtime environment. Table 2 illustrates exemplary commands contained in application deployment interface in accordance with one embodiment of the invention.

Business modeling interface is concerned with the creation and management of business models. By way of example business models include rule bases and business process flows. Business modeling interface serves as the entry point into information system for business personnel e.g. business line or marketing campaign managers and provides the functionality that is required to enable these users to enter business rules constraints and processes. In one embodiment business modeling interface implements the abstract commands shown in Table 3.

Application object system allows an application to interface with information system using Java objects of the modeled domain. Information system uses the application schema to construct these objects. Application object system also is used to integrate information system with tools that support or automate the process of building a graphical representation e.g. a user interface. The objects that are constructed represent a model of the domain. This model can be used in Model View Controller type user interfaces. The model includes objects that are defined in an application schema e.g. objects such as Customer Product or Offer. The objects of the domain model preferably comply with the Java Beans specification. This allows information system to use standard tools to build views and controllers corresponding to the object model. In this manner application object system transforms the generic representation of information items into a typed object system.

Delivery channel interface provides access to the services provided by information system via communication protocols. This submodule also is concerned with the preparation of the content for display or further processing by a remote client. Delivery channel interface serves as the entry point into information system for end users and provides the functionality that is required to deliver the personalized product and service recommendations. One function of delivery channel interface is to provide mechanisms to extract information from information system in a generic form. These mechanisms stand in contrast with application object system which represents domain objects as strictly typed Java Beans.

Delivery channel interface also enables the exchange of XML data with the information system environment. Thus any software system e.g. middleware that is able to process XML structured data and supports one of the channel protocols can communicate with information system . Every information set that can be retrieved from information system can be specified using a Uniform Resource Identifier URI . In contrast with Uniform Resource Locators URLs a URI does not encode the location of the resource. Information system maintains a repository of resource references and locates the resources based on the URI. As will be described in more detail below a URI is mapped and located by distributed information service .

As noted above information system supports a number of communication protocols. Delivery channel interface allows further protocols to be added. In one embodiment the HTTP HTTPS protocol family with the following content formats is supported initially SOAP Simple Object Access Protocol WML Wireless Markup Language and HTML the World Wide Web protocol . All of these protocols use some specific form of XML as the data content format. Delivery channel interface also provides components that encapsulate particular services of information system . These components which belong to a special system domain are used to access information and recommendations from generic applications. They do not implement the functionality but rather delegate the requests to the specific modules. Examples of such components include the interaction flow engine and the distributed information service both of which are described in detail below.

In one embodiment each engine that is part of reasoning engine acts upon its own model. As used herein a model is a representation of an aspect of the business domain. The engine and the models are tuned to one another thereby providing an efficient way to describe a part of the business domain and to perform efficient reasoning on the model. As used herein reasoning refers to the process of reaching conclusions based on a formal representation of the domain e.g. a model and an inference procedure. Reasoning engine reacts to changes in the information system environment by use of user and application interface and the distributed information service . These modules act as the sensors and actors to the outside world. When acting in the capacity of sensors these modules deliver events and thereby cause the invocation of reasoning engine and more particularly interaction flow engine

Interaction flow engine provides the functionality that is required to coordinate the usage of external data ontologies business rules business constraints and optimization parameters. As indicated above interaction flow engine invokes specialized engines that are able to interpret specialized models. In a given business context interaction flow engine generates a set of candidate recommendations e.g. goods services or information based on a customer profile and a set of business rules and constraints. The customer profile may reflect the customer s interests and the business rules and constraints may reflect the business expertise and goals. Interaction flow engine then prescribes the collection of feedback at the time when the interaction happens. Interaction flow engine may further specify that the recommendations be optimized based on the feedback and other contextual information the optimization models and further business rules. It will be apparent to those skilled in the art that because the process flow is model driven other business interactions may be specified easily.

Interaction flow engine uses an interaction model to drive the recommendation process. This interaction model is described in more detail below see the description of interaction flow model set forth below with reference to . Interaction flow engine communicates with distributed information service through an architected contract. In particular interaction flow engine invokes methods of arbitrary Java objects. These Java objects are located using the services of distributed information service . Furthermore interaction flow engine uses the interfaces of inference engine constraint satisfaction engine and optimization engine

Interaction flow engine is responsible for initiating actions based on the precepts of the environment. The general execution principle is as follows 

1. Identify which situation of the situations specified in the interaction flow model is most appropriately reflecting the real world. To do this interaction flow engine invokes categorization engine which as described in more detail below classifies events and other available and relevant information e.g. user input and information stored in a database .

2. Categorization engine determines a set of categories for events that have occurred. A preceding situation that has been dealt with is an event. Further the categorization engine determines a set of categories for information entities that are stored in a database and that are relevant for classifying a situation.

3. Based on the categorized events and categorized input data a situation action is selected and the associated actions are executed. The actions may be the interpretation of a model one of the built in actions or the execution of a method of an object. Model related actions include for example infer search with constraints interact optimize decide etc. A situation can describe multiple alternatives and loops. The decide action describes a branch in the flow.

4. After the situation is dealt with i.e. the termination state is reached the completion of the situation is recorded as an event.

Step 1 is similar to identifying the state in a classic workflow engine. The process of situation identification is however more powerful than simple state transition models because it takes into consideration that the flow is interrupted after a situation is dealt with. Even if the situation prescribes the transition into a follow up situation as states do when the transition into a new state is made the new situation does not occur unconditionally. It also is not deterministic when the following situation occurs. Often it depends on when and what feedback the user provides. Interaction flow model see may specify the usage of another model e.g. a rule base to evaluate what situation most appropriately reflects the real world situation.

Interaction flow engine uses distributed information service see to locate a Java object that is an information resource. Interaction flow engine need only provide a Uniform Resource Identifier URI to distributed information service to locate the Java object. Distributed information service manages the additional information that is needed to look up the desired object and does the lookup for interaction flow engine

Categorization engine provides the functionality that is required to categorize objects which can be information entities or events. An information entity may be stored in an external system or sent to information system using one of the interfaces. Events may be created in storage systems or an application or may be delivered via one of the channel interfaces. During categorization all concepts of which that object is an instance are determined. Categorization engine uses the properties and relationships of a concept to test the membership. The properties and relationships of a concept are defined in conceptual model which is described in more detail below with reference to . Categorization engine may use a number of techniques to perform classification which include but are not limited to property value testing exemplar approximation and probabilistic techniques. Categorization engine may receive requests for categorizations from interaction flow engine and inference engine In addition categorization engine uses the interfaces of conceptual model see .

Inference engine which also may be referred to as a rule engine provides the functionality that is required to perform logical inference. Logical inference which is sometimes referred to as deduction is the process of deriving conclusions that are entailed in a set of rules and a set of facts known to be true. A rule is a pair of premise or antecedent and conclusion or consequent. A set of rules e.g. a rule base is compiled into an efficient form for execution by inference engine . During logical inference the entailment relation over a set of rules and a set of facts is computed. The inferred knowledge is useful only if it helps to take actions. The actions may be taken by interaction flow engine which uses the inferred statement. Inference engine uses the interfaces of rule base which is described in more detail below with reference to .

Constraint satisfaction engine provides the functionality that is required to search for states in the state space that satisfy a number of constraints and the goal test. Thus constraint satisfaction is a modified search problem and constraint satisfaction engine is a special kind of search engine. In this context states are instances of concepts. Constraints can be either absolute or preferences. Violation of an absolute constraint rules out a potential solution. In the case of preferences one solution is preferred over another. Constraints may be dynamically inferred by inference engine or taken from a profile or constraint base which is managed in constraint model see the description of constraint model set forth below with reference to . A set of constraints e.g. a constraint base is compiled into an efficient form for execution by constraint satisfaction engine . Furthermore constraint satisfaction engine uses the interfaces of inference engine constraint model see and query service see .

An example of a constraint satisfaction problem is the search for products that match certain criteria. In this case the inference engine is invoked first and the inferred concepts and constraints are taken and passed to the constraint satisfaction engine. The inference engine does not search for instances of the concepts. Rather the inference results are interpreted as constraints by the constraint satisfaction engine. The constraint satisfaction engine now combines the constraints with a search strategy to come up with appropriate instances. The instances may be particular objects such as goods services and information. In many cases the constraint satisfaction engine may reformulate the constraints into a query that is passed on to the query service in the distributed information service.

Optimization engine provides the functionality that is required to find an optimal solution among a number of candidate solutions. Optimization engine is used when a problem may be solved by selecting a solution that is optimal with respect to an optimization criterion. This typically requires that a metric exist. Finding a solution e.g. a set of products to recommend by optimization usually leads to more accurate results than simple constraint bound searching. Optimization engine communicates with distributed information service through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information service . Furthermore optimization engine uses the interfaces of ontology which is described in more detail below with reference to . The meaning of the terms that are used in an optimization model is defined via the ontology and this knowledge may be used in interpreting the model.

Data mining engine provides the functionality that is required to analyze the correlation in data and to build a predictive model from that correlation. Stated differently data mining engine implements the functionality to build predictive models. A predictive model takes the properties of an instance or a set of instances and produces the value of another property or relationship that is not stored in the external storage systems. By way of example representative predictions include a person s tax bracket based on income marital status and number of children and a person s behavioral cluster based on previous purchases. Data mining engine communicates with distributed information service through an architected contract.

An ontology managed by information system typically contains multiple concepts and relationships between concepts. The complexity of a business domain is captured mainly in the relationships between concepts because a concept alone is usually too simplistic to be helpful. In contrast relationships between concepts are potentially very rich. A few fundamental relationships between concepts are found in many ontologies. These fundamental relationships are meronymy hypernomy and synonymy. Meronymy is defined between a whole concept and its partial concepts and is called the HAS A relationship. Hypernomy is defined between a concept and its subconcepts and is called the IS A relationship. Synonymy exists within a number of terms referring to a concept if one can be used for the other and the meaning would be the same relative to a specified context.

Interaction flow model manages multiple interaction flow models that is it performs operations such as creation reading modification and deletion with these models. An interaction flow includes a number of situations. Each situation has a context description that contains the event concepts that a situation requires in order to occur. An interaction flow is compiled into an efficient form for execution by interaction flow engine see . Interaction flow model communicates with distributed information service through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information service . Furthermore interaction flow model uses the interfaces of ontology . In particular the meaning of the terms that are used in interaction flow model is defined via ontology . This knowledge may be used in interpreting the model.

Ontology of information system serves as the common thread between all other models. For this reason information system is therefore an ontology driven information system. In a more general sense but still in the context of the information system described herein an ontology helps to formulate and relate various other knowledge representation models which usually are based on first order logic or interaction flow. Concrete models typically use a vocabulary. The vocabulary may be made up of words and word phrases of the particular domain. To relate different models a commitment to the meaning of the vocabulary is needed. If for instance one model makes propositions about a conservative investor then another model can refer to the same concept and assume the same intention for the concept. Ontology is linked to all of the other models by terms that are used in those models and that are defined in the ontology. Ontology communicates with distributed information service through an architected contract.

Each knowledge representation model refers to a conceptualization of the domain. A conceptualization is a model that represents the domain as concepts. A concept is an abstraction for a set of things. The set also may be called a category or class. The process of assigning a thing to a category is called categorization or classification. A conceptualization gathers relationships between concepts especially the relationships between concepts and their properties which also can be concepts. Those skilled in the art will appreciate that concepts exist independently of the words that are used to denote the concepts. For instance the concept to which the English noun bench refers exists independently of the existence of the English language. Indeed in the German language the noun bank is used to refer to this concept. However the English noun bank refers to a different concept.

Humans categorize concrete objects of the world as instances of concepts. Concepts are very useful for expressing knowledge so that it is understood by computer based interpreters. Here understanding refers to the derivation of conclusions and actions. Humans use concepts to cope with the limitations of the human memory. The knowledge that humans have about even simple concepts is huge and differs from person to person. A conceptualization allows humans to reason about the knowledge without having to process the associated knowledge completely. Often it is perfectly reasonable to categorize an object and reason about it using the concept. The irrelevant properties of that instance are simply ignored. Thus there are two basic operations in which a conceptualization is used categorization of an object and inference using the concept.

An ontology relates a modeling language to a conceptualization. The relation is indirect because the ontology specifies the intended meaning of a vocabulary in the modeling language. If the vocabulary is used in these models then the models commit themselves to that meaning. This commitment restricts the models that can be expressed using that modeling language. It also means that different models enter a mutual commitment via the ontology. The various models agree with the meaning of the terms that they use and will not contradict the meaning that is formulated in the conceptualization. The models can and will add more knowledge around the concepts but they do not redefine the terms. For those models the terms have an inner structure that is solely defined outside of the model. The model would otherwise treat the terms as atoms.

An ontology is very closely related to but not the same as a conceptualization. Two different ontologies can be linked to the same conceptualization. For instance take the conceptualization of mortgages plus an ontology that uses French terms and another that uses English terms. Using an ontology in a modeling language is essentially the same as declaring publicly that the terms of the vocabulary refer unambiguously to particular concepts of the conceptualization. Although a conceptualization may have more than one or no ontology an ontology is practically useless without a conceptualization.

Conceptual model manages the creation modification and deletion of concepts which form the basis of a conceptual model. A concept is represented by a set of properties and relationships. The concept may be named using the ontology. In fact a concept may have different names in different ontologies. Conceptual model communicates with distributed information service through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information service .

Rule base manages multiple rule bases. A rule base is a set of rules that are used together during inference. As described above a set of rules is compiled into an efficient form for execution by inference engine see . Rule base is invoked by inference engine which executes the search inference process. Inference engine is invoked by interaction flow engine which drives the entire reasoning process. Rule base communicates with distributed information service through an architected contract. The rule base may be stored in a persistent storage and may be read and modified using distributed information service . Furthermore rule base uses the interfaces of ontology . The meaning of the terms that are used in the rule base may be defined via the ontology. This knowledge may be used in interpreting the rules during the inference process.

Constraint model manages multiple models that define constraints for search problems. Constraint model contains the preference manager not shown . As described above a set of constraints e.g. a constraint base is compiled into an efficient form for execution by constraint satisfaction engine see . Constraint model is invoked by constraint satisfaction engine which executes the search process. Constraint satisfaction engine is invoked by interaction flow engine which drives the entire reasoning process. A typical interaction flow involves a search for an object in external storage systems. The search criteria may be formulated during the reasoning process. Often an inference process will produce search criteria. To ensure consistency throughout the reasoning process constraints can be formulated and stored in a constraint model. Constraints also can be preferences in which case an implicit ordering over the search results can be expressed.

Constraints are an important factor for the outcome of recommendations. In particular constraints are used to prevent business policies from being violated when recommendations are given. Constraints also can be used to prevent the recommendation of products e.g. goods services and information that have been rejected during a previous interaction. Constraint model communicates with distributed information service through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information system . Furthermore constraint model uses the interfaces of ontology . The meaning of the terms that are used in a constraint model may be defined via the ontology. This knowledge may be used in interpreting the model.

Optimization model manages multiple models that define metrics for optimization problems. Suitable metrics include formulas and simple properties of concepts. As described above an optimization model is compiled into an efficient form for execution by optimization engine see . Optimization model communicates with distributed information service through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information system . Furthermore optimization model uses the interfaces of ontology . The meaning of the terms that are used in an optimization model may be defined via the ontology. This knowledge may be used in interpreting the model.

Predictive model manages multiple models that define formulas or values found by data mining engine see . A predictive model describes a functional dependency between one or more properties of one or more instances and a property that is not externally stored. Predictive model communicates with distributed information service through an architected contract. The model may be stored in a persistent storage and may be read and modified using distributed information system . Furthermore predictive model uses the interfaces of ontology . The meaning of the terms that are used in a predictive model may be defined via the ontology. This knowledge may be used in interpreting the model.

To illustrate how the components shown in may interact an exemplary situation in which reasoning engine and knowledge manager interact with one another to generate a recommendation in response to events will now be described. In response to an event or set of events received from the real world interaction flow engine initially triggers categorization engine to determine a set of categories for the events that have occurred. In one embodiment a preceding situation that has been dealt with also is considered an event. Based on the categorized events a situation action is selected by searching interaction flow model . In one embodiment the selected situation action obtained from interaction flow model is in the form of a task list. Thus the task list which may include one or more tasks is read by interaction flow engine

In this example the task list includes instructions to interact with each of optimization engine inference engine and constraint satisfaction engine . It should be appreciated however that there are many scenarios in which only one of optimization engine inference engine and constraint satisfaction engine is needed to execute the instructions from the task list. In other instances interaction flow engine can communicate with one or more external applications or external models to execute the instructions from the task list. Returning now to the description of the example the task list may require that inference engine execute an inference for the situation provided by interaction flow engine . Accordingly inference engine will execute an inference using rule base model . Thus the inference engine provides the functionality that is required to perform logical inference. As described herein logical inference is the process of deriving conclusions that are entailed in a set of rules and a set of facts known to be true. A rule is a pair of premise or antecedent and conclusion or consequent. The set of rules may be compiled into an efficient form by rule base model for execution by inference engine

Inference engine passes the result which is in the form of a number of constraints to interaction flow engine which then executes the next task in the task list. In this example the next task in the task list requires that constraint satisfaction be performed. Accordingly interaction flow engine will pass the number of constraints to constraint satisfaction engine which also receives compiled constraint model data from constraint model . Constraint satisfaction engine will then perform a search i.e. execute to identify a set of objects or solutions e.g. a set of products or services to be recommended . The set of objects or solutions may then be communicated back to interaction flow engine . In other instances only one object or solution may be provided. If further refinement within a set of objects or solutions is set forth in the task list then interaction flow engine passes the objects or solutions to optimization engine

In this case optimization engine will also obtain compiled information from optimization model to execute an optimization model e.g. an optimization algorithm. The optimal solution may be recorded as an event and communicated back to interaction flow engine . In other words optimization engine functions to determine a solution that is optimal with respect to the optimization model. In one embodiment this requires that a metric exist. Finding a solution e.g a set of products to recommend by optimization leads to more accurate results than simple constraint bound searching. At this point interaction flow engine may communicate the result to the appropriate receiving module or interface such as distributed information service DIS . By way of example the receiving module may be a message system the user a display a database or any other type of data receiving data storing or data processing object. Those skilled in the art will recognize that the number and type of engines contained in reasoning engine may be varied from that shown in . Furthermore because the process flow is model driven interaction flow engine can interact with other business models applications or objects.

Mapping service provides the functionality that is required to implement aggregated objects whose attributes and relationships come from multiple physical data sources. Mapping service uses the interfaces of naming service storage system schema manager a schema may be stored in an external storage system and data model . Storage System defines the abstractions that all resource adapters etc. must implement to plug into information system as a data and event resource. Generally abstractions unify different storage systems along various dimensions. More specifically the storage system defines unification for connection management transaction management security management interaction management schema management event management and data structure representation.

Connection management specifies how connections to external enterprise information systems are created and pooled. Interaction management specifies how operations statements that retrieve create update and delete data in the specific storage systems are expressed and invoked. Schema management specifies how the schema information that is employed by a storage system is retrieved and manipulated. Data structure representation specifies how data structures which have been returned from a retrieval operation are examined and how they are provided for creation and update operations. Transaction management specifies how an application server uses a transaction manager to manage transactions across multiple resource managers. This contract also supports transactions that are managed internal to an EIS resource manager without the necessity of involving an external transaction manager. Security management enables secure access to an information resource e.g. an RDBMS a messaging system or a packaged application. Additional details of storage system are set forth below with reference to .

Schema manager provides the functionality that is required to create read update and delete schemas. The main purpose of the schema manager is to create application schemas. These schemas are used to communicate the guaranteed structure of information items to other modules and applications which can programmatically explore display and map the structure. Schema manager uses the interfaces of naming service storage system and data model . Query service provides the functionality that is required to execute queries that involve multiple physical data sources and schemas. Distributed information service provides a uniform view on aggregated data coming from multiple heterogeneous data sources and therefore it is desirable to query that view as if it were a single data source. The query language should be compliant with URI notation. As described above distribution information service makes an information resource available under a URI. To find that information resource an extended URI syntax e.g. XPath which allows selection of specific items along a path may be used. Query service uses the interfaces of naming service schema manager and data model

Data model provides a way to communicate the structure of a data item to its users e.g. other modules services and applications. Thus the data model is a foundation that is used by many other modules. Data model also makes the values of the data structure accessible via a single API. In one embodiment the data model uses an interface approach to access the data structures. Interfaces are desirable because they carry only minimal runtime overhead and do not add unnecessary development effort provided they are small and concise.

Data model provides an abstraction for all data structures that are stored in external storage systems. The data model lends itself to the abstract data model that is behind XML documents. The basic entity is an item. Items can have attributes which have an atomic data type no visible internal structure . Items also can have relationships with other items. These relationships may be represented as parent child relationships. This means that each item has at most one parent. Using this relationship aggregation can be expressed. General associations may be modeled using reference attributes. A reference attribute is similar to a Java object reference. Items have names that indicate the type of an item. However data items do not have to be strictly typed. Although an item may be an instance of a class it nevertheless can have additional attributes and relationships. If the class defines essential attributes and relationships then the item must have such attributes and relationships.

The method proceeds to operation in which data that meets the criteria of the rules being processed for the profile is found and retrieved. As described above the rules are expressed in terms of generalized concepts which may have different meanings in different contexts. The data that is found and retrieved in operation includes the specific instances of the generalized concepts that apply to the context of the user. Next in operation found data that conflicts with the user s preferences is removed. The method then proceeds to operation in which the remaining found data is optimized in order of preference against the context of the user. This optimization operation may be implemented using an appropriate optimization algorithm. In one exemplary embodiment of the invention in which investment recommendations are generated the Markowitz optimization algorithm may be used. The optimization algorithm generates a set of products or services that optimizes the remaining found data relative to a goal test which may be defined by the user.

Once the optimized data has been generated the method proceeds to operation in which the optimized data e.g. a product recommendation is displayed to the user. If desired the optimized data may be displayed to the user together with the reason for the selection and the ranking. Operations collectively comprise a product recommendation PR situation. Once the product recommendation or other optimized data is displayed in operation the product recommendation situation has reached its terminated state and the method waits for an event to occur before any further action is taken. If the user fails to respond within a predetermined period of time then an exit event is deemed to occur and this exit event is recorded. If the user responds then a response event is deemed to occur and the method proceeds to operations which collectively comprise a response situation.

In operation the feedback from the response is added to the user s profile. Next in decision operation it is determined whether the product recommendation is selected. If the recommendation is selected then the method proceeds to operation in which the response situation has reached its terminated state and the method transits to a purchase flow situation. On the other hand if the product recommendation is not selected then the method proceeds to operation in which a constraint is added to the user s profile. This constraint is added to the user s profile to avoid providing the user with the same recommendation that was just rejected. Once the constraint is added to the user s profile the method may cycle back up and wait for another product recommendation situation to arise.

In addition to the product recommendation situation and the response situation described above another situation which is labeled as situation X in may occur. In particular situation X may occur when external events indicate that the product recommendation made to the user is no longer valid. By way of example in the case of a recommendation that a user purchase stock in Company A news that Company A will experience a significant earnings shortfall may render the recommendation no good and thereby give rise to situation X. It will be apparent to those skilled in the art that numerous other events also may give rise to situation X.

As shown in universal node is coupled to classification node by arrow . Classification node which indicates concept A is coupled to classification node which indicates concept B by arrow and to classification node which indicates concept C by arrow . Classification nodes and are each coupled to classification node which indicates concept D by arrows and respectively. Universal node is coupled to nodes and by arrows and respectively and to nodes and by arrows and respectively. Nodes and indicate concepts X X X and X respectively. Nodes and indicate concepts Y Y Y and Y respectively.

In this exemplary scenario in the event Rule No. 1 fires the specific instances of concept X which are the items in list L will be returned. In the event Rule No. 2 fires the specific instances of concept X which are the items in list L will be returned. In the event Rule No. 3 fires the specific instances of concept X which are the items in list L will be returned. In the event Rule No. 4 fires the specific instances of concept X which are the items in list L will be returned.

The intermediate first class objects disposed between two nodes e.g. nodes and maintain the relationship between the two nodes. In the absence of such intermediate objects the information regarding the relationship between the nodes would have to be stored in one of the nodes themselves. This is undesirable however because it presents complex memory management and programming issues as the system grows and the amount of relationship information stored in the nodes increases. The use of intermediate objects is a powerful solution for at least two reasons. First the use of intermediate objects avoids the need to store relationship information in the nodes. As a result the information stored in the nodes may be limited to strings which the ontology treats as terms. Second the use of intermediate objects increases the flexibility of the system by enabling additional relationships e.g. time and precedence to be defined in the contextual arcs which the ontology uses to define the relationships between the terms stored in the nodes.

As shown in nodes and which indicate concepts X and Y respectively are overloaded for concepts B C and D using the contextual arcs. This enables the business to implement the same selling policy defined in Rule Nos. 1 4 above with only the following business rule 

When this rule fires the specific instances of concept X that will be returned depend on the particular context. In the context of concept A the items in list L will be returned see arrow in . In the context of concept B the items in list L will be returned see contextual arc in . In the context of concept C the items in list L will be returned see contextual arc in . In the context of concept D the items in list L will be returned see contextual arc in .

Although the ontology may implement either of the above described methods the method described with reference to i.e. the method in which contextual arcs are used provides significant advantages in terms of both maintenance and also performance. As demonstrated above the use of contextual arcs minimizes the number of business rules required to implement a given business policy. By minimizing the number of business rules required a significant maintenance advantage is obtained because it is easier to manage fewer business rules as illustrated below. The use of contextual arcs also provides a significant performance advantage.

To demonstrate the maintenance advantage that results from the use of contextual arcs consider the steps a business manager would have to take to change the recommended product from X to Y in the exemplary scenario described above. Using the method described with reference to i.e. the method without contextual arcs the business manager would have to remove all of the business rules that recommend X X X and X and add the following business rules to the ontology 

In contrast using contextual arcs the business manager would only have to remove the business rule that recommends X and add the following business rule to the ontology 

The use of contextual arcs also makes it easier to change the recommended products or services. For example in the exemplary scenario described above consider the steps a business manager would have to take to change the list of recommended stocks L. Without contextual arcs the business manager would have to change the expression for the concept X. With contextual arcs the business manager would only have to change the expression for contextual arc which extends from node which indicates concept B to node which indicates concept X see .

In summary the present invention provides an information system that captures data from disparate sources and provides intelligent personalized recommendations. The invention has been described herein in terms of several preferred embodiments. Other embodiments of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention. The embodiments and preferred features described above should be considered exemplary with the invention being defined by the appended claims.

