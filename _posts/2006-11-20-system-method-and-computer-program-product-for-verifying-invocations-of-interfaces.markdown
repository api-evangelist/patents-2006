---

title: System, method and computer program product for verifying invocations of interfaces
abstract: A verification system, method and computer program product are provided. In one embodiment, one of a plurality of call instruction formats is selected. In addition, it is verified whether an invocation of an interface was attempted by code utilizing the selected call instruction format. Further, the selection and the verification are repeated for each of the plurality of call instruction formats. In another embodiment, a return target address is identified. Still yet, it is determined whether return of contra to the return target address would result in invocation a one of a plurality of interfaces.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07987451&OS=07987451&RS=07987451
owner: McAfee, Inc.
number: 07987451
owner_city: Santa Clara
owner_country: US
publication_date: 20061120
---
The present invention relates to interfaces and more particularly to monitoring interfaces for a variety of purposes.

Interfaces such as application program interfaces API s are generally monitored for various reasons. For example interfaces may be monitored for security purposes for understanding a flow of applications for tracking problems associated with applications etc. Traditionally security related monitoring has involved examining return addresses passed to an interface by a caller that invokes the interface for verifying that the call to the interface is valid e.g. non malicious etc. . However various techniques are available to callers which allow them to hide the actual return addresses or otherwise obfuscate their identify thus allowing such callers to escape detection.

A verification system method and computer program product are provided. In one embodiment one of a plurality of call instruction formats is selected. In addition it is verified whether an invocation of an interface was attempted by code utilizing the selected call instruction format. Further the selection and the verification are repeated for each of the plurality of call instruction formats. In another embodiment a return target address is identified. Still yet it is determined whether return of control to the return target address would result in invocation of one of a plurality of interfaces.

Coupled to the networks are servers which are capable of communicating over the networks . Also coupled to the networks and the servers is a plurality of clients . Such servers and or clients may each include a desktop computer lap top computer hand held computer mobile phone personal digital assistant PDA peripheral e.g. printer etc. any component of a computer device and or any other type of logic for that mater. In order to facilitate communication among the networks at least one gateway is optionally coupled therebetween.

The workstation shown in includes a Random Access Memory RAM Read Only Memory ROM an I O adapter for connecting peripheral devices such as disk storage units to the bus a user interface adapter for connecting a keyboard a mouse a speaker a microphone and or other user interface devices such as a touch screen not shown to the bus communication adapter for connecting the workstation to a communication network e.g. a data processing network and a display adapter for connecting the bus to a display device .

The workstation may have resident thereon any desired operating system. It will be appreciated that an embodiment may also be implemented on platforms and operating systems other than those mentioned. One embodiment may be written using JAVA. C and or C language or other programming languages along with an object oriented programming methodology. Object oriented programming OOP has become increasingly used to develop complex applications.

Of course the various embodiments set forth herein may be implemented utilizing hardware software or any desired combination thereof. For that matter any type of logic may be utilized which is capable of implementing the various functionality set forth herein.

As shown in operation one of a plurality of call instruction formats is selected. In one embodiment the call instruction formats may each include a template. In this way each template may define a different format of call instructions. Just by way of example each template may define a length of a call instruction. Of course in the context of the present description a call instruction format may refer to any format associated with a call instruction capable of invoking or leading to the invoking of an interface.

In various embodiments the call instruction formats may be identified by analyzing call instruction formats supported by a CPU of an associated computer that attempts to invoke an interface in a manner that will be set forth later . Such analysis may for example include determining call instruction formats described in a published document provided by a manufacturer of the CPU and storing the same in a database. To this end the analysis may first include identifying the CPU such that the corresponding call instruction formats may be looked up in the database. In different embodiments the aforementioned computer may include any of the servers and or clients described above with respect to and or but of course may include any computer capable of being associated with a CPU or some other processor s .

Still yet one of the plurality of call instruction formats may be selected based on an ordering of the call instruction formats. Thus in one optional embodiment the call instruction formats may be stored in a list of call instruction formats. Accordingly a first call instruction format in the list may be selected after which a second one may be selected and so forth. Of course it should be noted that one of the call instruction formats may be selected in any desired manner.

Additionally it is verified whether an invocation of an interface was attempted by code utilizing the selected call instruction format as Shown in operation . In one embodiment the interface may include any computer code data structure or protocol that facilitates communication between a first instance of hardware or software with another instance of hardware or software. In one optional embodiment such hardware or software may be a component of any of the servers and or clients described above with respect to .

In another embodiment the interface may include a software interface. For example the interface may include an application programming interface API for facilitating communication between an application and an underlying operating system. Further such invocation of the interface may include a call to the interface such as code e.g. instruction etc. that transfers control to the interface. In another embodiment the call to the interface may be made by an application.

In use the verification of operation may be repeated for each of the call instruction formats. To this end if it can not be verified that the invocation of the interface was attempted utilizing at least one of the call instruction formats it can be concluded that there is at least a potential that the code that attempted the invocation may be obfuscating its identify which is typically done for malicious purposes . Thus an appropriate reaction may be initiated.

It should be noted that the foregoing verification may be carried out in any desired manner that utilizes the known call instructions formats. During reference to more illustrative information will be set forth regarding various optional features of a different embodiment with which the foregoing method may or may not be implemented per the desires of the user. It should be strongly noted such information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

As shown in operation a return target address is identified. In the context of the present description the return target address may include any identifier that identifies a location in code to which control is transferred upon execution of an associated return operation.

In one optional embodiment the return target address may be associated with a call to an interface. For example the call to the interface may specify the return target address. Thus the return target address may identify a location in code to which control is to transfer once invocation of the interface and execution of any other code associated therewith is completed.

Additionally it should be noted that the return target address may be identified in any desired manner. Just by way of example in one possible embodiment the return target address may be identified from a call stack. Such call stack may include a stack of calls where return target addresses are respectively pushed on the stack in association with each of such calls.

Further it is determined whether return of control to the return target address would result in invocation of one of a plurality of interfaces as shown in operation . For example it may be determined whether return of control to code identified by the return target address would result in invocation of one of a plurality of interfaces.

The plurality of interfaces may include for example any predetermined set of interfaces. In one embodiment the interfaces may include monitored interfaces e.g. interfaces whose invocation is monitored etc. . If it is determined that code which attempted to invoke the interface is attempting to as a result of a return of control invoke another interface it can be concluded that there is at least a potential that the code that attempted the invocation may be obfuscating its identify which is typically done for malicious purposes . Thus an appropriate reaction may be initiated.

It should be noted that the foregoing determination may be carried out in any desired manner. During reference to more illustrative information will be set forth regarding various optional features of a different embodiment with which the foregoing method may or may not be implemented per the desires of the user. It should be strongly noted such information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

As shown in operation a call interface instruction is executed. The call interface instruction may include any call made to an interface. For example the call interface instruction may include an instruction to invoke the interface. Moreover the call interface instruction may be executed by a caller. Optionally such caller may execute the call interface instruction utilizing any desired type of computer code e.g. automatically via an application via manual execution etc. .

In addition invocation of the interface is intercepted as shown in operation . Thus invocation of the interface by the execution of the call interface instruction may be intercepted. In one embodiment invocation of the interface may be intercepted by an application utilized for monitoring the interface e.g. a security application etc. .

In another embodiment the invocation of the interface may be intercepted by hooking the invocation of the interface. Of course however the invocation to the interface may be intercepted in any desired manner. In this way execution of the invocation of the interface may be prevented so that additional verification processing may be initiated.

Further code pointed to by a return address of the call interface instruction is retrieved as shown in operation . Optionally the code may be retrieved by identifying the return address. For example the return address may be identified from a call stack on which the return address was pushed in association with the call interface instruction that attempted the invocation of the interface.

The return address may then be utilized for locating and retrieving the code pointed to by the return address. Such code may include for example operations instructions etc. Thus the code may include any code to which control is transferred once the call interface instruction and any code associated therewith is executed. Optionally the code may also be stored.

Still yet a template of a first call instruction format is received as in operation . The first call instruction format may include one of a plurality of call instruction formats. In this way the template may define one type of format of call instructions. In one embodiment the first call instruction format may include a length of a call instruction. Of course in other embodiments the first call instruction format may be any format of a call instruction supported by a CPU of an associated computer e.g. a computer via which the call interface instruction is executed etc. .

Additionally code preceding the return address of the call interface instruction is examined using the template and a candidate target address is retrieved. Note operation . For example such code may immediately precede code pointed to by the return address. In this way a code context of the call interface instruction may be examined. In one exemplary embodiment the template may be utilized to identify a length of code preceding the return address to be examined. Of course however the template may be utilized in any desired manner for examining the appropriate code. For example in some embodiments the template being tested may retrieve its candidate target address from memory if in memory such candidate target address may be retrieved from a portion of memory referenced by the call instruction format being tested.

Furthermore the candidate target address may be retrieved from the examined code. Such candidate target address may include any portion of the code that is potentially a target address associated with the call interface instruction. For example such target address may identify an interface to be invoked by the associated call interface instruction.

In one embodiment the candidate target address may be retrieved from the code based on a location in the code that is determined in accordance with the call instruction format of the template. Optionally the template may be utilized for identifying where an instruction preceding the return address begins. Moreover such instruction may be potentially inclusive of the target address. In this way the candidate target address may be identified in the code based on the return address and the template.

Once the candidate target address is retrieved it is determined whether an interface address and the candidate target address match as shown in decision . The interface address may include any address associated with the interface for which the invocation was intercepted see operation . Accordingly it may be determined whether the target address of the call interface instruction is associated with such interface.

If it is determined that the interface address and the candidate target address match it is determined that the invocation of the interface used the currently selected call instruction format and was therefore valid. See operation . Optionally the interface may then be allowed to continue e.g. be invoked etc. . In this way a call interface instruction utilized for invoking an interface may be validated.

If however it is determined that the interface address and the candidate target address do not match the candidate target address may be checked for a jump JMP instruction. Note operation . If it is determined that a JMP instruction exists it is then determined whether the JMP target address associated with the JMP instruction and the interface address match as shown in decision . Of course if no JMP instruction exists decision may simply be skipped. The JMP target address may include any portion of code pointed to by the candidate target address. If it is determined that the JMP target address and the interface address match it is determined that the invocation of the interface was valid as shown in operation .

By this design the present method accommodates a situation where a lack of a match in decision does not necessarily mean that the current call instruction template was not used. Further while a JMP instruction is set forth in the current description it should be noted that the candidate target address may be checked for any type instruction that transfers control where such instruction does not affect the call stack associated with the call interface instruction executed by operation .

Similar to that described above with respect to the template of the first call instruction format JMP instructions may also take a plurality of different formats. In this way a template may be provided for each different JMP instruction format. Therefore as an option the candidate target address may be checked for a JMP instruction based on a template of a first JMP instruction format and if no match is found between the JMP target address and the interface address then a template of a next JMP instruction format may be utilized and so forth. To this end while not shown operations and may be iterative in nature. In some embodiments the template being tested may retrieve its JMP target address from memory. If in memory such JMP target address may be retrieved from a portion of memory referenced by the JMP instruction format being tested.

Thus situations may be accommodated where the target address is not presented directly in code associated with the call interface instruction. As an option in one optional embodiment contents of registers e.g. CPU registers etc. available at the time of the attempt to invoke the interface by the execution of the call interface instruction may be preserved e.g. stored etc. immediately upon interception of the invocation of the interface see operation . In this way the contents of the register may be available for identifying the JMP target address and therefore for determining whether the JMP target address and the interface address match see decision . It should be noted that this technique may be used for the aforementioned call instruction format testing as well.

In another exemplary embodiment secondary JMP instructions may be utilized to invoke an interface with respect to import libraries. For example Windows LdrLoadDll may be monitored in ntdll.dll but the LdrLoadDll export of Kernel32.dll may not be monitored. When the Kernel32.dll export is invoked such export performs a JMP instruction to the ntdll export of LdrLoadDll. Thus the return address may point to a call instruction that invokes the Kernel32 export but not the ntdll export. Accordingly the JMP target address may be identified and compared with the interface address to determine if there is a match see decision .

With continuing reference to if it is determined that the JMP target address and the interface address do not match it is determined whether another call instruction format is available to test. Note operation . If another call instruction format is available a template for a next call instruction format is received as shown in operation . Code preceding the return address is then examined using the received template and a candidate target address is retrieved see operation . In this way code preceding the return address of the call interface instruction may be examined based on each available call instruction format.

If all call instruction formats have been checked and none have resulted in a determination that the invocation of the interface is valid see operation a violation event is created and an exception is applied as needed to control strictness of enforcement as shown in operation . In one embodiment the violation event may include transmitting an alert to a user. Such alert may include an alert that malicious code is potentially executing on the computer on which the call interface instruction was executed.

In addition the user may be provided with options for responding to the intercepted invocation of the interface. Such options may include allowing the interface to be invoked by the call interface instruction logging information associated with the intercepted invocation of the interface blocking usage of the interface e.g. by a particular application by all applications etc. terminating a process thread utilized in attempting to invoke the interface shutting down a computer on which the call interface instruction was executed causing an exception to be performed etc. Further the user may also be allowed to create an exception such that future attempts to invoke the interface by the call interface instruction are automatically determined to be valid and are therefore allowed. Of course however the violation event may also include automatically performing an action without input from a user including for example any of those actions described above.

Thus malicious code that is utilized to indirectly invoke an interface may be identified. For example malicious code that invokes an interface via a JMP instruction e.g. via a push of a return address a push of a return address that points to a return instruction in a legitimate area of code and a JMP instruction may be identified in this way an intrusion prevention system may be provided which prevents hackers from bypassing detection by hiding behind a return address that points to a legitimate area of code.

As shown in operation a call interface instruction is executed. In addition invocation of an interface by the call interface instruction is intercepted as shown in operation . Further a return target address of the invocation of the interface along with code pointed to by the return target address are retrieved as shown in operation . For example such return target address may be retrieved from a call stack on which the return target address was pushed.

Any sledding instructions present in the code are skipped for yielding the revised return target address located in the code as shown in operation . The sledding instructions may include any series of instructions that do not necessarily cause a change in operation or whose change is considered to be of or little consequence. For example the sledding instructions may include no operation NOP instructions that serve as placeholders such that the execution of such NOP instructions does not necessarily effect a change. In this way the revised return target address may be identified regardless of whether the return target address points to a start of an instruction sled.

Still yet an address of a first interface on a watch list is received as shown in operation . The watch list may include any list of interfaces for which invocations are monitored. For example the watch list ma include a list of interfaces for which returns from call interface instructions are to be monitored.

As shown in decision it is determined whether the interface address and the revised return target address match. Such a match may potentially indicate a situation where a caller is attempting to discuss itself as one of the monitored interfaces. Thus if the interface address and the revised return target address match a violation event is created as shown in operation . Such violation event may optionally include the violation events described above with respect to operation of but of course may include any action capable of being taken in response to the intercepted invocation of the interface.

If however it is determined that the interface address and the revised return target address do not match the method may continue. While not shown it may be optionally determined whether the revised return target address is associated with a JMP instruction that points to a return target address that matches the interface address as described above in with respect to operation . Thus the return target address may be identified if the attempt to invoke the interface was indirect.

With continuing reference to if it is determined that the interface address and the revised return target address do not match it may be determined whether there are more interfaces on the watch list to check as shown in decision . If there are more interfaces on the watch list to check an address of a next interface on the watch list is received see operation such that it may be determined whether the address of the next interface matches the revised return target address see decision . Thus it may be determined whether a return target address associated with a call interface instruction utilized for invoking an interface returns control to another interface on a watch list.

If it is determined that the revised return target address does not match any of the interface addresses associated with interfaces on the watch list it is determined that the invocation of the interface is valid as shown in operation . Thus the invocation of the interface may be allowed to continue. In various embodiments additional analysis may be performed on the attempted invocation of the interface such as for example the analysis described above with respect to for preventing false positive violation events associated with legitimate code.

In this way an identification of an actual source that executed the call interface instruction may be verified and an invocation of the interface validated. Of course the methods and of respectively may also be performed independently for providing streamlined validation of invocations to interfaces. Moreover in one optional embodiment the methods and of respectively may be utilized by an intrusion prevention system IPS which monitors usage of interfaces. Such monitoring may be carried out for the purpose of detecting for example buffer overflow situations where a source thereof is hidden etc.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

