---

title: Storage and support for large amounts of constant data in a graphics library
abstract: One embodiment of the invention is a method of accessing a bindable uniform variable bound to a buffer object that includes the steps of creating a linked program object comprising one or more shader programs, where each shader program includes instructions written in a high-level shader language, and where the linked program object includes a reference to a bindable uniform variable and indicates which shader programs use the bindable uniform variable. The method also includes determining a memory size to support the bindable uniform variable, allocating a buffer object having the memory size, binding the buffer object to the bindable uniform variable, populating the buffer object with values for the bindable uniform variable, and accessing the values of the bindable uniform with one or more of the shader programs in the linked program object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07852345&OS=07852345&RS=07852345
owner: NVIDIA Corporation
number: 07852345
owner_city: Santa Clara
owner_country: US
publication_date: 20061212
---
This application claims priority to the U.S. Provisional Application titled API Extensions for Advanced Graphics Processing Units filed on Jul. 28 2006 and having U.S. patent application No. 60 833 978.

Embodiments of the present invention generally relate to computer programming techniques for graphics processing systems. More specifically embodiments of the invention relate to parameter buffer objects used to store shader program parameters.

Over the past decade the cost of adding on chip logic to processors has substantially decreased. Consequently certain types of processors such as advanced graphics processing units GPUs now include functionality not previously available in earlier GPU designs. For example a GPU may include multiple texture image units used to store references to texture maps used in graphics rendering operations. One benefit of this new capability is that more efficient texture mapping operations and the like may now be performed on the GPU thereby increasing overall performance in the graphics pipeline.

To fully realize the additional processing capabilities of advanced GPUs as much GPU functionality as possible needs to be exposed to graphics application developers. Among other things doing so enables graphics application developers to tailor their shader programs to optimize the way GPUs process graphics scenes and images. Exposing new GPU processing capabilities to graphics application developers requires that the application programming interface API be configured with new calls and libraries that make new features and functionalities directly accessible by developers.

Programmable shader programs executing on a GPU repeatedly perform operations accessing attributes of individual inputs vertices or fragments and may also access a set of values that are constant over a set of inputs. Such constants are often referred to as uniforms or program parameters. For example a vertex shader may perform lighting calculations where the position direction and intensity of each light source are stored as uniforms and read by the vertex shader. The use of uniforms in a programmable shader allow an application to access a relatively large amount of data describing a given scene without transmitting all the data for each vertex or fragment processed.

When rendering an image an application may use a variety of shader programs each performing a different operation. Although each shader program may be configured to perform a specific function two or more shader programs may rely upon the same constant data. For example two or more shader programs may perform lighting operations that use the same data e.g. lighting information . However current graphics APIs provide very limited ability to share uniforms among multiple shader programs and may even require that the same uniform data be duplicated for each shader program. Additionally a single shader program may operate using different sets of uniforms. For example different portions of a scene may be illuminated by different lights. Using current APIs combining all uniforms used over the scene into one large collection may run into implementation dependent limits on the amount of uniform storage. Dynamic updates to a small set of uniform values can reduce uniform storage requirements but can incur substantial CPU and GPU overhead. Additionally updates may require a pause in the highly pipelined GPU to wait for threads using the old values of the uniforms to complete before the update can be performed.

Since the computational power of the GPU relative to the CPU has increased dramatically over the years applications have progressively moved more computation onto the GPU. For example applications may perform physics simulations e.g. computing the position of a set of particles on the GPU by executing a shader program on one or more of the processing units of the GPU. The results of those simulations may be used in a variety of ways including as uniform values for subsequent computations. To perform the next sequential processing pass however it is often necessary to transmit the results back to the CPU and through the API so that the data can be sent to the appropriate processing unit of the GPU. This process of moving uniform datasets between the CPU and the GPU can result in a substantial performance penalty.

As the foregoing illustrates what is needed in the art is a mechanism that provides greater efficiency and flexibility for using bindable uniforms and parameter buffer objects relative to current techniques.

One embodiment of the present invention sets forth a method for updating data in a buffer object during the execution of a shader program. The method includes the steps of creating a linked program object comprising one or more shader programs where each shader program includes instructions written in a high level shader language and where the linked program object includes a reference to a bindable uniform variable and indicates which shader programs use the bindable uniform variable. The method also includes the steps of determining a memory size to support the bindable uniform variable allocating a buffer object having the memory size binding the buffer object to the bindable uniform variable populating the buffer object with values for the bindable uniform variable and accessing the values of the bindable uniform with one or more of the shader programs in the linked program object.

One advantage of the disclosed method is that using buffer objects as parameter buffer objects enables a number of graphics rendering operations to be performed without requiring intervention by a CPU thereby increasing the performance of the graphics rendering hardware. Additionally a graphics API may be used to update data values stored in a buffer object during rendering operations without having to wait until all active shader programs using one version of data in the buffer object have completely executed before the data values stored in the buffer object may be updated further increasing GPU performance.

Embodiments of the invention allow developers of graphics applications to efficiently and effectively use buffer objects in the local memory of a GPU as the storage space for a bindable uniform variable declared in a shader program or as a parameter buffer object storing one or more parameters used by a shader program. Buffer objects provide a region of memory i.e. buffers accessible through an identifier. Buffer objects allow a GPU driver to optimize an internal memory management scheme and choose the best type of memory such as cached uncached system memory or graphics memory in which to store a buffer object.

Generally parameter buffer objects may be used by an assembly level shader program and bindable uniforms may be used by shader programs developed in high level shader languages such as the OpenGL Shading Language GLSL or the Cg shading language. In either case the use of buffer objects as parameter buffer objects or as the storage space for a bindable uniform allows a number of graphics rendering operations to be performed without requiring intervention by a CPU thereby increasing the performance of the graphics rendering hardware.

In one embodiment a uniform variable in a shader program may be declared as being bindable. As used herein a bindable uniform or bindable uniform variable is a uniform variable declared in a shader program where storage for the uniform is not allocated by a compiler linker but instead comes from a buffer object specified by the shader program. Bindable uniforms are a programming construct provided by a high level shader program such as one composed using the GLSL or Cg shader programming languages. An API call may be used to bind the bindable uniform variable to a particular buffer object. By binding different buffer objects to a bindable uniform an application may easily switch between different uniform data sets without having to re specify the data every time having to pass the data from the CPU to a GPU driver as part of the switch. Further the same buffer object can be bound to bindable uniforms used by different shader programs. For example if two shader programs each declare a bindable uniform of the same data type then accessing a bindable uniform in program object A results in the same data if the same access is made in program object B. Thus bindable uniforms advantageously allow data sets that may be shared among multiple program objects and shader programs without storing multiple copies of the data set or requiring multiple updates if the data set is changed.

In one embodiment a parameter buffer object provides a type of program parameter than can be used as a constant during the execution of vertex fragment or geometry shader programs. A graphics hardware device may include a set of parameter buffer binding points to which buffer objects can be attached. This allows a vertex fragment or geometry program to read data from an attached buffer objects using a binding like the form program.buffer a b . This binding reads data from the buffer object attached to binding point . The attached buffer object is treated as an array of 32 bit words or four component vectors consisting of 32 bit words and the binding reads the word or vector numbered . The use of buffer objects to store shader program parameters allows applications to change large blocks of shader program parameters at once simply by binding a new buffer object to a given binding point. A parameter buffer object is a programming construct for shader programs composed in using an assembly level programming language such as an assembly harder language or microcode.

Parameter values i.e. the data values in a parameter buffer object may be loaded into the buffer object using a variety of mechanisms provided by a graphics API including for example reading back from the frame buffer transmitting the values through a transform feedback path or implementing buffer object loading functions used to map data supplied by a graphics application into the buffer object. A transform feedback path may provide and use feedback and record transformed vertices processed by units within a graphics rendering pipeline. Examples of transform feedback are described in the commonly owned U.S. patent application titled Feedback and Record of Transformed Vertices in a Graphics Library filed on Dec. 12 2006 having U.S. patent application Ser. No. 11 609 763.

The graphics API may include calls specifically provided to load and or update data in a parameter buffer object. Thus parameter buffer objects may provide a great deal of flexibility not available from other assembly language parameter mechanisms. Additionally in one embodiment a graphics API may be used to update data values stored in a buffer object during rendering operations without having to wait until all active shader programs using one version of data in the buffer object to complete executing before the data values stored in the buffer object may be updated thereby increasing GPU utilization.

GPU includes at least one rendering engine that incorporates at least one graphics rendering pipeline . System memory includes an application program a GPU driver and an application program interface API . Generally GPU driver implements the functions and data structures exposed by API for a given GPU . The application program generates calls to the API in order to produce a desired set of results typically in the form of a sequence of graphics images.

In one programming model the application program transmits one or more high level shader programs to the API for processing within GPU driver by complier linker . The high level shader programs are typically source code text of high level shader language instructions that are designed to operate on one or more processing units within the GPU . In turn the compiler linker may be configured to compile and link the source code of high level shader programs . In one embodiment compiler linker is configured to provide cross domain linking capabilities. More specifically compiler linker may be configured to translate high level shader programs designated for different domains into distinct compiled software objects. Compiler linker also links the compiled code to generate a single compiled linked program object.

The compiled linked program object generated by compiler linker may be in the form of assembly code which would be directed to a GPU microcode assembler which may generate three software objects of domain specific microcode for GPU to execute. Alternately compiler linker may generate GPU microcode directly. The vertex shader microcode is derived from a vertex shader program the geometry shader microcode is derived from a geometry shader program and the fragment shader microcode is derived from a fragment shader program. Additional examples of cross domain compiling and linking of shader programs are described in the commonly owned U.S. patent application titled Methods and Systems for Processing a Geometry Shader Program Developed in a High Level Shading Language filed on Nov. 30 2006 having U.S. application Ser. No. 11 565 566.

In another programming model the application may transmit assembly level shader programs for execution on GPU . In addition to the high level shader language discussed above OpenGL also provides an interface for developing shader programs using an assembly level interface to graphics hardware device . The source code text of an assembly level shader language program may include assembly level commands used to control the operations of the processing units within the graphics rendering pipeline . Further GPU microcode assembler may be configured to generate software objects of domain specific microcode from the assembly level commands for execution on the vertex geometry and fragment processing units as the case may be of graphics rendering pipeline . In such a scenario the application may bypass the compiler linker and provide the assembly level shader language programs directly to microcode assembler . Alternatively the GPU driver may not include the compiler linker .

Local memory stores among other things a frame buffer a parameter buffer object a bindable uniform buffer object and a memory page pool . Data output from the graphics rendering pipeline may be stored in frame buffer . When graphics rendering pipeline completes rendering a display frame the contents of frame buffer may be output to display device . Typically display device is a CRT or LCD display. However the output of rendering operations may not be used for immediate display such as when graphics rendering pipeline is used to generate frames for an animation sequence or rendered visual effect.

Parameter buffer object stores the constant data used by the different shader programs running on the processing units of graphics rendering pipeline . Uniform variable buffer object stores data used by bindable uniform variables declared in shader programs . Hardware binding tables are used to manage which buffer objects are bound to which parameter buffer object and which buffer objects are used to provide memory storage for a given bindable uniform variable. As shown hardware binding tables includes vertex shader bindings geometry shader bindings and fragment shader bindings . In one embodiment hardware binding tables are used to map a reference to a parameter buffer object in a shader program to an actual buffer object in local memory . Changing the buffer object bound to one of the binding points for a given processing unit allows an application to bind and unbind large groups of shader program parameters at once and also to specify the buffer object used to load parameters into when using calls provided by a graphics API.

As described in greater detail herein memory page pool stores a set of memory pages used to manage multiple versions of a given buffer object whether the buffer object is used as a parameter buffer object or as a bindable uniform buffer object . Memory page pool in conjunction with buffer object version table allows different versions of a given buffer object to be used concurrently by different shader programs running on the processing units of graphics rendering pipeline .

Between vertex processing unit geometry processing unit and fragment processing unit are primitive assembly unit and primitive assembly and rasterizer unit . The primitive assembly unit is typically a fixed function unit that receives processed vertex data from vertex processing unit and constructs graphics primitives e.g. points lines triangles or the like for processing by geometry processing unit . Primitive assembly and rasterizer unit which is optional in various implementations may receive the graphics primitives output by geometry processing unit such as a set of triangles perform clipping operations to limit the triangles passed to fragment processing unit to ones that are viewable on display device and generate fragments for each pixel covered by the primitive. During rendering operations the processing units of graphics rendering pipeline may access data from a parameter buffer object and or bindable uniform buffer object represented in by an arrow .

The processing performed by vertex processing unit geometry processing unit and fragment processing unit may be defined by shader programs which may include some combination of a vertex shader program a geometry shader program and a fragment shader program . In one embodiment under the first programming model these shader programs may be written using a high level shading language such as the Cg or GLSL shading languages and transmitted to API for processing within GPU driver . Again the shader programs are then compiled and linked by a compiler linker included with GPU driver to produce a linked version of the shader programs. In one embodiment the output of compiler linker may include linked program object . The linked program object may include multiple shader programs as well as a buffer object binding table used to manage the bindings between a given shader program and the binding points of hardware binding table .

The code generated by the compiler linker may be in the form assembly code in which case it is then converted into machine code also referred to as microcode by microcode assembler . Alternately the compiler linker may directly generate machine code in which case the GPU driver may not include a microcode assembler . The machine code versions of the shader programs are then transmitted to the vertex processing unit the geometry processing unit and the fragment processing unit as the case may be for execution. In alternative embodiments under the second programming model the vertex shader program the geometry shader program and the fragment shader program may be written in assembly code or may be compiled into assembly code externally to GPU driver . In such embodiments GPU driver would not necessarily include compiler linker and GPU driver would receive assembly code versions of the shader programs directly. Assembler would then convert the assembly code into machine code and transmit the machine code versions of the shader programs to the appropriate processing units of the graphics rendering pipeline as set forth above.

API may include calls used to write data generated by one of the processing units of the graphics rendering pipeline into buffer objects and or . API may also include calls used to modify the data in buffer objects and or . For example buffer objects and or may be loaded or modified using a transform feedback pathway which captures selected transformed attributes of vertices processed by vertex processing unit or geometry processing unit

Additionally a linked program object may contain a buffer object bindings table . As described in greater detail in conjunction with buffer object binding table is used to store the active bindings for the bindable uniforms in program object . Further API may provide calls allowing application to write data to buffer objects and or . For example API may provide an API call that allows a developer to map the buffer object to a pointer used by application allowing application to write to buffer objects and or directly. In one embodiment an in band update mechanism described below in conjunction with is used to manage updates to buffer objects and or made using API calls provided by a graphics library.

As shown the execution of vertex geometry and fragment shader programs flows from left to right and an in band update occurs to a parameter buffer object at time t. A vertex shader program executes a first time using version of parameter buffer object segment . A geometry shader program and a fragment shader program also execute using version of parameter buffer object segments and . After the update to parameter buffer object a second execution of vertex shader program runs at a second time using version of parameter buffer object segment . Similarly geometry shader program and fragment shader program also execute using version of parameter buffer object segments and . The vertex processing unit geometry processing unit and fragment processing unit are logically arranged in a serial pipeline and vertex fragment and geometry shader programs e.g. programs and may execute on the respective processing units of graphics rendering pipeline concurrently. Thus as can be seen in vertex shader program executes using version segment while concurrently geometry shader program executes using version segment of parameter buffer object . To support this parallel execution when a shader program is executed on one of the processing units of graphics rendering pipeline the shader program may be configured to use a version of parameter buffer object specified in buffer object version table .

Buffer object version table allows multiple shader programs to reference either versions or version of buffer object as appropriate. For example referring to the timing diagram of segment represents an instance of vertex shader program executing using version of buffer object . Simultaneously segment represents an instance of geometry shader executing using version of buffer object . Thus the in band update mechanism of the present invention increases the parallel execution capabilities of graphics rendering pipeline . Otherwise the shader programs represented by segments would first complete executing before the buffer object was updated and segment began executing. In one embodiment to allow other uses of the buffer object after the update the GPU will write the updated version of page stored in page of the page pool back to buffer object after all vertex geometry and fragment shader programs using version have completed executing. Additionally as shown buffer object version table allows up to three entries of buffer object to be active at any given time. Of course the number of concurrent versions may be dependent on the size of buffer object version table and may be tailored as needed for a particular graphics hardware device.

The method begins at step where application invokes a call provided by API to bind one or more buffer objects to binding points in the binding tables . In one embodiment the API may include calls with the following signatures 

In step application invokes a call provided by API to modify data in a parameter buffer object. In one embodiment the API may provide calls with the following signatures 

At step the memory pages of the buffer object affected by the update may be copied to a memory page pool and modified as specified by the API call received at step . Thereafter at steps and memory addresses for the modified version of the buffer object are stored in the next available version in buffer object version table. At step addresses for the memory pages of the current version of the buffer object are propagated to the next version of the buffer object. At step addresses for the pages modified by the update are set to the addresses of the corresponding pages in the page pool. After steps and the modified version includes a collection of addresses to pages in the original buffer object and modified pages in the page pool. At the same time the previous version of the buffer object includes a complete set of references that describe the buffer object before the modification. Thus any active shader programs may still access the previous version and any new instances of a shader program may access the modified version.

At step once all the active shader programs using a previous version of the buffer object complete executing the modified pages in the page pool may be copied to the buffer object overwriting the corresponding unmodified pages to produce a modified version of the buffer object. Using the example of once all active shader programs using version of parameter buffer object complete executing the data in page of the page pool may be written to page of buffer object overwriting original page and freeing up space in page pool to store subsequently modified pages. At the same time the entry for page version in buffer object version table may be updated to store the address of page of buffer object .

In one embodiment when program object is complied and linked by compiler linker the bindable uniforms declared in shader programs and are set to an unbound state. Thereafter API calls may be used to bind the color size and position bindable uniforms to the storage space of a buffer object. A buffer object has to first be bound to the bindable uniform before being accessed by a shader program or before an API call may be used to set the data values of the bindable uniform. Buffer object binding table is used to store the active bindings for the bindable uniforms in program object . That is buffer object binding table stores a reference to a binding point in hardware bindings table which may be used to store the address of a buffer object for a particular bindable uniform. Illustratively the bindable uniform named position included in vertex shader program is bound to binding point in vertex shader binding table . Similarly the bindable uniform named color included in geometry shader program and fragment shader is bound to binding point in both geometry shader binding table and fragment shader binding table . Lastly the bindable uniform named size included in geometry shader program and fragment shader program is bound to binding point in geometry shader binding table and binding point in fragment shader binding table .

Binding points in hardware bindings table map to the bindable uniform buffer objects and in local memory . For the vertex shader bindings binding point maps to bindable uniform buffer object . That is to buffer object storage for the position bindable uniform. For the geometry shader bindings binding point maps to bindable uniform buffer object and binding point maps to bindable uniform buffer object . That is to buffer object storage for the color and size bindable uniforms respectively. And for the fragment shader program binding point maps to bindable uniform buffer object and binding point maps to bindable uniform buffer object . That is to buffer object storage for the color and size bindable uniforms respectively.

The method begins at step where a linked program object that includes bindable uniforms is transmitted for execution to one of the processing units of GPU . As stated when a shader program in a program object is complied and linked any bindable uniforms declared in that shader programs are set to an unbound state. Thereafter calls included in API may be used to bind a buffer object to a bindable uniform variable referenced by the linked shader program.

At step an API call may be used to determine the location of a specific bindable uniform variable. For example the OpenGL API includes a call with the following signature 

Invoking this call with the program ID of a given shader program and the name of a bindable uniform variable returns a reference to the bindable uniform specified by the parameter. In other words the value returned by glGetUniformLocation may be used to specify the bindable uniform variable side of a binding between a given bindable uniform and buffer object.

At step an API call may be used to determine the size of a buffer object required for the bindable uniform variable specified at step . For example the OpenGL API may be extended to include a call with a signature like the following 

This API call returns the size in basic machine units e.g. bytes of the smallest buffer object that can be used for the bindable uniform given by the parameter. The size returned may subsequently be passed as the parameter to the BufferData command used to populate a buffer object with application data. The error INVALID OPERATION is generated if does not correspond to an active bindable uniform in the shader program specified by the parameter. The parameter has to be the location corresponding to the name of the bindable uniform itself returned by the glGetUniformLocation call otherwise the error INVALID OPERATION is generated.

At step API calls may be used to allocate storage for a buffer object from local memory and to populate the buffer object with data supplied by application . For example the OpenGL API includes a call with the following signature 

At step an API call may be used to bind the buffer object specified in step to the bindable uniform variable identified in step . For example the OpenGL API may be extended to include a call with a signature like the following 

This API call binds the buffer object specified by the parameter to the bindable uniform in the program object . The parameter has to correspond to the name of the uniform variable itself as described for the GetUniformLocation API call otherwise the error INVALID OPERATION is generated. If the parameter has not been successfully linked or if the parameter is not the name of an existing buffer object then the error INVALID OPERATION may be generated.

In one embodiment a buffer object may be bound to at most one uniform variable in a given program object. However a buffer object may be bound to bindable uniform variables in multiple program objects. Furthermore if those bindable uniforms are all of the same type then accessing a scalar vector a member of a structure or an element of an array in program object A results in the same data being accessed in program object B.

At step an API call may be used to update the values of the bindable uniform. The bindable uniform may be updated using one of the well known API commands used to update the contents of a buffer object. Additionally well known API commands may be used to directly update the values of the bindable uniforms used by the active program object. For example the OpenGL API call with a signature 

may be used to update a bindable uniform declared as an array of four component vectors. identifies the bindable uniform being updated identifies the number of array elements to update and identifies the new values of the uniform. The advantageous in band update mechanism described above may be used to update the uniform values with increased efficiency.

Advantageously by allowing uniform variables to be bound to storage provided by a buffer object the API in effect allows a mechanism for sharing data sets among multiple program objects and shader programs. Further the use of buffer objects as parameter buffer objects or as the storage space for a bindable uniform allows a number of graphics rendering operations to be performed without requiring intervention by a CPU thereby increasing the performance of the graphics rendering hardware. Additionally a graphics API may be used to update data values stored in a buffer object during rendering operations without having to wait until all active shader programs using one version of data in the buffer object have completely executed before the data values stored in the buffer object may be updated further increasing GPU performance.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

One embodiment of the invention provides a computer readable medium that includes program instructions that when executed by a processor cause the processor to bind a bindable uniform variable to a buffer object by performing the steps of creating a linked program object comprising one or more shader programs where each shader program includes instructions written in a high level shader language and where the linked program object includes a reference to a bindable uniform variable and indicates which shader programs use the bindable uniform variable determining a memory size to support the bindable uniform variable allocating a buffer object having the memory size binding the buffer object to the bindable uniform variable populating the buffer object with values for the bindable uniform variable and accessing the values of the bindable uniform with one or more of the shader programs in the linked program object.

