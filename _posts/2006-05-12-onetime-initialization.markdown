---

title: One-time initialization
abstract: Aspects of the present invention are directed at providing safe and efficient ways for a program to perform a one-time initialization of a data item in a multi-threaded environment. In accordance with one embodiment, a method is provided that allows a program to perform a synchronized initialization of a data item that may be accessed by multiple threads. More specifically, the method includes receiving a request to initialize the data item from a current thread. In response to receiving the request, the method determines whether the current thread is the first thread to attempt to initialize the data item. If the current thread is the first thread to attempt to initialize the data item, the method enforces mutual exclusion and blocks other attempts to initialize the data item made by concurrent threads. Then, the current thread is allowed to execute program code provided by the program to initialize the data item.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07962912&OS=07962912&RS=07962912
owner: Microsoft Corporation
number: 07962912
owner_city: Redmond
owner_country: US
publication_date: 20060512
---
A common activity performed by computer programs is to initialize a data item. For example some high level programming languages are object oriented in that functionality of a program may be implemented in objects created from a class. As a program executes the first time the program uses an object a function or other program code initializes the object. As used herein the term initialize or initialization refers to the process of allocating resources to a data item such as an object. By way of example only if a program creates a file object the initialization process may include but is not limited to allocating memory to the file object setting object specific variables obtaining a file handle used to reference the file object and the like.

In some instances the process of initializing a data item such as an object is resource intensive. As a result modern computer systems are typically configured to defer initialization until such time that a program will access the resources allocated to the object. Moreover once an object has been initialized information used to access or call the initialized object is cached so that subsequent calls to the object may be handled quickly without initialization being repetitively performed.

However deferring initialization of a data item such as an object introduces potential error sources into a program that executes in any multi threaded environment. In this regard to overcome the deficiencies associated with previous generations of computers modern operating systems have been created that are multi threaded. A thread is the basic unit used by an operating system to allocate processor time and may include any part of a program s code including parts currently being executed by another thread. Thus as used herein multi threaded refers to the technique implemented by modern operating systems to alternate between different parts of a program e.g. threads . As each thread completes executing the processor is allocated to another thread. In a computer with one processor the extraordinary speed of the processor provides the illusion that programs and their associated threads execute simultaneously. Multi threaded operating systems increase the amount of work a computer system is able to accomplish because most programs do not require that threads continuously execute. For example periodically a thread blocks or stops executing and waits while a slow resource completes a data transfer or while another thread is using a resource it needs. When one thread must wait multi threaded environments allow another thread to execute thus taking advantage of processor cycles that would otherwise be wasted.

While a multi threaded operating system allocates resources efficiently a potential error source arises as two or more threads may be configured to concurrently initialize the same data item e.g. object . In some systems a program developer may be required to synchronize the initialization of an object using a synchronization construct such as but not limited to a semaphore condition variable spinlock etc. Synchronization constructs provide the ability for one thread to voluntarily stop executing or sleep and wait until another thread performs an operation. However using a synchronization construct requires developers to carefully consider synchronization issues when developing a program. For example the way in which a synchronization construct is implemented may be dependent on the computer platform in which a program will execute.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Aspects of the present invention are directed at providing safe and efficient ways for a program to perform a one time initialization of a data item in a multi threaded environment. In accordance with one embodiment a method is provided that allows a program to perform a synchronized initialization of a data item that may be modified by multiple threads. More specifically the method includes receiving a request to initialize the data item from a current thread. In response to receiving the request the method determines whether the current thread is the first thread to attempt to initialize the data item. If the current thread is the first thread to attempt to initialize the data item the method enforces mutual exclusion and blocks other attempts to initialize the data item made by concurrent threads. Then the current thread is allowed to execute program code provided by the program to initialize the data item.

The present invention may be described in the general context of data items that cause computer instructions to be executed. Generally described a data item may include but is not limited to objects routines widgets components data structures and the like that perform particular tasks or implement particular abstract data types. Moreover the present invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment data items may be located on local and or remote computer storage media.

While the present invention will primarily be described in the context of using a one time initialization primitive to synchronize initialization of a data item those skilled in the relevant art and others will recognize that the present invention is also applicable to other areas than those described. In any event the following description first provides a general context and system in which aspects of the present invention may be implemented. Then methods that implement aspects of the invention are described. The illustrative examples described herein are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Similarly any steps described herein may be interchangeable with other steps or combinations of steps in order to achieve the same result.

Embodiments of the present invention are operational in numerous general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for implementing the invention include but are not limited to personal computers server computers laptop devices multiprocessor systems microprocessor based systems network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or the like. In this regard illustrates an exemplary computer with components that collectively provide a one time initialization system. As illustrated in the computer includes a hardware platform an operating system that provides services to the threads and via the interface . Moreover in the embodiment illustrated in the operating system includes a blocking initialization routine a non blocking initialization routine and a shared object . For ease of illustration and because it is not important for an understanding of the present invention does not show some typical components of modem computers such as a memory processor keyboard a mouse a printer or other I O devices a display etc.

As illustrated in the computer includes an operating system that may be a general purpose operating system such as a Microsoft operating system UNIX operating system or Linux operating system. Alternatively the operating system may be a specialized operating system designed specifically for a computer that maintains non generic hardware. In any event the operating system controls the general operation of the computer and is responsible for providing certain core services including but not limited to input output memory management thread scheduling and the like. For example when the threads request resources from the hardware platform the operating system provides services to access the resources. Typically services provided by the operating system are accessible using the interface which may define a set of callable functions APIs .

The threads are independent paths of software execution within one or more processes not illustrated and may execute concurrently and asynchronously in the computer . Multi threading environments that support concurrent threads of execution imply that certain program tasks may be executed in any order and possibly in parallel. When designing an operating system that supports multi threading with concurrent threads of execution it is preferable to avoid any potential data conflicts that may result from multiple attempts to initialize the same data item. In this regard depicts a shared object that may be accessed by either of the threads or . In accordance with one embodiment the present invention extends the functionality of the operating system by providing APIs that among other things abstract synchronization logic for initializing data items shared by multiple threads such as the shared object .

A program may issue an API call to the interface for initializing the. shared object and obtain data to access the shared object . When the API call is received software components in the operating system may perform an efficient and lightweight initialization of the shared object if initialization of the shared object has not been previously performed. As described in further detail below by having a trusted software component such as the operating system synchronize initialization of the shared object the potential for program developers to implement common synchronization errors is avoided.

One aspect of the present invention is a blocking initialization routine that enforces mutual exclusion to initialize a data item. Since the blocking initialization routine is described in further detail below with reference to a detailed description of the routine will not be provided here. However generally described the blocking initialization routine enforces mutual exclusion when causing a one time initialization of a data item to be performed. In other words a critical section or code area where the multiple threads could execute concurrently to initialize a data item is identified. Then mutual exclusion is enforced in the critical section through a set of atomic operations that allow a first in time thread to start initialization of the shared object as subsequent threads are blocked until the initialization started by the first in time thread is complete. Stated differently the set of atomic operations allows one thread among the multiple threads to initialize the shared object . Once initialization of the shared object is complete data that may be used to access the shared object may be returned to all threads that attempt the initialization.

Another aspect of the present invention is a non blocking initialization routine that initializes a data item without blocking any thread s initialization attempt. Since the non blocking initialization routine is described in further detail below with reference to a detailed description of the routine will not be provided here. However similar to the blocking initialization routine the non blocking initialization routine may initialize a data item such as the shared object . In this instance multiple threads are allowed to concurrently attempt to initialize the shared object without subsequent threads being blocked until a first in time thread completes the initialization. Stated differently until a first in time thread successfully completes the initialization subsequent threads are not prevented from also attempting the initialization. Once a first in time thread successfully completes the initialization transitions are implemented to prevent subsequent threads from attempting the initialization. Moreover any thread that attempted the initialization but was not the first in time thread is returned an indication that the initialization occurred but the current thread s attempt failed so that clean up operations may be performed.

In the embodiment of the computer illustrated in logic provided by the present invention is implemented in the operating system . However those skilled in the art and others will recognize that the computer architecture described with reference to is exemplary and should not be construed as limiting. For example the logic provided by blocking initialization routine and non blocking initialization routine may be implemented in other contexts without departing from the scope of the claimed subject matter. Generally stated is an exemplary depiction of one computer in which aspects of the present invention may be implemented. Actual embodiments of the computer will have additional components not illustrated in or described in the accompanying text. Moreover shows one component architecture for performing a one time initialization of a data item but other component architectures are possible.

Now with reference to an exemplary embodiment of a blocking initialization routine briefly mentioned above with reference to will be described in further detail. In accordance with one embodiment the blocking initialization routine is executed each time a thread issues an API call to an operating system for initializing a specified data item in a way that enforces mutual exclusion. For example in the context of both of the threads or may concurrently issue an API call to the interface that invokes the blocking initialization routine . The blocking initialization routine handles each API call by causing the data item to be initialized and returns initialization information to each calling thread. As described in further detail below the operations performed by the blocking initialization routine only allow the first in time thread to perform a synchronized one time initialization of the data item the results of which are reported to other threads that make an initialization attempt.

As illustrated in the blocking initialization routine begins at decision block where a determination is made regarding whether a specified data item was previously initialized. In accordance with one embodiment arguments are passed to the blocking initialization routine by a calling program which identifies the specified data item that will be initialized and a callback function or other program code that is configured to perform the initialization.

When an attempt to initialize a data item is initially made a global variable hereinafter referred to as a one time initialization primitive is created. In one embodiment the one time initialization primitive includes a two tuple of bits used for tracking the initialization state of the data item. When the one time initialization primitive is created the initialization state of the data item is set to uninitialized by default. As described in further detail below the two tuple of bits may be manipulated through a set of atomic operations that transitions a one time initialization primitive into one of three possible states including the states of 1 uninitialized 2 initializing blocking or 3 initialized. By tracking the state of the one time initialization primitive the blocking initialization routine may implement functionality that allows a synchronized one time initialization of the data item to be performed.

At block the blocking initialization routine accesses the one time initialization primitive allocated to the data item that the current thread is attempting to initialize. As described in further detail below a first in time thread may have previously initialized the data item and transitioned the one time initialization primitive into the initialized state. In this instance the blocking initialization routine determines that an initialization was previously performed and proceeds to block described in further detail below. Conversely if the one time initialization primitive indicates that the specified data item has not reached the initialized state the blocking initialization routine determines that an initialization was not previously performed and proceeds to block .

It should be well understood that the one time initialization primitive may be created and used by the blocking initialization routine either statically at compile time or dynamically at run time. For example in operating systems that support dynamic creation of objects the one time initialization primitive may be created as part of a larger object by a dynamic object allocator such as a structure commonly known as a heap. Those skilled in the art and others will recognize that allowing the one time initialization primitive to be created dynamically expands the possible uses of the present invention over existing systems.

At decision block the blocking initialization routine determines whether the current thread is the first in time thread that will succeed in causing program code for initializing the data item to be executed. It should be well understood that the current thread s call to the blocking initialization routine may be interrupted in a multi threaded environment thereby potentially resulting in multiple concurrent attempts to initialize the same data item. Stated differently the blocking initialization routine has not yet enforced mutual exclusion as a critical section of program code in which only one thread may enter at a time has not yet been reached. As a result an operating system may interrupt the current thread s attempt to initialize the data item potentially resulting in a different thread reaching a critical section where mutual exclusion is enforced. As described in further detail below mutual exclusion is enforced when the one time initialization primitive transitions to the initializing state as only one thread is allowed to transition the one time initialization primitive to the initializing state. Thus to determine whether the current thread is the first in time thread at block the value of the one time initialization primitive is identified. If the one time initialization primitive indicates that the data item is still in the uninitialized state the blocking initialization routine determines that the current thread is the first in time thread and proceeds to block described below. Conversely if the one time initialization primitive now indicates that the data item has either reached the initializing or initialized state the blocking initialization routine determines that the current thread is not the first in time thread and proceeds to block .

At block a wait block associated with the current thread is added to a data structure. If block is reached the current thread is not the first in time thread that will initially attempt to execute the program code for initializing the data item. As each subsequent in time thread reaches block a compare and swap operation is performed in which data associated with the previous thread is added to the current thread s stack. As a result concurrent threads are linked in a data structure that tracks concurrent attempts to initialize the same data item. In this regard and in accordance with one embodiment entries in the data structure are reverse ordered based on the time when an entry was added to the data structure e.g. LIFO . However those skilled in the art and others will recognize that a different type of data structure may be used and entries may be linked in other ways without departing from the scope of the claimed subject matter. As described in further detail below tracking concurrent attempts to initialize the same data item in a data structure provides a mechanism for the thread that succeeds in initializing the data item to identify and awaken threads that are put to sleep. 

As further illustrated in at block the blocking initialization routine blocks the current thread from continuing to execute. If block is reached the current thread was not identified as the first in time thread that will be allowed to initially attempt to initialize the data item. In this instance the current thread is blocked or put to sleep at block . As a result processor time previously allocated to the current thread is available and may be allocated to other threads. Then at block the blocking initialization routine remains idle until the current thread is awakened from sleep. As described in further detail below once the first in time thread has either successfully initialized the data item or failed in the initialization attempt a thread that was previously put to sleep is awakened. In this instance the blocking initialization routine proceeds back to block where a determination regarding whether the data item was successfully initialized is made. If the data item was successfully initialized by a different thread the blocking initialization routine proceeds to block where the results of the successful initialization are returned to the current thread. Conversely if the data item was not successfully initialized the current thread may proceed in making another initialization attempt.

At block the blocking initialization routine transitions the initialization state of the data item into the initializing blocking state. If block is reached the current thread was identified as the first in time thread that will initially attempt to initialize the data item. In this instance the value of the two tuple of bits in the one time initialization primitive is modified at block to reflect that the current thread s initialization attempt is proceeding. As a result the blocking initialization routine is now enforcing mutual exclusion so that only one thread may proceed to block and execute program code to initialize the data item. Stated differently subsequent threads that reach block described above will now determine that they are not the first in time thread since the one time initialization primitive is now in the state of initializing. As mentioned previously these subsequent threads will block thereby resulting in mutual exclusion in the critical code section block . It should be noted that the implementation of the blocking initialization routine described herein enforces mutual exclusion without relying on a synchronization construct such as an internal locking mechanism. As a result aspects of the present invention provide a streamlined initialization mechanism that abstracts synchronization issues from developers. Moreover the initialization mechanism provided by the present invention is optimized for the initialization scenario to use only a pointer sized variable e.g. the one time initialization primitive thereby minimizing the use of computer resources.

As illustrated in at block the blocking initialization routine causes program code that initializes the data item to be executed. As mentioned previously and in accordance with one embodiment an argument known as a callback function may be passed to the blocking initialization routine when the appropriate API call is made. The callback function identifies the function or other program code provided by the calling program that is configured to initialize the data item. In this example the blocking initialization routine causes the data item to be initialized at block by branching program execution to the callback function that was received when the API call was made. However those skilled in the art will recognize that program code for initializing the data item may be called using other mechanisms without departing from the scope of the claimed subject matter.

The callback function may be configured to return data to the blocking initialization routine . For example if the data item initialized is a file object the callback function may return a file handle to the blocking initialization routine that was allocated by an operating system to access the file object. In one embodiment the data capable of being returned to the blocking initialization routine is a variable capable of storing any data format. Thus the memory overhead used by the present invention to synchronize initialization of a data item is small. It should be well understood that the callback function is not required to return any data to the blocking initialization routine . In accordance with one embodiment the data returned is stored in the one time initialization primitive along with the two tuple of bits. As described in further detail below the data returned by the callback function that is stored in a one time initialization primitive will be returned to each thread that attempts to initialize the data item.

At decision block a determination is made regarding whether the specified data item was successfully initialized. Stated differently a determination is made at block regarding whether the program code that is configured to initialize the data item was successfully executed at block . Those skilled in the art and others will recognize that program code for initializing a data item may fail for any number of different reasons. In one embodiment if data is returned from the callback function that is indicative of a failure the result of the test performed at block is NO and the blocking initialization routine proceeds to block . Conversely if the data item was successfully initialized the result of the test performed at block is YES and the blocking initialization routine proceeds to block described in further detail below.

At block the blocking initialization routine transitions the current thread from the initializing blocking state into the uninitialized state by modifying the two tuple of bits in the one time initialization primitive allocated to the current thread. By changing the state of the current thread s initialization attempt mutual exclusion is no longer enforced. As a result threads that were previously blocked by being put to sleep are awakened and may proceed in attempting to initialize the data item. More specifically the operating system receives notice of the state transition and traverses the data structure in which concurrent threads are represented. In one embodiment each concurrent thread represented in the data structure of linked wait blocks is awakened and proceeds to block where a determination is made regarding whether the data item has been successfully initialized.

In the embodiment illustrated in the blocking initialization routine is configured to then proceed to block where data is returned to the current thread that indicates the initialization attempt failed. When a calling thread receives an indicator of an initialization failure any number of different actions may be performed in response to the failure. For example and as mentioned previously other initialization attempts may be made by other concurrent threads. In another embodiment a program may merely handle the failure to prevent error conditions. In this instance information may be passed to the operating system that indicates the first in time initialization attempt succeeded. However concurrent threads that are blocking may be passed information that prohibits the concurrent threads from proceeding in attempting to initialize the data item. As a result the concurrent threads are awakened but additional initialization attempts are not made.

At block the blocking initialization routine transitions the current thread from the initializing blocking state into the initialized state by modifying the two tuple of bits in the one time initialization primitive. Then the blocking initialization routine proceeds to block described below. As a result of changing the state of the current thread s initialization attempt at block mutual exclusion is no longer enforced and threads that were previously put to sleep are awakened. As mentioned previously the threads that are awakened may proceed back to block from block where those threads may determine that the data item has been initialized. Moreover any other initialization attempts made by subsequent threads will also determine that the data item has been successfully initialized when block is reached. These subsequent threads will then proceed to block where the results of the successful initialization attempt are returned.

At block data is returned to the current thread that includes the results produced by the successful initialization attempt. In one embodiment the blocking initialization routine is executed in response to an API call. At block data is returned to the current thread where the API call was generated that indicates the data item was successfully initialized. Moreover any data stored in the one time initialization primitive allocated to the thread that was successful in initializing the data item is returned to all threads. As a result all threads receive data that may be used to access the initialized data item even though the current thread may or may not have been the thread that was successful in causing the data item to be initialized. Then the blocking initiation routine proceeds to block where it terminates.

Now with reference to an exemplary embodiment of a non blocking initialization routine briefly mentioned above with reference to will be described in further detail. In accordance with one embodiment the non blocking initialization routine is executed each time a thread issues an API call that attempts to initialize a specified data item in a way that prevents any thread from being blocked. For example in the context of both of the threads or may issue an API call to the interface that invokes the non blocking initialization routine . In response each API call is handled by a set of operations that allows concurrent threads to initialize the same data item. As described in further detail below when concurrent threads initialize the same data item each is returned data obtained as a result of the first in time initialization. However concurrent but subsequent in time threads are also returned data that indicates their initialization did not succeed so that clean up operations may be performed. Those skilled in the art and others will recognize that robustness is added to operating system if an API is available to initialize a data item without blocking a concurrent thread s attempt to initialize the same data item. For example certain real time systems may not allow a thread to be put to sleep when an attempt to complete a task is made.

As illustrated in the non blocking initialization routine begins at decision block where a determination is made regarding whether a specified data item was previously initialized. Similar to the description provided above with reference to arguments are passed to the non blocking initialization routine by a calling program which identifies the specified data item that will be initialized and a callback function or other program code that is configured to perform the initialization Similar to the description provided above with reference to when an attempt to initialize a data item using the non blocking initialization routine is initially made a one time initialization primitive is created. In one embodiment the one time initialization primitive includes a two tuple of bits for tracking the initialization state of the data item. When block is initially reached the one time initialization primitive is set to uninitialized by default. As described in further detail below the two tuple of bits may be manipulated to transition the initialization state of a data item into one of three possible states including the states of 1 uninitialized 2 initializing non blocking or 3 initialized. By tracking the initialization state of the data item the non blocking initialization routine may implement functionality that allows a non blocking initialization of the data item to be performed.

At block the non blocking initialization routine accesses the one time initialization primitive associated with the data item that the current thread is attempting to initialize. As described in further detail below a first in time thread may have previously initialized the data item and transitioned the one time initialization primitive into the initialized state. In this instance the non blocking initialization routine determines that an initialization was previously performed and proceeds to block described in further detail below. Conversely if the one time initialization primitive indicates that the data item has not reached the initialized state the non blocking initialization routine determines that an initialization was not previously performed and proceeds to block .

At decision block a determination is made regarding whether the current thread is the first thread to attempt to initialize the data item. The operating system may interrupt the current thread s attempt to initialize the data item potentially resulting in multiple concurrent initialization attempts. However unlike the blocking initialization routine described above the non blocking initialization routine does not enforce mutual exclusion when initializing a data item. Instead multiple initialization attempts are allowed to proceed in parallel with subsequent in time threads receiving results obtained by the first in time thread. However only the first in time thread is allowed to transition the one time initialization primitive to the initializing state non blocking and ultimately to the initialized state. Thus to determine whether the current thread is the first in time thread at block the value of the one time initialization primitive is identified. If the one time initialization primitive indicates that the data item is still in the uninitialized state the non blocking initialization routine determines that the current thread is the first in time thread and proceeds to block described below. Conversely if the one time initialization primitive indicates that the data item has either reached the initializing or initialized state the non blocking initialization routine determines that the current thread is not the first in time thread and proceeds to block .

At block the non blocking initialization routine transitions the current thread into the initializing non blocking state. If block is reached the current thread was identified as the first in time thread. In this instance the value of the two tuple of bits in the one time initialization primitive is modified at block to reflect that the current thread is entering the initializing non blocking state. However as mentioned previously changing the state of the first in time thread to the initializing non blocking state does not prevent other concurrent threads from proceeding to attempt to initialize the data item.

As illustrated in at block the non blocking initialization routine causes program code that initializes the data item to be executed. Similar to the description provided above with reference to an argument known as a callback function may be passed to the non blocking initialization routine when the appropriate API call is made. The callback function identifies the function or other program code provided by the calling program that is configured to initialize the data item. In this example the non blocking initialization routine causes the data item to be initialized at block by branching program execution to the callback function or other program code that was identified when the API call was made. When execution is complete the callback function may or may not return data to the non blocking initialization routine . Similar to the description provided above with reference to the data returned may be stored in the one time initialization primitive along with the state information. As mentioned previously the non blocking initialization routine does not block a concurrent but duplicative attempt to initialize a data item. Thus multiple concurrent threads may reach block and cause the data item to be initialized.

At decision block a determination is made regarding whether the current thread was the first in time thread that successfully initialized the data item. As described in further detail below the first in time thread transitions the one time initialization primitive from the initializing blocking state into the initialized state. Thus at block the non blocking initialization routine accesses the one time initialization primitive associated with the data item. If the one time initialization primitive was previously transitioned into the initialized state the non blocking initialization routine determines that an initialization was previously performed and proceeds to block . Conversely if the one time initialization primitive indicates that the data item has not reached the initialized state the non blocking initialization routine determines that the current thread is the first thread to successfully complete initialization and proceeds to block .

At block the blocking initialization routine transitions the current thread from the initializing blocking state into the initialized state by modifying the two tuple of bits in the one time initialization primitive. By changing the state of the one time initialization primitive subsequent threads that reach decision block proceed directly to block where results of the initialization performed by the current thread are returned. Moreover by changing the state of the one time initialization primitive to initialized threads that reach decision block make a determination that initialization was previously completed and proceed to block .

At block data is returned to the current thread that indicates the initialization performed at block was not the first successful initialization of the data item. Those skilled in the art and others recognize that certain resources may be allocated to a thread when an attempt to initialize a data item is made. As mentioned previously if block is reached the current thread is not the first in time thread that successfully completed the initialization of the data item. In this instance the current thread may need to discard any allocated resources. Thus the non blocking initialization routine returns data to the current thread that indicates the initialization performed at block was not the first successful initialization of the data item so that these types of clean up operations may be performed.

At block data is returned to the current thread that includes the results produced by the successful initialization that was identified as being the first in time. In one embodiment the non blocking initialization routine is executed in response to an API call. At block data is returned to the current thread where the call originated that indicates the data item was successfully initialized. Moreover any data stored in the one time initialization primitive allocated to the first in time thread is also returned. As a result the current thread receives data that may be used to access the initialized data item. Then the non blocking initialization routine proceeds to block where it terminates.

While illustrative embodiments have been illustrated and described it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention.

