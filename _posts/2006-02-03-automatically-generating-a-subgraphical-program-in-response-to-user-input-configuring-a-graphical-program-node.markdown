---

title: Automatically generating a sub-graphical program in response to user input configuring a graphical program node
abstract: A system and method for configuring a node in a graphical program by programmatically generating graphical source code associated with the node. The node may initially have no functionality or may have default functionality and may be able to take on different functionality in the graphical program, depending on configuration user input received. User input specifying desired functionality for the node may be received via a GUI. Graphical source code may then be programmatically generated for the node, such that the node is operable to implement the specified desired functionality when the graphical program is executed. Since the graphical source code associated with the node is generated programmatically, a “minimal” amount of graphical source code may be generated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07689917&OS=07689917&RS=07689917
owner: National Instruments Corporation
number: 07689917
owner_city: Austin
owner_country: US
publication_date: 20060203
---
This application is a continuation of U.S. patent application Ser. No. 09 886 456 titled System and Method for Programmatically Creating Graphical Program Code in a Graphical Program filed Jun. 20 2001 now U.S. Pat. No. 7 069 517 whose inventors were Jeffrey D. Washington and Paul F. Austin which is a continuation in part of U.S. patent application Ser. No. 09 745 023 titled System and Method for Programmatically Generating a Graphical Program in Response to Program Information filed Dec. 20 2000 now U.S. Pat. No. 7 210 117 whose inventors were Ram Kudukoli Robert Dye Paul F. Austin Lothar Wenzel and Jeffrey L. Kodosky.

The present invention relates to the field of graphical programming and more particularly to a system and method for receiving user input specifying desired program functionality for a node in a graphical program and programmatically generating graphical source code to implement the specified functionality.

Traditionally high level text based programming languages have been used by programmers in writing application programs. Many different high level programming languages exist including BASIC C Java FORTRAN Pascal COBOL ADA APL etc. Programs written in these high level languages are translated to the machine language level by translators known as compilers or interpreters. The high level programming languages in this level as well as the assembly language level are referred to herein as text based programming environments.

Increasingly computers are required to be used and programmed by those who are not highly trained in computer programming techniques. When traditional text based programming environments are used the user s programming skills and ability to interact with the computer system often become a limiting factor in the achievement of optimal utilization of the computer system.

There are numerous subtle complexities which a user must master before he can efficiently program a computer system in a text based environment. The task of programming a computer system to model or implement a process often is further complicated by the fact that a sequence of mathematical formulas mathematical steps or other procedures customarily used to conceptually model a process often does not closely correspond to the traditional text based programming techniques used to program a computer system to model such a process. In other words the requirement that a user program in a text based programming environment places a level of abstraction between the user s conceptualization of the solution and the implementation of a method that accomplishes this solution in a computer program. Thus a user often must substantially master different skills in order to both conceptualize a problem or process and then to program a computer to implement a solution to the problem or process. Since a user often is not fully proficient in techniques for programming a computer system in a text based environment to implement his solution the efficiency with which the computer system can be utilized often is reduced.

Examples of fields in which computer systems are employed to interact with physical systems are the fields of instrumentation process control industrial automation and simulation. Computer measurement and control of devices such as instruments or industrial automation hardware has become increasingly desirable in view of the increasing complexity and variety of instruments and devices available for use. However due to the wide variety of possible testing and control situations and environments and also the wide array of instruments or devices available it is often necessary for a user to develop a custom program to control a desired system.

As discussed above computer programs used to control such systems traditionally had to be written in text based programming languages such as for example assembly language C FORTRAN BASIC etc. Traditional users of these systems however often were not highly trained in programming techniques and in addition text based programming languages were not sufficiently intuitive to allow users to use these languages without training. Therefore implementation of such systems frequently required the involvement of a programmer to write software for control and analysis of instrumentation or industrial automation data. Thus development and maintenance of the software elements in these systems often proved to be difficult.

U.S. Pat. Nos. 4 901 221 4 914 568 5 291 587 5 301 301 and 5 301 336 among others to Kodosky et al disclose a graphical system and method for modeling a process i.e. a graphical programming environment which enables a user to easily and intuitively model a process. The graphical programming environment disclosed in Kodosky et al can be considered a higher and more intuitive way in which to interact with a computer. A graphically based programming environment can be represented at a level above text based high level programming languages such as C Basic Java etc.

The method disclosed in Kodosky et al allows a user to construct a diagram using a block diagram editor. The block diagram may include a plurality of interconnected icons such that the diagram created graphically displays a procedure or method for accomplishing a certain result such as manipulating one or more input variables and or producing one or more output variables. In response to the user constructing a diagram or graphical program using the block diagram editor data structures may be automatically constructed which characterize an execution procedure which corresponds to the displayed procedure. The graphical program may be compiled or interpreted by a computer. Therefore Kodosky et al teaches a graphical programming environment wherein a user places or manipulates icons and interconnects or wires up the icons in a block diagram using a block diagram editor to create a graphical program. A graphical program for measuring controlling or modeling devices such as instruments processes or industrial automation hardware or for modeling or simulating devices may be referred to as a virtual instrument VI . Thus a user can create a computer program solely by using a graphically based programming environment. This graphically based programming environment may be used for creating virtual instrumentation systems modeling processes control simulation and numerical analysis as well as for any type of general programming.

In creating a graphical program a user may create a front panel or user interface panel. The front panel may include various user interface elements or front panel objects such as controls and or indicators that represent or display the respective input and output that will be used by the graphical program or VI and may include other icons which represent devices being controlled. The front panel may be comprised in a single window of user interface elements or may comprise a plurality of individual windows each having a user interface element wherein the individual windows may optionally be tiled together. When the controls and indicators are created in the front panel corresponding icons or terminals may be automatically created in the block diagram by the block diagram editor. Alternatively the user can place terminal icons in the block diagram which may cause the display of corresponding front panel objects in the front panel either at edit time or later at run time. As another example the front panel objects e.g. the GUI may be embedded in the block diagram.

During creation of the block diagram portion of the graphical program the user may select various function nodes or icons that accomplish his desired result and connect the function nodes together. For example the function nodes may be connected in one or more of a data flow control flow and or execution flow format. The function nodes may also be connected in a signal flow format which is a subset of data flow. The function nodes may be connected between the terminals of the various user interface elements e.g. between the respective controls and indicators. Thus the user may create or assemble a graphical program referred to as a block diagram graphically representing the desired process. The assembled graphical program may be represented in the memory of the computer system as data structures. The assembled graphical program i.e. these data structures may then be compiled or interpreted to produce machine language that accomplishes the desired method or process as shown in the block diagram.

Input data to a graphical program may be received from any of various sources such as from a device unit under test a process being measured or controlled another computer program or from a file. Also a user may input data to a graphical program or virtual instrument using front panel controls. This input data may propagate through the data flow block diagram or graphical program and appear as changes on the output indicators. In an instrumentation application the front panel can be analogized to the front panel of an instrument. In an industrial automation application the front panel can be analogized to the MMI Man Machine Interface of a device. The user may adjust the controls on the front panel to affect the input and view the output on the respective indicators. Alternatively the front panel may be used merely to view the input and output or just the output and the input may not be interactively manipulable by the user during program execution.

Thus graphical programming has become a powerful tool available to programmers. Graphical programming environments such as the National Instruments LabVIEW product have become very popular. Tools such as LabVIEW have greatly increased the productivity of programmers and increasing numbers of programmers are using graphical programming environments to develop their software applications. In particular graphical programming tools are being used for test and measurement data acquisition process control man machine interface MMI supervisory control and data acquisition SCADA applications simulation machine vision applications and motion control among others.

As graphical programming environments have matured and grown in popularity and complexity it has become increasingly desirable to provide high level tools which help a user create a graphical program. These tools may be able to dynamically or programmatically generate a graphical program or a portion of a graphical program. For example for various applications it would be desirable to provide various types of program information to a program wherein the program information specifies functionality of a graphical program or portion of a graphical program to be programmatically generated.

As described above a user typically creates a graphical program within a graphical programming environment by interactively or manually placing icons or nodes representing the desired blocks of functionality on a diagram and connecting the icons nodes together to represent one or more of the data flow control flow and or execution flow of the program. The ability to programmatically generate a graphical program in response to program information enables a graphical program or graphical program portion to be automatically generated without this type of interactive user input.

In particular it would be desirable for the user to be able to specify program functionality for a node in a graphical program at a high level via one or more graphical user interface GUI panels and to then programmatically generate graphical source code for the node to implement the specified program functionality.

One embodiment of the present invention comprises a system and method for configuring a node in a graphical program by programmatically generating graphical source code associated with the node. The node may be displayed in the graphical program in response to user input. The node may initially have no functionality or may have default functionality. As described below the node may be able to take on different functionality in the graphical program depending on configuration user input received. The node may be generally related to a particular functional realm such as data acquisition signal analysis data display network communications etc. However until configuration user input is received for the node as described below the exact behavior of the node within the graphical program may be undefined.

User input requesting to specify desired functionality or configuration information for the node may be received. For example the user may double click on the node execute a menu option for configuring the node or perform this request in any of various other ways. In response a graphical user interface GUI for specifying the configuration information may be displayed. Any type of GUI may be displayed in one embodiment the GUI may comprise one or more GUI input panels. The GUI input panels may take any of various forms including a dialog box or window and may include any of various means for receiving user input such as menus GUI input controls such as text boxes check boxes list controls etc. The GUI input panels may comprise textual and or graphical information and may be able to receive textual and or graphical user input.

The GUI e.g. the GUI input panel s may comprise information useable in guiding the user to specify functionality for the node. User input specifying desired functionality for the node may be received via the GUI. In other words the node may be configured to perform a variety of functions within the program depending on this received user input. As noted above the node may be generally related to a particular functional realm such as data acquisition signal analysis data display etc. Thus the GUI displayed may comprise information related to the particular functional realm. For example for a node related to network communications the GUI may comprise a GUI input panel including GUI controls for configuring the node to specify a data source or target to which to connect specify a connection protocol etc.

Graphical source code may then be automatically i.e. programmatically generated based on the specified desired functionality. This graphical source code may be associated with the node in the graphical program such that the node is operable to implement the specified desired functionality when the graphical program is executed. The programmatically generated graphical source code may comprise graphical source code similar to that which a user could create manually in a graphical programming development environment e.g. by including various function nodes or other types of nodes in the graphical program and connecting the nodes in one or more of a data flow control flow and or execution flow format.

The programmatically generated graphical source code may be associated with the node in various ways. In one embodiment the graphical source code programmatically generated for the node may replace the node in the graphical program so that the node is no longer visible in the graphical program. However in the preferred embodiment the graphical program may still appear the same even after the graphical source code has been programmatically generated in association with the node. That is in response to the user input specifying desired functionality for the node the graphical source code implementing the specified functionality may be generated behind the node in a hierarchical fashion such that the node still appears in the graphical program. In this instance the graphical source code may be programmatically created as a sub program or sub VI of the graphical program wherein the node represents the sub program. Generating the portion of graphical source code behind the node in this way may help to keep the graphical program more readable.

The user may choose to view the graphical source code programmatically generated behind the node if desired. For example in response to using a menu option or double clicking on the node to view the source code generated behind the node the programmatically generated graphical source code may be displayed. This may enable the user to modify the programmatically generated source code if desired. However in one embodiment the user may be prevented from viewing and or editing the programmatically generated graphical source code. This may force the user to control the functionality of the node through the GUI input panel s for the node rather than directly modifying the graphical source code.

As noted above in one embodiment when the node is initially displayed in the program the node may have no functionality. That is the node may not initially be operable to perform any function when the graphical program is executed. A traditional function node available for inclusion in a graphical program typically has associated program instructions that are executed when the node is executed in the program. In this case however the node may not initially have such associated program instructions. Instead the programmatically generated graphical source code that is associated with the node may define the program instructions to be executed for the node. For example these program instructions may be created from the programmatically generated graphical source code when the graphical program is compiled or interpreted and these program instructions may be executed when the node is executed in the program.

Also as noted above in one embodiment when the node is initially displayed in the program the node may have default functionality. That is the node may initially be operable to perform a default function when the graphical program is executed. Thus the node may have associated program instructions to be executed when the node is executed in the program or there may be default graphical source code associated with the node when the node is initially included in the graphical program. In this case the programmatically generated graphical source code that is associated with the node may replace the default functionality for the node.

As described above the node may be configured to perform a plurality of operations depending on user input specifying configuration information for the node. The configuration information may be received via a GUI and may specify one or more desired operations for the node from the plurality of possible operations. However since the graphical source code associated with the node is generated programmatically a minimal amount of graphical source code may be generated i.e. only graphical source code necessary to implement the one or more desired operations may be generated. Thus source code corresponding to operations from the plurality of operations that are not among the one or more desired operations may not be included in the graphical program.

Associating a minimal amount of source code with a graphical program node operable to perform a plurality of operations may have several advantages. For example by only including graphical source code in the program that is actually used the program may be significantly more readable. Also by not including unnecessary code the size of the executable program can be reduced which may be important for systems with limited amounts of memory. Also if the program is to be implemented in a hardware device e.g. in an FPGA device then it may be especially important to reduce the program size so that the program may be implemented with a limited amount of hardware resources available on the device.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternative following within the spirit and scope of the present invention as defined by the appended claims.

The following references are hereby incorporated by reference in their entirety as though fully and completely set forth herein.

The computer system may include or store a computer program referred to herein as a graphical program generation program or a GPG program that is operable to receive program information and programmatically generate a graphical program based on the program information. One embodiment of a method for programmatically generating a graphical program is described below.

In one embodiment the GPG program may be implemented as a self contained program or application that includes ail necessary program logic for generating the graphical program. In another embodiment the GPG program may comprise a client portion and a server portion or client program and server program wherein the client portion may request or direct the server portion to generate the graphical program. For example the client portion may utilize an application programming interface API provided by the server portion in order to generate the graphical program. In other words the client portion may perform calls to the API provided by the server portion and the server portion may execute functions or routines bound to these calls to generate the graphical program. In one embodiment the server portion may be an instance of a graphical programming development environment application. For example the LabVIEW graphical programming development environment application enables client programs to interface with a LabVIEW server in order to programmatically generate or modify graphical programs.

As used herein the term GPG program is intended to include any of various implementations of a program or programs that are executable to programmatically generate a graphical program based on received program information. For example the term GPG program is intended to include an embodiment in which the GPG program is a self contained program or application not implemented as a client server program that includes all necessary program logic for programmatically generating a graphical program. The term GPG program is also intended to include an embodiment in which a combination of a client portion or client program and server portion or server program operate together to programmatically generate the graphical program. The term GPG program is also intended to include other program implementations.

In an embodiment in which a client program interfaces with a server program to generate the graphical program the server program may execute on the same computer system as the client program or may execute on a different computer system e.g. a different computer system connected via a network. For example in the client program may execute on the computer system and the server program may execute on the computer system . In this case the graphical program e.g. files representing the graphical program may be created on the computer system or or on a different computer system.

It is noted that the GPG program may be implemented using any of various programming technologies or methodologies. Where the GPG program is implemented as client and server programs each of these programs may utilize procedure based techniques component based techniques and or object oriented techniques among others. The programs may be written using any combination of text based or graphical programming languages. Also the programs may be written using distributed modules or components so that each program may reside on any combination of computer system computer system and other computer systems connected to the network . Also in various embodiments the client program may interface with the server program through a proxy software component or program.

The one or more instruments may include one or more of a GPIB instrument and associated GPIB interface card a data acquisition board and associated signal conditioning circuitry a VXI instrument a PXI instrument a video device and associated image acquisition card a motion control device and associated motion control interface card and or one or more computer based instrument cards among other types of devices.

The GPIB instrument may be coupled to the computer via the GPIB interface card comprised in the computer . In a similar manner the video device may be coupled to the computer via the image acquisition card and the motion control device may be coupled to the computer through the motion control interface card . The data acquisition board may be coupled to the computer and may interface through signal conditioning circuitry to the UUT. The signal conditioning circuitry preferably comprises an SCXI Signal Conditioning extensions for Instrumentation chassis comprising one or more SCXI modules .

The GPIB card the image acquisition card the motion control interface card and the DAQ card are typically plugged in to an I O slot in the computer such as a PCI bus slot a PC Card slot or an ISA EISA or MicroChannel bus slot provided by the computer . However these cards and are shown external to computer for illustrative purposes.

The VXI chassis or instrument may be coupled to the computer via a VXI bus MXI e.g. MXI 3 bus or other serial or parallel bus provided by the computer . The computer preferably includes VXI interface logic such as a VXI MXI or GPIB interface card not shown which interfaces to the VXI chassis . The PXI chassis or instrument is preferably coupled to the computer through the computer s PCI bus.

A serial instrument not shown may also be coupled to the computer through a serial port such as an RS 232 port USB Universal Serial bus or IEEE 1394 or 1394.2 bus provided by the computer .

In typical instrumentation control systems an instrument will not be present of each interface type and in fact many systems may only have one or more instruments of a single interface type such as only GPIB instruments. The one or more instruments are coupled to the unit under test UUT or process or are coupled to receive field signals typically generated by transducers. The system may be used in a data acquisition and control application in a test and measurement application a process control application a man machine interface application or other types of applications.

The one or more devices may include a data acquisition board and associated signal conditioning circuitry a PXI instrument a video device and associated image acquisition card a motion control device and associated motion control interface card a fieldbus device and associated fieldbus interface card a PLC Programmable Logic Controller a serial instrument and associated serial interface card or a distributed data acquisition system such as the Fieldpoint system available from National Instruments among other types of devices.

The DAQ card the PXI chassis the video device and the image acquisition card are preferably connected to the computer as described above. The serial instrument is coupled to the computer through a serial interface card or through a serial port such as an RS 232 port USB or IEEE 1394 or 1394.2 provided by the computer . The PLC couples to the computer through a serial port Ethernet port or a proprietary interface. The fieldbus interface card is preferably comprised in the computer and interfaces through a fieldbus network to one or more fieldbus devices. Each of the DAQ card the serial card the fieldbus card the image acquisition card and the motion control card are typically plugged in to an I O slot in the computer as described above. However these cards and are shown external to computer for illustrative purposes. In typical industrial automation systems a device will not be present of each interface type and in fact many systems may only have one or more devices of a single interface type such as only PLCs. The devices are coupled to the device or process .

Referring again to the computer system s preferably includes a memory medium s on which one or more computer programs or software components according to one embodiment of the present invention are stored. For example the memory medium may store a GPG program which is executable to receive program information and programmatically generate a graphical program based on the information. The same or a different memory medium may also store a server program with which a client portion of the GPG program interfaces in order to generate the graphical program. The memory medium may also store a programmatically generated graphical program. The memory medium may also store a graphical programming development environment application operable execute or edit the programmatically generated graphical program. It is noted that various of these software programs may be stored on different computer systems as described above with reference to . Also in various embodiments various of the above software programs may be implemented or combined in different ways. For example a graphical programming development environment application may implement the server program with which a client program interfaces to programmatically generate a graphical program.

The term memory medium is intended to include an installation medium e.g. a CD ROM floppy disks or tape device a computer system memory or random access memory such as DRAM SRAM EDO RAM Rambus RAM etc. or a non volatile memory such as a magnetic media e.g. a hard drive or optical storage. The memory medium may comprise other types of memory as well or combinations thereof.

In addition the memory medium may be located in a first computer in which the programs are executed or may be located in a second different computer which connects to the first computer over a network such as the Internet. In the latter instance the second computer may provide the program instructions to the first computer for execution. Also the computer system may take various forms including a personal computer system mainframe computer system workstation network appliance Internet appliance personal digital assistant PDA television system or other device. In general the term computer system can be broadly defined to encompass any device having at least one processor which executes instructions from a memory medium.

In one embodiment the GPG program and or the resulting graphical program that is programmatically generated may be designed for data acquisition generation analysis and or display and for controlling or modeling instrumentation or industrial automation hardware. For example in one embodiment the National Instruments LabVIEW graphical programming development environment application which provides specialized support for developers of instrumentation applications may act as the server program. In this embodiment the client program may be a software program that receives and processes program information and invokes functionality of the LabVIEW graphical programming development environment. The client program may also be a program involved with instrumentation or data acquisition.

However it is noted that the present invention can be used for a plethora of applications and is not limited to instrumentation or industrial automation applications. In other words are exemplary only and graphical programs for any of various types of purposes may be generated by a GPG program designed for any of various types of purposes wherein the programs are stored in and execute on any of various types of systems. Various examples of GPG programs and generated graphical programs are discussed below.

The computer includes at least one central processing unit or CPU which is coupled to a processor or host bus . The CPU may be any of various types including an x86 processor e.g. a Pentium class a PowerPC processor a CPU from the SPARC family of RISC processors as well as others. Main memory is coupled to the host bus by means of memory controller .

The main memory may store computer programs according to one embodiment of the present invention such as described above with reference to . The main memory may also store operating system software as well as other software for operation of the computer system as well known to those skilled in the art. Computer programs stored in the main memory may implement one or more of the methods described below.

The host bus is coupled to an expansion or input output bus by means of a bus controller or bus bridge logic. The expansion bus is preferably the PCI Peripheral Component Interconnect expansion bus although other bus types can be used. The expansion bus includes slots for various devices such as the data acquisition board of and a GPIB interface card which provides a GPIB bus interface to the GPIB instrument of . The computer further comprises a video display subsystem and hard drive coupled to the expansion bus .

As shown a reconfigurable instrument may also be connected to the computer . The reconfigurable instrument may include configurable logic such as a programmable logic device PLD e.g. an FPGA or a processor and memory which may execute a real time operating system. According to one embodiment of the invention a programmatically generated graphical program may be downloaded and executed on the reconfigurable instrument . For example a graphical programming development environment with which the graphical program is associated may provide support for downloading a graphical program for execution on configurable logic in a real time system. In various embodiments the configurable logic may be comprised on an instrument or device connected to the computer through means other than an expansion slot e.g. the instrument or device may be connected via an IEEE 1394 bus USB or other type of port. Also the configurable logic may be comprised on a device such as the data acquisition board or another device shown in .

In prior systems a user interactively or manually creates or edits a graphical program. For example the user may interactively add various objects or icons to a graphical program block diagram connect the objects together etc. In contrast one embodiment of the present invention comprises a system and method for programmatically generating a graphical program or portion of a graphical program without requiring this type of user interaction.

As described below the GPG program may be implemented based on a client server programming model. The client portion may call an application programming interface API provided by the server portion usable for programmatically creating the new graphical program. For example a text based GPG program may include text based code for calling various API functions or methods while a graphical GPG program may include various graphical nodes which are operable to invoke functions of the API. The creation of the GPG program may be performed by a developer wherein the GPG program may then be used as a tool for the programmatic creation of graphical programs by users or other developers.

As shown in step program information for the new graphical program or graphical program portion to be generated may be specified e.g. in response to user input. As described below this program information may comprise any of various types of information and may specify functionality of the new graphical program.

In step the GPG program may be executed. The GPG program may be executed in any type of computer system.

In step the GPG program may receive the program information specifying the functionality for the graphical program or graphical program portion. As described below the GPG program may receive any type of information from any type of source.

In step the GPG program may programmatically generate a graphical program or graphical program portion to implement the functionality specified by the received information. In other words in response to receiving the information in step the GPG program may programmatically generate a new graphical program or program portion based on the information. The graphical program may be programmatically generated with little or no user input received during this creating. In one embodiment the graphical program is programmatically generated with no user input required. In another embodiment the user may be prompted for certain decisions during programmatic generation such as the type of graphical program the look and feel of a user interface for the graphical program the number or degree of comments contained within the graphical program etc.

In response to receiving the information in step the GPG program may process the information in order to determine how to generate the graphical program i.e. in order to determine appropriate graphical source code for the program an appropriate user interface for the program etc. As described below the determination of how to generate the graphical program may depend on a combination of the received information and or the program logic of the GPG program i.e. what the GPG program is operable to do with the received information .

In generating the determined graphical program the GPG program may specify the inclusion of various objects in the new graphical program. For example the new graphical program may have a diagram portion including a plurality of interconnected nodes which visually indicate functionality of the new graphical program. The new graphical program may also have a user interface portion including various user interface objects such as one or more user interface panels having controls for specifying user input to the graphical program and or indicators for displaying output from the graphical program. The GPG program may also specify other aspects of the graphical program such as interconnections between diagram objects connections between diagram objects and user interface objects positions of objects sizes of objects input output terminals or terminal names for diagram objects comments for diagram objects and properties or configuration of objects e.g. configuration of data types parameters etc. among other aspects of the graphical program.

In various embodiments the GPG program may generate a graphical program of any of various types. For example the GPG program may generate the graphical program specifically so that a particular graphical programming development environment is operable to edit and or execute the graphical program.

In one embodiment the GPG program may be a self contained program that includes all executable logic necessary for programmatically generating the new graphical program. However in the preferred embodiment the GPG program utilizes a client server programming model in which the client portion processes the program information and determines the graphical program to be generated based on the program information i.e. determines the function nodes or other objects to be included in the program the interconnections among these nodes objects etc. . The client portion may then call an API provided by the server portion to request the server portion to perform the actual creation of the new graphical program e.g. by creating files and or other data structures representing the new graphical program. The server portion may execute on the same computer system as the client portion or may execute on a different computer system e.g. a different computer system connected by a network. In one embodiment the server portion may be an instance of a graphical programming development environment application which provides an API enabling client programs to programmatically create and or edit graphical programs.

The method of is illustrated and is described above in terms of generating a new graphical program. It is noted that a similar method may be used to modify an existing graphical program e.g. in order to add functionality to the program such as functionality specified by user input received by a user interface wizard. In other words instead of specifying creation of a new graphical program the GPG program may specify the modification of an existing graphical program. When executed the GPG program is then operable to programmatically modify the existing graphical program. For example the GPG program may include a reference to the existing graphical program and may perform various API calls to modify the graphical program e.g. by adding one or more objects to the graphical program changing connections between graphical program objects changing various properties of graphical program objects etc.

It is noted that represents one embodiment of a method for programmatically generating a graphical program and various steps may be added reordered combined omitted modified etc. For example as described above the GPG program may include or may be associated with an application that the user uses to specify the program information. For example such an application may enable the user to specify a state diagram a test executive sequence a prototype etc. on which to base the graphical program. Thus executing the GPG program in step may comprise invoking a routine or program associated with this application e.g. in response to the user selecting a menu option included in the application s user interface. In other embodiments the user may launch the GPG program as an independent application.

In some embodiments the GPG program may include or be coupled with a program or application which a user utilizes to construct or characterize a computational process. In response to the specified computational process the GPG program may programmatically generate a graphical program to implement the computational process.

For example a state diagram editor may be used to construct a state diagram characterizing a computational process e.g. in response to user input. As shown in the GPG program may then receive state diagram information A and use this state diagram information to programmatically generate the graphical program. For example the programmatically generated graphical program may implement functionality specified by the state diagram created by the user.

As another example the GPG program may include or be coupled with a program or application which a user utilizes to construct a prototype e.g. in order to characterize an algorithm at a high level. The constructed prototype may be represented as prototype information B. In this case the GPG program may then programmatically generate a graphical program that implements the prototype based on the prototype information B. For more information on programmatically generating a graphical program to implement a prototype please see U.S. patent application Ser. No. 09 595 003 incorporated by reference above.

As another example the GPG program may include or be coupled with a program or application which a user utilizes to construct a test executive sequence e.g. to perform a series of tests on a unit under test. In this case the GPG program may then programmatically generate a graphical program operable to perform the series of tests when executed based on test executive sequence information C.

In other embodiments the GPG program may be associated with a program or application that directly aids the user in creating a graphical program. For example the GPG program may be associated with a graphical programming development environment application. In this case the GPG program may be operable to receive user input specifying desired functionality indicated as user interface wizard information D in and may automatically i.e. programmatically add a portion of graphical source code to the user s graphical program implementing the specified functionality. For example the user interface wizard information D may be received via one or more wizard graphical user interface GUI panels or dialogs enabling the user to specify various options. Such graphical program code generation wizards may greatly simplify the user s task of implementing various operations. As an example it is often difficult for developers of instrumentation applications to properly implement code to analyze an acquired signal due to the inherent complexity involved. By enabling the developer to specify the desired functionality through a high level user interface the developer can quickly and easily request appropriate graphical source code for implementing the signal analysis to be automatically included in the graphical program. Furthermore since the graphical source code is generated programmatically the code may be optimized resulting in an efficient program and a readable block diagram without unnecessary code.

In other embodiments the GPG program may be operable to automatically translate an existing program into a graphical program. The GPG program may examine the existing program and programmatically generate a graphical program. In one embodiment the GPG program may include or interface with different front end plug in modules wherein each plug in module is operable to analyze a particular type of program e.g. a program written in a particular language or used by a particular development environment and generate existing program information E usable by the GPG program for creating a graphical program that implements functionality of the existing program. The programmatically generated graphical program may perform the same or substantially the same functionally as or a subset of the functionality of the existing program.

In one embodiment the existing program may be a text based program such as a C program. In another embodiment the existing program may itself be a graphical program. For example although graphical programs created using different graphical programming development environments are similar in some respects the graphical programs typically cannot be easily transferred across different graphical programming environments for editing or execution. For example different graphical programming development environments provide different nodes for inclusion in a block diagram store program files in different formats etc. Thus if an existing graphical program associated with one programming environment is desired to be ported to a new programming environment the GPG program may examine the existing graphical program or may examine abstract information specifying the existing graphical program and may programmatically generate a new graphical program associated with the new programming environment.

In another embodiment the GPG program may be operable to automatically generate a graphical program in response to algorithm information F.

In addition to the examples given above a GPG program may receive any other type of information and programmatically generate a graphical program based on the received information.

It is noted that in various embodiments the GPG program may receive the information used in generating the graphical program in any of various ways. The information may be received from the user from another program or from other sources such as a file or database. The information may comprise information of any type including text or binary information structured in any of various ways. The information may be self describing and or the GPG program may include knowledge of how to interpret the information in order to generate the appropriate graphical program.

As an example consider a state diagram editor application usable for constructing a state diagram. In this example the GPG program may be or may be included in the state diagram editor application itself. For example the state diagram editor application may receive user input specifying state diagram information. The state diagram editor application may then programmatically generate a graphical program to implement functionality specified by the state diagram information e.g. in response to the user selecting a menu option to generate the graphical program. In other embodiments the GPG program may be separate from the state diagram editor application. For example when the user selects the menu option to generate the graphical program the state diagram editor application may provide the state diagram information to another application i.e. the GPG program which then generates the graphical program based on this information. In another embodiment a user may invoke the GPG program separately and request the GPG program to generate a graphical program e.g. by specifying a state diagram file. The GPG program may receive the state diagram information in any of various ways formats e.g. as binary data XML data etc.

In most of the examples given above functionality of the graphical program to be generated is specified explicitly by the received information. For example a state diagram user input specified via a wizard interface a prototype a test executive sequence and an existing program all explicitly specify to varying degrees functionality which the graphical program should implement.

It is noted that in other embodiments the received information by itself may not explicitly or inherently specify functionality of the graphical program to be generated. In a case such as this the functionality of the generated graphical program may be determined mainly by the GPG program. Thus one embodiment may include different types of GPG programs wherein each type of GPG program is configured to generate graphical programs of a certain type. For example consider two different GPG programs program A and program B which are both operable to receive numeric data from a database and create a graphical program based on the numeric data. Program A may be operable to create a graphical program which when executed performs one type of operation on the numeric data and program B may be operable to create a graphical program which when executed performs a different type of operation on the numeric data. Thus in these examples the functionality of the graphical program is determined mainly by the GPG program that generates the graphical program.

Thus in various embodiments the functionality of the graphical program may be determined by the received program information and or the GPG program. In some cases the functionality may be specified almost entirely by the received information. For example in a case where the GPG program programmatically translates an existing program to a new graphical program the functionality of the new graphical program may be specified entirely by the existing program. In other cases the received information and the GPG program may each determine a portion of the functionality. For example in a case where the GPG program generates a graphical program to implement a test executive sequence the test executive sequence information may determine the body of the program which includes the code for executing the tests but the GPG program may be operable to add additional functionality to the graphical program e.g. by adding code operable to prompt the user for a log file and save test results to the log file code to display a user interface indicating the current unit under test and the current test being performed etc.

In a typical case the implementation of the source code for the graphical program is determined mainly or entirely by the GPG program although the received information may influence the manner in which the GPG program generates the code or the GPG program may receive separate information influencing the code generation. For example consider a GPG program operable to translate an existing graphical program to a new graphical program e.g. in order to port the existing graphical program to a new programming environment. In one embodiment the GPG program may be operable to generate the new graphical program in such a way as to match the existing graphical program as closely as possible in appearance. In other words the new graphical program may be generated so that when the user sees the block diagram of the new graphical program the block diagram appears substantially the same as the block diagram of the existing graphical program e.g. in terms of the number of block diagram nodes the layout and interconnections among the block diagram nodes etc. In another embodiment the GPG program may be operable to implement the source code for the new graphical program differently e.g. by optimizing the code where possible. In this example the functionality of the generated graphical program may be the same in either case but the graphical program may be implemented in different ways.

The GPG program may also receive input specifying how to implement the graphical program. For example in the case above the user may specify whether or not to perform optimizations when translating an existing graphical program. For example the new programming environment may support downloading the generated graphical program to a hardware device for execution. If the user desires to download the generated graphical program to a hardware device e.g. for use in a real time application then it may be important to optimize the new program. Otherwise it may be more important to implement the generated graphical program similarly as the existing graphical program is implemented.

In one embodiment the GPG program may provide extended support for specifying graphical program code implementation beyond the ability to specify simple options. For example the GPG program may support plug ins specifying code generation information for various cases. Referring again to the program translation example above each plug in may specify how to generate code intended for execution on a particular hardware device. For example if the generated program is to be run on an FPGA the generation of the code may be optimized depending on the number of gates available on that particular FPGA.

In various embodiments an association between a generated graphical program and the received program information used in generating the graphical program may be maintained. For example after the graphical program has been generated this association may enable a user to recall the program information or return to an application from which the program information originates e.g. in order to view or edit the program information. For example consider a prototyping environment application which enables a user to develop a prototype characterizing an algorithm. The prototyping environment application may programmatically generate a graphical program implementing the developed prototype. The user may then execute the graphical program and if a problem with the program is discovered the association may enable the user to return to the prototyping environment application in order to view or modify the prototype used to generate the program. The graphical program may then be programmatically modified or re generated accordingly.

In one embodiment a generated graphical program may be locked requiring the user to explicitly unlock the program before the program can be modified within the graphical programming environment. Locking the graphical program may facilitate the retrieval or recreation of the program information that was used to generate the graphical program.

In various embodiments the GPG program may be operable to generate any of various types of graphical programs. For example as discussed above a generated graphical program may be targeted toward a particular graphical programming development environment application e.g. to utilize proprietary features or to create files that are formatted in a manner expected by the graphical programming development environment. Examples of graphical programming development environments include LabVIEW BridgeVIEW DasyLab and DiaDem from National Instruments VEE from Hewlett Packard Simulink from The MathWorks Softwire from Measurement Computing Inc. Sanscript from Northwoods Software WiT from Coreco and Vision Program Manager from PPT Vision among others.

In various embodiments the graphical program may be generated using any of various methods or techniques. Generating the graphical program may comprise generating one or more files defining the graphical program. When a user interactively develops a graphical program from within a graphical programming environment the graphical programming environment may create one or more program files. For example the program files may specify information such as a set of nodes that the graphical program uses interconnections among these nodes programmatic structures such as loops etc. In other cases the program files may store various data structures e.g. in binary form which the graphical programming environment uses to directly represent the graphical program. Thus in programmatically generating the graphical program the GPG program may programmatically generate one or more files representing the graphical program wherein these files are structured or formatted appropriately for a particular graphical programming environment.

In various cases a graphical program generated by a GPG program in response to program information may be a fully working program. Thus the user may load the generated graphical program into the graphical programming environment execute the program etc. In other cases the generated graphical program may not be a complete program. As an example if an existing program is translated to a graphical program it may not be possible to translate the entire program. For example the existing program may utilize functions which do not exist in the graphical programming environment to which the program is to be ported. However the GPG program may still create a partial graphical program making it relatively easy for the user to complete the graphical program. In still other cases it may be desirable to programmatically generate only a graphical code portion e.g. as discussed above in the case of user interface wizard tools that aid the user in program development.

As discussed above in one embodiment a graphical program or portion of a graphical program may be programmatically generated in response to program information received as user input. is a flowchart diagram illustrating one embodiment of a method for programmatically generating a graphical program in response to user input received via a graphical user interface GUI . The GUI may be any type of GUI and the user input may be received via the GUI in any of various ways. In one embodiment the GUI may comprise one or more GUI input panels. The GUI input panels may take any of various forms including a dialog box or window and may include any of various means for receiving user input such as menus GUI input controls such as text boxes check boxes list controls etc. The GUI input panels may comprise textual and or graphical information and may be able to receive textual and or graphical user input.

In step the GUI may be displayed e.g. one or more graphical user interface GUI input panels may be displayed wherein the GUI input panels comprise information useable in guiding a user in creation of a program. For example a GPG program may include various code generation wizards i.e. tools that enable a user to specify desired program functionality at a high level via GUI input panels. The GUI input panels may be displayed in response to user input indicating a desire to specify program functionality. For example the GPG program may provide various menu options for invoking the GUI input panels. As another example the user may first display a node in a graphical program and may then request to configure functionality for the node and GUI input panels for configuring functionality of the node may be displayed in response to this request. Exemplary GUI input panels are described below.

In step user input may be received via the one or more GUI input panels wherein the user input specifies desired program functionality. For example as described above the GUI input panels may comprise various GUI input controls such as text boxes check boxes list controls etc. and the user may configure these GUI input controls to indicate the desired program functionality. As an example consider a case where the GUI input panels enable the user to specify program functionality for generating waveform data. In this example the GUI input panel may include a list GUI control for choosing whether to generate the data as a sine wave square wave etc. a numeric GUI control for specifying the desired amplitude for the wave a numeric GUI control for specifying the desired frequency for the wave etc. Thus in this example the user input received may specify the desired waveform type the desired amplitude and frequency etc.

In step a graphical program or graphical program portion to implement the specified desired functionality may be programmatically generated in response to the received user input. Step may comprise programmatically including graphical source code in the graphical program. For example the programmatically generated graphical source code may comprise a plurality of nodes that are interconnected in one or more of a data flow control flow and or execution flow format so as to implement the specified functionality. The nodes may have input output terminals terminal names comments or other aspects that are programmatically generated. Thus the GPG program may be operable to generate various graphical programs or portions depending on the received user input. For example in the waveform generation example discussed above the GPG program may include a sine wave node in the graphical program if the user specifies to generate sine wave data in step or may include a square wave node in the graphical program if the user specifies to generate square wave data.

It is noted that in steps and a plurality of GUI input panels may be displayed and user input may be received from each of these panels. For example a first panel may be displayed on the display wherein the first panel includes one or more first fields adapted to receive first user input specifying first functionality of the graphical program. User input specifying first functionality of the graphical program may be received via the first panel. A second panel may then be displayed for receiving second user input specifying second functionality of the graphical program. In one embodiment the second panel that is displayed may be based on the first user in put. In other words in one embodiment the GUI input panels may be displayed in a wizard based manner that guides the user in specifying the desired functionality.

In step a node may be displayed in a graphical program wherein the node initially has no functionality or has default functionality. As described below the node may be able to take on different functionality in the graphical program depending on configuration user input received. The node may be generally related to a particular functional realm such as data acquisition signal analysis data display network communications etc. However until configuration user input is received for the node as described below the exact behavior of the node within the graphical program may be undefined.

In step user input requesting to specify desired functionality or configuration information for the node may be received. For example the user may double click on the node execute a menu option for configuring the node or perform this request in any of various other ways.

In step one or more GUI input panels associated with the node may be displayed in response to the user request received in step wherein the GUI input panels comprise information useable in guiding the user to specify functionality for the node. In step user input specifying desired functionality for the node may be received via the one or more GUI input panels. In other words the node may be configured to perform a variety of functions within the program depending on this received user input. As noted above the node may be generally related to a particular functional realm such as data acquisition signal analysis data display etc. Thus the GUI input panels displayed may comprise information related to the particular functional realm. For example for a node related to network communications the GUI input panel may comprise GUI controls for configuring the node to specify a data source or target to which to connect specify a connection protocol etc.

In step graphical source code may be programmatically generated based on the desired functionality specified in step . This graphical source code may be associated with the node in the graphical program such that the node is operable to implement the desired functionality specified in step when the graphical program is executed. The programmatically generated graphical source code may comprise graphical source code similar to that which a user could create manually in a graphical programming development environment e.g. by including various function nodes or other types of nodes in the graphical program and connecting the nodes in one or more of a data flow control flow and or execution flow format.

The programmatically generated graphical source code may be associated with the node in various ways. In one embodiment the graphical source code programmatically generated for the node may replace the node in the graphical program so that the node is no longer visible in the graphical program. However in the preferred embodiment the graphical program may still appear the same even after the graphical source code has been programmatically generated in association with the node. That is in response to the user input specifying desired functionality for the node the graphical source code implementing the specified functionality may be generated behind the node in a hierarchical fashion such that the node still appears in the graphical program. In this instance the graphical source code may be programmatically created as a sub program or sub VI of the graphical program wherein the node represents the sub program. Generating the portion of graphical source code behind the node in this way may help to keep the graphical program more readable.

The user may choose to view the graphical source code programmatically generated behind the node if desired. For example in response to using a menu option or double clicking on the node to view the source code generated behind the node the programmatically generated graphical source code may be displayed. This may enable the user to modify the programmatically generated source code if desired. However in one embodiment the user may be prevented from viewing and or editing the programmatically generated graphical source code. For example for a Lite or Express version of a graphical programming development environment product it may be desirable to prevent users from viewing the programmatically generated graphical source code. This may force the user to control the functionality of the node through the GUI input panel s for the node rather than directly modifying the graphical source code. For example this may help to prevent novice users from becoming confused by seeing more complex graphical source code.

As noted above in one embodiment when the node is initially displayed in the program the node may have no functionality. That is the node may not initially be operable to perform any function when the graphical program is executed. A traditional function node available for inclusion in a graphical program typically has associated program instructions that are executed when the node is executed in the program. In this case however the node displayed in step may not initially have such associated program instructions. Instead the programmatically generated graphical source code that is associated with the node in step may define the program instructions to be executed for the node. For example these program instructions may be created from the programmatically generated graphical source code when the graphical program is compiled or interpreted and these program instructions may be executed when the node is executed in the program.

Also as noted above in one embodiment when the node is initially displayed in the program the node may have default functionality. That is the node may initially be operable to perform a default function when the graphical program is executed. Thus the node may have associated program instructions to be executed when the node is executed in the program or there may be default graphical source code associated with the node when the node is initially included in the graphical program. In this case the programmatically generated graphical source code that is associated with the node in step may replace the default functionality for the node.

As described above a node may be configured to perform a plurality of operations depending on user input specifying configuration information for the node. The configuration information may be received via one or more GUI input panels and may specify one or more desired operations for the node from the plurality of possible operations. However since the graphical source code associated with the node is generated programmatically a minimal amount of graphical source code may be generated i.e. only graphical source code necessary to implement the one or more desired operations may be generated. Thus source code corresponding to operations from the plurality of operations that are not among the one or more desired operations may not be included in the graphical program.

Associating a minimal amount of source code with a graphical program node operable to perform a plurality of operations may have several advantages. For example by only including graphical source code in the program that is actually used the program may be significantly more readable. Also by not including unnecessary code the size of the program can be reduced which may be important for systems with limited amounts of memory. Also if the program is to be implemented in a hardware device e.g. in an FPGA device then it may be especially important to reduce the program size so that the program may be implemented with a limited amount of hardware resources available on the device.

As described above with reference to in one embodiment the user may first display a node in a graphical program and may then utilize one or more GUI input panels to configure program functionality for the node. illustrates an exemplary GUI input panel for configuring a waveform generator node. In response to the user specifying different settings for the GUI controls on the GUI input panel different graphical source code portions may be programmatically generated for the waveform generator node.

In response to the user input received via the GUI input panel of different portions of graphical source code may be programmatically generated in the graphical program. If the user chooses the multiply operation then the graphical source code of may be programmatically generated this portion of graphical source code includes a multiplication function node. If the user chooses the add operation then the graphical source code of may be programmatically generated this portion of graphical source code includes an addition function node. illustrate GUI panels for the graphical program that indicate the execution results of the graphical source code of respectively.

The graphical source code of illustrates a multiplication node and the graphical source code of illustrates an addition node. When the user first includes the Simple Math node in the graphical program the Simple Math node may not be associated with either one of the multiplication or addition node or may be associated with a default one of these nodes. In response to the user operating the GUI input panel of the GPG program which in this example may be a graphical programming development environment application may programmatically generate either the multiplication or addition node such that the programmatically generated node is associated with the Simple Math node and in effect replaces the Simple Math node during program execution. However as described above the program may still appear to the user as shown in in which the Simple Math node is shown. That is the multiplication or addition node may be generated behind the Simple Math node. The user may then request to view the graphical source code generated behind the Simple Math node if desired.

In step user input requesting to change functionality of the node may be received. For example this input may be received similarly as in step of e.g. by the user double clicking on the node executing a menu option for configuring the node etc.

In step the one or more GUI input panels associated with the node displayed in step may be re displayed in response to the user request received in step . As described above the GUI input panel s may comprise information useable in guiding the user to specify functionality for the node. In this case the GUI input panels may be used to specify additional or changed functionality for the node.

In step user input specifying new functionality for the node may be received via the one or more GUI input panels. For example referring again to the waveform generator node example discussed above if the node was originally configured to generate sine wave data the GUI input panel s may be used to reconfigure the node to generate square wave data.

In step the graphical source code that was previously generated in association with the node may be replaced with new graphical source code that implements the specified new functionality for the node or may be modified to implement the specified new functionality.

It is noted that although the method of is discussed in terms of replacing graphical source code generated in association with a particular node a similar method may be employed to replace a graphical program portion generated in accordance with the more general case of the method of .

In many scientific and engineering domains in which computer programs are utilized problems may be classified into certain general groups. Thus a particular computer program is often implemented as a specific variation of a more generic program process. Each scientific or engineering domain may have its own paradigmatic program processes.

For example within the test and measurement and industrial automation fields program processes often involve receiving input from and or sending output to hardware devices. One typical program process may be referred to as Acquire Process Display . In other words a program based on this program process may acquire data from a device or UUT process the data and display the data. Another typical program process may be referred to as Output Wait Acquire Process Display . In other words a program based on this program process may output data to a device e.g. a control signal wait for a specified period of time e.g. while the device responds to the control signal acquire data from the device e.g. data generated in response to the control signal process the acquired data and display the data.

Providing a library of pre defined program processes on which to base a program may help the user in conceptualizing the problem to be solved and may help the user to implement the desired program more rapidly. However for each particular program that is based on one of these general program processes the program typically needs to be customized to perform the desired task. For example for a program based on the Output Wait Acquire Process Display program process described above the step of outputting the data to the device may need to be customized to specify the data to be outputted the device to which to send the data etc. The other steps may need to be similarly customized.

In each window the available program processes are listed in a list box on the left side of the window. Each program process has a corresponding graphical program template wherein each graphical program template comprises a plurality of interconnected nodes for implementing the program process. As the user selects a program process in the list box on the left the corresponding graphical program template is shown on the right side of the window.

In step user input selecting a desired program process from the plurality of available program processes may be received. For example in the windows described above the user may select the desired program process in the list box on the left and may then press the Use Template button.

In step the graphical program template corresponding to the selected program process may be programmatically included in the graphical program. In other words the interconnected nodes of the template are programmatically included in the graphical program.

The user may then customize the graphical program to perform the exact process desired. In one embodiment one or more of the nodes included in the template may be customized according to the method of . In other words the node s may initially have no definite functionality or may have default functionality and one or more GUI panels may be displayed to receive user input specifying desired functionality for the node s . Graphical source code to implement the specified functionality may then be programmatically generated and associated with the node s as described above e.g. as sub programs.

As graphical programming development environments have matured and grown more complex graphical source code has become more feature packed and in some cases this has made the graphical programs harder to understand at a glance. One area in which readability problems have occurred is in the area of input output terminals for graphical program nodes. An input terminal for a node comprises a connection point where the node can receive data from a data source in the graphical program e.g. from an output terminal of another node . An output terminal for a node comprises a connection point where the node can provide data to a data target in the graphical program e.g. to an input terminal of another node .

For some graphical program nodes the number of input output terminals has become very large so that it can be confusing to the user. As a result the purpose of each of the various terminals is not always apparent to the user. Also it is often not clear to the user what combination of terminals needs to be connected to other elements in the program to accomplish the desired task. In many cases not all of the input output terminals need to be used. For example the functional behavior of some nodes can be controlled to a great degree depending on which of a subset of input output terminals are connected to data sources targets.

In step a node may be displayed in a graphical program e.g. in response to user input requesting inclusion of the node in the graphical program. For example the user may select the node from a GUI palette or menu. In one embodiment when the node is initially displayed no input output terminals may appear on the node or a default set of input output terminals may appear.

In step one or more GUI input panels may be displayed in response to user input requesting to provide configuration information for the node. For example the GUI input panel s may enable the user to specify desired functionality for the node similarly as described above. In step user input specifying functionality or other configuration information for the node may be received via the GUI input panel s .

In step input and or output terminals for the node may be programmatically created and displayed on the node based on the configuration information received in step . The one or more input output terminals that are displayed on the node may be a subset of the possible input output terminals i.e. a subset that facilitates configuration of the node to accomplish the desired functionality specified in step . For example it may be determined that one or more of the possible input output terminals for the node are not relevant depending on the configuration information specified by the user. In this case the irrelevant terminal s may not be displayed on the node only the terminals needed for accomplishing the desired functionality may be displayed.

In another embodiment one or more input output terminals that are relevant may not be displayed simply to make the graphical program more readable. For example the method may only display input output terminals that facilitate an understanding of the functionality performed by the node and may hide other terminals such as terminals for propagating state or error information.

In step the programmatically created input output terminals for the node may be connected to data sources targets in the graphical program in response to user input. Since only relevant terminals may be displayed the user may have a much better understanding of how to connect the node to other elements of the program. The resulting graphical program may be significantly more understandable.

It is noted that in some graphical programming development environments input output terminals for a node are not explicitly displayed at all times. For example the terminals may not appear until the user moves the mouse cursor over the node. In this instance displaying the programmatically created input output terminals in step may involve causing the terminals to appear when the user moves the mouse cursor over the node or performs another action causing the terminals to appear.

A drawback of the approach of not displaying input output terminals at all times is that the input output terminals for the node are not clearly labeled. For example illustrates a prior art graphical program including various nodes with wires leading to input terminals of the nodes or leading from output terminals of the nodes. However it is not clear what the purposes of the input output terminals are. For example for a given wire connected to an input terminal of a node it is difficult to tell at a glance what data that wire provides to the input terminal.

In one embodiment of step the programmatically created input output terminals for the node may be displayed in such a way as to solve this problem. The input output terminals may be displayed as labels under the node as shown in the graphical programs of . These labels clearly indicate the purpose of the input output terminals. To connect an input output terminal to a data source target the appropriate label may be wired to the data source target as shown in . It is noted that in other embodiments the labels may be placed in other locations besides underneath the nodes as desired.

It is noted that this method of displaying input output terminals for nodes in a graphical program as labels under the nodes may be used regardless of whether the input output terminals are programmatically created based on node configuration information as described above. For example some graphical programming development environments may not support the above described method of programmatically creating and displaying a relevant subset of input output terminals for a node but may always display all of the possible terminals for the node. In this instance the terminals may still be displayed as labels under the nodes.

Another aspect related to understanding the function of a node pertains to the actual names of the input output terminals. In the prior art the user has not been able to change default terminal names. It would be desirable to enable the user to change default terminal names to names that are more meaningful to the user or to the particular program. is a flowchart diagram illustrating one embodiment of a method for specifying an alias for input output terminals of a node.

In step a node may be displayed in a graphical program e.g. in response to user input requesting inclusion of the node in the graphical program. For example the user may select the node from a GUI palette or menu. The node may initially have input and or output terminals with default names.

In step one or more GUI input panels may be displayed in response to user input requesting to provide configuration information for the node. For example the GUI input panel s may enable the user to specify desired functionality for the node similarly as described above or may enable the user to provide any other type of configuration information for the node. In particular the GUI input panel s may enable the user to specify an alias for one or more input and or output terminals of the node.

In step user input specifying configuration information for the node may be received via the GUI input panel s wherein the user input includes input specifying an alias for at least one input terminal or output terminal of the node. As an example for a node that includes an input terminal with a default name of input signal the user may choose to specify an alias of voltage which may be a more meaningful name for the input terminal of the node in the user s particular case.

In step for each input terminal or output terminal for which an alias was specified the aliases may be displayed in the graphical program. This may involve replacing default terminal names. In one embodiment the aliases may be displayed as labels under the nodes similarly as shown in . The user may then connect the input terminals and output terminals to data sources targets in the graphical program as described above. The method of may be combined with other methods described above. For example with respect to the method of when input output terminals for a node are programmatically created one or more of the terminals may be indicated by a specified alias.

One common task that often needs to be performed in a program is to perform various types of numerical functions on a collection of data values. For example the program may implement a loop in which a data value is received in each iteration of the loop. The program may keep track of the data values that have been received and may numerically analyze the data values e.g. to compute the average value the sum of the values the maximum value or any other type of analysis or numerical function.

While simple in concept in the prior art this type of behavior has been difficult to implement in a graphical program in part because it involves keeping track of previously received values. illustrates a node referred to herein as a collector node which simplifies these types of common programming tasks. The collector node is preferably a primitive node provided by a graphical programming development environment for inclusion in a graphical program. The collector node may be operable to maintain state information regarding received data values and may use the state information to determine a data collection on which to perform a numerical function. The data collection comprises at least a subset of data values that have been received by the collector node. As described below the user may be able to configure the collector mode to determine the data collection in various ways. Exemplary graphical programs that use collector nodes are discussed below. The collector node and these example graphical programs also illustrate exemplary applications of various embodiments of the methods described above.

If Sliding Block is chosen then the data collection becomes valid once the specified number of data values has been received by the collector node. These data values may then be analyzed. From that point on each time a new data value is received the oldest data value is removed from the data collection so that the number of data values under analysis remains constant.

If Fixed Block is chosen then the data collection becomes valid once the specified number of data values has been received by the collector node. These data values may then be analyzed. When a new data value is then received the old data collection is discarded and data value collection restarts until the specified number of data values has again been received.

If Always is chosen then all data values are tracked and the analysis is performed on all of these data values regardless of the number of data values received.

Referring now to a collector node is shown which includes output terminals labeled as Average Sum and Waveform Output . The Average output terminal outputs the average value of the data values currently being analyzed e.g. according to the Collection Mode and Size of Collection criteria specified in the GUI input panel of . The Sum output terminal outputs the sum of the data values currently being analyzed. The Waveform Output output terminal outputs the data values themselves as they are received.

In various embodiments the collector node shown in may be configured in any of various ways to result in the collector node shown in with the displayed Average Sum and Waveform Output output terminals. In one embodiment the user may click on the collector node to view a list of available output terminals and may then select the ones desired to use in the program and the selected output terminals may be displayed in response. In another embodiment the desired terminals may be specified through a GUI input panel as described above with reference to the method of . For example the GUI input panel of may be extended to enable the user to specify the outputs of interest.

It is noted that the output terminals shown in are exemplary only and in various embodiments the collector node may implement any of various types of numerical or statistical functions that can be performed on a collection of data values such as numerical average sum maximum value minimum value etc. In one embodiment source code may be programmatically generated in association with the collector node such that only a minimal amount of code is included in the program similarly as described above. For example if the user chooses to use an Average output terminal but not a Sum output terminal then during execution of the graphical program the collector node may be operable to maintain a running average of the data values but not a running sum. If on the other hand the user also chooses to use the Sum output terminal then code for maintaining a running sum of the data values may also be associated with the collector node.

Referring again to the GUI input panel of there is also a field labeled Name of the Collection . This field enables the user to specify an alias for the output terminal that outputs the actual data values i.e. the output terminal labeled Waveform Output in . There is also a field labeled Name of Collector Block that enables the user to change the name of the collector node as it appears in the graphical program e.g. to a meaningful name for the particular program. There is also a checkbox enabling the user to select an option titled Automatically take name of collector function . If this checkbox is checked then the collector node s label in the block diagram will be automatically set as a result of using the GUI input panel. For example if the user selects the Sliding Block collection mode then the collector node s name would be automatically set to Sliding Block . If the user unchecks this checkbox then the user can specify another name for the collector node s label.

There is also a checkbox labeled Create Indicator . If the user checks this checkbox a user interface indicator for displaying the data values received may be automatically created on a user interface panel for the graphical program. A user interface node corresponding to this indicator may be programmatically created in the block diagram of the graphical program and may be wired to the collector node to receive the data values for display.

The above discussed examples of programmatically generating a graphical program or graphical program portion may be implemented in any of various ways. For more information on one embodiment of a system and method for programmatically generating a graphical program please refer to the above incorporated patent application titled System and Method for Programmatically Generating a Graphical Program in Response to Program Information .

Although the system and method of the present invention has been described in connection with the preferred embodiment it is not intended to be limited to the specific form set forth herein but on the contrary it is intended to cover such alternatives modifications and equivalents as can be reasonably included within the spirit and scope of the invention as defined by the appended claims.

