---

title: Generation of managed assemblies for networks
abstract: A network toolset enables developers to automatically generate a C header file and underlying signal software, as well as automatically generate a managed code assembly from a network description. The managed code assembly can be generated in a binary format and may include sufficient metadata to support extended functionalities for a network. The managed code assembly can be relatively easily integrated with an existing image (e.g., machine code for a network device) without any compilation required. A software development kit can also be generated to help programmers manage the generated assemblies.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09128727&OS=09128727&RS=09128727
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09128727
owner_city: Redmond
owner_country: US
publication_date: 20060809
---
Control area networks CANs are peer to peer networks that are typically used in vehicles. The CANs allow communication between electronic control units ECUs that are distributed across the network. The majority of automotive CAN networks are designed using tools that generate a set of data files that describe the interaction on this network. The most common format for this data is a .dbc file. While tools exist today that will generate C code for application developers and the underlying signal software that access this network they lack some core functionality.

For example the types of signals and protocols used by CANs are predefined by C language header files. The C language header files can usually only be accessed by software developers having access to proprietary formats and require a programmer s input to manage and expose. Additionally the .dbc file is a proprietary data format file that only a relatively small number of toolsets support. Existing systems typically generate information from the .dbc which is statically compiled into system components. Existing systems also have little or no ability to support additional metadata for the information contained within the .dbc file.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the detailed description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended as an aid in determining the scope of the claimed subject matter.

The present disclosure is directed to architecture for a toolset that enables developers to automatically generate not only a C header file and underlying signal software but that also automatically generates a managed code assembly. The managed code assembly is generated in a binary format and includes sufficient metadata to support extended functionalities. The managed code assembly can be easily modified and or the CAN database changed without the need for recompilation of modules that depend on this assembly. This support enables developers new to CAN to relatively easily develop software to operate on the CAN vehicle network with the confidence that future changes to this module will not break their code.

In addition to generation of a managed code assembly the developer also has the option of creating an additional metadata file e.g. in XML that provides additional enhancements to all the software generated managed code assembly. These enhancements provided by meta data can include security permissions for specific APIs application programming interfaces in the generated assembly and usage hints that allow optimization of system performance and network bandwidth based on this usage. Metadata can further support network filtering information that is used to generate low level filter software that prevents applications that do not have unfettered systems access from accessing this data. Moreover metadata can allow improved friendly naming for code generation to better support software developers.

With this toolset architecture developers can quickly generate a fully operational managed signal API software stack from their .dbc file. The developers can also use the toolset solution to make changes to the generated code assembly such that they can relatively easily create what they desire for their final shipping image.

These and other features and advantages will be apparent from a reading of the following detailed description and a review of the associated drawings. It is to be understood that both the foregoing general description and the following detailed description are explanatory only and are not restrictive. Among other things the various embodiments described herein may be embodied as methods devices or a combination thereof. Likewise the various embodiments may take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment combining software and hardware aspects. Furthermore various operating systems and drivers can be used to provide a system providing dynamic feedback flash management. Likewise any memory storage device that uses stored charge which is typically subject to leakage can benefit from this disclosure. The disclosure herein is therefore not to be taken in a limiting sense.

As briefly described above embodiments are directed to generation of managed code assemblies for network customization. With reference to one example system for managed code assemblies includes a computing device such as computing device . Computing device may be configured as a client a server a mobile device or any other computing device that interacts with data in a network based collaboration system. In a very basic configuration computing device typically includes at least one processing unit and system memory . Depending on the exact configuration and type of computing device system memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. System memory typically includes an operating system one or more applications and may include program data . Generation of managed code assemblies described below with reference to can be implemented using system memory .

Computing device may have additional features or functionality. For example computing device may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included.

Computing device also contains communication connections that allow the device to communicate with other computing devices such as over a network. Networks include local area networks and wide area networks as well as other large scale networks including but not limited to intranets and extranets. Communication connection is one example of communication media. Communication media may typically be embodied by computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.

The output file is typically a markup language file which allows greater separation of the network design from the design tool. The tool separation allows for a much easier adaptation to different formats and more flexibility when working with the CAN database for example because during operation support can be easily provided for any CAN database description format that can be converted to XML in a relatively small amount of time.

In operation the markup language file produced in operation can optionally be preprocessed to include metadata. The metadata allows additional information to be added from a source other than the .dbc file . The metadata can be used to add enhancements such as security permissions improved performance and network utilization low level filtering and an improved developer experience.

Since all relevant information is usually kept in the XML representation the addition of extended metadata can be provided in a variety of ways. The metadata can be provided by having a separate application applying parameters by editing the readable XML format by hand and or by writing a XLST transformation that automatically modifies the attributes. Any combination of the above can also be used.

In operation a managed code assembly is generated from a preprocessed markup language file. The managed code assembly includes a managed API that can include for example auto completion for convenience of network designers. Additionally the markup language input file is typically loaded at runtime which allows changes to be made that do not require recompilation to handle changes of the .dbc file. To enhance compatibility with a precompiled application a versioning system can be used.

The intermediate XML file may also be used to generate other useful data that can be used by the system. The other useful data can allow for signal level interaction such as signal filter lists native code header generation documentation and the like. These files are further described below with reference to .

An input file can be written in an arbitrary format when the parser is capable of understanding the input format. For example input file is written in an arbitrary format and can be translated by markup language file generator into a markup language output file . Input file represents a file that is written in an markup language that is capable of producing a markup language output file. Input file can be parsed by markup language file generator to produce a markup language output file that can be in a different format or even the same format as input file .

System further comprises an optional metadata preprocessor . Metadata preprocessor transforms markup language file using for example direct operator input not shown settings files that can include settings for various ECUs and extensible stylesheet language transformations via XSLT . Metadata preprocessor produces markup language file that can be the same as or different from markup language file .

The general function for the metadata to be added by metadata preprocessor includes iterating over the message map for each of the signals in each message and applying general rules and applying specific changes to certain messages and or signals. The general rules may include for example converting a custom attribute GenMsgCycleTime to an attribute Period and setting correct timeout for received messages. The specific changes include adding support and events for specific CAN signals such as button presses to be translated to managed code events and support for multi frame message requirements that are not provided in the .dbc file for the CAN database.

System further comprises an object generator . Object generator automatically generates managed CAN object definitions and the related properties using the extended XML file data. Object generator has multiple outputs including native code header generation filter lists for signals message maps managed assembly generation and configuration settings in the form of registry files. Convergence image is typically an optimized binary representation of the code to be ported to an ECU. Convergence system development kit can be used for writing applications and managing code for any part of the system. An assembly versioning scheme allows for certain changes to be made without forcing all applications for a target CAN system to be recompiled.

The filter list and message maps can be stored in CAN configuration file . CAN configuration file is used to enforce communication rules in the CAN interaction layers. As described below message map changes are handled by system in such a way that allows un recompiled applications to successfully connect with an updated interaction layer IL configuration.

Updating message maps without requiring recompilation of applications is possible when certain kinds of changes are made such as when adding new message and or new signals. Compilation is also not needed when changing signal properties like OnEvent or Initial value because these properties are typically only evaluated by the IL and when changing message properties such as the timing and transmission type.

Other changes can be made to the message map that would usually require existing applications to be recompiled for the applications to interact correctly with the IL configuration. The other changes include deleting an existing message and or signal renaming messages and or signals changing the DLC data link control information for a message and changing the position and or size of a signal. Additionally changes made to properties used by a wrapper to present the signal to an application typically require a recompile.

While the above changes that would normally be identified by the tool generating the compatible message map changes such as semantic changes of a message and or signal may require human intervention to properly identify. The programmer can instruct the tool to change the version information so an existing application does not incorrectly access a signal or message that has a changed meaning.

The version information typically comprises a major version change and a minor version change. The minor version is incremented whenever there were changes that still maintain compatibility with the predecessor version. To minimize the impact on existing applications the version information is typically wrapped within the GUID that has last been used to validate the matching of message maps. There is also usually no need to expose the structure to applications because applications normally do not have a need to access the version information directly.

The above specification examples and data provide a complete description of the manufacture and use of embodiments of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention the invention resides in the claims hereinafter appended.

