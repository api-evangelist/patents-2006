---

title: Method and apparatus to ensure consistency of depth values computed in different sections of a graphics processor
abstract: At least two different processing sections in a graphics processors compute Z coordinates for a sample location from a compressed Z representation. The processors are designed to ensure that Z coordinates computed in any unit in the processor are identical. In one embodiment, the respective arithmetic circuits included in each processing section that computes Z coordinates are “bit-identical,” meaning that, for any input planar Z representation and coordinates, the output Z coordinates produced by the circuits are identical to each other.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07659893&OS=07659893&RS=07659893
owner: NVIDIA Corporation
number: 07659893
owner_city: Santa Clara
owner_country: US
publication_date: 20061002
---
The present disclosure is related to commonly assigned U.S. patent application Ser. No. 10 878 460 filed Jun. 28 2004 titled Planar Z Representation for Z Compression now U.S. Pat. No. 7 382 368 and to commonly assigned co pending U.S. patent application Ser. No. 10 970 101 filed Oct. 20 2004 titled Multipurpose Arithmetic Functional Unit. The respective disclosures of these applications are incorporated herein by reference for all purposes.

The present invention relates in general to graphics processing devices and methods and in particular to a method and apparatus to ensure consistency of depth values computed in different sections of a graphics processor.

Graphics processors are used to render images in many computer systems. In a typical rendering process the graphics processor receives primitives e.g. points lines and or triangles representing objects in a scene. In accordance with instructions provided by an application program the graphics processor transforms each primitive to a viewing space then determines which pixels or samples where there may be one or more samples per pixel of the image are covered by the primitive. For each pixel that is covered the graphics processor computes a color and depth or z value for the fragment of the primitive that covers or partially covers the pixel. The color and depth values computed for each fragment are provided to a raster operations ROP unit which builds up the rendered image by storing per pixel or per sample color and depth information in a frame buffer. As the ROP unit receives new data for newly rendered fragments it compares each new depth value for a pixel to a previous depth value stored in the frame buffer for that pixel. Based on the comparison the ROP unit determines whether to write the new data to the frame buffer. If new data is to be written the ROP unit updates the depth and color values in the frame buffer based on the new data.

In the course of generating an image the ROP unit typically generates a large number of requests to transfer data to and from the frame buffer. Images may include a large number of fragments and each time the ROP unit receives new fragment data it reads one or more old pixels at least the Z information from the frame buffer. For each pixel that is to be changed the ROP unit also reads the current color from the frame buffer. Modified colors and Z values are then written back to the frame buffer. In some graphics systems bandwidth between the ROP unit and the frame buffer can become a bottleneck limiting system performance.

In some graphics processors demand for bandwidth between the ROP unit and the frame buffer is reduced by storing Z data in the frame buffer in a compressed form. The ROP unit compresses the Z data prior to writing it to the frame buffer and decompresses the Z data after reading it from the frame buffer in order to perform Z comparisons.

A related patent application above referenced application Ser. No. 10 878 460 describes a technique for compressing Z data by storing a planar representation of the Z coordinate for a fragment that covers all or part of a tile a region of pixels e.g. 16 16 rather than a separate Z value for each pixel in the tile. In one embodiment described therein Z is represented using tile relative coordinates where the tile relative coordinates x y for a sample location define that location relative to a tile center X Y in screen space. In one example the planar Z representation for a fragment is an ordered triple of coefficients A B C such that Eq. 1 for any sample location x y within the tile where coordinates x y are defined relative to the center of the tile. For each tile a frame buffer stores one or more triples A B C depending on how many fragments at least partially cover the tile. Also stored is coverage information indicating which portion of the tile is covered by which triples A B C . In one example described in application Ser. No. 10 878 460 tiles are 16 16 pixels and up to six planar Z representations representing fragments of up to six different surfaces that are at least partially visible in the tile can be stored per tile. If more than six Z surfaces are needed for a particular tile data for that tile is stored in uncompressed form. Using this technique compression factors of 8 1 can be achieved for tiles that are covered by visible fragments of one or two Z surfaces. In some cases the same amount of frame buffer space is allocated per tile regardless of whether the data for that tile is compressed or not. Where Z information for a tile is stored in compressed form read and write operations for the tile require less bandwidth than for tiles where uncompressed Z data is stored.

In graphics processors described in above referenced application Ser. No. 10 878 460 computations and comparisons of Z coordinates are performed by one unit e.g. the ROP unit . In some graphics processors it is desirable to enable multiple different units to compute and or compare Z coordinates. Where Z coordinates are computed in multiple different units errors or inconsistencies in the rendered image may result if different units do not produce the same Z coordinate from the same set of inputs e.g. the same plane equation coefficients and x y coordinates .

Embodiments of the present invention provide graphics processors in which at least two different units compute Z coordinates from a planar Z representation. The processors are designed to ensure that Z coordinates computed in any unit in the processor are identical. For instance in some embodiments Z coordinates may be computed by one or more of a processing core that executes a pixel shader a texture unit a ROP unit or a frame buffer interface. The respective arithmetic circuits used to compute Z in each of these units are advantageously bit identical meaning that for any input planar Z representation and coordinates the output Z coordinates produced by the circuits are identical to each other.

According to one aspect of the present invention a graphics processor includes a plane equation module a first processing section subsequent to the plane equation module and a second processing section also subsequent to the plane equation module. The plane equation module is configured to receive vertex information for a number of primitives each of which covers one or more of a number of tiles and to generate a compressed Z representation e.g. a planar Z representation corresponding to each primitive. Each compressed Z representation is associated with at least one tile covered by the primitive. The first processing section includes a first arithmetic circuit configured to compute a first Z coordinate for a sample location within a first tile from a first compressed Z representation associated with the first tile. The second processing section includes a second arithmetic circuit configured to compute a second Z coordinate for a sample location within the first tile from a second compressed Z representation associated with the first tile. The first arithmetic circuit and the second arithmetic circuit are bit identical to each other.

As used herein the first and second processing sections may be any two processing sections of a graphics processor that each include a bit identical arithmetic circuit used to compute Z. For instance in one embodiment the first processing section is a processing core configured to execute a pixel shader while the second processing section is a raster operations unit. In another embodiment the first processing section is a raster operations unit and the second processing section is a frame buffer interface. In a further another embodiment the first processing section is a processing core configured to execute a pixel shader and the second processing section is a texture processing unit. In a still further embodiment the first processing section is a texture processing unit and the second processing section is a frame buffer interface.

In some embodiments the graphics processor also includes a third processing section subsequent to the plane equation module. The third processing section is configured to receive the first Z coordinate from the first processing section and the second Z coordinate from the second processing section and is further configured to compare the first Z coordinate and the second Z coordinate. Thus for instance the third processing section might be a texture pipeline that receives a first Z coordinate that was computed by a processing core executing a fragment shader program and a second Z coordinate that was computed by either a raster operations unit or a frame buffer interface. As long as the first and second Z coordinates are computed using bit identical arithmetic circuits the comparison by the texture pipeline will have the same result regardless of which processing section computed the Z coordinates.

According to another aspect of the present invention a method of rendering an image in a graphics processor includes generating a first compressed Z representation e.g. a planar Z representation corresponding to a first one of a number of primitives. The first compressed Z representation is associated with a tile covered by the first primitive. A first Z coordinate for a sample location within the tile is computed from the first compressed Z representation using a first arithmetic circuit in a first processing section of the graphics processor. A second compressed Z representation corresponding to a second one of the primitives is also generated. The second compressed Z representation is also associated with the tile. A second Z coordinate for the sample location within the tile is computed from the second compressed Z representation using a second arithmetic circuit in a second processing section of the graphics processor. The second arithmetic circuit is bit identical to the first arithmetic circuit. The first Z coordinate and the second Z coordinate are compared and a rendering operation that depends at least in part on the result of comparing the first Z coordinate to the second Z coordinate is performed.

The following detailed description together with the accompanying drawings will provide a better understanding of the nature and advantages of the present invention.

Embodiments of the present invention provide graphics processors in which at least two different units compute Z coordinates from a planar Z representation. The processors are designed to ensure that Z coordinates computed in any unit in the processor are identical. For instance in some embodiments Z coordinates may be computed by one or more of a processing core that executes a pixel shader a ROP unit or a frame buffer interface. The respective arithmetic circuits used to compute Z in each of these units are advantageously bit identical meaning that for any input planar Z representation and coordinates the output Z coordinates produced by the circuits are identical to each other.

Graphics processing subsystem includes a graphics processing unit GPU and a graphics memory which may be implemented e.g. using one or more integrated circuit devices such as programmable processors application specific integrated circuits ASICs and memory devices. GPU may be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and bus interacting with graphics memory to store and update pixel data and the like. For example GPU may include a rendering pipeline that generates pixel data from 2 D or 3 D scene data provided by various programs executing on CPU . GPU may also store pixel data received via memory bridge to graphics memory with or without further processing. GPU may also include a scanout module configured to deliver pixel data from graphics memory to display device .

CPU operates as the master processor of system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of GPU . In some embodiments CPU writes a stream of commands for GPU to a command buffer which may be in system memory graphics memory or another storage location accessible to both CPU and GPU . GPU reads the command stream from the command buffer and executes commands asynchronously with operation of CPU . The commands may include conventional rendering commands for generating images as well as general purpose computation commands that enable applications executing on CPU to leverage the computational power of GPU for data processing that may be unrelated to image generation.

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The bus topology including the number and arrangement of bridges may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies graphics subsystem is connected to I O bridge rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

The connection of GPU to the rest of system may also be varied. In some embodiments graphics system is implemented as an add in card that can be inserted into an expansion slot of system . In other embodiments a GPU is integrated on a single chip with a bus bridge such as memory bridge or I O bridge .

A GPU may be provided with any amount of local graphics memory including no local memory and may use local memory and system memory in any combination. For instance in a unified memory architecture UMA embodiment no dedicated graphics memory device is provided and the GPU uses system memory exclusively or almost exclusively. In UMA embodiments the GPU may be integrated into a bus bridge chip or provided as a discrete chip with a high speed bus e.g. PCI E connecting the GPU to the bridge chip and system memory.

It is also to be understood that any number of GPUs may be included in a system e.g. by including multiple GPUs on a single graphics card or by connecting multiple graphics cards to bus . Multiple GPUs may be operated in parallel to generate images for the same display device or for different display devices.

In addition GPUs embodying aspects of the present invention may be incorporated into a variety of devices including general purpose computer systems video game consoles and other special purpose computer systems DVD players handheld devices such as mobile phones or personal digital assistants and so on.

In some embodiments the present invention has applications in graphics processors in which units at different places in a rendering pipeline each compute Z information from a planar representation. For purposes of understanding the present invention an example of a rendering pipeline that may be implemented in GPU will now be described. It is to be understood that embodiments of the present invention may also be employed in other rendering pipelines.

In addition to multithreaded core array rendering pipeline includes a front end and data assembler a setup module a rasterizer a color assembly module and a raster operations ROP unit each of which can be implemented using conventional integrated circuit technologies or other technologies. ROP unit communicates with a frame buffer which may be located e.g. in graphics memory or system memory of .

Front end receives state information STATE rendering commands CMD and geometry data GDATA e.g. from CPU of . In some embodiments rather than providing geometry data directly CPU provides references to locations in system memory at which geometry data is stored data assembler retrieves the data from system memory . The state information rendering commands and geometry data may be of a generally conventional nature and may be used to define the desired rendered image or images including geometry lighting shading texture motion and or camera parameters for a scene.

Front end directs the geometry data to data assembler . Data assembler formats the geometry data and prepares it for delivery to a geometry module in multithreaded core array .

Geometry module directs programmable processing engines not explicitly shown in multithreaded core array to execute vertex and or geometry shader programs on the vertex data with the programs being selected in response to the state information provided by front end . The vertex and or geometry shader programs can be specified by the rendering application as is known in the art and different shader programs can be applied to different vertices and or primitives. A detailed description of such programs is omitted as not being critical to understanding the present invention.

After the vertex and or geometry shader programs have executed geometry module passes the processed geometry data GDATA to setup module . Setup module which may be of generally conventional design generates edge equations from the clip space or screen space coordinates of each primitive the edge equations are advantageously usable to determine whether a point in screen space is inside covered by or outside the primitive.

Setup module provides edge equations for each primitive PRIM to rasterizer . Rasterizer which may be of generally conventional design determines which if any pixels are covered by the primitive e.g. using conventional scan conversion algorithms. As used herein a pixel refers generally to a region in 2 D screen space for which a single color value is to be determined the number and arrangement of pixels can be a configurable parameter of rendering pipeline and might or might not be correlated with the screen resolution of a particular display device. As is known in the art pixel color may be sampled at multiple locations within a pixel e.g. using conventional supersampling or multisampling techniques and in some embodiments supersampling or multisampling is handled within the pixel shader. It is to be understood that pixel as used herein could also refer to a single sample within a supersampled or multisampled pixel.

In accordance with one embodiment of the present invention rasterizer also generates a planar representation of the Z depth coordinate for each fragment of a primitive also referred to herein as a surface that at least partially covers a tile i.e. a region of pixels as described in above referenced application Ser. No. 10 878 460. For example in one embodiment Eq. 2 where X and Y are screen space coordinates of a pixel and A B C are floating point coefficients determined from the Z coordinates of the vertices of the primitive using conventional techniques.

In some embodiments it is preferable to express the Z plane equation using tile relative coordinates. A point with screen coordinates X Y e.g. at the center of the tile is defined as a reference point and other points in the tile are assigned tile relative coordinates x y such that x X Xand y Y Y. Z can be expressed in tile relative coordinates x y as Eq. 3 where . Eq. 4 

Using tile relative coordinates rather than screen space coordinates allows the plane equation to be computed to a desired precision while retaining a smaller number of bits. More specifically to the extent that the tile is smaller than the screen the range in X Y space over which interpolation is performed is reduced consequently fewer bits for coefficients A and B are needed to interpolate within the range of a tile than over the entire screen. Thus in one embodiment Z is represented by coefficients A B and C where Cis given by Eq. 4 above and Aand Bare created from A and B by dropping zero or more least significant bits LSBs of the mantissas. Dropping LSBs results in lossy compression which is acceptable as long as the resulting resolution of Z coordinates computed using Eq. 3 is adequate for the rendering operations to be performed.

The coefficients A B and C or A Band C are advantageously stored in frame buffer on a per tile basis as described in application Ser. No. 10 878 460. As described therein where multiple surfaces each cover portions of a tile a set of coefficients for each such surface may be stored in the portion of frame buffer allocated to that tile together with coverage information indicating which pixels within the tile are covered by each surface. An implementation of a rasterizer that generates a planar Z representation is described in application Ser. No. 10 878 460 other implementations may be substituted.

Referring again to after determining which pixels are covered by a primitive rasterizer provides the vertices attributes and planar Z representation of the primitive PRIM together with a list of screen coordinates X Y of the pixels covered by the primitive to a color assembly module . Color assembly module associates the primitives and coverage information received from rasterizer with attributes e.g. color components texture coordinates surface normals of the vertices of the primitive and generates plane equations or other suitable equations defining some or all of the attributes as a function of position in screen coordinate space. In some embodiments color assembly module rather than rasterizer also generates the planar Z representation.

For each primitive that covers at least one pixel color assembly module and rasterizer provide the attribute equations EQS including the planar Z representation and a list of screen coordinates X Y of the covered pixels to a pixel module in multithreaded core array . Pixel module directs programmable processing engines not explicitly shown in multithreaded core array to execute one or more pixel shader programs on each pixel covered by the primitive with the program s being selected in response to state information provided by front end . Pixel shader programs can be used to implement a variety of visual effects including lighting and shading effects reflections texture blending procedural texture generation and so on. As with vertex shader programs and geometry shader programs rendering applications can specify the pixel shader program to be used for any given set of pixels. Numerous examples of pixel shader algorithms and programs are known in the art and a detailed description is omitted as not being critical to understanding the present invention.

Core array in one embodiment includes one or more cores adapted to execute instructions for such programs as well as a dedicated texture pipeline adapted to perform texture filtering operations in response to instructions included in the pixel shader program s . These aspects of core array are described below with reference to .

It should be noted that some pixel shader algorithms require a Z coordinate for a pixel or sample where a planar Z representation is used the processing engines of multithreaded core array compute the Z coordinate from the planar representation. If a Z coordinate is not required to execute the pixel shader algorithm multithreaded core array advantageously does not compute a Z coordinate. Similarly in some instances texture filtering may also include computing Z coordinates.

Once processing for a pixel or group of pixels is complete pixel module provides the fragment data PDATA to ROP unit . The fragment data advantageously includes the Z information which may be provided using either a planar representation or per pixel Z values. ROP unit which may be of generally conventional design integrates new fragment data referred to herein as source data received from pixel module with data previously stored in frame buffer referred to herein as destination data . In some embodiments ROP unit can mask source fragment data overwrite destination fragment data with source fragment data and or blend source data with destination data.

ROP unit advantageously performs hidden surface removal using a Z test. The Z test in one embodiment entails reading destination Z information from frame buffer and comparing the destination Z value to a source Z value to determine whether the new pixel corresponds to a surface that is hidden behind the surface represented by the existing one.

Where Z information is provided to ROP unit in a planar representation ROP unit may need to compute Z coordinates for the source and the destination. In some embodiments ROP unit can skip per pixel Z computation in at least some instances. For instance as described in above referenced application Ser. No. 10 878 460 the Z test may include a preliminary bounds test applied at a tile level. Using the planar representations e.g. A B Ccoefficients of the source and destination tiles a maximum Z and a minimum Z are computed for the source tile and the destination tile. Comparing the maximum Z for the source tile to the minimum Z for the destination tile and vice versa indicates whether one of the two surfaces completely hides the other at least within that tile if so no further Z testing is necessary. Where the bounds test indicates that one surface only partially hides the other per pixel testing is done in which case ROP unit may compute a Z coordinate for each pixel in the source and destination tiles.

In some embodiments other tests such as alpha tests and or stencil tests can also be used to determine the contribution if any of each new fragment to the rendered image.

After ROP unit has finished its operations it writes pixel data PDATA corresponding to the appropriate combination of source and destination data to frame buffer . Once the image is complete frame buffer can be scanned out to a display device and or subjected to further processing.

It will be appreciated that the rendering pipeline described herein is illustrative and that variations and modifications are possible. The pipeline may include different units from those shown and the sequence of processing events may be varied from that described herein. For instance in some embodiments rasterization may be performed in stages with a coarse rasterizer that processes the entire screen in tiles e.g. 16 16 pixels to determine which if any tiles each primitive covers or partially covers followed by a fine rasterizer that determines coverage for individual pixels within any tile that the coarse rasterizer identifies as being at least partially covered. Either the coarse rasterizer or the fine rasterizer may compute a screen space or tile specific planar Z. In one such embodiment the fine rasterizer is contained within pixel module . In another embodiment some operations conventionally performed by a ROP unit may be performed within pixel module before the pixel data is forwarded to ROP unit .

Core interface also controls a texture pipeline that is shared among cores . Texture pipeline advantageously includes logic circuits configured to receive texture requests to fetch texture data referenced in the request from memory e.g. frame buffer of or graphics memory or system memory of and to filter the texture data according to various algorithms. Conventional filtering algorithms including bilinear and trilinear filtering may be used. When a core encounters a texture instruction in one of its threads it makes a texture request to texture pipeline via core interface . The texture request may include a texture identifier texture coordinates and information about the fragment being processed such as a Z coordinate computed by core . Texture pipeline processes the texture request and returns the result to the core via core interface . It should be noted that in some instances texture pipeline may perform various tests based on comparisons between the Z coordinate included in the texture request and one or more Z coordinates included in the texture data and may also compute Z coordinates e.g. when compositing a current fragment with a previously rendered fragment.

It will be appreciated that the multithreaded core array described herein is illustrative and that variations and modifications are possible. Any number e.g. 1 4 8 or any other number of processing clusters may be provided and each processing cluster may include any number e.g. 1 2 4 or any other number of cores. Various algorithms may be used to distribute work to the cores and or to the processing clusters in embodiments with multiple processing clusters . In some embodiments shaders of certain types e.g. vertex shaders geometry shaders and or pixel shaders may be restricted to executing in certain processing clusters or in certain cores such design choices may be driven by considerations of hardware size and complexity versus performance as is known in the art and are not critical to the present invention. A shared texture pipeline is also not critical to the present invention in some embodiments each core might have its own texture pipeline or might leverage general purpose functional units to perform texture operations.

A Z triage unit within Z operations unit receives source src Z data e.g. tile specific coefficients and coverage information from core . Z triage unit also receives destination dst Z data from frame buffer . The destination Z data may be compressed or uncompressed. If the Z data is compressed Z triage unit performs a trivial Z test based on the minimum and maximum Z values for the source Z data and the destination Z data without decompressing the Z data. The result of the trivial Z test may be used to reject the source data accept the source data or determine that Z values for each pixel or sample need to be compared in a Z test unit .

The source Z data is provided to a source Z bounds evaluator which determines a minimum source Z value Z and a maximum source Z value Z For instance source Z bounds evaluator may determine the minimum and maximum source Z values as 22 Eq. 5a and 22 Eq. 5b where DX is the screen space width of the tile and DY is the screen space height of the tile. It should be noted that DX and DY might or might not be equal .

The destination Z data is provided to a destination Z bounds evaluator which determines a minimum destination Z value Z and a maximum destination Z value Z. The computation advantageously uses equations similar to Eqs. 5a and 5b except that the coefficients A B Capplicable to the destination tile rather than the source tile are used.

A Z bounds unit receives the minimum and maximum source Z values from source Z bounds evaluator and the minimum and maximum destination Z values from destination Z bounds evaluator . Z bounds unit performs a trivial Z test by comparing the maximum and minimum source Z values to the maximum and minimum destination Z values. The test may be performed in one of a number of modes e.g. always never less than greater than and the like the mode can be specified by the application programming interface API . The trivial Z test result indicates whether the source data should be rejected in its entirety the source data should be accepted in its entirety or further per pixel testing is needed.

For example when a less than Z test is specified if the maximum source Z value is less than the minimum destination Z value the trivial Z test result indicates that the source data should be accepted if the minimum source Z value is greater than the maximum destination Z value the trivial Z test result indicates that the source data should be rejected. If the source Z interval bounded by the minimum and maximum source Z values includes at least one Z value that overlaps with the destination Z interval bounded by the minimum and maximum destination Z values the trivial Z test result indicates that Z values for each pixel or sample need to be compared.

When the always Z test is specified the trivial Z test result always indicates that the source data should be accepted. When the never Z test is specified the trivial Z test result indicates that the source data should be rejected. In these instances Z triage unit may disable source Z bounds evaluator and destination Z bounds evaluator .

It should be noted that the trivial Z test result is determined without decompressing either the source Z data or the destination Z data. Further the trivial Z test result is computed for an entire tile so fragment data for several pixels may be trivially accepted or rejected without decompressing either the source or destination Z data.

Z bounds unit provides the trivial Z test result to an expansion unit which also receives the source and destination Z data. If the trivial Z test result indicates that per pixel testing is needed expansion unit performs a per pixel expansion of the Z data to produce a Z coordinate for each pixel. If the trivial Z test result indicated the source Z data should be accepted or rejected expansion unit may provide appropriate control signals to Z test unit but does not need to expand the Z data.

Expansion unit includes a source Z evaluation unit and a destination Z evaluation unit . Source Z evaluation unit computes a Z coordinate or multiple Z coordinates for a pixel using the source Z data which may be in the form of a tile specific plane equation. Destination Z evaluation unit computes a Z coordinate or multiple Z coordinates for a pixel using the destination Z data which may also be in the form of a tile specific plane equation. The source and destination Z coordinates are provided to Z test unit .

Z test unit determines whether an update is needed based on information received from Z triage unit and or expansion unit . If an update is needed Z test unit loads Z data to be written to frame buffer into a destination Z write unit . In one embodiment if the trivial Z test result indicates that the source data should be accepted Z test unit loads only the compressed source data including coverage information if the compressed source data covers only part of the tile . If the trivial Z test result indicates that per pixel Z values for the source and destination Z coordinates need to be computed Z test unit compares each source Z value from source Z evaluation unit to a corresponding destination Z value from destination Z evaluation unit and determines for each pixel whether the source Z or the destination Z value should be used. Z test unit generates coverage information indicating which value was determined in each case and provides this information to Z write unit . In some embodiments Z test unit also generates signals that are used by other elements not explicitly shown in ROP unit to perform updates to color information and or other per pixel information.

Z write unit formats the Z data for writing into frame buffer . In some embodiments Z data for each tile can be stored in either compressed or uncompressed format regardless of how data for other tiles is stored. For instance in one embodiment compressed Z data can be stored for a tile as long as the number of planar Z representations needed to represent all surfaces that at least partially cover that tile does not exceed some maximum e.g. 2 4 6 or some other number if the number of Z planes needed exceeds the maximum then uncompressed Z data is stored for that tile. Z write unit determines whether to store the data in compressed or uncompressed form formats the data accordingly updates a compression tag indicating whether the data is compressed or not and generates a Z write request that is transmitted to frame buffer to update the Z information.

It will be appreciated that the Z operations unit described herein is illustrative and that variations and modifications are possible. Examples of arithmetic circuits that can be used to implement source Z evaluation unit and or destination Z evaluation unit are described below. Further features and operations that can be included in a Z operations unit are described in above referenced application Ser. No. 10 878 460.

As shown in GPU has a number of different processing sections such as a core a texture pipeline a ROP unit and a frame buffer interface . Each processing section is advantageously usable to perform a particular portion of a rendering operation. For instance core is usable to perform pixel shader operations e.g. executing a pixel shader program . Texture pipeline is usable to perform texture filtering during the course of pixel shading as described above. ROP unit is usable to integrate new fragments produced by core into an image being rendered into frame buffer . Frame buffer interface communicates with ROP unit to load the image into frame buffer and also communicates with texture pipeline to provide texture data that may be stored in frame buffer or other memory.

Any of these or other processing sections may include arithmetic circuits configured to compute Z coordinates for various fragments from planar Z representations and or logic circuits configured to compare two or more Z coordinates for use in various rendering decisions. In one embodiment core ROP unit texture pipeline and frame buffer interface include respective Z calc circuits that compute a Z coordinate for a pixel or sample by interpolation from a planar Z representation. Texture pipeline and ROP unit include respective Z test circuits that compare two Z coordinates. It is to be understood that a GPU may include any number of instances of each of the modules shown in and each instance may include one or more copies of a Z test and or Z calc circuit.

As described above with reference to core may compute Z coordinates for individual pixels or samples from a planar Z representation during execution of a pixel shader program. In the embodiment of core computes Z coordinates using Z calc circuit which may be implemented in a multipurpose arithmetic functional unit capable of performing planar interpolation operations as well as other operations. An example of such a functional unit is described in above referenced application Ser. No. 10 970 101.

In this embodiment core provides Z information to ROP unit using the planar Z representation. ROP unit includes a Z calc circuit that computes Z values for source fragments i.e. fragments received from core and destination fragments i.e. fragments retrieved from frame buffer as needed for use by Z test circuit . In some embodiments ROP unit advantageously includes two copies of Z calc circuit so that source and destination Z coordinates may be computed in parallel. For instance if ROP unit includes Z operations unit of source Z evaluation unit and destination Z evaluation unit may each include a copy of Z calc circuit .

ROP unit advantageously writes compressed Z data for a tile to frame buffer using the planar Z representation as described above and in above referenced application Ser. No. 10 878 460. As described above in one embodiment a planar Z representation can be used to represent up to a maximum number e.g. six of surfaces that are each visible in at least part of the tile. Where more than the maximum number of surfaces are visible in a tile uncompressed Z data i.e. a Z coordinate for each pixel in the tile is stored instead. If uncompressed Z data is to be stored for a tile ROP unit advantageously computes the Z coordinates and writes them to frame buffer . A compression flag can be associated with each tile in frame buffer and used to indicate whether the stored Z data for that tile is compressed or uncompressed.

Frame buffer interface manages all interactions with frame buffer including reading and writing of Z data. Frame buffer interface is advantageously able to supply Z data to a requesting client in either compressed or uncompressed form depending on the form in which the requested information is stored the nature of the requesting client and or the parameters of the request. In one embodiment if the Z data for a particular tile is stored in uncompressed form frame buffer interface provides the uncompressed Z data to all requesters if the Z data is in compressed form frame buffer interface determines whether to supply compressed or uncompressed Z data.

In some embodiments the determination depends on the identity of the requesting client. For instance ROP unit in one embodiment has a Z calc circuit to save bandwidth frame buffer interface advantageously provides compressed Z data to ROP unit . Texture pipeline in the embodiment of has a Z calc circuit frame buffer interface may provide compressed Z data. Alternatively texture pipeline might not include a Z calc circuit and frame buffer interface may decompresses the compressed Z data using its own Z calc circuit and deliver the resulting per pixel Z coordinate s to texture pipeline .

In some embodiments clients external to GPU e.g. CPU of may also request Z data from frame buffer . Where such requests are handled by frame buffer interface frame buffer interface advantageously converts the planar Z data to Z coordinates and supplies the Z coordinates to the requesting client. Computing the Z coordinates within GPU when servicing requests from an external client can be useful e.g. for ensuring that consistent Z values are used throughout a system of which GPU is a part such as system of .

In other embodiments a client may explicitly request compressed or uncompressed Z data e.g. by including a Z compression parameter in the request. Frame buffer interface reads the Z compression parameter. If uncompressed information is requested for a tile for which compressed Z information is stored frame buffer interface uses Z calc circuit to compute per pixel Z coordinates to be returned to the requesting client.

Because different components of GPU may compute Z coordinates it is possible that components of GPU may end up using Z coordinates computed by two or more different Z calc circuits. For instance although texture pipeline in this embodiment does not compute Z coordinates from planar representations it may perform Z tests using a Z test circuit . In one embodiment texture pipeline compares the respective Z coordinates of a first pixel provided by core and a second pixel retrieved from frame buffer by frame buffer interface . In this example the Z coordinate of the first pixel is computed by core using Z calc circuit while the Z coordinate of the second pixel is computed by frame buffer interface using Z calc circuit . It should also be noted that in cases where frame buffer stores uncompressed Z data for a tile the Z coordinate for the second pixel might have been computed by Z calc circuit in ROP unit .

Thus texture pipeline may compare Z coordinates computed by different Z calc circuits in different units of GPU . For instance a Z coordinate computed by Z calc circuit in core might be compared to a Z coordinate computed either by Z calc circuit in ROP unit or by Z calc circuit in frame buffer interface . One example occurs in the context of depth peeling a widely used algorithm that renders transparency by sorting depth layers from front to back and successively compositing fragments at different depths. In one implementation of depth peeling texture pipeline performs the sorting by comparing a Z coordinate computed for the current layer by Z calc circuit in core to a previous Z value stored in a depth buffer e.g. within frame buffer . If the depth buffer stores compressed Z data texture pipeline computes the previous Z value. To the extent that core and texture pipeline do not compute Z values consistently visual artifacts e.g. small holes or gaps in surfaces that should appear continuous may appear in the rendered image.

To ensure that the result of the comparison is independent of which Z calc circuit computed a particular Z coordinate it is desirable to ensure that Z calc circuits and are all bit identical to each other. As used herein two calculation circuits are bit identical if for any input planar Z representation and coordinates the output Z coordinates produced by the circuits are identical to each other. Having bit identical Z calc circuits in texture pipeline and core for instance allows depth peeling to operate correctly.

In some embodiments bit identical Z calc circuits are provided by using the same arrangement of arithmetic circuits multipliers adders etc. of like design in each Z calc circuit. It is to be understood that calculation circuits may be bit identical in the sense used herein even if they differ in the arrangement of components and or in the presence or absence of various components that do not affect the output of the Z calculation.

For instance Z calc circuit of core can be implemented using a multipurpose arithmetic functional unit of the kind described in above referenced application Ser. No. 10 970 101. In this embodiment the functional unit includes an arrangement of multipliers shifters inverters and adders that are used to perform planar interpolation operations along with other components e.g. multiplexers lookup tables etc. that allow the functional unit to be reconfigured to perform other operations as described in above referenced application Ser. No. 10 970 101. In one embodiment of the present invention any components of one Z calc circuit e.g. circuit of core that do not affect the result of a planar interpolation operation need not be replicated in other Z calc circuits e.g. circuit in ROP unit or circuit in frame buffer interface .

Circuit includes an alignment control block a product section that computes products P A Xand P B Y an offset section that computes an offset P A dx B dy C and a sum section that adds the products P and P produced by product section and offset P computed by offset section to produce the final result.

Circuit receives parameters A B C or A B Cif the planar Z representation uses tile relative coordinates coordinates of a reference point X Y and an offset dx dy relative to the reference point X Y . In one embodiment where the planar Z representation uses tile relative coordinates the reference point coordinates may be 0 0 and the offset dx dy may be the tile relative coordinates x y of the pixel or sample for which a Z coordinate is to be computed. In other embodiments the reference point might be the center of a tile in screen space coordinates while the offsets identify the centers of pixels relative to the tile center or the reference point might be the center of a pixel in screen space or tile relative coordinates depending on the Z representation while the offsets identify sample locations within the pixel relative to the pixel center.

In one embodiment parameters A B C are in a 32 bit floating point format e.g. the IEEE standard 32 bit floating point format referred to herein as fp32 while the reference point and offset coordinates are in a fixed point format. In one embodiment the reference point coordinates X Y are in a signed 13 bit format while the offsets dx dy are in either an unsigned 4 bit format or a signed 5 bit format.

Alignment control circuit determines shift amounts for products P and P as well as for parameters A B and C and generates appropriate Sh P Sh P Sh A Sh B and Sh C signals. Alignment control circuit also advantageously determines a block exponent not explicitly shown in for the final result. Where X Y dx and dy are fixed point numbers while A B and C are floating point numbers the shift amounts and block exponent will depend only on the respective exponents of A B and C. Thus in some embodiments some or all of these shift signals may be determined earlier e.g. at the time A B and C are computed and provided to circuit along with parameters A B and C. These shift signals are used to align the various products prior to addition as described below. Conventional techniques for determining alignment shifts and block exponents may be used.

Product section includes Booth encoders multiplier trees and shift circuits which may be of generally conventional design. In one embodiment Booth encoders implement the well known Booth2 radix 4 encoding while multipliers are 24 13 bit multiplier trees that each include a set of nine 25 bit Booth multiplexers followed by a suitable carry save adder CSA tree such as three 27 bit 3 2 CSAs followed by two 29 bit 3 2 CSAs followed by one 35 bit 4 2 CSA. Multipliers may provide products in redundant carry save form or they may each include a final carry propagation adder CPA to convert the product to non redundant form.

In operation Booth encoders and Booth encode reference coordinates Xand Y respectively and provide the Booth encoded operands as multipliers to multiplier trees and . Plane equation coefficients A and B are provided as multiplicands to multiplier trees and respectively. Thus multiplier tree computes a product A Xwhile multiplier tree computes a product B YIn one embodiment multiplier trees and use the sign bits of A and B respectively to invert the signs of the Booth partial products if A or B is a negative number.

Shift circuits and apply the appropriate shifts determined by signals Sh P and Sh P in order to properly align these products before they are added in sum section . In one embodiment multiplier trees and provide their outputs in redundant carry save form and shift circuits and operate on the redundant form results as described in above referenced application Ser. No. 10 970 101. In another embodiment multipliers and provide their outputs in non redundant form and shift circuits and sign extend the shifted results P and P.

Where the planar Z representation uses tile relative coefficients A B C product section may use X 0 and Y 0 to generate P 0 and P 0.

Offset section includes shift circuits two s complement inverters IN2 conditional inverter CIN Booth encoders multiplier trees and adders which may be of generally conventional design.

In operation shift circuits and apply appropriate shifts determined by signals Sh A and Sh B respectively to the plane coefficients A and B to support correct addition later in the circuit. Inverters perform two s complement inversion on shifted coefficients Aand B. If A B is less than zero inverter provides the two s complement inverse of A B as a multiplicand A B to multiplier otherwise multiplier A B is just the shifted coefficient A B . Booth encoders and encode offset coordinates dx and dy respectively e.g. using Booth2 radix 4 encoding and provide the Booth encoded operands as multipliers to multiplier trees and . Multiplier tree computes a product A dx while multiplier tree computes a product B dy. Multiplier trees and provide their respective products to an adder which adds the two products. In one embodiment multiplier trees and each provide products in redundant form and adder is a 4 2 CSA.

Shift circuit applies an appropriate shift determined by signal Sh C to the plane coefficient C to support correct addition later in the circuit producing a shifted coefficient CConditional inverter inverts Cif C is less than zero otherwise the addend Cis just C. Adder e.g. a 3 2 CSA adds the sum produced by adder to the addend Cto produce offset P.

Sum section includes an addition unit a normalization unit and a formatting and output unit which may be of generally conventional design. Addition unit adds P P and P which have already been properly aligned as described above . In one embodiment P P and P are each in redundant form and addition unit includes a pair of 3 2 CSAs followed by a 4 2 CSA that adds the output values from the 3 2 CSAs to produce a redundant form result. A CPA can also be included in addition unit to reduce the result to non redundant form.

Normalization unit normalizes the result e.g. right shifting a mantissa in the case of a carry out during the addition operation or left shifting the mantissa in the event of cancellation of MSBs that may occur when addition unit adds P P and P . Normalization unit advantageously also modifies the block exponent to reflect the effect of any mantissa shift.

Formatting and output unit formats the final result in accordance with a selected format and delivers the result Z at an output of circuit . In one embodiment Z coordinates may be delivered either in fp32 format or in an unsigned normalized 24 bit fixed point format referred to herein as unorm24 in which fractional values in the range 0 1 are represented using 24 bits. The format to be used for a particular application may be specified by the application program executing on CPU as is known in the art. In this embodiment formatting unit advantageously is capable of converting a result to either fp32 or unorm24 format or any other format allowable in a particular embodiment a control signal received by formatting unit may be used to select the format.

Referring again to Z calc circuits and may each be implemented as a copy of circuit of . As long as each copy uses identical Booth encoders multipliers adders and so on each copy will produce identical output from identical input. Different Z calc circuits in the same GPU may differ in including or omitting various components not shown in that do not affect the result of a Z computation.

In some embodiments circuit may be modified to compute Z coordinates for multiple locations in a tile in parallel by replicating offset section and sum section the desired number of times. An example is shown in a block diagram of an alternative Z calc circuit according to an embodiment of the present invention. Circuit includes an alignment control block not explicitly shown in a product section four copies of offset section and four copies of sum section . It is to be understood that each section of circuit may include multipliers adders and the like identical to those shown explicitly in . Product section receives reference point coordinates X Y and planar Z coefficients A B C and computes products P and P as described above. Each copy of offset section receives a different set of offset coordinates dx dy where i 0 1 2 3 and the same planar Z coefficients A B C each offset section computes a different offset P. Each copy of sum section receives products P and P and a different one of the offsets Pand adds the received values to determine a Z coordinate Z.

It will be appreciated that the Z calculation circuits described herein are illustrative and that variations and modifications are possible. The particular configuration of multipliers and adders shown herein may be modified as desired. A Z calc circuit may include any number of copies of the offset section and product section. Further Z calc circuits in different units within a GPU may include different numbers of such copies depending on the optimum degree of parallelism for that circuit. For instance referring to a Z calc unit in core may include four copies of offset section and sum section as shown in while ROP includes two Z calc circuits each of which has two copies of offset section and sum section .

It should also be noted that where Xand Yare always zero as is the case in some embodiments where the planar Z representation is always in tile relative coordinates offset section could be used with appropriate normalization and formatting blocks to compute Z without using product section or adder in sum section . Alternatively a Z calculation circuit that computes only one Z coordinate at a time might be simplified relative to circuit by omitting the multiplier trees and adders of offset section .

In one embodiment Z calc unit in core is implemented as part of a multipurpose arithmetic functional unit as described in above referenced application Ser. No. 10 970 101. The multiplier and adder sizes shifter behavior and the like adopted for Z calc unit can be duplicated in other Z calc units e.g. Z calc units and in order to assure that all Z calc units produce identical results.

Referring again to persons having ordinary skill in the art with access to the present teachings will recognize that Z coordinates computed by different Z calc circuits might be in different formats. For instance in one embodiment Z calc circuit in core always computes Z coordinates in fp32 format while Z calc circuit in frame buffer interface and Z calc circuit in ROP unit each compute Z coordinates in the format specified by the application program which might be e.g. either fp32 or unorm24 .

When Z coordinates that were generated by different Z calc circuits are to be compared e.g. by Z test circuit of texture pipeline the coordinates should be in the same format. In one embodiment where core always provides Z coordinates in fp32 format texture pipeline converts any Z coordinates received in unorm24 format to fp32 format. No loss of precision occurs during this conversion as the mantissa size of an fp32 number happens to be 24 bits.

In another embodiment uncompressed Z data is stored in frame buffer in a fixed point format e.g. unorm24 or unorm16 and Z calc circuit in ROP unit computes Z coordinates in fp32 format. ROP unit may convert the fp32 computation result to the fixed point format prior to making comparisons. It is to be understood that other conversions could also be used.

While the invention has been described with respect to specific embodiments one skilled in the art will recognize that numerous modifications are possible. For instance although particular formats such as fp32 and unorm24 have been used herein for illustration any other format or combination of formats could be substituted without departing from the scope of the invention.

The planar Z representations used herein as an example of compressed Z data are also illustrative and other representations of a surface fragment may be substituted. Planar Z representations may be defined using any point in screen coordinate space as a reference point in some embodiments planar Z representations for different surfaces may use different reference points and the stored information for a planar Z representation may include reference point coordinates. In some embodiments a non linear or non planar Z representation might be used such representations have been proposed e.g. to equalize sampling density for shadow depth maps.

Z comparison or Z test operations described herein are not limited to particular Z rules and results of such a comparison or test may be used in any manner desired.

Further while particular units within a graphics processor have been identified as including circuits that compute Z coordinates it is to be understood that any or all units in a graphics processor may be provided with Z calculation circuits as described herein. In some embodiments all Z calculation circuits across the entire processor are bit identical but this is not required in other embodiments all Z calculation circuits whose results might be shared with another unit or compared to Z coordinates provided by another unit are bit identical while other Z calculation circuits whose results are only used within a single unit and are not compared to results produced by another unit might diverge from the rest. In some instances using non bit identical Z values that are never compared might result in certain anomalies e.g. in results of depth tests performed in different stages of the rendering pipeline.

In some embodiments a graphics processing system may include two or more graphics processors that cooperate to render images. In such systems each processor may include one or more processing sections with arithmetic circuits that compute Z coordinates. The arithmetic circuits in different processors are advantageously made bit identical so that the rendered image does not depend on which graphics processor performed a particular rendering operation.

Thus although the invention has been described with respect to specific embodiments it will be appreciated that the invention is intended to cover all modifications and equivalents within the scope of the following claims.

