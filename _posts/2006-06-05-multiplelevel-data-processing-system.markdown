---

title: Multiple-level data processing system
abstract: Methods and systems for processing multiple levels of data in system security approaches are disclosed. In one embodiment, a first set and a second set of resources are selected to iteratively and independently reverse multiple levels of format conversions on the payload portions of a data unit from a first file and a data unit from a second file, respectively. The first file and the second file are associated with a first transport connection and a second transport connection, respectively. Upon completion of the aforementioned reversal operations, the payload portions of a first reversed data unit and a second reversed data unit, which correspond to the data unit of the first file and the data unit of the second file, respectively, are inspected for suspicious patterns prior to any aggregation of the data units of the first file or the second file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07930742&OS=07930742&RS=07930742
owner: Lionic Corporation
number: 07930742
owner_city: Science-Based Industrial Park, Hsinchu
owner_country: TW
publication_date: 20060605
---
This application is a continuation in part of U.S. application Ser. No. 10 868 665 filed on Jun. 14 2004 which is incorporated herein by reference in its entirety.

This patent document generally relates to system security approaches especially a multi level data processing system that can be employed in such system security approaches.

Unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

Some of the most malicious software also known as malware capable of crippling a computing device or even an entire corporate network are being distributed worldwide via electronic mail email and email attachments. As individuals and businesses become increasingly dependent on email communications the likelihood of such programs setting off disruptive consequences has also increased considerably. Further complicating the matter is that some email attachments are compressed to conserve communication bandwidth. Finding malware in such compressed attachments generally involves decompressing the entire compressed attachments before scanning the uncompressed version of the attachments.

One approach employed by existing anti virus solutions is to filter out an attachment file based on its extension. Thus if the attachment file has a known compression extension such as zip then the attachment file is blocked from reaching users of such solutions. However since this approach does not inspect the content of the attachment file a legitimate and a malware free attachment file may be erroneously filtered out.

Another approach employed by the anti virus solutions is to recommend or even require a user of the solutions to decompress and scan the compressed attachment file for malware prior to permitting the user to access the file. After an affirmative act by the user such as manually electing to start the decompressing and scanning process the entire attachment file is temporarily stored either on the user s computing device or on the mail server on the network for processing. Unlike the first approach discussed above this approach inspects the content of the attachment file. However the inspection takes place only after the entire file is stored and decompressed. By its nature a compressed file tends to contain a large amount of information when it is in its uncompressed state. Since the entire uncompressed file is stored and inspected this approach consumes significant processing and memory resources. When faced with multiple attachments from different email sessions concurrently the resource requirements of this approach renders the implementation of the approach impractical and prohibitively expensive.

As the foregoing illustrates what is needed is a way to efficiently and yet thoroughly inspect the content of these compressed attachment files in email communications.

Methods and systems for processing multiple levels of data in system security approaches are disclosed. In one embodiment a first set of resources is selected to iteratively reverse multiple levels of format conversions on the payload data of a data unit. This data unit is part of a first file which is associated with a first transport connection. Independently a second set of resources is also selected to iteratively reverse multiple levels of format conversions on the payload data of a data unit. This data unit is part of a second file which is associated with a second transport connection. Upon completion of the aforementioned reversal operations the payload data of a first reversed data unit and a second reversed data unit which correspond to the data unit of the first file and the data unit of the second file respectively are inspected for suspicious patterns. The inspection of the first and the second reversed data units occur prior to any aggregation of the data units of the first file or the second file.

Methods and systems for processing multiple levels of data in system security approaches are described. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details.

Certain computing and programming theories and networking protocols are well known in the art and will not be elaborated in detail. However throughout this disclosure any two data processing operations are said to be in parallel when at least some portions of the operations are performed at the same time. Each data unit generally refers to data that are stored in a particular memory location or a packet with a destination address. The reversal of one format conversion of a data unit is referred to as a single level data processing. So if a data unit has been encoded and also compressed then a two level data processing namely decompressing and decoding is needed to reverse the two format conversions. Data unit based processing generally refers to operations performed on a single data unit without any precondition of assembling and combining multiple data units.

A multi level data processing system MDPS is capable of allocating resources to perform multiple data unit based processing in parallel. Some illustrative types of such processing include without limitation decoding decompressing unarchiving and any reversing of a format conversion for email attachment files from multiple TCP connections in parallel on a data unit by data unit basis. For each of the email attachment files the multi level processing capability of the data unit based processing discussed above is invoked if the format of the file has been converted more than once.

One embodiment of MDPS is also coupled to protocol parser and content inspection engine . Protocol parser generates and directs MDPS data units that characterize the data from transport service users such as and shown in to handler selector . Subsequent discussions will detail the process that protocol parser follows and also one format of a MDPS data unit. Some examples of a transport service user include without limitation a Simple Mail Transfer Protocol SMTP client a File Transfer Protocol FTP client a Hyper Text Transfer Protocol HTTP client and a Post Office Protocol 3 POP3 client. After MDPS has an opportunity to process the MDPS data units content inspection engine examines the processed results for suspicious patterns. Content inspection engine generally supports a data unit based inspection mechanism which is disclosed and claimed in the U.S. application Ser. No. 10 868 665 filed on Jun. 14 2004.

Handler selector is mainly responsible for interacting with resource manager to track resources of MDPS and designates certain MDHs such as MDH and to handle the incoming data from the transport service users via protocol parser . In one implementation handler selector may designate one or more MDHs for each TCP connection and the designation of a MDH spawns a process. This spawned process is referred to as a MDH process and is used interchangeably with MDH throughout this disclosure. Each MDH operates independently from one another and has access to a set of resources such as one or more data processing blocks and storage. As each MDH processes the incoming data the MDH keeps certain state information of the processing in state table and also feeds certain information back to handler selector . After the MDH completes the processing of the incoming data it places the results in output queue . Subsequent sections will provide detailed discussions of the interactions among these various components of MDPS .

MDPS supports a finite number of MDHs. For each of the supported MDHs resource manager allocates at least a table entry in a finite sized state table . In one implementation the table entry may contain identification information status information state information and resource information. Specifically the identification information may be a MDPS session number which uniquely corresponds to a specific TCP connection and any MDH that is designated to process the data on this TCP connection. The status information indicates the availability of the designated MDH. The state information provides a snapshot of any processing the designated MDH may have undertaken. Lastly the resource information tracks the resources the designated MDH utilizes such as the FIFO buffers and the data processing blocks mentioned above. Subsequent paragraphs will further detail the management of state table and the allocation and the de allocation of the resources.

As an illustration suppose one of the transport service users is a SMTP client. The data units that this SMTP client receives are thus in the form of SMTP packets. Suppose further that this SMTP client also supports Multipurpose Internet Mail Extension MIME and receives SMTP packets that are associated with the TCP connection and collectively contain an email and an attachment file. For clarity of the discussions unless otherwise indicated references to these SMTP packets are meant to cover the packets containing the email the email and the attachment file or the attachment file. In this illustration the first of these SMTP packets refers to the packet containing both the email and also a beginning portion of the attachment file. The subsequent SMTP packets refer to the packets containing the remaining portions of the attachment file. One embodiment of protocol parser generates a MDPS data unit for each SMTP packet that it receives. In most instances the subsequent MDPS data units have the same payload data as the subsequent SMTP packets.

After the TCP connection is established and the required handshaking is completed pursuant to the SMTP protocol the SMTP client begins to send the aforementioned SMTP packets to protocol parser . In this example protocol parser examines the payload data of the first SMTP packet in search of a boundary marker that indicates the beginning of the attachment file. At this boundary marker protocol parser retrieves certain information such as the type of encoding for this attachment file the existence of the attachment file and the name of the attachment file. Based on the retrieved information protocol parser determines a data type for this first portion of the attachment file. So if the type of encoding is base64 then protocol parser denotes the data type of this first portion in step to represent base64 encoding.

With at least the TCP connection and the denoted data type information protocol parser requests MDPS shown in to decode the first portion of the attachment file in step . Specifically one embodiment of protocol parser in step initiates the opening of a MDPS session by requesting for a MDPS session ID which corresponds to a MDH in MDPS that handles at least base64 decoding. Resource manager of MDPS shown in maintains certain information of all the supported MDPS sessions in state table as discussed above. If handler selector of MDPS working with resource manager is able to reserve a MDPS session ID and indicates to protocol parser in step that the MDPS session ID is available for the TCP connection then the MDPS session is successfully established. Protocol parser proceeds to generate and send the first MDPS data unit with this MDPS session ID the established base64 encoding data type a data ID and the payload data in the first SMTP packet to MDPS in step . In one implementation each data ID distinctly maps to a MDPS data unit so that protocol parser has means to track the MDPS data unit and also allocate or de allocate the resources relating to the MDPS data unit. On the other hand if the MDPS session ID is not available then protocol parser may notify the SMTP client of the resource unavailability in step before attempting to open the MDPS session again. Alternatively protocol parser may request to have the resources reallocated including without limitation releasing and making available the least recently used resources prior to notifying SMTP client of the resource unavailability.

Continuing with the aforementioned example because the subsequent portions of the same attachment file belong to the same TCP connection and are likely to remain as base64 encoded for each of the SMTP packets that contain these subsequent portions protocol parser generates a corresponding MDPS data unit with the same MDPS session ID and the same data type as the MDPS data unit for the first portion of the attachment file. In addition protocol parser examines each SMTP packet for a boundary marker that indicates the end of the attachment file. If the boundary marker is found and the last SMTP packet containing the remaining portion of the attachment file is identified in step then protocol parser initiates the closing of the MDPS session in step . On the other hand if the boundary marker is not found then protocol parser continues to generate and send MDPS data units to MDPS in step .

Protocol parser is capable of handling different TCP connections in parallel. In other words multiple instances of process as shown in and discussed above may occur concurrently. Moreover it should be apparent to one with ordinary skill in the art to recognize that MDPS may support an Application Programming Interface API to facilitate the communication and interaction between MDPS and modules such as protocol parser . For instance the steps of opening a MDPS session and closing a MDPS session discussed above can be implemented as API calls that protocol parser makes.

It should be noted that protocol parser may not be able to precisely determine the data type of a data unit in certain situations. In such situations data type subfield as shown in does not contain data type information. Instead the subfield may contain information that indicates the shift of the data type identification task to MDPS .

To further describe the multi level operations of MDH is a flow diagram of one process process that handler selector and MDH follow to process the first MDPS data unit after the establishment of a MDPS session. Suppose this MDPS session corresponds to the aforementioned TCP connection in Section 1.1 in which an email and an attachment file are distributed among multiple SMTP packets. The MDPS session ID for this session is happy. Suppose further that this attachment file has the file name of hello.exe and has undergone multiple levels of format conversions as shown in . Particularly hello.exe has been archived compressed and encoded.

In conjunction with and as handler selector receives the first MDPS data unit from protocol parser that contains the first portion of hello.exe handler selector extracts the MDPS session ID and the data type information from the header sub fields of the MDPS data unit. The data type information should at least indicate that hello.exe has been base64 encoded. In step handler selector provides resource manager with the extracted MDPS session ID to locate the corresponding table entry in stable table . In step handler selector spawns the process of MDH and initializes an n variable which tracks the number of levels of reversal operations MDH has performed to a value of 1. In step based on the extracted data type information MDH proceeds to reserve and invoke the appropriate resources to perform the first level of reversal operation on the payload data of the first MDPS data unit. During this operation MDH stores various state information of the reversal operation in the table entry that is identified in step . One example of such state information is certain portions of the payload data in the first MDPS data unit instead of being processed in the first MDPS data unit are grouped with the payload data of the subsequent MDPS data units to be processed with the subsequent MDPS data units. More specifically for decompressing payload data that are of the ZIP format MDH maintains at least a sliding window of a certain size of the payload data such as 32 kilobytes in the table entry. In other words to decompress the payload data of a current MDPS data unit the sliding window of data resulting from the processing of the immediately preceding MDPS data unit is considered. According to the embodiment of MDH shown in and continuing with the hello.exe example shown in MDH also invokes level data handler in step . The invoked level data handler reserves at least one FIFO buffer such as FIFO buffer and invokes at least one data processing block such as reversal operation type A to perform base64 decoding on the MDPS data unit in step . Moreover prior to the completion of the base64 decoding of the entire first MDPS data unit by reversal operation type A MDH searches the decoded results in FIFO buffer for another distinct data type in step . Because MDH has the knowledge of the file name of the compressed hello.exe file .zip MDH looks for certain patterns that are representative of a particular zip compression methods in the decoded results. For example if MDH finds the characters PK and other parameter values that are known to be used in PKZIP then MDH confirms that another distinct data type PKZIPPED data exists at this level and proceeds to increment the level variable n by 1 in step . Then MDH invokes level data handler which retrieves information if any from the table entry in stable table shown in that corresponds to the MDPS Session ID of happy in step before invoking reversal operation type B to perform PKUNZIP operations on the first MDPS data unit in step .

Following the same process discussed above MDH continues to invoke single level data handlers for different levels of processing if MDH continues to identify distinct data types and has not exceeded a threshold number of iterations of extracting a data type and utilizing appropriate resources for such data type. Thus prior to the completion of the PKUNZIP operation on the first MDPS data unit MDH increments level variable n by 1 and invokes reversal operation type C not shown in in step to unarchive the first MDPS data unit of File .tar.gz shown in . The use of this threshold number in step is one method of avoiding performing an unusually large number of reverse operations. After all the multiple levels of processing MDH places the results in output queue as shown in . One embodiment of content inspection engine retrieves data from output queue and inspects the data on a data unit by data unit basis for suspicious patterns.

Host processor can either be a general purpose processor or a specific purpose processor. Some examples of a specific purpose processor are processors that are designed for without limitation data communications signal processing mobile computing and multimedia related applications. Specific purpose processors may include interfaces that other external units such as memory system and CICP can directly connect to.

CICP can be implemented as an application specific integrated circuit ASIC as software to be programmed in a programmable logic device or even as a functional unit in a system on chip SOC . One or more of the components illustrated in can be added e.g. display device combined e.g. CICP and host processor can reside on a single SOC or further divided e.g. bridge can be further divided into a host processor bridge a bus controller and a memory controller and still remain within the claimed scope of the present invention.

High speed I O bridge manages the data intensive pathways and supports high speed peripherals such as without limitation a content inspection system that includes the aforementioned CICP shown in display gigabit Ethernet fiber channel and Redundant Array of Independent Disks RAID . High speed I O bridge is also coupled with secondary I O bridge which supports secondary peripherals such as without limitation disk controllers Universal Serial Bus USB audio serial system Basic Input Output System BIOS the Industry Standard Architecture ISA bus the interrupt controller and the Intelligent Driver Electronics IDE channels.

Server system carries out the operations of the illustrated transport service users and and protocol parser shown in by having processor execute one or more sequences of one or more instructions contained in memory modules . Such instructions may be read into main memory modules from another computer readable medium such as a storage device via secondary I O bridge . Execution of the sequences of instructions contained in memory modules causes processor to perform the steps discussed in Section 1.1 above. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the aforementioned operations.

The term computer readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks. Volatile media includes dynamic memory.

In the foregoing specification the present invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

