---

title: Architecture for supporting sparse volumes
abstract: An architecture, including a file-level protocol, for supporting sparse volumes on a storage system is provided. The file-level protocol provides coherency checking for use in retrieving data stored on a backing store remote from a storage system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07689609&OS=07689609&RS=07689609
owner: NetApp, Inc.
number: 07689609
owner_city: Sunnyvale
owner_country: US
publication_date: 20060424
---
The present application claims the benefit of U.S. Provisional Patent Application Ser. No. 60 674 641 which was filed on Apr. 25 2005 by Jason Ansel Lango for a Architecture For Supporting Sparse Volumes and is hereby incorporated by reference.

This application is related to U.S. patent application Ser. No. 11 409 887 entitled SYSTEM AND METHOD FOR SPARSE VOLUMES by Jason Lango et al the contents of which are hereby incorporated by reference.

The present invention relates to file systems and more specifically to a protocol for use with a file system that includes volumes having one or more files with blocks that require a special operation to retrieve data associated therewith from a remote backing store.

A storage system typically comprises one or more storage devices into which information may be entered and from which information may be obtained as desired. The storage system includes a storage operating system that functionally organizes the system by inter alia invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including but not limited to a network attached storage environment a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array wherein the term disk commonly describes a self contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive HDD or direct access storage device DASD .

Storage of information on the disk array is preferably implemented as one or more storage volumes of physical disks defining an overall logical arrangement of disk space. The disks within a volume are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of redundant information parity with respect to the striped data. The physical disks of each RAID group may include disks configure to store striped data i.e. data disks and disks configure to store parity for the data i.e. parity disks . The parity may thereafter be retrieved to enable recovery of data lost when a disk fails. The term RAID and its various implementations are well known and disclosed in by D. A. Patterson G. A. Gibson and R. H. Katz Proceedings of the International Conference on Management of Data SIGMOD June 1988.

The storage operating system of the storage system may implement a high level module such as a file system to logically organize the information stored on the disks as a hierarchical structure of directories files and blocks. For example each on disk file may be implemented as set of data structures i.e. disk blocks configured to store information such as the actual data for the file. These data blocks are organized within a volume block number vbn space. The file system which controls the use and contents of blocks within the vbn space organizes the data blocks within the vbn space as a logical volume each logical volume may be although is not necessarily associated with its own file system. The file system typically consists of a contiguous range of vbns from zero to n 1 for a file system of size n blocks.

A known type of file system is a write anywhere file system that does not over write data on disks. If a data block is retrieved read from disk into a memory of the storage system and dirtied i.e. updated or modified with new data the data block is thereafter stored written to a new location on disk to optimize write performance. A write anywhere file system may also opt to maintain a near optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations particularly for sequential read operations directed to the disks. An example of a write anywhere file system that is configure to operate on a storage system is the Write Anywhere File Layout WAFL file system available from Network Appliance Inc. Sunnyvale Calif.

The storage operating system may further implement a storage module such as a RAID system that manages the storage and retrieval of the information to and from the disks in accordance with input output I O operations. The RAID system is also responsible for parity operations in the storage system. Note that the file system only sees the data disks within its vbn space the parity disks are hidden from the file system and thus are only visible to the RAID system. The RAID system typically organizes the RAID groups into one large physical disk i.e. a physical volume such that the disk blocks are concatenated across all disks of all RAID groups. The logical volume maintained by the file system is then disposed over spread over the physical volume maintained by the RAID system.

The storage system may be configure to operate according to a client server model of information delivery to thereby allow many clients to access the directories files and blocks stored on the system. In this model the client may comprise an application such as a database application executing on a computer that connects to the storage system over a computer network such as a point to point link shared local area network wide area network or virtual private network implemented over a public network such as the Internet. Each client may request the services of the file system by issuing file system protocol messages in the form of packets to the storage system over the network. By supporting a plurality of file system protocols such as the conventional Common Internet File System CIFS and the Network File System NFS protocols the utility of the storage system is enhanced.

When accessing a block of a file in response to servicing a client request the file system specifies a vbn that is translated at the file system RAID system boundary into a disk block number dbn location on a particular disk disk dbn within a RAID group of the physical volume. It should be noted that a client request is typically directed to a specific file offset which is then converted by the file system into a file block number fbn which represents an offset into a particular file. For example if a file system is using 4 KB blocks fbn of a file represents a block of data starting 24 KB into the file and extending to 28 KB where fbn begins. The fbn is converted to an appropriate vbn by the file system. Each block in the vbn space and in the dbn space is typically fixed e.g. 4 k bytes kB in size accordingly there is typically a one to one mapping between the information stored on the disks in the dbn space and the information organized by the file system in the vbn space. The disk dbn location specified by the RAID system is further translated by a disk driver system of the storage operating system into a plurality of sectors e.g. a 4 kB block with a RAID header translates to 8 or 9 disk sectors of 512 or 520 bytes on the specified disk.

The requested block is then retrieved from disk and stored in a buffer cache of the memory as part of a buffer tree of the file. The buffer tree is an internal representation of blocks for a file stored in the buffer cache and maintained by the file system. Broadly stated the buffer tree has an inode at the root top level of the file. An inode is a data structure used to store information such as metadata about a file whereas the data blocks are structures used to store the actual data for the file. The information contained in an inode may include e.g. ownership of the file access permission for the file size of the file file type and references to locations on disk of the data blocks for the file. The references to the locations of the file data are provided by pointers which may further reference indirect blocks that in turn reference the data blocks depending upon the quantity of data in the file. Each pointer may be embodied as a vbn to facilitate efficiency among the file system and the RAID system when accessing the data on disks.

The RAID system maintains information about the geometry of the underlying physical disks e.g. the number of blocks in each disk in raid labels stored on the disks. The RAID system provides the disk geometry information to the file system for use when creating and maintaining the vbn to disk dbn mappings used to perform write allocation operations and to translate vbns to disk locations for read operations. Block allocation data structures such as an active map a snapmap a space map and a summary map are data structures that describe block usage within the file system such as the write anywhere file system. These mapping data structures are independent of the geometry and are used by a write allocator of the file system as existing infrastructure for the logical volume. Examples of the block allocation data structures are described in U.S. Patent Application Publication No. US2002 0083037 A1 titled Instant Snapshot by Blake Lewis et al. and published on Jun. 27 2002 which application is hereby incorporated by reference.

The write anywhere file system typically performs write allocation of blocks in a logical volume in response to an event in the file system e.g. dirtying of the blocks in a file . When write allocating the file system uses the block allocation data structures to select free blocks within its vbn space to which to write the dirty blocks. The selected blocks are generally in the same positions along the disks for each RAID group i.e. within a stripe so as to optimize use of the parity disks. Stripes of positional blocks may vary among other RAID groups to e.g. allow overlapping of parity update operations. When write allocating the file system traverses a small portion of each disk corresponding to a few blocks in depth within each disk to essentially lay down a plurality of stripes per RAID group. In particular the file system chooses vbns that are on the same stripe per RAID group during write allocation using the vbn to disk dbn mappings.

During storage system operation a volume or other data container such as a file or directory may become corrupted due to e.g. physical damage to the underlying storage devices software errors in the storage operating system executing on the storage system or an improperly executing application program that modifies data in the volume. In such situations an administrator may want to ensure that the volume is promptly mounted and exported so that it is accessible to clients as quickly as possible this requires that the data in the volume which may be substantial be recovered as soon as possible. Often the data in the volume may be recovered by e.g. reconstructing the data using stored parity information if the storage devices are utilized in a RAID configuration. Here reconstruction may occur on the fly resulting in virtually no discernable time where the data is not accessible.

In other situations reconstruction of the data may not be possible. As a result the administrator has several options one of which is to initiate a direct copy of the volume from a point in time image stored on another storage system. In the general case all volume data and metadata must be copied prior to resuming normal operations as a guarantee of application consistency. However such brute force data copying is generally inefficient as the time required to transfer substantial amounts of data e.g. terabytes may be on the order of days. Similar disadvantages are associated with restoring data from a tape device or other offline data storage. Another option that enables an administrator to rapidly mount and export a volume is to generate a hole filled volume wherein the contents of the volume are holes . In this context holes are manifested as entire blocks of zeros or other predefined pointer values stored within the buffer tree structure of a volume. An example of the use of such holes is described in the U.S. Pat. No. 7 457 982 issued on Jun. 27 2008 entitled WRITABLE READ ONLY SNAPSHOTS by Vijayan Rajan the contents of which are hereby incorporated by reference.

In such a hole filled environment the actual data is not retrieved from a backing store until requested by a client. However a noted disadvantage of such a hole based technique is that repeated write operations are needed to generate the appropriate number of zero filled blocks on disk for the volume. That is the use of holes to implement a data container that requires additional retrieval operations to retrieve data further requires that the entire buffer tree of a file and or volume be written to disk during creation. The time required to perform the needed write operations may be substantial depending on the size of the volume or file. Thus the creation of a hole filled volume is oftentimes impractical due to the need for quick data access to a volume.

A storage environment in which there is typically a need to quickly bring back a volume involves the use of a near line storage server. As used herein the term near line storage server means a secondary storage system adapted to store data forwarded from one or more primary storage systems typically for long term archival purposes. The near line storage server may be utilized in such a storage environment to provide a back up of data storage e.g. a volume served by each primary storage system. As a result the near line storage server is typically optimized to perform bulk data restore operations but suffers reduced performance when serving individual client data access requests. This latter situation may arise where a primary storage system encounters a failure that damages its volume in such a manner that a client must send its data access requests to the server in order to access data in the volume. This situation also forces the clients to reconfigure with appropriate network addresses associated with the near line storage server to enable such data access.

The present invention overcomes the disadvantages of the prior art by providing a system and method for supporting a sparse volume within a file system of a storage system. As used herein a sparse volume contains one or more files with at least one data block i.e. an absent block that is not stored locally on disk coupled to the storage system. By not storing the data block or a block of zeros as in a hole environment the sparse volume may be generated and exported quickly with minimal write operations required. The missing data of an absent block is stored on an alternate possibly remote source e.g. a backing store and is illustratively retrieved using a remote fetch operation.

A storage operating system executing on the storage system includes a novel NRV NetApp Remote Volume protocol module that implements an NRV protocol. The NRV protocol module interfaces with the file system to provide remote retrieval from the backing store. The NRV protocol module is invoked by an exemplary Load Block function within the file system that determines whether a block is to be retrieved from the remote backing store.

The Load Block function initiates a series of NRV protocol requests to the backing store to retrieve the data. The NRV protocol module first authenticates the connection and then transmits an initialization request to match the appropriate information required at the beginning of the connection. Once the NRV protocol connection has been initialized and authenticated various types of data may be retrieved from the backing store including for example information relating to volumes blocks and files or other data containers stored on the backing store. Additionally the NRV protocol provides a mechanism to remotely lock a persistent consistency point image PCPI or snapshot a lock PCPI request on the backing store so that the backing store does not modify or delete the PCPI until it is unlocked via an unlock command an unlock PCPI request . Such locking may be utilized when the backing store is instantiated within a PCPI that is required for a long lived the application on the storage system such as a restore on demand application. The novel NRV protocol also includes commands for retrieving status information such as volume information from the backing store. This may be accomplished by sending a VOLINFO request to the backing store identifying the particular volume of interest

In the illustrative embodiment the memory comprises storage locations that are addressable by the processor and adapters for storing software program code. A portion of the memory may be further organized as a buffer cache for storing certain data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. Storage operating system portions of which are typically resident in memory and executed by the processing elements functionally organizes the system by inter alia invoking storage operations executed by the storage system. It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the invention described herein.

The network adapter comprises the mechanical electrical and signaling circuitry needed to connect the storage system to a client over a computer network which may comprise a point to point connection or a shared medium such as a local area network LAN or wide area network WAN . Illustratively the computer network may be embodied as an Ethernet network or a Fibre Channel FC network. The client may communicate with the storage system over network by exchanging discrete frames or packets of data according to pre defined protocols such as the Transmission Control Protocol Internet Protocol TCP IP .

The client may be a general purpose computer configured to execute applications . Moreover the client may interact with the storage system in accordance with a client server model of information delivery. That is the client may request the services of the storage system and the system may return the results of the services requested by the client by exchanging packets over the network . The clients may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over TCP IP when accessing information in the form of files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of blocks.

The storage adapter cooperates with the storage operating system executing on the system to access information requested by a user or client . The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks such as HDD and or DASD of array . The storage adapter includes input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance FC serial link topology.

Storage of information on array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.

Additionally a second storage system is operatively interconnected with the network . The second storage system may be configured as a remote backing store server or illustratively a near line storage server. The storage system generally comprises hardware similar to storage system however it may alternatively execute a modified storage operating system that adapts the storage system for use as a near line storage server. It should be noted that in alternate embodiments multiple storage systems may be utilized.

To facilitate access to the disks the storage operating system implements a write anywhere file system that cooperates with virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each on disk file may be implemented as set of disk blocks configure to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization modules allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such where the term WAFL is employed it should be taken broadly to refer to any file system that is otherwise adaptable to the teachings of this invention.

An iSCSI driver layer provides block protocol access over the TCP IP network protocol layers while a FC driver layer receives and transmits block access requests and responses to and from the storage system. The FC and iSCSI drivers provide FC specific and iSCSI specific access control to the blocks and thus manage exports of luns to either iSCSI or FCP or alternatively to both iSCSI and FCP when accessing the blocks on the storage system. In addition the storage operating system includes a storage module embodied as a RAID system that manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations and a disk driver system that implements a disk access protocol such as e.g. the SCSI protocol. The storage operating system further comprises an NRV protocol layer that interfaces with file system . The NRV protocol is generally utilized for remote fetching of data blocks that are not stored locally on disk. However as described further below the NRV protocol may be further utilized in storage appliance to storage appliance communication to fetch absent blocks in a sparse volume in accordance with the principles of the present invention.

Bridging the disk software layers with the integrated network protocol stack layers is a virtualization system that is implemented by a file system interacting with virtualization modules illustratively embodied as e.g. vdisk module and SCSI target module . The vdisk module is layered on the file system to enable access by administrative interfaces such as a user interface UI in response to a user system administrator issuing commands to the storage system. The SCSI target module is disposed between the FC and iSCSI drivers and the file system to provide a translation layer of the virtualization system between the block lun space and the file system space where luns are represented as blocks. The UI is disposed over the storage operating system in a manner that enables administrative or user access to the various layers and systems.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as disks. That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as mirroring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte kB blocks and using index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . The file system uses files to store metadata describing the layout of its file system these metadata files include among others an inode file. A file handle i.e. an identifier that includes an inode number is used to retrieve an inode from disk.

Broadly stated all inodes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The inode of the root fsinfo block may directly reference point to blocks of the inode file or may reference indirect blocks of the inode file that in turn reference direct blocks of the inode file. Within each direct block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

Operationally a request from the client is forwarded as a packet over the computer network and onto the storage system where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . Here the file system generates operations to load retrieve the requested data from disk if it is not resident in core i.e. in the buffer cache . Illustratively this operation may be embodied as a Load Block function of the file system . If the information is not in the cache the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in buffer cache for processing by the storage system. Upon completion of the request the storage system and operating system returns a reply to the client over the network .

The file system illustratively provides the Load Block function to retrieve one or more blocks of data from disk. A block may be retrieved in response to a read request or may be retrieved in response to an exemplary read ahead algorithm. The illustrative Load Block function attempts to load a requested block of data. The Load Block function initiates transfer of a fetch operation to an appropriate backing store using the illustrative NRV protocol if any blocks require data to be remotely retrieved. Once the data has been retrieved the Load Block function returns with the requested data. Sparse volumes and ABSENT block pointers are further described in the above referenced U.S. Patent Application entitled SYSTEM AND METHOD FOR SPARSE VOLUMES by Jason Lango et al. It should be noted that the use of the NRV protocol for remote retrieval of data for sparse volumes is exemplary and that the novel NRV protocol described herein may be utilized for other types of remote data retrieval. As such the illustrative embodiment of utilizing the NRV protocol for retrieving sparse volumes data should be taken as exemplary only and should not limit the scope of the present invention.

Additionally in the illustrative embodiment the file system provides a Load Inode function to retrieve an inode from disk. In the illustrative embodiment the Load Inode function is adopted to obtain appropriate file geometry information as described further below. In the illustrative embodiment a sparse configuration metadata file is stored on the storage system. The sparse configuration metadata file includes appropriate configuration information to enable data retrieval from a backing store. Such information may include identification information of the remote backing store along with an identification of what data container s on the backing store are to be utilized as the backing store. In the illustrative embodiment a sparse volume may be supported by a plurality of backing stores.

It should be further noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the storage system may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by storage system in response to a request issued by client . Moreover in another alternate embodiment of the invention the processing elements of adapters may be configure to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the system. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable to perform a storage function in a storage system e.g. that manages data access and may in the case of a file server implement file system semantics. In this sense the ONTAP software is an example of such a storage operating system implemented as a microkernel and including the WAFL layer to implement the WAFL file system semantics and manage data access. The storage operating system can also be implemented as an application program operating over a general purpose operating system such as UNIX or Windows NT or as a general purpose operating system with configurable functionality which is configure for storage applications as described herein.

In addition it will be understood to those skilled in the art that the inventive technique described herein may apply to any type of special purpose e.g. file server filer or multi protocol storage appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system . An example of a multi protocol storage appliance that may be advantageously used with the present invention is described in U.S. Patent Publication No. 2004 0030668 published Feb. 12 2004 titled MULTI PROTOCOL STORAGE APPLIANCE THAT PROVIDES INTEGRATED SUPPORT FOR FILE AND BLOCK ACCESS PROTOCOLS by Pawlowski et al. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configure to perform a storage function and associated with other equipment or systems.

In the illustrative embodiment a file is represented in the write anywhere file system as an inode data structure adapted for storage on the disks . is a schematic block diagram of an inode which preferably includes a metadata section and a data section . The information stored in the metadata section of each inode describes the file and as such includes the type e.g. regular directory virtual disk of file the size of the file time stamps e.g. access and or modification for the file and ownership i.e. user identifier UID and group ID GID of the file. The contents of the data section of each inode however may be interpreted differently depending upon the type of file inode defined within the type field . For example the data section of a directory inode contains metadata controlled by the file system whereas the data section of a regular inode contains file system data. In this latter case the data section includes a representation of the data associated with the file.

Specifically the data section of a regular on disk inode may include file system data or pointers the latter referencing 4 kilobyte KB data blocks on disk used to store the file system data. Each pointer is preferably a logical vbn to facilitate efficiency among the file system and the RAID system when accessing the data on disks. Given the restricted size e.g. 128 bytes of the inode file system data having a size that is less than or equal to 64 bytes is represented in its entirety within the data section of that inode. However if the file system data is greater than 64 bytes but less than or equal to 64 KB then the data section of the inode e.g. a first level inode comprises up to 16 pointers each of which references a 4 KB block of data on the disk.

Moreover if the size of the data is greater than 64 KB but less than or equal to 64 megabytes MB then each pointer in the data section of the inode e.g. a second level inode references an indirect block e.g. a first level block that contains 1024 pointers each of which references a 4 KB data block on disk. For file system data having a size greater than 64 MB each pointer in the data section of the inode e.g. a third level inode references a double indirect block e.g. a second level block that contains 1024 pointers each referencing an indirect e.g. a first level block. The indirect block in turn that contains 1024 pointers each of which references a 4 KB data block on disk. When accessing a file each block of the file may be loaded from disk into the buffer cache .

When an on disk inode or block is loaded from disk into buffer cache its corresponding in core structure embeds the on disk structure. For example the dotted line surrounding the inode indicates the in core representation of the on disk inode structure. The in core structure is a block of memory that stores the on disk structure plus additional information needed to manage data in the memory but not on disk . The additional information may include e.g. a dirty bit . After data in the inode or block is updated modified as instructed by e.g. a write operation the modified data is marked dirty using the dirty bit so that the inode block can be subsequently flushed stored to disk. The in core and on disk format structures of the WAFL file system including the inodes and inode file are disclosed and described in the previously incorporated U.S. Pat. No. 5 819 292 titled METHOD FOR MAINTAINING CONSISTENT STATES OF A FILE SYSTEM AND FOR CREATING USER ACCESSIBLE READ ONLY COPIES OF A FILE SYSTEM by David Hitz et al. issued on Oct. 6 1998.

A file system layout is provided that apportions an underlying physical volume into one or more virtual volumes vvols of a storage system. An example of such a file system layout is described in U.S. Pat. No. 7 409 494 issued on Aug. 5 2008 titled EXTENSION OF WRITE ANYWHERE FILE SYSTEM LAYOUT by John K. Edwards et al. The underlying physical volume is an aggregate comprising one or more groups of disks such as RAID groups of the storage system. The aggregate has its own physical volume block number pvbn space and maintains metadata such as block allocation structures within that pvbn space. Each vvol has its own virtual volume block number vvbn space and maintains metadata such as block allocation structures within that vvbn space. Each vvol is a file system that is associated with a container file the container file is a file in the aggregate that contains all blocks used by the vvol. Moreover each vvol comprises data blocks and indirect blocks that contain block pointers that point at either other indirect blocks or data blocks.

In one embodiment pvbns are used as block pointers within buffer trees of files such as file stored in a vvol. This hybrid vvol embodiment involves the insertion of only the pvbn in the parent indirect block e.g. inode or indirect block . On a read path of a logical volume a logical volume vol info block has one or more pointers that reference one or more fsinfo blocks each of which in turn points to an inode file and its corresponding inode buffer tree. The read path on a vvol is generally the same following pvbns instead of vvbns to find appropriate locations of blocks in this context the read path and corresponding read performance of a vvol is substantially similar to that of a physical volume. Translation from pvbn to disk dbn occurs at the file system RAID system boundary of the storage operating system .

In an illustrative dual vbn hybrid flexible vvol embodiment both a pvbn and its corresponding vvbn are inserted in the parent indirect blocks in the buffer tree of a file. That is the pvbn and vvbn are stored as a pair for each block pointer in most buffer tree structures that have pointers to other blocks e.g. level L indirect blocks inode file level L blocks. is a schematic block diagram of an illustrative embodiment of a buffer tree of a file that may be advantageously used with the present invention. A root top level inode such as an embedded inode references indirect e.g. level blocks . Note that there may be additional levels of indirect blocks e.g. level level depending upon the size of the file. The indirect blocks and inode contain pvbn vvbn pointer pair structures that ultimately reference data blocks used to store the actual data of the file.

The pvbns reference locations on disks of the aggregate whereas the vvbns reference locations within files of the vvol. The use of pvbns as block pointers in the indirect blocks provides efficiencies in the read paths while the use of vvbn block pointers provide efficient access to required metadata. That is when freeing a block of a file the parent indirect block in the file contains readily available vvbn block pointers which avoids the latency associated with accessing an owner map to perform pvbn to vvbn translations yet on the read path the pvbn is available.

As noted each inode has 64 bytes in its data section that depending upon the size of the inode file e.g. greater than 64 bytes of data function as block pointers to other blocks. For traditional and hybrid volumes those 64 bytes are embodied as 16 block pointers i.e. sixteen 16 4 byte block pointers. For the illustrative dual vbn flexible volume the 64 bytes of an inode are embodied as eight 8 pairs of 4 byte block pointers wherein each pair is a vvbn pvbn pair. In addition each indirect block of a traditional or hybrid volume may contain up to 1024 pvbn pointers each indirect block of a dual vbn flexible volume however has a maximum of 510 pvbn vvbn pairs of pointers.

Moreover one or more of pointers may contain a special ABSENT value to signify that the object s e.g. an indirect block or data block referenced by the pointer s is not locally stored e.g. on the volume and thus must be fetched retrieved from an alternate backing store. In the illustrative embodiment the Load Block function interprets the content of the each pointer and if a requested block is ABSENT initiates transmission of an appropriate request e.g. a remote fetch operation for the data to a backing store using e.g. the novel NRV protocol of the present invention.

Whereas the aggregate is analogous to a physical volume of a conventional storage system a vvol is analogous to a file within that physical volume. That is the aggregate may include one or more files wherein each file contains a vvol and wherein the sum of the storage space consumed by the vvols is physically smaller than or equal to the size of the overall physical volume. The aggregate utilizes a physical pvbn space that defines a storage space of blocks provided by the disks of the physical volume while each embedded vvol within a file utilizes a logical vvbn space to organize those blocks e.g. as files. Each vvbn space is an independent set of numbers that corresponds to locations within the file which locations are then translated to dbns on disks. Since the vvol is also a logical volume it has its own block allocation structures e.g. active space and summary maps in its vvbn space.

A container file is a file in the aggregate that contains all blocks used by a vvol. The container file is an internal to the aggregate feature that supports a vvol illustratively there is one container file per vvol. Similar to a pure logical volume in a file approach the container file is a hidden file not accessible to a user in the aggregate that holds every block in use by the vvol. The aggregate includes an illustrative hidden meta data root directory that contains subdirectories of vvols 

Specifically a physical file system WAFL directory includes a subdirectory for each vvol in the aggregate with the name of subdirectory being a file system identifier fsid of the vvol. Each fsid subdirectory vvol contains at least two files a filesystem file and a storage label file. The storage label file is illustratively a 4 kB file that contains metadata similar to that stored in a conventional raid label. In other words the storage label file is the analog of a raid label and as such contains information about the state of the vvol such as e.g. the name of the vvol a universal unique identifier uuid and fsid of the vvol whether it is online being created or being destroyed etc.

In addition to being embodied as a container file having level blocks organized as a container map the filesystem file includes block pointers that reference various file systems embodied as vvols . The aggregate maintains these vvols at special reserved inode numbers. Each vvol also has special reserved inode numbers within its vvol space that are used for among other things the block allocation bitmap structures. As noted the block allocation bitmap structures e.g. active map summary map and space map are located in each vvol.

Specifically each vvol has the same inode file structure content as the aggregate with the exception that there is no owner map and no WAFL fsid filesystem file storage label file directory structure in a hidden metadata root directory . To that end each vvol has a volinfo block that points to one or more fsinfo blocks each of which may represent a snapshot along with the active file system of the vvol. Each fsinfo block in turn points to an inode file that as noted has the same inode structure content as the aggregate with the exceptions noted above. Each vvol has its own inode file and distinct inode space with corresponding inode numbers as well as its own root fsid directory and subdirectories of files that can be exported separately from other vvols.

The storage label file contained within the hidden metadata root directory of the aggregate is a small file that functions as an analog to a conventional raid label. A raid label includes physical information about the storage system such as the volume name that information is loaded into the storage label file . Illustratively the storage label file includes the name of the associated vvol the online offline status of the vvol and other identity and state information of the associated vvol whether it is in the process of being created or destroyed .

A sparse volume is identified by a special marking of an on disk structure of the volume vvol to denote the inclusion of a file with an absent block. is a schematic block diagram of the on disk structure which illustratively is an exemplary fsinfo block . The fsinfo block includes a set of PCPI pointers a sparse volume flag field an inode for the inode file and in alternate embodiments additional fields . The PCIP pointers are dual vbn vvbn pvbn pairs of pointers to PCPIs associated with the file system. The sparse volume flag field identifies whether the vvol described by the fsinfo block is sparse. In the illustrative embodiment a flag is asserted in field to identify the volume as sparse. The sparse volume flag field may be embodied as a type field identifying the type of a vvol associated with the fsinfo block. The inode for the inode file includes the inode containing the root level pointers to the inode file of the file system associated with the fsinfo block.

Appropriate block pointer s of the file are marked labeled with special ABSENT value s to identify that certain block s including data and or indirect blocks within the sparse volume are not physically located on the storage system serving the volume. The special value further alerts the file system that the data is to be obtained from the alternate source namely a remote backing store which is illustratively near line storage server . In response to a data access request the Load Block function of the file system detects whether an appropriate block pointer of a file is marked as is ABSENT and if so transmits a remote fetch e.g. read operation from the storage system to the remote backing store to fetch the required data. The fetch operation illustratively requests one or more file block numbers of the file stored on the backing store.

The backing store retrieves the requested data from its storage devices and returns the requested data to the storage system which processes the data access request and stores the returned data in its memory. Subsequently the file system flushes writes the data stored in memory to local disk during a write allocation procedure. In accordance with an illustrative write anywhere policy of the procedure the file system assigns pointer values other than ABSENT values to indirect block s of the file to thereby identify location s of the data stored locally within the volume. Thus the remote fetch operation is no longer needed to access the data.

An example of a write allocation procedure that may be advantageously used with the present invention is described in U.S. Pat. No. 7 430 571 issued on Sep. 30 2008 titled Extension of Write Anywhere File Layout Write Allocation by John K. Edwards and assigned to Network Appliance Inc. which application is hereby incorporated by reference. Broadly stated block allocation proceeds in parallel on the flexible vvol and aggregate when write allocating a block within the vvol with a write allocator process selecting an actual pvbn in the aggregate and a vvbn in the vvol. The write allocator adjusts block allocation bitmap structures such an active map and space map of the aggregate to record the selected pvbn and adjusts similar structures of the vvol to record the selected vvbn. A vvid of the vvol and the vvbn are inserted into owner map of the aggregate at an entry defined by the selected pvbn. The selected pvbn is also inserted into a container map not shown of the destination vvol. Finally an indirect block or mode file parent of the allocated block is updated with one or more block pointers to the allocated block. The content of the update operation depends on the vvol embodiment. For the dual vbn hybrid vvol embodiment both the pvbn and vvbn are inserted in the indirect block or mode as block pointers.

In the illustrative embodiment the storage operating system utilizes the novel NRV protocol to retrieve ABSENT blocks from a remote storage system configured to act as a backing store for a sparse volume. It should be noted that the novel NRV protocol may also be utilized to retrieve non ABSENT blocks from the backing store. Thus the NRV protocol may be utilized to retrieve data in a file system that utilizes holes as described above. The NRV protocol typically utilizes the TCP IP protocol as a transport protocol and all NRV messages both requests and responses are prefixed with a framing header identifying the length of the NRV message in bytes exclusive of this length of the initial length header itself .

A response to the protocol request is in the format of a protocol response data structure which is illustratively shown as a schematic block diagram in . The response data structure includes header a NRV Status field a protocol status field and in alternate embodiments additional fields . The NRV Status field may include one of the protocol specific status indicators such as OK NOINIT VERSION CANTSEND LS and FS VERSION. It should be noted that in alternate embodiments other and or differing status indicators may be utilized. The OK status indicator signifies that the request was successful and that there is no error condition. The NOINIT indicator is sent in response to a request being transferred prior to beginning a session. In the illustrative embodiment an INIT request described further below must be the first request in a session after any authentication AUTH requests. The VERSION indicator is utilized when there are mismatched versions of the NRV protocol e.g. the storage system and backing store are utilizing incompatible versions of the NRV protocol. The CANTSEND indicator indicates a failure of the underlying transport protocol in transmitting a particular request or response. The LS status indicator is used by the backing store to indicate that a PCPI was not able to be locked in response to a LOCK PCPI request described further below. The FS VERSION indicator means that the storage system and the backing store are utilizing incompatible versions of a file system so that data may not be retrieved from the backing store.

The protocol status field includes a file system error value. Thus the protocol status field may be utilized to transfer a WAFL file system or other file system error value between the backing store and the storage appliance. Each of the NRV protocol operations that includes a response data structure includes a type specific data structure that is appended to the end of a protocol response data structure .

Many NRV protocol requests and or responses include a file handle identifying a file to which an operation is directed. is a schematic block diagram of a file handle data structure in accordance with an embodiment of the present invention. The file handle data structure includes a file system ID field a PCPI ID field a file ID field a generation field and in alternate embodiments additional fields . The file system ID field identifies the particular file system containing the file of interest. This may be a particular virtual volume or physical volume associated with the backing store. This field typically contains the fsid of the desired volume The PCPI ID field identifies the appropriate PCPI associated with the file. Thus the NRV protocol permits access to a file stored within a particular PCPI. File ID field identifies the unique file ID associated with the file. The generation field contains a value identifying a particular generation of the inode associated with the file.

Additionally many NRV requests and responses contain a set of file attributes that are contained within an exemplary file attribute data structure as shown in a schematic block diagram of . The file attribute data structure includes a blocks field a size field a type field a subtype field a generation field a user identifier UID field a group identifier field GID a creation time field and in alternate embodiments additional fields . The blocks field identifies the number of blocks utilized by the file. The size field contains the size of the file in bytes. The type and subtype fields identify the type and if necessary a subtype of the file. The generation field identifies the current generation number associated with the inode of the file. The UID field identifies the owner of the file whereas the GID field identifies the current group that is associated with the file.

In accordance with the illustrative embodiment of the protocol the first request sent over a connection after any authentication requests described further below is an initialization request. This initialization request i.e. an INIT type of type field comprises an initialization data structure which is exemplary shown as a schematic block diagram in . The initialization data structure includes a protocol request data structure a protocol version field an application field a byte order field and in alternate embodiments additional fields . The request data structure is described above in reference to . The protocol version field contains a protocol minor version in use at the client storage appliance initiating the connection that identifies clients utilizing different versions of the protocol. The application field identifies the application utilizing the NRV protocol such applications may include restore on demand ROD or proxy file system PFS . Restore on demand techniques are further described in U.S. Patent Publication No. 2007 0124341 published on May 31 2007 entitled SYSTEM AND METHOD FOR RESTORING DATA ON DEMAND FOR INSTANT VOLUME RESTORATION by Jason Lango et al. and proxy file systems are further described in U.S. Patent Publication No. 2007 0250552 published on Oct. 25 2007 entitled SYSTEM AND METHOD FOR CACHING NETWORK FILE SYSTEMS by Jason Lango et al. The byte order field identifies the client s native byte order e.g. big or little endian.

In response to the initialization request data structure the backing store transmits an initialization response data structure which is illustratively shown in a schematic block diagram of . The initialization response data structure includes a protocol response data structure a file system version field a byte order field and in alternate embodiments additional fields . The response data structure is described above in reference to . The file system version field identifies the maximum file system version supported by the backing store. The byte order field identifies the backing store s native byte order. In the protocol specification if the storage system s and backing store s byte orders differ all future communication occurs using the backing store s of byte order as defined in field .

To retrieve information pertaining to a particular volume the storage appliance may transmit a volume information VOLINFO request data structure which is shown as a schematic block diagram of . The volume information data structure includes a protocol request data structure a name length field a volume name field at and in alternate embodiments additional fields . The name length field identifies length of the volume name field while the volume name field comprises a text string of the volume name. The VOLINFO request is utilized to obtain volume information which may be used to e.g. ensure that a volume on the storage system is sufficiently sized to accommodate all data located on a volume on the backing store.

In response to a volume information request the backing store will issue a volume information response data structure of which an exemplary schematic block diagram is shown in . The volume information response data structure comprises a protocol response data structure a root file handle field a maximum volume block number field a number of inodes used field a number of inodes field and in alternate embodiments additional fields . The root file handle field contains a conventional file handle for the root directory of the specified volume. The maximum volume block number field is set to the greatest allowable volume block number in the file system of the specified volume. The value of this field plus one is the size of the volume in blocks as in the illustrative embodiment volume block numbers begin with vbn . Thus in the illustrative embodiment of the WAFL file system which utilizes 4 KB blocks the value of this field plus one is the size of the volume in 4 KB blocks. The number of inodes used field contains number of inodes in use in the active file system of the specified volume whereas the number of inodes field holds the total number of allocable inodes in the active file system of the specified volume.

A read request response data structure is illustratively shown in . The read response data structure includes response data structure an end of file field a data field and in alternate embodiments additional fields . The response structure is described above in reference to . The end of file field identifies whether there is additional data to be read from the file and if not its content may be set to a FALSE value. Alternatively the field may be set to a TRUE value if the end of the file has been reached by the requested read operation. The data field is a variable number of bytes of data from the file starting at the requested file block number.

Another type of remote file system operation supported by the novel NRV protocol is the lock PCPI operation i.e. a LOCK PCPI type field that is used to prevent a PCPI from being deleted on the backing store. The Lock PCPI operation is typically utilized when the PCPI is necessary for a long lived application such as restore on demand. In the illustrative embodiment the locked PCPI command is an inherently stateful request that instructs the backing store to prevent deletion of the PCPI until either the client disconnects or unlocks the PCPI the latter with the unlocked PCPI command described further below . An exemplary LOCK PCPI request data structure is illustratively shown as a schematic block diagram in . The LOCK PCPI request data structure includes a request data structure a file system ID field a lock default PCPI field a checked PCPI configuration field a PCPI name length field a PCPI information field a PCPI name field and in alternate embodiments additional fields . The request data structure is described above in conjunction with . The file system ID field identifies the volume containing the PCPI to be locked. The lock default PCPI field may be set to a value of TRUE or FALSE. If it is set to TRUE then the backing store locks the default PCPI for the volume identified and ignores the name and information fields . If the value if FALSE then the values of these fields are utilized in identifying the PCPI. In certain embodiments the backing store may be configured to have a default PCPI for use in serving NRV protocols. This default PCPI may be selected by the use of the lock default PCPI field . The check PCPI configuration field may also be set to a value of TRUE or FALSE. If TRUE then the server verifies that the specified volume is an acceptable secondary volume for use in a sparse volume application. The PCPI name length field is set to the length of the PCPI name field which holds a string comprising the name of the PCPI to be locked.

The PCPI information field comprises a PCPI information data structure illustratively shown as a schematic block diagram of . The PCPI information data structure includes an identifier field a consistency point count field a PCPI creation time field a PCPI creation time in microseconds field and in alternate embodiments additional fields . The identifier field is a PCPI identifier that uniquely identifies a particular PCPI. The consistency point count field identifies a particular CP count associated with the PCPI. Illustratively at each CP the CP count is incremented thereby providing a unique label for the PCPI created at that point in time. Similarly the PCPI creation time fields are utilized to uniquely identify the particular PCPI by identifying its creation time in seconds and microseconds respectively.

In response the server sends a lock PCPI response data structure of which a schematic block diagram of which s shown in . The lock PCPI response data structure includes a response data structure PCPI information data structure a blocks used field a blocks holes field a blocks overwrite field a blocks holes CIFS field an inodes used field a total number of inodes field and in alternate embodiments additional fields . The response data structure is described above in reference to . The PCPI information data structure is described above in reference to . The blocks used field contains a value identifying the number of blocks that are utilized by the PCPI on the backing store. The blocks holes field identifies the number of blocks in the PCPI that are reserved for holes within the PCPI. The blocks overwrite field contains a value identifying the number of blocks that are reserved for overwriting in the PCPI. The inodes field contains a value identifying the number of inodes used in the PCPI and the total number of inodes field contains a value identifying the total number of allocable inodes in the PCPI.

Once a client no longer requires a PCPI to be locked it may issue an unlock PCPI command of type UNLOCK PCPI in field to the backing store. The client issues such a command by sending an unlock PCPI request data structure as illustratively shown in . The unlock PCPI command data structure includes a request data structure a file system ID field a PCPI ID field and in alternate embodiments additional fields . The requested data structure is described above in conjunction with . The file system identifier field identifies the volume containing the PCPI to the unlocked. The PCPI identifier field identifies the PCPI previously locked using LOCK PCPI request. In accordance with the protocol the server must unlocked the PCPI prior to responding to this command. The response to an unlock PCPI request is illustratively a zero length message body.

As noted above the first request issued over a protocol connection is a series of authentication requests i.e. a AUTH type of field . The authentication request is utilized for NRV session authentication and in the illustrative embodiment is preferably the first request issued over an NRV connection. The backing store and storage appliance may negotiate with any number of authentication request response pairs. An illustrative schematic block diagram of an authentication request data structure is shown in . The AUTH request data structure includes a request data structure a length field a type field an application field a data field and in alternate embodiments additional fields . The requested data structure is described above in conjunction with . The length field identifies the number of bytes contained within the data field . Type field identifies a type of authentication to be utilized. The application field identifies one of a plurality of applications that utilizes the protocol. The application utilizing the protocol is identified so that for example the backing store may impose higher or lower authentication and standards depending on the type of application utilizing the protocol. The data field contains authentication data.

In response the backing store sends an authentication response data structure as shown in . The authentication response data structure includes response data structure a status field a data field and in alternate embodiments additional fields . The response data structure is described above in reference to . The status field identifies the current status of the authentication e.g. OK signifying that authentication is complete or NEED AUTHENTICATION signifying that the backing store requests that the storage system transmit a higher level of authentication. The status field may also hold a value of CONTINUE which may be utilized if multiple exchanges are required to authenticate the session. The data field contains the authentication response data.

The NRV protocol also supports a get holy bitmap function i.e. a GET HOLY BITMAP type of field that identifies which if any blocks on a backing store are not present e.g. either absent or a hole. is a schematic block diagram of an exemplary GET HOLY BITMAP request data structure in accordance with an embodiment of the present invention. The request includes a protocol request data structure a file handle a cookie value and in alternate embodiments additional field . The protocol request data structure is described above in reference to . The file handle field contains a protocol file handle that identifies the file system ID snapshot ID and file ID of the file for which the bitmap is to be obtained. The cookie field contains one of two values. The first value is a predetermined value utilized for an initial request. The second value is the value of the last cookie value received from the backing store to be utilized for continued retrieval of bitmaps.

Network file system protocols typically provide information within the protocol so that clients may cache data to provide an accurate and consistent view of the file system. For example in the Network File System NFS Version 2 file attributes are sometimes returned along with operations thereby permitting clients to cache data as long as the attributes have not been modified. This was further improved in version 3 of NFS where many operations that modify the file system return attributes from before the operation as well as after the operation. This feature allows a client to recognize if its cached content was up to date before the operation was executed. If the cache content was accurate the client may update its cache by doing the update locally without invalidate its own cached content. This technique is known as pre post operation attributes.

Most file systems cache content based on a file s unique file handle. While most network operations in protocols that modify the file system have the necessary file handle in attributes allow the client to correctly update its cache there are some operations that do not include sufficient information. These operations typically reference files using a directory file handle and a file name which results in the client receiving a response from which it cannot determine which file was referenced and potentially modified. As a client cannot determine which file was referenced and or modified it is unable to ensure that its cache is consistent with the state of the file system. One advantage of the present invention is that the novel NRV protocol provides sufficient information to permit proper caching of any object modified on the origin server using any of these operations.

A remove response data structure is illustratively shown in . The remove response data structure illustratively includes a protocol response data structure a directory pre post attributes field a removed file handle field a removed file pre post attributes field and in alternate embodiments additional fields . The protocol response data structure is described above in reference to . The directory pre post attributes field contains the attributes for the directory both before and after the removal. These attributes permit clients to properly maintain their caches. The removed file handle field contains the file handle for the file that was removed while processing the remove operation. The removed file pre post attributes contains the attributes for the file prior to and following the removal operation.

In this illustrated example the storage appliance sends a READ request to the backing store in step . In response the backing store retrieves the requested data from its storage devices in step by for example retrieving the data from disk. The backing store then sends a READ response including the requested data to the storage to appliance in step . Upon receiving the requested data the storage appliance processes the retrieved data in step . The process then completes in step .

The storage appliance may then send a READ request to the backing store in step . In response the backing store retrieves the requested data from its storage devices in step and a sends a READ reply including the requested data to the storage appliance in step . It should be noted that during the course of the long lived application steps to may be repeated a plurality of times. Additionally alternate commands other than a READ request may be issued by the storage appliance to the backing store. In response to such alternate commands the backing store processes the received commands in accordance with the protocol specification as described above. At some point in time when the long lived application no longer requires the use of the particular PCPI the storage appliance sends an unlock PCPI request to the backing store step . In response the backing store unlocks the identified PCPI and sends an unlock PCPI reply to the storage appliance in step . The procedure then completes in step .

To again summarize the present invention is directed to system and method for supporting a sparse volume within a file system of a storage system. In accordance with the illustrative embodiment a storage operating system executing on a storage appliance includes a novel NRV protocol module that implements the NRV protocol. The NRV protocol module interfaces with the file system to provide remote retrieval of data from a backing store. The NRV protocol illustratively utilizes the TCP IP protocol as a transport protocol. The NRV protocol module is invoked by an exemplary Load Block function within a file system that determines whether a block is to be retrieved from the remote backing store. If so the Load Block function initiates a series of NRV protocol requests to the backing store to retrieve the data.

The NRV protocol module first authenticates the connection and then transmits an initialization request to match the appropriate information required at the beginning of the connection. Once the NRV protocol connection has been initialized and authenticated various types of data may be retrieved from the backing store including for example information relating to volumes blocks and files or other data containers stored on the backing store. Additionally the NRV protocol provides a mechanism to remotely lock a PCPI a lock PCPI request on the backing store so that the backing store does not modify or delete the PCPI until it is unlocked via an unlock command an unlock PCPI request sent via the NRV protocol. Such locking may be utilized when the backing store is instantiated within a PCPI that is required for a long lived the application on the storage appliance such as a restore on demand application. The novel NRV protocol also includes commands for retrieving status information such as volume information from the backing store. This may be accomplished by sending a VOLINFO request to the backing store identifying the particular volume of interest.

The present invention provides a NRV protocol that provides several noted advantages over using conventional open protocols. One noted advantage is the transparency of operations. Existing open protocols such as the network file system protocol NFS do not expose side effects file system operations such as that generated a rename operation which implicitly deletes a target file. Conventional protocols do not inform a client that the file handle of the file that has been deleted. However certain applications of the NRV protocol such as that described in United States Patent Publication No. 2007 0250552 entitled Proxy File System by Jason Lango or other file caching mechanisms is interested in such information to ensure that cache contents can be invalidated at the appropriate times. A second noted advantage is that the novel NRV protocol of the present invention exposes file system metadata. Conventional protocols such as NFS. do not expose file system specific metadata but rather normalizes the information into a standard format which may be lossy in that it does not convey some file system specific information. In one alternate embodiment of the present invention certain features of the NRV protocol may be implemented using a conventional open protocol coupled with an extension protocol that provides the desired functionality necessary for implementing sparse volumes. In such an environment an open protocol such as the NFS protocol would be coupled to the NRV protocol. In such an environment the NRV would be configured to utilize the NFS protocol for certain file system operations directed to a backing store.

The foregoing description has been directed to specific embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. For instance it is expressly contemplated that the teachings of this invention can be implemented as software including a computer readable medium having program instructions executing on a computer hardware firmware or a combination thereof. Accordingly this description is to be taken only by way of example and not to otherwise limit the scope of the invention. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

