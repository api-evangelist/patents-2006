---

title: Data schemata in programming language contracts
abstract: Systems and methods that integrate data type conversion(s) into a programming language, and describe external formats within a syntax thereof. A mapping component defines a declarative mapping from an external data format to one or more of its internal data types (e.g., expressing external data types in terms of source languages.) Moreover, a rule establishing component can define value-based rules, such as invariants to the external data format, wherein the schema declaration further defines data fields that make up the schema. Accordingly, by expressing rules in form of predicate logic (instead of imperative program logic) the subject innovation increase a likelihood that compilers can reason about the data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07934207&OS=07934207&RS=07934207
owner: Microsoft Corporation
number: 07934207
owner_city: Redmond
owner_country: US
publication_date: 20061219
---
The advent of global communications networks supplies users with access to significant amount of data. In general such free flow of information prevalent today in wired and wireless regimes demands that the source and destination be compatible insofar as storing and interpreting the data for use for example. The world is populated with information sources where in many cases the data can be represented differently from source to source.

Accordingly a major challenge facing companies and individuals today is that data existing in one model schema may be needed in a different model schema for another purpose. Conversion processes are being hampered by a largely disparate and ever changing set of models schemas. For example in data warehousing where data is received from many different sources for storage and quick access from other sources conversion processes can create difficulties. Converting data from one model to another model is not only time consuming and resource intensive but can be fraught with conversion problems.

Furthermore conventional data systems applications and operating systems have typically relied on multiple incompatible handling and exchange for data including the registry event log messages contact information and e mail or simply have used multiple flat files for data such as images and audio. For example in conventional data stores stored contents are in general treated as separate entities even though they are interrelated at some level. Accordingly when a large number of items and applications exist it can become important to have a flexible and efficient mechanism to exchange items between applications.

At the same time given new file systems that operate based on relational objects with an extensible data type new challenges can arise. For example in such environments a data model can play an important role in the way that participants interact with the database. Moreover a manner for which applications exchange store and retrieve data can be governed by the data model.

Interactions involved with data handling of such a data store can involve various parties and different data models. Accordingly existence of different models can hinder proper interaction between the participants as data may not be properly representable to all parties involved. Moreover conventional methods of converting from one data representation to another can typically become time consuming and resource intensive while at the same time be fraught with conversion problems and in some cases totally impracticable due to such complexity.

As programming approaches and foundations have evolved application programming interfaces APIs and programming schemas have been developed to standardize and unify programming methodologies that were previously multi variant and relatively incompatible. Modern programming therefore often involves employing APIs and schemas in conjunction with reusable libraries. Such Programming languages continue to evolve to facilitate specification by programmers as well as efficient execution.

Compilers and or interpreters bear the burden of translating high level logic into executable machine code. In general compilers and or interpreters are components that receive a program specified in a source programming language e.g. C C Visual Basic Java . . . and covert the logic provided thereby to machine language that is executable by a hardware device.

However the conversion need not be done verbatim. In fact conventional compilers and or interpreters analyze the source code and generate very efficient code. For example programmers write code that sets forth a logical flow of operations that is intuitive and easy for humans to understand but is often inefficient for a computer to execute. Compilers and or interpreters can identify inefficiencies and improve program performance at the hardware level by eliminating unnecessary operations and or rearranging the execution of instructions while still achieving the intended results. In this manner programmers can create robust and efficient software.

The following presents a simplified summary in order to provide a basic understanding of some aspects described herein. This summary is not an extensive overview of the claimed subject matter. It is intended to neither identify key or critical elements of the claimed subject matter nor delineate the scope thereof. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

The subject innovation provides for systems and methods that integrate data type s conversion into a programming language s and describe external formats within a syntax of the programming language s via a mapping component that defines a declarative mapping from an external data format to one or more of its internal data types e.g. expressing external data types in terms of source languages. Moreover a rule establishing component can define value based rules such as invariants to the external data format wherein the schema declaration further defines data fields that make up the schema e.g. names types acceptable values such fields. Such rule establishing component can further provide for enforceable semantic rules about exchanged data and a form of automated argument validation. For example the invariants language can be defined as a functional subset of the source language that allows the programmer to express the rules using predicate logic defining predicates and clauses over the data elements of the schema and the related schemata it refers to. Accordingly by expressing rules in form of predicate logic instead of imperative program logic the subject innovation increase a likelihood that compilers can efficiently reason about the data and its invariants.

In a related aspect the subject innovation integrates the conversion into the programming language external formats and mappings by describing external data formats inside a programming language that conventionally has been employed for describing internal formats. The mapping can occur by constraining expressions both in the external formats and the idioms of the internal language that are used to describing it to arrive at a subset of the two. Such subset enables sharing between languages of different object oriented type systems and allows mapping to be straight forward and readily preformed. For example by employing terms that are internal to the program the external expressions can be expressed and mapped automatically. Accordingly preserving versionability of the exchange format can be readily provided.

The following description and the annexed drawings set forth in detail certain illustrative aspects of the claimed subject matter. These aspects are indicative however of but a few of the various ways in which the principles of such matter may be employed and the claimed subject matter is intended to include all such aspects and their equivalents. Other advantages and novel features will become apparent from the following detailed description when considered in conjunction with the drawings.

The various aspects of the subject innovation are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

Moreover the data model can be extensible through the introduction of new schema which extends at least one existing schema for example. Accordingly the applications can include different data types and models and 1 thru M M being an integer such as object oriented entity relationships XMl SQL and the like. Thus versioning scenarios can emerge during the data exchange wherein different sets and versions of schema can be referenced and inconsistencies can occur if the subset exercised during a data exchange fail to match. A mismatch can either be due to a disparity in the version of a definition and or due to a missing definition. Such mismatch can occur when a version of a type is available to at least of one of the applications and is different from that of the other applications or when a type is available to at least one party but not all. As described in detail infra at data type conversion can be integrated into a programming language employed by the applications to describe external formats within syntax thereof and hence facilitate data exchange between the applications and .

Moreover a rule establishing component can define value based rules such as invariants to the external data format wherein the schema declaration further defines data fields that make up the schema e.g. names types acceptable values such fields. Such rule establishing component can further provide for enforceable semantic rules about exchanged data and a form of automated argument validation. For example the invariants language can be defined as a functional subset of the source language that allows the programmer to express the rules using predicate logic defining predicates and clauses over the data elements of the schema and the schemata it refers to. Accordingly by expressing rules in form of predicate logic instead of imperative program logic the subject innovation increase a likelihood that compilers can reason about the data.

In this particular example the structure can function as a base component of the data model schema and serves as a container for related mapping fields e.g. a class in an object domain a relational domain and the like. Likewise field entity can associate with a data model concept that holds typed data e.g. properties in an object domain. Moreover the relationship can act as the link and association between two structures and can describe how structures in the same domain relate to each other. The relationship can be established through either common fields in the two structures and or containment reference wherein a structure contains another structure e.g. containment hierarchy and an object that references another object through its field for example. Hence the mapping can occur by constraining expressions both in the external formats and the idioms of the internal language that are used to describing it to arrive at a subset of the two. Such subset enables sharing between language s of different object oriented type systems and allows mapping to be straight forward and readily preformed wherein by employing terms that are internal to the program the external expressions can be expressed and mapped automatically.

For example typically Visual Basic VB has been a data centric language wherein outside data data sent between services is supported via programmatic manipulation of XML and inside data data that is managed and manipulated within a service can be supported via language integrated queries. Moreover for a related schema VB schema can function as VB support for data contracts wherein such data contracts can represent an entire category of data. In one aspect by not tying the data contract definition directly to the type that is serialized de serialized the subject innovation allows a type to adhere to more than one data contract. As detailed infra the subject innovation is described with respect to VB examples and it is to be appreciated that the innovation is not so limited.

A schema can be considered similar to a class or interface definition with only properties. As with an interface typically the abstract members of a schema are declared without an access specifier. Moreover Schema properties cannot be declared as ReadOnly or WriteOnly and in general abstract members of a schema are defined as either Required or Optional . Such schema can also function as the location of choice regarding validation logic for data passed between components. Data validation can be commonly implemented in a variety of ways and in a variety of places depending on associated purpose. For outside data ad hoc validation can occur when such data passes the trust boundary of a component sent to received from another component . By not tying the data contract definition directly to the type that is serialized de serialized the subject innovation enables a type to adhere to more than one data contract.

The set of abstract members is what defines a schema s structure and such structure is defined only in terms of properties e.g.

The set of abstract members is what defines a schema s structure and such structure is defined only in terms In addition to properties a schema can define a set of rules over all classes implementing it. Rules can be expressed as Boolean conditions that must all hold true at certain points during the lifetime of a schema instance as described in detail infra for example 

The rule establishing component can define rules in terms of properties of the schema such as properties of schemas that are employed as the types of properties in the invariant defining schema compile time constants functions and the like. Such can be placed inside blocks that in general contain only expressions of rules and for each schema there can exist more than one block. In addition typically a rules block can only contain three kinds of statements namely Require which is a new statement added to VB Try . . . Catch statements and Dim statements. In general Rules may not modify anything including locals declared using Dim and therefore assignment statements are typically not allowed. Similarly Functions can be employed to define sub expressions of invariant definitions and unlike other schema members they may be declared as public private or protected. For example 

The same stringent functional requirements can apply as for invariant blocks wherein functions can typically only contain three kinds of statements Return Try . . . Catch statements and Dim statements. In general functions may not modify anything including locals declared using Dim hence assignment statements are not allowed. The same expression terms are allowed within functions as within invariant blocks schema properties compile time constants and schema functions. Functions can be called from anywhere according to their protection level.

In addition to schema properties rules and functions a schema definition may contain constant and enum declarations e.g. 

In addition to schema properties rules and functions a schema definition can contain constant and enum declarations 

In general by implementing a schema an instance does not typically establish any kind of is a relation to it and any reference to a schema is unrelated to any other .NET type except Object .

A schema can inherit from another schema but typically not from a class other than System.Object. In addition typically classes or interfaces may not inherit a schema. Moreover for schema polymorphic inheritance semantics are typically not applicable.

Furthermore Rules can be enforced when wrapping an instance array or collection of instances into a schema array of schema or collection of schema coercion . Such rules can also be enforced when an instance is passed to a method which accepts a schema as an argument. At any time a schema s rules may be enforced on a schema instance by calling Check obj defined in the VB runtime 

Likewise regarding mapping restrictions a schema member defined in terms of schema can be mapped implicitly or explicitly to any member of a type that implements such schema. A schema member defined in terms of a non schema type can in general be mapped only to members that conform using normal Common Language Runtime CLR widening conversion rules.

For example a schema member of type String can in general only be mapped to members of type String. A schema member of type Byte can be mapped to Byte Short Integer or Long. A schema member of type C can be mapped to members that have type C or any type derived from it. In essence when coercing from the class instance to the schema instance the member conversion typically should be widening and not narrowing.

The mapping can occur by constraining expressions both in the external formats and the idioms of the internal language that are used to describing it to arrive at a subset of the two. Such subset enables sharing between languages of different object oriented type systems and allows mapping to be straight forward and readily preformed. For example by employing terms that are internal to the program the external expressions can be expressed and mapped automatically. Accordingly preserving versionability of the exchange format can be readily provided.

Structure and behavior of objects are defined by a class which is a definition of all objects of a specified type. Objects are explicitly created as a function of a class and an object so created is considered to be an instance of such class. Objects can further be associated with method pointers member access control implicit data members utilized to locate instances of a class in a class hierarchy and the like. Moreover an object s data and or functionality can be based on data and or functionality of disparate objects s from which the former object inherits. Inheritance enables commonalities amongst differing types of objects to be expressed a single time and thereafter utilized multiple times in multiple contexts.

The mapping can occur via the mapping component by constraining expressions both in the external formats and the idioms of the internal language that are used to describing it to arrive at a subset of the two. Such subset enables sharing between languages of different object oriented types data models and allows mapping to be straight forward and readily preformed. For example by employing terms that are internal to the program the external expressions can be expressed and mapped automatically. Accordingly preserving versionability of the exchange format can be readily provided.

The system further includes a data store that stores information regarding each direct or inherited attribute of each type of a type hierarchy. The mapping component can store information in the inheritance mapping data store based at least in part on information received from a user regarding a quantity of relations used for representing the type hierarchy as discussed above with respect to the mapping component .

Similarly for each schema class the compiler can supply methods to perform transformation e.g. with the following definition 

In general when performing a transformation the compiler can face three scenarios. The first scenario occurs when the target type implements a schema that is the static type of the source expression. In such case the target type s Transform method can be employed for the transformation. In the second scenario the target type typically does not implement the dynamic interface that is the static type of the source. In such case the source schema s Transform method can be employed for the transformation. In the third scenario the source type can include an array of a schema type e.g. multi dimensional or a generic binding wherein the type parameter is a schema type. The compiler can subsequently employ the Transform method found in RuntimeSchema to perform the transformation for example.

Compiler can accept as input a file having source code associated with processing of a sequence of elements. The source code may include mixed language code including associated with a number of type systems. Compiler may process source code in conjunction with one or more components for analyzing constructs and generating or injecting code.

A front end component reads and performs lexical analysis upon the source code. In essence the front end component reads and translates a sequence of characters e.g. alphanumeric in the source code into syntactic elements or tokens indicating constants identifiers operator symbols keywords and punctuation among other things. Converter component parses the tokens into an intermediate representation. For instance the converter component can check syntax and group tokens into expressions or other syntactic structures which in turn coalesce into statement trees. Conceptually these trees form a parse tree . Furthermore and as appropriate the converter module can place entries into a symbol table that lists symbol names and type information used in the source code along with related characteristics.

A state can be employed to track the progress of the compiler in processing the received or retrieved source code and forming the parse tree . For example different state values indicate that the compiler is at the start of a class definition or functions has just declared a class member or has completed an expression. As the compiler progresses it continually updates the state . The compiler may partially or fully expose the state to an outside entity which could subsequently provide input to the compiler .

Based upon constructs or other signals in the source code or if the opportunity is otherwise recognized the converter component can inject code to facilitate efficient and proper execution. Rules coded into the converter component or other component indicates what must be done to implement the desired functionality and identify locations where the code is to be injected or where other operations are to be carried out. Injected code typically includes added statements metadata or other elements at one or more locations but this term can also include changing deleting or otherwise modifying existing source code. Injected code can be stored as one or more templates or in some other form. In addition it should be appreciated that symbol table manipulations and parse tree transformations can take place.

Likewise based on the symbol table and the parse tree a back end component can translate the intermediate representation into output code. The back end component converts the intermediate representation into instructions executable in or by a target processor into memory allocations for variables and so forth. The output code can be executable by a real processor but the invention also contemplates output code that is executable by a virtual processor.

Furthermore the front end component and the back end component can perform additional functions such as code optimization and can perform the described operations as a single phase or in multiple phases. Various other aspects of the components of compiler are conventional in nature and can be substituted with components performing equivalent functions. Additionally at various stages of processing of the source code an error checker component can check for errors such as errors in lexical structure syntax errors and even semantic errors e.g. type checking . Upon detection error checker component can halt compilation and generate a message indicative of the error. Furthermore and as previously described the compiler can associate one or more types from a multitude of type systems with programmatic elements to facilitate not only type checking but also intelligent program support.

As used in herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an instance an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Similarly examples are provided herein solely for purposes of clarity and understanding and are not meant to limit the subject innovation or portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented but have been omitted for purposes of brevity.

Furthermore all or portions of the subject innovation may be implemented as a system method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed innovation. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the subject innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the claimed innovation can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects of the subject innovation includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. Dual microprocessors and other multiprocessor architectures e.g. multi core also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory.

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example mass or auxiliary storage . Mass storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition mass storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the mass storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on mass storage and loaded to system memory acts to control and allocate resources of the system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on mass storage . It is to be appreciated that the subject innovation can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like displays e.g. flat panel CRT LCD plasma . . . speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected e.g. wired or wirelessly via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems power modems and DSL modems ISDN adapters and Ethernet cards or components.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers . For example the virtual reality component can be associated with server s . This web service server can also be communicatively coupled with a plurality of other servers as well as associated data stores such that it can function as a proxy for the client .

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having or variations in form thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

