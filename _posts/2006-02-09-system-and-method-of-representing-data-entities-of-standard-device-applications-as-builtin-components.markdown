---

title: System and method of representing data entities of standard device applications as built-in components
abstract: A system and method for developing a standard data component for coupling with a plurality of components of a component-based application to access a stored data entity of a non-component-based native application, the applications for executing in a runtime environment of a device. The system and method comprises an application module configured for storing a model of the component-based application including features of data and message component definitions expressed in a structured definition language. Also included is a native module configured for storing properties of the data entity of the native application and a standard module for generating the standard data component definition based on the features of the component-based application and the properties of the data entity of the native application. The standard data component definition is expressed in the structured definition language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07805735&OS=07805735&RS=07805735
owner: Research In Motion Limited
number: 07805735
owner_city: Waterloo, Ontario
owner_country: CA
publication_date: 20060209
---
This application claims the benefit of U.S. provisional 60 672 077 filed Apr. 18 2005 the entire disclosure of which is herein incorporated by reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by any one of the patent document or patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyrights whatsoever.

This application relates generally to communications between a client application and a data source coupled over a network.

There are continually increasing numbers of terminals and mobile devices in use today such as smart phones PDAs with wireless communication capabilities personal computers self service kiosks and two way pagers communication devices. Software applications which run on these devices help to increase their utility. For example a smart phone may include an application which retrieves the weather for a range of cities or a PDA which may include an application that allows a user to shop for groceries. These software applications take advantage of the connectivity to a network in order to provide timely and useful services to users. However due to the restricted resources of some devices and the complexity of delivering large amounts of data to the devices developing and maintaining software applications tailored for a variety of devices remains a difficult and time consuming task.

Devices from different manufacturers expose native application data entities NADEs by providing their native application programming interfaces APIs which are usually not compliant with one other. Following the traditional way of developing a native application a third party application vendor tailors or re develops native applications on a per device manner in order to use specific vendors proprietary function calls native APIs to access NADEs resident in onboard memory of the device. Furthermore for a specific device the same piece of code for each of the respective native APIs has to be rewritten or otherwise tailored for each of its device specific native applications in order to access the device s respective NADEs. This revision i.e. versioning of native APIs could be avoided by somehow sharing the code of the native APIs among these native applications.

Systems and methods disclosed herein provide a development tool to obviate or mitigate at least some of the above presented disadvantages.

Devices from different manufacturers expose native application data entities NADEs by providing their native application programming interfaces APIs which are usually not compliant with one other. Furthermore for a specific device the same piece of code for each of the respective native APIs has to be rewritten or otherwise tailored for each of its device specific native applications in order to access the device s respective NADEs. Contrary to present implementations there is provided a system and method for developing a standard data component for coupling with a plurality of components of a component based application to access a stored data entity of a non component based native application the applications for executing in a runtime environment of a device. The system and method comprises an application module configured for storing a model of the component based application including features of data and message component definitions expressed in a structured definition language. Also included is a native module configured for storing properties of the data entity of the native application and a standard module for generating the standard data component definition based on the features of the component based application and the properties of the data entity of the native application. The standard data component definition is expressed in the structured definition language.

Accordingly there is provided a system for developing a standard data component for coupling with a plurality of components of a component based application to access a stored data entity of a non component based native application the applications having the plurality of components including metadata descriptors expressed in a structured definition language for defining execution of the application in a runtime environment of a device the system comprising an application module configured for storing a model of the component based application including features of data and message metadata descriptors expressed in the structured definition language a native module configured for storing properties of the data entity of the native application and a standard module for generating the standard data component definition as additional metadata descriptors based on the features of the component based application and the properties of the data entity of the native application the additional metadata descriptors of the standard data component definition expressed in the structured definition language.

Also provided is a method for developing a standard data component for coupling with a plurality of components of a component based application to access a stored data entity of a non component based native application the applications having the plurality of components including metadata descriptors expressed in a structured definition language for defining execution of the application in a runtime environment of a device the method comprising the steps of accessing a model of the component based application including features of data and message component metadata descriptors expressed in the structured definition language accessing properties of the data entity of the native application and generating the standard data component definition as additional metadata descriptors based on the features of the component based application and the properties of the data entity of the native application the additional metadata descriptors of the standard data component definition expressed in the structured definition language.

Also provided is a computer program product for developing a standard data component for coupling with a plurality of components of a component based application to access a stored data entity of a non component based native application the applications having the plurality of components including metadata descriptors expressed in a structured definition language for defining execution of the application in a runtime environment of a device the computer program product comprising a computer readable medium an application module stored on the computer readable medium and configured for storing a model of the component based application including features of data and message metadata descriptors expressed in the structured definition language a native module stored on the computer readable medium and configured for storing properties of the data entity of the native application and a standard module stored on the computer readable medium for generating the standard data component definition as additional metadata descriptors based on the features of the component based application and the properties of the data entity of the native application the additional metadata descriptors of the standard data component definition expressed in the structured definition language.

Referring to a network system comprises mobile communication devices for interacting with one or more backend data sources e.g. a schema based service such as web service or database that provides enterprise services used by an application via a wireless network coupled to an application gateway AG. The devices are devices such as but not limited to mobile telephones PDAs two way pagers dual mode communication devices. It is recognised that the application gateway AG and data sources can be linked via extranets e.g. the Internet and or intranets as is known in the art. The application gateway AG handles request response messages initiated by the application as well as subscription notifications pushed to the device from the data sources . The Application Gateway AG functions as a Data Mapping Server for mediating messaging between a client runtime RE on the device executing the application s and a backend server of the data sources . The gateway AG can provide for asynchronous messaging for the applications and can integrate and communicate with legacy back end data sources . The devices transmit and receive the wireless applications as further described below when in communication with the data sources as well as transmit receive messaging associated with operation of the applications . The devices operate as web clients of the data sources through execution of the applications when provisioned on respective runtime environments RE of the devices .

For satisfying the appropriate messaging associated with the applications the application gateway AG communicates with the data sources through various protocols such as but not limited to HTTP SQL and component API for exposing relevant business logic methods to the applications once provisioned on the devices . The applications can use the business logic of the data sources similarly to calling a method on an object or a function . It is recognized that the applications can be downloaded uploaded in relation to data sources via the network and application gateway AG directly to the devices . For example the application gateway AG is coupled to a provisioning server and a discovery server for providing a mechanism for optimized over the air provisioning of the applications including capabilities for application discovery from the device as listed in a Universal Description Discovery and Integration UDDI for example registry . The Registry is a directory service where businesses can register and search for Web services and can be part of the Discovery Service implemented by the server . The registry is used for publishing the applications . The application information in the registry can contain such as but not limited to a Deployment Descriptor DD contains information such as application name version and description as well as the location of this application in an application repository . The registry can provide a directory for storing information about web services as provided by the data sources including a directory of web service interfaces described by WSDL for example. Further UDDI as a registry is based on Internet standards such as but not limited to XML HTTP and DNS protocols.

Referring again to for initialization of the runtime environment RE the RE can receive the gateway AG URL and the gateway AG public key in a network data server e.g. Mobile Data Service service book. The runtime environment RE uses this information to connect to the gateway AG for initial handshaking. Device provisioning is implemented by a web client system depending on the domain which pushes the network data server service book to the device . It is recognised there could be more than one gateway AG in the network as desired. Once initialized access to the applications by the devices as downloaded uploaded can be communicated via the gateway AG directly from the application repository and or in association with data source direct access not shown to the repository .

Referring to the devices are devices such as but not limited to mobile telephones PDAs two way pagers or dual mode communication devices. The devices include a network connection interface such as a wireless transceiver or a wired network interface card or a modem coupled via connection to a device infrastructure . The connection interface is connectable during operation of the devices to the network such as to the wireless network by wireless links e.g. RF IR etc. which enables the devices to communicate with each other and with external systems such as the back end data sources via the network and to coordinate the requests response messages between the client application programs and the data sources see . The network supports the transmission of data in the requests response messages between devices and external systems which are connected to the network . A wireless data transmission protocol can be used by the wireless network such as but not limited to DataTAC GPRS or CDMA.

Referring again to the devices also have a user interface coupled to the device infrastructure by connection to interact with a user not shown . The user interface includes one or more user input devices such as but not limited to a QWERTY keyboard a keypad a track wheel a stylus a mouse a microphone and the user output device such as an LCD screen display and or a speaker. If the screen is touch sensitive then the display can also be used as the user input device as controlled by the device infrastructure . The user interface is employed by the user of the device to coordinate the requests response message messages over the system see as employed by client applications of a runtime environment RE further described below.

Referring again to operation of the device is enabled by the device infrastructure . The device infrastructure includes the computer processor and the associated memory module . The computer processor manipulates the operation of the network interface the user interface and the runtime environment RE of the communication device by executing related instructions which are provided by an operating system and client applications located in the memory module . Further it is recognized that the device infrastructure can include a computer readable storage medium coupled to the processor for providing instructions to the processor and or to load update client applications in the memory module . The computer readable medium can include hardware and or software such as by way of example only magnetic disks magnetic tape optically readable medium such as CD DVD ROMS and memory cards. In each case the computer readable medium may take the form of a small disk floppy diskette cassette hard disk drive solid state memory card or RAM provided in the memory module . It should be noted that the above listed example computer readable mediums can be used either alone or in combination.

Referring again to the Runtime Environment RE of the device is coupled to the device infrastructure by the connection and is preferably capable of generating hosting and executing the client applications which are in the form of component applications see below from meta data definitions. Therefore Runtime Environment RE provides the native client runtime environment for the client applications and is an interface to the device functionality of the processor and associated operating system of the device infrastructure . The Runtime Environment RE provides an application container for example for execution of the applications . The application container can be referred to as a smart host container for the client application and can be responsible for analyzing message meta data of the messages and for updating the representation of the meta data of the data components and standard data components instantiated in the memory module .

Further specific functions of the client runtime environment RE can include such as but not limited to support for language coordinating memory allocation networking management of data during I O operations coordinating graphics on an output device of the devices and providing access to core object oriented classes and supporting files libraries.

The terminal runtime environment of the devices preferably supports the following basic functions for the resident executable versions of the client applications see such as but not limited to 

provide a communications capability to send messages to the Web Services or messages to any other generic schema defined services connected via the network to the devices 

provide data input capabilities by the user on the input device of the devices to supply data parts for Web Services outgoing messages messages to the service 

provide data presentation or output capabilities for Web Services response messages incoming messages or uncorrelated notifications of the Web Service on the output device 

provide data storage services to maintain local client data in the memory module see of the device for example for the data components and standard data components see and

provide an execution environment for a scripting language for coordinating operation of the application components see of the client applications including the standard data components see .

The component applications comprise software applications which are executed by the Runtime Environment RE. The Runtime Environment RE creates the application container for each component see of the application each time that the component application is executed. The application container loads the components of the application linked with the standard data components and can create native code which is executed by the processor in the device infrastructure . The application container can provision the component application as per the template based native execution and metadata based execution models as described.

Referring to the client runtime RE loads the metadata contained in the component definitions and builds the executable version of the application on the device via the application container . For example there are the two operational models for client runtime template based native execution and metadata based execution. With the template based native execution model the runtime hosts data message and screen templates pre built on the device using the native code. When the application definition is loaded the client environment provided by the client runtime RE fills the templates with metadata defined parameters from the components and builds the executable client application in the native format. The workflow script for example ECMAScript of the workflow component could be either converted to native code or executed using an appropriate script interpreter e.g. ECMAScript Interpreter to a native code redirector where the redirector interprets calls to the scripting language into operations on native components through a native runtime engine. With the metadata based execution the runtime environment of the client runtime RE either keeps component definitions in XML for example which are parsed during execution time or uses native representation of XML for example nodes. During execution the native runtime engine operates on definitions of the components rather than on native component entities. It is recognized that the template based approach can be more performance efficient over the metadata based execution but can require a more sophisticated execution environment and more memory resources.

Referring to the Runtime Environment RE can also provide framework services a standard set of generic services to the client application in the event certain services are not included as part of the components see or received as separate components not shown as part of the component application . The application has communications with the application container which coordinates communications with the framework services as needed. The framework services of the Runtime Environment RE can coordinate communications via the connection with the device infrastructure and can include such as but not limited to a communication service a presentation service a persistence service an access service a provisioning service and a utility service . The communication service manages connectivity between the component applications and the external system such as the messages and associated data sent received in respect to the web service by the communication service on behalf of the component applications . The presentation service manages the representation of the component application as they are output on the output device of the user interface see . The persistence service allows the component application to store data in the memory module see of the device infrastructure . The access service provides the component application access to other software applications which are present on the communication device and are not component based applications rather native based applications. The provisioning service manages the provisioning of software applications on the communication device . Application provisioning can include requesting and receiving new and updated component applications configuring component applications for access to services which are accessible via the network modifying the configuration of component applications and services and removing component applications and services. The utility service is used to accomplish a variety of common tasks such as performing data manipulation in the conversion of strings to different formats.

It is recognized that the framework services of the communication device can provide functionality to the component applications which can include the services described above. As a result the component applications can have access to the functionality of the communication device without having to implement it. The runtime environment RE of the device has only preferably one copy of the code which implements these services present in the framework services regardless of the number of component applications which are present thereby minimizing code duplication of the framework services . Further unlike ordinary applications where all service requests or service API calls are programmed by developers in the native code the component definitions and workflow describe service requests using a structured definition language such as XML and the set of instructions such as ECMAScript. The structured definition language provides a non procedural definition of the application s user interface persistent storage and communications with the Web Service while the instructions provide the procedural component linkage. The Client runtime environment interprets these definitions into the native calls to supported services.

Referring to the applications can be stored in the repository as a series of packages that can be created by a developer tool which is employed by developers of the applications . The developer tool can be a RAD tool used to develop the Wireless Application packages as well as develop built in or standard data components see for accessing native application data entities NADEs such as but not limited to contacts email tasks calendar appointments of native device applications NDAs e.g. Microsoft Outlook features and other non component based applications that may be desirable for direct access by the component applications as further described below. It is recognised that the non component based applications including NDAs contain a plurality of data that may overlap one another. For example contacts and email applications can both contain a separate copy of an individuals name and email address which preferably could be one copy sharable by the component and non component based applications through the standard data components .

The developer tool can provide support for a drag and drop graphical approach for the visual design of the application including the mapping model. For example in a component based XML Script application model the application packages can be represented as metadata XML that can be generated automatically by the developer tool through an automatic code generation process. The developer tool can provide for the automatic generated code to include or be otherwise augmented by an industry standard scripting language e.g. JavaScript or other scripting programming languages known in the art. The availability of the application packages of the repository are published via the discovery service of the server in the registry . It is recognized that there can be more than one repository and associated registries as utilized by the particular network configuration of the application gateway AG and associated data sources .

Referring to the developer tool is operated on a computer that can be connected to the network via a network connection interface such as a transceiver coupled via connection to a device infrastructure . The transceiver can be used to upload completed application programs to the repository see as well as access the registry and selected data sources . Referring again to the developer tool also has a user interface coupled to the device infrastructure by connection to interact with a user not shown . The user interface includes one or more user input devices such as but not limited to a keyboard a keypad a trackwheel a stylus a mouse a microphone and is coupled to a user output device such as a speaker not shown and a screen display . If the display is touch sensitive then the display can also be used as the user input device as controlled by the device infrastructure . The user interface is employed by the user of the developer tool to coordinate the design of applications and or the standard data components see using a series of editors and viewers see and using a plurality of wizards to assist drive in the workflow of the development process.

Referring again to operation of the tool computer is enabled by the device infrastructure . The device infrastructure includes a computer processor and the associated memory module . The computer processor manipulates the operation of the network interface the user interface and the display of the developer tool by executing related instructions which are provided by an operating system and application design editors wizards dialogs and viewers resident in the memory module . Further it is recognized that the device infrastructure can include a computer readable storage medium coupled to the processor for providing instructions to the processor and or to load design the applications also resident for example in the memory module . The computer readable medium can include hardware and or software such as by way of example only magnetic disks magnetic tape optically readable medium such as CD DVD ROMS and memory cards. In each case the computer readable medium may take the form of a small disk floppy diskette cassette hard disk drive solid state memory card or RAM provided in the memory module . It should be noted that the above listed example computer readable mediums can be used either alone or in combination.

Referring again to the developer tool is operated on the computer as a development environment for developing the applications and or the standard data components . The development methodology of the developer tool can be based on a visual drag and drop system of building the application visual data messaging behaviour and runtime navigation model. The developer tool can be structured as a set of plug ins to a generic integrated design environment IDE framework such as but not limited to the Eclipse framework or the developer tool can be configured as a complete design framework without using plug in architecture. For exemplary purposes only the developer tool will now be described as a plug in design environment using the Eclipse framework.

Referring to Eclipse makes provisions for a basic developer tool environment that can be extended to provide custom editors wizards project management and a host of other functionality. The Eclipse Platform is designed for building integrated development environments IDEs that can be used to create applications as diverse as web sites embedded Java TM programs C programs and Enterprise JavaBeans TM. The navigator view shows files in a user s e.g. developer workspace a text editor section shows the content of a file being worked on by the user of the developer tool to develop the application and or standard data components in question the tasks view section shows a list of to dos for the user of the developer tool and the outline viewer section shows for example a content outline of the application and or standard data components being designed edited and or may augment other views by providing information about the currently selected object such as properties of the object selected in another view. It is recognised that the developer tool aids the developer in creating and modifying the coded definition content of the application and or standard data components for example in a structured definition language e.g. in XML . Further the developer tool also aids the developer in creating modifying and validating the interdependencies of the definition content between the application message data and or screen data relationships included in the application definition and the standard data components . It is also recognised that presentation on the display of wizard and dialog content for use by the developer during use of the editors and viewers can be positioned in one of the sections and or in a dedicated wizard section not shown as desired.

The Eclipse Platform is built on a mechanism for discovering integrating and running modules called plug ins i.e. editors and viewers . When the Eclipse Platform is launched via the UI of the computer the user is presented with an integrated development environment IDE on the display composed of the set of available plug ins such as editors and viewers . The various plug ins to the Eclipse Platform operate on regular files in the user s workspace indicated on the display . The workspace consists of one or more top level projects where each project maps to a corresponding user specified directory in the file system as stored in the memory and or accessible on the network which is navigated using the navigator . The Eclipse Platform UI paradigm is based on editors views and perspectives. From the user s standpoint a workbench display consists visually of views and editors . Perspectives manifest themselves in the selection and arrangements of editors and views visible on the display . Editors allow the user to open edit and save objects. The editors follow an open save close lifecycle much like file system based tools. When active a selected editor can contribute actions to a workbench menu and toolbar. Views provide information about some object that the user is working with in the workbench. A viewer may assist the editor by providing information about the document being edited. For example viewers can have a simpler lifecycle than editors whereby modifications made in using a viewer such as changing a property value are generally saved immediately and the changes are reflected immediately in other related parts of the display . It is also recognised that a workbench window of the display can have several separate perspectives only one of which is visible at any given moment. Each perspective has its own viewers and editors that are arranged tiled stacked or detached for presentation on the display .

For example the applications can be compiled applications for transmission to and subsequent execution on the device or can be packages having application elements or artifacts such as but not limited to XML definitions mappings application resources and optionally resource bundle s for localization support. XML file definitions can be XML coding of application data messages screens components optionally workflow components part of the raw uncompiled application . It is recognised that XML syntax is used only as an example of any structured definition language applicable to coding of the applications . The XML definitions may be produced either by the developer tool generation phase described below or may be hand coded by the developer as desired. The application XML definitions can be generically named and added to the top level for example of ajar file.

The resources are one or more resources images audio clips video clips etc. . . . that are packaged with the application as static dependencies. For example resources can be located relative to a resources folder not shown such that a particular resource may contain its own relative path to the main folder e.g. resources icon.gif resources screens clipart1.0 happyface.gif and resources soundbytes midi inthemood.midi . The resource bundles can contain localization information for each language supported by the application . These bundles can be located in a locale folder for example and can be named according to the language supported e.g. locale lang en.properties and locale lang fr.properties .

Referring to as an example only the applications can be component architecture based software applications which can have artifacts written for example in eXtensible Markup Language XML and a subset of ECMAScript. XML and ECMAScript are standards based languages which allow software developers to develop the component applications in a portable and platform independent way. A block diagram of the component application comprises the data components the presentation components and the message components which are coordinated by workflow components through interaction with the client runtime environment RE of the device see once provisioned thereon. The structured definition language e.g. XML can be used to construct the components as a series of metadata records which consist of a number of pre defined elements representing specific attributes of a resource such that each element can have one or more values. Each metadata schema typically has defined characteristics such as but not limited to a limited number of elements a name of each element and a meaning for each element. Example metadata schemas include such as but not limited to Dublin Core DC Anglo American Cataloging Rules AACR2 U.S. Government Information Locator Service GILS Encoded Archives Description EAD Instructional Management System IMS Global Learning Consortium and Australian Government Locator Service AGLS . Encoding syntax allows the metadata of the components to be processed by the runtime environment RE see and encoding schemes include schemes such as but not limited to XML HTML XHTML XSML RDF Machine Readable Cataloging MARC and Multipurpose Internet Mail Extensions MIME . The client runtime environment RE of the device operates on the metadata descriptors of the components to provision an executable version of the application .

Referring again to the data components define data entities which are used by the application . Data components define what information is required to describe the data entities and in what format the information is expressed stored. For example the data component may define information such as but not limited to an order which is comprised of a unique identifier for the order which is formatted as a number a list of items which are formatted as strings the time the order was created which has a date time format the status of the order which is formatted as a string and a user who placed the order which is formatted according to the definition of another one of the data components . It is recognised that standard data components see of the runtime environment RE can be similar in design and content to that of the data components or data components of the application . Further it is recognized that in the above described client component application definitions hosting model the standard data components may vary depending on the client platform and environment of the device .

Referring again to the message components define the format of messages used by the component application to communicate with external systems such as the web service. For example one of the message components may describe information such as but not limited to a message for placing an order which includes the unique identifier for the order the status of the order and notes associated with the order. It is recognised that data definition content of the components can be shared for data and message components that are linked or otherwise contain similar data definitions. The message component allows the message content to be evaluated to determine whether mandatory fields have been supplied in the message and to be sent to the data source via the AG.

Referring again to the presentation components define the appearance and behavior of the component application as it displayed by a user interface of the devices . The presentation components can specify GUI screens and controls and actions to be executed when the user interacts with the component application using the user interface. For example the presentation components may define screens labels edit boxes buttons and menus and actions to be taken when the user types in an edit box or pushes a button. It is recognised that data definition content of the components can be shared for data and presentation components that are linked or otherwise contain similar data definitions.

Referring to it is recognized that in the above described client component application S definitions hosting model the presentation components may vary depending on the client platform and environment of the device . For example in some cases Web Service consumers do not require a visual presentation. The application definition of the components of the component application can be hosted in the Web Service repository as a package bundle of platform neutral data message workflow component descriptors with a set of platform specific presentation component descriptors for various predefined client runtimes RE. When the discovery or deployment request message for the application is issued the client type would be specified as a part of this request message. In order not to duplicate data message and workflow metadata while packaging component application for different client platforms of the communication devices application definitions can be hosted as a bundle of platform neutral component definitions linked with different sets of presentation components . For those Web Service consumers the client application would contain selected presentation components linked with the data and message components through the workflow components .

Referring again to the workflow components of the component application define processing that occurs when an action is to be performed such as an action specified by a presentation component as described above or an action to be performed when messages arrive from the application gateway AG see . Presentation workflow and message processing are defined by the workflow components . The workflow components are written as a series of instructions in a programming language e.g. object oriented programming language and or a scripting language such as but not limited to ECMAScript and can be for example compiled into native code and executed by the runtime environment RE as described above. An example of the workflow components may be to assign values to data manipulate screens or send the message . As with presentation components multiple workflow definitions can be created to support capabilities and features that vary among devices . ECMA European Computer Manufacturers Association Script is a standard script language wherein scripts can be referred to as a sequence of instructions that is interpreted or carried out by another program rather than by the computer processor. Some other example of script languages are Perl Rexx VBScript JavaScript and Tcl Tk. The scripting languages in general are instructional languages that are used to manipulate customize and automate the facilities of an existing system such as the devices .

Referring to the application is structured for example using component architecture such that when the device see receives a response message from the application gateway AG containing message data the appropriate workflow component interprets the data content of the message according to the appropriate message component definitions. The workflow component then processes the data content and inserts the data into the corresponding data component for subsequent storage in the device . Further if needed the workflow component also inserts the data into the appropriate presentation component for subsequent display on the display of the device . A further example of the component architecture of the applications is for data input by a user of the device such as pushing a button or selecting a menu item. The relevant workflow component interprets the input data according to the appropriate presentation component and creates data entities which are defined by the appropriate data components . The workflow component then populates the data components with the input data provided by the user for subsequent storage in the device . Further the workflow component also inserts the input data into the appropriate message component for subsequent sending of the input data as data entities to the data source web service for example as defined by the message component .

An example component application represented in XML and mEScript could be as follows including data components as wcData and message components content as wcMsg 

As given above the XML wcData element content defines the example data component content which is comprised of a group of named typed fields. The wcMsg element content defines the example message component which similarly defines a group of named typed fields.

The developer tool has a UI Layer composed mainly of the editors and viewers which are assisted through the workflow wizards . The layer has access to an extensive widget set and graphics library known as the Standard Widget Toolkit SWT for Eclipse. The UI layer modules can also make use of a higher level toolkit called JFace that contains standard viewer classes such as lists trees and tables and an action framework used to add commands to menus and toolbars. The developer tool can also use a Graphical Editing Framework GEF to implement diagramming editors. The UI layer modules can follow the Model View Controller design pattern where each module is both a view and a controller. Data models represents the persistent state of the application and are implemented in the data model layer the developer tool architecture. The separation of the layers keeps presentation specific information in the various views and provides for multiple UI modules e.g. editors and viewers to respond to data model changes. Operation by the developer of the editors and viewers on the display see can be assisted by the wizards for guiding the development of the application and or standard data components .

Referring to the UI Layer is comprised of the set of editors viewers wizards and dialogs . The UI Layer uses the Model View Controller MVC pattern where each UI module is both a View and a Controller. UI Layer modules interact with data models with some related control logic as defined by the MVC pattern. The editors are modules that do not commit model changes until the user of the developer tool chooses to Save them. Viewers are modules that commit their changes to the model immediately when the user makes them. Wizards are modules that are step driven by a series of one or more dialogs wherein each dialog gathers certain information from the user of the developer tool via the user interface see . No changes are applied to the design time model using the wizards until the user of the developer tool selects a confirmation button like a Finish . It is recognised in the example plug in developer tool environment modules can extend two types of interfaces Eclipse extension points and extension point interfaces. Extension points declare a unique package or plug in already defined in the system as the entry point for functional extension e.g. an editor wizard or project. Extension point interfaces allow the developer tool to define its own plug in interfaces e.g. for skins and backend connectors as further described below.

The developer tool data models are based by example on the Eclipse Modeling Framework EMF . It is recognised that other modeling frameworks can be used as desired. The framework provides model change notification persistence support and an efficient reflective API for manipulating EMF objects generically. The code generation facility is used to generate the model implementation and create adapters to connect a model layer with the user interface modules of the UI layer .

Referring again to modules primarily Editors and Viewers in the developer tool are observers of the data models and are used to interact or otherwise test and modify the data models of the application e.g. components see and standard data components see in question. It is recognised that the components of the application and the standard data components preferably of the runtime environment RE can be incorporated as a set in the data models in order to test the interoperability of the components as needed by the developer when using the developer tool . When the data model changes the models are notified and respond by updating the presentation of the application . The developer tool uses the Eclipse Modeling Framework EMF for example to connect the Eclipse Ul framework to the developer tool data model whereby the modules can use the standard Eclipse interfaces to provide the information to display and edit an object on the display see . In general the EMF framework implements these standard interfaces and adapt calls to these interfaces by calling on generated adapters that know how to access the data model residing in memory . The design time Data Model is used to represent the current version of the application e.g. an application module in development along with the standard data components and is accessed by the users employing the modules to interact with associated data of the model . Modules can also trigger validation actions on the Design Time Data Model . Modules can also cause some or all of the application to be generated from the Design Time Data Model resident in memory . In general the Design Time Data Model accepts a set of commands via the UI see that affect the state of the model and in response may generate a set of events. Each module editor and viewer described includes the set of commands and the events that affect the module and data model pairing.

Referring to the Runtime Data Model represents the state of an emulated application under development by the developer tool using as a basis the contents of the design time data model . The runtime data model stores values for the following major items such as but not limited to standard data components Data Components see Global Variables Message Components Resources Screen Components and Styles. The Runtime Data Model collaborates with the Design Time Data Model and a Testing Preview viewer not shown during emulation of application for testing and preview purposes for example . The viewer also collaborates with the skin manager for emulating the runtime data model for a specified device type. The Runtime Data Model also notifies through a bridge the viewer as well as any other modules of the UI layer associated with changes made to the model . For example an API call can be used as a notifier for the associated modules when the state of the model has changed. The Design Time Data Model represents the state of an application development project and interacts with the modules of the UI layer by notifying modules when the state of the model has changed as well as saving and loading objects from storage . The model s primary responsibility is to define the applications including such as but not limited to the following items standard data components Data Component . Definitions Global Variable Definitions Message Component Definitions Resource Definitions Screen Component Definitions Scripts Style Definitions and Backend data source Mapping Descriptors. The Design Time Data Model responds to commands of each editor viewer . The Design Time Data Model also fires events to modules in response to changes in the model as well as collaborating communicating with the other modules module module interaction by notifying respective modules when the data model has changed. The data model depends on an interface in order to serialize model content retrieval and storage to and from the memory .

The above describes the mechanism used by the developer tool editors and viewers to interact with the models . The EMF.Edit framework is an optional framework provided by the Eclipse framework. The developer tool can use the EMF.Edit framework and generated code for example as a bridge or coupling between the Eclipse UI framework and the tool models . Following the Model View Controller pattern the editors and viewers do not know about the models directly but rely on interfaces to provide the information needed to display and edit.

It is recognised that the SDCs could be part of the skin manager for emulating the runtime environment RE of the device and or the SDCs could be part of the application model layer see along with the model of the application including application elements such as but not limited to component metadata descriptions as well as at least a reference e.g. mapping to the SDC . In general the SDCs are built by a standard component module using knowledge of the properties stored in a native module such as but not limited to the data structures of the NDAs e.g. the NADEs and or the communication interface of the respective APIs as well as those data structures used by the device for storing the NADEs in the memory of the device . The application developer creates the SDCs using the module of the developer tool whereby the runtime environment RE utilizes the SDCs information during execution of the application when accessing the data of the NDAs . The SDCs can be generated as an annotation to the application metadata or for example the SDCs can be included as a separate file instead for inclusion in a representative runtime environment RE module for implementation on the device .

Referring again to a service layer provides facilities for the UI layer such as validation localization generation build standard data component module and deployment further described below. The developer tool can make use of the Eclipse extension point mechanism to load additional plug ins for two types of services backend connectors and device skin managers with associated presentation environments .

The backend connector defines an Eclipse extension point to provide for the developer tool to communicate with or otherwise obtain information about different backend data sources in order to obtain the message format e.g. as provided by WSDL definitions of the selected data source . The backend connector can be used as an interface to connect to and to investigate backend data source services such as Web Services and SQL Databases. The backend connector facilitates building a suitable application message and data set to permit communication with these services from the application when running on the device . The backend connector can support the access to multiple different types of data sources such as but not limited to exposing respective direct communication interfaces through a communication connector based architecture. At runtime the developer tool reads the plug in registry to add contributed backend extensions to the set of backend connectors such as but not limited to connectors for Web Services.

The Backend Connector can be responsible for such as but not limited to connecting to a selected one or more of the backend data sources e.g. Web Service Database providing an interface for accessing the description of the backend data source e.g. messages operations and data types and or providing for the identification of Notification services those which push notifications over the network to the device see . The Backend Connector can provide an interface to the backend data source e.g. a web service SQL Database or other for access of the data source description and can provide a level of abstraction between implementation specific details of the backend messaging and generic messaging descriptions. For example the Backend Connector can be used to generate appropriate messaging and data component e.g. data elements sets for the application and is used by the Model Validator as part of validation tasks to verify models with standard data components under development. For example the backend connector can be implemented as an interface using an API call as the protocol to access the underlying backend data source e.g. using a WSDL Interface for Web Services . It is recognised that the data source information accessed through the connector can be used to help construct the standard data components as further described below.

The device skin manager defines an Eclipse extension point for example to allow the developer tool to emulate different devices see such that the look and feel of different target devices of the application can be specified. At runtime the developer tool reads the plug in registry to add contributed skin extensions or presentation environments to the set of device environments coordinated by the manager such as but not limited to environments for a generic BlackBerry or other device . The Skin Manager is used by the Testing Preview viewer to load visual elements of the data model that look appropriate for the device that is being emulated i.e. elements that are compatible with the specified environment . Different skins or presentation environments formats are pluggable into the manager of the developer tool meaning that third parties can implement their own presentation environments by creating new unique SkinIds an Eclipse extension point for example and implementing an appropriate interface to create instances of the screen elements supported by the runtime environment RE of the emulated device . In order to load a new presentation environment the Testing Preview viewer first asks the Manager for an instance of the specified environment . The Manager then instantiates the environment and the Testing Preview viewer uses the specified environment to construct the screen elements according to the screen components of the model . For example the presentation environments e.g. SkinPlugins are identified to the SkinManager through a custom Eclipse extension point using the Eclipse framework.

The model validation of the service layer provides facilities for the UI layer such as validating the design time data model and or the standard data components . The Model Validator is used to check that the representation of application messages is in line with the backend data source presentation of messaging operations. The Model Validator can be responsible to validate the model representation of the application to be generated for example such as but not limited to elements of workflow sanity of the workflow component consistency of parameters and field level mappings of the components screen control mappings and screen refresh messages of the screen components message and or data duplications inter and intra component . In order to achieve its responsibilities the validator collaborates with the Design Time Data Model the message structures an application generator and the backend connector . The Model Validator utilizes as part of the validation task the Design Time Data Model for application validation and the message structures as well as the backend connector which supports the interface to the backend data sources .

Referring again to the localization Service has responsibilities such as but not limited to supporting a build time localization of user visible strings supporting additional localization settings e.g. default time date display format default number display format display currency format etc and creating the resource bundle files and resources that can be used during preparation of the deployable application e.g. an application jar file by a Build Service . For example the localization service can be implemented as a resource module for collecting resources that are resident in the design time data model for inclusion in the deployable application . The JAR file can be a file that contains the class image and sound files for the application gathered into a single file and compressed for efficient downloading to the device . The Localization Service is used by the application Generator to produce the language specific resource bundles for example. The Build Service implements preparation of the resource bundles and packaging the resource bundles with the deployable application . The Localization Service interacts provides an interface with the tool editors and viewers for setting or otherwise manipulating language strings and locale settings of the application .

Referring to the Generator can be responsible for such as but not limited to generation of the application XML from the components optimizing field ordering of the component descriptors and generation of dependencies and script transformation as desired for storage in the memory . The Generator collaborates with the Design Time Data Model to obtain the content of the developed components comprising the application as well as cooperating with the standard data components . The Generator utilizes the Model Validator to check that both the application definitions of the components are correct. The Generator then produces the XML code of the application with inclusions and or augmentations of the script of the workflow components and or the standard data components file descriptors used by the runtime environment RE . The Generator uses the Localization Service to produce the language resource bundles through for example a Resource Bundles interface not shown . The Generator generation process can be kicked off through a Generate interface accessed by the developer using the UI of the developer tool i.e. by user input events such as mouse clicks and or key presses . It is recognised that the generator can be configured as a collection of modules such as but not limited to a code module for generating the XML which may include associated script . It is recognised that the standard data components can be developed while the application is in development or can be developed once the application development is complete.

The deployment service is used to deploy the appropriate application descriptor file with respect to the repository and registry and or to deploy the standard data components for example as part of a published runtime environment RE module upgrade or for incorporation as original operating software supplied with the device when provided to the user . The Build Service provides a mechanism for building the deployable form of the application and or the runtime environment RE module . The Build Service produces via a build engine the deployable application file and or the runtime environment RE module file. These files are made available to the deployment service via an output interface of the developer tool . The security service has the ability to sign the application file and or the runtime environment RE module file to prevent tampering with their contents and to provide the identity of the originator. There can be two example options for signing either making use of DSA with SHA1 digest or RSA with MD5 as is know in the art. For example the security service can handle certificates that are used for application and or mapping model file signing. The security service can have the ability to request store and use a public private key pair to help ensure the validity of both the originator and content of the application and or runtime environment RE module files as deployed.

As described above the component applications are constructed by the developer tool in a component based means with a plurality of interacting components . Preferably runtime elements of the applications are defined as provisioned components for example as described above in the runtime environment RE. In one embodiment the applications comprise a data component components of other types e.g. components and reference and or inclusion of the SDCs for representing shared by multiple applications standard data definitions for accessing the NADEs . Each component is of a specific type which is associated with predefined behaviors or functions. For example each data component could be created deleted updated and its field values can be retrieved and or set. In one embodiment of the component applications three types of components include i data component having behaviors to create remove load persistent update ii message component having a send or transmit behaviour and iii screen component having behaviours to display refresh close displayed elements on the UI of the device .

The component based applications are preferably provided shared access to the NADEs of the native device applications through the preferably shared SDCs provisioned in the runtime environment RE. The SDCs can be provisioned as part of the application i.e. multiple copies of the SDC for each of the provisioned applications or as part of the runtime environment RE and therefore shared by multiple applications i.e. a single copy of the SDC shared by multiple provisioned applications . It is noted that the SDC XML definitions can be included as part of the runtime environment RE module implemented on the device for access to all provisioned applications similar in function to the common set of services provided to the applications see and therefore the SDCs are only referenced for example by name in the XML definitions metadata of the component applications . Another SDC implementation embodiment would be for the XML definitions metadata of the SDC to be part of the application XML definitions metadata but only one copy is provisioned in the runtime environment RE for sharing by the plurality of the component applications provisioned in the runtime environment RE. In this case the runtime environment RE would have knowledge of the sharable SDCs and would only provision the first copy of a particular SDC while other provisioning requests would be denied and instead access given to the already provisioned initial SDC . In any of the manners described above access to the NADEs of the NDAs would be provided to the component applications via the SDCs .

It is recognised that knowledge of the API features e.g. callable functions and call format must be made available to the user of the developer tool when developing the SDCs in the case where the APIs are used to access the NADEs through the NDAs . Otherwise knowledge of the storage format and content for example of the NADEs are made available to the user of the developer tool when developing the SDCs in order for inclusion in the definitions of the SDCs to enable direct access by the applications e.g. such as in interaction between components with the appropriate SDC of the NADE data content. Accordingly in either case direct or indirect access of the NADEs the SDCs are treated as another version of the application data components described above. It should be noted that in both access cases the runtime environment RE would have knowledge of the storage location of the NADEs in the storage for example as monitored by the persistence service of the services framework see . Otherwise the runtime environment RE would rely upon the operating system of the device infrastructure for information on the storage location of the NADEs in the memory .

As shown symbolically in the runtime environment RE and the developer tool share the common set of standard data component definitions. It is recognised that the developer tool can have multiple sets for different devices and combinations of component applications and or can have a master set for use in developing all envisioned component applications for all envisioned runtime environments RE of selected devices . The runtime environments RE provides a runtime context and implementation of the SCDs while the developer tool offers application developers the facilities of accessing and embedding or otherwise associating the definitions of the SCDs into with the component applications in the development stage. Further it is recognised that the SDCs content of the runtime environments RE and the developer tool are to be in sync in order to provide for proper implementation of the developed applications coupled to the SDCs . Furthermore different versions of the SDCs could be developed by the developer tool for different targeted runtime environments RE and devices .

Furthermore it is recognised that certain Functions that are not available through the device APIs can be incorporated as behaviours or functions of the data components which automatically become available to SDCs during execution of the now coupled components of the application with the SDC . For example in the development of the application with built in SDCs search functions can be defined and incorporated into the data components which the become available to any SDC cooperating with the application components during access of the NADEs . For example a Contact search function is usually not directly available through the device API . Without built in SDCs the developer may have to implement the search function for each of the NADEs and the code written is not sharable among device applications that require the same function. It is recognised that the additional functionality desired could also be incorporated in the SDCs themselves as desired or shared between the data components and the SDCs .

Further it is recognised that the additional functionality could include searching across a grouping of NADEs i.e. the SDC accesses data from a plurality of the NDAs of the corresponding NADEs . With respect to the data component along with the aforementioned behaviours for individual data components the search function or other additional desired functionality features may be available to a set of the data components or a data collection.

Referring to a generation process of the standard data component in conjunction with information on the component application and the properties of the data entity NADE is shown including steps such as but not limited to 

step accessing the model of the component based application including features of data and message component definitions expressed in the structured definition language 

step generating the standard data component definition based on the features of the component based application and the properties of the data entity of the native application the standard data component definition expressed in the structured definition language and

step incorporating the standard data component definition into either the component based application definitions or the runtime environment RE module for execution on the device .

Advantageously in the component based application the access to the built in data repository NADEs of the device is presented as access through standard data components SDCs thereby helping to reduce the need for additional and non reusable between device applications code in each application as could be the case for a traditional application exposing the access as device APIs . Moreover when developing the component application coupled to SDCs the developer may not have to use platform dependent APIs and implement corresponding code to access standard data repositories NADEs e.g. Contact Email Task etc. as is usually inevitable for the traditional applications NDAs . Advantageously by cooperating with SDCs in a manner used for the other data components the interacting components of the application can access the data in the NADEs such as but not limited to data being created modified deleted and or searched in a device independent manner.

The developer tool system and methods described above may be implemented by any hardware software or a combination of hardware and software having the above described functions. The software code either in its entirety or a part thereof may be stored in a computer readable memory. Further a computer data signal representing the software code which may be embedded in a carrier wave may be transmitted via the communication network . Such a computer readable memory and a computer data signal are also within the scope of the present invention as well as the hardware software and the combination thereof. While particular embodiments of the present invention have been shown and described changes and modifications may be made to such embodiments without departing from the true scope of the invention.

