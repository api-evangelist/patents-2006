---

title: Mechanism for transparently interfacing with a third party version control system
abstract: Approaches for transparently interfacing with a third party version control system (VCS) are provided. In one approach, an enterprise application integration (EAI) system comprises an integrated development environment (IDE) client, a repository, an API, and an API implementation. The IDE client enables a user to develop one or more functional components that can be used or executed to derive one or more enterprise application functionalities. The repository interacts with the IDE client to save and access the one or more functional components. The API is invoked by the repository to interact with any VCS. The API implementation enables the repository, by way of invoking the API, to interact with a VCS, which is an external VCS that is not provided as part of the EAI system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07950024&OS=07950024&RS=07950024
owner: Oracle America, Inc.
number: 07950024
owner_city: Redwood City
owner_country: US
publication_date: 20061227
---
Early software programs in areas such as inventory control human resources sales automation and database management were designed to run independently with no interaction between the programs. The programs were custom built in the technology of the day for a specific need being addressed and were often proprietary systems. As enterprises grew and recognized the need for their information and applications to have the ability to be transferred across and shared between systems companies began investing in enterprise application integration EAI systems in order to streamline processes and keep all the elements of the enterprise interconnected.

Some EAI systems include an integrated development environment IDE also known as integrated design environment and integrated debugging environment . An IDE is a type of computer software that assists computer programmers in developing integrated software applications. IDEs typically consist of a source code editor a compiler and or interpreter build automation tools and usually a debugger. Sometimes a version control system VCS and various tools to simplify the construction of a GUI are integrated as well. Although some multiple language IDEs are in use such as the Eclipse IDE NetBeans and Microsoft Visual Studio an IDE is typically devoted to a specific programming language as in the Visual Basic IDE.

Today many EAI systems contain their own VCS. However many enterprises that purchase EAI systems prefer to continue to use their existing third party VCS rather than the embedded VCS of their respective EAI system. Common third party VCSs include Concurrent Versions System CVS Source Code Control System SCCS and Clear Case. Such enterprises typically configure an IDE client to interact directly with the third party VCS. In order to use a third party VCS an integration project is saved locally as components e.g. files and the components are then checked into the third party VCS. A plug in i.e. an API is used to allow the IDE client to interact with the third party VCS.

The system of may operate as follows. A source file for a coding project is created and stored locally on IDE client . A user e.g. through a GUI of IDE initiates a check in operation whereby IDE invokes the VCS API which causes the API implementation to be executed. In turn the API implementation invokes the check in function of the VCS which causes the source file to be stored in data storage .

A disadvantage of the above approach is the significant risk of losing work if a user does not take the steps necessary to check in modified files to a VCS. For example if a user forgets to check in modified files then all the changes may be lost when the user logs out of the system. Therefore there is a need to provide a better mechanism for enabling a third party VCS to be used in an EAI system.

The approaches described in this section could be pursued but are not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

An approach for transparently interfacing with a third party version control system VCS is provided herein. According to an embodiment an enterprise application integration EAI system comprises an integrated development environment IDE client a repository an API and an API implementation. The IDE client enables a user to develop functional components that can be used or executed to derive one or more enterprise application functionalities. The repository interacts with the IDE client to save and access the functional components. The API is invoked by the repository to interact with any VCS. The API implementation enables the repository by way of invoking the API to interact with a VCS which is an external VCS that is not provided as part of the EAI system. Thus the IDE client need not be concerned with aspects of the VCS because the repository takes care of them.

In one embodiment multiple API implementations may be provided. These API implementations enable the same API to be used to interact with different VCSs.

The systems and methods described herein relate to transparently interfacing with a third party version control system. For purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the various systems and methods. It will be apparent however that the systems and methods described herein may be implemented without these specific details. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

With an IDE client such as IDE client a user defines all or portions of an enterprise application. For example a user may develop enterprise applications through all phases of development generating source code compiling the source code and debugging the source code all with an IDE client. Overall a user may use IDE client to define functional software components that can be executed to give rise to an enterprise application. When the user is ready to save components the user causes IDE client to invoke repository . Repository responds by causing components which may take the form of definition configuration and or executable files to be stored in a VCS. Similarly repository accesses components requested by IDE client .

Although IDE client knows that it is saving and accessing components IDE client may be unaware that any VCS is involved. As far as IDE client knows IDE client is simply saving and accessing components. On the other hand repository knows that it is interacting with a VCS however repository is not required to know which particular VCS it is interacting with. The API implementation takes care of the specifics of the VCS. In software terms the third party VCS is transparent to IDE client and repository . In other words in the views of IDE client and repository it is as if the native VCS provided with EAI system were used instead of a third party VCS.

With the information from IDE client repository invokes a VCS API . By doing so repository causes components to be stored in or accessed from a VCS such as VCS . In one embodiment the VCS is not native to EAI system but is provided by a third party. VCS API provides repository with a standard interface that it can use to interact with any third party VCS. The API implementation will translate the API calls into proper calls for invoking the functionalities of the specific third party VCS.

Components are analogous to source files with a traditional IDE. Components are not required to be stored locally on a user s system like files but rather may be stored through the repository.

Components may be any of various types of files such as files from a Java collaboration and object type definitions or OTDs which represent different kinds of messages that are used in executing EAI applications . Components may include definition files configuration files executable files and all metadata about a particular project that is built. Ultimately components may be stored in a VCS as a file. In one embodiment a component is an XML file that describes an object which indicates that the repository may model an object database.

VCS API provides methods that can be called by repository to access and store components. Some methods may include 

API implementations such as API implementation implement VCS API . There is one API implementation for each VCS. The API implementation translates calls to the methods of the API into proper calls for invoking the functionalities of the specific VCS. In normal operation because only one VCS is used at a time only one API implementation is required. In order to use another VCS another API implementation is implemented. Multiple API implementations i.e. and are shown to illustrate that any VCS may be used so long as a proper API implementation is provided. Each VCS may provide a different interface for interacting with other components. Thus an API implementation includes logic to properly interact with a VCS e.g. call the right methods of the VCS .

For example suppose a VCS provides several methods that can be invoked such as check in and check out . Suppose further that these methods need to be invoked in a certain way using a certain call or message format suppose further that the API has the methods save and retrieve . When the repository invokes the save method the API implementation translates that into a check in request with the proper format. Similarly when the repository invokes the retrieve method the API implementation translates that into a check out request with the proper format.

The following is an example of how components may be stored and accessed in an EAI system such as EAI system . Using IDE client a user logs into EAI system and develops a new component for an enterprise application. Using IDE client the user saves the new component. Repository receives the save request and invokes VCS API e.g. invokes the save method of API . In response to the invocation of the API the API implementation translates the invocation into a proper call to VCS having the format expected by VCS . The proper call may be for example check in . The API implementation then sends the call to VCS . VCS subsequently checks the component in to data storage .

Thus by saving the component the IDE client is causing the component to be checked in to a VCS. The IDE client does not even have to be aware that the component is being checked in to the VCS. With this setup a user does not have to save a file locally and then affirmatively check the component in. The check in process is performed automatically and transparently to the user which is a significant improvement over the current methodology.

In one embodiment repository implements a workspace for each user. A user may save work e.g. modified components to his her respective workspace without performing a check in. Thus the user may later choose to check in a modified component which then causes VCS API to be used and the modified component to be checked into VCS . Therefore in this embodiment a save operation by a user does not automatically check in the component to the appropriate VCS. However because a user s workspace is still within the repository different client machines may access saved work. Also saved work is not lost if the user fails to check in a modified component as is the case with traditional IDEs.

In a subsequent session the user logs into EAI system and desires to modify the newly created component. Using IDE client the user requests the component from repository . In response to the request from IDE client repository invokes VCS API for example by calling the retrieve method. API implementation translates the retrieve method into a proper call and format such as a check out call. VCS then checks out the component from data storage and provides the component to repository which provides the component to IDE client .

EAI system may comprise multiple version control systems as illustrated such as VCS and VCS . Accordingly the EAI system may comprise multiple API implementations and one for each VCS. In such a system the user or another user may use IDE client to save components to and retrieve components from repository . In response to requests to save components repository invokes methods of VCS API . In response to the invocations of the API one of the API implementations e.g. the API implementation translates the invocations into proper calls to VCS having the format expected by VCS . The API implementation then sends the calls to VCS to for example check components in and out of data storage .

In one embodiment VCS like VCS is not an integrated VCS provided with repository and or IDE client but rather is a VCS provided by a third party.

One benefit of the above approach is that rather than storing files locally files are stored through a repository which is a common place that multiple IDE clients may connect to in order to ensure that all modified files are checked into a VCS. Otherwise when working with local files there is a significant risk that one or more users will forget to perform a check in of modified components thus losing important changes and wasting valuable time.

Computer system may be coupled via bus to a display for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

In computer system bus may be any mechanism and or medium that enables information data etc. to be exchanged between the various components. Bus may further be a network connection that connects one or more of the components. Any mechanism and or medium that enables information data etc. to be exchanged between the various components may be used as bus .

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable medium as used herein refers to any storage medium that participates in providing data that causes a machine to operation in a specific fashion. In an embodiment implemented using computer system various machine readable media are involved for example in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and tangible media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory .

Common forms of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM DVD or any other optical storage medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge or any other tangible non transitory medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may be carried on a magnetic disk of a remote computer. Bus may carry the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented.

Network link typically provides data communication through one or more networks to other devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet .

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

At this point it should be noted that although the invention has been described with reference to a specific embodiment it should not be construed to be so limited. Various modifications may be made by those of ordinary skill in the art with the benefit of this disclosure without departing from the spirit of the invention. Thus the invention should not be limited by the specific embodiments used to illustrate it but only by the scope of the issued claims and the equivalents thereof.

