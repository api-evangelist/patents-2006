---

title: Redirection of embedded content
abstract: A method for extracting content from a data store includes creating a file identifier mapped to an item. The method includes receiving a request that seeks cached access to the item and that is not directed to the item. In response to the request, contents of the item are provided using the file identifier without caching the contents. A system for extracting content from a data store includes an indexer. The system includes a data store containing at least an item. The system includes a redirector containing a file identifier mapped to the item. When the redirector receives a request originated by the indexer that seeks cached access to the item and that is not directed to the item in the data store the redirector provides contents of the item using the file identifier without caching the contents in the system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08185564&OS=08185564&RS=08185564
owner: Google Inc.
number: 08185564
owner_city: Mountain View
owner_country: US
publication_date: 20061121
---
Many computer systems place data volumes in one or more data stores. The storage may be intended for short or long periods but it can happen that one or more portions of information must be extracted from time to time. Extraction can for example be required for purposes of indexing because an indexing application being executed in the system may need the information extracted before the indexing can be performed. Such indexing and associated extraction can be performed on the textual contents of the data store s and also on metadata that may be included in any of the items.

The extraction of item content can in conventional systems involve the creation of a temporary file for the content. Such a temporary file can then be placed on a disk in the system. While it is on the disk the temporary file may be subject to inadvertent indexing by another routine or subject to unauthorized access. Generally the presence of the temporary file on the disk consumes some amount of system resource and may affect performance. In some situations the resource consumption may be considered a significant factor for example where only a fraction of the content is used in the indexing.

The access to content in a data store can sometimes affect the cache memory in the system. Particularly if a relatively large amount of data that is retrieved is made to pass through the cache memory this can result in other data being evicted from the cache. This can also cause the cache to grow at the cost of other system memory and so evict code and data from system memory.

In a first general aspect a computer implemented method for extracting content from a data store includes creating a file identifier mapped to an item. The method includes receiving a request that seeks cached access to the item and that is not directed to the item. In response to the request contents of the item are provided using the file identifier without caching the contents.

Implementations can include any all or none of the following features. The method can further include presenting semantics compatible with a cached access while providing the contents. The presented semantics can include that at least one of a read or write operation with an arbitrary starting byte offset is allowed. The presented semantics can include that at least one of a read or write operation with an arbitrary size is allowed. The presented semantics can include that the request is not restricted to be sector aligned in a starting byte offset or in size. The request can be generated for indexing of the contents. The method can further include presenting a virtual file system including at least the file identifier. The method can further include generating a prompt to seek the access to the file identifier and the contents can be provided in response to the prompt. The method can further include providing at least part of the contents to perform the indexing.

In a second general aspect a system for extracting content from a data store includes an indexer. The system includes a data store containing at least an item. The system includes a redirector containing a file identifier mapped to the item. When the redirector receives a request originated by the indexer that seeks cached access to the item and that is not directed to the item in the data store the redirector provides contents of the item using the file identifier without caching the contents in the system.

Implementations can include any all or none of the following features. The redirector can include a kernel mode driver in the system. The kernel mode driver can terminate in a user land application program interface available at least to the indexer. The redirector can include a dynamic link library hosting an object that provides the user land application program interface. The redirector can include a system account service configured to start and stop the redirector. The redirector can include a server presenting to the extractor a virtual file system that includes at least the file identifier.

The details of one or more implementations of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention will be apparent from the description and drawings and from the claims.

The system includes a redirector . The redirector can be logically attached to and can be coupled with the indexer as indicated by arrow . In another implementation the redirector can be implemented in the indexer . The system can use the redirector for redirecting a request for extraction of content when for example the resident extractor of the indexer or any third party extractor it may employ encounters content e.g. embedded content that the extractor is not configured to handle. For instance the system can use the redirector if the extractor during extraction for indexing purposes encounters content such as the embedded item in the data store that cannot be extracted e.g. because of the API or the file format . Particularly the redirector can facilitate the extraction of content without writing the content item to a temporary file such as a disk .

The system can include an extractor e.g. third party extractor software . The extractor can include for example one or more applications e.g. third party software that are configured to extract textual contents and metadata from various file types such as email messages word processing documents spreadsheets instant messages web pages and files in archives to name a few examples. In a sense the extractor can represent the collection of third party applications configured to extract content of various formats that the indexer can index. The indexer can invoke the extractor as indicated by arrow .

In some implementations the extractor can use one or more Portable Document Format PDF to text converters such as the Linux Unix command pdftotext for extracting PDF documents. In other implementations the extractor can use one or more document based filters such as the Microsoft Office Document Filter for extracting content from documents such as word processing documents spreadsheets and presentation applications. In yet other implementations the extractor can use one or more other interfaces such as Windows Shell programmatic interfaces for extracting metadata e.g. document authors titles etc. .

The extractor can be logically attached to the redirector as indicated by arrow . During the extraction process information can flow among the indexer the extractor and the redirector as indicated by the arrows and . Such information can include requests and responses extracted content and metadata corresponding to the extracted content. A more detailed exemplary description of the interactions among the indexer the extractor and the redirector is included below in reference to .

To facilitate file identification for the extraction by the extractor the redirector can maintain a file system e.g. a virtual file system . The file system can keep track of and provide access to the files within the system that are to be extracted and indexed. For example the file system can provide access to items in data stores that are extracted by the extractor . This access can be independent of the underlying physical file structures of the items and the data stores .

The file system can provide similar access to the indexer so that it can access items in data stores for indexing purposes as indicated by arrow .

The file system can include one or more file identifiers . Such identifiers can serve to represent e.g. virtually the collection of files that can be extracted and indexed in the system . For example the indexer generates the file identifier e.g. a unique file name for the item . Here the file identifier is mapped one to one to the associated physical item as indicated by dashed arrow . If there are several file identifiers in the file system each can have a corresponding mapping . The mappings can facilitate extraction of content within the system that relies on the use of the redirector . For example the extractor when extracting content from the item can access the file e.g. a word processing document attachment embedded in an email message virtually via its corresponding file identifier .

The system can also be used to extract and index non embedded content. For example the item such as a text file can be a file that is not embedded within a data store . In this case the indexer can direct the extractor to open the file directly to extract information used for indexing purposes. Thus the extractor can provide extracted content to the indexer for indexing and this content can include information that was obtained from an embedded item and contents from a non embedded item.

The system can also be configured to extract content from a data store without dragging the content through a cache. For example when extracting content from the item the indexer and the redirector can access the item directly bypassing the cache . Particularly bypassing can be accomplished while providing semantics to the entity requesting the information that are compatible with a cached access. For example while the software interface of the access to item can remain unchanged the low level e.g. kernel mode implementation can bypass the logic that writes intermediately to the cache. In some implementations the cache bypass can be implemented by invoking RxIndicateChangeOfBufferingState or a similar procedure for changing the buffering state in order for example to disable all local read write caching. In other implementations the cache bypass can be implemented by changing the internal software logic of the redirector such as at the kernel mode to include a modified caching implementation that bypasses the system wide caching implementation and so does not contribute to system cache growth and the subsequent eviction of other needed data. Providing non cached input output can have the advantage of improved system performance by avoiding cache manager poisoning. Such poisoning can occur for example when the indexer drags large amounts of data through the cache manager evicting other data such as executable images and data of other programs that are running.

Before or when it is time to index the indexer can determine that the data store contains embedded content. In particular the embedded content can have a content type that the API of the indexer is not configured to extract. For example the embedded content can be a word processing document e.g. included in zip archive that the extractor cannot read.

In order to extract the sought contents the indexer can create a unique name for the embedded content in the namespace of the redirector . To complete this operation the indexer can first invoke the redirector using the redirector s API passing it the name of the data store and the unique name for the content. The redirector can store the unique name for this file for example in the file system . This can provide the extractor access e.g. virtual access to the item which in this example is a file . The file is here shown outside the data store to illustrate that to the extractor the file can appear as located in a virtual file system generated by the redirector.

The indexer can request the extractor to extract the content of the file. The request can occur for example using the extractor s API . In general this type of request can be for embedded content or for non embedded content. For example if the request is to extract embedded content such as the word processing document embedded in an archive the extractor can be requested to extract the document. In another example if the request is to extract non embedded content such as a single specific file the extractor can be requested to extract the single specific file. In either case the request can be to extract the metadata and or contents of the document or file. Having received the extraction request from the indexer the extractor can request the file from the file system of the redirector . The extractor can receive the file from the redirector using the redirector s API .

After the extractor requests the file from the redirector the redirector can notify the indexer . The notification of the content extraction request can occur using the API of the redirector . The requested content can be for example the word processing document that is embedded in the data store .

Once the redirector has completed its redirection of the extraction request the indexer can retrieve the contents of the embedded file. For example the indexer can extract the contents of the word processing document that is embedded in the data store . This extraction process can occur on a byte by byte basis or on a block by block basis such as in a generic read system call that can use a starting index and a length.

After the content has been extracted such as from an embedded or non embedded file the indexer can forward the extracted content e.g. for receipt by the third party software that forms the extractor . The operation of forwarding the content can use the extractor s API and the redirector s API .

The extractor can accumulate the extracted content received from the indexer and optionally combine the extracted content with other textual content or metadata extracted earlier. For example content that the indexer extracted from the word processing document for indexing purposes can be accumulated with earlier extracted textual content and metadata such as words or phrases in the document and the document s attributes. While the extraction is taking place the extractor can for example keep partially extracted content in memory and may optionally return partial extracts to the indexer through the extractor s API .

Using the extracted content provided by the extractor the indexer can index the content. The indexing can occur on extracted embedded content as well as extracted non embedded content. For example the indexer can index embedded content e.g. the word processing document extracted in an operation involving the redirector as well as non embedded content extracted directly e.g. without redirection by the extractor .

In another implementation the indexer need not notify the redirector of the existence of a virtual file identifier before requesting that it be opened. For example when the extractor attempts of access the file the indexer can be notified and handed back the identifier e.g. a path or file name that was passed to the extractor cf. step .

In step the content can be accessed using the file identifier. For example the indexer can provide the file identifier to the extractor . Selection of the particular third party software that can perform the extraction and thus form the extractor can be based on metadata associated with the file identifier that can aid in identifying the type of content to be extracted. For example if the file identifier maps to a word processing document the extractor can use third party software that extracts that type of word processing document content. By providing the file identifier to the extractor the indexer is directing the extractor to extract the contents of the item mapped to by the file identifier .

In step the file identifier i.e. identifying the file to be extracted is requested. For example the extractor can make a request to the redirector to open the name of the file from which content is to be extracted. In particular the file name can be the file identifier that is mapped to the item which contains the content to be extracted. Such a file identifier can be included in the file system .

In step notification is made to provide the content. For example the notification can be made using the API of the redirector. For instance the redirector using its API can notify the indexer to extract the embedded content detected in step .

In step extraction begins e.g. the indexer can access the data store to begin extraction . For example the extraction can complete in step when for example the indexer retrieves the remaining contents of the data store . Such extraction can occur on a byte by byte and or a block by block basis without extracting the content to a temporary file. For example the indexer can extract the item without having to write to the disk . Redirecting without using temporary files can provide the advantage of improved system efficiency by avoiding the corresponding extra processing and disk input output that temporary files use.

In step the extracted content is stored. For example the indexer can provide the content extracted in step to the redirector for storage.

In step the contents of the item are provided. For example the redirector can provide the third party software that forms the extractor with the contents of the word processing document extracted in step . The content can be combined with other content previously received by the extractor such as textual content or metadata extracted at other times.

In step all or some of the extracted contents are provided. For example the extractor can provide some or all of the content extracted from the item to the indexer . The extractor can also provide other extracted content such as textual content or metadata extracted at other times. Upon receipt of the contents the indexer can perform indexing based on those contents.

In step an access request is initiated. For example the indexer can provide the file identifier to the extractor directing the extractor to seek access to the file. Selection of the third party software that can form the extractor can be based on metadata associated with the file identifier that can aid in identifying the type of content to be extracted. By providing the file identifier to the extractor the indexer is directing the extractor to extract the contents of the item mapped to by the file identifier . In another implementation the extractor is not used and instead the indexer is the component that requests the item content from the redirector.

In step access to the file identifier is requested. For example the extractor can make a request to the redirector to open the name of the file from which content is to be extracted. In particular the file name can be the file identifier that is mapped to the item which contains the content to be extracted. Such a file identifier can be included in the virtual file system . In an implementation that does not use the extractor the indexer can send the request .

In step extraction begins. The extraction occurs in step when the redirector retrieves the contents of the data store. Such extraction can occur on a byte by byte and or a block by block basis without using the cache. For example the redirector can extract the item without having to use the cache . Redirecting without using cache can provide the advantage of improved system efficiency by avoiding unnecessary cache poisoning.

The contents are stored in step . For example the redirector can provide the extractor with the contents of the word processing document extracted in step . The content can be combined with other content previously received by the extractor such as textual content or metadata extracted at other times.

In one implementation the redirector extracts the contents without caching them. Moreover the redirector can present semantics compatible with cached file access while doing so. That is the redirector can behave in one or more respects as if it were performing cached access to the contents for example as will be described below. This can provide an advantage in the interaction with the indexer and other components because they may be configured to interact according to a protocol that assumes that caching takes place.

The presentation of semantics compatible with cached access can include the operations that the redirector make available for the other entities such as the extractor that interact with it. This can relate to the reading or writing of data into the data store.

For example the redirector can be configured so that it allows a read or write operation to be performed with an arbitrary starting byte offset. As another example the redirector can be configured to allow the read or write operation to have an arbitrary size. As another example the redirector can be configured to not restrict the request to be sector aligned in a starting byte offset or in size.

In step the contents extracted from the data store are provided. For example the extractor can provide some or all of the contents extracted from the item to the indexer . The extractor can also provide other extracted content such as content having different content types. Upon receipt of the contents the indexer can perform indexing based on those contents.

The components of the redirector can be divided logically into a kernel area and a user land area as indicated by dotted line . For example the types of redirector components in the kernel area can include processes that execute in the kernel area of operating system for purposes of efficiency. The remaining components of the redirector function in the user land area . These components can include components that execute outside of the kernel optionally in connection with system programs and third party applications. In some implementations a given component can have one or more sub components that execute in the kernel area while other sub components execute in the user land area .

The user land area can further be divided logically into a user context area and system context area as indicated by dotted line . The types of redirector components present in the user context area can include third party applications such as applications that extract and index content. The types of redirector components present in the system context area can include system level programs such as those that start and stop processes within the system.

The portion of the redirector in the kernel area is kernel mode application that is here labeled MRxGoogle.sys. The area can include a Redirected Drive Buffering SubSystem RDBSS library embedded in a kernel driver . The RDBSS.lib can serve as a kernel level shell for the redirector. In a sense the RDBSS.lib can serve as a kernel level driver that provides services to sub components in the kernel. The kernel driver can manage integration of kernel interfaces such as interfaces with the memory manager cache manager and input output manager. The kernel driver can also manage most handle level semantics such as per file read write calls and pointers byte range locking and permissions to name a few examples.

The user context area of the redirector includes a GoogleDriveAPI.dll an NPGoogle.dll and a GoogleDesktop.exe . The GoogleDriveAPI.dll can be for example a DLL dynamic link library hosting a COM communication object that provides the AP for handling server registration requests received from the user context area as well as forwarding requests such as share enumeration file open create read write directory enumeration etc. to the user land service e.g. GoogleDesktop.exe . The NPGoogle.dll can provide a network provider data link library for services such as enumeration over the redirector s namespace drive mapping drive mappings enumeration and such. Each of the user context area components can provide access to resources in the kernel area such as those resources used by the system in extraction and indexing operations as depicted in . In a sense the kernel mode driver can be considered to terminate in the user context area where the API of the driver is accessible to the GoogleDriveAPI.dll and the NPGoogle.dll which are in turn accessible to the indexer .

The GoogleDesktop.exe can be a component of the user land area that registers a server object such as one that implements IGoogleDriveServer with the redirector COM AP . During the registration the redirector can be associated with a server name in some namespace e.g. desktop in a UNC namespace . File system operations on the namespace governed by the redirector can subsequently result in calls to the server object and objects in the GoogleDesktop.exe . For example the GoogleDesktop.exe can contain a hierarchy of objects a server a share a file a directory and a directory enumeration which represent entities in the virtual file system presented by the redirector and or handle operations thereon.

As an example an instance of IGoogleDriveFile represents a file on the virtual file system and handles operations such as Read Write SetAttributes etc. whereas an instance of IGoogleDriveDirectory represents a directory on the virtual file system and is responsible for creating an instance of IGoogleDriveDirectoryEnumeration upon request to handle directory enumeration of the virtual directory.

The system context area can include a GoogleDrive.exe system service . The service can be configured to start and stop the redirector at system startup and shutdown .

The memory stores information within the system . In one implementation the memory is a computer readable medium. In one implementation the memory is a volatile memory unit. In another implementation the memory is a non volatile memory unit.

The storage device is capable of providing mass storage for the system . In one implementation the storage device is a computer readable medium. In various different implementations the storage device may be a floppy disk device a hard disk device an optical disk device or a tape device.

The input output device provides input output operations for the system . In one implementation the input output device includes a keyboard and or pointing device. In another implementation the input output device includes a display unit for displaying graphical user interfaces.

The features described can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. The apparatus can be implemented in a computer program product tangibly embodied in an information carrier e.g. in a machine readable storage device for execution by a programmable processor and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output. The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. A computer program is a set of instructions that can be used directly or indirectly in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment.

Suitable processors for the execution of a program of instructions include by way of example both general and special purpose microprocessors and the sole processor or one of multiple processors of any kind of computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally a computer will also include or be operatively coupled to communicate with one or more mass storage devices for storing data files such devices include magnetic disks such as internal hard disks and removable disks magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in ASICs application specific integrated circuits .

To provide for interaction with a user the features can be implemented on a computer having a display device such as a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.

The features can be implemented in a computer system that includes a back end component such as a data server or that includes a middleware component such as an application server or an Internet server or that includes a front end component such as a client computer having a graphical user interface or an Internet browser or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include e.g. a LAN a WAN and the computers and networks forming the Internet.

The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network such as the described one. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

A number of implementations of the invention have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly other implementations are within the scope of the following claims.

