---

title: System and method for managing hard and soft lock state information in a distributed storage system environment
abstract: A system and method manages lock state information in a storage system. A meta-data volume node includes a lock state database which is a comprehensive source for lock state information about data containers in the system. A plurality of data volume nodes include local lock caches, which contain information about locks. Lock state messaging between the meta-data volume node and the data volume nodes is used to assign locks and to update local lock caches. The meta-data volume node is configured to determine whether input/output requests should be allowed or denied and to instruct the data volume nodes of this input/output operation result. Lock information is also sent to the data volume nodes for storage in local lock state caches to the extent the data volume nodes have the network capacity locally.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07730258&OS=07730258&RS=07730258
owner: NetApp, Inc.
number: 07730258
owner_city: Sunnyvale
owner_country: US
publication_date: 20061102
---
This application is a continuation in part application based on U.S. patent application Ser. No. 11 264 831 now U.S. Pat. No. 7 587 558 Smith et al. for a SYSTEM AND METHOD FOR MANAGING HARD LOCK STATE INFORMATION IN A DISTRIBUTED STORAGE SYSTEM ENVIRONMENT which was filed on Nov. 1 2005 and issued on Sep. 8 2009 the contents of which are presently incorporated by reference herein in entirety.

The present invention relates to a distributed cluster computer environment and more particularly to managing hard and soft lock state information in memory constrained components in such environments.

A storage system typically comprises one or more storage devices into which information may be entered and from which information may be obtained as desired. The storage system includes a storage operating system that functionally organizes the system by inter alia invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including but not limited to a network attached storage environment a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array wherein the term disk commonly describes a self contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive HDD or direct access storage device DASD .

The storage operating system of the storage system may implement a high level module such as a file system to logically organize the information stored on volumes as a hierarchical structure of data containers such as files and logical units. For example each on disk file may be implemented as set of data structures i.e. disk blocks configured to store information such as the actual data for the file. These data blocks are organized within a volume block number vbn space that is maintained by the file system. The file system may also assign each data block in the file a corresponding file offset or file block number fbn . The file system typically assigns sequences of fbns on a per file basis whereas vbns are assigned over a larger volume address space. The file system organizes the data blocks within the vbn space as a logical volume each logical volume may be although is not necessarily associated with its own file system.

A known type of file system is a write anywhere file system that does not overwrite data on disks. If a data block is retrieved read from disk into a memory of the storage system and dirtied i.e. updated or modified with new data the data block is thereafter stored written to a new location on disk to optimize write performance. A write anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations particularly for sequential read operations directed to the disks. An example of a write anywhere file system that is configured to operate on a storage system is the Write Anywhere File Layout WAFL file system available from Network Appliance Inc. Sunnyvale Calif.

The storage system may be further configured to operate according to a client server model of information delivery to thereby allow many clients to access data containers stored on the system. In this model the client may comprise an application such as a database application executing on a computer that connects to the storage system over a computer network such as a point to point link shared local area network LAN wide area network WAN or virtual private network VPN implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file based and block based protocol messages in the form of packets to the system over the network.

A plurality of storage systems may be interconnected to provide a storage system environment configured to service many clients. Each storage system may be configured to service one or more volumes wherein each volume stores one or more data containers. Yet often a large number of data access requests issued by the clients may be directed to a small number of data containers serviced by a particular storage system of the environment. A solution to such a problem is to distribute the volumes serviced by the particular to storage system among all of the storage systems of the environment. This in turn distributes the data access requests along with the processing resources needed to service such requests among all of the storage systems thereby reducing the individual processing load on each storage system. However a noted disadvantage arises when only a single data container such as a file is heavily accessed by clients of the storage system environment. As a result the storage system attempting to service the requests directed to that data container may exceed its processing resources and become overburdened with a concomitant degradation of speed and performance.

One technique for overcoming the disadvantages of having a single data container that is heavily utilized is to stripe the data container across a plurality of volumes configured as a striped volume set SVS where each volume is serviced by a different storage system thereby distributing the load for the single data container among a plurality of storage systems. A technique for data container striping is described in the above incorporated U.S. patent application Ser. No. 11 119 278 of Kazar et al. entitled STORAGE SYSTEM ARCHITECTURE FOR STRIPING DATA CONTAINER CONTENT ACROSS VOLUMES OF A CLUSTER. In such an environment a SVS comprises one or more data volumes DV and a meta data volume MDV . Each DV and the MDV is typically served by a separate node of the distributed storage system environment. In the environment described in the above incorporated U.S. Patent Application the node may comprise a network element N module and a disk element D module that includes a file system. As used herein a D module serving hosting a DV is referred to as a DV node while a D module hosting the MDV for a SVS is referred to as a MDV node. 

Most file access protocols include locking capabilities. A lock is a mechanism that enables a client or system administrator to prevent access to a shared resource. An entity later attempting to access this shared resource will be notified of the lock which may prevent others from accessing the resource. The types of locks can vary. For example in some instances there may be a write lock placed on a resource by the owner yet other entities may be able to simultaneously obtain read access to the resource. The type of lock and or the absence of a lock over a particular data container such as a file or to portion thereof are referred to herein as a lock state. 

Various challenges arise with respect to managing lock state information regarding a distributed storage system. The volume of lock state information can be potentially large and subject to constant change as information is updated and edited.

Known techniques for managing lock state information include an approach in which lock state information is distributed directly to end clients. In this case clients and or end users utilize specific lock state management software applications and special protocols that allow the users to create edit and manage lock state information.

Another approach stores lock state information in a central repository for the entire system however this centralized approach can result in a bottleneck for file access in a large distributed system.

The approach described in the previously incorporated parent application Ser. No. 11 264 831 discloses a method and system in which a lock state manager configures a MDV as the authoritative source for lock state information for data containers on the SVS. Client requests for access to a particular data container or a portion of a container are directed to the MDV node which searches its lock state database and returns the resulting lock state information to respective DV nodes associated with the data containers that store the requested data. The lock state information for each data request is returned by the MDV node to the DV node for storage in a local lock cache on the DV node.

Many DV nodes however have limited memory resources thus limited space. In such limited memory situations the DV node does not have adequate memory space capacity to store all lock state information provided to it by the MDV node. Secondly the DV node may be unable to render a decision about whether to process a read or write request e.g. directed to a file because it may not have all of the respective lock state information for that file. In other words if the DV node has consumed all of its memory capacity prior to receiving all of the lock state information then it cannot retain all of the information locally and thus may be unable to make a processing decision. Moreover the DV node may not even be capable of returning a response to the MDV node which to may cause the system to hang up or other similar error condition.

The parent application further discloses the use of permissive areas which are similar to locks that are pre assigned to designate one or more areas in a file that contain no locks. Permissive area information is sent to a DV node upon a request to the MDV node for lock state information about a file range that includes a respective permissive area. However the request for permissive area information also requires additional memory capacity on the part of the DV nodes in order to locally store and maintain the information at the node.

Thus there remains a need for a system that provides lock state information between an MDV node and its associated DV nodes which requires only limited memory resource space i.e. a small memory footprint particularly in a local lock cache of the node. In addition there remains a need for a technique for controlling lock state information while maintaining the ability to rapidly update this information on the distributed storage system without requiring the use of specialized software programs and without requiring large memory resource capacity on each DV node.

The present invention overcomes the disadvantages of the prior art by providing a technique for managing lock state information in a distributed storage system architecture comprising two or more volumes distributed across a plurality of nodes interconnected as a cluster. The volumes are organized as one or more striped volume sets SVS and configured to store content of data containers such as files and logical units served by the cluster in response to multi protocol data access requests issued by clients. Each node of the cluster includes i a storage server adapted to service a volume of a SVS and ii a multi protocol engine adapted to redirect the data access requests to any storage server of the cluster. Notably the content of each data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster.

According to the invention a lock manager is configured to efficiently manage to the lock state information including granting revoking and releasing of various types of locks on data containers or ranges of data containers stored on the SVS. Illustratively the lock manager functions inter alia to manage lock state information including hard soft shared and exclusive lock state information. As used herein hard locks are client requested locks which prevent other clients from either obtaining a conflicting lock or from violating the hard lock. For example if client A obtains a hard lock to prevent I O operations over a particular region of a file then later client B will not only be unable to obtain a conflicting lock as to that region but also will be unable to simply issue an I O request against that region even if client B does not attempt to obtain a lock first. Hard locks are also sometimes referred to by those skilled in the art as mandatory locks. 

These are in contrast to soft locks which in contrast provide no such guarantee. The soft lock prevents clients from obtaining a conflicting lock. For example if client A obtains a soft lock to prevent I O requests over a particular region of a file then client B could successfully perform I O operations over that region though this would not be desirable as long as client B does not attempt to obtain a conflicting lock.

As used herein shared locks are locks which span an entire file as opposed to a range lock which describes a range of a file. Shared locks and range locks can be either read or write locks. Write locks are sometimes referred to as exclusive locks i.e. locks that allow only one writer at a time. A write lock may or may not allow concurrent read transactions during a write transaction by the client holding the exclusive lock. This protects against concurrent data changes. Read locks allow concurrent read transactions.

In accordance with the distributed storage system architecture each SVS comprises a meta data volume MDV configured to store a canonical copy of meta data including access control lists and directories associated with all data containers stored on the SVS and one or more data volumes DV configured to store at least data content of those containers. Notably the MDV the MDV node also functions as the authoritative source for lock state information for data containers on the SVS. To that end the lock manager configures and maintains a lock state database on the MDV that contains to the lock state information for the SVS. Client requests for access to particular data containers or portions of data containers are directed to and processed by the MDV node and the resulting lock state information is provided to the DVs DV nodes for storage on local lock caches on the DV nodes.

In accordance with a further aspect of the invention novel lock state command messages are provided to convey lock state information between the MDV node and the DV nodes. For example in response to receiving a data access request directed to a data container from a client the DV node checks its own local lock cache to determine whether it contains relevant lock state information for the pending request. If not the DV node sends a command query within a lock state message to the MDV node which responds with appropriate lock state information regarding conflicting locks if any.

When a DV node sends a lock state message to the MDV node with a command query the MDV node inspects the lock state information with respect to a range if any requested by the DV node and determines whether there are shared locks or exclusive locks pertaining to that requested range. The MDV node then consults this relevant lock state information and determines whether the data access request is permitted depending on the type of locks present and whether the request is a read request or a write request. For example if the request is a write request for a range upon which there is an exclusive lock in effect then that write request must be denied.

After determining that the DV node s request will be accepted or rejected based on its local lock state information the MDV node constructs a response to the DV node. The response contains the specific locks pertaining to the DV node s request along with a field which states whether the file operation is permitted to proceed or not. The DV node will add the lock state returned in the MDV node s response in its local lock cache assuming it has sufficient memory space available. However if the DV node does not have the requisite memory space available in its local lock cache then it can still process the request or deny the request accordingly based upon the authoritative operation permission result provided to it in the MDV node s response. By providing both the relevant lock state as well as an authoritative decision about the acceptability of the requested operation the system is able to behave properly even in cases where the DV node is unable or unwilling to store more lock state information in its local cache.

In addition illustratively the MDV node maintains a record of lock state information that it has sent to each DV node. Subsequently if a client removes a lock from a file the MDV node examines the lock being removed and notifies each affected DV node that this lock is no longer present.

to is a schematic block diagram of a plurality of nodes interconnected as a cluster and configured to provide storage service relating to the organization of information on storage devices. The nodes comprise various functional components that cooperate to provide a distributed storage system architecture of the cluster . To that end each node is generally organized as a network element N module and a disk element D module . The N module includes functionality that enables the node to connect to clients over a computer network while each D module connects to one or more storage devices such as disks of a disk array . The nodes are interconnected by a cluster switching fabric which in the illustrative embodiment may be embodied as a Gigabit Ethernet switch. An exemplary distributed file system architecture is generally described in U.S. Patent Application Publication No. US 2002 0116593 titled METHOD AND SYSTEM FOR RESPONDING TO FILE SYSTEM REQUESTS by M. Kazar et al. published Aug. 22 2002. It should be noted that while there is shown an equal number of N and D modules in the illustrative cluster there may be differing numbers of N and or D modules in accordance with various embodiments of the present invention. For example there may be a plurality of N modules and or D modules interconnected in a cluster configuration that does not reflect a one to one correspondence between the N and D modules. As such the description of a node comprising one N module and one D module should be taken as illustrative only. In an alternate embodiment each N or D module in the distributed storage system environment may be referred to as a node of such environment.

The clients may be general purpose computers configured to interact with the node in accordance with a client server model of information delivery. That is each client may request the services of the node and the node may return the results of the services requested by the client by exchanging packets over the network . The client may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over the Transmission Control Protocol Internet Protocol TCP IP when accessing information in the form of files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP IP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of blocks.

Each node is illustratively embodied as a dual processor storage system executing a storage operating system that preferably implements a high level module such as a file system to logically organize the information as a hierarchical structure of named data containers such as directories files and special types of files called virtual disks hereinafter generally blocks on the disks. However it will be apparent to those of ordinary skill in the art that the node may alternatively comprise a single or more than two processor system. Illustratively one processor executes the functions of the N module on the node while the other processor executes the functions of the D module .

The memory illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system portions of which is typically resident in memory and executed by the processing elements functionally organizes the node by inter alia invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the invention described herein.

The network adapter comprises a plurality of ports adapted to couple the node to one or more clients over point to point links wide area networks virtual private networks implemented over a public network Internet or a shared local area network. The network adapter thus may comprise the mechanical electrical and signaling circuitry needed to connect the node to the network. Illustratively the computer network may be embodied as an Ethernet network or a Fibre Channel FC network. Each client may communicate with the node over network by exchanging disframes or packets of data according to pre defined protocols such as TCP IP.

The storage adapter cooperates with the storage operating system executing on the node to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks of array . The storage adapter comprises a plurality of ports having input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance FC link topology.

Storage of information on each array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.

To facilitate access to the disks the storage operating system implements a write anywhere file system that cooperates with one or more virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named data containers such as directories and files on the disks. Each on disk file may be implemented as set of disk blocks configured to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module s allow the file system to further logically organize information as a hierarchical structure of data containers such as blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. of Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such where the term ONTAP is employed it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.

In addition the storage operating system includes a series of software layers organized to form a storage server that provides data paths for accessing information stored on the disks of the node . To that end the storage server includes a file system module in cooperating relation with a volume striping module VSM a RAID system module and a disk driver system module . The RAID system manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations while the disk driver system implements a disk access protocol such as e.g. the SCSI protocol. The VSM illustratively implements a striped volume set SVS . As described further herein the VSM cooperates with the to file system to enable storage server to service a volume of the SVS. In particular the VSM implements a Locate function to compute the location of data container content in the SVS volume to thereby ensure consistency of such content served by the cluster.

The file system implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules illustratively embodied as e.g. a virtual disk vdisk module not shown and a SCSI target module . The vdisk module enables access by administrative interfaces such as a user interface of a management framework not shown in response to a user system administrator issuing commands to the node . The SCSI target module is generally disposed between the FC and iSCSI drivers and the file system to provide a translation layer of the virtualization system between the block lun space and the file system space where luns are represented as blocks.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as disks. That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as mirroring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte KB blocks and using index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . The file system uses files to store meta data describing the layout of its file system these meta data files include among others an inode file. A file handle i.e. an identifier that includes an Mode number is used to retrieve an inode from disk.

Broadly stated all inodes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The inode of the inode file may directly reference point to data blocks of the inode file or may reference indirect blocks of the inode file that in turn reference data blocks of the inode file. Within each data block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

As described further herein the file system includes a lock state manager which is a software process that is configured to efficiently manage lock state information including granting revoking and releasing of various types of locks on data containers such as files stored on the SVS. For example in response to a file access operation that includes a request for a lock of a particular type the lock manager decides whether to grant refuse to grant or wait for the appropriate time to grant that lock. To that end the lock manager coordinates shared open requests which provide for locks on an entire file and range locks that cover a specific byte range within a file. As will be understood by those skilled of the art both shared locks and range locks can be read locks that allow concurrent transactions so that more than one client can read a file concurrently. Alternatively the shared lock or range lock may be a write lock which protects against concurrent data changes. As noted herein sometimes a write lock is referred to as an exclusive lock which may not allow concurrent access or allows read only concurrent access. Both shared open locks and range locks are established upon request of the client who then becomes the owner of the lock. Illustratively the locks may be removed only by the lock owner. More specifically the lock manager functions inter alia to manage lock state information including hard lock state information. As noted herein hard locks are client requested locks that prevent other clients from either obtaining a conflicting lock or from violating the hard lock. For example if client A obtains a hard lock to prevent I O operations over a particular region of a file then later client B will not only be unable to obtain a conflicting lock as to that region but also will be unable to simply issue an I O request against that region even if client B does not attempt to obtain a lock first.

These are in contrast to soft locks which in contrast provide no such guarantee. The soft lock prevents clients from obtaining a conflicting lock. For example if client A obtains a soft lock to prevent I O requests over a particular region of a file then client B could successfully perform I O operations over that region though this would not be desirable as long as client B does not attempt to obtain a conflicting lock.

Operationally a data access request directed to a data container such as a file is issued from a client and forwarded as a packet over the computer network to the node where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . The lock state manager examines the lock state information to determine whether there is an existing lock on the file that could prevent execution of the operation associated with the access request.

If it is determined that execution of the operation is allowed the file system generates additional operations to load retrieve the requested data from disk if it is not resident in core i.e. in memory . If the information is not in memory the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in memory for processing by the node. Upon completion of the request the node and operating system returns a reply to the client over the network .

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases to the performance of the storage service provided by node in response to a request issued by client . Moreover in another alternate embodiment of the invention the processing elements of adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer to perform a storage function that manages data access and may in the case of a node implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel an application program operating over a general purpose operating system such as UNIX or Windows XP or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the invention described herein may apply to any type of special purpose e.g. file server filer or storage serving appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment and a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system the teachings of the present invention may be utilized with any suitable file system including a write in place file system.

In the illustrative embodiment the storage server is embodied as D module of the storage operating system to service one or more volumes of array . In addition the multi protocol engine is embodied as N module to i perform protocol termination with respect to a client issuing incoming data access request packets over the network as well as ii redirect those data access requests to any storage server of the cluster . Moreover the N module and D module cooperate to provide a highly scalable distributed storage system architecture of the cluster . To that end each module includes a cluster fabric CF interface module a b adapted to implement intra cluster communication among the modules as well as D module toD module communications for data container striping operations for example.

The protocol layers e.g. the NFS CIFS layers and the iSCSI FC layers of the N module function as protocol servers that translate file based and block based data access requests from clients into CF protocol messages used for communication with the D module . That is the N module servers convert the incoming data access requests into file system primitive operations commands that are embedded within CF messages by the CF interface module for transmission to the D modules of the cluster . Notably the CF interface modules cooperate to provide a single file system image across all D modules in the cluster . Thus any network port of an N module that receives a client request can access any data container within the single file system image located on any D module of the cluster.

Further to the illustrative embodiment the N module and D module are implemented as separately scheduled processes of storage operating system however in an alternate embodiment the modules may be implemented as pieces of code within a single operating system process. Communication between an N module and D module is thus illustratively effected through the use of message passing between the N module and D module although in the case of remote communication between an N module and D module of different nodes such message passing occurs over the cluster switching fabric . A known message passing mechanism provided by the storage operating system to transfer information between N modules and D modules processes is the Inter Process Communication IPC mechanism. The protocol used with the IPC mechanism is illustratively a generic file and or block based agnostic CF protocol that comprises a collection of methods functions constituting a CF application programming interface API . Examples of such an agnostic protocol are the SpinFS and SpinNP protocols available from Network Appliance Inc. The SpinFS protocol is described in the above referenced U.S. Patent Application Publication No. US 2002 0116593.

The CF interface module implements the CF protocol for communicating file system command messages including novel lock state command messages described herein among the modules of cluster . Communication is illustratively effected by the D module exposing the CF API to which an N module or another D module issues calls. To that end the CF interface module is organized as a CF encoder and CF decoder. The CF encoder of e.g. CF interface on N module encapsulates a CF message as i a local procedure call LPC when communicating a file system command to a D module residing on the same node or ii a remote procedure call RPC when communicating the command to a D module residing on a remote node of the cluster . In either case the CF decoder of CF interface on D module deencapsulates the CF message and processes the file system command.

A data container e.g. a file is accessed in the file system using a data container handle. is a schematic block diagram illustrating the format of a data container handle including a SVS ID field an inode number field a unique ifier field a striped flag field and a striping epoch number field . The SVS ID field contains a global identifier within the cluster of the SVS within which the data container resides. The inode number field contains an inode number of an inode within an inode file pertaining to the data container. The unique ifier field contains a monotonically increasing number that uniquely identifies the data container handle . The unique ifier is particularly useful in the case where an inode number has been deleted reused and reassigned to a new data container. The unique ifier distinguishes that reused inode number in a particular data container from a potentially previous use of those fields. The striped flag field is illustratively a Boolean value that identifies whether the data container is striped or not. The striping epoch number field indicates the appropriate striping technique for use with this data container for embodiments where the SVS utilizes differing striping techniques for different data containers. Further details about an illustrative file system organization can be found in commonly owned U.S. patent application Ser. No. 11 119 278 filed on Apr. 29 2005 of Kazar et al. for a STORAGE SYSTEM ARCHITECTURE FOR STRIPING DATA CONTAINER CONTENT ACROSS VOLUMES OF A CLUSTER which is incorporated by reference herein in its entirety.

The present invention is directed to a technique for managing lock state information in a distributed storage system architecture comprising two or more volumes distributed across a plurality of nodes of cluster . As noted the volumes are organized as one or more striped volume sets SVS and configured to store content of data containers such as files and luns served by the cluster in response to multi protocol data access requests issued by clients. Each node may include a D module adapted to service a volume of the SVS. As more particularly illustrated in the SVS comprises a meta data volume MDV and one or more data volumes DV DV and DV . The MDV is configured to store a canonical or definitive copy of certain meta data including access control lists ACLs and directories associated with all data containers e.g. files stored on the SVS whereas each DV is configured to store at least data contents of those files. The MDV and the DV cooperate with a container attributes volume CAV to provide a multi tier caching and distribution architecture described in commonly owned U.S. patent application Ser. No. 11 119 277 filed on Apr. 29 2005 of Kazar et al. entitled SYSTEM AND METHOD FOR MULTI TIERED METADATA CACHING AND DISTRIBUTION IN A CLUSTERED ENVIRONMENT which is incorporated herein by reference in its entirety. As used herein a D module serving hosting a DV is referred to herein as a DV node while a D module hosting the MDV in a SVS is referred to as an MDV node. 

However the local lock cache has a limited memory space capacity. Therefore only a limited amount of information may be stored by the DV node . Accordingly a suitable caching methodology is employed to determine the information that is to be cached. Illustratively one way of selecting information that is to be cached in a memory constrained environment is to establish packing rules which list various types of information in order of priority such that the types of information are stored in that order until the limited memory space of the local lock cache reaches its capacity. The following illustrative packing rules may be applied in this illustrative order or in a different order and some of the following rules may be included in the rule set or not depending upon the particular application of the invention. It is noted that if a rule fails the next rule is attempted and thus the rules may illustratively be a attempt to include all uncached sharelocks for the file b attempt to include all uncached range locks for the file c attempt to include all uncached range locks for the file stripe in which the I O operation resides d attempt to include all uncached range locks for the range of the requested I O operation and e include as many uncached range locks as possible beginning a the starting location of the requested I O operation. The older data can be discarded on a FIFO basis or other suitable methodology.

Further in accordance with the invention the MDV node is configured to perform the lock state calculations regarding whether a particular I O operation can be allowed or denied at the DV. More specifically as illustrated in File A and File B span two stripes exactly once in each DV node and such that DV node serves hosts the first 50 bytes offset for each file and DV node hosts the next 50 bytes offset for each file. The lock state database in the MDV node maintains all of the lock state information for the ranges embodied in Files A and B from offset to offset .

The specific lock state information that is maintained for each file is schematically illustrated in the lock state information data structure of . The lock state information data structure contains a lock state field that in turn includes an owner identification ID field that stores an owner ID or a unique identifier of the client that is allowed to access the file. An access type field stores an indication of the type of lock which illustratively is either a read lock or a write lock. In addition an access range field is provided that indicates the range of the file locked by the lock type. Result field indicates whether or not the request should be allowed or denied by the DV node. In accordance with the invention the MDV node calculates whether or not the request should be allowed or denied and inserts this information into lock information data structure result field . The lock state validation field allows the MDV node to notify the DV node about whether it has all the lock state information for that entire file.

Illustratively if the field is true then the DV node has thereby been notified that it does in fact now have all the lock state information for the file in question. This means that DV node does not have to call up to the MDV node regarding lock state for any subsequent I O requests involving that particular file. If field is illustratively false then this indicates to the DV node that it does not have all of the lock state information and thus it must call up to the MDV node to obtain additional information for further I O requests.

Referring again to assume further that a client C sends a request to the N module to obtain exclusive write access for ranges 10 40 of File A stored on the SVS. The N module directs this request to the MDV node as the authoritative source of lock state information for that SVS. The MDV node places an exclusive lock on bytes of the File A for C in its lock state database . Assume now that a client C subsequently requests write access to byte of File A. Specifically the DV node receives an I O request from a client C for write access to byte of file A for example. In turn the DV node searches its local lock cache for lock state information pertaining to that file range. If the lock state cache is empty with respect to the file range indicated in the request then the absence of the information causes the DV node to query the MDV node to determine the current lock state information with respect to the requested byte of File A. When the DV node queries the MDV node it sends a message to the MDV node and includes the information above the type of I O request involved. More specifically the DV node sends a message requesting write access to byte of File A.

In response the MDV node consults its authoritative lock state database and provides a result about the validity of the I O request in its response to the DV node by calculating whether a write operation is allowable for that byte range requested. In the present example byte is subject to an exclusive lock by client C and thus a write request is not available for the client C. Therefore in accordance with the invention the MDV node responds with a result that the request should be denied. As there are one or more locks in the requested range the MDV node also responds with the information about the set of locks that is relevant to that particular request. Illustratively the MDV node responds to the DV node that a client has a write lock on bytes . Notably the MDV node is unable to provide the DV node with full lock state information because the DV node s local lock cache is out of memory space nevertheless the MDV node still returns the result about the I O request. Therefore requests can continue to be processed even in a memory constrained environment in which the local lock cache of the DV node is out of memory space. Note that communication between the MDV and DV nodes is effected using lock state commands embedded in the CF protocol message e.g. CF protocol field as described previously with respect to .

The procedure described above is summarized in the flowchart of . The procedure starts at step and continues to step where a lock state database is established in the MDV node as the source for lock state information for the SVS. In step an N module receives a request for exclusive access to a range of a file from a client. The N module directs this request for exclusivity to the MDV node . Assuming there is no conflict i.e. no existing lock to the requested file range in step the MDV node enters the lock state information for the affected byte range in its to lock state database . Subsequently when a data access request arrives at a particular DV node via the N module that DV node checks its local lock cache for information about a lock state that exists for the affected range step . At step a determination is made as to whether the lock cache is empty.

The absence of information in the lock state cache causes the procedure to continue to step whereby the DV node sends a message to the MDV node indicating the type of request and the particular file or byte range requested step . In step the MDV node checks its lock state database and calculates whether or not a read or write request can be performed for the particular file type or range requested depending upon locks which exist for that file or byte range. For example if a read request has been submitted certain locks will allow a read request concurrently with another read request. Alternatively if a write request has been submitted exclusive locks do not allow any type of concurrent transactions during a write operation. The MDV node checks the type of lock and the type of transaction being requested and makes a determination based on its own lock state database information and returns a result to the DV node. In addition it responds with relevant lock state information about byte ranges involved in the request.

In step the MDV node marks its records that the requesting DV node has been notified of particular locks. The DV node then updates its local lock cache if possible accordingly as shown in step . If the local lock cache is at full memory capacity then the DV node can still respond to the client because it has received the results from the MDV node. If the local lock cache of the affected DV node does contain lock state information at step then the procedure continues to step where the DV node checks its local lock cache information indicating whether the operation is allowed or should be rejected. The client is notified accordingly and thereafter the procedure ends at step .

As noted herein in addition to responding to the DV node with the result as to whether the request can be allowed or denied and locks that pertain to that particular file or byte range the MDV node also in accordance with the invention sends the DV node a Boolean value which indicates whether the DV node has all of the relevant lock state information for the particular file in question. Thus the DV node can update its own records accordingly if possible as indicated in step of . As noted if the DV invalidation value sent to the DV node is indicated as false then the DV node has implicitly been told that it does not have all lock state information for the file in question and thus upon receiving the next I O request pertaining to that file the DV node must request call up to the MDV node for additional information.

During subsequent operation of the system a particular client may determine that it no longer requires exclusivity with respect to a particular file or byte range. Thus in accordance with the invention the procedure is followed which is illustrated in . The procedure starts at step and continues to step where an N module receives a notification from a client that it no longer requires exclusivity on a particular byte range. In step the N module notifies the MDV node of this development. In step the MDV node thereafter checks its records to determine which DV nodes had been supplied with lock state information and sends a lock state command e.g. a LOCK PURGE message to each affected DV node to purge its local lock cache with respect to that byte range. In step the relevant DV nodes purge their lock state caches to remove the lock on that particular byte range and in step each DV node sends an acknowledgement to the MDV node that the lock has been purged. In step the MDV node updates its lock state database to remove the particular lock which had existed on that byte range. In step the MDV node updates its records that each DV node has been notified thereof and has received an acknowledgement of the removal of the locks i.e. the lock purge. The procedure ends at step . In an alternative aspect of the invention the MDV node may itself decide to purge locks and in which case these changes are either separately sent by messages to the respective DV nodes or are broadcast notified to all DVs that have an interest in that file or byte range. There may be other reasons for which the MDV node determines that lock state has changed and it can thereby notify DV nodes accordingly. In other instances the DV node may determine that it is going to release cached locks from its own local lock cache under certain circumstances.

More specifically is a flow chart of a procedure for discarding locks by a DV node in accordance with the invention. In this instance a DV node determines that it must release cached locks particularly if e.g. as noted the DV node is memoryconstrained and needs to free up memory space. In this case the DV node is configured to release older locks in favor of newer ones. The procedure starts at step and proceeds to step in which a DV node determines that it will release cached locks and thus in accordance with step the DV node removes the corresponding lock state information from its local lock cache. In step the DV node sends a message to the MDV node. In step that DV node s corresponding information bit in the lock state validation field in the respective lock state database structure of the MDV node is cleared. The procedure ends at step .

The following examples illustrate lock state interaction between DV nodes and the MDV node in accordance with the present invention. illustrates an initial configuration in which MDV node has an empty lock state database indicating the absence of a lock for a file in question. DV node is responsible for client data access requests directed to the first half of the file and DV node is responsible for such access requests directed to the second half of the file. In DV node the lock cache is empty and thus contains no lock state information. Similarly lock cache of DV node is also empty with no lock state information contained therein.

Similarly when DV node receives its request it consults its local lock cache and finds an absence of information. DV node thus sends an ACCESSREAD REQUEST message regarding the received read request to the MDV node. The MDV node receives the write and read messages from the DV and DV nodes respectively and checks its authoritative lock state database . Since no locks are present that conflict with either request the MDV node responds that both operations can proceed.

If possible DV and DV nodes can update their local caches and respectively because of lock caches have memory capacity available. To the extent they do not have such information available the DV nodes can still complete the requests because the MDV node has provided the results of the I O requests.

In accordance with a further illustrative aspect of the invention a list of locking ranges per file can be maintained in the DV node s local lock cache if there is memory capacity in the local lock cache. If so when the lock state is first created for a file on a DV node the entire span of the file handled by that DV node is assumed to be invalid meaning that it is subject to a lock. The DV node adds an entry with this span to its list of invalid ranges. When an I O operation arrives at a DV node the DV node s lock manager examines this list of invalid ranges for the requested file. If the I O operation overlaps with any of the invalid ranges the operation is suspended and a request for locking information is sent to the MDV node by the DV node. This is because the DV node may not have the full set of locks for this range and though the span includes locks it may be that the respective individual range requested is not subject to a lock which would mean that the I O request may be allowable. Thus a request is sent to the MDV node that includes information about the I O operation that instigated the request.

Upon receiving the request from the DV node the MDV node consults its lock state database and determines the validity of the operation included in the request populating this result in its response to the DV node in a message such as those discussed with reference to . In a further aspect of the invention the MDV node next ensures that all shared locks on entire files have already been cached by the DV node for that span. If not shared lock state is added to the response if possible. Finally the MDV node also scans the set of range locks for the file in question and for each lock which is not yet cached on the requesting DV node the MDV node adds this lock to the response message. It is noted that not all shared and range locks may fit into the response and an appropriate priority packing rule can be established as desired in a particular application of the invention as noted herein.

Referring to a second client requests write access to a byte range controlled by the DV node. The DV node thus sends an access write request message to the MDV node . Yet the second client has requested write access to a range within the file protected by the earlier implemented write range lock WL in . The MDV node checks its authoritative lock state database and determines that the byte range requested is already protected by a write range lock and therefore a second write cannot concurrently be allowed. Thus the MDV node returns an access write request acknowledgement with an indication that the write is denied the WL write range lock. The MDV message if possible also indicates whether or not the DV node now has all of the lock state information for that file in question. As illustrated in the client write request thus fails as shown in .

If instead the MDV node determines that there are no conflicting locks then the procedure continues to step in which the MDV node further checks whether there are supporting locks that allow requested operation. If there are such supporting locks then the procedure continues to step in which the MDV node sends an ACCESS REQUEST ACK message with supporting lock information. The DV node then completes the requested operation in step and the procedure ends at step .

If there are no supporting locks and in fact there are no locks at all the procedure continues to step in which the MDV node sends an acknowledgement message indicating that the I O operation is permitted and the permitting indication that the DV has all lock information associated with that file or byte range. In step the DV then completes the client request. The procedure ends at step .

If later the client determines that the write range lock should be removed step the MDV node can send a lock purge message designating elimination of the lock to an affected DV as shown in step . When the DV acknowledges the lock purge message as shown in step the MDV can update its records that the DV node has been notified as shown in step . Alternatively as long as the client continues the lock then DV write requests will be denied as shown in step and read only requests will be allowed if permitted by the particular type of lock imposed by the client. The procedure ends at step .

To again summarize in accordance with the invention novel lock state command messages are provided to convey lock state information between the MDV node and the DV nodes. For example in response to receiving a data access request directed to a data container from a client the DV node checks its own local lock cache to determine whether it contains relevant lock state information for the pending request. If not the DV node sends a command query within a lock state message to the MDV node which responds with appropriate lock state information regarding conflicting locks if any.

When a DV node sends a lock state message to the MDV node with a cornmand query the MDV node inspects the lock state information with respect to a range if any requested by the DV node and determines whether there are shared locks or exclusive locks pertaining to that requested range. The MDV node then consults this relevant lock state information and determines whether the data access request is permitted depending on the type of locks present and whether the request is a read request or a write request. For example if the request is a write request for a range upon which there is an exclusive lock in effect then that write request must be denied.

After determining that the DV node s request will be accepted or rejected based on its local lock state information the MDV node constructs a response to the DV node. The response contains the specific locks pertaining to the DV node s request along with a field which states the result i.e. whether the input output file operation is permitted to proceed or not. The DV node will add the lock state returned in the MDV node s response in its local lock cache assuming it has sufficient memory space available. However if the DV node does not have the requisite memory space available in its local lock cache then it can still process the request or deny the request accordingly based upon the authoritative operation permission result provided to it in the MDV node s response. By providing both the relevant lock state as well as an authoritative decision about the acceptability of the requested operation the system is able to behave properly even in cases where the DV node is unable or unwilling to store any more lock state in its local cache.

In addition illustratively the MDV node maintains a record of lock state information that it has sent to each DV node. Subsequently if a client removes a lock from a file the MDV node examines the lock being removed and notifies each affected DV node that this lock is no longer present.

In accordance with a further illustrative aspect of the invention when a client adds a lock to a file in a striped volume environment the MDV node does not push this information automatically to the DV node. It may however be configured to inform interested DV nodes that their lock states for that file are now invalid for some regions. The MDV node accomplishes this by first consulting a striping table to determine the striping rules for this file. Using the striping rules and the file range of the lock being added the MDV node determines which DV nodes are potentially impacted by the addition of this lock. For each such DV node which is listed in the files list of interested DV nodes the MDV illustratively performs the following check if the new lock range overlaps with any empty ranges byte ranges with no locks present or locks which are marked as having been cached by the DV node in question then the MDV node sends a message to that DV node telling it the file range covered by the lock being added is now invalid. In other words if the range of the lock being added completely overlaps the ranges of the other locks which have not yet been cached at the DV node in question there is no reason to inform the DV node that this lock s range is invalid.

When a client removes a lock from a file the MDV node examines the lock being removed. Iterating over each DV node which is marked as having previously cached the lock being removed the MDV node notifies each DV node that this lock is no longer present. The state of the recipient DV nodes invalid ranges and other cached locks is unaffected. It is noted that when the MDV node makes a locking decision on behalf of a DV node the MDV marks the locks it examines when making that decision as being in use on that DV node even if those locks are unable to fit in the response to the DV node. Thus when a lock is later removed by a client as just discussed those locks being removed which are also marked as having been used in any decision must be revoked at the affected DV nodes before that lock may be removed from the MDV node.

It should be understood that the CF protocol messaging for managing lock state information illustratively described herein may be written modified or expanded upon or written in a different software language or in a code with different semantics or of a different format while remaining within the scope of the present invention.

In sum the present invention described herein provides an efficient and reliable technique for managing lock state information including hard lock state information in a distributed storage system environment without requiring specialized software on the client. The foregoing description has been directed to particular embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. Specifically it should be noted that the principles of the present invention may be implemented in non distributed file systems. Furthermore while this description has been written in terms of N and D modules the teachings of the present invention are equally suitable to systems where the functionality of the N and D modules are implemented in a single system. Alternately the functions of the N and D modules may be distributed among any number of separate systems wherein each system performs one or more of the functions. Additionally the procedures processes and or modules described herein may be implemented in hardware software embodied as a computer readable medium having program instructions firmware or a combination thereof. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

