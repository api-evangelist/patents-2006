---

title: Arbitration mechanisms to deal with conflicting applications and user data
abstract: An arbitration policy resolves software applications operating on a single unit of data in a manner conflicting with other applications that operates on the same data or properties of the data. This is accomplished through picking an entity type of one application to have priority over an entity type of another application when both entity types map to a same property which caused the conflict. This allows user to observe the data in a consistent manner when switching between applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08015570&OS=08015570&RS=08015570
owner: Microsoft Corporation
number: 08015570
owner_city: Redmond
owner_country: US
publication_date: 20060630
---
A portion of the disclosure of this patent document may contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever. The following notice shall apply to this document Copyright 2006 Microsoft Corp.

Storage systems such as WinFS Microsoft Windows Future Storage or Microsoft Windows File System for example allow different kinds of data to be identified by metadata and uses it to set up relationships among data thereby giving a semantic structure to the data. These relationships can then be used by a relational database to enable searching and dynamic aggregation of the data allowing the data to be presented in a variety of ways. WinFS includes a relational database engine derived from the Microsoft SQL Server 2005 SQL database platform to facilitate this.

However to allow applications to search and categorize data in such storage systems without knowledge of the structure of the different kinds of data in the system there is a need for a system that provides applications the ability to just operate on a single set of search properties that is type format independent rather than operating on the individual types. Storage systems like WinFS also allows for independent software vendors ISVs to be able to extend existing data in the system using custom extensions called entity types and pick the search properties for their entity types independent of the search properties on the original data that they extended. In such a system a given unit of data could have a single search property provided from multiple entity types defined by independent ISVs. As a result only one of these multiple entity types can be picked as the winner that provides the desired search property. These entity types could be owned by different ISVs applications and it is essential that the winner is picked using a deterministic arbitration policy.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

In consideration of the above identified shortcomings of the art arbitration mechanisms to deal with conflicting applications and user data is provided. For several embodiments the method for managing data between different software applications comprises providing an arbitration policy that resolves the problem of software applications operating on data in a manner conflicting with other applications using said data or properties of said data.

Also a method for managing data between different software applications may comprise picking an entity type in a first category to have priority over an entity type in a second category when both entity types map to the same search property.

Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the invention. Certain well known details often associated with computing and software technology are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the invention. Further those of ordinary skill in the relevant art will understand that they can practice other embodiments of the invention without one or more of the details described below. Finally while various methods are described with reference to steps and sequences in the following disclosure the description as such is for providing a clear implementation of embodiments of the invention and the steps and sequences of steps should not be taken as required to practice this invention.

Referring to shown is a block diagram representing an exemplary computing device suitable for use in conjunction with implementing the processes described above. For example the computer executable instructions that carry out the processes and methods for arbitration mechanisms to deal with conflicting applications and user data may reside and or be executed in such a computing environment as shown in . The computing system environment is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing environment be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment . For example a computer game console may also include those items such as those described below for use in conjunction with implementing the processes described above.

Aspects of the invention are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Aspects of the invention may be implemented in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Aspects of the invention may also be practiced in distributed computing environments where tasks are. performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

An exemplary system for implementing aspects of the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through an non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through a output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the processes described in connection with the invention e.g. through the use of an API reusable controls or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

Although exemplary embodiments may refer to utilizing aspects of the invention in the context of one or more stand alone computer systems the invention is not so limited but rather may be implemented in connection with any computing environment such as a network or distributed computing environment. Still further aspects of the invention may be implemented in or across a plurality of processing chips or devices and storage may similarly be effected across a plurality of devices. Such devices might include personal computers network servers handheld devices supercomputers or computers integrated into other systems such as automobiles and airplanes.

In light of the diverse computing environments that may be built according to the general framework provided in the systems and methods provided herein cannot be construed as limited in any way to a particular computing architecture. Instead the invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

Referring next to shown is an exemplary networked computing environment in which many computerized processes may be implemented to perform the processes described above. For example parallel computing may be part of such a networked environment with various clients on the network of using and or implementing the defining and extracting of a flat list of search properties from a rich structured type. One of ordinary skill in the art can appreciate that networks can connect any computer or other client or server device or in a distributed computing environment. In this regard any computer system or environment having any number of processing memory or storage units and any number of applications and processes occurring simultaneously is considered suitable for use in connection with the systems and methods provided.

Distributed computing provides sharing of computer resources and services by exchange between computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for files. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may implicate the processes described herein.

This network may itself comprise other computing entities that provide services to the system of and may itself represent multiple interconnected networks. In accordance with an aspect of the invention each entity and may contain discrete functional program modules that might make use of an API or other object software firmware and or hardware to request services of one or more of the other entities and .

It can also be appreciated that an object such as may be hosted on another computing device . Thus although the physical environment depicted may show the connected devices as computers such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs televisions MP3 players etc. software objects such as interfaces COM objects and the like.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems may be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks. Any such infrastructures whether coupled to the Internet or not may be used in conjunction with the systems and methods provided.

A network infrastructure may enable a host of network topologies such as client server peer to peer or hybrid architectures. The client is a member of a class or group that uses the services of another class or group to which it is not related. In computing a client is a process i.e. roughly a set of instructions or tasks that requests a service provided by another program. The client process utilizes the requested service without having to know any working details about the other program or the service itself. In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the example of any entity and can be considered a client a server or both depending on the circumstances.

A server is typically though not necessarily a remote computer system accessible over a remote or local network such as the Internet. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server. Any software objects may be distributed across multiple computing devices or objects.

Client s and server s communicate with one another utilizing the functionality provided by protocol layer s . For example HyperText Transfer Protocol HTTP is a common protocol that is used in conjunction with the World Wide Web WWW or the Web. Typically a computer network address such as an Internet Protocol IP address or other reference such as a Universal Resource Locator URL can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium e.g. client s and server s may be coupled to one another via TCP IP connection s for high capacity communication.

In light of the diverse computing environments that may be built according to the general framework provided in and the further diversification that can occur in computing in a network environment such as that of the systems and methods provided herein cannot be construed as limited in any way to a particular computing architecture or operating system. Instead the invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

Although the concepts ideas and features described herein are described in an exemplary fashion with respect to how they are implemented in a file system called Microsoft Windows Future Storage or Microsoft Windows File System WinFS and the Microsoft Windows Vista operating system formerly code named Longhorn implementations in and applicability to other operating and file systems are contemplated entirely possible and apparent to those skilled in the art based on the exemplary descriptions provided herein. Provided below is a background and overview of WinFS largely from http en.wikipedia.org wiki WinFS including description of the data storage data model type system relationships rules accsess control data retrieval search and data sharing aspects of WinFS.

WinFS is a data storage and management system based on relational databases developed by Microsoft Corp. headquartered in Redmond Wash. for use as an advanced storage subsystem for the Microsoft Windows operating system.

Implemented on top of the NT File System NTFS one of the file systems for the Microsoft Windows NT operating system WinFS is a centralized data store for the Microsoft Windows platform. It allows different kinds of data to be identified by metadata and uses them to set up relationships among data thereby giving a semantic structure to the data. These relationships can then be used by a relational database to enable searching and dynamic aggregation of the data allowing the data to be presented in a variety of ways. WinFS includes a relational database engine derived from the Microsoft SQL Server 2005 SQL database platform to facilitate this.

Previously file systems viewed files and other file system objects only as a stream of bytes and had no information regarding the data that is stored in the files. They also provided only a single way of organizing the files and that is via folders and file names. Because such a file system has no knowledge about the data it stores the applications creating the file tend to use specific often proprietary file formats i.e. the data can be interpreted only by the application that created it. This leads to proliferation of application specific file formats and hampers sharing of data between multiple applications. It becomes difficult to create an application which processes information from multiple file types because the programmers have to understand the structure of all the files where the source data could reside and then figure out how to filter out the necessary information from all the information that will be stored in the file. If more than one file type stores the same data in different formats it becomes necessary to convert them to a single format before they can be used. Though common file formats can be used as a workaround to this problem they do not present a universal solution there is no guarantee that any given application will be able to access the data.

As a result of the above mentioned properties of file systems data from multiple applications cannot be easily. aggregated. The only knowledge that the file system has about the data is the name of the file the data is stored in. As a result of this file systems can retrieve and search data based only on the filename. A better solution would be the use of rich properties independently exposed by each file recognizable by either the file system natively or via some extension. These rich properties are metadata about the files such as type of file e.g. document picture music etc. creator artist etc. This allows files to be searched for by its properties in ways not possible using only the folder hierarchy such as finding pictures which have person X . Desktop search applications take this concept a step further. They index the files including the rich properties and using file filters extract interesting data from different file formats. Different filters have to be used for different file formats. This allows for searching on both the file s properties and the data contained in the file.

However they still don t promote data sharing as the data they extract is stored in a format specific to the desktop search application in a format which enables fast searching. Desktop search applications can only find information and can t help users with anything that needs to be done with the searched information. Also this approach doesn t solve the problem of aggregating data from two or more applications. For example it is nearly impossible to search for the phone numbers of all persons who lives in some city X and has more than 100 appearances in my collection of photos and with whom I have had e mail within last month. Such a search encompasses data across three applications address book for phone numbers and address photo manager for information on who appears in which photo and the e mail application to know the e mail acquaintances.

This is where WinFS comes into effect. The artificial organization using names and location is done away with and a more natural organization is created one using rich properties to describe the data in files and the relation of that data with other data. By creating a unified datastore it promotes sharing and reuse of data between different applications. The advantage is that any application or even the file browser can understand files created by any application. Addition of rich properties will give further meaning to the data such as which persons appear in which pictures and the person an e mail was addressed to. But instead of viewing the pictures and e mails and files WinFS recognizes picture and e mail to be specific types of data which are related to person using the relation of some person. So by following the relation a picture can be used to aggregate e mails from all the persons in the picture and conversely an e mail can aggregate all pictures in which the addressee appears in. WinFS extends this to understand any arbitrary types of data and the relations that hold them together. The types and relations have to be specified by the application that stores the data or the user and WinFS organizes the data accordingly.

WinFS stores data in virtual locations called stores. A WinFS store is a common repository where every application will store their data along with its metadata relationships and information on how to interpret the data. In this way WinFS does away with the folder hierarchy and allows searching across the entire repository of data.

WinFS store is actually a relational store where applications can store their structured as well as unstructured data. Based on the meta data metadata type of data and also the relationships of the data with other data as will be specified by the application or the user WinFS will assign a relational structure to the data. By using the relationships WinFS aggregates related data. WinFS provides a unified storage but stops short of defining the format that is to be stored in the data stores. Instead it supports data to be written in application specific formats. But applications must provide a schema that defines how the file format should be interpreted. For example a schema could be added to allow WinFS to understand how to read and thus be able to search and analyze say a Portable Document Format PDF file. By using the schema any application can read data from any other application and also allows different applications from writing in each other s format by sharing the schema.

Multiple WinFS stores can be created on a single machine. This allows different classes of data to be kept segregated for example official documents and personal documents can be kept in different stores. WinFS by default provides only one store named DefaultStore. WinFS stores are exposed as shell objects akin to virtual folders which dynamically generates a list of all items present in the store and presents them in a folder view. The shell object also allows searching information in the datastore.

WinFS is not a physical file system. Rather it provides rich data modeling capabilities on top of the NTFS file system. It still uses NTFS to store its data in physical files. WinFS uses a relational engine which is derived from Microsoft SQL Server 2005 to provide the data relations mechanism as the relation system in WinFS is very similar to the relation system used in relational databases. WinFS stores are SQL Server database .MDF files with the FILESTREAM attribute set. These files are stored in secured folder named System Volume Information placed into the volume root in folders under the folder WinFS with names of GUIDs of these stores.

WinFS also allows programmatic access to its features for example via a set of Microsoft .NET .NET application programming interfaces APIs that enables applications to define custom made data types define relationships among data store and retrieve information and allow advanced searches. The applications can then use novel ways of aggregating data and presenting the aggregated data to the user.

A data unit that has to be stored in a WinFS store is called a WinFS item. A WinFS item along with the core data item also contains information on how the data item is related with other data.

WinFS helps in unification of data and thus reduce redundancies. If different applications store data in a non interoperable way data has to be duplicated across applications which deal with same data. For example if more than one e mail application is used the list of contacts must be duplicated across the two. So when there is any need for updating contact information it must be done at two places. If by mistake it is not updated in one of the applications it will continue to have outdated information. But with WinFS an application can store all the contact information in a WinFS store and supply the schema in which it is stored. Then other applications can use the stored data. By doing so duplicate data is removed and with it the hassles of manually synchronizing all instances of the data.

WinFS models data using the data items along with its relationships fragments and rules governing its usage. WinFS needs to understand the type and structure of the data items so that the information stored in the data item can be made available to any application that requests it. This is done by the use of schemas. For every type of data item that is to be stored in WinFS a corresponding schema needs to be provided which will define the type structure and associations of the data. These schemas are defined for example using Extensible Markup Language XML . XML allows designers to create their own customized tags enabling the definition transmission validation and interpretation of data between applications and between organizations.

Predefined WinFS schemas include schemas for messages contacts calendars file items etc. and also includes system schemas that include configuration programs and other system related data. Custom schemas can be defined on a per application basis in situations where an application wants to store its data in WinFS but not share the structure of that data with other applications or they can be made available across the system.

The most important difference between other file systems and WinFS is that WinFS knows the type of each data item that it stores and the type specifies the properties of the data item. The WinFS type system is closely associated with the .NET Framework s concept of classes and inheritance. A new type can be created by extending and nesting any predefined types.

Referring next to shown is a block diagram illustrating an exemplary type hierarchy. Shown is item that has three other item types deriving from it contact document and picture .

In particular WinFS provides four predefined base types Items Relationships ScalarTypes and ComplexTypes. An Item is the fundamental data object which can be stored and a Relationship is the relation or link between two data items. Generally since all WinFS items must have a type the type of item stored defines its properties. The properties of an Item may be a ScalarType which defines the smallest unit of information a property can have or a ComplexType which is a collection of more than one ScalarTypes and or ComplexTypes. All WinFS types are made available as .NET Common Language Runtime CLR classes. CLR is the core runtime engine in the Microsoft .NET Framework for executing applications.

Any object represented as a data unit such as contact picture document etc can be stored in a WinFS store as a specialization of the Item type. By default WinFS provides Item types for Files Contacts Calendar Messages etc.. The File Item can store any generic data which is stored in file systems as files. The file item may not be specialized derived from but a WinFS schema can be provided to extend it using fragments that are added on to particular instances of File items. A file Item can also support being related to other Items. A developer can extend any of the WinFS types other than File item or the base type Item to provide a type for his or her custom data.

Referring next to shown is a block diagram illustrating an example use of the predefined types in defining a new type. The data contained in an Item is defined in terms of properties or fields which hold the actual data. For example an Item Contact may have a field Name which is a ScalarType and one field Address a ComplexType which is further composed of two ScalarTypes Street and City . To define this type the base class Item is extended and the necessary fields are added to the class. A ComplexType field can be defined as another class which contains the two ScalarType fields. Once the type is defined a schema has to be defined which denotes the primitive type of each field for example the Name field is a String the Address field is a custom defined Address class both the fields of which are Strings. Other primitive types that WinFS supports are Integer Byte Decimal Float Double Boolean and DateTime among others. The schema will also define which fields are mandatory and which are optional. The Contact Item defined in this way will be used to store information regarding the Contact by populating the properties field and storing it. If more properties on the item such as last conversed date needs to be added this type can be simply extended to accommodate them. Item types for other data can be defined similarly.

Items can be related to one more other items giving rise to a one to one relationship or with more than one item resulting in a one to many relationship. The related items in turn may be related to other data items as well resulting in a network of relationships. Creating a relationship between two items creates another field in the data of the items concerned which refer to the row in the other item s table where the related object is stored.

Referring next to shown is a block diagram illustrating an exemplary relationship between two items Item Reference . A Relationship represents a mapping between two items a Source e.g. a picture item and a Target a e.g. a contact item . From the point of view of the Source item the relationship is an Outgoing Relationship whereas from that of the target item it is an Incoming Relationship. Relationships are bidirectional which means that if Source is related with Target the Target is also related with the Source . WinFS provides three types of primitive relationships Containment ItemReference and Condition based association.

WinFS includes Rules which are executed when certain condition is met. WinFS rules work on data and data relationships. For example a rule can be created which states that whenever an Item is created which contains field Name and if the value of that field is some particular name a relationship should be created which relates the Item with some other Item. WinFS rules can also access any external application. For example a rule can be built which launches a Notify application whenever a mail is received from a particular contact. WinFS rules can also be used to add new properties fields to existing data Items.

WinFS rules are also exposed as .NET CLR objects. As such any rule can be used for any other purposes. They can be even extended by inheriting them to form a new rule which consists of the condition and action of the parent rule plus something more or new.

Even though all data is shared everything is not equally accessible. WinFS uses Microsoft Windows authentication system to provide two data protection mechanisms. First there is share level security that controls access to the WinFS share. Second there is item level security that supports Microsoft Windows NT compatible security descriptors. The process accessing the item must have enough privileges to access it.

The primary mode of data retrieval from a WinFS store is searching for the required data and enumerating through the set of Items that has been returned. WinFS also supports retrieval of the entire collection of Items that is stored in the WinFS store or returning a subset of it which matches the criteria that has been queried for.

WinFS makes all data available as CLR objects. So the data retrieved which is encapsulated as an object has intrinsic awareness of itself. By using the abstraction provided by use of objects it presents a uniform interface to hide its physical layout and still allow applications to retrieve the data in an application independent format or to get information about the data such as its author type and its relations.

For each Item that has been returned WinFS can also return a set of Relations which specify the Relations the Item is involved in. WinFS can return all the relations of the Item or can return Relations that conform to a queried criterion. For each pair or Item and Relation WinFS can retrieve the Item which forms the other end of the Relation. Thus by traversing the Relations of an Item all the Items that are related with the Item can be retrieved.

WinFS application programming interface API provides a class called the ItemContext class which is used to query for and update WinFS Items. The criterion for the query is expressed using an ESQL Entity SQL query string which is derived from Transact SQL TSQL and extends it with additional support for rich types collections and objects. As an example the following query will return a collection of messages located in a folder given the folder s ItemId itemId and that has a Title that starts with a specified string 

The above statement is very similar to a transact SQL statement with the addition of a new operator ofType. Joins order by group by aggregate functions nested queries can also be used in ESQL. ESQL however does not provide 100 compatibility with TSQL.

An ESQL query can specify a single search condition or a compound condition. ESQL queries can also be used with relationships to find related data.

WinFS is about sharing data. It allows easy sharing of data between applications. Not just that there is provision to share data among multiple WinFS stores as well which might reside in different computers by copying to and from them. A WinFS item can also be copied to a non WinFS file system but unless that data item is put back into WinFS store it won t support the advanced services provided by WinFS.

WinFS API also provides some support for sharing with non WinFS applications. WinFS exposes a shell object to access WinFS stores. This object which maps the WinFS items to a virtual folder hierarchy can be accessed by any application. Non WinFS file formats can be stored in WinFS stores as well using the File Item provided by WinFS. Importers can be written which convert specific file formats to WinFS Item types.

WinFS data can also be manually shared using network shares by sharing the legacy shell object. In addition WinFS provides synchronization services to automatically synchronize Items in two or more WinFS stores subject to some predefined condition such as share only photos or share photos which have an associated contact. The stores may be in the same computer or on different computers. Synchronization is done in a peer to peer mode eliminating the need to any central authority to manage the synchronization. Whenever a synchronization which can be either manual or automatic or scheduled is initiated WinFS enumerates the changes i.e. it finds out which Items are new or changed and therefore in need of synchronization and then update accordingly. If two or more changes are conflicting WinFS can either resort to automatic resolution of the conflict based on predefined rules or can defer them for manual resolution.

Extracting Microsoft Windows Vista operating system i.e. Windows or Windows Vista search properties from WinFS data is important to allow WinFS applications to search and categorize data in WinFS. Applications that are WinFS type agnostic can just operate on these search properties rather than operating on the individual types. Since these properties are stored in Windows Desktop Search WDS store as well it allows non WinFS applications written against WDS application programming interfaces APIs to also view search properties from WinFS data.

Also the WinFS independent software vendors ISVs can pick the metadata search properties for their types without compromising their item schema design. The ISVs specify mappings between WinFS types and the Windows search properties. These mappings can be specified by a type designer as mapping files. For file stream contents in file items WinFS leverages the Property handlers registered with the Windows property system and extract appropriate search properties.

Referring next to shown is a block diagram illustrating as an example the alignment of WinFS content in WDS to accomplish the above objectives. As shown WinFS notifies WDS about WinFS item changes. Then the Protocol Handler is invoked by WDS . Search properties for the item are then extracted and stored in WinFS Store and WDS property store using the WDS components. Properties of WinFS items can then be used in Windows Vista search and in organization capabilities similar to any other content in Windows Vista. WinFS items are full text indexed using the Windows Search indexer . Indexes for WinFS items are stored in the common index catalog defined as part of the WDS . Full text queries in Windows platform return WinFS items alongside other non WinFS content.

WinFS API surface programs against search properties associated with an item . This includes querying for these properties and allows updates to these properties . The WinFS API query syntax allows making use of WDS full text query operations. Full text queries through the WinFS API are also satisfied by the common index catalog maintained by WDS. The WinFS Shell Namespace Extension WinFS SNE handles generic shell operations over WinFS items like double click bindings icons thumbnails etc. WinFS SNE allows updates of search properties of WinFS Items using the WinFS API . Out of the box WinFS schemas accommodate search property mapping definitions and corresponding schema types.

As shown above rich structured data in WinFS is mapped into a set of Windows search properties which is a flat list. These properties are stored both in the WDS Store i.e. WDS property store and in the WinFS Store . This is applicable not only to WinFS but any rich structured data that should be mapped into Windows search properties .

A mapping language is used for mapping search properties from rich structured data types declared as part of a WinFS type schema. For example this mapping language uses a query language for operating on entities in WinFS. The mapping is specified in a separate file from the schema definition using an XML syntax. Windows search properties can be defined in terms of schematized properties with simple functions over them such as WindowsSearchName Contact.FirstName Contact.LastName. Referring next to shown is an example of such XML code for search property mappings.

In addition if the type designer desires these search properties to be updatable he she to provides C code for doing the reverse mapping from search properties to the appropriate native type properties. This reverse mapping indicates that when the user changes the value of search property through WinFS API this supplied C code will be invoked to change the appropriate native type properties.

The process involved in defining and compiling these mappings is as follows. For defining the mappings at build time the type designer defines his her types in the schema and generates the client C classes using the normal WinFS schema install mechanism. The type designer or a separate mapping designer defines the ESQL mapping expressions from the WinFS type properties to the Windows search properties. These mappings are provided in a separate mapping file see . This file is also compiled through WinFS APIG to generate C classes. C classes are compiled to generate the client assembly.

The mapping file using specific schema definition language XML constructs can contain the ESQL mapping from multiple types from many different.schemas. ESQL Mapping and Update code for search properties are defined on the base item type. The ESQL expression can refer to ItemReferences and Fragments for types defined in the same schema or schemas being referenced through a using clause in the schema file where Item is defined. The mappings are installed in an assembly. If an assembly contained mappings for more than one item type one would still install all the mappings in that assembly.

An installation mechanism is used to install these mappings on a machine where WinFS is installed. The mappings are installed on a per machine basis. The installation process will generate SQL queries corresponding to the mappings and store this along with associated metadata in WinFS.

The Installer utility will iterate through the supplied client assembly and the ESQL mapping information associated with it to generate SQL queries corresponding to the mappings on the item type defined in the schema. These generated SQL statements will be stored in a set of tables in the default WinFS store on the machine where WinFS is installed. These are used by the WinFS search property extraction component at runtime to extract search properties from a given item of certain type.

The reverse process of search property extraction or promotion is called demotion. Anytime a search property is modified using the WinFS API the reverse mapping to promotion is done by using update code supplied by the mapping provider to write back the search property to the original data location in the WinFS item or file.

The metadata about the stored mappings will also be retrieved and used by the WinFS API demotion infrastructure. To facilitate this WinFS search infrastructure will provide a stored procedure called GetDemotionAssemblies that can be called by the WinFS API during the demotion phase see code and table below .

During demotion WinFS API needs to know which set of update codes need to be executed for mapping the values from the changed search property to the appropriate properties in the native types. This information is retrieved by calling this stored procedure. This stored procedure does the following 

For file items WinFS will leverage any defined Windows property handlers for extracting search properties.

If the property handler an IPropertyStore implementation for this file type is already defined as part of the Windows platform on the machine where WinFS is also installed the type designer does not need to do anything extra to get the search properties of this file item type to participate in the Windows Search experience. WinFS search property extraction components working inside the Windows Desktop Search service will be able to extract the search properties and expose them through the Windows Vista search mechanisms whenever a file item of the defined type is created or modified in WinFS.

If there is no property handler for this file type in the Windows platform the type designer can define a new one using mechanisms provided by the Windows shell component or associate their file type with an existing property handler. If the file item has native fragments defined on it ESQL mappings are specified to extract any search properties from these native portions of the file items. This process is similar to the mapping specification defined earlier.

In addition to WDS property store search Properties are also stored in the WinFS store. WinFS store will allow WinFS API and other clients to query update search properties. Also in addition to promoting the search properties into the Windows Search property store and WinFS store WinFS application developers can also program against these search properties using WinFS API. This includes capability for querying search properties as well as updating search properties stored in the WinFS Store.

An execution infrastructure utilizes the generated SQL from the mappings to extract search properties from WinFS items. This infrastructure asynchronously extracts and stores search properties from WinFS data into WinFS and the WDS store.

Referring next to shown is a block diagram illustrating search property extraction and storage. Once the required ESQL mappings and file property handlers are in place on the machine for a given WinFS type extraction and storage of search properties i.e. search property promotion happens automatically whenever an item of that type is created modified in any WinFS store on that machine. shows the steps involved in the promotion process. The components shaded in dark gray color are the WinFS components code participating in the promotion process. In the example scenario used in an item native or file item is created modified in the WinFS Store using WinFS API or Win32 API. Provided below is a description of the control flow during the search property extraction and storage phase. The step numbers specified below have corresponding reference numerals shown in 

At the end of this process all the search properties are extracted from the modified item and stored in both WinFS Store and the Windows Search Property store .

A deterministic arbitration policy is imposed by the storage system e.g. WinFS infrastructure so that the act of using mappings defined by different applications on the same item type does not change the search properties observed by the user. The result is that the user always sees his or her data in a consistent manner while at the same time giving flexibility to applications to provide additional functionality by defining new fragments on the item and mappings on them to search properties.

For example during the search property promotion described in the sections above properties from multiple entity types could map to the same search property. Referring next to shown is an example of properties from multiple entity types mapping to the same search property. The jpg filestream has a location property . Two applications digital images Application digital image and Application digital image are based on that jpg filestream . The Applications also have their own WinFS native properties for the digital image in fragments on the WinFS item corresponding to that file location property for Application and city and state properties for Application . The jpg filestream location property is shown mapped to the user property System.photo.location . The Application location property is also mapped to the same search property System.photo.location .

A deterministic arbitration policy would decide which property wins over the other. In the present example of the filestream property wins over the Application native property . The reasoning behind this is that the filestream property is likely a standard that is more well known in general than the native properties of a particular application. Also another example of an arbitration policy is that the native properties for the application that created the item base item type win over the derived item types. The general policy is that the entity type picked as the winner is that which maintains application compatibility. However these rules are examples and opposite different or additional rules may be applied as long as there is some arbitration policy in effect that picks one of the entity types as the winner.

Provided below is a more comprehensive example arbitration policy example that may be applied in the WinFS context.

2. In a given schema and for a given item type there cannot be duplicate mapping for the same search property. This would fail at installation time and hence is not part of the runtime arbitration policy as such. This will be enforced at mapping installation time.

3. Mappings defined in a schema that contains the item type referred to as the item schema win over mappings defined in other schemas for the same item type. This is because the person defining the item type is an owner of sorts and hence is given preference.

4. Between two item types in an inheritance hierarchy the base type wins. This is to maintain application compatibility so that a new subtype introduced in the system does not change the behavior of an application working on the base type.

5. If two non item schemas map the same search property for the same item type then the schema based on the schema strong name is chosen. The lesser schema strong name in dictionary order wins. This is to ensure that the policy is deterministic and is not dependent on the order of installation of schemas. This ensures that 2 machines with identical mappings installed would have the same search properties for a given WinFS item.

An alternative arbitration policy between multiple entity types could allow a priority number to be associated with a search property mapping definition. The priority number would be specified by the individual providing the mapping file. A higher priority number would indicate that mapping should win over others. If the priority is not specified then a default priority is chosen based on the above arbitration rules or a similar set of rules.

The various systems methods and techniques described herein may be implemented with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computer will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

The methods and apparatus of the present invention may also be embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer a video recorder or the like the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates to perform the functionality of the present invention.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating there from. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific hardware software interface systems are herein contemplated especially as the number of wireless networked devices continues to proliferate. Therefore the present invention should not be limited to any single embodiment but rather construed in breadth and scope in accordance with the appended claims.

Finally the disclosed embodiments described herein may be adapted for use in other processor architectures computer based systems or system virtualizations and such embodiments are expressly anticipated by the disclosures made herein and thus the present invention should not be limited to specific embodiments described herein but instead construed most broadly.

