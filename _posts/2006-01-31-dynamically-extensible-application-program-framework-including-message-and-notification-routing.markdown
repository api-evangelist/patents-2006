---

title: Dynamically extensible application program framework including message and notification routing
abstract: Dynamically configuring an application program at run-time via one or more extension objects. The invention software implements a framework with one or more extension objects providing functionality to an application program and an application manager for integrating the functionality with the application program during execution of the application program. The framework of the invention also formulates and routes application messages between extensible objects of one application program and extensible objects of other application programs implementing a similar, dynamically extensible application program framework. On receipt of messages or notifications, the framework of the receiving application program facilitates the discovery of the intended recipient extension object and routes the message accordingly.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07861167&OS=07861167&RS=07861167
owner: Microsoft Corporation
number: 07861167
owner_city: Redmond
owner_country: US
publication_date: 20060131
---
This application is a divisional of U.S. patent application Ser. No. 10 219 222 filed Aug. 15 2002 the entire disclosure of which is incorporated herein by reference.

The present invention relates to the field of application program design. In particular this invention relates to an extensible application program framework in which extension object providers supply extension objects to add functionality to or change existing functionality of an application program.

Object oriented programming methodologies are rapidly replacing the procedure oriented monolithic application development that was prevalent a decade ago. In current application program development frameworks the exposed functionality is static in nature in that a fixed and inherent set of exposed properties and methods are employed by the application components. Existing extension mechanisms require that extensions be provided via fixed properties methods and general framework updates at compile or design time. Such current systems fail to provide a dynamically upgradeable or otherwise extensible application program framework encompassing both user interface and application logic i.e. core infrastructure components.

For these reasons a dynamically extensible application program framework having messaging and notification routing is desired to address one or more of these and other disadvantages.

The invention includes software implementing a framework for a dynamically extensible application program. In particular the invention software includes one or more extension objects providing functionality to the application program and an application manager for integrating the functionality with the application program during execution of the application program.

Rather than a static configuration of functionality for an application program the extensible application program framework of the invention provides for dynamic reconfiguration of application program functionality on the fly without a re compilation of the application program. The extensible application program framework of the invention enables dynamically extending the inherent functionality that is available for a component resident within the application program through extension objects. An extension object is proffered by an extension object provider when the extension object is first referenced e.g. the functionality is first requested . The extension object provider creates an appropriate extension object that implements the requested functionality. The extension object services all references to the extension or other requests for the functionality. Information about the extension object provider is registered in a database of the application manager when the extension object provider is installed. The database is used to resolve references to the extended methods and or properties upon execution of the application program.

The framework of the invention also formulates and routes application messages between extensible objects of one application program and extensible objects of other application programs implementing a similar dynamically extensible application program framework. On receipt of messages or notifications the framework of the receiving application program facilitates the discovery of the intended recipient extension object and routes the message accordingly.

The framework of the invention facilitates multiple extensions developed by different parties over time to reuse interoperate and extend existing infrastructure components. Further the framework permits the ability to add new user interface UI elements as extension objects that proffer additional functionality and yet maintain interoperability with previously released UI components. The invention provides a development methodology for use in any application development environment permits the addition of functionality without replacing or installing the entire application program by reusing existing common infrastructure and facilitates a staged release approach where features are enhanced and realized over time via extension objects. In particular extension object providers provide extension objects that add new communication channels provide or extend communication protocols implement secure communication channels by providing authentication and encryption features and provide additional UI features or elements.

In accordance with one aspect of the invention a system for a dynamically extensible application program framework includes an application program having functionality and one or more extension objects that modify the functionality during execution of the application program.

In accordance with another aspect of the invention one or more computer readable media have computer executable modules for implementing an extensible application program framework. The modules include one or more extension objects and an application manager module. The extension objects provide functionality to an application program. The application manager module integrates the functionality with the application program during execution of the application program.

In accordance with yet another aspect of the invention a method dynamically configures an application program. The method includes defining one or more extension objects to provide functionality to the application program. The method also includes integrating the functionality provided by the one or more extension objects with the application program during execution of the application program.

In accordance with yet another aspect of the invention a system switches between multiple views of a workspace in a user interface. The system includes at least one view extension object and a view selector object. The view extension object provides at least one user interface element for the user interface. The user interface is associated with a dynamically extensible application. The view extension object corresponds to a view selection service object. The view selector object manages the view selection service object to transition a view for the workspace.

In accordance with yet another aspect of the invention a computer readable medium stores a data structure representing a header for a message. The message is encapsulated by an extension object in an extension object hierarchy of a dynamically extensible application program. The data structure includes a type field identifying a class of the extension object and a name field identifying the extension object.

Many application programs are multi tiered static and have distinguished structure. To add functionality to these application programs the application programs are recompiled and delivered in their entirety to end users of the application program. In contrast for application programs implementing the dynamically configurable framework of the invention functionality can be added deleted or otherwise modified in each layer of the application program via extension objects as illustrated in . With reference to an application program implemented according to a framework of the invention includes but is not limited to a workspace an application manager and one or more extension object providers such as extension object provider through extension object provider N where N is a positive integer value. The application manager includes but is not limited to a database a transfer agent an event dispatcher and a view selector object . Each extension object provider includes one or more extension objects such as extension object through extension object X where X is a positive integer value.

To add functionality to an application program implemented in accordance with the invention an extension object or other component implementing the desired functionality is used to upgrade the application program. That is the extension objects modify e.g. add delete or replace the functionality of the application program. The extension objects modify the functionality during execution of the application program. For example functionality embodied within the extension object may enhance a user interface or provide for additional protocol adaptation at a later time to extend the application program. Those skilled in the art are familiar with implementing and delivering application programs via computer readable media or via downloading over a network. If protocols e.g. communication protocols are developed after the application program has been implemented and delivered an extension object may be delivered to add a corresponding protocol adapter to enable support for the developed protocol. The extension objects may be developed by a developer of the application program or by third parties. In one exemplary embodiment the extension objects are instantiated objects as described in the context of object oriented programming. However it is contemplated by the inventors that extension objects and the framework of the invention as described herein are applicable in an environment other than an object oriented environment.

In addition it is contemplated by the inventors that the invention software may include more or less services and or components than those illustrated in . In addition the services and or components of the invention software may include more or less functionality than the services components and functionality described and illustrated herein. In addition those skilled in the art will note that the framework and software of the invention may implement various communications protocols not specifically limited to the communications protocols described herein. Also the application program framework may be implemented by different application programs on a single computing device to facilitate communication between the application programs. Alternatively the application program framework may be implemented by different application programs executing on different computing devices to facilitate communication between the application programs.

One embodiment where such an application program framework can be used is in case of a peer to peer application such as instant messaging. In such an application new functionality such as voice and video communication file sharing shared browsing shared music listening etc. can be added to the application after the application is initially released. Also new communications protocols may be added to the application either to support new functionality or to enable this functionality between different kinds of peers. In an example of the latter one peer is a user on one instant messaging service and the other peer is a user on another instant messaging service. Note that this is only one example of an application which could use such an application framework to extend functionality over time.

In one embodiment as illustrated in components of the framework include the application manager one or more extension object providers one or more extension objects and one or more workspaces . In addition communication between components of the framework and between frameworks is implemented via messages. Depending on the type and needs of the application program to be implemented one or more of the components illustrated in are included with the application program. In one embodiment no extension objects are included in application programs that are shipped initially to the end user. Later as additional functionality is requested extension objects implementing the requested functionality are shipped to the end user. For example communicative application programs e.g. application programs that communicate with other application programs or other computing devices utilize the transfer agent within the application manager so the transfer agent is included with the application manager for those communicative application programs. The transfer agent is not included with the application manager for non communicative application programs.

In the illustrated embodiment the framework includes default extension objects and extension objects as UI elements . Further details of the application program framework are described in the following sections.

The application manager may include one or more of the following the database the transfer agent the event dispatcher the view selector object an extension object loader a query service and a message routing module for routing messages within a particular application program.

When the framework is initialized at application program startup the framework creates the application manager . This centralized component manages requests for specific functionality by other components e.g. extension objects that are loaded within the framework . Simultaneously the application manager services requests from extension objects which are currently loaded to obtain the identity to other extension objects that may be installed later to provide other specific functionality. When a request for specific functionality is received by the application manager the application manager queries the database to locate the appropriate extension object provider checks the validity of the request and of the provider instantiates the appropriate extension object obtains the required interfaces and identifies the instantiated extension object to the requesting component. For example the application manager may return a reference handle or pointer of the instantiated extension object to the requesting component. In one embodiment extension objects are created in response to a request from other extension objects or the application manager with the exception of specific framework objects such as those that provide the basic functionality of the application manager . Certain extension object providers however can register to have their extension objects be loaded at startup.

In addition as described below the application manager facilitates discovery and resolution between multiple extension object providers and provides message event routing within the application program framework . In particular previously installed extension objects can discover newly installed extension objects . The application manager also facilitates discovery between application programs on the same computing device or on different computing devices. For example an application program can discover whether another application program supports a given protocol. In one embodiment extension objects that are specifically used for communication are discovered resolved and loaded by the transfer agent within the application manager .

In one embodiment extension object providers are executables that house one or more extension objects described in greater detail below. Extension object providers implement specific interfaces through which the version of the extension object provider can be verified certificates can be used to check for authenticity and validity of the extension object provider and instances of the housed extension objects can be instantiated. Those skilled in the art will appreciate that a single executable could provide multiple extension objects such as illustrated in . When an extension object is instantiated the instantiated extension object may request functionality that is proffered by other extension object providers . In such cases the other extension object providers will also be loaded by the application manager .

Upon installation extension object providers register with the database of the application manager . That is the extension object providers contribute registration information such as presence information and housed extension objects to the database in the application manager to register with the framework . Optional authentication routines can be performed at this stage to prevent rogue executables from registering themselves with the framework . For example the application manager may ask the registering extension object provider for a certificate or other credential to verify that the registering extension object provider was obtained from an authorized or otherwise trusted source.

Extension objects proffer additional functionality or augment existing functionality of the framework . The extension objects are not limited or bound to any application logic layer. For example the extension objects may include new functionality added to the application or proffer UI elements to existing functionality. The UI elements may include an application UI property pages an instance user list that needs to be displayed on the UI or client area designers . The application program framework services these objects by routing the appropriate messages to the workspace windows .

Some extension objects proffer UI within workspaces as plug ins. In addition to the interfaces implemented by the extension object providers described above plug in extension objects support interfaces that are sited within the workspace windows and are able to persist and recreate themselves from instance data.

Protocol adapters are one form of extension objects that establish and authenticate peer to peer connections and perform data transfers when a message is to be transacted. The protocol adapters listen to communication port events and may be instantiated when the framework is initialized or when communication functionality using the specific protocol is requested by some other extension object. When an event occurs on the bound port the protocol adapters raise an application program framework event that is routed to the event dispatcher within the application manager through the transfer agent .

Referring now to in one embodiment of the application program framework a hierarchical relation may exist amongst extension objects . In extension object A communicates with extension object B while extension object B communicates with extension object C. In this example extension object A communicates with extension object B and extension object D but has no direct communication with extension object C. In this example extension object A may communicate with extension object B to solicit the services of extension object B. The functionality of extension object B is never exposed outside the context and hierarchical relationship of extension object A. Such hierarchies are utilized within the workspace window to provide alternate views and layout of the UI see below for details .

With further reference to default extension objects are extension objects made available by the framework to facilitate basic functionality such as persistence. Extension object providers can provide overriding functionality that supersedes the default extension objects . Exemplary default extension objects include a persistence object a client area designer e.g. a UI element a global user list and a generic workspace . The generic workspace is a generic window that provides a client area where UI extension objects expose their UI and have selection and context sensitive UI interaction.

In the extensible application program framework of the invention the extension object provider and the extension object are often cached when first referenced and subsequent references to the extension object are resolved to the cache. Furthermore because the run time environment resolves the first reference to an extension object to the appropriate extension object provider extension objects can be instantiated or otherwise activated at application program run time rather than at application program compile time. This permits the deployment of application logic components e.g. objects as well as UI elements in staged releases where all components seamlessly interact and realize the additional functionality enabled by the newly instantiated components.

In operation extension objects proffer their services to the application manager . For example an extension object providing chat functionality provides other services e.g. secondary functionality such as voice chat UI views. The secondary functionality becomes available to all other extension objects through the application manager after the extension object proffers the secondary functionality to the application manager . In addition extension objects inform the application manager of needed support and the application manager checks the database to determine whether such support exists via one or more other previously loaded extension objects . The application manager provides to the requesting extension object a pointer to the extension object having the requested functionality.

For example an extension object or another similar application program on the same machine or a peer machine may ask the application manager via the query service whether the application program supports voice chat. The application manager loads and initializes the voice chat extension object and provides the interface for the chat service to the requesting extension object . It is contemplated that a first application program may ask the application manager of a second application program whether the second application program has chat capability. The first application program communicates with the second application program via the chat extension object of the second application program. In such a manner the application manager of the second application program acts as a broker to provide the service. The application manager of the second application program may need to load and initialize the previously installed chat extension object to render the object functional. In this example a graceful degradation of end user experience occurs when different peers may or may not have specific extension objects installed due to different versions of programs or due to other reasons.

The workspace is a top level window that is created by the application manager and maintained by the application program framework . The framework routes UI messages between the workspace windows and the plug in extension objects that proffer and site their UI within the workspace windows e.g. the extension objects UI elements . There could be more than one type of workspace in a given application program and each workspace is uniquely identifiable by a unique workspace identifier. For example each workspace may be associated with a unique identifier such as WorkSpaceID which may be a 128 bit globally unique identifier GUID .

When a workspace window is closed the workspace state is persisted along with the plug in extension object identities and instance data. On creation of a workspace with a specific workspace identifier the framework utilizes the persisted data if any to reconstruct the UI layout and state. As with other extension objects the UI plug in extension objects are created and initialized on demand.

Within the context of a workspace window extension object providers are contextually referred to as view extension object providers as illustrated in . The view extension object providers divide the client area of a given workspace and site or otherwise locate plug ins in the regions that are managed by the view extension object providers . The view extension object providers and instantiated view extension objects facilitate alternate layouts within a workspace window . As shown in the example of a user list extension object a tab control bar extension object and other workspace elements are sited in regions of the workspace window that are managed by a view extension object provider .

There can be multiple workspaces for a given application program. For example there can be a first workspace for communication between a first extension object or application program and a second extension object in addition to a second workspace for communication between the first extension object and a third extension object. The first workspace is completely independent of the second workspace. For example there may be one workspace for a user A to communicate with a user B using chat and another separate workspace for the user A to communicate with a user C using voice and chat. In this example there is a separate chat window in each of the workspaces. In addition there can be more than one view extension object provider associated with a given workspace . This will provide multiple selectable views for a given workspace . This concept is further described below.

In one embodiment the workspace window is associated with another peer a group of peers or a device. For example user A may have workspace opened and associated with a peer such as user B. The workspace has a unique identifier such as WS USERA USERB. In this example an extension object e.g. a plug in that supports chat functionality is available within the workspace . When the workspace is closed on user A s machine the data pertaining to the chat extension object and associated with workspace WS USERA USERB is persisted on user A s machine. When the workspace is later created with the identity WS USERA USERB the chat extension object is re instantiated and initialized with the association to user B. Similarly the data pertaining to the chat extension object and associated with workspace WS USERA USERB is persisted and reloaded on user B s machine. Through a communication channel established between the peer machines of user A and user B data including workspace identities are synchronized on initial workspace creation. Subsequent communications on workspace WS USERA USERB carry this identifying signature.

As illustrated in the example of a workspace window operates with at least one view extension object provider at least one view extension object and at least one UI element . One or more view extension objects manage UI elements and their placement within the workspace window . A view extension object includes one or more UI elements and is responsible for providing a particular look and feel placement state management message routing and persistence. UI elements provide specific UI pieces to the workspace through view extension objects . For example the User List Tab Control Bar and other WorkSpace UI element areas of are view extension objects that may be provided by a single view extension object provider . This enables the view extension object providers to proffer different UI view extension objects and UI elements . Hence a given workspace can support multiple views. The relationship between the workspace and the associated view extension provider is determined the persisted workspace instance data or defaults as determined by the database in the application manager . The relationship between multiple view extension providers is determined by the database in the application manager .

As outlined in when one or many view extension providers provide multiple views for a given workspace the application program framework enables a common mechanism and UI to manage the selection of these alternate views. When more than one view is available for a given workspace the application program framework enables a view selector object or other view selection context manager to switch between views. To facilitate this each view extension object provider that provides view extension objects registers their availability with the view selector object through view selection service objects . Each view extension object has a corresponding view selection service object which is registered with the application program framework view selector object . This data is stored in the application manager database to resolve associations. When the framework detects the possibility of using multiple views within a given workspace the framework displays a view selector UI and calls the appropriate view selection service object to transition the view activation de activation and restore state. The workspace frame window informs individual views via message routing both application message and default windows messages and command routing e.g. user commands to resize move or adjust as necessary in response to events such as user selections and inputs. In a chat application program example when a first user on one end of the chat changes views e.g. changes the background color that change occurs for a second user on the other end of the chat. That is the application manager associated with the chat extension object of the first user informs the application manager associated with the chat extension object of the second user of the view change. The application manager sends an application message to the chat extension object of the second user to change the currently active views.

In one embodiment the view selector object is associated with the application manager. It is contemplated by the inventors that the view selector object may be separate from the application manager .

Extension objects register with the application manager to receive messages. Extension objects can broadcast messages through the application manager by using functionality exposed by the application manager . For example a software routine such as BroadcastMessages is available from the application manager . The broadcast messages are sent to all objects that have registered themselves to receive the messages of a given type.

In a distributed application program environment messages and notifications could be originated and targeted to extension objects that have not yet been instantiated if the extension objects have registered themselves in the application database to receive such messages even if they have not been instantiated. The invention software constructs routes and handles these messages within the application program framework as herein described.

The various plug ins or extension objects can use the communication channel provided by the framework to communicate with a similar application program on the peer machine. This communication channel is itself an extension object proffered by extension object providers thereby allowing new types of communication channels with their own connection and authentication protocols to be added later as needed. The extension objects using a communication channel provided by the framework define their own message types based on the kind of functionality the extension objects add to the application program.

As illustrated in application A and application B communicate via a peer to peer connection across network . An application UI receives a message or other input from a user for delivery to a user of application B . The application UI communicates the message or input to an application manager of application A . Application manager A sends the message to application B via the application framework of application A . An application manager of application B receives the message via the application framework of application B . Application manager communicates the message to an application UI of application B for display to the user of application B .

For example a chat extension object defines the structure of a chat message and includes logic on how chat messages are generated and how these messages are received parsed and rendered. When a user sends a chat message the chat extension object generates a chat message and sends it to the workspace e.g. application UI under which the chat extension object is housed. The workspace provides its own workspace specific identification headers e.g. Workspace ID such as WS USERA USERB and routes the message to the extension object e.g. protocol adapter that provides the communication channel via the application manager e.g. application manager and the transfer agent. When the message is received by the peer s application program e.g. application program B the extension object e.g. protocol adapter that provides the communication channel routes the message to the appropriate workspace e.g. application UI via the application manager e.g. application manager and the transfer agent. The workspace parses the workspace specific information and routes the message to the chat extension object on the peer s machine that parses and renders the chat message.

Since the extension objects are hierarchical each extension object defines its own message type. These messages are wrapped with appropriate message headers by the parent extension objects and forwarded to the peer application program where the appropriate portion of the message will be read and interpreted by the appropriate extension objects . As such different types of extension objects can be created over time that can reuse an existing communication infrastructure for sending and receiving messages specific to the extension objects .

Each extension object can choose to encrypt its messages in such a way that only an instance of that extension object on the peer application program can decrypt the encrypted message using a key known only to that extension object . As such security can be added to an existing communication channel for features that require secure communications. For example the communication channel provided by an extension object can be used for both transmitting chat messages and for file transfers. Chat messages may not require secure communication whereas the file transfer messages may require security. The file transfer extension object may encrypt the file transfer messages and use the same communication channel used for sending unencrypted chat messages.

An error condition is generated when a particular extension object is unavailable on a layer of the routing hierarchy at the destination peer machine that parallels that of the sender. In this case the layer where the routing fails may instantiate a default handler that fits the category of the intended recipient extension object type or return the error code through the messaging chain to the sender.

As described above a message can be routed through the hierarchy of extension objects . illustrates encapsulating and sending a message via a transfer agent such as transfer agent . At each level in the hierarchy the message data is encapsulated with an envelope specific to the extension object at that level in the hierarchy. Each envelope identifies a schema and content of the extension object . The extension object and the associated extension object provider determine organization within the envelope. An exemplary nested envelope structure at level K in the hierarchy includes a layout with an extension object type an extension object identity at level K and data for level K. The extension object type and the extension object identity may each be represented as a globally unique identifier GUID . The data for level K may include envelopes from any subordinate levels K X in the hierarchy where K and X are positive integer values. Encryption may occur at any and all levels in the hierarchy.

Once the workspace extension object receives data as a nested envelope from an extension object subordinate in the hierarchy of extension objects e.g. UI element the workspace extension object encapsulates the received data within its own envelope that is stamped with workspace specific data such as its workspace type and identity. The workspace extension object operates on the received envelope via an event handler . For example the encapsulation by the workspace extension object may be represented as E workspace type GUID workspace ID GUID data E UI Data 2 In 2 workspace type identifies the type of workspace extension object workspace ID uniquely identifies workspace extension object and data E UI Data represents the encapsulated data received from the UI element .

Based on the protocol used or recommended by the workspace the workspace extension object interrogates the transfer agent for a suitable protocol adapter. Since the communicating workspaces maintain an association between peers e.g. between user A and user B in the above example the identity and destination of the intended recipient is known. The transfer agent transmits the outbound message using the appropriate communications protocol adapters.

In one embodiment the invention software utilizes a transmission control protocol Internet protocol TCP IP as the transport and other protocols for authentication. In the instant messaging embodiment of the invention network addresses are determined by user association and application programming interface APIs calls in an instant messaging server.

As illustrated in connections and messages inbound from an application program are received by the protocol adapter extension objects of the receiving application program that strip the data specific to the protocol adapter e.g. to perform peer authentication and send the message to the transfer agent . Once the data has been received the transfer agent raises an application event through the event dispatcher of the application manager of the receiving application program. The event dispatcher strips the first envelope and reads a first portion of the data including the workspace type and workspace identifier. Utilizing this data the associated workspace is located if available or created if unavailable. A second portion of the received data e.g. the remaining portion is delivered to the identified workspace . For example a software routine delivers the received envelope to the identified workspace . The workspace then strips the workspace specific data from the message envelope e.g. another first portion and reads in the data e.g. another second portion intended for the extension objects e.g. UI element contained within the workspace . The extension object type and identifier that is stored in each envelope e.g. as the first portion is utilized by the workspace to locate or create the extension object e.g. UI element . This process repeats until all received envelopes are stripped and data e.g. the second portion distributed to the appropriate extension objects. If a hierarchy of extension objects exists each receiving level of extension object strips the data encapsulated for that level. Incoming messages may include extension object identifiers to indicate the recipient extension objects. The extension object identifiers may cause the application manager to load the extension objects. In the example of UI element displays the received message as a UI response to the user.

A communication channel between application programs running on peer machines can be implemented through extension object providers so that additional extension objects can be added at a later stage to implement different means of establishing connections different means of authentication and different mechanisms for data transfer. As discussed above such extension objects are referred to as protocol adapters . Protocol adapters extend the design to handle different methods of establishing and authenticating connections different protocols of data transfer and to allow extension object providers that add UI functionality to determine their own transaction procedure to exchange functionality specific messages. For example the transaction procedure for messages to allow peers to draw on a shared whiteboard would be different from the procedure for file sharing messages.

As shown in the the transfer agent is the central framework object that handles all peer to peer communication. The transfer agent employs protocol adapters for creating and authenticating connections as well as for performing data input and output. For example when a message created by an extension provider in a workspace is received by the transfer agent to be sent to a specific user the transfer agent determines that the user is a buddy on a specific instant messaging IM server such as IM server A IM server B or IM server C . The transfer agent uses the appropriate extension object that can establish a peer to peer connection to the peer on the specific IM server. For example if the user is a buddy on IM server A then IM A connection provider is used as the protocol adapter for sending the message the user. Similarly if the user is a buddy on IM server B then IM B connection provider is used as the protocol adapter for sending the message the user. Further if the user is a buddy on IM server C then IM C connection provider is used as the protocol adapter for sending the message the user.

When the connection is established the transfer agent identifies the type of connection and loads the appropriate protocol adapter extension object to handle the data transfer. For example if the transfer agent determines the connection to be a transmission control protocol Internet protocol TCP IP socket connection e.g. communicating with an external socket API the transfer agent loads the appropriate extension object e.g. socket UI for handling data input and output on socket connections and uses it to handle the data transfer. The protocol used for the exchange of data is defined in the message body that was generated by the extension object provider that provided the specific functionality within the workspace .

If functionality is to be added later for the application program to communicate with users on another specific IM server an extension object provider could provide functionality through protocol adapters to establish connections to an application program on a peer machine if the peers are on the other specific IM server. Similarly if the type of connection is an HTTP network connection a different protocol adapter e.g. HTTP IO 912 could be instantiated e.g. plugged in to handle the data input and output to communicate with an external HTTP API 914.

The database in the application manager stores information on the registered extension object providers for peer to peer communication. For example such information associates the appropriate protocol adapters to be used for transferring messages via specific protocols. Optionally when extension object providers that provide a specific functionality create messages the extension object providers can specify recommended registered communication protocol adapters to be used for transferring those messages. Such recommended protocol adapters supersede any default protocol adapter used for communication or authentication.

The computer typically has at least some form of computer readable media. Computer readable media which include both volatile and nonvolatile media removable and non removable media may be any available medium that can be accessed by computer . By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. For example computer storage media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and that can be accessed by computer . Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. Those skilled in the art are familiar with the modulated data signal which has one or more of its characteristics set or changed in such a manner as to encode information in the signal. Wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media are examples of communication media. Combinations of the any of the above are also included within the scope of computer readable media.

The system memory includes computer storage media in the form of removable and or non removable volatile and or nonvolatile memory. In the illustrated embodiment system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. For example illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media. also shows a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive and magnetic disk drive and optical disk drive are typically connected to the system bus by a non volatile memory interface such as interface .

The drives or other mass storage devices and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into computer through input devices or user interface selection devices such as a keyboard and a pointing device e.g. a mouse trackball pen or touch pad . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are connected to processing unit through a user input interface that is coupled to system bus but may be connected by other interface and bus structures such as a parallel port game port or a Universal Serial Bus USB . A monitor or other type of display device is also connected to system bus via an interface such as a video interface . In addition to the monitor computers often include other peripheral output devices not shown such as a printer and speakers which may be connected through an output peripheral interface not shown .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and global computer networks e.g. the Internet .

When used in a local area networking environment computer is connected to the LAN through a network interface or adapter . When used in a wide area networking environment computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external is connected to system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to computer or portions thereof may be stored in a remote memory storage device not shown . By way of example and not limitation illustrates remote application programs as residing on the memory device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Generally the data processors of computer are programmed by means of instructions stored at different times in the various computer readable storage media of the computer. Programs and operating systems are typically distributed for example on floppy disks or CD ROMs. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory. The invention described herein includes these and other various types of computer readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described herein.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks. It is recognized however that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

Although described in connection with an exemplary computing system environment including computer the invention is operational with numerous other general purpose or special purpose computing system environments or configurations. The computing system environment is not intended to suggest any limitation as to the scope of use or functionality of the invention. Moreover the computing system environment should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

In operation computer executes computer executable instructions such as those illustrated in to dynamically configure an application program by integrating functionality provided by one or more extension objects with the application program during execution of the application program.

The following examples illustrate the invention. In one embodiment the application programs implementing the application program framework of the invention are communication centric peer to peer application programs. An application program on one machine communicates and exchanges data with a similar application program on another machine. The framework provides a common channel of communication that is leveraged by all extension object providers that extend the application program functionality. Though this embodiment is specific to a peer to peer application program the application program framework discovery of extension object providers and message formulation and routing are applicable to any type of application program.

In another example customers that design and manufacture audio digital signal processing devices with audio effect processing capabilities such as three dimensional process acceleration mixing digital encoding decoding or object acceleration could implement the application program framework of the invention for audio drivers to expose hardware features as individually controllable extension objects in an operating system environment. With more and more feature rich audio devices equipped with powerful digital signal processing capabilities the operating system audio stack implemented according to the invention allows a third party audio driver to expose these capabilities to users in a coordinated way so that these capabilities are available to all application programs on a computing device. An audio stack according to the invention allows a third party to separate its render function from other processing units e.g. mixing . In addition an audio stack according to the invention allows a third party driver to partition hardware features into individual extension objects . The application program framework of the invention provides more flexibility in the logical hardware feature partitions.

When introducing elements of the present invention or the embodiment s thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

In view of the above it will be seen that the several objects of the invention are achieved and other advantageous results attained.

As various changes could be made in the above constructions products and methods without departing from the scope of the invention it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

