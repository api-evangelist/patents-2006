---

title: Apparatus and method for dynamic instrumenting of code to minimize system perturbation
abstract: An apparatus and method are provided for the dynamic instrumentation of code to minimize system perturbation during tracing of the execution of the code. With the apparatus and method, “hot spots” in the execution of the code are dynamically determined during tracing of the execution of the code. These “hot spots” are dynamically instrumented, i.e. an event hook is inserted, to cause control to be passed to a handler that determines a caller of the “hot spot” method. The method that called the “hot spot” method, or “caller” method, is identified from a call stack and is dynamically instrumented for an appropriate metric so that the next time the calling method is executed, the dynamically inserted hooks are executed. The execution of the hooks in the caller method is continued for a predetermined period, e.g., number of invocations, to get an understanding of the caller method's characteristics. A list of callers of instrumented methods is maintained and used to determine one or more calling methods of the instrumented caller method. One or more of these calling methods may be instrumented and the hooks inserted in the instrumented caller method (called by the one or more calling methods), are removed. In this way, the call graph of the hot spots of a program execution is “walked up” and characterized over time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07823129&OS=07823129&RS=07823129
owner: International Business Machines Corporation
number: 07823129
owner_city: Armonk
owner_country: US
publication_date: 20060718
---
This application is a continuation of application Ser. No. 10 365 991 filed Feb. 13 2003 now U.S. Pat. No. 7 114 150.

The present invention is directed to an improved apparatus and method for performing traces of program execution. More specifically the present invention is directed to an apparatus and method for dynamic insertion of hooks into program code in order to trace the execution of the program code with minimal system perturbation.

In analyzing and enhancing performance of a data processing system and the applications executing within the data processing system it is helpful to know which software modules within a data processing system are using system resources. Effective management and enhancement of data processing systems requires knowing how and when various system resources are being used. Performance tools are used to monitor and examine a data processing system to determine resource consumption as various software applications are executing within the data processing system. For example a performance tool may identify the most frequently executed modules and instructions in a data processing system or may identify those modules which allocate the largest amount of memory or perform the most I O requests. Hardware performance tools may be built into the system or added at a later point in time.

Software performance tools also are useful in data processing systems such as personal computer systems which typically do not contain many if any built in hardware performance tools. One known software performance tool is a trace tool. A trace tool may use more than one technique to provide trace information that indicates execution flows for an executing program.

One technique keeps track of particular sequences of instructions by logging certain events as they occur so called event based profiling technique. For example a trace tool may log every entry into and every exit from a module subroutine method function or system component. Alternately a trace tool may log the requester and the amounts of memory allocated for each memory allocation request. Typically a time stamped record is produced for each such event. Corresponding pairs of records similar to entry exit records also are used to trace execution of arbitrary code segments starting and completing I O or data transmission and for many other events of interest.

Event based profiling tends to perturb the computing system and possibly invalidate results of the trace of the program execution. The perturbation of computing systems is due to the expense in handling too many events. That is because hooks which are used to generate events in event based profiling must be inserted into the code of the program before the workload of the program is executed it is not known where the hooks should be placed. That is since the trace tool or programmer does not know a priori the path of the workload all possible paths must be covered by the insertion of hooks. As a result many more hooks are encountered during the execution and trace of the program than may be necessary to obtaining an understanding of the program execution.

In some cases hooks in a program under trace may be turned on and off. However in such cases either all of the hooks are turned on or all of the hooks are turned off. As a result while the workload of the program can run unperturbed when not being traced when the events are turned on for tracing the perturbation begins and different performance results may be obtained by the trace than are actually experienced when the hooks are turned off.

In still other cases certain ones of the hooks in a program under trace may be turned on while others are turned off. For example only hooks on selected threads may be turned on while all other hooks are turned off. However with such systems there is considerable overhead in determining whether a hook is to be executed or not i.e. whether the hook is turned on or off that results in performance penalties.

Executing hooks frequently causes a significant amount of perturbation. For example Java profiling using the Java Virtual Machine Profiler Interface JVMPI for method entries and exits tends to slow applications from 2 to 30 times.

One approach to avoiding the overhead of execution of hooks during tracing of a program is to execute fewer hooks. However in this case all the possible paths of execution are not hooked and thus important paths of execution may be missed. That is if the number of hooks is reduced so is the information that is obtained during the trace.

Therefore it would be advantageous to have an apparatus and method for tracing the execution of a program in which the number of hooks executed during the trace is kept to a minimum without losing information regarding important paths of execution of the program. It would further be advantageous to have an apparatus and method for tracing the execution of a program in which hooks are inserted into and removed from the paths of execution of a program dynamically so as to maintain the number of hooks at a minimum level.

The present invention provides an apparatus and method for the dynamic instrumentation of code and removal of instrumented code to minimize system perturbation during tracing of the execution of the code. With the apparatus and method of the present invention hot spots in the execution of the code are dynamically determined during tracing of the execution of the code. These hot spot methods or routines hereafter collectively referred to as methods are dynamically instrumented i.e. an event hook is inserted to cause control to be passed to a handler that determines a caller of the hot spot method.

The method that called the hot spot method hereafter referred to as the caller method is identified from a call stack and is dynamically instrumented so that the next time the calling method is executed the dynamically inserted hooks are executed. The execution of the hooks in the caller method is continued for a predetermined period e.g. number of invocations to get an understanding of the caller method s characteristics.

The present invention maintains a list of callers of instrumented methods. When the predetermined period for executing inserted hooks in a caller method has expired the list of callers is used to determine one or more calling methods of the instrumented caller method. One or more of these calling methods in the call stack are then instrumented and the hooks inserted in the instrumented caller method called by the one or more calling methods are removed. In this way the call graph of the hot spots of a program execution is walked up and characterized over time.

Thus with the present invention the number of hooks that are executed during tracing of a program is minimized by reducing the number of hooks required to be inserted prior to the workload being executed and keeping the number of hooks that are dynamically inserted to a minimum. The number of hooks that are dynamically inserted is minimized by performing dynamic instrumentation based on detected hot spots and by removing inserted hooks from methods when one of its calling methods is instrumented.

These and other features and advantages of the present invention will be described in or will become apparent to those of ordinary skill in the art in view of the following detailed description of the preferred embodiments.

With reference now to the figures and in particular with reference to a pictorial representation of a distributed data processing system in which the present invention may be implemented is depicted. Distributed data processing system is a network of computers in which the present invention may be implemented. Distributed data processing system contains a network which is the medium used to provide communications links between various devices and computers connected together within distributed data processing system . Network may include permanent connections such as wire or fiber optic cables or temporary connections made through telephone connections.

In the depicted example a server is connected to network along with storage unit . In addition clients and also are connected to a network . These clients and may be for example personal computers or network computers. For purposes of this application a network computer is any computer coupled to a network which receives a program or other application from another computer coupled to the network. In the depicted example server provides data such as boot files operating system images and applications to clients . Clients and are clients to server . Distributed data processing system may include additional servers clients and other devices not shown. In the depicted example distributed data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial government educational and other computer systems that route data and messages. Of course distributed data processing system also may be implemented as a number of different types of networks such as for example an Intranet or a local area network.

With reference now to a block diagram of a data processing system which may be implemented as a server such as server in is depicted in accordance to the present invention. Data processing system may be a symmetric multiprocessor SMP system including a plurality of processors and connected to system bus . Alternatively a single processor system may be employed. Also connected to system bus is memory controller cache which provides an interface to local memory . I O Bus Bridge is connected to system bus and provides an interface to I O bus . Memory controller cache and I O Bus Bridge may be integrated as depicted.

Peripheral component interconnect PCI bus bridge connected to I O bus provides an interface to PCI local bus . A modem may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add in connectors. Communications links to network computers in may be provided through modem and network adapter connected to PCI local bus through add in boards.

Additional PCI bus bridges and provide interfaces for additional PCI buses and from which additional modems or network adapters may be supported. In this manner server allows connections to multiple network computers. A memory mapped graphics adapter and hard disk may also be connected to I O bus as depicted either directly or indirectly.

Those of ordinary skill in the art will appreciate that the hardware depicted in may vary. For example other peripheral devices such as optical disk drive and the like also may be used in addition or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention. The data processing system depicted in may be for example an IBM RISC System 6000 system a product of International Business Machines Corporation in Armonk N.Y. running the Advanced Interactive Executive AIX operating system.

With reference now to a block diagram of a data processing system in which the present invention may be implemented is illustrated. Data processing system is an example of a client computer. Data processing system employs a peripheral component interconnect PCI local bus architecture. Although the depicted example employs a PCI bus other bus architectures such as Micro Channel and ISA may be used. Processor and main memory are connected to PCI local bus through PCI Bridge . PCI Bridge also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus may be made through direct component interconnection or through add in boards.

In the depicted example local area network LAN adapter SCSI host bus adapter and expansion bus interface are connected to PCI local bus by direct component connection. In contrast audio adapter graphics adapter and audio video adapter A V are connected to PCI local bus by add in boards inserted into expansion slots. Expansion bus interface provides a connection for a keyboard and mouse adapter modem and additional memory . SCSI host bus adapter provides a connection for hard disk drive tape drive and CD ROM in the depicted example. Typical PCI local bus implementations will support three or four PCI expansion slots or add in connectors.

An operating system runs on processor and is used to coordinate and provide control of various components within data processing system in . The operating system may be a commercially available operating system such as Windows NT or Windows 2000 which are available from Microsoft Corporation .

An object oriented programming system such as Java may run in conjunction with the operating system and may provide calls to the operating system from Java programs or applications executing on data processing system . Instructions for the operating system the object oriented operating system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processor . Hard disk drives are often absent and memory is constrained when data processing system is used as a network client.

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. For example other peripheral devices such as optical disk drives and the like may be used in addition to or in place of the hardware depicted in . The depicted example is not meant to imply architectural limitations with respect to the present invention. For example the processes of the present invention may be applied to a multiprocessor data processing system.

The present invention provides a process and system for profiling e.g. tracing software applications. Although the present invention may operate on a variety of computer platforms and operating systems it may also operate within a Java runtime environment. Hence the present invention may operate in conjunction with a Java virtual machine JVM yet within the boundaries of a JVM as defined by Java standard specifications. In order to provide a context for the present invention portions of the operation of a JVM according to Java specifications are herein described.

With reference now to a block diagram is provided that illustrates the relationship of software components operating within a computer system that may implement the present invention. Java based system contains platform specific operating system that provides hardware and system support to software executing on a specific hardware platform. JVM is one software application that may execute in conjunction with the operating system. JVM provides a Java run time environment with the ability to execute Java application or applet which is a program servlet or software component written in the Java programming language. The computer system in which JVM operates may be similar to data processing system or computer described above. However JVM may be implemented in dedicated hardware on a so called Java chip Java on silicon or Java processor with an embedded picoJava core.

At the center of a Java run time environment is the JVM which supports all aspects of Java s environment including its architecture security features mobility across networks and platform independence.

The JVM is a virtual computer i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.

The JVM is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner Java is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems a compiler typically generates an architecture neutral file format the compiled code is executable on many processors given the presence of the Java run time system. The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Byte codes may be translated into native code by a just in time compiler or JIT.

A JVM must load class files and execute the bytecodes within them. The JVM contains a class loader which loads class files from an application and the class files from the Java application programming interfaces APIs which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.

One type of software based execution engine is a just in time compiler. With this type of execution the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs usually interpret bytecodes but JVMs may also use other techniques such as just in time compiling to execute bytecodes.

Interpreting code provides an additional benefit. Rather than instrumenting the Java source code the interpreter may be instrumented. Trace data may be generated via selected events and timers through the instrumented interpreter without modifying the source code. Profile instrumentation is discussed in more detail further below.

When an application is executed on a JVM that is implemented in software on a platform specific operating system a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language compiled to bytecodes and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.

With reference now to a block diagram of a JVM is depicted in accordance with a preferred embodiment of the present invention. JVM includes a class loader subsystem which is a mechanism for loading types such as classes and interfaces given fully qualified names. JVM also contains runtime data areas execution engine native method interface and memory management . Execution engine is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine may be for example Java interpreter or just in time compiler . Native method interface allows access to resources in the underlying operating system. Native method interface may be for example a Java native interface.

Runtime data areas contain native method stacks Java stacks PC registers method area and heap . These different data areas represent the organization of memory needed by JVM to execute a program.

Java stacks are used to store the state of Java method invocations. When a new thread is launched the JVM creates a new Java stack for the thread. The JVM performs only two operations directly on Java stacks it pushes and pops frames. A thread s Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables the parameters with which it was invoked its return value if any and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method the JVM pushes a new frame onto the Java stack of the thread. When the method completes the JVM pops the frame for that method and discards it. The JVM does not have any registers for holding intermediate values any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the Java instruction set is well defined for a variety of platform architectures.

PC registers are used to indicate the next instruction to be executed. Each instantiated thread gets its own pc register program counter and Java stack. If the thread is executing a JVM method the value of the pc register indicates the next instruction to execute. If the thread is executing a native method then the contents of the pc register are undefined.

Native method stacks store the state of invocations of native methods. The state of native method invocations is stored in an implementation dependent way in native method stacks registers or other implementation dependent memory areas. In some JVM implementations native method stacks and Java stacks are combined.

Method area contains class data while heap contains all instantiated objects. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap each of which are shared by all threads running inside the JVM. When the JVM loads a class file it parses information about a type from the binary data contained in the class file. It places this type information into the method area. Each time a class instance or array is created the memory for the new object is allocated from heap . JVM includes an instruction that allocates memory space within the memory for heap but includes no instruction for freeing that space within the memory. Memory management in the depicted example manages memory space within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

With reference now to a block diagram depicts components used to profile processes in a data processing system. A trace program is used to profile processes . Trace program may be used to record data upon the execution of a hook which is a specialized piece of code at a specific location in a routine or program in which other routines may be connected. Trace hooks are typically inserted for the purpose of debugging performance analysis or enhancing functionality. These trace hooks are employed to send trace data to trace program which stores the trace data in buffer . The trace data in buffer may be subsequently stored in a file for post processing or the trace data may be processed in real time.

With Java operating systems the present invention employs trace hooks that aid in identifying methods that may be used in processes . In addition since classes may be loaded and unloaded these changes may also be identified using trace data. This is especially relevant with network client data processing systems such as those that may operate under JavaOS since classes and jitted methods may be loaded and unloaded more frequently due to the constrained memory and role as a network client. Note that class load and unload information is also relevant in embedded application environments which tend to be memory constrained.

With reference now to a diagram depicts various phases in profiling the processes active in an operating system. Subject to memory constraints the generated trace output may be as long and as detailed as the analyst requires for the purpose of profiling a particular program.

An initialization phase is used to capture the state of the client machine at the time tracing is initiated. This trace initialization data includes trace records that identify all existing threads all loaded classes and all methods for the loaded classes. Records from trace data captured from hooks are written to indicate thread switches interrupts and loading and unloading of classes and jitted methods. Any class which is loaded has trace records that indicate the name of the class and its methods. In the depicted example four byte IDs are used as identifiers for threads classes and methods. These IDs are associated with names that have been output in the records. A record is written to indicate when all of the start up information has been written.

Next during the profiling phase trace records are written to a trace buffer or trace file. In the present invention a trace buffer may have a combination of types of records such as those that may originate from a trace hook executed in response to a particular type of event e.g. a method entry or method exit and those that may originate from a stack walking function executed in response to a timer interrupt e.g. a stack unwind record also called a call stack record.

For example the following process may occur during the profiling phase if the user of the profiling utility has requested sample based profiling information. Each time a particular type of timer interrupt occurs a trace record is written which indicates the system program counter. This system program counter may be used to identify the routine that is interrupted. In the depicted example a timer interrupt is used to initiate gathering of trace data. Of course other types of interrupts may be used other than timer interrupts. Interrupts based on a programmed performance monitor event or other types of periodic events may be employed.

In the post processing phase the data collected in the trace buffer is sent to a trace file for post processing. In one configuration the file may be sent to a server which determines the profile for the processes on the client machine. Of course depending on available resources the post processing also may be performed on the client machine. In post processing phase B trees and or hash tables may be employed to maintain names associated the records in the trace file to be processed. A hash table employs hashing to convert an identifier or a key meaningful to a user into a value for the location of the corresponding data in the table. While processing trace records the B trees and or hash tables are updated to reflect the current state of the client machine including newly loaded jitted code or unloaded code. Also in the post processing phase each trace record is processed in a serial manner. As soon as the indicator is encountered that all of the startup information has been processed trace records from trace hooks and trace records from timer interrupts are then processed. Timer interrupt information from the timer interrupt records are resolved with existing hash tables. In addition this information identifies the thread and function being executed. The data is stored in hash tables with a count identifying the number of timer tick occurrences associated with each way of looking at the data. After all of the trace records are processed the information is formatted for output in the form of a report.

Alternatively trace information may be processed on the fly so that trace data structures are maintained during the profiling phase. In other words while a profiling function such as a timer interrupt is executing rather than or in addition to writing trace records to a buffer or file the trace record information is processed to construct and maintain any appropriate data structures. In such an embodiment a determination is made as to whether an end condition has occurred step . If the end condition occurs i.e. stopping of the trace then the operation terminates. Otherwise the operation returns to step and continues the profiling of the program execution and post profiling operations to generate trace data structures.

For example during the processing of a timer interrupt during the profiling phase a determination could be made as to whether the code being interrupted is being interpreted by the Java interpreter. If the code being interrupted is interpreted the method ID of the method being interpreted may be placed in the trace record. In addition the name of the method may be obtained and placed in the appropriate B tree. Once the profiling phase has completed the data structures may contain all the information necessary for generating a profile report without the need for post processing of the trace file.

With reference now to a flowchart depicts a process used by a trace program for generating trace records from processes executing on a data processing system. provides further detail concerning the generation of trace records that were not described with respect to .

Trace records may be produced by the execution of small pieces of code called hooks . Hooks may be inserted in various ways into the code executed by processes including statically source code and dynamically through modification of a loaded executable . This process is employed after trace hooks have already been inserted into the process or processes of interest. The process begins by allocating a buffer step such as buffer in . Next in the depicted example trace hooks are turned on step and tracing of the processes on the system begins step . Trace data is received from the processes of interest step . This type of tracing may be performed during phases and or . This trace data is stored as trace records in the buffer step . A determination is made as to whether tracing has finished step . Tracing finishes when the trace buffer has been filled or the user stops tracing via a command and requests that the buffer contents be sent to file. If tracing has not finished the process returns to step as described above.

Otherwise when tracing is finished the buffer contents are sent to a file for post processing step . A report is then generated in post processing step with the process terminating thereafter.

With reference now to a flowchart depicts a process that may be used during an interrupt handler trace hook.

The process begins by obtaining a program counter step . Typically the program counter is available in one of the saved program stack areas. Thereafter a determination is made as to whether the code being interrupted is interpreted code step . This determination may be made by determining whether the program counter is within an address range for the interpreter used to interpret bytecodes.

If the code being interrupted is interpreted a method block address is obtained for the code being interpreted step . The method block address may be obtained for example from the information obtained by the sampling code of the program trace.

That is the Java profiler and sampling code are configured such that for each thread created the profiler obtains control via the JVMPI and requests a work area from the sampling code for placing the method block address for the thread. The sampler returns a pointer which is passed back to the profiler. The profiler then informs the Java Virtual Machine where to write the method block address when it starts interpreting the method. The profiler obtains control when the thread is destroyed and tells the sampling code that the thread work area is no longer required.

A trace record is then written step . The trace record is written by sending the trace information to a trace program such as trace program which generates trace records for post processing in the depicted example. This trace record is referred to as an interrupt record or an interrupt hook.

This type of trace may be performed during phase . Alternatively a similar process i.e. determining whether code that was interrupted is interpreted code may occur during post processing of a trace file.

A set of processes may be employed to obtain sample based profiling information. As applications execute the applications may be periodically interrupted in order to obtain information about the current runtime environment. This information may be written to a buffer or file for post processing or the information may be processed on the fly into data structures representing an ongoing history of the runtime environment. describe sample based profiling in more detail.

A sample based profiler may obtain information from the stack of an interrupted thread. The thread is interrupted by a software timer interrupt available in many operating systems. The user of the trace facility selects either the program counter option or the stack unwind option which may be accomplished by enabling one major code or another major code as described further below. This timer interrupt is employed to sample information from a call stack. By walking back up the call stack a complete call stack can be obtained for analysis. A stack walk may also be described as a stack unwind and the process of walking the stack may also be described as unwinding the stack. Each of these terms illustrates a different metaphor for the process. The process can be described as walking as the process must obtain and process the stack frames step by step or frame by frame. The process may also be described as unwinding as the process must obtain and process the stack frames that point to one another and these pointers and their information must be unwound through many pointer dereferences.

The stack unwind follows the sequence of functions method calls at the time of the interrupt. A call stack is an ordered list of routines plus offsets within routines i.e. modules functions methods etc. that have been entered during execution of a program. For example if routine A calls routine B and then routine B calls routine C while the processor is executing instructions in routine C the call stack is ABC. When control returns from routine C back to routine B the call stack is AB. For more compact presentation and ease of interpretation within a generated report the names of the routines are presented without any information about offsets. Offsets could be used for more detailed analysis of the execution of a program however offsets are not considered further herein.

Thus during timer interrupt processing or at post processing the generated sample based profile information reflects a sampling of call stacks not just leaves of the possible call stacks as in some program counter sampling techniques. A leaf is a node at the end of a branch i.e. a node that has no descendants. A descendant is a child of a parent node and a leaf is a node that has no children.

With reference now a diagram depicts the call stack containing stack frames. A stack is a region of reserved memory in which a program or programs store status data such as procedure and function call addresses passed parameters and sometimes local variables. A stack frame is a portion of a thread s stack that represents local storage arguments return addresses return values and local variables for a single function invocation. Every active thread of execution has a portion of system memory allocated for its stack space. A thread s stack consists of sequences of stack frames. The set of frames on a thread s stack represent the state of execution of that thread at any time. Since stack frames are typically interlinked e.g. each stack frame points to the previous stack frame it is often possible to trace back up the sequence of stack frames and develop the call stack . A call stack represents all not yet completed function calls in other words it reflects the function invocation sequence at any point in time.

Call stack includes information identifying the routine that is currently running the routine that invoked it and so on all the way up to the main program. Call stack includes a number of stack frames and . In the depicted example stack frame is at the top of call stack while stack frame is located at the bottom of call stack . The top of the call stack is also referred to as the root . The timer interrupt found in most operating systems is modified to obtain the program counter value pcv of the interrupted thread together with the pointer to the currently active stack frame for that thread. In the Intel architecture this is typically represented by the contents of registers EIP program counter and EBP pointer to stack frame . By accessing the currently active stack frame it is possible to take advantage of the typical stack frame linkage convention in order to chain all of the frames together. Part of the standard linkage convention also dictates that the function return address be placed just above the invoked function s stack frame this can be used to ascertain the address for the invoked function. While this discussion employs an Intel based architecture this example is not a restriction. Most architectures employ linkage conventions that can be similarly navigated by a modified profiling interrupt handler.

When a timer interrupt occurs the first parameter acquired is the program counter value. The next value is the pointer to the top of the current stack frame for the interrupted thread. In the depicted example this value would point to EBP in stack frame . In turn EBP points to EBP in stack frame which in turn points to EBP in stack frame . In turn this EBP points to EBP in stack frame . Within stack frames are EIPs which identify the calling routine s return address. The routines may be identified from these addresses. Thus routines are defined by collecting all of the return addresses by walking up or backwards through the stack.

With reference now to the an illustration of a call stack is depicted. A call stack such as call stack is obtained by walking the call stack. A call stack is obtained each time a periodic event such as for example a timer interrupt occurs. These call stacks may be stored as call stack unwind trace records also called merely stack unwinds within the trace file for post processing or may be processed on the fly while the program continues to execute.

In the depicted example call stack contains a pid which is the process identifier and a tid which is the thread identifier. Call stack also contains addresses addr addr . . . addrN . In this example addr represents the value of the program counter at the time of the interrupt. This address occurs somewhere within the scope of the interrupted function. addr represents an address within the process that called the function that was interrupted. For Intel processor based data processing systems it represents the return address for that call decrementing that value by 4 results in the address of the actual call also known as the call site. This corresponds with EIP in addrN is the top of the call stack EIP . The call stack that would be returned if the timer interrupt interrupted the thread whose call stack state is depicted in would consist of a pid which is the process id of the interrupted thread a tid which is the thread id for the interrupted thread a pcv which is a program counter value not shown on for the interrupted thread EIP EIP EIP and EIP . In terms of pcv addr EIP addr EIP addr EIP addr EIP addr.

With reference now to a diagram of a program execution sequence along with the state of the call stack at each function entry exit point is provided. The illustration shows entries and exits occurring at regular time intervals but this is only a simplification for the illustration. If each function A B C and X in the figure were instrumented with entry exit event hooks then complete accounting of the time spent within and below each function would be readily obtained. Note in that at time the executing thread is in routine C. The call stack at time is C. At time routine C calls routine A and the call stack becomes CA and so on. It should be noted that the call stack in is a reconstructed call stack that is generated by processing the event based trace records in a trace file to follow such events as method entries and method exits.

It should be appreciated that the entire call stack is not always ascertainable. That is it may be difficult to determine the caller of an interrupted routine at the time of the interruption because the context of the interrupt handler and the context of the routine being sampled are different. Trying to follow the stack of the interrupted routine may require that memory pages be read in. This may be a problem while the processor is executing at an interrupt level because other interrupts required for disk access completion may be inhibited and cannot complete. In addition not all programs follow the coding conventions required to make the call stack traversal correct.

The present invention provides a mechanism for dynamic instrumentation of code in which the entire call stack need not be known. In fact the dynamic instrumentation mechanisms of the present invention operate on one level of the call stack at a time. A hot spot method or routine is first identified and instrumented to pass control to an interrupt handler that identifies a caller of the hot spot method or routine. The caller is then instrumented. Thus the call stack need not be known and a mechanism is provided for identifying the caller of a method or routine one level up in the call stack.

As previously mentioned the present invention provides an apparatus and method for the dynamic instrumentation of code to minimize system perturbation during tracing of the execution of the code. In a preferred embodiment the present invention operates as a daemon process that executes in a background of a trace of the execution of a program. In this way as the trace is being performed trace information in a trace buffer or trace file may be analyzed by the present invention to identify hot spots callers of hot spots and instrument these hot spots and callers.

With the apparatus and method of the present invention hot spots in the execution of the code are dynamically determined during tracing of the execution of the code. A hot spot in the execution of code is a portion of code that is either executed a many times compared to other portions of the code a portion of code that consumes a large amount of processing cycles compared to other portions of code or the like. Hot spot detection is generally known in the art and any known or later developed mechanism for the identification of hot spots may be used without departing from the spirit and scope of the present invention.

For example in a preferred embodiment the Tprof mechanism in which program counter sampling is performed may be used to identify hot spots in the execution of a program. With the Tprof or other sampling based tracing mechanisms for tracing the execution of a program when a sample occurs the instrumentation software identifies the address of the interrupted routine. The address is used to access a table where the count for each tick at that address is incremented. Hash tables may be used to maintain the table of addresses. In some cases where the range of addresses tends to be small an index into a table may be constructed from the address. For each address identified by sampling a count of occurrences at those addresses is maintained. It is this count of occurrences that is used to identify hot spots in the execution of the program.

After sampling has been in process for a predetermined period of time the dynamic instrumentation facility reads the tables and converts the addresses to the symbolic names of the functions associated with the addresses. An example mechanism for the conversion of addresses to symbolic names is described in commonly assigned and co pending U.S. patent application Ser. No. 09 613 101 entitled Apparatus and Method for Creating an Indexed Database of Symbolic Data for Use with Trace Data of a Computer Program. The basic approach to obtaining symbolic names from addresses is to capture the information related to all loaded modules at start up time and to continue updating this information as new loads take place.

The dynamic support i.e. updating of the loaded module information is especially important with JITted code as such code tends to be dynamic. For JITted code as methods are JITted a profiler attached to the JVM receives events as each method is JITted via the Java Virtual Machine Profiling Interface JVMPI which identifies the method block load address and length of the method. Although methods are often reJITed the space for the old methods does not tend to be reused until the entire class is unloaded. For this reason the last method identified for each address range is used to resolve the mapping from address to symbolic name. For executables the process and address can be used to identify the executable and displacement within the executable. The address to symbolic name mapping facility then reads the executable or the symbolic information related to the executable to determine the function being executed at that address. By mapping the addresses to processes modules functions the dynamic instrumentation facility now has a table of functions with counts of number of occurrences of samples in each function.

If the percentage of occurrences in a function or set of functions compared to other functions reaches a predetermined threshold then the functions are deemed candidates for the dynamic instrumentation of the present invention i.e. the functions are deemed to be hot spots. If there are no functions that reach the desired percentages then some predetermined number of functions that have the highest counts can be used for the dynamic instrumentation.

When a hot spot is detected using a hot spot detection mechanism such as the Tprof mechanism noted above a caller of the hot spot method or routine hereafter only referred to as a method for simplicity is identified and instrumented for characteristics of interest. The identification of the caller of the hot spot method may be performed in different ways depending on the type of code e.g. native jitted or interpreted code of the hot spot method.

For native or jitted code the hot spot method is simply instrumented by the insertion of a hook that transfers control to a handler that identifies the caller of the method in which the hot spot is detected. The inserting of a hook of this type may be performed for example by patching in a call to a handler routine.

One approach to instrumenting code i.e. insertion of a hook into code that may be used by the dynamic instrumentation facility of the present invention is to maintain a table which represents the address and code that is replaced for each function being modified. The code at the entry to the function is copied to the table identifying the address of the code being modified and a copy of the code that is being replaced. The code is then replaced by an instruction that causes a break or interrupt for example an int 3 on Intel x86 processors and a break instruction on IA64 processors .

When the code is executed the break or exception handler determines that the occurrence of the exception is due to inserted code the address of where the break occurred is available to the handler . The handler then determines which code was being executed restores the code and uses a single step handler to execute the restored instruction. The single step handler then determines that the code of interest was just restored and then puts back the int 3 or other code so that the next time it is executed the exception will occur.

Another approach is to simply modify the code to jump to a handler that is aware of the code that is modified and causes the replaced instruction to be executed. Such an approach may require careful modification of relative addresses if the instruction being replaced is not directly relocatable.

When the hook is executed during execution of this hot spot method control is passed to the handler method that performs the functions of identifying the caller of the hot spot method. When the dynamic instrumentation facility obtains control from the hooked or changed code it can determine the caller by a variety of means. If it obtains control at the entry then the call stack will have the return address at a known displacement within the call stack. In other processor architectures the caller may be in a register. If the code is badly behaved it is possible that the caller may be incorrect. However even in this case the caller of the caller will most likely be identified and this should give acceptable results.

The dynamic instrumentation facility may also determine the amount of time that the function has been executing. It may do this by changing the returns exits using the same technique as with the entries or it may do this by modifying the return information so that the dynamic instrumentation facility gets control when the return occurs and thereby can record the desired information. Of course the techniques similar to the instrumentation at entry can be used to ensure that the dynamic instrumentation returns control to the real caller after it has completed its processing of the return.

If the code of the hot spot method is interpreted the information about the hot spot e.g. the thread identifier and method block address may be passed to a Java profiler routine connected to the Java Virtual Machine JVM . The JVM may enable an instrumented JVM to selectively cause the class method of the hot spot to call out to the Java profiler on entry to the method. The profiler can then determine the caller of the method by requesting the caller information from a driver application that investigates the call stack to identify a caller of the hot spot method.

Alternatively if the code of the hot spot method is interpreted the byte codes of the method may be changed to insert the necessary instrumentation e.g. a hook to a method that identifies the caller of the hot spot method from the call stack. With such an implementation at the time a class is loaded the bytecode of the class is changed to insert the hook. This approach requires the instrumentation to occur on a separate run or runs.

Alternatively the instrumentation may be inserted but not turned on at the time the class is loaded. The instrumented code may be instrumented such that a flag is set or reset to control the firing of the hook. A different flag may be used for each method so that the control of firing the hook is at the method level. The update of the flags are done via native methods by the profiler. Thus the profiler dynamically changes the values of the flags as determined by the instrumentation facility.

Whether the native or jitted code is instrumented by patching a hook into the code interpreted code is instrumented by use of a profiler or changing of byte code or the like the method that called the hot spot method hereafter referred to as the caller method is identified and is dynamically instrumented For an appropriate metric or characteristic e.g. wall clock time cycles number of instructions or the like. The next time the calling method is executed the dynamically inserted hooks are executed.

In addition once the caller method is instrumented in this fashion if a hook was inserted into the hot spot method to identify this caller method this hook may be removed in order to maintain the number of hooks inserted in the code at a minimum. The removal of a hook is generally known in the art. For example a hook may be removed from code by restoring the original code and removing the entries from the instrumentation facilities or in the case of Java by turning off the flags that control the firing of the hooks.

The execution of the hooks in the caller method may be continued for a predetermined period to get an understanding of the caller method s characteristics. The predetermined period may be for example a predetermined number of invocations of the caller method a predetermined number of clock cycles a predetermined wall clock time or the like. When this predetermined period is expired the call stack is walked up to the next level of caller method and the caller of the currently instrumented caller method is then instrumented.

In other words the present invention maintains a list of callers of instrumented methods. When the predetermined period for executing inserted hooks in a caller method has expired the list of callers is read and used to determine one or more calling methods of the instrumented caller method. One or more of these calling methods are then instrumented by the insertion of hooks to measure given metrics. In addition the hooks inserted in the instrumented caller method called by the one or more calling methods are removed. In this way the call stack is walked up a single level at a time and instrumented to identify characteristics of the execution of a program over time. As a result it is not necessary to instrument an entire call stack to obtain the trace information of interest.

In addition with the present invention the number of hooks that are executed during tracing of a program is minimized by reducing the number of hooks required to be inserted prior to the workload being executed and keeping the number of hooks that are dynamically inserted to a minimum. The number of hooks that are dynamically inserted is minimized by performing dynamic instrumentation based on detected hot spots and by removing inserted hooks from methods when one of its calling methods is instrumented.

With the present invention a trace tool is used to trace the execution of a program. The dynamic instrumentation facility is part of this trace tool and performs the functions of hot spot detection. When a hot spot is detected a determination is made as to whether the hot spot is native or jitted code or interpreted code. If it is determined that the hot spot method is native or jitted code the dynamic instrumentation facility patches a hook into the hot spot method that passes control to a handler routine.

The handler routine determines a caller of the hot spot method from the native stack and passes this information back to the dynamic instrumentation facility . The dynamic instrumentation facility then instruments the caller method by for example patching in hooks to routines that measure metrics or characteristics of the execution of the instrumented method.

If the hot spot method is interpreted code then the dynamic instrumentation facility passes control to the JVM which is instrumented to cause the hot spot method to call the profiler which determines the caller of the hot spot method using the driver . The driver searches the Java stack to identify the caller method of the hot spot method and returns this information to the profiler . The profiler then returns this information to the dynamic instrumentation facility via the JVM . The dynamic instrumentation facility then instruments the caller method.

In addition to hot spot detection and instrumentation of callers of hot spot methods the dynamic instrumentation facility also monitors the periods which an instrumented caller method has executed hooks. For example the dynamic instrumentation facility may store in the caller list data structure an identification of caller methods an identification of whether the caller method has been dynamically instrumented as well as a count of the number of times the caller method s hooks have been executed. The count may be compared to a predetermined threshold to determine if the metrics measured by the routines associated with the hooks have been measured for a sufficient period so as to obtain information about the execution characteristics of the caller method.

If the predetermined threshold is met the caller list data structure is consulted by the dynamic instrumentation facility to identify one or more calling methods of the instrumented caller method. One or more of these calling methods are then instrumented and the hooks in the currently instrumented caller method are removed by the dynamic instrumentation facility . The hooks may be removed by consulting the tables generated during the insertion of the hooks discussed previously to perform a reverse operation to restore the code to its original state.

As shown in the dynamic instrumentation facility includes a controller a JVM interface a hot spot detection mechanism an instrumentation mechanism a caller list data structure interface and a data collection and storage mechanism . The elements are in communication with one another via a control data signal bus . Although a bus architecture is shown in the present invention is not limited to such and any architecture may be used that facilitates communication of control data signals between the elements without departing from the spirit and scope of the present invention.

The controller controls the overall operation of the dynamic instrumentation facility and orchestrates the operation of the other elements . The JVM interface provides an interface to the Java Virtual Machine. The hot spot detection mechanism performs hot spot detection using any of a number of different hot spot detection algorithms.

When the hot spot detection mechanism detects the presence of a hot spot in the execution of a program under trace the hot spot detection mechanism informs the instrumentation mechanism of the existence of the hot spot and the identity of the method in which the hot spot is detected. The instrumentation mechanism then determines the caller method of the hot spot method using one of the various techniques discussed above based on the type of code native jitted or interpreted for the hot spot method. The instrumentation mechanism then instruments the caller method for monitoring purposes and adds an entry to the caller list data structure via the caller list data structure interface for the caller method.

This entry may include for example an identification of the caller method an indication that the caller method has been instrumented and a count of the number of times that the caller method has been executed following instrumentation of the caller method. The entry may further include an identification of methods called by the caller method and methods that call the caller method. For example the caller list data structure may take the form of a linked list or doubly linked list.

The dynamic instrumentation facility or other portions of the trace tool performs a trace of the program execution and collect data on the metrics of interest for characterizing the execution of the program. This data collection and storage is performed by the data collection and storage mechanism . As each instrumented method is executed during the trace the count for the method in the caller list data structure is incremented.

The instrumentation mechanism monitors the counts for each of the caller methods identified in the caller list data structure to determine if any count exceeds a predetermined threshold. If so the instrumentation mechanism reads the caller list data structure via the caller list data structure interface to determine the identity of one or more calling methods of the caller method if any. This may be done for example by looking at the identifications of the methods that call the caller method or following the links in the linked list to the next calling method up the chain of links. It should be noted that the identification of a calling method of the caller method only traverses one level in the call stack and does not require identification of each calling method in the chain of method calls used to reach the caller method.

One or more of the calling methods are instrumented by the instrumentation mechanism and the instrumentation that was added to the caller method is removed. In this way the number of inserted hooks is maintained at a minimum level.

If the hot spot method code is not native or jitted the method information is passed to an instrumented JVM and ultimately to a profiler step . The profiler determines the caller of the hot spot method e.g. by using a driver that queries a Java stack or call stack to identify the caller method of the hot spot method step . Thereafter entry exit hooks that monitor a given metric are inserted into the caller method step . The metrics are then measured using the inserted entry exit hooks in order to identify characteristics of the execution of the program step .

It is important to note that while the present invention has been described in the context of a fully functioning data processing system those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable type media such as a floppy disk a hard disk drive a RAM CD ROMs DVD ROMs and transmission type media such as digital and analog communications links wired or wireless communications links using transmission forms such as for example radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

