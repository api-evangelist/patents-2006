---

title: Dynamic generation and implementation of globalization verification testing for user interface controls
abstract: A machine implemented technique for performing dynamic globalization verification testing in a software user interface includes identifying one or more user interface controls in the software user interface having text strings that have been pseudo translated, generating one or more applicable test cases that test for display defects stemming from the pseudo translations, executing the test cases, and logging defects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07752501&OS=07752501&RS=07752501
owner: International Business Machines Corporation
number: 07752501
owner_city: Armonk
owner_country: US
publication_date: 20060727
---
The present invention relates to software globalization verification testing. More particularly the invention is directed to the automation of globalization verification testing procedures.

By way of background globalization verification testing or GVT is a software internationalization procedure for verifying the integrity of software user interface controls whose text strings require translation from one language to another. For example a user interface whose controls are initially developed to display English text may need to be translated to non English languages for persons who do not speak English. The translation process frequently changes a control s text string formatting because the target language will invariably use a different number of words and or characters to convey the same information. A user interface control that displays the seven character word Welcome in English will thus become Willkommen in German and Bienvenue in French.

User interface controls whose text strings may require translation include such entities as frames windows buttons tabs labels tool bars menus text entry forms dialog boxes error status messages tool tips group boxes tables and other elements. Because such controls and their text strings are rendered using predefined geometry and character map information the fact that a control may properly display a text string in one language does not mean that the same control will correctly display the text string after it has been translated to another language. Thus text string translation can and often will result in formatting problems such as text corruption concatenation normalization truncation etc.

In the past text string translation required that each user interface control in a software program under test be exposed inspected for defects and verified for each translated language. This is a laborious and time consuming task. GVT was developed to streamline the translation verification process. As part of GVT instead of testing user interface controls after full translation to another language a procedure known as mock or pseudo translation is performed. The pseudo translations are checked and verified to identify formatting problems that are likely to surface when the actual text string translations are subsequently performed. Only after pseudo translation testing is completed and all problems are resolved will the text strings be fully translated into different languages.

Pseudo translation preserves the readability of the original text string but adds additional formatting according to the anticipated size of the text string following translation to another language. According to one known technique the original text is appended or prepended with additional placeholder characters such as tildes and the entire string is bracketed to signify that it has been pseudo translated. The text string Enter appearing on a button style user interface control may thus be pseudo translated to Enter if it is anticipated that Enter a five character word in English will be translated into another language that requires twenty characters. Another method of pseudo translation involves changing single byte character codes to double byte character codes which are used to represent characters in many non Western languages.

An advantage of a pseudo translation is that a person who speaks the same language used by the text string author e.g. English can perform GVT without having to learn another language. The GVT function may thus be performed relatively early in the development cycle by the software developer or a co worker of the developer instead of shipping the product to another site possibly in a foreign country for verification after actual translation. This allows formatting errors detected by GVT to be corrected more quickly and at less cost.

Although GVT is an improvement over previous translation verification techniques based on actual translations it is still a time consuming repetitive task. Among other things GVT requires the manual creation of test cases to check for different kinds of formatting errors according to the user interface control types being evaluated. For example some user interface control types may need to be checked for text normalization concatenation and corruption while other control types need to be checked for each of these errors plus truncation. Creating a set of test cases for each user interface control of a software program requires a tester or engineer who is familiar with both GVT testing and the product that has been translated. This process takes considerable time and most of the effort involves tedious cut and paste operations insofar as similar tests are usually run on dozens if not hundreds of user interface controls.

Once a set of GVT test cases has been defined the test cases must be implemented. Again this is a manual process in which a human tester exposes and inspects each user interface control individually according to the subset of test cases defined for that control. The process is time consuming and subject to human error. GVT additionally requires that all defects detected while running test cases be documented. Documenting a defect requires that the defect be verified by reproducing it. The defect must then be logged e.g. in defect tracking software along with verification information such as the steps required to reproduce the defect and a screenshot showing the defect. Defect documentation may also involve information that helps the software developer fix the problem.

It is to improvements in the field of software GVT that the present invention is directed. What is particularly needed is an improved GVT technique that eliminates the time expense and error associated with manually generating executing and documenting GVT test cases on multiple user interface controls and which introduces a greater degree of automation into the GVT process.

The foregoing problems are solved and an advance in the art is obtained by a novel method system computer program product and automated service for performing dynamic globalization verification testing of a software user interface. According to the inventive technique which is machine implemented one or more user interface controls in the software user interface having text strings that have been pseudo translated are identified. One or more applicable test cases are generated that test for display defects stemming from the pseudo translations. The test cases are executed. Defects discovered by executing the test cases are logged.

According to exemplary embodiments disclosed herein an identification of the user interface controls may be initiated by a software program that implements the software user interface. Alternatively the identification may be obtained by querying the software program. During identification the user interface controls may be exposed as necessary in order to generate user interface control screen shots. The test cases may be generated by categorizing the user interface controls by type and applying rules that associate the test cases to the user interface control types. At least some of the test cases may be executed by comparing pseudo translated strings in the user interface controls to defined string specifications. The test cases may be executed recursively on child user interface controls associated with parent user interface controls. Logging may include linking screenshots of user interface controls associated with defects and identifying test cases whose execution resulted in discovery of the defects. A report may be generated based on the logging.

According to a further exemplary embodiment disclosed herein dynamic globalization verification testing of a software user interface may be implemented by a test engine operating in conjunction with an automated functional testing program. The automated testing program is adapted to read a test script identifying one or more user interface controls in the user interface having text strings that have been pseudo translated. The automated testing program queries a software program that implements the user interface to obtain information that allows it to create test objects corresponding to the user interface controls. The automated testing program passes the test objects to the test engine for testing. The test engine utilizes the test objects to generate one or more applicable test cases that test for display defects stemming from the pseudo translations. The test engine executes the test cases and returns control to the automated testing program. The automated testing program logs defects discovered by executing the test cases and generates a test report.

According to a still further exemplary embodiment disclosed herein dynamic globalization verification testing of a software user interface may be provided by an automated system that directly interacts with a software program that implements the user interface. The automated system is called by the software program and is provided with an identification of one or more user interface controls in the user interface having text strings that have been pseudo translated. The automated system may be called by the software program in response to manipulation of one of the user interface controls. The automated system generates one or more applicable test cases that test for display defects stemming from the pseudo translations then executes the test cases. The automated system logs defects discovered by executing the test cases and generates a test report. The automated system then returns control to the software program.

Turning now to the Drawing figures wherein like reference numerals indicate like components in all of the several views illustrates an exemplary system adapted to perform dynamic globalization verification testing in accordance with the invention. Also shown in is a software program under test 4 that defines various user interface controls for display in a user interface in order to control software program operations. One such user interface control A is shown in the user interface . The user interface control A is a panel type control that contains a number of child controls such as text boxes buttons and tabs. As will be described in more detail below in connection with the user interface control A and its children have associated text strings that have been pseudo translated by introducing formatting information and double byte characters.

The software under test 4 may be any software that displays user interface control components and may be written using any conventional software language. Examples include but are not limited to Java registered trademark of Sun Microsystems Inc. byte code that defines the user interface controls as Java objects Microsoft registered trademark of Microsoft Corporation Visual Studio .NET code that defines the user interface controls as .NET objects and web device code that defines the user interface controls using HTML Hypertext Transport Markup Language specifications.

The dynamic testing system utilizes functional components and for performing globalization verification testing of the user interface . Details of the operations performed by each component will be found in the discussion below of . Exemplary alternative implementations of these components are described below with reference to . By way of introduction the components and may be summarized as follows 

As described in more detail below in connection with the foregoing components of the dynamic testing system may be implemented using any suitable machine implemented logic including software written in any suitable programming language. The logic may be built upon existing automated functional testing software that is capable of interacting with the software under test 4 or it may be implemented to operate directly with the software under test 4 for example as a callable routine that is invoked by the software under test during manipulation of the user interface controls .

With additional reference now to globalization verification testing as performed by the dynamic testing system of begins with step in which the user interface control identifier identifies at least one of the user interface controls of the software under test 4 that has been pseudo translated. For convenience the first user interface control that is identified may be a high level container object such as the frame A of or any other control that serves as a container for other controls such as buttons labels and menus. In the ensuing discussion it is assumed that the user interface control A is the initial control being tested by the automated system . Step will then further include identifying all children of the parent control A for recursive testing of such controls. The identifications of the parent user interface control A and its children obtained in step may be stored for subsequent testing using any suitable storage technique such as creating an array not shown containing identifications of the parent control and all child controls to be tested.

As described in more detail below in connection with there are several techniques that may be used to pass an identification of the user interface controls from the software under test 4 to the dynamic testing system . These techniques include the user interface control identifier querying the software under test 4 for user interface control information with the query format being dependent on the manner in which the software under test defines its user interface objects see discussion of below . An advantage of this approach is that the software under test 4 does need to be modified in order to exchange information with the dynamic testing system . An alternative approach is to modify the software under test 4 by adding software hooks that pass user interface control objects to the dynamic testing system in response to user interface events see discussion of below . Opening or closing the user interface control A e.g. using a mouse input device are examples of such events.

Step of represents recursive logic that allows the dynamic testing system to recursively test user interface controls that are children of the parent control A and thereby ensure that testing of the user interface is comprehensive and complete.

In step the test case generator categorizes the current user interface control according to its type e.g. textbox label etc. . For standard user interface controls this information can be determined from the user interface control identification obtained in step insofar as the software under test 4 will normally define its user interface controls by type. For example if the software under test 4 is a Java program the user interface controls may be defined using Java Java Foundation classes e.g. the JButton class for button controls . In other cases the user interface control may be a user created custom class. In that event the class type can be categorized based on class parents or the available methods provided by the custom class.

In step the test case generator exposes the current user interface control according to its type and generates a screen shot thereof. Exposing a user interface control may include actions such as switching to an appropriate tab page expanding a menu scrolling a panel or in the case of a combination or list control selecting the longest choice. The test case generator can expose the current user interface control by issuing conventional input device control commands that cause an input device e.g. mouse keyboard etc. to perform the necessary input operations within the user interface . Alternatively the test case generator may issue input device simulation commands e.g. simulated mouse clicks keyboard presses etc. to an API Application Programming Interface of the software under test 4 if such is provided. A screen shot of the exposed user interface control may be taken by issuing a screen shot command to lower level software such as a Java Virtual Machine or other application an operating system or a combination of application and operating system support functions. To aid in test result analysis the user interface control can be marked as by modifying the screen shot to draw a box around the control. Alternatively the user interface control could be marked as by changing its background color. However this requires modification of the software under test 4 and needs to be performed prior to taking the screen shot.

In step the test case generator generates one or more test cases based on the determined user interface control type. The test cases are designed to test for display defects stemming from pseudo translation. Test case generation may be handled by consulting the rule set which contains rules that associate different user interface control types with one or more test cases. For example if the user interface control contains permanently displayed text the test s run on the control may be different than if the control contains a tool tip that is temporarily exposed in response to a mouse over event and so on. It will be appreciated that innumerable associations may be created between user interface control types and GVT test sets depending on design requirements. As such no attempt is made herein to catalog any particular rule set associations. Suffice it to state that the rule set will normally be created by an experienced quality assurance engineer either manually or perhaps partially by way of automatic generation from pseudo translation rules used to translate the user interface control text strings. Insofar as it may be desirable to modify the rule set from the time to time it can be maintained separately from the dynamic testing system e.g. in a text file as illustrated in . Alternatively the rule set could be coded into the dynamic testing system itself.

In step the test case executor performs each GVT test determined from step on the current user interface control in order to detect display defects stemming from pseudo translation. Without limitation the following enumerated tests 1 10 are examples of the kind of testing that may be performed according to the type of user interface control being evaluated 

Test 1 Verify that control text is pseudo translated. This can be done by comparing control text to a regular expression such as GS . Ii A Z that searches for elements like brackets and tildes and other pseudo translation formatting elements. Test 2 Verify that control text is not corrupted. This can be done by comparing control text to a regular expression such as . . . u 0 9a fA F 4 . This expression looks for frequent use of the ASCII character F which is often substituted for unrecognized characters. The expression also looks for hexadecimal numbers following a format such as uxxxx where each x represents a hexadecimal digit 0 F and uxxxx should have been converted to an appropriate single character. Test 3 Verify that pseudo translated control text is not concatenated. This can be done by verifying that all text is contained within the pseudo translated string bookends. Assuming the bookends to be square brackets and cases a and b below would be acceptable but c d and e would fail 

If any test applied to the current user interface control detects a defect that defect will be logged in step by the defect logger . The log entry may include a link to the screen shot taken in step test case information and information specific to any failures. If desired log entries may also be created for tests that complete successfully such that the log will have pass fail entries.

Following step and the completion of testing of the current user interface control e.g. the panel control A processing may return to step in order to recursively test all children of that control. Steps will be repeated for each such control. After all child user interface controls have been tested a test report is generated in step by the report generator . The test report may be used for correcting the defects found in the tested user interface control s and also for future testing of other user interface controls. One example of the latter would be to use the test report to identify false positives so that user interface control types improperly identified as containing defects could either be omitted from future tests or their test results could be ignored. The test report also provides the ability to export the generated test cases for importation into other software testing tools such as a manual GVT tool.

Turning now to processing of the user interface control A and its child controls will be described in order to illustrate how the dynamic testing system is able to search for and detect various translation defects therein. shows a screen shot of the user interface control A taken in step . A box has been drawn around the control A which represents the entire window panel shown in the figure to identify it to persons who may subsequently consult the test report generated in step . The user interface control A represents a generic panel control containing text representing English language spellings of Japanese names. This panel and all of its child controls have undergone a pseudo translation process in order to determine whether the control text can be translated into Japanese language characters without error. The pseudo translation scheme converts each English character from single byte format to double byte format. Moreover the English language text is prepended with the characters G and and appended with a series of tildes followed by the Turkish capital the Turkish lower case i and a vertical bar . Brackets are also placed around each text string. It will thus be seen that the bold faced upper left hand text string which initially read Endo Shusaku has been pseudo translated to G Endo Shusaku i . The other text strings of the user interface control A have undergone similar pseudo translations.

Turning now to an exemplary implementation of the dynamic testing system is shown in which the system is built by extending an existing automated software functional testing program . One exemplary product that may be used to provide the automated testing program is the IBM Rational Functional Tester 6.1 IBM and Rational are registered trademarks of International Business Machines Corporation . This product is an automated functional and regression testing tool for testers and user interface developers. The product currently supports Java Microsoft Visual Studio .NET and web based HTML applications. The product is capable of recording user interactions with user interface controls and creating a test script that when activated reproduces those actions in the user interface being tested. Test scripts can also be written manually to perform any desired data manipulation and environment configuration within the target user interface.

One such test script is shown by reference numeral in . It may be written to provide the functions of the user interface control identifier of . In particular the test script directs the automated testing program to query the software under test 4 via a conventional interprocess communication mechanism. This query requests the software under test 4 to provide object information corresponding to the user interface controls . The automated testing program uses the object information to create corresponding test objects that are to undergo dynamic testing in accordance with the invention. Identifications of the user interface controls whose object information is required may be manually written into the test script . Alternatively they could be inserted automatically by recording user selections during interaction with the user interface . The functionality required to query the software under test 4 obtain the test object information and generate the test objects is currently available in functional testing products such as the IBM Rational Functional Tester 6.1. Also included in this functionality are mechanisms for creating test objects corresponding to child user interface controls of a known parent user interface control. No modifications of the software under test 4 are required.

The test script may be further written to pass test objects from the automated testing program to the test case generator and the test case executor which are collectively shown in to provide a test engine . The test engine may be written as a library routine that is called by the automated testing program when directed to do so by the test script . The test engine could also be implemented as an executable program running in a separate process or thread. After being called the test engine will implement the processing of steps and on the test object passed with the call. The test engine then uses the functions methods associated with the test object to recursively obtain child test objects that are descendent from the initial test object repeating steps and for each child object.

Whenever the test case generator needs to expose a user interface control it can request the automated testing program to manipulate the control using conventional input device control commands that cause an input device e.g. mouse keyboard etc. to perform the necessary input operations on the target user interface control within the user interface . Alternatively the automated testing program could make API calls to the software under test 4 to simulate input device actions. Both types of functionality are currently available in automated testing products such as the IBM Rational Functional Tester 6.1.

Whenever the test case generator needs to generate a screen shot of a user interface control it may utilize an existing screen shot capture support service provided by an application e.g. a Java Virtual Machine an operating system or both. The screen shot capture support service will return a reference to a file containing the captured screen shot. The file can then be modified to add additional graphical artifacts such as boxes to help identify the user interface control being captured.

Whenever defect logging is required the test engine can utilize the existing logging functions of the automated testing program . The logging request can be implemented using any suitable technique such as the test engine registering a logging request callback for processing by the automated testing program after the test engine returns control. The automated testing program may also be used for report generation.

Turning now to an exemplary implementation of the dynamic testing system is shown in which the system is built as a stand alone library routine or executable that is called by the software under test 4. This implementation requires modification of the software under test 4 as by providing a hook that calls the dynamic testing system whenever a user interface control is manipulated in a specified way by a user or via software . Such manipulation could include closing a panel such as the panel A of opening a panel or any other action involving the user interface control . When called in this fashion the dynamic testing system will perform the operations described above in connection with then return control to the software under test 4.

In the implementation of the dynamic testing system will be responsible for its own logging and test report generation functions. Relative to screen shot generation the dynamic testing system may invoke an existing screen shot capture support service as describe above relative to .

Accordingly a technique for performing dynamic globalization verification testing in a software user interface has been disclosed. It will be appreciated that the foregoing concepts may be variously embodied in any of a data processing system a machine implemented method and a computer program product in which programming instructions are provided by one or more machine readable media for use in controlling a data processing system to perform the required functions. Relative to a data processing system and machine implemented method illustrates an exemplary hardware environment in which the dynamic testing system may be implemented. The hardware environment includes a CPU or other data processing resource a physical memory a graphics card for generating visual output to a monitor not shown a peripheral storage device other peripheral devices and a bus infrastructure interconnecting the foregoing elements. The dynamic testing system and the software under test 4 may be loaded in the physical memory . The rule set may reside on the storage device . The test script may be input through user interaction with the peripheral devices e.g. keyboard mouse etc. . Please amend the paragraph beginning on page line as follows 

Relative to a computer program product having a machine readable media and programming instructions for controlling a data processing system exemplary machine readable media for providing such programming instructions are shown by reference numeral in . The media are shown as being portable optical storage disks of the type that are conventionally used for commercial software sales such as compact disk read only memory CD ROM disks compact disk read write CD R W disks and digital versatile disks DVDs . Such media can store the programming instructions of the invention either alone or in conjunction with another software product that incorporates the required functionality. The media providing the programming instructions could also be implemented using portable magnetic media such as floppy disks flash memory sticks etc. or magnetic media combined with drive systems e.g. disk drives or media incorporated in data processing platforms such as random access memory RAM read only memory ROM or other semiconductor or solid state memory. More broadly the media could comprise any electronic magnetic optical semiconductor system or apparatus or device network or other entity that can contain store communicate or transport the programming instructions for use by or in connection with a data processing system computer or other instruction execution system apparatus or device.

It will also be appreciated that the invention may be implemented as an automated globalization verification testing service whereby a software user interface is tested by a service provider following text string pseudo translation by either the service provider or by another entity such as the software developer who is the service provider s client. According to the service model all dynamic globalization verification testing functionality would be the same as that shown in except that the dynamic testing system would be implemented by the service provider at a first location and the software under test would be implemented by the service provider s client at a second location. Communication between the dynamic testing system and the software under test 4 could take place over a network or other telecommunication link using a suitable remote communication protocol. All globalization verification testing could be performed at the service provider location. Following testing a test report could be generated at the service provider location and sent to the client location.

Although various embodiments of the invention have been described it should be apparent that many variations and alternative embodiments could be implemented in accordance with the invention. It is understood therefore that the invention is not to be in any way limited except in accordance with the spirit of the appended claims and their equivalents.

