---

title: Exception thrower
abstract: A method, apparatus and computer-usable medium for testing error handling code. The method includes selecting a method signature to be error tested; selecting an error associated with the method signature from a menu; generating an aspect to be used in a pointcut for an exception that is to be thrown for the selected error; invoking code that generates the selected error; and identifying resultant errors caused by a selected component of the selected error.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07810072&OS=07810072&RS=07810072
owner: International Business Machines Corporation
number: 07810072
owner_city: Armonk
owner_country: US
publication_date: 20060106
---
The present invention relates in general to the field of computers and similar technologies and in particular to software utilized in this field. More particularly the present invention relates to exception throwers.

Computer systems process code that has been written and tested by software engineers using available testing and debugging tools. Such testing includes secondary field beta testing by volunteer users which results in error deficiency spotting which results in the issuing upgraded revised versions months and years later. Before sending the software out for field testing the software engineers use laboratory tools such as Java s Integrated Development Environment IDE to identify code that produces errors both fatal and non fatal.

An interface is made up of functions with inputs and outputs. For outputs there are generally two forms output and errors. In the Java language for example there are return values outputs and exceptions errors . When testing interfaces tools such as IDE provide sophisticated support for debugging code. IDE includes a Java programming editor that aids in the debugging process. This is accomplished by recognizing errors that occur while code is being compiling and then highlighting the errors with distinctive colors. While IDE can recognize and can even suggest corrections to written code IDE cannot describe what long range effects the error has or can cause. That is while IDE supports error trapping error trapping is usually used to fix an existing bug. However IDE does not provide tools or debugging aids for testing error handling code.

To test error handling code developers have had to force error scenarios by writing specialized unit tests changing code during testing or taking unnatural process steps.

If a developer is comfortable using tools to test code writing specialized unit tests may push the developer away from the testing tools of an IDE. Furthermore many tests assume that error conditions are caused by bad input which is not always the case. Unanticipated errors can happen from the conditions around the target component. Thus writing specialized unit tests that force bad input does not cover every testing scenario.

Changing code during testing is a dangerous practice. A software developer may choose to change a piece temporality timing to force an exception such as adding a throw clause to a piece of code. However if the developer forgets to remove this test code then a permanent error condition is introduced.

Taking unnatural process steps is also problematic. For example killing a particular process just to test an error handler may not be feasible if the error handling code in the same process as the code that generated the error. It is also difficult to properly determine when a process should be killed in many scenarios.

Error handling code that does not behave correctly can cause unwanted consequences in a system. For example consider a transactional system that requires a rollback in case of a particular application exception. The error handler may not rollback properly thus causing the system to have inconsistent data. Other unhandled exceptions may cause systems to freeze or even to crash.

For example consider the scenario shown in . Calling component is a software component e.g. object that calls a particular function or service. Target component is software that services the request call operation from calling component . If target component experiences an error when trying to service the request then an error message throw ErrorException is returned to calling component . Calling component then calls exception handler which executes logic in response to the error. As noted above traditional systems such as IDE s do not support testing of the code that is implemented by exception handler .

Object Oriented Programming OOP in which a system is viewed as a set of collaborating objects having methods actions and attributes data as well as procedural programming in which calls are made to reusable subroutines both focus on the separation and encapsulation of concerns areas of interest into single entities by defining classes methods object factories interfaces etc. However they do a poor job of addressing cross cutting issues such as step tracing event logging etc. That is OOP and traditional linear programs have difficulty in handling code that runs across multiple software blocks caused by shared requirements among objects.

The problems described above also occur when using the programming paradigm known as Aspect Oriented Programming AOP . AOP focuses on a modularization and encapsulation of cross cutting concerns. AOP addresses the issue of cross cutting through the use of an aspect. An aspect packages advice code that is applied to objects and join points points in the model where advice will be applied into functional units in a manner that is analogous to the way OOP uses classes to package methods and attributes into objects. Join points may be at a method execution an instantiation of an object or a throwing of an exception.

An aspect can alter the behavior of base code the non aspect part of a program by applying advice additional behavior to multiple join points elements of the programming language semantics which the aspects coordinate with . This results in a logical description of a set of join points called a pointcut. A pointcut can either match a join point or not at runtime and may expose runtime information to a piece of advice.

Thus an aspect is a stand alone module that addresses operations that are scattered across applied to multiple program modules and tangled with interdependent with other modules. An aspect is made up of one or more advice code snippets similar to methods and a list of join points points into a main program into which the advice should be weaved .

Weaving is the injecting of the advice presented in an aspect into the specified join points associated with each advice. That is weaving coordinates aspects and non aspects to ensure that advice executes at the appropriate dynamic join points.

Thus whether a programmer is using AOP OOP or even linear programming there is not a safe and efficient way to test error handling code.

To address the need described above for an improved method and system for testing error handling code the present invention includes but is not limited to a method apparatus and computer usable medium for selecting a method signature to be error tested selecting an error associated with the method signature from a menu generating an aspect to be used in a pointcut for an exception that is to be thrown for the selected error invoking code that generates the selected error and identifying resultant errors caused by a selected component of the selected error.

The above as well as additional purposes features and advantages of the present invention will become apparent in the following detailed written description.

A method apparatus and computer usable medium is presented for providing a way to generate error conditions from a development tool or technique. As presented herein the error condition generation is transparent and requires no code changes to a core code implementation. The error condition generation can be accomplished statically so developers can test error handling code in a static manner. Alternatively the error condition generation can be accomplished dynamically so that developers can generate an error condition while execution is stopped in a debug mode.

Referring now to there is depicted a novel system for calling an exception. Rather than sending a call to a target component as shown in a call for an error exception is made to a specialized exception generator which is preferably an object identified in AOP by a pointcut. As noted in one embodiment exception generator intercepts step 0 b the call operation from call component step 0 a to target component and initiates the call ErrorException command step 0 c in call component . Call component then calls the ErrorException step 1 from exception generator which returns throws the ErrorException back to call component step 2 . Call component then calls for the error exception handler logic step 3 from exception generator thus going around target component .

With reference now to there is depicted a Graphical User Interface GUI showing a debug program which uses a menu that includes an option to throw an exception such as may occur when the call described in is made. To describe what is occurring when such an exception throw is invoked the following static scenario is presented. Note that a dynamic scenario which allows an IDE to compile the called exception on the fly follows the same general steps described herein.

Through the use of AOP and in particular AspectJ temporary functionality is added to applications in a transparent way. Using an IDE s ability to pull up a context menu the Throw Exception option is added to the menu shown in . Note that while menu is shown as a pop up menu menu may alternatively be any type of visual display of a menu including pull down menus active windows etc.

Upon catching an exception an execution thrower as shown in as Exception generator executes and returns the appropriate error condition and allows the calling component to execute an error handler that should execute gracefully and not cause any damage to existing real code. To test this the following code gets executed by the snippet shown above 

Rather than modify the code IDE features which allow direct insertion of the code are used to test this bit of code. Thus by clicking Throw Exception shown in menu the steps shown in are executed.

Referring then to after initiator block the method signature to be tested e.g. ErrorHandler e is selected block . The menu shown in is generated including a secondary menu showing choices of exceptions that can be thrown. An aspect to be used in a pointcut for the thrown exception is generated block and the aspect then throws the selected exception block . Any needed source code then goes through an aspect compiler part of an AOD suite and cross cuts the code i.e. is applied to all relevant objects as shown in block . In order to aid in the debugging process for the thrown execution markers are added block . Errors caused by the execution of the thrown exception are then debugged block and the process ends terminator block .

The aspect shown uses the around advice. The around advice gets called instead of the actual business method. Once the error handling code is tested the aspect can be removed the application re compiled and the code continues to execute normally. For precautionary measures warnings should be added either as comments in the code or through a warning message generated by the IDE that an Exception thrower has been added and should be removed once error handling is tested.

While the preferred embodiment has been shown in a Java environment the present invention may be utilized in any language having exceptions as constructs such as C . Furthermore any interceptor patterns may be used to accomplish the function described above for aspects.

With reference now to there is depicted a block diagram of an exemplary client computer in which the present invention may be utilized. Client computer includes a processor unit that is coupled to a system bus . A video adapter which drives supports a display is also coupled to system bus . System bus is coupled via a bus bridge to an Input Output I O bus . An I O interface is coupled to I O bus . I O interface affords communication with various I O devices including a keyboard a mouse a Compact Disk Read Only Memory CD ROM drive a floppy disk drive and a flash drive memory . The format of the ports connected to I O interface may be any known to those skilled in the art of computer architecture including but not limited to Universal Serial Bus USB ports.

Client computer is able to communicate with a service provider server via a network using a network interface which is coupled to system bus . Network may be an external network such as the Internet or an internal network such as an Ethernet or a Virtual Private Network VPN . Using network client computer is able to use the present invention to access service provider server .

A hard drive interface is also coupled to system bus . Hard drive interface interfaces with a hard drive . In a preferred embodiment hard drive populates a system memory which is also coupled to system bus . Data that populates system memory includes client computer s operating system OS and application programs .

OS includes a shell for providing transparent user access to resources such as application programs . Generally shell is a program that provides an interpreter and an interface between the user and the operating system. More specifically shell executes commands that are entered into a command line user interface or from a file. Thus shell as it is called in UNIX also called a command processor in Windows is generally the highest level of the operating system software hierarchy and serves as a command interpreter. The shell provides a system prompt interprets commands entered by keyboard mouse or other user input media and sends the interpreted command s to the appropriate lower levels of the operating system e.g. a kernel for processing. Note that while shell is a text based line oriented user interface the present invention will equally well support other user interface modes such as graphical voice gestural etc.

As depicted OS also includes kernel which includes lower levels of functionality for OS including providing essential services required by other parts of OS and application programs including memory management process and task management disk management and mouse and keyboard management.

Application programs include a browser . Browser includes program modules and instructions enabling a World Wide Web WWW client i.e. client computer to send and receive network messages to the Internet using HyperText Transfer Protocol HTTP messaging thus enabling communication with service provider server .

Application programs in client computer s system memory also include an Exception Thrower ET . ET includes code for implementing the processes described in . In one embodiment client computer is able to download ET from service provider server .

The hardware elements depicted in client computer are not intended to be exhaustive but rather are representative to highlight essential components required by the present invention. For instance client computer may include alternate memory storage devices such as magnetic cassettes Digital Versatile Disks DVDs Bernoulli cartridges and the like. These and other variations are intended to be within the spirit and scope of the present invention.

As noted above ET can be downloaded to client computer from service provider server shown in exemplary form in . Service provider server includes a processor unit that is coupled to a system bus . A video adapter is also coupled to system bus . Video adapter drives supports a display . System bus is coupled via a bus bridge to an Input Output I O bus . An I O interface is coupled to I O bus . I O interface affords communication with various I O devices including a keyboard a mouse a Compact Disk Read Only Memory CD ROM drive a floppy disk drive and a flash drive memory . The format of the ports connected to I O interface may be any known to those skilled in the art of computer architecture including but not limited to Universal Serial Bus USB ports.

Service provider server is able to communicate with client computer via network using a network interface which is coupled to system bus . Access to network allows service provider server to execute and or download ET to client computer .

System bus is also coupled to a hard drive interface which interfaces with a hard drive . In a preferred embodiment hard drive populates a system memory which is also coupled to system bus . Data that populates system memory includes service provider server s operating system which includes a shell and a kernel . Shell is incorporated in a higher level operating system layer and utilized for providing transparent user access to resources such as application programs which include a browser and a copy of ET described above which can be deployed to client computer .

The hardware elements depicted in service provider server are not intended to be exhaustive but rather are representative to highlight essential components required by the present invention. For instance service provider server may include alternate memory storage devices such as flash drives magnetic cassettes Digital Versatile Disks DVDs Bernoulli cartridges and the like. These and other variations are intended to be within the spirit and scope of the present invention.

Note further that in a preferred embodiment of the present invention service provider server performs all of the functions associated with the present invention including execution of ET thus freeing client computer from using its resources.

It should be understood that at least some aspects of the present invention may alternatively be implemented in a computer useable medium that contains a program product. Programs defining functions on the present invention can be delivered to a data storage system or a computer system via a variety of signal bearing media which include without limitation non writable storage media e.g. CD ROM writable storage media e.g. hard disk drive read write CD ROM optical media system memory such as but not limited to Random Access Memory RAM and communication media such as computer and telephone networks including Ethernet the Internet wireless networks and like network systems. It should be understood therefore that such signal bearing media when carrying or encoding computer readable instructions that direct method functions in the present invention represent alternative embodiments of the present invention. Further it is understood that the present invention may be implemented by a system having means in the form of hardware software or a combination of software and hardware as described herein or their equivalent.

As described above in one embodiment the processes described by the present invention including the functions of ET are performed by service provider server . Alternatively ET and the method described herein and in particular as shown and described in can be deployed as a process software from service provider server to client computer . Still more particularly process software for the method so described may be deployed to service provider server by another service provider server not shown .

Referring then to step begins the deployment of the process software. The first thing is to determine if there are any programs that will reside on a server or servers when the process software is executed query block . If this is the case then the servers that will contain the executables are identified block . The process software for the server or servers is transferred directly to the servers storage via File Transfer Protocol FTP or some other protocol or by copying though the use of a shared file system block . The process software is then installed on the servers block .

Next a determination is made on whether the process software is to be deployed by having users access the process software on a server or servers query block . If the users are to access the process software on servers then the server addresses that will store the process software are identified block .

A determination is made if a proxy server is to be built query block to store the process software. A proxy server is a server that sits between a client application such as a Web browser and a real server. It intercepts all requests to the real server to see if it can fulfill the requests itself. If not it forwards the request to the real server. The two primary benefits of a proxy server are to improve performance and to filter requests. If a proxy server is required then the proxy server is installed block . The process software is sent to the servers either via a protocol such as FTP or it is copied directly from the source files to the server files via file sharing block . Another embodiment would be to send a transaction to the servers that contained the process software and have the server process the transaction then receive and copy the process software to the server s file system. Once the process software is stored at the servers the users via their client computers then access the process software on the servers and copy to their client computers file systems block . Another embodiment is to have the servers automatically copy the process software to each client and then run the installation program for the process software at each client computer. The user executes the program that installs the process software on his client computer block then exits the process terminator block .

In query step a determination is made whether the process software is to be deployed by sending the process software to users via e mail. The set of users where the process software will be deployed are identified together with the addresses of the user client computers block . The process software is sent via e mail to each of the users client computers block . The users then receive the e mail block and then detach the process software from the e mail to a directory on their client computers block . The user executes the program that installs the process software on his client computer block then exits the process terminator block .

Lastly a determination is made on whether to the process software will be sent directly to user directories on their client computers query block . If so the user directories are identified block . The process software is transferred directly to the user s client computer directory block . This can be done in several ways such as but not limited to sharing of the file system directories and then copying from the sender s file system to the recipient user s file system or alternatively using a transfer protocol such as File Transfer Protocol FTP . The users access the directories on their client file systems in preparation for installing the process software block . The user executes the program that installs the process software on his client computer block and then exits the process terminator block .

The present software can be deployed to third parties as part of a service wherein a third party VPN service is offered as a secure deployment vehicle or wherein a VPN is build on demand as required for a specific deployment.

A virtual private network VPN is any combination of technologies that can be used to secure a connection through an otherwise unsecured or untrusted network. VPNs improve security and reduce operational costs. The VPN makes use of a public network usually the Internet to connect remote sites or users together. Instead of using a dedicated real world connection such as leased line the VPN uses virtual connections routed through the Internet from the company s private network to the remote site or employee. Access to the software via a VPN can be provided as a service by specifically constructing the VPN for purposes of delivery or execution of the process software i.e. the software resides elsewhere wherein the lifetime of the VPN is limited to a given period of time or a given number of deployments based on an amount paid.

The process software may be deployed accessed and executed through either a remote access or a site to site VPN. When using the remote access VPNs the process software is deployed accessed and executed via the secure encrypted connections between a company s private network and remote users through a third party service provider. The enterprise service provider ESP sets a network access server NAS and provides the remote users with desktop client software for their computers. The telecommuters can then dial a toll bee number or attach directly via a cable or DSL modem to reach the NAS and use their VPN client software to access the corporate network and to access download and execute the process software.

When using the site to site VPN the process software is deployed accessed and executed through the use of dedicated equipment and large scale encryption that are used to connect a companies multiple fixed sites over a public network such as the Internet.

The process software is transported over the VPN via tunneling which is the process the of placing an entire packet within another packet and sending it over a network. The protocol of the outer packet is understood by the network and both points called runnel interfaces where the packet enters and exits the network.

The process for such VPN deployment is described in . Initiator block begins the Virtual Private Network VPN process. A determination is made to see if a VPN for remote access is required query block . If it is not required then proceed to query block . If it is required then determine if the remote access VPN exists query block .

If a VPN does exist then proceed to block . Otherwise identify a third party provider that will provide the secure encrypted connections between the company s private network and the company s remote users block . The company s remote users are identified block . The third party provider then sets up a network access server NAS block that allows the remote users to dial a toll free number or attach directly via a broadband modem to access download and install the desktop client software for the remote access VPN block .

After the remote access VPN has been built or if it been previously installed the remote users can access the process software by dialing into the NAS or attaching directly via a cable or DSL modem into the NAS block . This allows entry into the corporate network where the process software is accessed block . The process software is transported to the remote user s desktop over the network via tunneling. That is the process software is divided into packets and each packet including the data and protocol is placed within another packet block . When the process software arrives at the remote user s desktop it is removed from the packets reconstituted and then is executed on the remote user s desktop block .

A determination is then made to see if a VPN for site to site access is required query block . If it is not required then proceed to exit the process terminator block . Otherwise determine if the site to site VPN exists query block . If it does exist then proceed to block . Otherwise install the dedicated equipment required to establish a site to site VPN block . Then build the large scale encryption into the VPN block .

After the site to site VPN has been built or if it had been previously established the users access the process software via the VPN block . The process software is transported to the site users over the network via tunneling block . That is the process software is divided into packets and each packet including the data and protocol is placed within another packet block . When the process software arrives at the remote user s desktop it is removed from the packets reconstituted and is executed on the site user s desktop block . The process then ends at terminator block .

The process software which consists code for implementing the process described herein may be integrated into a client server and network environment by providing for the process software to coexist with applications operating systems and network operating systems software and then installing the process software on the clients and servers in the environment where the process software will function.

The first step is to identify any software on the clients and servers including the network operating system where the process software will be deployed that are required by the process software or that work in conjunction with the process software. This includes the network operating system that is software that enhances a basic operating system by adding networking features.

Next the software applications and version numbers will be identified and compared to the list of software applications and version numbers that have been tested to work with the process software. Those software applications that are missing or that do not match the correct version will be upgraded with the correct version numbers. Program instructions that pass parameters from the process software to the software applications will be checked to ensure the parameter lists matches the parameter lists required by the process software. Conversely parameters passed by the software applications to the process software will be checked to ensure the parameters match the parameters required by the process software. The client and server operating systems including the network operating systems will be identified and compared to the list of operating systems version numbers and network software that have been tested to work with the process software. Those operating systems version numbers and network software that do not match the list of tested operating systems and version numbers will be upgraded on the clients and servers to the required level.

After ensuring that the software where the process software is to be deployed is at the correct version level that has been tested to work with the process software the integration is completed by installing the process software on the clients and servers.

For a high level description of this process reference is now made to . Initiator block begins the integration of the process software. The first tiling is to determine if there are any process software programs that will execute on a server or servers block . If this is not the case then integration proceeds to query block . If this is the case then the server addresses are identified block . The servers are checked to see if they contain software that includes the operating system OS applications and network operating systems NOS together with their version numbers which have been tested with the process software block . The servers are also checked to determine if there is any missing software that is required by the process software in block .

A determination is made if the version numbers match the version numbers of OS applications and NOS that have been tested with the process software block . If all of the versions match and there is no missing required software the integration continues in query block .

If one or more of the version numbers do not match then the unmatched versions are updated on the server or servers with the correct versions block . Additionally if there is missing required software then it is updated on the server or servers in the step shown in block . The server integration is completed by installing the process software block .

The step shown in query block which follows either the steps shown in block or determines if there are any programs of the process software that will execute on the clients. If no process software programs execute on the clients the integration proceeds to terminator block and exits. If this not the case then the client addresses are identified as shown in block .

The clients are checked to see if they contain software that includes the operating system OS applications and network operating systems NOS together with their version numbers which have been tested with the process software block . The clients are also checked to determine if there is any missing software that is required by the process software in the step described by block .

A determination is made is the version numbers match the version numbers of OS applications and NOS that have been tested with the process software query block . If all of the versions match and there is no missing required software then the integration proceeds to terminator block and exits.

If one or more of the version numbers do not match then the unmatched versions are updated on the clients with the correct versions block . In addition if there is missing required software then it is updated on the clients also block . The client integration is completed by installing the process software on the clients block . The integration proceeds to terminator block and exits.

The process software is shared simultaneously serving multiple customers in a flexible automated fashion. It is standardized requiring little customization and it is scalable providing capacity on demand in a pay as you go model.

The process software can be stored on a shared file system accessible from one or more servers. The process software is executed via transactions that contain data and server processing requests that use CPU units on the accessed server. CPU units are units of time such as minutes seconds hours on the central processor of the server. Additionally the assessed server may make requests of other servers that require CPU units. CPU units are an example that represents but one measurement of use. Other measurements of use include but are not limited to network bandwidth memory usage storage usage packet transfers complete transactions etc.

When multiple customers use the same process software application their transactions are differentiated by the parameters included in the transactions that identify the unique customer and the type of service for that customer. All of the CPU units and other measurements of use that are used for the services for each customer are recorded. When the number of transactions to any one server reaches a number that begins to affect the performance of that server other servers are accessed to increase the capacity and to share the workload. Likewise when other measurements of use such as network bandwidth memory usage storage usage etc. approach a capacity so as to affect performance additional network bandwidth memory usage storage etc. are added to share the workload.

The measurements of use used for each service and customer are sent to a collecting server that sums the measurements of use for each customer for each service that was processed anywhere in the network of servers that provide the shared execution of the process software. The summed measurements of use units are periodically multiplied by unit costs and the resulting total process software application service costs are alternatively sent to the customer and or indicated on a web site accessed by the customer which then remits payment to the service provider.

In another embodiment the service provider requests payment directly from a customer account at a banking or financial institution.

In another embodiment if the service provider is also a customer of the customer that uses the process software application the payment owed to the service provider is reconciled to the payment owed by the service provider to minimize the transfer of payments.

With reference now to initiator block begins the On Demand process. A transaction is created than contains the unique customer identification the requested service type and any service parameters that further specify the type of service block . The transaction is then sent to the main server block . In an On Demand environment the main server can initially be the only server then as capacity is consumed other servers are added to the On Demand environment.

The server central processing unit CPU capacities in the On Demand environment are queried block . The CPU requirement of the transaction is estimated then the servers available CPU capacity in the On Demand environment are compared to the transaction CPU requirement to see if there is sufficient CPU available capacity in any server to process the transaction query block . If there is not sufficient server CPU available capacity then additional server CPU capacity is allocated to process the transaction block . If there was already sufficient Available CPU capacity then the transaction is sent to a selected server block .

Before executing the transaction a check is made of the remaining On Demand environment to determine if the environment has sufficient available capacity for processing the transaction. This environment capacity consists of such things as but not limited to network bandwidth processor memory storage etc. block . If there is not sufficient available capacity then capacity will be added to the On Demand environment block . Next the required software to process the transaction is accessed loaded into memory then the transaction is executed block .

The usage measurements are recorded block . The usage measurements consist of the portions of those functions in the On Demand environment that are used to process the transaction. The usage of such functions as but not limited to network bandwidth processor memory storage and CPU cycles are what is recorded. The usage measurements are summed multiplied by unit costs and then recorded as a charge to the requesting customer block .

If the customer has requested that the On Demand costs be posted to a web site query block then they are posted block . If the customer has requested that the On Demand costs be sent via e mail to a customer address query block then these costs are sent to the customer block . If the customer has requested that the On Demand costs be paid directly from a customer account query block then payment is received directly from the customer account block . The On Demand process is then exited at terminator block .

While the present invention has been particularly shown and described with reference to a preferred embodiment it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. Furthermore as used in the specification and the appended claims the term computer or system or computer system or computing device includes any data processing system including but not limited to personal computers servers workstations network computers main frame computers routers switches Personal Digital Assistants PDA s telephones and any other system capable of processing transmitting receiving capturing and or storing data.

