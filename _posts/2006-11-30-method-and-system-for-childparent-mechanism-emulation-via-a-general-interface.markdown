---

title: Method and system for child-parent mechanism emulation via a general interface
abstract: A method for emulating a system call includes making the system call by a first process in a first operating system (OS) for interacting with a second process, wherein the first OS is emulated in a second OS, spawning an agent process, wherein the agent process is a child process of the first process, implementing a functionality of the system call using a general mechanism in the second OS between the agent process and the second process, passing a result associated with the system call from the second process to the agent process using the general mechanism, and relaying the result from the agent process to the first process using a system call in the second OS, wherein the result is stored by the first process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07720671&OS=07720671&RS=07720671
owner: Oracle America, Inc.
number: 07720671
owner_city: Redwood Shores
owner_country: US
publication_date: 20061130
---
Emulation refers to the ability of a program or device to imitate another program or device. A software emulator allows computer programs to run on a platform i.e. computer architecture and or operating system other than the platform for which the programs were originally written. Emulation attempts to model the state of the device being emulated as well as reproduce the program s behavior in the emulated device. Emulation software may be packaged for use by computer users programmers and manufacturers.

Two common types of emulation are central processing unit CPU emulation and operating system OS emulation. CPU engineers choose the instruction set that is executed by a given CPU. As a result a line of CPUs use an instruction set that is generally incompatible with instruction sets used by another line of CPUs. For example IBM compatible computers tend to use Intel 80x86 compatible CPUs such as Intel Pentium Pentium is a registered trademark of Intel Corporation and AMD Athlon Athlon is a registered trademark of Advanced Micro Devices Inc. CPUs whereas Macintosh computers originally used Motorola 680x0 CPUs. Macintosh is a registered trademark of Apple Computer Inc. CPU emulation software allows a CPU to execute an instruction set that is typically incompatible with that CPU.

Operating Systems OSes are collections of instructions that provide a set of routines to the programs running on a computer. OS routines are generally grouped into layers the lowest layers interact directly with hardware and the higher layers interact with lower layers. OS emulation software allows a computer to provide routines that are not normally provided by the OS installed on the computer. For example OS emulation software may allow functions from one OS to run on a second OS even if the second OS does not normally support these functions. OS emulation may also replace some or all of the layers of a given OS.

In general in one aspect the invention relates to a method for emulating a system call comprising making the system call by a first process in a first operating system OS for interacting with a second process wherein the first OS is emulated in a second OS spawning an agent process wherein the agent process is a child process of the first process implementing a functionality of the system call using a general mechanism in the second OS between the agent process and the second process passing a result associated with the system call from the second process to the agent process using the general mechanism and relaying the result from the agent process to the first process using a system call in the second OS wherein the result is stored by the first process.

In general in one aspect the invention relates to a system comprising a first operating system OS emulated in a second OS the second OS comprising an emulation environment for the first OS and an emulated userland of the first OS wherein the emulation environment for the first OS is configured to make a system call by a first process in the first OS for interacting with a second process spawn an agent process wherein the agent process is a child process of the first process implement a functionality of the system call using a general mechanism in the second OS between the agent process and the second process.

In general in one aspect the invention relates to a computer readable medium containing software instructions embodied therein for causing a computer system to perform a method for emulating a system call comprising making the system call by a first process in a first operating system OS for interacting with a second process wherein the first OS is emulated in a second OS spawning an agent process wherein the agent process is a child process of the first process implementing a functionality of the system call using a general mechanism in the second OS between the agent process and the second process passing a result associated with the system call from the second process to the agent process using the general mechanism and relaying the result from the agent process to the first process using a system call in the second OS wherein the result is stored by the first process.

Other aspects of the invention will be apparent from the following description and the appended claims.

Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.

In the following detailed description of embodiments of the invention numerous specific details are set forth in order to provide a more thorough understanding of the invention. However it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail to avoid unnecessarily complicating the description.

In general embodiments of the invention provide a method and system to provide functionality of a first operating system OS within a second OS. Further embodiments of the invention provide a method and system to emulate system calls in the first OS within the second OS where the system calls in the first OS can be used by any two processes but where the same system calls in the second OS can only be used within a parent child process relationship.

Specifically embodiments of the invention provide a method and system to emulate a ptrace system call from an emulated Linux Linux is a registered trademark of William R. Della Croce Jr. userland within Solaris Solaris is a registered trademark of Sun Microsystems Inc . Because Solaris only allows ptrace to be used between a parent process and a child process whereas Linux allows ptrace to be used between two arbitrary processes the generality of Linux ptrace must be emulated within Solaris when ptrace is used within the emulated Linux userland. In accordance with one or more embodiments of the invention a general mechanism in Solaris such as proc is used to implement the functionality of Linux ptrace between two arbitrary processes using a third intermediary process which is created as a child of one of the processes.

The operating system kernel is a central component of a computer s operating system OS . The OS kernel manages the computer s resources and the communication between the computer s hardware and software components. The OS kernel also provides the lowest layer of abstraction for the resources such as memory processors and input output I O devices used by applications e.g. userland applications emulated userland applications running on the OS. The OS kernel typically provides these resources to applications e.g. userland applications emulated userland applications using system calls . The OS kernel may also provide methods for synchronization and communication between processes e.g. userland processes agent processes emulated userland processes using for example inter process communication IPC mechanisms. The OS kernel also executes and provides support for applications e.g. userland applications emulated userland applications on the computer. In addition the OS kernel may manage a set of peripheral devices not shown such as printers scanners mice external storage devices and other devices that are optional to the normal operation of the computer.

In one or more embodiments of the invention the OS kernel uses one or more kernel execution streams to carry out its responsibilities. In one or more embodiments of the invention a kernel execution stream is a sequence of instructions executed by a processor such as a central processing unit CPU on the computer. In one or more embodiments of the invention a kernel execution stream is analogous to a thread. A kernel execution stream may be associated with one or more processes e.g. userland processes agent processes emulated userland processes . In other words a kernel execution stream may execute instructions related to one or more processes e.g. userland processes agent processes emulated userland processes on the computer. Alternatively multiple kernel execution streams may be associated with a single process e.g. userland processes agent processes emulated userland processes . For example in a multitasking environment a process e.g. userland processes agent processes emulated userland processes may employ multiple concurrent kernel execution streams to carry out one or more tasks for which the process is responsible.

In one or more embodiments of the invention userland applications allow tasks to be performed on the computer by one or more users. Examples of userland applications include word processors spreadsheets media players web browsers and other utilities. In one or more embodiments of the invention the userland applications are external to the OS kernel . In addition the userland applications must interact with the OS kernel to use the resources e.g. memory processors I O on the computer for executing tasks specified by the user. For example a web browser must display one or more web pages to a user and respond to input provided by the user through a keyboard mouse and or other I O device. The OS kernel provides memory required to run the web browser as well as store content from the web. The OS kernel also regulates the web browser s access to I O devices. The OS kernel further decides when the web browser is allowed to run on one or more processors in the computer.

As shown in the userland applications are associated with a set of userland processes . In one or more embodiments of the invention a userland process is a running instance of a userland application . In one or more embodiments of the invention an instance of a userland application is started as a userland process . The userland process may then spawn one or more child processes which are also userland processes . In one or more embodiments of the invention a userland process may be associated with an image of the executable code of the affiliated userland application a region of memory that includes the executable code and other process specific data OS descriptors of resources allocated to the process such as file descriptors or handles security attributes such as the process owner and permissions set for the process and a process state such as created terminated running blocked waiting etc.

In one or more embodiments of the invention a userland application uses one or more system calls to request service from the OS kernel . In one or more embodiments of the invention a system call from a userland application transfers control to the OS kernel . The OS kernel then executes code related to the system call before transferring control back to the userland application . Examples of system calls include open read write close wait exec fork and kill.

Those skilled in the art will appreciate that different OSes may contain different system calls . Further those skilled in the art will appreciate that the same system call may behave differently based on the OS installed on the computer. As a result the userland applications may use different system calls to interact with the OS kernel depending on the OS kernel and or the OS in general.

The system of also includes an emulation environment . In one or more embodiments of the invention an emulation environment allows the behavior of a second OS to be emulated on the OS kernel . For example the OS kernel may be Solaris based e.g. Solaris 10 but a user may wish to run one or more Linux programs on the OS kernel . To do so a Linux emulation environment may be installed on the computer allowing Linux programs to run on the computer. In one or more embodiments of the invention the emulation environment allows the computer to provide routines e.g. Linux routines that are not normally associated with the OS kernel . In other words the emulation environment resolves compatibility issues between the OS of the OS kernel and the OS emulated by the emulation environment .

Together the OS kernel and emulation environment allow a user to run a set of emulated userland applications on the computer. In one or more embodiments of the invention emulated userland applications are applications that are native to an OS other than the OS kernel s OS. In one or more embodiments of the invention the emulated userland applications interact with the emulation environment as if the emulation environment were an OS kernel of the OS emulated by the emulation environment . In one or more embodiments of the invention the emulation environment is indistinguishable from an OS kernel to the emulated userland applications . Using the example above a user may run one or more Linux applications i.e. emulated userland applications on a Solaris kernel by running the applications through a Linux emulation environment. The Linux emulation environment translates any Linux based routines found in the Linux applications into Solaris based routines that can be comprehended by the Solaris kernel.

As with the userland applications and userland processes the emulated userland applications are associated with a set of emulated userland processes . Like userland processes the emulated userland processes are running instances of emulated userland applications . In one or more embodiments of the invention an emulated userland process may also be associated with an image of the executable code of the affiliated emulated userland application a region of memory OS descriptors of resources allocated to the process security attributes and a process state. In one or more embodiments of the invention an emulated userland process corresponds to a running instance of an emulated userland application or a child process of the running instance.

In one or more embodiments of the invention the emulated userland applications interact with the emulation environment using a set of emulated system calls . In one or more embodiments of the invention emulated system calls are system calls of the OS emulated by the emulation environment . For example if the OS emulated by the emulation environment includes a wait system call and an emulated userland application uses the wait system call in a routine the emulation environment intercepts the wait system call from the emulated userland application and processes the system call according to the emulated OS s use of the system call. The emulation environment then interacts with the OS kernel using one or more translated system calls to carry out the function of the emulated system call .

In one or more embodiments of the invention translated system calls are used by the emulation environment to perform the same function as the emulated system calls made by an emulated userland application . In other words the emulation environment performs a mapping from the emulated system calls to system calls that exist for the OS kernel . The emulation environment may also perform additional processing and packaging so that the behavior of the emulated system calls is adequately simulated. For example an emulated system call of the emulation environment may be simulated using three system calls from the OS kernel as well as additional configuration of emulated userland processes and associated data. In such cases the emulation environment makes the three system calls and performs the necessary configurations when the emulated system call is made by an emulated userland application . Further the emulated userland application then receives any output related to the emulated system call as if the emulated system call were made on the native OS of the emulation environment .

Those skilled in the art will appreciate that the mapping may be arbitrarily complex depending on the overlap of system call functionalities between the OS emulated in the emulation environment and the OS of the OS kernel . For example if the OS kernel includes a system call that performs the same function as an emulated system call made by an emulated userland application then an invocation of the emulated system call by the emulated userland application is handled by calling the functionally equivalent system call i.e. translated system call by the emulation environment . In one or more embodiments of the invention functional equivalents between emulated system calls and system calls may be stored in a table map pointer array etc. for fast lookup. However if no functional equivalent exists between an emulated system call and a system call the emulation environment provides one or more routines for performing the steps of the emulated system call using the kernel s existing system calls and any additional code for formatting data assigning ownership to emulated userland processes etc.

In one or more embodiments of the invention translated system calls form part of the routines provided by the emulation environment for performing emulated system calls . In one or more embodiments of the invention translated system calls correspond to system calls of the OS kernel invoked by the emulation environment to help carry out the functionality of emulated system calls . As mentioned above the emulation environment may also format data change security settings and privileges configure parent child relationships among emulated userland processes and perform other tasks related to emulating an emulated system call in the OS kernel s environment.

Embodiments of the invention provide the ability to handle a functionally equivalent mechanism that exists between a system call of the OS kernel and an emulated system call of the emulation environment . However the emulated system call allows the mechanism to be implemented between any two processes e.g. userland processes agent processes emulated userland processes whereas the system call only allows the mechanism to be carried out within a parent child process relationship. For example a Linux ptrace system call allows one process e.g. userland processes agent processes emulated userland processes to trace another process regardless of the relationship between the two processes. However a Solaris ptrace system call only allows a process e.g. userland processes agent processes emulated userland processes to trace another process if the traced process is a child of the tracing process. Consequently embodiments of the invention enable a Linux emulation environment to execute on a computer with a Solaris kernel. Further embodiments of the invention enable the emulation of a Linux ptrace system call i.e. emulated system call using the system calls available on the Solaris kernel.

In one or more embodiments of the invention the emulation environment emulates a mechanism that can be implemented between any two processes e.g. userland processes agent processes emulated userland processes in the emulated OS in an OS kernel that only supports the mechanism between a parent process and a child process. In one or more embodiments of the invention the emulation environment spawns an agent process as a child of the first emulated userland process . The agent process then implements the functionality of the mechanism with the second emulated userland process using a general mechanism supported by the OS kernel . The agent process then reports back to the parent emulated userland process using a parent child mechanism supported by the OS kernel .

In one or more embodiments of the invention an agent process is a child process of an emulated userland process that is spawned specifically to implement an emulated system call between any two emulated userland processes when the functionally equivalent system call in the OS kernel is only allowed between a parent process e.g. userland processes agent processes emulated userland processes and a child process. As stated above the agent process uses a general mechanism supported by the OS kernel to implement the emulated system call between the two emulated userland processes . In other words the agent process acts as an intermediary between the two emulated userland processes and carries out the functionality of the emulated system call between the two emulated userland processes . The agent process also passes any data and instructions between the two emulated userland processes that would normally be directly exchanged between the two emulated userland processes using mechanisms that both emulated userland processes would expect.

For example a Linux ptrace system call between an arbitrary tracing process and an arbitrary traced process may be emulated in a Solaris kernel by spawning an agent process that is a child of the tracing process. The agent process then traces the traced process using a general mechanism supported by the Solaris kernel such as proc which is a pseudo file system used to obtain process data from the OS kernel . Traced data and process state are then passed back to the tracing process using a parent child mechanism such as a wait system call . In one or more embodiments of the invention the parent child mechanism used between the agent process and tracing process is the same as the parent child mechanism used between the traced process and the tracing process in a native Linux environment. As a result neither the user calling ptrace from the emulated Linux environment nor the tracing process are aware of the details of the ptrace emulation mechanism.

Those skilled in the art will appreciate that two functionally equivalent mechanisms such as a ptrace system call and proc operate using different application programming interfaces APIs . Thus to shield the user and emulated userland process created to carry out the emulated system call from knowledge of a different API for implementing the emulated system call s functionality an agent process is created. The agent process then uses the different API to perform the emulated system call s function then uses the API of the emulated system call on the native OS of the emulation environment to communicate the results of the emulated system call to the emulated userland process associated with the execution of the emulated system call .

As shown in an emulated userland process is created from an emulated userland application using an emulated system call . In one or more embodiments of the invention the emulated userland application refers to a running instance of the emulated userland application with which the user interacts. As discussed in an emulated system call is a system call native to the emulated first OS. The functionality of the emulated system call is reproduced in the second OS through system calls supported by the second OS and or customized routines in the emulation environment of the first OS. In one or more embodiments of the invention an emulated userland process is created using a system call in the native OS of the computer when an emulated system call is made from within an emulated userland application . In one or more embodiments of the invention the emulated userland process is created to carry out the emulated system call . In one or more embodiments of the invention the emulated system call involves interacting with a third party process using the emulated userland process .

For example an exec system call may be used to create the emulated userland process when the emulated system call is made from the emulated userland application . The emulated system call may be issued to the emulation environment of the first OS which may then make the same system call or a similar system call to the kernel of the second OS to create the emulated userland process . Alternatively the emulation environment may use an entirely different system call to the kernel of the second OS to create the emulated userland process . Those skilled in the art will appreciate that different system calls and emulated system calls may be used depending on the emulation environment of the first OS and the native second OS.

In one or more embodiments of the invention the emulated userland process is configured to interact with a third party process through the emulated system call . However the kernel of the second OS does not support the emulated system call directly between the emulated userland process and an arbitrary third party process which may be any other process on the computer. Instead the kernel of the native second OS only supports the system call between the emulated userland process and a child process of the emulated userland process.

To emulate the functionality of the system call in the emulated first OS the emulation environment creates an agent process from the emulated userland process using a child spawning mechanism . In one or more embodiments of the invention an agent process is a child process of the emulated userland process that acts as an intermediary between the emulated userland process and the third party process . In other words the agent process implements the functionality of the system call in the emulated first OS between the emulated userland process and the third party process using mechanisms supported by the native second OS. The agent process also hides the emulation mechanism of the emulated system call from the emulated userland process emulated userland application and user.

In one or more embodiments of the invention the agent process is created from the emulated userland process using a child spawning mechanism . In one or more embodiments of the invention a child spawning mechanism creates a child process from a parent process. In one or more embodiments of the invention the agent process is created as a child of the emulated userland process and inherits at least one of its attributes from the emulated userland process . In one or more embodiments of the invention the agent process is created from the emulated userland process using a system call such as the fork system call in Unix like OSes.

The agent process interacts with the third party process using a general mechanism . In one or more embodiments of the invention the general mechanism is used by the agent process to implement the functionality of the emulated system call between the emulated userland process and the third party process . In one or more embodiments of the invention the general mechanism is a routine program process system call etc. that operates using a different API from the emulated system call but performs the same function as the emulated system call . Using the general mechanism the agent process can bypass the parent child restriction on the emulated system call from within the native second OS to emulate the broader application of the emulated system call specified by the emulated first OS.

In one or more embodiments of the invention the agent process obtains an emulated result related to the emulated system call using the general mechanism . The agent process then sends the emulated result to the emulated userland process using a parent child mechanism . In one or more embodiments of the invention the parent child mechanism is the same as the parent child mechanism used between a parent process and a child process in invoking the emulated system call in the native first OS. As a result the emulated userland process is unable to detect a difference in behavior between making the emulated system call in an emulated environment and making the emulated system call in an OS that inherently supports the emulated system call between two arbitrary processes.

In one or more embodiments of the invention the emulated userland process transfers the emulated result to the emulated userland application where the emulated result is displayed to the user and or stored for further processing. In one or more embodiments of the invention the emulated result is formatted as if the emulated result were obtained in a native environment of the second OS as opposed to an emulated environment of the second OS.

The emulated Linux userland application refers to an application native to Linux that includes functionality to invoke the ptrace system call. For example the emulated Linux userland application may be an emulated Linux command console a debugging application etc. An emulated ptrace process is created from the emulated Linux userland application when an emulated ptrace system call is invoked from the emulated Linux userland application to trace a traced process . In one or more embodiments of the invention the emulated ptrace system call corresponds to a Linux ptrace system call . As mentioned previously the Linux ptrace system call allows a process to trace any other process regardless of an existing parent child relationship between the traced process and tracing process i.e. the emulated ptrace process . In one or more embodiments of the invention the traced process is a process within the Linux emulation environment that is targeted for tracing. For example the traced process may be a process that is being monitored for debugging purposes.

To emulate the Linux ptrace system call the emulated ptrace process creates an emulated ptrace child process using the fork system call . In one or more embodiments of the invention the fork system call creates the emulated ptrace child process as a copy of the emulated ptrace process and also as a child of the emulated ptrace process . The emulated ptrace child process may also inherit its attributes from the emulated ptrace process . As mentioned above the emulated ptrace child process carries out the functionality of the emulated ptrace system call between the emulated ptrace process and the traced process .

As shown in the emulated ptrace child process uses proc to interact with and trace the traced process . In one or more embodiments of the invention proc is a pseudo file system used to access information from the kernel. In one or more embodiments of the invention proc allows a process to trace any other process within Solaris regardless of any existing parent child relationships. Those skilled in the art will appreciate that another general tracing mechanism may be used by the emulated ptrace child process to trace the traced process .

In one or more embodiments of the invention traced data from the traced process is obtained by the emulated ptrace child process using proc . The emulated ptrace child process then passes the traced data to the emulated ptrace process using the wait system call . In one or more embodiments of the invention the wait system call is used by a parent process to collect information about a child process after the child process has ended execution. In one or more embodiments of the invention a wait system call is used by Linux ptrace to obtain information about a traced process . Because the same wait system call is used to pass information about the traced process to the emulated ptrace process the emulated ptrace process is unable to distinguish the emulated ptrace system call from a ptrace system call executed in a Linux environment even though ptrace and proc use different interfaces.

The emulated ptrace process may then pass the traced data to the emulated Linux userland application where the traced data may be displayed to a user and or stored for analysis and potentially further processing. In one or more embodiments of the invention the traced data is formatted as if the traced data were obtained in a native Linux environment as opposed to an emulated Linux environment.

An emulated userland process is created to carry out the emulated system call Step . As mentioned previously the emulated userland process is created when the emulated system call is made by the emulated userland application. The emulated userland process may be made using a system call in the native second OS such as exec. The emulated userland process also spawns a child agent process Step using a fork system call for example. The agent process then carries out the functionality of the emulated system call by acting as an intermediary between the emulated userland process and the third party process.

In one or more embodiments of the invention the agent process uses a general mechanism for communicating with the third party process Step . In one or more embodiments of the invention the general mechanism performs the same function as the emulated system call using a different API. In one or more embodiments of the invention the agent process is created to hide the use of the different API from the emulated userland process. The general mechanism is also used to pass an emulated result from the third party process to the agent process Step . The agent process relays the emulated result to the emulated userland process using a parent child mechanism Step and the agent process is closed Step . In one or more embodiments of the invention the parent child mechanism is the same parent child mechanism used between two processes in a native environment of the emulated first OS to carry out the emulated system call. As described above the emulated result may be formatted to match a result obtained through normal operation of the emulated system call in the emulated first OS.

Initially the ptrace system call is received from the Linux emulation environment to trace a traced process Step . The ptrace system call may be made from a command line a graphical user interface GUI a shell script a scheduled task etc. An emulated ptrace process is also created to carry out the Linux ptrace system call Step . In one or more embodiments of the invention the emulated ptrace process is spawned by the Linux emulation environment using a system call to the Solaris kernel.

A ptrace child process is spawned from the emulated ptrace process Step . In one or more embodiments of the invention the ptrace child process is spawned using the fork system call which creates a copy of the emulated ptrace process as a child of the emulated ptrace process. The ptrace child process may also inherit some or all of its attributes from the emulated ptrace process. The ptrace child process uses the proc utility to trace data from the traced process Step . As mentioned above proc is a pseudo file system used to access process information from the kernel. In one or more embodiments of the invention proc allows a process to trace any other process using a different interface from ptrace. Alternatively the ptrace child process may use another general utility to trace the traced process.

The ptrace child process also uses proc to obtain traced data from the traced process Step . The ptrace child process relays the traced data to the emulated ptrace process using a wait system call Step . In one or more embodiments of the invention the wait system call allows a parent process to wait for a child process to die. The parent process may then obtain information about the child process once the child process has ended execution. In one or more embodiments of the invention the emulated ptrace process uses the wait system call to obtain the traced data from the ptrace child process. In one or more embodiments of the invention the wait system call is used by a ptrace process in a native Linux environment to obtain information directly from the traced process. As a result the emulated ptrace process is unable to distinguish the Linux ptrace system call in the Linux emulation environment from a Linux ptrace system call in a native Linux environment. The child process is closed Step once the traced data is obtained.

The invention may be implemented on virtually any type of computer regardless of the platform being used. For example as shown in a computer system includes a processor associated memory a storage device and numerous other elements and functionalities typical of today s computers not shown . The computer may also include input means such as a keyboard and a mouse and output means such as a monitor . The computer system is connected to a local area network LAN or a wide area network e.g. the Internet not shown via a network interface connection not shown . Those skilled in the art will appreciate that these input and output means may take other forms.

Further those skilled in the art will appreciate that one or more elements of the aforementioned computer system may be located at a remote location and connected to the other elements over a network. Further the invention may be implemented on a distributed system having a plurality of nodes where each portion of the invention e.g. first OS second OS etc. may be located on a different node within the distributed system. In one embodiment of the invention the node corresponds to a computer system. Alternatively the node may correspond to a processor with associated physical memory. The node may alternatively correspond to a processor with shared memory and or resources. Further software instructions to perform embodiments of the invention may be stored on a computer readable medium such as a compact disc CD a diskette a tape a file or any other computer readable storage device.

While the invention has been described with respect to a limited number of embodiments those skilled in the art having benefit of this disclosure will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly the scope of the invention should be limited only by the attached claims.

