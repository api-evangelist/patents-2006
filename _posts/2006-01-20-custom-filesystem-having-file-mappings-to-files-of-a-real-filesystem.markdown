---

title: Custom filesystem having file mappings to files of a real filesystem
abstract: A computer system having a computer, a custom filesystem, and a real filesystem is disclosed. The custom filesystem is comprised of virtual files that may be mapped to a subset of real files of the real filesystem. The custom filesystem may provide an arrangement of the virtual files to a user through the user interface. This limited arrangement may present the virtual files in a hierarchical arrangement that may be easily navigated and customized for a particular computer, group of computers, computer user, or group of computer users. The custom filesystem may maintain its own metafile information for the virtual files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07433900&OS=07433900&RS=07433900
owner: QNX Software Systems GmbH & Co. KG
number: 07433900
owner_city: Karlsbad
owner_country: DE
publication_date: 20060120
---
This application is a continuation in part application of U.S. application Ser. No. 09 824 252 filed Apr. 3 2001 now U.S. Pat. No. 7 047 257 which is incorporated herein by reference.

The present invention relates to a computer file management system that employs a local filesystem and a custom filesystem.

Computer systems store data by encoding the data in a binary format and storing the binary data on a storage device. Storage devices may include hard disks optical media flash media and the like. A computer operating system may be used to control the physical storage and retrieval operations of the storage device. Similarly filesystem software may be used to logically organize the encoded data in files and directories on the storage device. The filesystem may be provided as part of the computer operating system or may be a separate software component that interfaces with the computer operating system. In either instance the filesystem provides a logical interface between software programs executed by the computer and the corresponding storage device.

Existing filesystems suffer from a number of problems which may result in the inefficient use of computer and network resources. For example many users may not need access to all of the files available through the filesystem on a regular basis. Rather many users may need access to only a subset of the available files. However existing filesystems present the user with a large amount of unnecessary file and directory information that effectively obscures the file and directory information the user is trying to obtain. In an attempt to address this problem personal subdirectories may be created by the user through the filesystem to store personal files. This allows the user to store personal files in an identifiable location.

Although a user may use personal directories to organize non executable data files that are created and accessed by various software applications personal directories do not readily lend themselves to management of the actual software application packages that are run by the user. As a result software application packages often are installed for multi user access on one or more common storage devices. A system administrator may install an upgrade and or make changes to a software application package using the appropriate common storage device to make the upgrade changes accessible to all system users.

In this common storage device configuration system users may modify or inadvertently damage files used in the execution of one or more software application packages. In the case of modifications the modifications to a file may be useful to one group of users while other users may need access to the original version of the file. User specific configuration of a software application package may be difficult to implement if at all in such circumstances. When certain files are inadvertently damaged by a user the software application package will no longer be accessible to the remaining system users. Consequently it may be difficult to maintain an operational version of the software application package without placing substantial limitations on the interaction between the users and the software application.

Another file management problem relates to the administration of multiple versions of a software application package. When a network administrator attempts to perform a system wide upgrade of a software application package it may not be desirable or possible for all of the user systems on the network to operate with the new version. For example different versions of a software application package may be distinct and rely on separate software components such as executable files libraries patches support files and the like. Consequently the software components of a particular version of a software application package may be incompatible with legacy software or hardware that is found on certain user systems. Further a user may refuse to learn how to operate a new version of a software application package particularly if it offers minimal advantages to the user over a prior version. Finally a system administrator may anticipate problems with the removal of an older version of a software application package from one or more of the user systems.

Access to multiple versions of the same software application may be necessary to accommodate one or more of the foregoing situations. Again existing filesystems present the user with a large amount of unnecessary file and directory information relating to the multiple versions of the software packages. The presence of this unnecessary file and directory information effectively obscures the particular software application versions that the user attempts to access.

A computer system having a computer a custom filesystem and a real filesystem is disclosed. The custom filesystem is comprised of virtual files that may be mapped to a subset of real files of the real filesystem. The custom filesystem may provide an arrangement of the virtual files to a user through the user interface. This limited arrangement may present the virtual files in a hierarchical arrangement that may be easily navigated and customized for a particular computer group of computers computer user or group of computer users. The custom filesystem may maintain its own metafile information for the virtual files.

The type of metafile information maintained by the custom filesystem and the way in which file requests are handled by the computer system may vary. The metafile information may indicate whether a file request associated with a particular virtual file is to be directed to the real file of the real filesystem or to a spilled file. The custom filesystem may process requests associated with the subset of real files prior to processing of the request by the real filesystem.

The computer system may comprise a configuration file that identifies one or more attributes associated with the computer or a computer user. The attributes identified by the configuration file may include a location of at least one package repository on the real filesystem a location of at least one software package on the real filesystem where the software package is identified for access by the computer system through the custom filesystem a location for a root directory at which the custom filesystem is to be mounted and or a location for a spill directory root that is to be used by the custom filesystem for storage of files modified using the computer system.

Other systems methods features and advantages of the invention will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the invention and be protected by the following claims.

The network may include a number distinct filesystems that cooperate to establish an overall file management system. To this end each of the computer systems includes a local filesystem that provides access to the actual files that are locally stored on storage device . Server filesystems may be used to access the actual files that are remotely stored at one or more of the servers such as at data storage devices . Each computer system also includes a custom filesystem that is logically interposed between a user of the terminal and the local filesystem . Alternatively the custom filesystem may be logically interposed between the user of the terminal and one or more of the server filesystems . In a still further alternative configuration the local filesystem may be logically interposed between the custom filesystem and one or more of the server filesystems . As will be set forth below the custom filesystem includes virtual files that correspond to a selected subset of actual files located in the local filesystem and or server filesystems . When a file request relating to one of the virtual files is received by the custom filesystem the custom filesystem handles the request prior to handling of the request if any by the local filesystem and or server filesystems whichever filesystem contains the actual file.

A logical representation of the actual files and directories that for example make up one of the server filesystems is shown in . The computer system in this example does not employ a custom filesystem and consequently all of the actual files of the server filesystem are presented and accessible by the user. For exemplary purposes three software packages are shown in a drawing subdirectory of the server filesystem first and second versions of a drawing package draw1.4 and draw2.0 respectively and a format converting package convert2.2 . Related files are also stored in this subdirectory software tool sets for the two drawing packages drtools1.4 and drtools2.0 a software patch for the first drawing package drpatch1.4 and a font set for the second drawing package drfont2.0 . As software applications often comprise dozens of files that are installed in numerous subdirectories management of these files can be complex.

An example of a set of subdirectories in server filesystem for the software application of draw1.4 is shown in . For the sake of simplicity the two higher levels in the hierarchical file directory structure main and drawing are not shown. As illustrated this exemplary software application package has two top level directories named bin and etc that are platform independent. Shell scripts and the like may be stored in the bin subdirectory while configuration files and the like may be stored in the etc subdirectory. The exemplary software application package also may include three top level directories that are hardware architecture platform dependent x86 mips and ppc. In the exemplary platform specific files the CPU type is encoded as part of the pathname. For example x86 specific binaries are included in the pathname x86 bin. The balance of the identified directories store related files required by the draw1.4 application. Both the mips and ppc subdirectories may have similar structures to that of the x86 subdirectory.

The custom filesystem may limit user access to only a subset of the files and software that would otherwise be accessible directly through the local filesystem and or the server filesystem . This limited access ensures that a given computer system only accesses and executes software packages that are needed for example by the corresponding user . Whether a computer system is to have access to a subset of the software and or files otherwise available through the local filesystem and or server filesystem may be determined by storing the proper parameters in a node configuration file for the given computer system . The node configuration file may be automatically or manually configured based on attributes of the system and for example may be stored on the data storage device of the respective system . Each system may have its own node configuration file. Alternatively multiple computer systems may share the same node configuration file or otherwise have identical node configuration files.

At the level shown in the custom filesystem presents two directories and their corresponding files. These directories and files constitute virtual links to the two software applications that the computer system is to access convert2.2 and draw1.4 . As such only directories and their corresponding files are exposed by the custom filesystem for access by the user instead of the seven subdirectories that include all three software applications per . If for example the system has a x86 processor these two sub directories may be linked to their respective locations in the server filesystem in the manner shown sub directory draw being linked to main drawing draw1.4 x86 bin and sub directory convert being linked to main drawing convert2.2 x86 bin. The user interface to the selected software applications is simplified by the custom filesystem since extraneous information relating to other files and applications that the user will not generally access has been removed. Furthermore when the computer system is upgraded for example to another version of the draw software i.e. draw2.0 a system administrator can easily implement the upgrade by changing the node configuration file used by the computer system . For example the node configuration file may be changed to link an existing virtual file of the custom filesystem to the location of the new software version in the server filesystem so that the computer system is re directed by the custom filesystem to execute the new software version. Alternatively the node configuration file identifying the prior version of the software application package may be replaced with a new configuration file identifying the upgraded version of the software application package. Still further the virtual files linked into the custom filesystem may remain static while the actual files corresponding to the links may be updated. In each instance the user is provided with a consistent customized user interface.

Both processor specific and non processor specific files may be included in the same sub directory or folder of the custom filesystem . For example the sub directory in labelled convert may be linked to both the x86 processor specific files at main drawing convert2.2 x86 bin and to the more general files in sub directory main drawing convert2.2 bin.

The custom filesystem cooperates with one or more real filesystems such as local filesystem and or server filesystems so that file requests relating to files of the custom filesystem are redirected by the custom filesystem to the corresponding locations of real files through the real filesystem or as will be described in further detail below to a spill directory. Implemented in this manner the custom filesystem may be realized on any computer system that allows file re direction.

The foregoing system is particularly well suited for selecting which software application packages in one or more software application repositories are to be accessible by a particular computer system . In the following examples a software application package may be comprised of a number of files and directories that are related to one another by virtue of being part of a software product or of a particular software product release. Software packages may be considered immutable read only objects. Each software package may include a software package manifest file that describes various aspects of the corresponding software package including a list of the files within the software package the locations where each of the files of the package will be or are already installed a description of the software package any special requirements that the package may have other software packages on which the software package depends and any scripts that are to be executed when the package is installed or uninstalled. The software package manifest may be generated by the authors of the software and may be provided as one of the files of the software package file. A patch to an operating system or software program might contain only selected files and documentation correlating with the files that have changed and likewise may be considered a software package.

The location at which a software package is installed on the system is called a repository. The system may include numerous software package repositories. These repositories may be located for example on one or more of the servers so that a given software package may be accessed by multiple users using the respective computer systems .

An exemplary routine for setting up a node configuration file is shown in . At step attributes associated with the computer system node are identified. The attributes may include static characteristics of the system and or dynamic attributes. Static characteristics may include attributes such as the microprocessor model and operating system platform. Dynamic attributes may include characteristics that are based on the configuration of one or more of the servers . For example dynamic attributes may identify the software packages that are to be accessible by the computer system through the custom filesystem the locations of the software package repositories the version of a given software package that is to be made accessible identification of the root directory at which the custom filesystem is to be mounted and the location of the spill directory that is to be used by the custom filesystem .

The attributes associated with the computer system may be ascertained and or provided at step in a number of different manners. For example static attributes such as the microprocessor model operating system platform BIOS version clock speed installed memory hardware devices drivers and configurations such as sound video and modem cards and the like may be identified using standard automatic system query techniques. Some dynamic attributes such as which version of a software package is to be through the custom filesystem may be determined automatically by comparing information in the software package manifest with one or more of the static attributes. This operation likewise may be executed manually by editing the node configuration file directly or through a corresponding node configuration file utility. Decisions on other dynamic attributes such as which software packages are to be accessible at the computer system may be made based on the preferences of a system administrator and or user . Again entry of the desired information into the node configuration file may be automated achieved through direct editing of the file and or through the use of a node configuration file utility.

Once the static and dynamic attributes associated with the particular computer system are known the attributes are stored in the node configuration file at step . The node configuration file may be stored locally at the computer system or remotely such as on one of the servers .

One manner in which a custom filesystem may be generated using the information contained in the node configuration file is illustrated in . The operations used to generate the custom filesystem may be automatically executed at boot time. Alternatively the operations may be executed as part of a stand alone configuration program that may be executed at any time by the user or system administrator.

As shown the computer system reads the corresponding node configuration file at step . The node configuration file may include information identifying the location at which the custom filesystem is to be mounted. For example the custom filesystem may be mounted at step by mapping it into an existing directory structure of the local filesystem called the mount point. Once the custom filesystem is mounted at a given mount point the files and directories of the custom filesystem may be accessed as if they are contained in the directory serving as the mount point. Mount points may be empty directories since the contents of the directory serving as a mount point may become inaccessible to the local filesystem while the custom filesystem is mounted.

Once the custom filesystem has been mounted the computer system determines whether the spill directory identified in the node configuration file exists in the local filesystem or server filesystem . If the spill directory exists the spill directory is mapped into the custom filesystem at step . If it does not exist the spill directory is created and subsequently mapped into the custom filesystem .

As noted above the node configuration file may include information identifying the software packages that are to be accessible to a user of a computer system through the respective custom filesystem . These software packages are identified from the node configuration file at step . For each software package listed in the node configuration file the system locates the software package in the corresponding package repository identified by the node configuration file at step . The package manifest file is used at step to determine whether any additional software packages need to be added to the list to render the software package complete. At step each file used by the software package as identified in the package manifest file is mapped from the server filesystem and or local filesystem into the custom filesystem . Because the custom filenames used in the custom filesystem are linked to a real filesystem special tools or modifications to the real filesystem are not necessarily required. Linking between the custom filesystem and the real filesystem may comprise the generation of virtual files symbolic links or the like in the custom filesystem that correspond to actual files in the real filesystem. Various mapping methods may be employed.

Any macros dynamic components that can be resolved before the software package is used may be resolved at step . The processing shown at steps through may continue until all of the software packages that have been identified for access in the node configuration file have been mapped into the custom filesystem at step .

Upon completion of the operations shown in the custom filesystem becomes active and is capable of handling file requests. Instructions now can be entered that refer to files on the custom filesystem. The instructions may be entered for example through a graphical user interface a command line interface or by another software program. Consequently it may not be necessary to implement API application programming interface changes. If an instruction is received that does not refer to a file managed by the custom filesystem regular execution of the instruction may be undertaken by one of the real filesystems. The custom filesystem may be bypassed to access the real filesystems so that all files that are accessible through the real filesystems may be viewable by the user if desired. Bypassing of the custom filesystem may be an option that is selectable by the user or an option that is designated by the system administrator using the node configuration file.

The operations presented in are exemplary and various implementations may have additional or different steps which would follow logically from this example. In the illustrated examples the system may determine which files software packages and or software versions appear on the custom file system. To this end as new software applications are added to the file system a smaller and simpler routine can be performed that cycles through steps . Similarly additional steps may be added to those shown in . For example steps may be added to prompt the user or query system as to the suggested filename or path name for a given software application or package. This may be used to generate a more succinct or logical file hierarchy from the user s or system s perspective.

One manner in which the custom filesystem may respond to various types of file requests is shown in connection with . As shown in the custom filesystem is initialized at step . Initialization of the custom filesystem may proceed in a manner shown in . Once initialized the custom filesystem may enter an idle mode in which it waits for file requests from the respective system.

When the system attempts to load an executable program modify a file or read a file a request to that effect is generated and received by the custom filesystem at step . On all requests the custom filesystem verifies that the subject file is managed as part of the custom file system at step . If the file is not valid an error message or similar action is taken at step and control returns to step to await further requests. In one exemplary system any failed search for a filename may fall through to another file system that is lower in the filesystem hierarchy.

If the file name is valid on the custom filesystem the custom filesystem checks to determine whether the state of the file is known. There may be any number of states for a given file. In the exemplary system shown in three files states are employed unknown spilled and normal. Other states also may be used. For example a file state of cached may be used to indicate that a local copy of a file is available so it is not necessary to access a copy of the file over the network.

Initially the states of all files of the custom filesystem may be marked as unknown. As each file is accessed a query may be made at step to determine whether the state of the file is known. If the state of the file is unknown it may be updated at step depending on the type of file request received at step . When a request has been made to modify or change the metadata associated with a target file the custom filesystem redirects the file request to a corresponding copy of the file in a predetermined spill directory. The spill directory may be one of the parameters identified in the node configuration file. This same redirection process may be followed if the state of the file is spilled. If the state of the file is normal the file request may be redirected to the corresponding original file through the matching real filesystem. In this example the state of the file affects the location that the custom filesystem uses to redirect the file request.

At step of the custom filesystem checks to see if the state of the target file indicates that the target file has been spilled. If the target file has been spilled the custom filesystem directs the file request to the location of the corresponding copy of the spilled file in the spill directory at step . Spilled files are treated differently from other file types by the custom filesystem . Generally the custom filesystem treats all original files as read only to protect their integrity. These files may be located on one or more servers with multiple systems concurrently accessing the same files. However it may be desirable at some point to customize files for use by an individual system . Customization of such files may be implemented using a spill directory. To this end the node configuration file contains a field identifying a spillroot directory that serves as the root of the spill file locations. If no spillroot is present the corresponding system is blocked from modifying files and may only operate in a read only mode. A file that has been modified through the custom filesystem may be copied to a location within the spillroot directory hierarchy while the corresponding file on for example the server remains in its original state. The custom filesystem redirects subsequent file requests associated with the spilled file to the copied version in the spillroot directory as shown at step . This allows the system or software which is operating to modify a file without damaging or altering the original file which may be shared by a multitude of other systems.

In the illustrated example there are three basic types of file requests that may be made by a system read requests write requests and status requests. These request types branch from the case statement at step and are shown at nodes B C and D respectively. A read request occurs when the system attempts to access the contents of the target file without modification of the file contents. A write request occurs when the system attempts to access and modify the contents of the target file. A status request occurs when the system attempts to access the metadata for the target file to determine permissions owner access time or similar information.

On a read request process control passes through the case statement of step to branch B of . At step the custom filesystem redirects the read request to the real filesystem that contains the target file based on the mapping for the custom filesystem generated for example at step of . The read request is executed at step and the results are provided through custom filesystem from the corresponding real filesystem .

In order to maintain high throughput subsequent read requests for a target file may be sent directly to the real filesystem that contains the original version of the target file. This may be advantageously used in connection with updates and changes since the custom filesystem configuration may change after the initial open for a read operation has been executed. As long as programs have opened up references to this file they can continue to access it. When the target file is removed from the custom filesystem further re direction may be terminated. In the meantime a new version of the file may be accessible thereby facilitating field updates and updates of critical running software without system downtime.

When a write request is received process control may pass to branch C of . At step the custom filesystem marks the state of the target file as spilled. If a suitable spill directory for copying the target file does not exist a directory is created at step . The newly created directory may mimic the attributes of the directory containing the original target file. The target file may be copied to the spill location as shown at step . Once the copy operation is completed the write request may be directed to the copy of the target file contained in the spill location as shown at step . Subsequent file requests relating to the original target file are directed by the custom filesystem to the copy of the target file contained in the spill location.

On a status request to gather metadata process control may pass to branch D of . At step the custom filesystem accesses metadata information relating to the target file and returns the information to the requester via the custom filesystem. The custom filesystem may maintain its own metadata files for the virtual files that it manages. Alternatively the custom filesystem may itself access the metadata information from the original target file in response to the status request. In such instances the custom filesystem does not perform a file re direction. Rather the custom filesystem performs the request directly on behalf of the system .

Executing status requests in this manner has several advantages. For example it provides an additional layer of caching resulting in a performance increase for status request operations. Further it provides a mechanism in the custom filesystem that may be used to obtain additional information contained in the package description files. The recovery of a spilled file to restore it to its original state may take advantage of this feature. Version information about files utilities and packages could also be referenced this way.

Occasionally a file request is made to change the metadata for a target file. In such instances the custom filesystem makes the requested modifications and then treats the request the same as an open for writing request spilling the file to the appropriate spill directory along with the updated metafile information. As in the case for a write request any further accesses associated with the spilled file will be re directed to the version in the spill location.

While file requests may be optimized to redirect access from the custom filesystem directly to the package location of the original file directory accesses may be executed in a different manner. When a directory entry is opened it can only be for reading to obtain a listing of the names of the files in or meta data information about the directory.

Although the custom filesystems have been described in connection with individual computer systems each custom filesystem may be associated with any identifiable entity or entities on the computer network . Depending on the computing environment these entities may include for example users clients computers systems nodes and the like. In a personal computer PC environment the custom filesystem may be associated with individual users or as described above with individual computer systems .

In an environment with a variety of different machines and operating systems such as the variety often found in a distributed computing environment the combined custom filesystem and local filesystem cooperate to optimize network operation by routing requests for software to the proper machine binaries. For example the computer network may be implemented in an environment with QNX and or Neutrino machines. Machines running these operating systems have the ability to transparently interact and communicate tasks to one another. By using custom filesystems on these machines communication between these machines may be implemented even in those instances in which the machines and files are located in totally different filesystems.

Still further management of the software applications used in the computer network may be simplified. For example one computer system might be a computer with an x86 microprocessor running with a graphic user interface GUI Photon version 1.14 patch level A and an operating system Neutrino version 2.00 while another node might be a PowerPC computer running Photon version 1.14 with no patch level applied and Neutrino version 2.00. Since these computers have different CPU types different types of executable files are required in the corresponding bin directories one set of x86 executables and one set of Power PC executables . Additionally different directory contents are required based on which version of the software is to run on the system and which patch levels are to be applied. A system administrator may maintain all software application packages on servers and provide access to selected versions of the software applications on a given computer system using the corresponding node configuration file. Upgrades to the existing software packages can be made on the servers without impacting the software that is run on a given computer system .

With the custom filesystem the computer system from the standpoint of the user is not cluttered and may be greatly simplified. The user is not confused by a number of different software versions and their respective libraries patches and support files because only the files pertaining to the configuration of the particular system are presented to the user through the custom filesystem. Providing this partial view of the complete filesystem removes complexity making it easier for users to access the information that is needed.

The file management system may be used to optimize testing and deployment of new software versions. To this end a proven version of the custom file system or its corresponding node configuration file may be stored prior to this testing and deployment. If the testing and deployment become problematic the stored file may be used to roll back the computer system to a known state. Alternatively an image of the custom filesystem when the custom filesystem is in a given state may be stored to facilitate subsequent roll back of the custom filesystem to the given state. The image file may be used to replace an existing custom filesystem that is experiencing problems.

While various embodiments of the invention have been described it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the invention. Accordingly the invention is not to be restricted except in light of the attached claims and their equivalents.

