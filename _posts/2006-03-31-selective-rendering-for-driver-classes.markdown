---

title: Selective rendering for driver classes
abstract: Described is a filtering mechanism/process that selectively controls whether graphics primitives are provided to a given driver. For example, graphics primitives of an accessibility (e.g., magnification) program may be excluded from being obtained by mirror drivers associated with the accessibility programs, so that the mirror drivers receive only the primitives of unmagnified windows. A registration mechanism allows a program to identify its window as being associated with a class of drivers for filtering, and the drivers may identify themselves as being of the class. By maintaining data that associates windows with a class of drivers, when graphics primitives associated with a registered window are received, a filtering operation be activated to determine which graphics primitives are provided to which driver or drivers. Filtering may be by exclusion to prevent certain primitives from being obtained by excluded drivers, or by inclusion whereby only included drivers receive certain primitives.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07619622&OS=07619622&RS=07619622
owner: Microsoft Corporation
number: 07619622
owner_city: Redmond
owner_country: US
publication_date: 20060331
---
A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Contemporary computer systems offer users the ability to magnify a portion of their display screen typically for providing visually impaired users with better accessibility to computers although also offering mainstream users the benefit of magnification in certain contexts. In general when the user runs a magnifier a magnification window is opened and the magnified content displayed in that window. The user can adjust the magnification window in size and position adjust the magnification level and possibly choose other effects e.g. color inversion. One such magnifier program operates by driver hooking to intercept graphics calls sent towards the video driver essentially in a screen capture operation where the magnifier program then scales up a corresponding graphics image in the magnification window.

Many existing accessibility applications generally used chained display drivers to implement magnifiers for example a Windows Driver model WDM chained display driver is a kernel mode video driver. Programs provided by accessibility or assisted technology vendors ATVs draw the magnifier window from the driver directly to the display device. This means that the driver s rendering primitives e.g. DrvXXX where Graphics DDI Device Driver Interface function names are in the DrvXxx form associated with the magnification window handle HWND are not present in the rendering stream intercepted by the chained display driver.

An alternative accessibility technology is described in U.S. patent application Ser. No. 11 180 859 filed Jul. 12 2005 assigned to the assignee of the present invention and hereby incorporated by reference which is among its aspects generally directed to a magnification engine and API application programming interface that renders a magnifier in software and or hardware. This API technology may be used in conjunction with a non chained driver model that instead uses accessibility mirror drivers that are attached to the primary display driver essentially as peers of the primary display driver rather than being above the primary display driver in the rendering path.

Many assistive technology products are combined magnifier screen reader products that will use mirror drivers and the magnification API. Such products as well as standalone screen readers are intended to be able to able to describe the area under a magnifier.

However regardless of whether rendered via software or hardware the full set of graphics primitives are present in the rendering stream that is sent to the primary display driver. As a result and because the magnifier window is generally topmost and layered accessibility code that is in the mirror drivers are unable to distinguish or locate which primitives for the screen are under the magnifier window. This results in an unacceptable blind spot problem in off screen models that is display models built from the primitives that are then used to provide actual display data.

By way of example the shift from chained display drivers to accessibility mirror drivers and the magnification API engine cause magnifier windows to obscure rendering information from accessibility applications such as screen readers. When this happens the screen readers cannot describe the screen content that is under a magnifier window. At an extreme if the magnifier was full screen the screen reader would not be able to read anything because of the above described blind spot problem.

This Summary is provided to introduce a selection of representative concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used in any way that would limit the scope of the claimed subject matter.

Briefly various aspects of the subject matter described herein are directed towards a filtering mechanism that selectively controls whether graphics primitives are provided to a given driver based on a window identifier associated with the graphics primitives a set of one or more registered windows and whether that given driver belongs to a particular class of drivers. In general a registration mechanism maintains registration information that is used to match window handles to a certain class of drivers.

By maintaining data that associates one or more windows with a class of drivers when graphics primitives associated with a window are received a filtering operation can determine which graphics primitives are provided to which driver or drivers. Filtering may be by exclusion to prevent certain primitives from being obtained by excluded drivers or by inclusion such that only included drivers receive certain primitives.

Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices tablet devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in local and or remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media described above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a tablet or electronic digitizer a microphone a keyboard and pointing device commonly referred to as mouse trackball or touch pad. Other input devices not shown in may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . The monitor may also be integrated with a touch screen panel or the like. Note that the monitor and or touch screen panel can be physically coupled to a housing in which the computing device is incorporated such as in a tablet type personal computer. In addition computers such as the computing device may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface or the like.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

An auxiliary display subsystem may be connected via the user interface to allow data such as program content system status and event notifications to be provided to the user even if the main portions of the computer system are in a low power state. The auxiliary display subsystem may be connected to the modem and or network interface to allow communication between these systems while the main processing unit is in a low power state.

Various aspects of the technology described herein are directed towards a technology that solves the blind spot problem by selective filtering out mechanism process that excludes the rendering primitives that corresponding to a class of driver such as an accessibility mirror driver. In general this is accomplished via a mechanism process that enables selective rendering and filtering based on window handles or the like. As will be understood selective rendering allows combined screen magnifiers and readers to operate as desired without implementing magnification rendering code in the display driver. Further with this technology multiple magnification surfaces may coexist e.g. one on top of the other and be correctly filtered out.

In one example implementation described herein selective filtering of accessibility mirror drivers is described in the example context of a Windows based operating system architecture. However as will be understood the present invention is not limited to accessibility mirror drivers or Windows based operating systems let alone any particular implementation or examples described herein. Instead numerous ways to implement the present invention are feasible. For example instead of filtering accessibility mirror drivers the mechanism described herein may selectively exclude essentially any driver or class of drivers can be from obtaining certain drawing primitives e.g. the filtering may be in effect for all drivers of a class of driver types such as accessibility mirror drivers or more granular including filtering based on the identities of individual drivers i.e. any class can correspond to as little as one driver . As such the present invention is not limited to any of the particular examples used herein but rather may be used various ways that provide benefits and advantages in computing in general.

Turning to of the drawings accessibility related programs such as magnifiers may include user mode programs such as a combined screen reader magnifier program a screen reader program a Braille program and or other such programs. While three such programs are represented in it is understood that this is only an example and a typical user may have anywhere from one to any practical number of such programs operating.

In the example of it is shown that the combined screen reader magnifier uses the magnification API engine as well as accessibility mirror driver technology such as via the mirror driver. In general accessibility mirror drivers generally allow accessibility technology vendors or the like to provide assistive technologies that work under a contemporary operating system e.g. Windows Vista driver model. The screen reader program and a Braille program are shown as using other mirror drivers e.g. one among . Moreover a magnifier application program is shown as using the magnification API engine to provide its magnification functionality.

For example a mirror driver e.g. may thus be associated with the screen reader and or a combined screen reader magnifier may be present. In general accessibility vendors use DrvXXX primitives to build an off screen model that is then used to describe objects on screen e.g. using a text to speech engine or a Braille output mechanism interface. Each accessibility vendor usually sends information from their off screen model back to user mode where their applications e.g. or are running such as represented in .

Thus as can be seen various types of programs may be implemented via the magnification API engine or implemented by using accessibility mirror drivers or by a combination both and these types may coexist. For a combined application such as the combined screen reader magnifier represented in one code path may correspond to calls the magnification API engine and another may implement an accessibility mirror driver e.g. .

With respect to magnifier filtering for programs using the magnification API engine in general the magnification API engine calls a register HWND function in e.g. in a user32 component such as User32p.lib to register a HWND for each magnification window of a set of one or more magnification windows to be registered. An example of one such method SetMagnifierWindow is described below and generally provides a way to enable or disable HWND based filtering. As the magnification API engine supports multiple clients filtering may be simultaneously enabled for multiple magnifier windows. In one implementation the magnification API engine may be granted private restricted access as an operating system component to HWND registration. Note that for lifecycle management of HWND filtering if a magnifier window is destroyed and the HWND is reused by another application window then filtering is automatically disabled for that reused HWND.

With respect to filtering for a class of accessibility mirror drivers in order to allow accessibility vendors to identify a driver as being of a type corresponding to an accessibility mirror driver an associated attribute such as a flag may be used to distinguish this class of drivers from other drivers. As described below magnifier HWNDs and their associated primitives are only filtered out from mirror drivers marked with this attribute flag. The following describes an example of one such flag 

In one implementation graphics primitive filtering takes place for all magnifier HWNDs for all properly flagged accessibility mirror drivers regardless of ownership e.g. if there are three magnifier HWNDs on the system and three drivers with a respective association each driver would have the primitives of all three magnifier windows filtered out of its rendering stream. Such drivers would thus see only the primitives that render the screen graphics as if the magnifier windows were not active e.g. to allow an off screen model to be built. In alternative implementations filtering may be more granular e.g. filtering could be such that each driver would have the primitives of some subset of the magnifier windows filtered out of its rendering stream e.g. its own primitives only.

It should be noted that in general filtering is only performed for layered top level windows and HWNDs are only associated with layered top level windows. Because layered windows are required to be top level windows the use of layered top level windows is effectively an over determination of the window properties. If a window is not marked as layered then this changes the clip region of the applications that are under the magnifier. If filtering was performed on non layered windows accessibility mirror drivers would not see the calls for clipped regions of the underlying applications even if the magnifier calls above it were filtered out.

Turning to an explanation of registration in the example represented in consider a filtering mechanism for a magnifier application to mirror driver. The magnifier application calls CreateWindowEx and sets the window to be layered which are typical operations. The magnifier application then passes the HWND to the magnification API engine . In turn the magnification API engine registers the HWND for the magnifier window and enables filtering via a function SetMagnifierWindow exposed privately via the User32 component . In the example implementation this function maps to an NTUser function NTUserSetMirrorRendering exposed by a system driver e.g. Win32k.sys as described below. The NTUser function NTUserSetMirrorRendering activates filtering code in the system driver e.g. Win32k.sys such as in its sprite layer .

With respect to filtering operations whenever the sprite layer is about to draw an update to sprites that are associated with the registered HWNDs and attached to an accessibility mirror driver e.g. properly flagged as such the sprite layer checks a table or the like that it maintains to associate HWNDs with drivers recall that as described above each accessibility mirror driver has identified itself as such e.g. by implementing the specified GCAPS flag . If the HWND is registered for filtering the sprite layer ignores the update that is does not provide the primitives to the accessibility mirror driver or drivers associated with the HWND. This has the effect that the accessibility mirror driver receives the DrvXXX rendering primitives excluding those that are associated with magnifier HWNDs. Note that the association information may be maintained in essentially any way that is appropriate for example in a straightforward implementation where all mirror drivers are excluded for any registered HWND only two sets of data need be maintained the HWND s and the associated driver s to be excluded. More elaborate mappings may for example associate only certain HWND s with only certain drivers and there may be any number of such mappings.

Turning to an explanation of rendering as also represented in alternative rendering paths from the magnification API engine to the kernel mode display driver may be used. In general the magnification API engine checks to see if it can open the graphics stream which is essentially an LPC channel to the media integration layer MIL composition engine . If a connection to the graphics stream cannot be opened magnification is implemented via the Win32k.sys system driver e.g. via GetDC null and StretchBlt as described below.

If a connection to the graphics stream can be opened magnification is implemented using the composition engine in either software or hardware rendering mode. More particularly hardware rendering may occur when the magnifier window is not a layered window and other hardware requirements to compose in hardware are met. If so the magnifier window will be rendered in hardware as a windowed Dx application. The composition engine uses DxgKernel interfaces to draw to the kernel mode display driver .

Software rendering is instead used by the composition engine when the magnifier window is a layered window or other hardware requirements to compose in hardware are not met. In such a situation the magnifier window is rendered in software to a surface which is composited by the GDI sprite layer in the system driver e.g. Win32k.sys as generally described above.

In a situation where a connection to the graphics stream cannot be opened the system driver e.g. Win32k.sys calls DrvXXX functions implemented by a canonical display driver CDD . The canonical display driver essentially implements a Windows XP type device driver interface calls GDI support services in the system driver Win32k.sys to render and then draws to the display driver via DxgKernel . Note that the canonical display driver DxgKernel and the display driver are a secure path. Further note that the canonical display driver essentially insulates other e.g. Windows Vista type driver model display drivers from having to implement the Windows XP type device driver interface and eliminate the need to avoid modifying Win32k.sys to work with a Dx interface which other e.g. Windows Vista type driver model display drivers support.

Steps and represent the disabling operation which is essentially similar. One additional error may be an attempt to de register an HWND that was not registered.

While the above examples primarily focused on selective filtering for magnification purposes and the like it should be noted that selective filtering for other applications may also be used. For example for security purposes certain drivers may be prevented via filtering e.g. particularly via inclusion filtering i.e. only included drivers will receive a window s primitives from receiving the primitives corresponding to another window. For example a window may specify that only a certain driver e.g. digitally signed can receive its primitives. Note that filtering may need to be performed in locations other than in the system driver to enforce such filtering.

The magnification API will call this function to register a magnifier HWND and enable or disable filtering for the HWND.

If the function fails the return value is zero. The function should fail if the HWND references a window that is not marked with the layered window style and or if the HWND references a non top level window such as a child window. This rolls up into the previous condition since non top level windows cannot be marked as layered windows.

The function is exposed privately via User32p.lib. The magnification API is an operating system component.

This function can be called multiple times to register more than one HWND. This enables the usage scenario of multiple magnifier windows since filtering will be performed for all such magnifier windows. If a call is made to register an HWND that has previously been registered the call should succeed if all other success conditions apply. This is plausible scenario since HWNDs can be reused by the system.

This function may be called by SetMirrorRendering depending on the bSetFilter argument that is when disabled .

This function is called by SetMirrorRendering depending on the bSetFilter argument that is when enabled .

Drawing for layered windows is handled in the sprite layer. The sprite layer code ignores updates to a sprite if the sprite is attached to an accessibility mirror driver. The sprite HWND needs to be marked as an accessibility HWND 

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

