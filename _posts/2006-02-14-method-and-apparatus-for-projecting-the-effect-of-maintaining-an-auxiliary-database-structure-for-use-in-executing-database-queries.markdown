---

title: Method and apparatus for projecting the effect of maintaining an auxiliary database structure for use in executing database queries
abstract: A database management system maintains a record of queries which can be executed against the database. For a given auxiliary database structure, an advisory function automatically reviews the query record and identifies those queries which might execute with greater efficiency using the auxiliary database structure, presenting analytical information to the user. Preferably, the auxiliary database structure is an index, and the information is used for determining whether to include the index in the database definition. Preferably, a query optimizer records potentially useful indexes when considering multiple alternative database optimizations, and this information is later retrieved to identify queries which would benefit from an index.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07743052&OS=07743052&RS=07743052
owner: International Business Machines Corporation
number: 07743052
owner_city: Armonk
owner_country: US
publication_date: 20060214
---
The present invention is related to U.S. patent application Ser. No. 11 239 617 filed Sep. 29 2005 entitled CONTINUAL GENERATION OF INDEX ADVICE which is herein incorporated by reference.

The present invention relates generally to digital data processing and more particularly to the generation and execution of database queries in a digital computer system.

In the latter half of the twentieth century there began a phenomenon known as the information revolution. While the information revolution is a historical development broader in scope than any one event or machine no single device has come to represent the information revolution more than the digital electronic computer. The development of computer systems has surely been a revolution. Each year computer systems grow faster store more data and provide more applications to their users.

A modern computer system typically comprises hardware in the form of one or more central processing units CPU for processing instructions memory for storing instructions and other data and other supporting hardware necessary to transfer information communicate with the external world and so forth. From the standpoint of the computer s hardware most systems operate in fundamentally the same manner. Processors are capable of performing a limited set of very simple operations such as arithmetic logical comparisons and movement of data from one location to another. But each operation is performed very quickly. Programs which direct a computer to perform massive numbers of these simple operations give the illusion that the computer is doing something sophisticated. What is perceived by the user as a new or improved capability of a computer system is made possible by performing essentially the same set of very simple operations but doing it much faster. Therefore continuing improvements to computer systems require that these systems be made ever faster.

The overall speed at which a computer system performs day to day tasks also called throughput can be increased by making various improvements to the computer s hardware design which in one way or another increase the average number of simple operations performed per unit of time. The overall speed of the system can also be increased by making algorithmic improvements to the system design and particularly to the design of software executing on the system. Unlike most hardware improvements many algorithmic improvements to software increase the throughput not by increasing the average number of operations executed per unit time but by reducing the total number of operations which must be executed to perform a given task.

Complex systems may be used to support a variety of applications but one common use is the maintenance of large databases from which information may be obtained. Large databases usually support some form of database query for obtaining information which is extracted from selected database fields and records. Such queries can consume significant system resources particularly processor resources and the speed at which queries are performed can have a substantial influence on the overall system throughput.

Conceptually a database may be viewed as one or more tables of information each table having a large number of entries analogous to rows of a table each entry having multiple respective data fields analogous to columns of the table . The function of a database query is to find all rows for which the data in the columns of the row matches some set of parameters defined by the query. A query may be as simple as matching a single column field to a specified value but is often far more complex involving multiple field values and logical conditions. A query may also involve multiple tables referred to as a join query in which the query finds all sets of N rows one row from each respective one of N tables joined by the query where the data from the columns of the N rows matches some set of query parameters.

Execution of a query involves retrieving and examining records in the database according to some search strategy. For any given logical query not all search strategies are equal. Various factors may affect the choice of optimum search strategy and the time or resources required to execute the strategy.

For example one of the factors affecting query execution is the sequential order in which multiple conditions joined by a logical operator such as AND or OR are evaluated. The sequential order of evaluation is significant because the first evaluated condition is evaluated with respect to all the entries in a database table but a later evaluated condition need only be evaluated with respect to some subset of records which were not eliminated from the determination earlier. Therefore as a general rule it is desirable to evaluate those conditions which are most selective first. Query execution may be affected by other and additional factors.

In particular query execution can be significantly affected by the use of certain auxiliary database structures. An auxiliary database structure is a structured collection of information derived from one or more tables of the database which may be used to more efficiently execute a database query. One well known type of auxiliary database structure is an index. An index is conceptually a sorting of entries in a database table according to the value of one or more corresponding fields columns . If a query includes an indexed value as a condition it may be advantageous to use the index to determine responsive records rather than examine each record in the applicable table.

Auxiliary database structures such as indexes are typically defined by a database designer administrator or similar person. A well designed database typically contains various auxiliary database structures to support query execution or for other purposes. Once defined these structures are automatically maintained by database management software as changes are made to the underlying database records.

To support database queries large databases typically include a query engine which executes the queries according to some automatically selected search execution strategy using the known characteristics of the database and other factors. Some large database applications further have query optimizers which construct search strategies and save the query and its corresponding search strategy for reuse. In such systems it may be possible to construct and save multiple different query execution strategies for a single query.

Where an auxiliary database structure such as an index exists and is useful in executing a query a query optimizer may construct an execution strategy to take advantage of the existing auxiliary database structure as a shortcut to executing the query. However in many complex queries it is desirable or essential to employ some auxiliary database structure in executing the query but no such defined auxiliary database structure already exists. The optimizer will generally choose an alternative execution strategy which does not require the auxiliary database structure and which may consume significantly more resource. In these cases the query optimizer may generate an execution strategy which itself constructs the needed auxiliary database structure as a temporary object for use in executing the query but this also involves further expenditure of resource.

While there are obvious benefits to maintaining auxiliary database structures the maintenance of such structures is not free. Every auxiliary database structure which is defined by the database designer for supporting queries and the like must be maintained concurrently with the data in the database tables i.e. as updates to database table records are made the applicable auxiliary database structure or structures must likewise be updated so that the data contained therein agrees with the underlying data in the database tables from which it was derived. Updating numerous auxiliary database structures is a significant overhead cost of maintaining a database. As more auxiliary database structures are added to the database definition this overhead burden increases. For these reasons an auxiliary database structure should not be defined to the database unless the resource savings from query execution or other functions which use the auxiliary database structure is sufficiently large to justify the overhead cost of maintaining the auxiliary database structure.

If a database designer administrator or similar person is presented with a hypothetical or actual auxiliary database structure for inclusion in a database definition it is difficult to predict the effect of the presence of such an auxiliary database structure on query execution performance and therefore difficult to determine whether the overhead burden of the auxiliary database structure will be justified. Although not necessarily recognized in the art a need exists for improved techniques for determining auxiliary database structures for inclusion in the definition of a database an in particular a need exists for techniques for projecting the effect of the presence of an auxiliary database structure on query execution performance.

A database management system for a structured database maintains a record of queries which can be executed against the database. For a given actual or hypothetical auxiliary database structure an advisory function automatically reviews the query record and identifies those queries in the query record which might execute with greater efficiency using the auxiliary database structure. This information might be presented directly to a user or used as a basis for further automated analysis which is presented to a user. Preferably the information is used for determining whether to include the auxiliary database structure in the database definition.

In the preferred embodiment a query optimizer function in the database management system automatically generates multiple potential query execution strategies plans and selects a best strategy for use. In some cases a potential strategy is not selected because it would require an auxiliary database structure which is not present and would be too expensive to generate for temporary use. In other cases a potential strategy which generates an auxiliary database structure for temporary use is selected notwithstanding the cost of generating the structure. Either event is recorded in the record of database queries called a plan cache . By retrieving and analyzing these events an advisory function can determine which queries are likely to benefit from the presence of an auxiliary database structure and present this data to the user. Optionally the data presented to the user can be further refined to automatically generate additional data from the identification of specific queries. For example as an optional enhancement an advisor can automatically determine the frequency of execution of each affected query automatically estimate a cost saving from implementing an auxiliary database structure for each affected query and so forth.

In the preferred embodiment the auxiliary database structure is an index and is described as such in the detailed description which follows. However it will be understood that other auxiliary database structures or auxiliary database structures in addition to indexes might alternatively be the subject of analysis according to the present invention.

By automatically determining those queries which might benefit from the presence of an actual or hypothetical database structure a database designer administrator or similar user has useful information for making the decision to include an auxiliary database structure in the database definition. Providing the user with better information concerning the effect of inclusion of the auxiliary database structure enables the user to make more informed design decisions including such auxiliary database structures as are justified by the query execution cost savings and not including those structures which would not be expected to provide sufficient query execution cost savings. These more informed design decisions improve the overall performance efficiency of the database.

The details of the present invention both as to its structure and operation can best be understood in reference to the accompanying drawings in which like reference numerals refer to like parts and in which 

Referring to the Drawing wherein like numbers denote like parts throughout the several views is a high level representation of the major hardware components of a computer system for use in generating and executing database queries and automatically projecting the effect of including an actual or hypothetical auxiliary database structure in the database definition according to the preferred embodiment of the present invention. CPU is at least one general purpose programmable processor which executes instructions and processes data from main memory . Main memory is preferably a random access memory using any of various memory technologies in which data is loaded from storage or otherwise for processing by CPU .

One or more communications buses provide a data communication path for transferring data among CPU main memory and various I O interface units which may also be known as I O processors IOPs or I O adapters IOAs . The I O interface units support communication with a variety of storage and I O devices. For example terminal interface unit supports the attachment of one or more user terminals . Storage interface unit supports the attachment of one or more direct access storage devices DASD which are typically rotating magnetic disk drive storage devices although they could alternatively be other devices including arrays of disk drives configured to appear as a single large storage device to a host . I O device interface unit supports the attachment of any of various other types of I O devices such as printer and fax machine it being understood that other or additional types of I O devices could be used. Network interface supports a connection to an external network for communication with one or more other digital devices. Network may be any of various local or wide area networks known in the art. For example network may be an Ethernet local area network or it may be the Internet. Additionally network interface might support connection to multiple networks.

It should be understood that is intended to depict the representative major components of system at a high level that individual components may have greater complexity than represented in that components other than or in addition to those shown in may be present and that the number type and configuration of such components may vary and that a large computer system will typically have more components than represented in . Several particular examples of such additional complexity or additional variations are disclosed herein it being understood that these are by way of example only and are not necessarily the only such variations.

Although only a single CPU is shown for illustrative purposes in computer system may contain multiple CPUs as is known in the art. Although main memory is shown in as a single monolithic entity memory may in fact be distributed and or hierarchical as is known in the art. E.g. memory may exist in multiple levels of caches and these caches may be further divided by function so that one cache holds instructions while another holds non instruction data which is used by the processor or processors. Memory may further be distributed and associated with different CPUs or sets of CPUs as is known in any of various so called non uniform memory access NUMA computer architectures. Although communications buses are shown in as a single entity in fact communications among various system components is typically accomplished through a complex hierarchy of buses interfaces and so forth in which higher speed paths are used for communications between CPU and memory and lower speed paths are used for communications with I O interface units . Buses may be arranged in any of various forms such as point to point links in hierarchical star or web configurations multiple hierarchical buses parallel and redundant paths etc. For example as is known in a NUMA architecture communications paths are arranged on a nodal basis. Buses may use e.g. an industry standard PCI bus or any other appropriate bus technology. While multiple I O interface units are shown which separate buses from various communications paths running to the various I O devices it would alternatively be possible to connect some or all of the I O devices directly to one or more system buses.

Computer system depicted in has multiple attached terminals such as might be typical of a multi user mainframe computer system. Typically in such a case the actual number of attached devices is greater than those shown in although the present invention is not limited to systems of any particular size. User workstations or terminals which access computer system might also be attached to and communicate with system over network . Computer system may alternatively be a single user system typically containing only a single user display and keyboard input. Furthermore while the invention herein is described for illustrative purposes as embodied in a single computer system the present invention could alternatively be implemented using a distributed network of computer systems in communication with one another in which different functions or steps described herein are performed on different computer systems.

While various system components have been described and shown at a high level it should be understood that a typical computer system contains many other components not shown which are not essential to an understanding of the present invention. In the preferred embodiment computer system is a computer system based on the IBM i Series architecture it being understood that the present invention could be implemented on other computer systems.

Database contains one or more tables of which three are shown in each having a plurality of entries or records each entry containing at least one and usually many fields as is well known in the art. Database tables might contain almost any type of data which is provided to users by a computer system. Associated with the database tables are one or more auxiliary data structures also sometimes referred to as metadata. Auxiliary data structures characterize the structure of the database and data therein and are useful in various tasks involved in database management particularly in executing queries against the database. Examples of auxiliary data structures include database indexes materialized query table MQT histogram index advice record and plan cache containing saved query objects it being understood that other types of metadata may exist.

Database management system provides basic functions for the management of database . Database management system may theoretically support an arbitrary number of database tables which may or may not have related information although only three tables are shown in . Database management system preferably allows users to perform basic database operations such as defining a database altering the definition of the database creating editing and removing records in the database viewing records in the database defining database auxiliary data structures such as indexes and materialized query tables and so forth. Among the functions supported by database management system is the making of queries against data in database tables . Query support functions in database management system include query optimizer and query engine . In the preferred embodiment database management system includes a metadata interface having one or more application programming interfaces APIs by which external applications can access data in one or more auxiliary data structures and particularly can access data in query objects and in index advice record . Database management system may further contain any of various more advanced database functions. In the preferred embodiment database management system implements a structured query language SQL query protocol it being understood that a database management system might alternatively query and structure data according to some other protocol. Although database management system is represented in as an entity separate from operating system kernel it will be understood that in some computer architectures various database management functions are integrated with the operating system.

Query optimizer generates query execution strategies for performing database queries. As is known in the database art the amount of time or resource required to perform a complex query on a large database can vary greatly depending on various factors such as the availability of an index or other auxiliary data structure the amount of resources required to evaluate each condition and the expected selectivity i.e. number of records eliminated from consideration of the various logical conditions. Optimizer determines an optimal execution strategy according to any optimizing algorithm now known or hereafter developed and generates an execution strategy also known as an access plan or plan according to the determination. The execution strategy is a defined series of steps for performing the query and thus is in effect a computer program. The optimizer which generates the execution strategy performs a function analogous to that of a compiler although the execution strategy data is not necessarily executable level code. It is rather a higher level series of statements which are interpreted and executed by query engine .

A query can be saved as a persistent storage object in memory and can be written to disk or other storage. Once created by optimizer a query execution strategy can be saved with the query as part of the persistent storage object. The query can be invoked and a saved query strategy re used re executed many times. For a given query it is possible to generate and save one or optionally multiple query execution strategies each optimized for different respective conditions. E.g. where a query contains an imported host variable in one of its conditions the value of which is specified at the time the query is executed different query execution strategies could be used for different values of the imported variable. Different query execution strategies might also be used for different environmental parameters under which the query is to be executed. In addition to saving one or more query execution strategies certain metadata with respect to each query execution strategy can be saved such as the conditions for which the strategy was generated and historical data concerning the execution of the strategy.

One or more auxiliary database structures such as indexes materialized query table or histogram may be specified by a database designer administrator or similar person as part of the database definition i.e. a data structure which is part of the database and is available for use by users accessing the database. Database management system automatically maintains such defined auxiliary database structures concurrently with changes made to records in database tables . A query execution strategy will often use a defined auxiliary database structure such as indexes or MQT to execute a query. In some cases it is necessary or desirable to use such a structure where no defined structure exists. A query optimizer may optionally generate a query execution strategy which builds a temporary auxiliary data structure as an intermediate step in executing the query.

The collection of saved queries query execution strategies saved latent indexes MQT s and so forth and associated data is loosely referred to as the plan cache . represents plan cache containing persistent storage objects Query A and Query B . Although two query objects are represented for illustrative purposes in it will be understood that the actual number of such entities may vary that typically a large computer system contains a much larger number of query objects that each query object may contain or be associated with zero one or more than one execution strategies. Although these are referred to herein as query objects the use of the term object is not meant to imply that database management system or other components are necessarily programmed using so called object oriented programming techniques or that the query object necessarily has the attributes of an object in an object oriented programming environment although it would be possible to implement them using object oriented programming constructs.

Generally query optimizer constructs a query execution strategy by considering multiple possible strategies for executing the query and choosing a best one according to some evaluation criteria. The choice of a best strategy will depend on the presence of certain auxiliary data structures. In some cases the optimizer will determine that had a particular index been present it would have chosen a different more efficient strategy. In such cases the optimizer may make a record of this determination in index advice record . Index advice record can be used for analysis of the database and as a basis for determining possible indexes to be added to the database definition as described further herein.

Although one database having three database tables two indexes one MQT one histogram and one index advice record are shown in the number of such entities may vary and could be much larger. The computer system may contain multiple databases each database may contain multiple tables and each database may have associated with it multiple indexes MQTs histograms or other auxiliary data structures not illustrated. Alternatively some entities represented in might not be present in all databases for example some databases might not contain materialized query tables or the like. Additionally database may be logically part of a larger distributed database which is stored on multiple computer systems. Although database management system is represented in as part of database the database management system being executable code is sometimes considered an entity separate from the database i.e. the data.

An external index advisor analytical tool application accesses data in index advice record and plan cache to find potential indexes for addition to the database definition and to project the effect of adding indexes to the database definition. The operation of this index advisor is described in greater detail herein. In the preferred embodiment index advisor is a separate application external to database management system which accesses database auxiliary data structures using metadata interface . Index advisor could alternatively be a function or set of functions integrated into database management system .

In addition to database management system and index advisor one or more user applications not shown may access data in database tables to perform tasks on behalf of one or more users and may use defined auxiliary database structures to do so. Such user applications may execute on computer system or may access the database from remote systems. Such user applications may include e.g. personnel records accounting code development and compilation mail calendaring or any of thousands of user applications.

Various software entities are represented in as being separate entities or contained within other entities. However it will be understood that this representation is for illustrative purposes only and that particular modules or data entities could be separate entities or part of a common module or package of modules. Furthermore although a certain number and type of software entities are shown in the conceptual representation of it will be understood that the actual number of such entities may vary and in particular that in a complex database server environment the number and complexity of such entities is typically much larger. Additionally although software components and are depicted in on a single computer system for completeness of the representation it is not necessarily true that all programs functions and data will be present on a single computer system or will be performed on a single computer system. In particular index advisor may be located on a system separate from database .

While the software components of are shown conceptually as residing in memory it will be understood that in general the memory of a computer system will be too small to hold all programs and data simultaneously and that information is typically stored in data storage devices comprising one or more mass storage devices such as rotating magnetic disk drives and that the information is paged into memory by the operating system as required. In particular database tables are typically much too large to be loaded into memory and typically only a small portion of the total number of database records is loaded into memory at any one time. The full database is typically recorded in disk storage . Furthermore it will be understood that the conceptual representation of is not meant to imply any particular memory organizational model and that system might employ a single address space virtual memory or might employ multiple virtual address spaces which overlap.

Index definition portion contains fields which define the index to which the index entry corresponds. Index definition portion preferably contains a table identifier identifying a table from database tables to which the index pertains one or more column identifiers of which two are represented in identifying columns from the applicable database table which are to be used as key values for the index and may contain one or more additional index parameters .

Statistical portion contains cumulative statistical information concerning the index or queries which caused the index entry to be generated. In the preferred embodiment statistical portion includes an advice count field containing a count of the number of times a query has been executed which triggers the index advice i.e. the number of times that one or more queries for which the optimizer has determined that the corresponding index would be helpful in execution have been executed. Statistical portion may include additional fields of useful statistics such as an average or cumulative cost of running the applicable queries a maximum cost of running the queries a timestamp representing the most recent applicable query execution or other fields.

Optional additional data may include any further data which may be helpful to a user in analyzing the desirability of the subject index. For example additional data might include a cost estimate for generating the index a reason indicating why the most recently executed query recommended the index and other potentially useful data.

The form and use of an index advice record is described in U.S. patent application Ser. No. 11 239 617 filed Sep. 29 2005 entitled CONTINUAL GENERATION OF INDEX ADVICE which is herein incorporated by reference.

In the preferred embodiment index advice record does not contain data identifying individual queries which advised the index or their attributes. Preferably such information is obtained by accessing data in the query objects themselves as explained in further detail herein. However it would alternatively be possible to structure index advice record so that such data is available directly from the index advice record and that the data described below is obtained directly from the index advice record. For example the index advice record might be structured as multiple SQL tables including an SQL table containing entries corresponding to queries.

The header portion contains a query identifier field a query logical representation query historical statistics advised indexes and additional query data . The query logical representation is a representation of the query in a form understandable by the query optimizer and or query engine from which a query execution strategy can be constructed. Query historical performance statistics include historical performance data concerning previous executions of the query. Preferably historical statistics includes at least a query execution count recording the number of times the query has been executed and a cumulative cost of execution . Cost may be any appropriate measure of the resources used and or time consumed such as an interactive response time a number of CPU cycles a number of I O operations etc and could be a combination of such factors. There could be multiple cost fields representing different respective elements of the cost of a query. An average cost may be obtained by dividing the cumulative cost by the number of executions. Other historical data such as cost distributions or histograms changes in the average cost of execution over time etc. might also be maintained. Additional query data includes various other data which might be useful to database management system or other applications accessing a query. For example additional data might include a text description of the query security and access control information and so forth. Additional query data is represented in as a single block of data for clarity of illustration however such additional data will typically comprise multiple fields some of which may be optional or of variable length or may reference data in other data structures.

Advised indexes includes a record of potential indexes determined by the optimizer to be of use in executing the query. I.e. these are indexes which did not actually exist at the time the optimizer constructed its optimized strategy and which had they existed would have been useful in constructing an optimized strategy. In the preferred embodiment the indexes recorded in advised indexes include any index which the optimizer determines would have been useful had it existed no matter how marginal the utility of the index. This is a broader criterion than that used for generating entries in index advice record entries generally require that some minimum threshold of utility be met. However the advised indexes could alternatively use the same criteria as used for entries in index advice record .

Advised indexes includes a respective index definition of each applicable advised index and optionally includes an associated execution cost and or additional data . Index definition identifies by reference or defines the advised index in a manner similar to that described above with respect to index definition portion . Execution cost contains a measure of execution cost of the query assuming that the hypothetical index was available for use in executing the query. Cost may be expressed as a cost saving or delta from actual or estimated cost without the index or may be expressed in some other terms.

Each execution strategy block contains data relating to a particular execution strategy for the query. As is known in the art of database management the choice of an optimal query execution strategy could depend in numerous factors including the resources allocated to a particular user or process invoking a query the values of imported variables within the query the state of the system and so forth. Query optimizer can generate and database manager can save multiple query execution strategies for a given query each appropriate for use under a different respective set of conditions. Each execution strategy block corresponds to a respective execution strategy for the query.

In general an execution strategy block contains a strategy header portion and a body comprising strategy instructions . Among other things the strategy header preferably includes one or more conditions on the use of the strategy historical performance statistics for the corresponding execution strategy and optionally advised indexes associated with the strategy.

Conditions express any conditions on the use of the strategy i.e. define the circumstances in which a given strategy as opposed to some other strategy is to be used to execute the query. For example conditions may include values of certain imported or host variables which are associated environmental parameters or other conditions. Historical statistics may include data described above as contained in historical statistics of query object header but as applied only to that subset of query execution instances which invoked the corresponding strategy. For example an execution count and cumulative cost would include only the number of execution instances which invoked the corresponding strategy and the cumulative cost of those execution instances. Similarly advised indexes where present may contain data described above as contained in advised indexes of the query object header but as applied only to that subset of query execution instances which invoked the corresponding strategy. I.e it would include only index definitions and associated execution cost measures for indexes which were advised under conditions causing the corresponding execution strategy to be used. It will be observed that different indexes may be advised under different execution conditions so that keeping optional additional data in the strategy header enables a more accurate determination of execution instances potentially affected by the advised index.

Each strategy block further contains a respective set of strategy instructions for executing the corresponding strategy. In the preferred embodiment these are not directly executable code but are higher level instructions which are interpreted by the query engine to execute the query. These instructions determine the order of searching certain tables whether or not indexes or other auxiliary data structures are used to search the database records and so on. In particular these instructions may access indexes or other auxiliary database structures in order to execute the query.

Among the functions supported by database management system is the making of queries against data in database which are executed by query engine . As is known queries typically take the form of statements having a defined format which test records in the database to find matches to some set of logical conditions. Typically multiple terms each expressing a logical condition are connected by logical conjunctives such as AND and OR . Many queries use existing defined auxiliary database structure such as indexes materialized query tables and the like to reduce the scope of execution activity. Because database may be very large having a very large number of records and a query may be quite complex involving multiple logical conditions a suitable index or similar structure does not always exist for a given need. In some cases a temporary index which is not defined in the database is constructed solely for the purpose of executing the query but more often than not the cost of constructing such a temporary index outweighs its benefits if it is assumed that it will be used only once.

In accordance with the preferred embodiment of the present invention query optimizer considers multiple hypothetical execution strategies including strategies which may require undefined indexes indexes not present in the database definition and selects a best strategy by estimating a cost associated with each respective hypothetical strategy. In some cases a strategy requiring the construction of an undefined index would have offered the lowest execution cost but for the fact that the index does not exist and must first be constructed. A record of such occurrences is saved in the advised indexes and or of the query object and if the potential execution cost savings is sufficiently large recorded in index advice record . Index advisor analyzes the desirability of a hypothetical index by searching query objects to identify those queries which could benefit from the presence of the hypothetical index. Index advisor may optionally generate additional analytical information such as frequency of execution of the applicable queries estimates of execution cost delta to be expected from the presence of the hypothetical index and so forth. Analytical information thus derived is presented to the user who is typically a database designer administrator or similar person.

For a new query a requesting user formulates and submits a database query using any of various techniques now known or hereafter developed step . E.g. the database query might be constructed and submitted interactively using a query interface in database management system might be submitted from a separate interactive query application program or might be embedded in a user application and submitted by a call to the query engine when the user application is executed. A query might be submitted from an application executing on system or might be submitted from a remote application executing on a different computer system. In response to receiving the query the system parses the query into logical conditions to generate a query object step which may be saved for re use.

The system invokes optimizer to generate an optimized execution strategy block for the query. Optimizer determines an optimum execution strategy for the given query using any conventional technique or any technique hereafter developed and may take into account imported variable values environmental parameters or other data. In particular in at least some cases optimizer may determine that an index or other auxiliary database structure would be useful in executing the query and record that determination in a form which can be accessed later by index advisor . The process of generating an execution strategy is represented in as step and shown in greater detail in . After generation and saving of a suitable execution strategy at step the database management system proceeds to step .

Where an existing query is re used a requesting user selects the existing query object for re use and invokes it using any of various techniques now known or hereafter developed step . E.g. the query might be selected interactively from a menu in database management system might be submitted from a separate interactive application program or might be embedded in a user application and submitted by a call to the query engine when the user application is executed any of which might be performed from system or from a remote system. Re using an existing query may require specifying one or more imported variable values or other conditions of execution

In response to invoking the query query optimizer determines whether a saved strategy exists in the query object step . If no such strategy exists the N branch from step the optimizer generates one step as in the case of a new query. If a previously saved execution strategy exists for the query the Y branch from step the optimizer determines whether the saved execution strategy is suitable for use under the execution parameters of the current query instance step . This determination may be made using any appropriate technique now known or hereafter developed but in general the optimizer accesses certain data in header associated with the query execution strategy which were saved when the strategy was initially generated to determine whether the existing strategy can be re used for the current execution parameters e.g. imported variable values system configuration database configuration etc. If the saved execution strategy is not suitable for use in the current query instance then the N branch is taken from step and the database management system looks for another previously saved execution strategy step continuing then to step . The database management system continues to look for execution strategies loop at steps until a suitable strategy is found the Y branch from step or there are no more strategies the N branch from step .

If a suitable execution strategy is found the Y branch is taken from step and the execution strategy is selected step . Where multiple execution strategies are permissible multiple strategies satisfy their respective logical conditions the database manager will choose one of these multiple strategies. Such a choice could be based on priorities or any criteria or technique now known or hereafter developed or could be arbitrary. After selecting a strategy the database management system proceeds to step .

The query engine is then invoked to execute the query according to the query execution strategy which was either generated at step or selected at step step . Generally this means that the query engine retrieves selective database records according to the query execution strategy and evaluates the logical query conditions with respect to the selected record in an order determined by the strategy. E.g. for a conjunction of logical ANDs each successive condition is evaluated until a condition returns false which obviates the need to evaluate any further conditions or until all conditions are evaluated. In some cases the chosen execution strategy may require the query engine to construct an index or other auxiliary database structure for temporary use in executing the query.

The query engine then generates and returns results in an appropriate form step . E.g. where a user issues an interactive query this typically means returning a list of matching database entries for display to the user. A query from an application program may perform some other function with respect to database entries matching a query.

After execution the database management system updates certain statistical information concerning the query. In particular it updates historical statistics within the query object and where necessary updates recommended index information in index advice record . The process of updating statistical information is represented generally in as step and is shown in greater detail in .

Referring to the query optimizer generates multiple alternative paths i.e. sequences of steps for solving the query step . These may be constructed using any known technique for constructing execution steps or paths in a query or any technique hereafter developed.

Having constructed multiple alternative paths the query optimizer chooses a best path designated P according to some evaluation criterion or criteria step . In the preferred embodiment the criteria involve an evaluation of projected execution cost. The cost as used herein could be any appropriate measure of resource cost and may take into account factors such as CPU utilization storage or other I O operations response time or other measures of cost . An evaluation cost function may be constructed according to any of various conventional techniques or any technique hereafter developed.

It will be noted that some of the paths may require the use of an undefined auxiliary data structure in particular an undefined index and that in this case the cost of such a path will include the cost of building the auxiliary structure from scratch because it is assumed that such a structure is for one time use only with each query execution instance and will be deleted after the query executes . I.e. the cost of path P which uses undefined index I can be generally expressed as Cost Cost Exec Cost Build 1 where Cost Build I is the cost of building index I from scratch and Cost Exec P is the cost of executing path P using index I once it is available. Usually but not always Cost Build I is sufficiently high that path P will not be chosen as the lowest cost path.

Having chosen an optimum path P the optimizer then records potentially useful indexes shown generally as steps . The optimizer selects a path P which was previously generated step . If path P doesn t use any undefined indexes the N branch is taken from step and steps are by passed. If path P uses an undefined hypothetical index the Y branch is taken from step and a cost delta for the hypothetical index is computed step . The cost delta of a hypothetical index I represents the potential execution cost saving which could be realized if the hypothetical index were present and may be computed as the difference between the cost of path Pand the cost of execution of path P assuming that the hypothetical index I does not need to be constructed i.e. Cost Delta Cost Cost Exec 2 

If Cost Delta I does not exceed some threshold T then the N branch is taken from step and steps are by passed. If threshold T is exceeded then a record of hypothetical index I is made in advised indexes of the query object header step . I.e. an entry in the list of advised indexes is added corresponding to hypothetical index I in which index definition field contains the defining parameters of index I and cost field contains Cost Delta I or some other appropriate measure of cost. Either alternatively or additionally it would be possible to record hypothetical index I in advised indexes record in the strategy header for the strategy being constructed.

If Cost Delta I does not exceed some threshold T then the N branch is taken from step and step is by passed. If threshold T is exceeded then a record of hypothetical index I is made in index advice record if one does not already exist step . I.e. an index advice entry corresponding to the hypothetical index is added to record and initialized with initial values.

In the preferred embodiment threshold T is zero so that any hypothetical index producing a positive cost delta no matter how small will be recorded in advised indexes . Threshold T is some positive non zero value so that an entry is generated in index advice record only if the cost delta is sufficiently substantial. However a different choice of T and T values could be made and T could be equal to T.

If any more paths remain to be analyzed the Y branch is taken from step and a next path is selected at step . When all paths have thus been analyzed the N branch is taken from step . It will be observed that path Pis among those paths which will be analyzed at steps and that Pcould be a path which requires an undefined index to be generated.

The optimizer generates a set of execution strategy instructions for implementing steps of path P step these execution strategy instructions will be used by the query engine when executing the query. The set of execution strategy instructions generated at step are saved as a new strategy block in the query object along with any required header information step .

The database manager further updates index advice record as required. If there are any entries in advised indexes of the query header or alternatively in optional advised indexes of the strategy header if such a record exists then the Y branch is taken from step and a next index is selected from the advised indexes step . If the cost delta or alternatively in field associated with the selected index is exceeds threshold T then the Y branch is taken from step and the database manager updates statistical data in the index advice entry of index advice record which corresponds to the selected index. I.e. execution count is incremented by one and any additional statistical data is updated as appropriate.

The database manager thus cycles through all indexes in the advised indexes or alternatively advised index . When all indexes have been considered the N branch is taken from step . The database manager updates any statistical information which is maintained on a global or other basis step . In most large databases a substantial amount of statistical information is maintained with respect to the performance of the database as a whole use of certain database components and so forth. Such information may be complex and the details of such information are not essential to an understanding of the present invention. Updating of such information is represented generally as step .

The maintenance of certain underlying information regarding query performance and the use of indexes is described generally above with respect to . Index advisor accesses this underlying information to formulate and present index advice to a user. Certain aspects of the operation of index advisor and particularly the presentation of information contained in index advice record are described in U.S. patent application Ser. No. 11 239 617 filed Sep. 29 2005 entitled CONTINUAL GENERATION OF INDEX ADVICE herein incorporated by reference. In addition to these aspects in accordance with the preferred embodiment index advisor includes at least one function for analyzing data in query objects to identify queries which would benefit from a hypothetical index. This function of the index advisor is described below with reference to .

Referring to a hypothetical index SI is specified for analysis step . A hypothetical index could be specified in any of various ways. For example the index advisor can display a list of advised index entries from index advice record and allow a user to select an index for analysis. Alternatively the index advisor might be directed to analyze every index in the index advice record in turn and to present the results of such analysis e.g. by sorting the various indexes according to some appropriate criterion such as a projected total cost delta. As a further alternative a user might specify the characteristics of any arbitrary hypothetical index and request the index advisor to analyze the hypothetical index.

The parameters of the analysis are specified either explicitly or implicitly by default step . The parameters of the analysis govern the conditions under which indexes are to be identified and the data which is to be obtained as explained in greater detail herein.

Each query object is then selected in turn and analyzed. A next query object is selected step . If the selected query does not meet any previously specified query selection criteria the N branch is taken from step to step and another query if there is one will be selected. Query selection criteria may be optionally specified at step i.e. analysis as described herein may be performed only with respect to some subset of query objects. By default all query objects are analyzed.

The analysis may be directed solely to the properties of the query itself. For example it may be desirable to find all queries where the query itself references a certain table and field on the assumption that such a query might benefit from a particular index. In this case the N branch from step is taken steps are by passed and the query is added to the result set having previously satisfied any applicable criteria at step . If the analysis requires a consideration of advised indexes the Y branch is taken from step .

If there are any unexamined entries advised indexes in advised indexes of the header of the selected query the Y branch is taken from step to step . Alternatively at step the advised index information may be contained in advised indexes of individual execution strategy blocks which may require a scan of all strategy blocks within the query object. If there are no entries in the advised indexes or all entries have been examined the N branch it taken from step to step .

A next index I from the advised indexes or alternatively advised indexes is selected step . The selected index I is then compared with specified hypothetical index SI step . If the two are identical or sufficiently close the Y branch is taken to step otherwise the N branch is taken to step and another unexamined index I is selected if there is one. Variable criteria can be used for the comparison at step these criteria being specified earlier at step . Of course if there is an exact identity of index I and SI they will compare. But in many cases a close match is sufficient. For example if an advised index record in a query contains an index of Table A which is sorted on Col1 Col2 and Col3 in that order it is likely that the query would also benefit from a hypothetical index of Table A which is sorted on Col1 Col3 and Col2 in that order. In accordance with the preferred embodiment the index advisor may accept a close match such as this as an equivalence for purposes of determining queries which are likely to benefit from the hypothetical index. Preferably the user may specify some degree of closeness required in performing the analysis and may require a strict identity of matching indexes or may use one or more looser criteria e.g. table and primary column matches 

If the selected index I matches the hypothetical index SI under analysis the advisor considers whether any other criteria specified at step are met step . Such additional criteria are optional and it might be that no such additional criteria are specified. Additional criteria could include e.g. a minimum or threshold value of a cost delta a minimum or threshold number of execution instances of the query or query strategy as the case may be or some other criteria. If any required additional criteria are met the Y branch is taken from step and the selected query is added to a cumulative results set step otherwise the N branch is taken back to step . Adding the selected query to the result set may be as simple as adding the query to a list of queries which would benefit from the hypothetical index but it may involve more sophisticated data analysis. Specifically in one alternative a projected cost saving from using the hypothetical index for executing the added query is computed from the cost delta and frequency of execution of the query. A total projected cost saving resulting from the hypothetical index can be computed as the sum of the cost savings of individual queries. Other forms of analytical data can also or alternatively be derived and compiled.

When all advised index entries in a query record have been thus analyzed the N branch is taken from step . If any more queries remain in the plan cache the Y branch is taken from step and a next query object is selected at step . When all queries have been analyzed the N branch is taken from step . The results set and any analytical data thus derived is presented to the user step . By presenting data to the user it is meant that the data is made available to the user. Data can be presented by interactive display by printing on paper or other readable medium by placing the data in an electronic file from which it can be retrieved by transmitting the data to some other digital device etc.

Although steps are described herein as being performed by the advisor in fact in the preferred embodiment the advisor invokes search functions of database management system through metadata interface to retrieve the required data. However these steps could be implemented entirely in the advisor or the advisor functions could be integrated into database management system .

Among the advantages of the technique described herein as a preferred embodiment is that useful data which can be used to more accurately project cost savings of a hypothetical index can be obtained. Furthermore because the underlying data is normally generated anyway during the process of optimizing and executing queries it is merely necessary to save this underlying data in appropriate form for use by the advisor. Relatively little overhead is involved in saving this underlying data and very useful information regarding the effect of hypothetical indexes can be obtained as a result.

In the preferred embodiment described above the generation and execution of the query and the projected benefit of an index is described as a series of steps in a particular order. However it will be recognized by those skilled in the art that the order of performing certain steps may vary and that variations in addition to those specifically mentioned above exist in the way particular steps might be performed. In particular the manner in which queries are written parsed or compiled and stored may vary depending on the database environment and other factors.

In the preferred embodiment described above it has been assumed for purposes of clarity that all data regardless of age is equal. In fact databases typically evolve over time and their characteristics may change. Index advice data or similar data may be appropriately aged on a periodic basis so that more recent data is given greater weight in any analysis than older data. Various techniques for aging data are known in the art.

In the preferred embodiment described above analysis is performed for the purpose of identifying hypothetical indexes which might be useful. It would alternatively be possible to perform similar analysis for the purpose of identifying existing defined database indexes which are not sufficiently useful to justify their maintenance cost and to recommend removal of such indexes from the database definition.

In general the routines executed to implement the illustrated embodiments of the invention whether implemented as part of an operating system or a specific application program object module or sequence of instructions are referred to herein as programs or computer programs . The programs typically comprise instructions which when read and executed by one or more processors in the devices or systems in a computer system consistent with the invention cause those devices or systems to perform the steps necessary to execute steps or generate elements embodying the various aspects of the present invention. Moreover while the invention has and hereinafter will be described in the context of fully functioning computer systems the various embodiments of the invention are capable of being distributed as a program product in a variety of forms and the invention applies equally regardless of the particular type of computer readable data storage media used to actually carry out the distribution. Examples of computer readable data storage media include but are not limited to volatile and non volatile memory devices floppy disks hard disk drives CD ROM s DVD s magnetic tape and so forth. Furthermore the invention applies to any form of signal bearing media regardless of whether data is exchanged from one form of signal bearing media to another over a transmission network including a wireless network. Examples of computer readable data storage media are illustrated in as system memory and as data storage devices .

Although a specific embodiment of the invention has been disclosed along with certain alternatives it will be recognized by those skilled in the art that additional variations in form and detail may be made within the scope of the following claims 

